
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,v6,41/62] selftest/x86: Move protecton key selftest to arch neutral directory - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,v6,41/62] selftest/x86: Move protecton key selftest to arch neutral directory</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=2448">Ram Pai</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 16, 2017, 3:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1500177424-13695-42-git-send-email-linuxram@us.ibm.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9842687/mbox/"
   >mbox</a>
|
   <a href="/patch/9842687/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9842687/">/patch/9842687/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	999C260393 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Jul 2017 04:05:37 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7ED3F2857B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Jul 2017 04:05:37 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7189C2859E; Sun, 16 Jul 2017 04:05:37 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1B08E2857D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Jul 2017 04:05:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752412AbdGPD7v (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 15 Jul 2017 23:59:51 -0400
Received: from mail-qk0-f194.google.com ([209.85.220.194]:36259 &quot;EHLO
	mail-qk0-f194.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752365AbdGPD7p (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 15 Jul 2017 23:59:45 -0400
Received: by mail-qk0-f194.google.com with SMTP id v17so14725113qka.3;
	Sat, 15 Jul 2017 20:59:44 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=L4YOzQ2/sa1G35Tw1wlHvhq9GKNrNzC+V9nPR3ygJ6o=;
	b=dhB+dCDiBo+M2RAX1CHjB7r7N/47IGYYfCnIT/5waZGDbjgmGJA97mTS2rzVVgSCvO
	ra8pSqdRbJGCDfzJCib7MtAspfdtN3PgiFsE78qtabybBluMS6Lsd543voqlg+MWbuwQ
	4aB0Eju3bzYXEx3QqIKQpzo8P+LrPIWAkpImtlAlnpGu/XLTrO9SgIT6O/TOLBpCmjfj
	4WiERlmaR+3KtInPLNtpxwHNunDQH71opF52UTIA9EvXv3DX9S8Sw/6Op1TUZnh35WBj
	QFF22w3FILDUnTKvKyDjXe6ZDPwLNM2IGVUZzZ1LKH66U2s/x6T63Si90Gh5c5BtiV41
	z/lQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:from:to:cc:subject:date:message-id
	:in-reply-to:references;
	bh=L4YOzQ2/sa1G35Tw1wlHvhq9GKNrNzC+V9nPR3ygJ6o=;
	b=S8YELAy9jid/fpfaDxvut4XlPb5/FXXNA7cAwtS4jnGIM+aAUzc9+LjnmfKh5QSyE9
	GSwJTSIeqQEwZbibc7gkJu1xlm68yFdYhNC3NpBqRj09JmZMnUlIQAafMvjkiP/GoaP/
	B4biMHloiYg+ULjp9dp2dRog3wfU4QLWN3d2L5GQxnvgVPlQDEaIyAhThIDbVWRudplL
	L8lLO4pJaYxMK5eP94aOyKpb6UjBDy8yBy5+puNswOvqUoAMtKiAiLhJ0yMURLvIdgTo
	Oa/yFiNPF7KELhXHMD8EPKhkyd8jE+B4bfsb9G1vocR1Jdr/gyyxVQjEn63VTqqkrj48
	w32g==
X-Gm-Message-State: AIVw110fQZ1D8uxGmTpIb6jNQasLM+yIeZoQJiQpmV/QrwOOI2r1Y8Uv
	68fIUY+j9xsouQ==
X-Received: by 10.55.192.148 with SMTP id v20mr21017746qkv.263.1500177582938;
	Sat, 15 Jul 2017 20:59:42 -0700 (PDT)
Received: from localhost.localdomain (50-39-103-96.bvtn.or.frontiernet.net.
	[50.39.103.96]) by smtp.gmail.com with ESMTPSA id
	q46sm2290345qtc.54.2017.07.15.20.59.40
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Sat, 15 Jul 2017 20:59:42 -0700 (PDT)
From: Ram Pai &lt;linuxram@us.ibm.com&gt;
To: linuxppc-dev@lists.ozlabs.org, linux-kernel@vger.kernel.org,
	linux-arch@vger.kernel.org, linux-mm@kvack.org, x86@kernel.org,
	linux-doc@vger.kernel.org, linux-kselftest@vger.kernel.org
Cc: benh@kernel.crashing.org, paulus@samba.org, mpe@ellerman.id.au,
	khandual@linux.vnet.ibm.com, aneesh.kumar@linux.vnet.ibm.com,
	bsingharora@gmail.com, dave.hansen@intel.com, hbabu@us.ibm.com,
	linuxram@us.ibm.com, arnd@arndb.de, akpm@linux-foundation.org,
	corbet@lwn.net, mingo@redhat.com, mhocko@kernel.org
Subject: [RFC v6 41/62] selftest/x86: Move protecton key selftest to arch
	neutral directory
Date: Sat, 15 Jul 2017 20:56:43 -0700
Message-Id: &lt;1500177424-13695-42-git-send-email-linuxram@us.ibm.com&gt;
X-Mailer: git-send-email 1.7.1
In-Reply-To: &lt;1500177424-13695-1-git-send-email-linuxram@us.ibm.com&gt;
References: &lt;1500177424-13695-1-git-send-email-linuxram@us.ibm.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2448">Ram Pai</a> - July 16, 2017, 3:56 a.m.</div>
<pre class="content">
<span class="signed-off-by">Signed-off-by: Ram Pai &lt;linuxram@us.ibm.com&gt;</span>
---
 tools/testing/selftests/vm/Makefile           |    1 +
 tools/testing/selftests/vm/pkey-helpers.h     |  219 ++++
 tools/testing/selftests/vm/protection_keys.c  | 1395 +++++++++++++++++++++++++
 tools/testing/selftests/x86/Makefile          |    2 +-
 tools/testing/selftests/x86/pkey-helpers.h    |  219 ----
 tools/testing/selftests/x86/protection_keys.c | 1395 -------------------------
 6 files changed, 1616 insertions(+), 1615 deletions(-)
 create mode 100644 tools/testing/selftests/vm/pkey-helpers.h
 create mode 100644 tools/testing/selftests/vm/protection_keys.c
 delete mode 100644 tools/testing/selftests/x86/pkey-helpers.h
 delete mode 100644 tools/testing/selftests/x86/protection_keys.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/tools/testing/selftests/vm/Makefile b/tools/testing/selftests/vm/Makefile</span>
<span class="p_header">index cbb29e4..1d32f78 100644</span>
<span class="p_header">--- a/tools/testing/selftests/vm/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/vm/Makefile</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"> TEST_GEN_FILES += transhuge-stress</span>
 TEST_GEN_FILES += userfaultfd
 TEST_GEN_FILES += mlock-random-test
 TEST_GEN_FILES += virtual_address_range
<span class="p_add">+TEST_GEN_FILES += protection_keys</span>
 
 TEST_PROGS := run_vmtests
 
<span class="p_header">diff --git a/tools/testing/selftests/vm/pkey-helpers.h b/tools/testing/selftests/vm/pkey-helpers.h</span>
new file mode 100644
<span class="p_header">index 0000000..b202939</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/testing/selftests/vm/pkey-helpers.h</span>
<span class="p_chunk">@@ -0,0 +1,219 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _PKEYS_HELPER_H</span>
<span class="p_add">+#define _PKEYS_HELPER_H</span>
<span class="p_add">+#define _GNU_SOURCE</span>
<span class="p_add">+#include &lt;string.h&gt;</span>
<span class="p_add">+#include &lt;stdarg.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdint.h&gt;</span>
<span class="p_add">+#include &lt;stdbool.h&gt;</span>
<span class="p_add">+#include &lt;signal.h&gt;</span>
<span class="p_add">+#include &lt;assert.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;ucontext.h&gt;</span>
<span class="p_add">+#include &lt;sys/mman.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define NR_PKEYS 16</span>
<span class="p_add">+#define PKRU_BITS_PER_PKEY 2</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef DEBUG_LEVEL</span>
<span class="p_add">+#define DEBUG_LEVEL 0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#define DPRINT_IN_SIGNAL_BUF_SIZE 4096</span>
<span class="p_add">+extern int dprint_in_signal;</span>
<span class="p_add">+extern char dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];</span>
<span class="p_add">+static inline void sigsafe_printf(const char *format, ...)</span>
<span class="p_add">+{</span>
<span class="p_add">+	va_list ap;</span>
<span class="p_add">+</span>
<span class="p_add">+	va_start(ap, format);</span>
<span class="p_add">+	if (!dprint_in_signal) {</span>
<span class="p_add">+		vprintf(format, ap);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		int len = vsnprintf(dprint_in_signal_buffer,</span>
<span class="p_add">+				    DPRINT_IN_SIGNAL_BUF_SIZE,</span>
<span class="p_add">+				    format, ap);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * len is amount that would have been printed,</span>
<span class="p_add">+		 * but actual write is truncated at BUF_SIZE.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (len &gt; DPRINT_IN_SIGNAL_BUF_SIZE)</span>
<span class="p_add">+			len = DPRINT_IN_SIGNAL_BUF_SIZE;</span>
<span class="p_add">+		write(1, dprint_in_signal_buffer, len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	va_end(ap);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define dprintf_level(level, args...) do {	\</span>
<span class="p_add">+	if (level &lt;= DEBUG_LEVEL)		\</span>
<span class="p_add">+		sigsafe_printf(args);		\</span>
<span class="p_add">+	fflush(NULL);				\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#define dprintf0(args...) dprintf_level(0, args)</span>
<span class="p_add">+#define dprintf1(args...) dprintf_level(1, args)</span>
<span class="p_add">+#define dprintf2(args...) dprintf_level(2, args)</span>
<span class="p_add">+#define dprintf3(args...) dprintf_level(3, args)</span>
<span class="p_add">+#define dprintf4(args...) dprintf_level(4, args)</span>
<span class="p_add">+</span>
<span class="p_add">+extern unsigned int shadow_pkru;</span>
<span class="p_add">+static inline unsigned int __rdpkru(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int eax, edx;</span>
<span class="p_add">+	unsigned int ecx = 0;</span>
<span class="p_add">+	unsigned int pkru;</span>
<span class="p_add">+</span>
<span class="p_add">+	asm volatile(&quot;.byte 0x0f,0x01,0xee\n\t&quot;</span>
<span class="p_add">+		     : &quot;=a&quot; (eax), &quot;=d&quot; (edx)</span>
<span class="p_add">+		     : &quot;c&quot; (ecx));</span>
<span class="p_add">+	pkru = eax;</span>
<span class="p_add">+	return pkru;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned int _rdpkru(int line)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pkru = __rdpkru();</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf4(&quot;rdpkru(line=%d) pkru: %x shadow: %x\n&quot;,</span>
<span class="p_add">+			line, pkru, shadow_pkru);</span>
<span class="p_add">+	assert(pkru == shadow_pkru);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pkru;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define rdpkru() _rdpkru(__LINE__)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __wrpkru(unsigned int pkru)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int eax = pkru;</span>
<span class="p_add">+	unsigned int ecx = 0;</span>
<span class="p_add">+	unsigned int edx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf4(&quot;%s() changing %08x to %08x\n&quot;, __func__, __rdpkru(), pkru);</span>
<span class="p_add">+	asm volatile(&quot;.byte 0x0f,0x01,0xef\n\t&quot;</span>
<span class="p_add">+		     : : &quot;a&quot; (eax), &quot;c&quot; (ecx), &quot;d&quot; (edx));</span>
<span class="p_add">+	assert(pkru == __rdpkru());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void wrpkru(unsigned int pkru)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprintf4(&quot;%s() changing %08x to %08x\n&quot;, __func__, __rdpkru(), pkru);</span>
<span class="p_add">+	/* will do the shadow check for us: */</span>
<span class="p_add">+	rdpkru();</span>
<span class="p_add">+	__wrpkru(pkru);</span>
<span class="p_add">+	shadow_pkru = pkru;</span>
<span class="p_add">+	dprintf4(&quot;%s(%08x) pkru: %08x\n&quot;, __func__, pkru, __rdpkru());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * These are technically racy. since something could</span>
<span class="p_add">+ * change PKRU between the read and the write.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void __pkey_access_allow(int pkey, int do_allow)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pkru = rdpkru();</span>
<span class="p_add">+	int bit = pkey * 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (do_allow)</span>
<span class="p_add">+		pkru &amp;= (1&lt;&lt;bit);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pkru |= (1&lt;&lt;bit);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf4(&quot;pkru now: %08x\n&quot;, rdpkru());</span>
<span class="p_add">+	wrpkru(pkru);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __pkey_write_allow(int pkey, int do_allow_write)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long pkru = rdpkru();</span>
<span class="p_add">+	int bit = pkey * 2 + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (do_allow_write)</span>
<span class="p_add">+		pkru &amp;= (1&lt;&lt;bit);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pkru |= (1&lt;&lt;bit);</span>
<span class="p_add">+</span>
<span class="p_add">+	wrpkru(pkru);</span>
<span class="p_add">+	dprintf4(&quot;pkru now: %08x\n&quot;, rdpkru());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define PROT_PKEY0     0x10            /* protection key value (bit 0) */</span>
<span class="p_add">+#define PROT_PKEY1     0x20            /* protection key value (bit 1) */</span>
<span class="p_add">+#define PROT_PKEY2     0x40            /* protection key value (bit 2) */</span>
<span class="p_add">+#define PROT_PKEY3     0x80            /* protection key value (bit 3) */</span>
<span class="p_add">+</span>
<span class="p_add">+#define PAGE_SIZE 4096</span>
<span class="p_add">+#define MB	(1&lt;&lt;20)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __cpuid(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_add">+		unsigned int *ecx, unsigned int *edx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* ecx is often an input as well as an output. */</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+		&quot;cpuid;&quot;</span>
<span class="p_add">+		: &quot;=a&quot; (*eax),</span>
<span class="p_add">+		  &quot;=b&quot; (*ebx),</span>
<span class="p_add">+		  &quot;=c&quot; (*ecx),</span>
<span class="p_add">+		  &quot;=d&quot; (*edx)</span>
<span class="p_add">+		: &quot;0&quot; (*eax), &quot;2&quot; (*ecx));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Intel-defined CPU features, CPUID level 0x00000007:0 (ecx) */</span>
<span class="p_add">+#define X86_FEATURE_PKU        (1&lt;&lt;3) /* Protection Keys for Userspace */</span>
<span class="p_add">+#define X86_FEATURE_OSPKE      (1&lt;&lt;4) /* OS Protection Keys Enable */</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int cpu_has_pku(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int eax;</span>
<span class="p_add">+	unsigned int ebx;</span>
<span class="p_add">+	unsigned int ecx;</span>
<span class="p_add">+	unsigned int edx;</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = 0x7;</span>
<span class="p_add">+	ecx = 0x0;</span>
<span class="p_add">+	__cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(ecx &amp; X86_FEATURE_PKU)) {</span>
<span class="p_add">+		dprintf2(&quot;cpu does not have PKU\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!(ecx &amp; X86_FEATURE_OSPKE)) {</span>
<span class="p_add">+		dprintf2(&quot;cpu does not have OSPKE\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define XSTATE_PKRU_BIT	(9)</span>
<span class="p_add">+#define XSTATE_PKRU	0x200</span>
<span class="p_add">+</span>
<span class="p_add">+int pkru_xstate_offset(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int eax;</span>
<span class="p_add">+	unsigned int ebx;</span>
<span class="p_add">+	unsigned int ecx;</span>
<span class="p_add">+	unsigned int edx;</span>
<span class="p_add">+	int xstate_offset;</span>
<span class="p_add">+	int xstate_size;</span>
<span class="p_add">+	unsigned long XSTATE_CPUID = 0xd;</span>
<span class="p_add">+	int leaf;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* assume that XSTATE_PKRU is set in XCR0 */</span>
<span class="p_add">+	leaf = XSTATE_PKRU_BIT;</span>
<span class="p_add">+	{</span>
<span class="p_add">+		eax = XSTATE_CPUID;</span>
<span class="p_add">+		ecx = leaf;</span>
<span class="p_add">+		__cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (leaf == XSTATE_PKRU_BIT) {</span>
<span class="p_add">+			xstate_offset = ebx;</span>
<span class="p_add">+			xstate_size = eax;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xstate_size == 0) {</span>
<span class="p_add">+		printf(&quot;could not find size/offset of PKRU in xsave state\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return xstate_offset;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _PKEYS_HELPER_H */</span>
<span class="p_header">diff --git a/tools/testing/selftests/vm/protection_keys.c b/tools/testing/selftests/vm/protection_keys.c</span>
new file mode 100644
<span class="p_header">index 0000000..3237bc0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/testing/selftests/vm/protection_keys.c</span>
<span class="p_chunk">@@ -0,0 +1,1395 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Tests x86 Memory Protection Keys (see Documentation/x86/protection-keys.txt)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * There are examples in here of:</span>
<span class="p_add">+ *  * how to set protection keys on memory</span>
<span class="p_add">+ *  * how to set/clear bits in PKRU (the rights register)</span>
<span class="p_add">+ *  * how to handle SEGV_PKRU signals and extract pkey-relevant</span>
<span class="p_add">+ *    information from the siginfo</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Things to add:</span>
<span class="p_add">+ *	make sure KSM and KSM COW breaking works</span>
<span class="p_add">+ *	prefault pages in at malloc, or not</span>
<span class="p_add">+ *	protect MPX bounds tables with protection keys?</span>
<span class="p_add">+ *	make sure VMA splitting/merging is working correctly</span>
<span class="p_add">+ *	OOMs can destroy mm-&gt;mmap (see exit_mmap()), so make sure it is immune to pkeys</span>
<span class="p_add">+ *	look for pkey &quot;leaks&quot; where it is still set on a VMA but &quot;freed&quot; back to the kernel</span>
<span class="p_add">+ *	do a plain mprotect() to a mprotect_pkey() area and make sure the pkey sticks</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Compile like this:</span>
<span class="p_add">+ *	gcc      -o protection_keys    -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm</span>
<span class="p_add">+ *	gcc -m32 -o protection_keys_32 -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define _GNU_SOURCE</span>
<span class="p_add">+#include &lt;errno.h&gt;</span>
<span class="p_add">+#include &lt;linux/futex.h&gt;</span>
<span class="p_add">+#include &lt;sys/time.h&gt;</span>
<span class="p_add">+#include &lt;sys/syscall.h&gt;</span>
<span class="p_add">+#include &lt;string.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdint.h&gt;</span>
<span class="p_add">+#include &lt;stdbool.h&gt;</span>
<span class="p_add">+#include &lt;signal.h&gt;</span>
<span class="p_add">+#include &lt;assert.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;ucontext.h&gt;</span>
<span class="p_add">+#include &lt;sys/mman.h&gt;</span>
<span class="p_add">+#include &lt;sys/types.h&gt;</span>
<span class="p_add">+#include &lt;sys/wait.h&gt;</span>
<span class="p_add">+#include &lt;sys/stat.h&gt;</span>
<span class="p_add">+#include &lt;fcntl.h&gt;</span>
<span class="p_add">+#include &lt;unistd.h&gt;</span>
<span class="p_add">+#include &lt;sys/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;setjmp.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;pkey-helpers.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+int iteration_nr = 1;</span>
<span class="p_add">+int test_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned int shadow_pkru;</span>
<span class="p_add">+</span>
<span class="p_add">+#define HPAGE_SIZE	(1UL&lt;&lt;21)</span>
<span class="p_add">+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))</span>
<span class="p_add">+#define ALIGN_UP(x, align_to)	(((x) + ((align_to)-1)) &amp; ~((align_to)-1))</span>
<span class="p_add">+#define ALIGN_DOWN(x, align_to) ((x) &amp; ~((align_to)-1))</span>
<span class="p_add">+#define ALIGN_PTR_UP(p, ptr_align_to)	((typeof(p))ALIGN_UP((unsigned long)(p),	ptr_align_to))</span>
<span class="p_add">+#define ALIGN_PTR_DOWN(p, ptr_align_to)	((typeof(p))ALIGN_DOWN((unsigned long)(p),	ptr_align_to))</span>
<span class="p_add">+#define __stringify_1(x...)     #x</span>
<span class="p_add">+#define __stringify(x...)       __stringify_1(x)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTR_ERR_ENOTSUP ((void *)-ENOTSUP)</span>
<span class="p_add">+</span>
<span class="p_add">+int dprint_in_signal;</span>
<span class="p_add">+char dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+extern void abort_hooks(void);</span>
<span class="p_add">+#define pkey_assert(condition) do {		\</span>
<span class="p_add">+	if (!(condition)) {			\</span>
<span class="p_add">+		dprintf0(&quot;assert() at %s::%d test_nr: %d iteration: %d\n&quot;, \</span>
<span class="p_add">+				__FILE__, __LINE__,	\</span>
<span class="p_add">+				test_nr, iteration_nr);	\</span>
<span class="p_add">+		dprintf0(&quot;errno at assert: %d&quot;, errno);	\</span>
<span class="p_add">+		abort_hooks();			\</span>
<span class="p_add">+		assert(condition);		\</span>
<span class="p_add">+	}					\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#define raw_assert(cond) assert(cond)</span>
<span class="p_add">+</span>
<span class="p_add">+void cat_into_file(char *str, char *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int fd = open(file, O_RDWR);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf2(&quot;%s(): writing &#39;%s&#39; to &#39;%s&#39;\n&quot;, __func__, str, file);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * these need to be raw because they are called under</span>
<span class="p_add">+	 * pkey_assert()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	raw_assert(fd &gt;= 0);</span>
<span class="p_add">+	ret = write(fd, str, strlen(str));</span>
<span class="p_add">+	if (ret != strlen(str)) {</span>
<span class="p_add">+		perror(&quot;write to file failed&quot;);</span>
<span class="p_add">+		fprintf(stderr, &quot;filename: &#39;%s&#39; str: &#39;%s&#39;\n&quot;, file, str);</span>
<span class="p_add">+		raw_assert(0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	close(fd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#if CONTROL_TRACING &gt; 0</span>
<span class="p_add">+static int warned_tracing;</span>
<span class="p_add">+int tracing_root_ok(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (geteuid() != 0) {</span>
<span class="p_add">+		if (!warned_tracing)</span>
<span class="p_add">+			fprintf(stderr, &quot;WARNING: not run as root, &quot;</span>
<span class="p_add">+					&quot;can not do tracing control\n&quot;);</span>
<span class="p_add">+		warned_tracing = 1;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+void tracing_on(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if CONTROL_TRACING &gt; 0</span>
<span class="p_add">+#define TRACEDIR &quot;/sys/kernel/debug/tracing&quot;</span>
<span class="p_add">+	char pidstr[32];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tracing_root_ok())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	sprintf(pidstr, &quot;%d&quot;, getpid());</span>
<span class="p_add">+	cat_into_file(&quot;0&quot;, TRACEDIR &quot;/tracing_on&quot;);</span>
<span class="p_add">+	cat_into_file(&quot;\n&quot;, TRACEDIR &quot;/trace&quot;);</span>
<span class="p_add">+	if (1) {</span>
<span class="p_add">+		cat_into_file(&quot;function_graph&quot;, TRACEDIR &quot;/current_tracer&quot;);</span>
<span class="p_add">+		cat_into_file(&quot;1&quot;, TRACEDIR &quot;/options/funcgraph-proc&quot;);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		cat_into_file(&quot;nop&quot;, TRACEDIR &quot;/current_tracer&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cat_into_file(pidstr, TRACEDIR &quot;/set_ftrace_pid&quot;);</span>
<span class="p_add">+	cat_into_file(&quot;1&quot;, TRACEDIR &quot;/tracing_on&quot;);</span>
<span class="p_add">+	dprintf1(&quot;enabled tracing\n&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void tracing_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if CONTROL_TRACING &gt; 0</span>
<span class="p_add">+	if (!tracing_root_ok())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	cat_into_file(&quot;0&quot;, &quot;/sys/kernel/debug/tracing/tracing_on&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void abort_hooks(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	fprintf(stderr, &quot;running %s()...\n&quot;, __func__);</span>
<span class="p_add">+	tracing_off();</span>
<span class="p_add">+#ifdef SLEEP_ON_ABORT</span>
<span class="p_add">+	sleep(SLEEP_ON_ABORT);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __page_o_noops(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* 8-bytes of instruction * 512 bytes = 1 page */</span>
<span class="p_add">+	asm(&quot;.rept 512 ; nopl 0x7eeeeeee(%eax) ; .endr&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This attempts to have roughly a page of instructions followed by a few</span>
<span class="p_add">+ * instructions that do a write, and another page of instructions.  That</span>
<span class="p_add">+ * way, we are pretty sure that the write is in the second page of</span>
<span class="p_add">+ * instructions and has at least a page of padding behind it.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * *That* lets us be sure to madvise() away the write instruction, which</span>
<span class="p_add">+ * will then fault, which makes sure that the fault code handles</span>
<span class="p_add">+ * execute-only memory properly.</span>
<span class="p_add">+ */</span>
<span class="p_add">+__attribute__((__aligned__(PAGE_SIZE)))</span>
<span class="p_add">+void lots_o_noops_around_write(int *write_to_me)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprintf3(&quot;running %s()\n&quot;, __func__);</span>
<span class="p_add">+	__page_o_noops();</span>
<span class="p_add">+	/* Assume this happens in the second page of instructions: */</span>
<span class="p_add">+	*write_to_me = __LINE__;</span>
<span class="p_add">+	/* pad out by another page: */</span>
<span class="p_add">+	__page_o_noops();</span>
<span class="p_add">+	dprintf3(&quot;%s() done\n&quot;, __func__);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Define some kernel-like types */</span>
<span class="p_add">+#define  u8 uint8_t</span>
<span class="p_add">+#define u16 uint16_t</span>
<span class="p_add">+#define u32 uint32_t</span>
<span class="p_add">+#define u64 uint64_t</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __i386__</span>
<span class="p_add">+#define SYS_mprotect_key 380</span>
<span class="p_add">+#define SYS_pkey_alloc	 381</span>
<span class="p_add">+#define SYS_pkey_free	 382</span>
<span class="p_add">+#define REG_IP_IDX REG_EIP</span>
<span class="p_add">+#define si_pkey_offset 0x14</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define SYS_mprotect_key 329</span>
<span class="p_add">+#define SYS_pkey_alloc	 330</span>
<span class="p_add">+#define SYS_pkey_free	 331</span>
<span class="p_add">+#define REG_IP_IDX REG_RIP</span>
<span class="p_add">+#define si_pkey_offset 0x20</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+void dump_mem(void *dumpme, int len_bytes)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *c = (void *)dumpme;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; len_bytes; i += sizeof(u64)) {</span>
<span class="p_add">+		u64 *ptr = (u64 *)(c + i);</span>
<span class="p_add">+		dprintf1(&quot;dump[%03d][@%p]: %016jx\n&quot;, i, ptr, *ptr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define __SI_FAULT      (3 &lt;&lt; 16)</span>
<span class="p_add">+#define SEGV_BNDERR     (__SI_FAULT|3)  /* failed address bound checks */</span>
<span class="p_add">+#define SEGV_PKUERR     (__SI_FAULT|4)</span>
<span class="p_add">+</span>
<span class="p_add">+static char *si_code_str(int si_code)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (si_code &amp; SEGV_MAPERR)</span>
<span class="p_add">+		return &quot;SEGV_MAPERR&quot;;</span>
<span class="p_add">+	if (si_code &amp; SEGV_ACCERR)</span>
<span class="p_add">+		return &quot;SEGV_ACCERR&quot;;</span>
<span class="p_add">+	if (si_code &amp; SEGV_BNDERR)</span>
<span class="p_add">+		return &quot;SEGV_BNDERR&quot;;</span>
<span class="p_add">+	if (si_code &amp; SEGV_PKUERR)</span>
<span class="p_add">+		return &quot;SEGV_PKUERR&quot;;</span>
<span class="p_add">+	return &quot;UNKNOWN&quot;;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int pkru_faults;</span>
<span class="p_add">+int last_si_pkey = -1;</span>
<span class="p_add">+void signal_handler(int signum, siginfo_t *si, void *vucontext)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ucontext_t *uctxt = vucontext;</span>
<span class="p_add">+	int trapno;</span>
<span class="p_add">+	unsigned long ip;</span>
<span class="p_add">+	char *fpregs;</span>
<span class="p_add">+	u32 *pkru_ptr;</span>
<span class="p_add">+	u64 si_pkey;</span>
<span class="p_add">+	u32 *si_pkey_ptr;</span>
<span class="p_add">+	int pkru_offset;</span>
<span class="p_add">+	fpregset_t fpregset;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprint_in_signal = 1;</span>
<span class="p_add">+	dprintf1(&quot;&gt;&gt;&gt;&gt;===============SIGSEGV============================\n&quot;);</span>
<span class="p_add">+	dprintf1(&quot;%s()::%d, pkru: 0x%x shadow: %x\n&quot;, __func__, __LINE__,</span>
<span class="p_add">+			__rdpkru(), shadow_pkru);</span>
<span class="p_add">+</span>
<span class="p_add">+	trapno = uctxt-&gt;uc_mcontext.gregs[REG_TRAPNO];</span>
<span class="p_add">+	ip = uctxt-&gt;uc_mcontext.gregs[REG_IP_IDX];</span>
<span class="p_add">+	fpregset = uctxt-&gt;uc_mcontext.fpregs;</span>
<span class="p_add">+	fpregs = (void *)fpregset;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf2(&quot;%s() trapno: %d ip: 0x%lx info-&gt;si_code: %s/%d\n&quot;, __func__,</span>
<span class="p_add">+			trapno, ip, si_code_str(si-&gt;si_code), si-&gt;si_code);</span>
<span class="p_add">+#ifdef __i386__</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 32-bit has some extra padding so that userspace can tell whether</span>
<span class="p_add">+	 * the XSTATE header is present in addition to the &quot;legacy&quot; FPU</span>
<span class="p_add">+	 * state.  We just assume that it is here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fpregs += 0x70;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	pkru_offset = pkru_xstate_offset();</span>
<span class="p_add">+	pkru_ptr = (void *)(&amp;fpregs[pkru_offset]);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;siginfo: %p\n&quot;, si);</span>
<span class="p_add">+	dprintf1(&quot; fpregs: %p\n&quot;, fpregs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we got a PKRU fault, we *HAVE* to have at least one bit set in</span>
<span class="p_add">+	 * here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dprintf1(&quot;pkru_xstate_offset: %d\n&quot;, pkru_xstate_offset());</span>
<span class="p_add">+	if (DEBUG_LEVEL &gt; 4)</span>
<span class="p_add">+		dump_mem(pkru_ptr - 128, 256);</span>
<span class="p_add">+	pkey_assert(*pkru_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	si_pkey_ptr = (u32 *)(((u8 *)si) + si_pkey_offset);</span>
<span class="p_add">+	dprintf1(&quot;si_pkey_ptr: %p\n&quot;, si_pkey_ptr);</span>
<span class="p_add">+	dump_mem(si_pkey_ptr - 8, 24);</span>
<span class="p_add">+	si_pkey = *si_pkey_ptr;</span>
<span class="p_add">+	pkey_assert(si_pkey &lt; NR_PKEYS);</span>
<span class="p_add">+	last_si_pkey = si_pkey;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((si-&gt;si_code == SEGV_MAPERR) ||</span>
<span class="p_add">+	    (si-&gt;si_code == SEGV_ACCERR) ||</span>
<span class="p_add">+	    (si-&gt;si_code == SEGV_BNDERR)) {</span>
<span class="p_add">+		printf(&quot;non-PK si_code, exiting...\n&quot;);</span>
<span class="p_add">+		exit(4);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;signal pkru from xsave: %08x\n&quot;, *pkru_ptr);</span>
<span class="p_add">+	/* need __rdpkru() version so we do not do shadow_pkru checking */</span>
<span class="p_add">+	dprintf1(&quot;signal pkru from  pkru: %08x\n&quot;, __rdpkru());</span>
<span class="p_add">+	dprintf1(&quot;si_pkey from siginfo: %jx\n&quot;, si_pkey);</span>
<span class="p_add">+	*(u64 *)pkru_ptr = 0x00000000;</span>
<span class="p_add">+	dprintf1(&quot;WARNING: set PRKU=0 to allow faulting instruction to continue\n&quot;);</span>
<span class="p_add">+	pkru_faults++;</span>
<span class="p_add">+	dprintf1(&quot;&lt;&lt;&lt;&lt;==================================================\n&quot;);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+	if (trapno == 14) {</span>
<span class="p_add">+		fprintf(stderr,</span>
<span class="p_add">+			&quot;ERROR: In signal handler, page fault, trapno = %d, ip = %016lx\n&quot;,</span>
<span class="p_add">+			trapno, ip);</span>
<span class="p_add">+		fprintf(stderr, &quot;si_addr %p\n&quot;, si-&gt;si_addr);</span>
<span class="p_add">+		fprintf(stderr, &quot;REG_ERR: %lx\n&quot;,</span>
<span class="p_add">+				(unsigned long)uctxt-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		fprintf(stderr, &quot;unexpected trap %d! at 0x%lx\n&quot;, trapno, ip);</span>
<span class="p_add">+		fprintf(stderr, &quot;si_addr %p\n&quot;, si-&gt;si_addr);</span>
<span class="p_add">+		fprintf(stderr, &quot;REG_ERR: %lx\n&quot;,</span>
<span class="p_add">+				(unsigned long)uctxt-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="p_add">+		exit(2);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dprint_in_signal = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int wait_all_children(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	return waitpid(-1, &amp;status, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void sig_chld(int x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprint_in_signal = 1;</span>
<span class="p_add">+	dprintf2(&quot;[%d] SIGCHLD: %d\n&quot;, getpid(), x);</span>
<span class="p_add">+	dprint_in_signal = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void setup_sigsegv_handler(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r, rs;</span>
<span class="p_add">+	struct sigaction newact;</span>
<span class="p_add">+	struct sigaction oldact;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* #PF is mapped to sigsegv */</span>
<span class="p_add">+	int signum  = SIGSEGV;</span>
<span class="p_add">+</span>
<span class="p_add">+	newact.sa_handler = 0;</span>
<span class="p_add">+	newact.sa_sigaction = signal_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*sigset_t - signals to block while in the handler */</span>
<span class="p_add">+	/* get the old signal mask. */</span>
<span class="p_add">+	rs = sigprocmask(SIG_SETMASK, 0, &amp;newact.sa_mask);</span>
<span class="p_add">+	pkey_assert(rs == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* call sa_sigaction, not sa_handler*/</span>
<span class="p_add">+	newact.sa_flags = SA_SIGINFO;</span>
<span class="p_add">+</span>
<span class="p_add">+	newact.sa_restorer = 0;  /* void(*)(), obsolete */</span>
<span class="p_add">+	r = sigaction(signum, &amp;newact, &amp;oldact);</span>
<span class="p_add">+	r = sigaction(SIGALRM, &amp;newact, &amp;oldact);</span>
<span class="p_add">+	pkey_assert(r == 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void setup_handlers(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	signal(SIGCHLD, &amp;sig_chld);</span>
<span class="p_add">+	setup_sigsegv_handler();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pid_t fork_lazy_child(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pid_t forkret;</span>
<span class="p_add">+</span>
<span class="p_add">+	forkret = fork();</span>
<span class="p_add">+	pkey_assert(forkret &gt;= 0);</span>
<span class="p_add">+	dprintf3(&quot;[%d] fork() ret: %d\n&quot;, getpid(), forkret);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!forkret) {</span>
<span class="p_add">+		/* in the child */</span>
<span class="p_add">+		while (1) {</span>
<span class="p_add">+			dprintf1(&quot;child sleeping...\n&quot;);</span>
<span class="p_add">+			sleep(30);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return forkret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void davecmp(void *_a, void *_b, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	unsigned long *a = _a;</span>
<span class="p_add">+	unsigned long *b = _b;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; len / sizeof(*a); i++) {</span>
<span class="p_add">+		if (a[i] == b[i])</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf3(&quot;[%3d]: a: %016lx b: %016lx\n&quot;, i, a[i], b[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void dumpit(char *f)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int fd = open(f, O_RDONLY);</span>
<span class="p_add">+	char buf[100];</span>
<span class="p_add">+	int nr_read;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf2(&quot;maps fd: %d\n&quot;, fd);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		nr_read = read(fd, &amp;buf[0], sizeof(buf));</span>
<span class="p_add">+		write(1, buf, nr_read);</span>
<span class="p_add">+	} while (nr_read &gt; 0);</span>
<span class="p_add">+	close(fd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define PKEY_DISABLE_ACCESS    0x1</span>
<span class="p_add">+#define PKEY_DISABLE_WRITE     0x2</span>
<span class="p_add">+</span>
<span class="p_add">+u32 pkey_get(int pkey, unsigned long flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 mask = (PKEY_DISABLE_ACCESS|PKEY_DISABLE_WRITE);</span>
<span class="p_add">+	u32 pkru = __rdpkru();</span>
<span class="p_add">+	u32 shifted_pkru;</span>
<span class="p_add">+	u32 masked_pkru;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s(pkey=%d, flags=%lx) = %x / %d\n&quot;,</span>
<span class="p_add">+			__func__, pkey, flags, 0, 0);</span>
<span class="p_add">+	dprintf2(&quot;%s() raw pkru: %x\n&quot;, __func__, pkru);</span>
<span class="p_add">+</span>
<span class="p_add">+	shifted_pkru = (pkru &gt;&gt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_add">+	dprintf2(&quot;%s() shifted_pkru: %x\n&quot;, __func__, shifted_pkru);</span>
<span class="p_add">+	masked_pkru = shifted_pkru &amp; mask;</span>
<span class="p_add">+	dprintf2(&quot;%s() masked  pkru: %x\n&quot;, __func__, masked_pkru);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * shift down the relevant bits to the lowest two, then</span>
<span class="p_add">+	 * mask off all the other high bits.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return masked_pkru;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int pkey_set(int pkey, unsigned long rights, unsigned long flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 mask = (PKEY_DISABLE_ACCESS|PKEY_DISABLE_WRITE);</span>
<span class="p_add">+	u32 old_pkru = __rdpkru();</span>
<span class="p_add">+	u32 new_pkru;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* make sure that &#39;rights&#39; only contains the bits we expect: */</span>
<span class="p_add">+	assert(!(rights &amp; ~mask));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* copy old pkru */</span>
<span class="p_add">+	new_pkru = old_pkru;</span>
<span class="p_add">+	/* mask out bits from pkey in old value: */</span>
<span class="p_add">+	new_pkru &amp;= ~(mask &lt;&lt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_add">+	/* OR in new bits for pkey: */</span>
<span class="p_add">+	new_pkru |= (rights &lt;&lt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_add">+</span>
<span class="p_add">+	__wrpkru(new_pkru);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf3(&quot;%s(pkey=%d, rights=%lx, flags=%lx) = %x pkru now: %x old_pkru: %x\n&quot;,</span>
<span class="p_add">+			__func__, pkey, rights, flags, 0, __rdpkru(), old_pkru);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void pkey_disable_set(int pkey, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long syscall_flags = 0;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	int pkey_rights;</span>
<span class="p_add">+	u32 orig_pkru = rdpkru();</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;START-&gt;%s(%d, 0x%x)\n&quot;, __func__,</span>
<span class="p_add">+		pkey, flags);</span>
<span class="p_add">+	pkey_assert(flags &amp; (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_add">+			pkey, pkey, pkey_rights);</span>
<span class="p_add">+	pkey_assert(pkey_rights &gt;= 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_rights |= flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pkey_set(pkey, pkey_rights, syscall_flags);</span>
<span class="p_add">+	assert(!ret);</span>
<span class="p_add">+	/*pkru and flags have the same format */</span>
<span class="p_add">+	shadow_pkru |= flags &lt;&lt; (pkey * 2);</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) shadow: 0x%x\n&quot;, __func__, pkey, shadow_pkru);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_assert(ret &gt;= 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_add">+			pkey, pkey, pkey_rights);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkru: 0x%x\n&quot;, __func__, pkey, rdpkru());</span>
<span class="p_add">+	if (flags)</span>
<span class="p_add">+		pkey_assert(rdpkru() &gt; orig_pkru);</span>
<span class="p_add">+	dprintf1(&quot;END&lt;---%s(%d, 0x%x)\n&quot;, __func__,</span>
<span class="p_add">+		pkey, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void pkey_disable_clear(int pkey, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long syscall_flags = 0;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	int pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_add">+	u32 orig_pkru = rdpkru();</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_assert(flags &amp; (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_add">+			pkey, pkey, pkey_rights);</span>
<span class="p_add">+	pkey_assert(pkey_rights &gt;= 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_rights |= flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pkey_set(pkey, pkey_rights, 0);</span>
<span class="p_add">+	/* pkru and flags have the same format */</span>
<span class="p_add">+	shadow_pkru &amp;= ~(flags &lt;&lt; (pkey * 2));</span>
<span class="p_add">+	pkey_assert(ret &gt;= 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_add">+			pkey, pkey, pkey_rights);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s(%d) pkru: 0x%x\n&quot;, __func__, pkey, rdpkru());</span>
<span class="p_add">+	if (flags)</span>
<span class="p_add">+		assert(rdpkru() &gt; orig_pkru);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void pkey_write_allow(int pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_disable_clear(pkey, PKEY_DISABLE_WRITE);</span>
<span class="p_add">+}</span>
<span class="p_add">+void pkey_write_deny(int pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_disable_set(pkey, PKEY_DISABLE_WRITE);</span>
<span class="p_add">+}</span>
<span class="p_add">+void pkey_access_allow(int pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_disable_clear(pkey, PKEY_DISABLE_ACCESS);</span>
<span class="p_add">+}</span>
<span class="p_add">+void pkey_access_deny(int pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_disable_set(pkey, PKEY_DISABLE_ACCESS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int sys_mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,</span>
<span class="p_add">+		unsigned long pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int sret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf2(&quot;%s(0x%p, %zx, prot=%lx, pkey=%lx)\n&quot;, __func__,</span>
<span class="p_add">+			ptr, size, orig_prot, pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	errno = 0;</span>
<span class="p_add">+	sret = syscall(SYS_mprotect_key, ptr, size, orig_prot, pkey);</span>
<span class="p_add">+	if (errno) {</span>
<span class="p_add">+		dprintf2(&quot;SYS_mprotect_key sret: %d\n&quot;, sret);</span>
<span class="p_add">+		dprintf2(&quot;SYS_mprotect_key prot: 0x%lx\n&quot;, orig_prot);</span>
<span class="p_add">+		dprintf2(&quot;SYS_mprotect_key failed, errno: %d\n&quot;, errno);</span>
<span class="p_add">+		if (DEBUG_LEVEL &gt;= 2)</span>
<span class="p_add">+			perror(&quot;SYS_mprotect_pkey&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return sret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int sys_pkey_alloc(unsigned long flags, unsigned long init_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = syscall(SYS_pkey_alloc, flags, init_val);</span>
<span class="p_add">+	dprintf1(&quot;%s(flags=%lx, init_val=%lx) syscall ret: %d errno: %d\n&quot;,</span>
<span class="p_add">+			__func__, flags, init_val, ret, errno);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int alloc_pkey(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	unsigned long init_val = 0x0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;alloc_pkey()::%d, pkru: 0x%x shadow: %x\n&quot;,</span>
<span class="p_add">+			__LINE__, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	ret = sys_pkey_alloc(0, init_val);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * pkey_alloc() sets PKRU, so we need to reflect it in</span>
<span class="p_add">+	 * shadow_pkru:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		/* clear both the bits: */</span>
<span class="p_add">+		shadow_pkru &amp;= ~(0x3      &lt;&lt; (ret * 2));</span>
<span class="p_add">+		dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_add">+				__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * move the new state in from init_val</span>
<span class="p_add">+		 * (remember, we cheated and init_val == pkru format)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		shadow_pkru |=  (init_val &lt;&lt; (ret * 2));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	dprintf1(&quot;alloc_pkey()::%d errno: %d\n&quot;, __LINE__, errno);</span>
<span class="p_add">+	/* for shadow checking: */</span>
<span class="p_add">+	rdpkru();</span>
<span class="p_add">+	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int sys_pkey_free(unsigned long pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = syscall(SYS_pkey_free, pkey);</span>
<span class="p_add">+	dprintf1(&quot;%s(pkey=%ld) syscall ret: %d\n&quot;, __func__, pkey, ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * I had a bug where pkey bits could be set by mprotect() but</span>
<span class="p_add">+ * not cleared.  This ensures we get lots of random bit sets</span>
<span class="p_add">+ * and clears on the vma and pte pkey bits.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int alloc_random_pkey(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int max_nr_pkey_allocs;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int alloced_pkeys[NR_PKEYS];</span>
<span class="p_add">+	int nr_alloced = 0;</span>
<span class="p_add">+	int random_index;</span>
<span class="p_add">+	memset(alloced_pkeys, 0, sizeof(alloced_pkeys));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* allocate every possible key and make a note of which ones we got */</span>
<span class="p_add">+	max_nr_pkey_allocs = NR_PKEYS;</span>
<span class="p_add">+	max_nr_pkey_allocs = 1;</span>
<span class="p_add">+	for (i = 0; i &lt; max_nr_pkey_allocs; i++) {</span>
<span class="p_add">+		int new_pkey = alloc_pkey();</span>
<span class="p_add">+		if (new_pkey &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		alloced_pkeys[nr_alloced++] = new_pkey;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_assert(nr_alloced &gt; 0);</span>
<span class="p_add">+	/* select a random one out of the allocated ones */</span>
<span class="p_add">+	random_index = rand() % nr_alloced;</span>
<span class="p_add">+	ret = alloced_pkeys[random_index];</span>
<span class="p_add">+	/* now zero it out so we don&#39;t free it next */</span>
<span class="p_add">+	alloced_pkeys[random_index] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* go through the allocated ones that we did not want and free them */</span>
<span class="p_add">+	for (i = 0; i &lt; nr_alloced; i++) {</span>
<span class="p_add">+		int free_ret;</span>
<span class="p_add">+		if (!alloced_pkeys[i])</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		free_ret = sys_pkey_free(alloced_pkeys[i]);</span>
<span class="p_add">+		pkey_assert(!free_ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,</span>
<span class="p_add">+		unsigned long pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int nr_iterations = random() % 100;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (0) {</span>
<span class="p_add">+		int rpkey = alloc_random_pkey();</span>
<span class="p_add">+		ret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);</span>
<span class="p_add">+		dprintf1(&quot;sys_mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\n&quot;,</span>
<span class="p_add">+				ptr, size, orig_prot, pkey, ret);</span>
<span class="p_add">+		if (nr_iterations-- &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+		sys_pkey_free(rpkey);</span>
<span class="p_add">+		dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);</span>
<span class="p_add">+	dprintf1(&quot;mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\n&quot;,</span>
<span class="p_add">+			ptr, size, orig_prot, pkey, ret);</span>
<span class="p_add">+	pkey_assert(!ret);</span>
<span class="p_add">+	dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_add">+			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct pkey_malloc_record {</span>
<span class="p_add">+	void *ptr;</span>
<span class="p_add">+	long size;</span>
<span class="p_add">+};</span>
<span class="p_add">+struct pkey_malloc_record *pkey_malloc_records;</span>
<span class="p_add">+long nr_pkey_malloc_records;</span>
<span class="p_add">+void record_pkey_malloc(void *ptr, long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long i;</span>
<span class="p_add">+	struct pkey_malloc_record *rec = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nr_pkey_malloc_records; i++) {</span>
<span class="p_add">+		rec = &amp;pkey_malloc_records[i];</span>
<span class="p_add">+		/* find a free record */</span>
<span class="p_add">+		if (rec)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!rec) {</span>
<span class="p_add">+		/* every record is full */</span>
<span class="p_add">+		size_t old_nr_records = nr_pkey_malloc_records;</span>
<span class="p_add">+		size_t new_nr_records = (nr_pkey_malloc_records * 2 + 1);</span>
<span class="p_add">+		size_t new_size = new_nr_records * sizeof(struct pkey_malloc_record);</span>
<span class="p_add">+		dprintf2(&quot;new_nr_records: %zd\n&quot;, new_nr_records);</span>
<span class="p_add">+		dprintf2(&quot;new_size: %zd\n&quot;, new_size);</span>
<span class="p_add">+		pkey_malloc_records = realloc(pkey_malloc_records, new_size);</span>
<span class="p_add">+		pkey_assert(pkey_malloc_records != NULL);</span>
<span class="p_add">+		rec = &amp;pkey_malloc_records[nr_pkey_malloc_records];</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * realloc() does not initialize memory, so zero it from</span>
<span class="p_add">+		 * the first new record all the way to the end.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (i = 0; i &lt; new_nr_records - old_nr_records; i++)</span>
<span class="p_add">+			memset(rec + i, 0, sizeof(*rec));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dprintf3(&quot;filling malloc record[%d/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_add">+		(int)(rec - pkey_malloc_records), rec, ptr, size);</span>
<span class="p_add">+	rec-&gt;ptr = ptr;</span>
<span class="p_add">+	rec-&gt;size = size;</span>
<span class="p_add">+	nr_pkey_malloc_records++;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void free_pkey_malloc(void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long i;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	dprintf3(&quot;%s(%p)\n&quot;, __func__, ptr);</span>
<span class="p_add">+	for (i = 0; i &lt; nr_pkey_malloc_records; i++) {</span>
<span class="p_add">+		struct pkey_malloc_record *rec = &amp;pkey_malloc_records[i];</span>
<span class="p_add">+		dprintf4(&quot;looking for ptr %p at record[%ld/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_add">+				ptr, i, rec, rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_add">+		if ((ptr &lt;  rec-&gt;ptr) ||</span>
<span class="p_add">+		    (ptr &gt;= rec-&gt;ptr + rec-&gt;size))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf3(&quot;found ptr %p at record[%ld/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_add">+				ptr, i, rec, rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_add">+		nr_pkey_malloc_records--;</span>
<span class="p_add">+		ret = munmap(rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_add">+		dprintf3(&quot;munmap ret: %d\n&quot;, ret);</span>
<span class="p_add">+		pkey_assert(!ret);</span>
<span class="p_add">+		dprintf3(&quot;clearing rec-&gt;ptr, rec: %p\n&quot;, rec);</span>
<span class="p_add">+		rec-&gt;ptr = NULL;</span>
<span class="p_add">+		dprintf3(&quot;done clearing rec-&gt;ptr, rec: %p\n&quot;, rec);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pkey_assert(false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void *malloc_pkey_with_mprotect(long size, int prot, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *ptr;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	rdpkru();</span>
<span class="p_add">+	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_add">+			size, prot, pkey);</span>
<span class="p_add">+	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_add">+	ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_add">+	pkey_assert(ptr != (void *)-1);</span>
<span class="p_add">+	ret = mprotect_pkey((void *)ptr, PAGE_SIZE, prot, pkey);</span>
<span class="p_add">+	pkey_assert(!ret);</span>
<span class="p_add">+	record_pkey_malloc(ptr, size);</span>
<span class="p_add">+	rdpkru();</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;%s() for pkey %d @ %p\n&quot;, __func__, pkey, ptr);</span>
<span class="p_add">+	return ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void *malloc_pkey_anon_huge(long size, int prot, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	void *ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_add">+			size, prot, pkey);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Guarantee we can fit at least one huge page in the resulting</span>
<span class="p_add">+	 * allocation by allocating space for 2:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	size = ALIGN_UP(size, HPAGE_SIZE * 2);</span>
<span class="p_add">+	ptr = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_add">+	pkey_assert(ptr != (void *)-1);</span>
<span class="p_add">+	record_pkey_malloc(ptr, size);</span>
<span class="p_add">+	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;unaligned ptr: %p\n&quot;, ptr);</span>
<span class="p_add">+	ptr = ALIGN_PTR_UP(ptr, HPAGE_SIZE);</span>
<span class="p_add">+	dprintf1(&quot;  aligned ptr: %p\n&quot;, ptr);</span>
<span class="p_add">+	ret = madvise(ptr, HPAGE_SIZE, MADV_HUGEPAGE);</span>
<span class="p_add">+	dprintf1(&quot;MADV_HUGEPAGE ret: %d\n&quot;, ret);</span>
<span class="p_add">+	ret = madvise(ptr, HPAGE_SIZE, MADV_WILLNEED);</span>
<span class="p_add">+	dprintf1(&quot;MADV_WILLNEED ret: %d\n&quot;, ret);</span>
<span class="p_add">+	memset(ptr, 0, HPAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;mmap()&#39;d thp for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_add">+	return ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hugetlb_setup_ok;</span>
<span class="p_add">+#define GET_NR_HUGE_PAGES 10</span>
<span class="p_add">+void setup_hugetlbfs(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int fd;</span>
<span class="p_add">+	char buf[] = &quot;123&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (geteuid() != 0) {</span>
<span class="p_add">+		fprintf(stderr, &quot;WARNING: not run as root, can not do hugetlb test\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cat_into_file(__stringify(GET_NR_HUGE_PAGES), &quot;/proc/sys/vm/nr_hugepages&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now go make sure that we got the pages and that they</span>
<span class="p_add">+	 * are 2M pages.  Someone might have made 1G the default.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fd = open(&quot;/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages&quot;, O_RDONLY);</span>
<span class="p_add">+	if (fd &lt; 0) {</span>
<span class="p_add">+		perror(&quot;opening sysfs 2M hugetlb config&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* -1 to guarantee leaving the trailing \0 */</span>
<span class="p_add">+	err = read(fd, buf, sizeof(buf)-1);</span>
<span class="p_add">+	close(fd);</span>
<span class="p_add">+	if (err &lt;= 0) {</span>
<span class="p_add">+		perror(&quot;reading sysfs 2M hugetlb config&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (atoi(buf) != GET_NR_HUGE_PAGES) {</span>
<span class="p_add">+		fprintf(stderr, &quot;could not confirm 2M pages, got: &#39;%s&#39; expected %d\n&quot;,</span>
<span class="p_add">+			buf, GET_NR_HUGE_PAGES);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hugetlb_setup_ok = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void *malloc_pkey_hugetlb(long size, int prot, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *ptr;</span>
<span class="p_add">+	int flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hugetlb_setup_ok)</span>
<span class="p_add">+		return PTR_ERR_ENOTSUP;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;doing %s(%ld, %x, %x)\n&quot;, __func__, size, prot, pkey);</span>
<span class="p_add">+	size = ALIGN_UP(size, HPAGE_SIZE * 2);</span>
<span class="p_add">+	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_add">+	ptr = mmap(NULL, size, PROT_NONE, flags, -1, 0);</span>
<span class="p_add">+	pkey_assert(ptr != (void *)-1);</span>
<span class="p_add">+	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	record_pkey_malloc(ptr, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;mmap()&#39;d hugetlbfs for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_add">+	return ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void *malloc_pkey_mmap_dax(long size, int prot, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *ptr;</span>
<span class="p_add">+	int fd;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_add">+			size, prot, pkey);</span>
<span class="p_add">+	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_add">+	fd = open(&quot;/dax/foo&quot;, O_RDWR);</span>
<span class="p_add">+	pkey_assert(fd &gt;= 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	ptr = mmap(0, size, prot, MAP_SHARED, fd, 0);</span>
<span class="p_add">+	pkey_assert(ptr != (void *)-1);</span>
<span class="p_add">+</span>
<span class="p_add">+	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	record_pkey_malloc(ptr, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;mmap()&#39;d for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_add">+	close(fd);</span>
<span class="p_add">+	return ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void *(*pkey_malloc[])(long size, int prot, u16 pkey) = {</span>
<span class="p_add">+</span>
<span class="p_add">+	malloc_pkey_with_mprotect,</span>
<span class="p_add">+	malloc_pkey_anon_huge,</span>
<span class="p_add">+	malloc_pkey_hugetlb</span>
<span class="p_add">+/* can not do direct with the pkey_mprotect() API:</span>
<span class="p_add">+	malloc_pkey_mmap_direct,</span>
<span class="p_add">+	malloc_pkey_mmap_dax,</span>
<span class="p_add">+*/</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void *malloc_pkey(long size, int prot, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+	static int malloc_type;</span>
<span class="p_add">+	int nr_malloc_types = ARRAY_SIZE(pkey_malloc);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		pkey_assert(malloc_type &lt; nr_malloc_types);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = pkey_malloc[malloc_type](size, prot, pkey);</span>
<span class="p_add">+		pkey_assert(ret != (void *)-1);</span>
<span class="p_add">+</span>
<span class="p_add">+		malloc_type++;</span>
<span class="p_add">+		if (malloc_type &gt;= nr_malloc_types)</span>
<span class="p_add">+			malloc_type = (random()%nr_malloc_types);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* try again if the malloc_type we tried is unsupported */</span>
<span class="p_add">+		if (ret == PTR_ERR_ENOTSUP)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf3(&quot;%s(%ld, prot=%x, pkey=%x) returning: %p\n&quot;, __func__,</span>
<span class="p_add">+			size, prot, pkey, ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int last_pkru_faults;</span>
<span class="p_add">+void expected_pk_fault(int pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprintf2(&quot;%s(): last_pkru_faults: %d pkru_faults: %d\n&quot;,</span>
<span class="p_add">+			__func__, last_pkru_faults, pkru_faults);</span>
<span class="p_add">+	dprintf2(&quot;%s(%d): last_si_pkey: %d\n&quot;, __func__, pkey, last_si_pkey);</span>
<span class="p_add">+	pkey_assert(last_pkru_faults + 1 == pkru_faults);</span>
<span class="p_add">+	pkey_assert(last_si_pkey == pkey);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The signal handler shold have cleared out PKRU to let the</span>
<span class="p_add">+	 * test program continue.  We now have to restore it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__rdpkru() != 0)</span>
<span class="p_add">+		pkey_assert(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	__wrpkru(shadow_pkru);</span>
<span class="p_add">+	dprintf1(&quot;%s() set PKRU=%x to restore state after signal nuked it\n&quot;,</span>
<span class="p_add">+			__func__, shadow_pkru);</span>
<span class="p_add">+	last_pkru_faults = pkru_faults;</span>
<span class="p_add">+	last_si_pkey = -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_not_expect_pk_fault(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_assert(last_pkru_faults == pkru_faults);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int test_fds[10] = { -1 };</span>
<span class="p_add">+int nr_test_fds;</span>
<span class="p_add">+void __save_test_fd(int fd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pkey_assert(fd &gt;= 0);</span>
<span class="p_add">+	pkey_assert(nr_test_fds &lt; ARRAY_SIZE(test_fds));</span>
<span class="p_add">+	test_fds[nr_test_fds] = fd;</span>
<span class="p_add">+	nr_test_fds++;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int get_test_read_fd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int test_fd = open(&quot;/etc/passwd&quot;, O_RDONLY);</span>
<span class="p_add">+	__save_test_fd(test_fd);</span>
<span class="p_add">+	return test_fd;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void close_test_fds(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nr_test_fds; i++) {</span>
<span class="p_add">+		if (test_fds[i] &lt; 0)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		close(test_fds[i]);</span>
<span class="p_add">+		test_fds[i] = -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	nr_test_fds = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span>
<span class="p_add">+__attribute__((noinline)) int read_ptr(int *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Keep GCC from optimizing this away somehow</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	barrier();</span>
<span class="p_add">+	return *ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_read_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ptr_contents;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;disabling write access to PKEY[1], doing read\n&quot;);</span>
<span class="p_add">+	pkey_write_deny(pkey);</span>
<span class="p_add">+	ptr_contents = read_ptr(ptr);</span>
<span class="p_add">+	dprintf1(&quot;*ptr: %d\n&quot;, ptr_contents);</span>
<span class="p_add">+	dprintf1(&quot;\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+void test_read_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ptr_contents;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;disabling access to PKEY[%02d], doing read @ %p\n&quot;, pkey, ptr);</span>
<span class="p_add">+	rdpkru();</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+	ptr_contents = read_ptr(ptr);</span>
<span class="p_add">+	dprintf1(&quot;*ptr: %d\n&quot;, ptr_contents);</span>
<span class="p_add">+	expected_pk_fault(pkey);</span>
<span class="p_add">+}</span>
<span class="p_add">+void test_write_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprintf1(&quot;disabling write access to PKEY[%02d], doing write\n&quot;, pkey);</span>
<span class="p_add">+	pkey_write_deny(pkey);</span>
<span class="p_add">+	*ptr = __LINE__;</span>
<span class="p_add">+	expected_pk_fault(pkey);</span>
<span class="p_add">+}</span>
<span class="p_add">+void test_write_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dprintf1(&quot;disabling access to PKEY[%02d], doing write\n&quot;, pkey);</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+	*ptr = __LINE__;</span>
<span class="p_add">+	expected_pk_fault(pkey);</span>
<span class="p_add">+}</span>
<span class="p_add">+void test_kernel_write_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	int test_fd = get_test_read_fd();</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;disabling access to PKEY[%02d], &quot;</span>
<span class="p_add">+		 &quot;having kernel read() to buffer\n&quot;, pkey);</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+	ret = read(test_fd, ptr, 1);</span>
<span class="p_add">+	dprintf1(&quot;read ret: %d\n&quot;, ret);</span>
<span class="p_add">+	pkey_assert(ret);</span>
<span class="p_add">+}</span>
<span class="p_add">+void test_kernel_write_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	int test_fd = get_test_read_fd();</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_write_deny(pkey);</span>
<span class="p_add">+	ret = read(test_fd, ptr, 100);</span>
<span class="p_add">+	dprintf1(&quot;read ret: %d\n&quot;, ret);</span>
<span class="p_add">+	if (ret &lt; 0 &amp;&amp; (DEBUG_LEVEL &gt; 0))</span>
<span class="p_add">+		perror(&quot;verbose read result (OK for this to be bad)&quot;);</span>
<span class="p_add">+	pkey_assert(ret);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_kernel_gup_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int pipe_ret, vmsplice_ret;</span>
<span class="p_add">+	struct iovec iov;</span>
<span class="p_add">+	int pipe_fds[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	pipe_ret = pipe(pipe_fds);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_assert(pipe_ret == 0);</span>
<span class="p_add">+	dprintf1(&quot;disabling access to PKEY[%02d], &quot;</span>
<span class="p_add">+		 &quot;having kernel vmsplice from buffer\n&quot;, pkey);</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+	iov.iov_base = ptr;</span>
<span class="p_add">+	iov.iov_len = PAGE_SIZE;</span>
<span class="p_add">+	vmsplice_ret = vmsplice(pipe_fds[1], &amp;iov, 1, SPLICE_F_GIFT);</span>
<span class="p_add">+	dprintf1(&quot;vmsplice() ret: %d\n&quot;, vmsplice_ret);</span>
<span class="p_add">+	pkey_assert(vmsplice_ret == -1);</span>
<span class="p_add">+</span>
<span class="p_add">+	close(pipe_fds[0]);</span>
<span class="p_add">+	close(pipe_fds[1]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_kernel_gup_write_to_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ignored = 0xdada;</span>
<span class="p_add">+	int futex_ret;</span>
<span class="p_add">+	int some_int = __LINE__;</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf1(&quot;disabling write to PKEY[%02d], &quot;</span>
<span class="p_add">+		 &quot;doing futex gunk in buffer\n&quot;, pkey);</span>
<span class="p_add">+	*ptr = some_int;</span>
<span class="p_add">+	pkey_write_deny(pkey);</span>
<span class="p_add">+	futex_ret = syscall(SYS_futex, ptr, FUTEX_WAIT, some_int-1, NULL,</span>
<span class="p_add">+			&amp;ignored, ignored);</span>
<span class="p_add">+	if (DEBUG_LEVEL &gt; 0)</span>
<span class="p_add">+		perror(&quot;futex&quot;);</span>
<span class="p_add">+	dprintf1(&quot;futex() ret: %d\n&quot;, futex_ret);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_add">+void test_pkey_syscalls_on_non_allocated_pkey(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Note: 0 is the default pkey, so don&#39;t mess with it */</span>
<span class="p_add">+	for (i = 1; i &lt; NR_PKEYS; i++) {</span>
<span class="p_add">+		if (pkey == i)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf1(&quot;trying get/set/free to non-allocated pkey: %2d\n&quot;, i);</span>
<span class="p_add">+		err = sys_pkey_free(i);</span>
<span class="p_add">+		pkey_assert(err);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = sys_pkey_free(i);</span>
<span class="p_add">+		pkey_assert(err);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, i);</span>
<span class="p_add">+		pkey_assert(err);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_add">+void test_pkey_syscalls_bad_args(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int bad_pkey = NR_PKEYS+99;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* pass a known-invalid pkey in: */</span>
<span class="p_add">+	err = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, bad_pkey);</span>
<span class="p_add">+	pkey_assert(err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_add">+void test_pkey_alloc_exhaust(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int allocated_pkeys[NR_PKEYS] = {0};</span>
<span class="p_add">+	int nr_allocated_pkeys = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; NR_PKEYS*2; i++) {</span>
<span class="p_add">+		int new_pkey;</span>
<span class="p_add">+		dprintf1(&quot;%s() alloc loop: %d\n&quot;, __func__, i);</span>
<span class="p_add">+		new_pkey = alloc_pkey();</span>
<span class="p_add">+		dprintf4(&quot;%s()::%d, err: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_add">+				__LINE__, err, __rdpkru(), shadow_pkru);</span>
<span class="p_add">+		rdpkru(); /* for shadow checking */</span>
<span class="p_add">+		dprintf2(&quot;%s() errno: %d ENOSPC: %d\n&quot;, __func__, errno, ENOSPC);</span>
<span class="p_add">+		if ((new_pkey == -1) &amp;&amp; (errno == ENOSPC)) {</span>
<span class="p_add">+			dprintf2(&quot;%s() failed to allocate pkey after %d tries\n&quot;,</span>
<span class="p_add">+				__func__, nr_allocated_pkeys);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pkey_assert(nr_allocated_pkeys &lt; NR_PKEYS);</span>
<span class="p_add">+		allocated_pkeys[nr_allocated_pkeys++] = new_pkey;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf3(&quot;%s()::%d\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ensure it did not reach the end of the loop without</span>
<span class="p_add">+	 * failure:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pkey_assert(i &lt; NR_PKEYS*2);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There are 16 pkeys supported in hardware.  One is taken</span>
<span class="p_add">+	 * up for the default (0) and another can be taken up by</span>
<span class="p_add">+	 * an execute-only mapping.  Ensure that we can allocate</span>
<span class="p_add">+	 * at least 14 (16-2).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pkey_assert(i &gt;= NR_PKEYS-2);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nr_allocated_pkeys; i++) {</span>
<span class="p_add">+		err = sys_pkey_free(allocated_pkeys[i]);</span>
<span class="p_add">+		pkey_assert(!err);</span>
<span class="p_add">+		rdpkru(); /* for shadow checking */</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_ptrace_of_child(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__attribute__((__unused__)) int peek_result;</span>
<span class="p_add">+	pid_t child_pid;</span>
<span class="p_add">+	void *ignored = 0;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This is the &quot;control&quot; for our little expermient.  Make sure</span>
<span class="p_add">+	 * we can always access it when ptracing.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	int *plain_ptr_unaligned = malloc(HPAGE_SIZE);</span>
<span class="p_add">+	int *plain_ptr = ALIGN_PTR_UP(plain_ptr_unaligned, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fork a child which is an exact copy of this process, of course.</span>
<span class="p_add">+	 * That means we can do all of our tests via ptrace() and then plain</span>
<span class="p_add">+	 * memory access and ensure they work differently.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	child_pid = fork_lazy_child();</span>
<span class="p_add">+	dprintf1(&quot;[%d] child pid: %d\n&quot;, getpid(), child_pid);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ptrace(PTRACE_ATTACH, child_pid, ignored, ignored);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		perror(&quot;attach&quot;);</span>
<span class="p_add">+	dprintf1(&quot;[%d] attach ret: %ld %d\n&quot;, getpid(), ret, __LINE__);</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+	ret = waitpid(child_pid, &amp;status, WUNTRACED);</span>
<span class="p_add">+	if ((ret != child_pid) || !(WIFSTOPPED(status))) {</span>
<span class="p_add">+		fprintf(stderr, &quot;weird waitpid result %ld stat %x\n&quot;,</span>
<span class="p_add">+				ret, status);</span>
<span class="p_add">+		pkey_assert(0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dprintf2(&quot;waitpid ret: %ld\n&quot;, ret);</span>
<span class="p_add">+	dprintf2(&quot;waitpid status: %d\n&quot;, status);</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+	pkey_write_deny(pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Write access, untested for now:</span>
<span class="p_add">+	ret = ptrace(PTRACE_POKEDATA, child_pid, peek_at, data);</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+	dprintf1(&quot;poke at %p: %ld\n&quot;, peek_at, ret);</span>
<span class="p_add">+	*/</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Try to access the pkey-protected &quot;ptr&quot; via ptrace:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = ptrace(PTRACE_PEEKDATA, child_pid, ptr, ignored);</span>
<span class="p_add">+	/* expect it to work, without an error: */</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+	/* Now access from the current task, and expect an exception: */</span>
<span class="p_add">+	peek_result = read_ptr(ptr);</span>
<span class="p_add">+	expected_pk_fault(pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Try to access the NON-pkey-protected &quot;plain_ptr&quot; via ptrace:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = ptrace(PTRACE_PEEKDATA, child_pid, plain_ptr, ignored);</span>
<span class="p_add">+	/* expect it to work, without an error: */</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+	/* Now access from the current task, and expect NO exception: */</span>
<span class="p_add">+	peek_result = read_ptr(plain_ptr);</span>
<span class="p_add">+	do_not_expect_pk_fault();</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ptrace(PTRACE_DETACH, child_pid, ignored, 0);</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = kill(child_pid, SIGKILL);</span>
<span class="p_add">+	pkey_assert(ret != -1);</span>
<span class="p_add">+</span>
<span class="p_add">+	wait(&amp;status);</span>
<span class="p_add">+</span>
<span class="p_add">+	free(plain_ptr_unaligned);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_executing_on_unreadable_memory(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *p1;</span>
<span class="p_add">+	int scratch;</span>
<span class="p_add">+	int ptr_contents;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	p1 = ALIGN_PTR_UP(&amp;lots_o_noops_around_write, PAGE_SIZE);</span>
<span class="p_add">+	dprintf3(&quot;&amp;lots_o_noops: %p\n&quot;, &amp;lots_o_noops_around_write);</span>
<span class="p_add">+	/* lots_o_noops_around_write should be page-aligned already */</span>
<span class="p_add">+	assert(p1 == &amp;lots_o_noops_around_write);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point &#39;p1&#39; at the *second* page of the function: */</span>
<span class="p_add">+	p1 += PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	madvise(p1, PAGE_SIZE, MADV_DONTNEED);</span>
<span class="p_add">+	lots_o_noops_around_write(&amp;scratch);</span>
<span class="p_add">+	ptr_contents = read_ptr(p1);</span>
<span class="p_add">+	dprintf2(&quot;ptr (%p) contents@%d: %x\n&quot;, p1, __LINE__, ptr_contents);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mprotect_pkey(p1, PAGE_SIZE, PROT_EXEC, (u64)pkey);</span>
<span class="p_add">+	pkey_assert(!ret);</span>
<span class="p_add">+	pkey_access_deny(pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+	dprintf2(&quot;pkru: %x\n&quot;, rdpkru());</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure this is an *instruction* fault</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	madvise(p1, PAGE_SIZE, MADV_DONTNEED);</span>
<span class="p_add">+	lots_o_noops_around_write(&amp;scratch);</span>
<span class="p_add">+	do_not_expect_pk_fault();</span>
<span class="p_add">+	ptr_contents = read_ptr(p1);</span>
<span class="p_add">+	dprintf2(&quot;ptr (%p) contents@%d: %x\n&quot;, p1, __LINE__, ptr_contents);</span>
<span class="p_add">+	expected_pk_fault(pkey);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void test_mprotect_pkey_on_unsupported_cpu(int *ptr, u16 pkey)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int size = PAGE_SIZE;</span>
<span class="p_add">+	int sret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpu_has_pku()) {</span>
<span class="p_add">+		dprintf1(&quot;SKIP: %s: no CPU support\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sret = syscall(SYS_mprotect_key, ptr, size, PROT_READ, pkey);</span>
<span class="p_add">+	pkey_assert(sret &lt; 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void (*pkey_tests[])(int *ptr, u16 pkey) = {</span>
<span class="p_add">+	test_read_of_write_disabled_region,</span>
<span class="p_add">+	test_read_of_access_disabled_region,</span>
<span class="p_add">+	test_write_of_write_disabled_region,</span>
<span class="p_add">+	test_write_of_access_disabled_region,</span>
<span class="p_add">+	test_kernel_write_of_access_disabled_region,</span>
<span class="p_add">+	test_kernel_write_of_write_disabled_region,</span>
<span class="p_add">+	test_kernel_gup_of_access_disabled_region,</span>
<span class="p_add">+	test_kernel_gup_write_to_write_disabled_region,</span>
<span class="p_add">+	test_executing_on_unreadable_memory,</span>
<span class="p_add">+	test_ptrace_of_child,</span>
<span class="p_add">+	test_pkey_syscalls_on_non_allocated_pkey,</span>
<span class="p_add">+	test_pkey_syscalls_bad_args,</span>
<span class="p_add">+	test_pkey_alloc_exhaust,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void run_tests_once(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int *ptr;</span>
<span class="p_add">+	int prot = PROT_READ|PROT_WRITE;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (test_nr = 0; test_nr &lt; ARRAY_SIZE(pkey_tests); test_nr++) {</span>
<span class="p_add">+		int pkey;</span>
<span class="p_add">+		int orig_pkru_faults = pkru_faults;</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf1(&quot;======================\n&quot;);</span>
<span class="p_add">+		dprintf1(&quot;test %d preparing...\n&quot;, test_nr);</span>
<span class="p_add">+</span>
<span class="p_add">+		tracing_on();</span>
<span class="p_add">+		pkey = alloc_random_pkey();</span>
<span class="p_add">+		dprintf1(&quot;test %d starting with pkey: %d\n&quot;, test_nr, pkey);</span>
<span class="p_add">+		ptr = malloc_pkey(PAGE_SIZE, prot, pkey);</span>
<span class="p_add">+		dprintf1(&quot;test %d starting...\n&quot;, test_nr);</span>
<span class="p_add">+		pkey_tests[test_nr](ptr, pkey);</span>
<span class="p_add">+		dprintf1(&quot;freeing test memory: %p\n&quot;, ptr);</span>
<span class="p_add">+		free_pkey_malloc(ptr);</span>
<span class="p_add">+		sys_pkey_free(pkey);</span>
<span class="p_add">+</span>
<span class="p_add">+		dprintf1(&quot;pkru_faults: %d\n&quot;, pkru_faults);</span>
<span class="p_add">+		dprintf1(&quot;orig_pkru_faults: %d\n&quot;, orig_pkru_faults);</span>
<span class="p_add">+</span>
<span class="p_add">+		tracing_off();</span>
<span class="p_add">+		close_test_fds();</span>
<span class="p_add">+</span>
<span class="p_add">+		printf(&quot;test %2d PASSED (iteration %d)\n&quot;, test_nr, iteration_nr);</span>
<span class="p_add">+		dprintf1(&quot;======================\n\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	iteration_nr++;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void pkey_setup_shadow(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	shadow_pkru = __rdpkru();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int main(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int nr_iterations = 22;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_handlers();</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;has pku: %d\n&quot;, cpu_has_pku());</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu_has_pku()) {</span>
<span class="p_add">+		int size = PAGE_SIZE;</span>
<span class="p_add">+		int *ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		printf(&quot;running PKEY tests for unsupported CPU/OS\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+		ptr  = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_add">+		assert(ptr != (void *)-1);</span>
<span class="p_add">+		test_mprotect_pkey_on_unsupported_cpu(ptr, 1);</span>
<span class="p_add">+		exit(0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pkey_setup_shadow();</span>
<span class="p_add">+	printf(&quot;startup pkru: %x\n&quot;, rdpkru());</span>
<span class="p_add">+	setup_hugetlbfs();</span>
<span class="p_add">+</span>
<span class="p_add">+	while (nr_iterations-- &gt; 0)</span>
<span class="p_add">+		run_tests_once();</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;done (all tests OK)\n&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/tools/testing/selftests/x86/Makefile b/tools/testing/selftests/x86/Makefile</span>
<span class="p_header">index 97f187e..fee6181 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/Makefile</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"> include ../lib.mk</span>
 
 TARGETS_C_BOTHBITS := single_step_syscall sysret_ss_attrs syscall_nt ptrace_syscall test_mremap_vdso \
 			check_initial_reg_state sigreturn ldt_gdt iopl mpx-mini-test ioperm \
<span class="p_del">-			protection_keys test_vdso</span>
<span class="p_add">+			test_vdso</span>
 TARGETS_C_32BIT_ONLY := entry_from_vm86 syscall_arg_fault test_syscall_vdso unwind_vdso \
 			test_FCMOV test_FCOMI test_FISTTP \
 			vdso_restorer
<span class="p_header">diff --git a/tools/testing/selftests/x86/pkey-helpers.h b/tools/testing/selftests/x86/pkey-helpers.h</span>
deleted file mode 100644
<span class="p_header">index b202939..0000000</span>
<span class="p_header">--- a/tools/testing/selftests/x86/pkey-helpers.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,219 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _PKEYS_HELPER_H</span>
<span class="p_del">-#define _PKEYS_HELPER_H</span>
<span class="p_del">-#define _GNU_SOURCE</span>
<span class="p_del">-#include &lt;string.h&gt;</span>
<span class="p_del">-#include &lt;stdarg.h&gt;</span>
<span class="p_del">-#include &lt;stdio.h&gt;</span>
<span class="p_del">-#include &lt;stdint.h&gt;</span>
<span class="p_del">-#include &lt;stdbool.h&gt;</span>
<span class="p_del">-#include &lt;signal.h&gt;</span>
<span class="p_del">-#include &lt;assert.h&gt;</span>
<span class="p_del">-#include &lt;stdlib.h&gt;</span>
<span class="p_del">-#include &lt;ucontext.h&gt;</span>
<span class="p_del">-#include &lt;sys/mman.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define NR_PKEYS 16</span>
<span class="p_del">-#define PKRU_BITS_PER_PKEY 2</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef DEBUG_LEVEL</span>
<span class="p_del">-#define DEBUG_LEVEL 0</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#define DPRINT_IN_SIGNAL_BUF_SIZE 4096</span>
<span class="p_del">-extern int dprint_in_signal;</span>
<span class="p_del">-extern char dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];</span>
<span class="p_del">-static inline void sigsafe_printf(const char *format, ...)</span>
<span class="p_del">-{</span>
<span class="p_del">-	va_list ap;</span>
<span class="p_del">-</span>
<span class="p_del">-	va_start(ap, format);</span>
<span class="p_del">-	if (!dprint_in_signal) {</span>
<span class="p_del">-		vprintf(format, ap);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		int len = vsnprintf(dprint_in_signal_buffer,</span>
<span class="p_del">-				    DPRINT_IN_SIGNAL_BUF_SIZE,</span>
<span class="p_del">-				    format, ap);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * len is amount that would have been printed,</span>
<span class="p_del">-		 * but actual write is truncated at BUF_SIZE.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (len &gt; DPRINT_IN_SIGNAL_BUF_SIZE)</span>
<span class="p_del">-			len = DPRINT_IN_SIGNAL_BUF_SIZE;</span>
<span class="p_del">-		write(1, dprint_in_signal_buffer, len);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	va_end(ap);</span>
<span class="p_del">-}</span>
<span class="p_del">-#define dprintf_level(level, args...) do {	\</span>
<span class="p_del">-	if (level &lt;= DEBUG_LEVEL)		\</span>
<span class="p_del">-		sigsafe_printf(args);		\</span>
<span class="p_del">-	fflush(NULL);				\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-#define dprintf0(args...) dprintf_level(0, args)</span>
<span class="p_del">-#define dprintf1(args...) dprintf_level(1, args)</span>
<span class="p_del">-#define dprintf2(args...) dprintf_level(2, args)</span>
<span class="p_del">-#define dprintf3(args...) dprintf_level(3, args)</span>
<span class="p_del">-#define dprintf4(args...) dprintf_level(4, args)</span>
<span class="p_del">-</span>
<span class="p_del">-extern unsigned int shadow_pkru;</span>
<span class="p_del">-static inline unsigned int __rdpkru(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int eax, edx;</span>
<span class="p_del">-	unsigned int ecx = 0;</span>
<span class="p_del">-	unsigned int pkru;</span>
<span class="p_del">-</span>
<span class="p_del">-	asm volatile(&quot;.byte 0x0f,0x01,0xee\n\t&quot;</span>
<span class="p_del">-		     : &quot;=a&quot; (eax), &quot;=d&quot; (edx)</span>
<span class="p_del">-		     : &quot;c&quot; (ecx));</span>
<span class="p_del">-	pkru = eax;</span>
<span class="p_del">-	return pkru;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned int _rdpkru(int line)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int pkru = __rdpkru();</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf4(&quot;rdpkru(line=%d) pkru: %x shadow: %x\n&quot;,</span>
<span class="p_del">-			line, pkru, shadow_pkru);</span>
<span class="p_del">-	assert(pkru == shadow_pkru);</span>
<span class="p_del">-</span>
<span class="p_del">-	return pkru;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define rdpkru() _rdpkru(__LINE__)</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __wrpkru(unsigned int pkru)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int eax = pkru;</span>
<span class="p_del">-	unsigned int ecx = 0;</span>
<span class="p_del">-	unsigned int edx = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf4(&quot;%s() changing %08x to %08x\n&quot;, __func__, __rdpkru(), pkru);</span>
<span class="p_del">-	asm volatile(&quot;.byte 0x0f,0x01,0xef\n\t&quot;</span>
<span class="p_del">-		     : : &quot;a&quot; (eax), &quot;c&quot; (ecx), &quot;d&quot; (edx));</span>
<span class="p_del">-	assert(pkru == __rdpkru());</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void wrpkru(unsigned int pkru)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintf4(&quot;%s() changing %08x to %08x\n&quot;, __func__, __rdpkru(), pkru);</span>
<span class="p_del">-	/* will do the shadow check for us: */</span>
<span class="p_del">-	rdpkru();</span>
<span class="p_del">-	__wrpkru(pkru);</span>
<span class="p_del">-	shadow_pkru = pkru;</span>
<span class="p_del">-	dprintf4(&quot;%s(%08x) pkru: %08x\n&quot;, __func__, pkru, __rdpkru());</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * These are technically racy. since something could</span>
<span class="p_del">- * change PKRU between the read and the write.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void __pkey_access_allow(int pkey, int do_allow)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int pkru = rdpkru();</span>
<span class="p_del">-	int bit = pkey * 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (do_allow)</span>
<span class="p_del">-		pkru &amp;= (1&lt;&lt;bit);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		pkru |= (1&lt;&lt;bit);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf4(&quot;pkru now: %08x\n&quot;, rdpkru());</span>
<span class="p_del">-	wrpkru(pkru);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __pkey_write_allow(int pkey, int do_allow_write)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long pkru = rdpkru();</span>
<span class="p_del">-	int bit = pkey * 2 + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (do_allow_write)</span>
<span class="p_del">-		pkru &amp;= (1&lt;&lt;bit);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		pkru |= (1&lt;&lt;bit);</span>
<span class="p_del">-</span>
<span class="p_del">-	wrpkru(pkru);</span>
<span class="p_del">-	dprintf4(&quot;pkru now: %08x\n&quot;, rdpkru());</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define PROT_PKEY0     0x10            /* protection key value (bit 0) */</span>
<span class="p_del">-#define PROT_PKEY1     0x20            /* protection key value (bit 1) */</span>
<span class="p_del">-#define PROT_PKEY2     0x40            /* protection key value (bit 2) */</span>
<span class="p_del">-#define PROT_PKEY3     0x80            /* protection key value (bit 3) */</span>
<span class="p_del">-</span>
<span class="p_del">-#define PAGE_SIZE 4096</span>
<span class="p_del">-#define MB	(1&lt;&lt;20)</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __cpuid(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_del">-		unsigned int *ecx, unsigned int *edx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* ecx is often an input as well as an output. */</span>
<span class="p_del">-	asm volatile(</span>
<span class="p_del">-		&quot;cpuid;&quot;</span>
<span class="p_del">-		: &quot;=a&quot; (*eax),</span>
<span class="p_del">-		  &quot;=b&quot; (*ebx),</span>
<span class="p_del">-		  &quot;=c&quot; (*ecx),</span>
<span class="p_del">-		  &quot;=d&quot; (*edx)</span>
<span class="p_del">-		: &quot;0&quot; (*eax), &quot;2&quot; (*ecx));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Intel-defined CPU features, CPUID level 0x00000007:0 (ecx) */</span>
<span class="p_del">-#define X86_FEATURE_PKU        (1&lt;&lt;3) /* Protection Keys for Userspace */</span>
<span class="p_del">-#define X86_FEATURE_OSPKE      (1&lt;&lt;4) /* OS Protection Keys Enable */</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int cpu_has_pku(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int eax;</span>
<span class="p_del">-	unsigned int ebx;</span>
<span class="p_del">-	unsigned int ecx;</span>
<span class="p_del">-	unsigned int edx;</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = 0x7;</span>
<span class="p_del">-	ecx = 0x0;</span>
<span class="p_del">-	__cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(ecx &amp; X86_FEATURE_PKU)) {</span>
<span class="p_del">-		dprintf2(&quot;cpu does not have PKU\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!(ecx &amp; X86_FEATURE_OSPKE)) {</span>
<span class="p_del">-		dprintf2(&quot;cpu does not have OSPKE\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define XSTATE_PKRU_BIT	(9)</span>
<span class="p_del">-#define XSTATE_PKRU	0x200</span>
<span class="p_del">-</span>
<span class="p_del">-int pkru_xstate_offset(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int eax;</span>
<span class="p_del">-	unsigned int ebx;</span>
<span class="p_del">-	unsigned int ecx;</span>
<span class="p_del">-	unsigned int edx;</span>
<span class="p_del">-	int xstate_offset;</span>
<span class="p_del">-	int xstate_size;</span>
<span class="p_del">-	unsigned long XSTATE_CPUID = 0xd;</span>
<span class="p_del">-	int leaf;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* assume that XSTATE_PKRU is set in XCR0 */</span>
<span class="p_del">-	leaf = XSTATE_PKRU_BIT;</span>
<span class="p_del">-	{</span>
<span class="p_del">-		eax = XSTATE_CPUID;</span>
<span class="p_del">-		ecx = leaf;</span>
<span class="p_del">-		__cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (leaf == XSTATE_PKRU_BIT) {</span>
<span class="p_del">-			xstate_offset = ebx;</span>
<span class="p_del">-			xstate_size = eax;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xstate_size == 0) {</span>
<span class="p_del">-		printf(&quot;could not find size/offset of PKRU in xsave state\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return xstate_offset;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _PKEYS_HELPER_H */</span>
<span class="p_header">diff --git a/tools/testing/selftests/x86/protection_keys.c b/tools/testing/selftests/x86/protection_keys.c</span>
deleted file mode 100644
<span class="p_header">index 3237bc0..0000000</span>
<span class="p_header">--- a/tools/testing/selftests/x86/protection_keys.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,1395 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Tests x86 Memory Protection Keys (see Documentation/x86/protection-keys.txt)</span>
<span class="p_del">- *</span>
<span class="p_del">- * There are examples in here of:</span>
<span class="p_del">- *  * how to set protection keys on memory</span>
<span class="p_del">- *  * how to set/clear bits in PKRU (the rights register)</span>
<span class="p_del">- *  * how to handle SEGV_PKRU signals and extract pkey-relevant</span>
<span class="p_del">- *    information from the siginfo</span>
<span class="p_del">- *</span>
<span class="p_del">- * Things to add:</span>
<span class="p_del">- *	make sure KSM and KSM COW breaking works</span>
<span class="p_del">- *	prefault pages in at malloc, or not</span>
<span class="p_del">- *	protect MPX bounds tables with protection keys?</span>
<span class="p_del">- *	make sure VMA splitting/merging is working correctly</span>
<span class="p_del">- *	OOMs can destroy mm-&gt;mmap (see exit_mmap()), so make sure it is immune to pkeys</span>
<span class="p_del">- *	look for pkey &quot;leaks&quot; where it is still set on a VMA but &quot;freed&quot; back to the kernel</span>
<span class="p_del">- *	do a plain mprotect() to a mprotect_pkey() area and make sure the pkey sticks</span>
<span class="p_del">- *</span>
<span class="p_del">- * Compile like this:</span>
<span class="p_del">- *	gcc      -o protection_keys    -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm</span>
<span class="p_del">- *	gcc -m32 -o protection_keys_32 -O2 -g -std=gnu99 -pthread -Wall protection_keys.c -lrt -ldl -lm</span>
<span class="p_del">- */</span>
<span class="p_del">-#define _GNU_SOURCE</span>
<span class="p_del">-#include &lt;errno.h&gt;</span>
<span class="p_del">-#include &lt;linux/futex.h&gt;</span>
<span class="p_del">-#include &lt;sys/time.h&gt;</span>
<span class="p_del">-#include &lt;sys/syscall.h&gt;</span>
<span class="p_del">-#include &lt;string.h&gt;</span>
<span class="p_del">-#include &lt;stdio.h&gt;</span>
<span class="p_del">-#include &lt;stdint.h&gt;</span>
<span class="p_del">-#include &lt;stdbool.h&gt;</span>
<span class="p_del">-#include &lt;signal.h&gt;</span>
<span class="p_del">-#include &lt;assert.h&gt;</span>
<span class="p_del">-#include &lt;stdlib.h&gt;</span>
<span class="p_del">-#include &lt;ucontext.h&gt;</span>
<span class="p_del">-#include &lt;sys/mman.h&gt;</span>
<span class="p_del">-#include &lt;sys/types.h&gt;</span>
<span class="p_del">-#include &lt;sys/wait.h&gt;</span>
<span class="p_del">-#include &lt;sys/stat.h&gt;</span>
<span class="p_del">-#include &lt;fcntl.h&gt;</span>
<span class="p_del">-#include &lt;unistd.h&gt;</span>
<span class="p_del">-#include &lt;sys/ptrace.h&gt;</span>
<span class="p_del">-#include &lt;setjmp.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &quot;pkey-helpers.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-int iteration_nr = 1;</span>
<span class="p_del">-int test_nr;</span>
<span class="p_del">-</span>
<span class="p_del">-unsigned int shadow_pkru;</span>
<span class="p_del">-</span>
<span class="p_del">-#define HPAGE_SIZE	(1UL&lt;&lt;21)</span>
<span class="p_del">-#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*(x)))</span>
<span class="p_del">-#define ALIGN_UP(x, align_to)	(((x) + ((align_to)-1)) &amp; ~((align_to)-1))</span>
<span class="p_del">-#define ALIGN_DOWN(x, align_to) ((x) &amp; ~((align_to)-1))</span>
<span class="p_del">-#define ALIGN_PTR_UP(p, ptr_align_to)	((typeof(p))ALIGN_UP((unsigned long)(p),	ptr_align_to))</span>
<span class="p_del">-#define ALIGN_PTR_DOWN(p, ptr_align_to)	((typeof(p))ALIGN_DOWN((unsigned long)(p),	ptr_align_to))</span>
<span class="p_del">-#define __stringify_1(x...)     #x</span>
<span class="p_del">-#define __stringify(x...)       __stringify_1(x)</span>
<span class="p_del">-</span>
<span class="p_del">-#define PTR_ERR_ENOTSUP ((void *)-ENOTSUP)</span>
<span class="p_del">-</span>
<span class="p_del">-int dprint_in_signal;</span>
<span class="p_del">-char dprint_in_signal_buffer[DPRINT_IN_SIGNAL_BUF_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-extern void abort_hooks(void);</span>
<span class="p_del">-#define pkey_assert(condition) do {		\</span>
<span class="p_del">-	if (!(condition)) {			\</span>
<span class="p_del">-		dprintf0(&quot;assert() at %s::%d test_nr: %d iteration: %d\n&quot;, \</span>
<span class="p_del">-				__FILE__, __LINE__,	\</span>
<span class="p_del">-				test_nr, iteration_nr);	\</span>
<span class="p_del">-		dprintf0(&quot;errno at assert: %d&quot;, errno);	\</span>
<span class="p_del">-		abort_hooks();			\</span>
<span class="p_del">-		assert(condition);		\</span>
<span class="p_del">-	}					\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-#define raw_assert(cond) assert(cond)</span>
<span class="p_del">-</span>
<span class="p_del">-void cat_into_file(char *str, char *file)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int fd = open(file, O_RDWR);</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf2(&quot;%s(): writing &#39;%s&#39; to &#39;%s&#39;\n&quot;, __func__, str, file);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * these need to be raw because they are called under</span>
<span class="p_del">-	 * pkey_assert()</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	raw_assert(fd &gt;= 0);</span>
<span class="p_del">-	ret = write(fd, str, strlen(str));</span>
<span class="p_del">-	if (ret != strlen(str)) {</span>
<span class="p_del">-		perror(&quot;write to file failed&quot;);</span>
<span class="p_del">-		fprintf(stderr, &quot;filename: &#39;%s&#39; str: &#39;%s&#39;\n&quot;, file, str);</span>
<span class="p_del">-		raw_assert(0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	close(fd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#if CONTROL_TRACING &gt; 0</span>
<span class="p_del">-static int warned_tracing;</span>
<span class="p_del">-int tracing_root_ok(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (geteuid() != 0) {</span>
<span class="p_del">-		if (!warned_tracing)</span>
<span class="p_del">-			fprintf(stderr, &quot;WARNING: not run as root, &quot;</span>
<span class="p_del">-					&quot;can not do tracing control\n&quot;);</span>
<span class="p_del">-		warned_tracing = 1;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-void tracing_on(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#if CONTROL_TRACING &gt; 0</span>
<span class="p_del">-#define TRACEDIR &quot;/sys/kernel/debug/tracing&quot;</span>
<span class="p_del">-	char pidstr[32];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!tracing_root_ok())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	sprintf(pidstr, &quot;%d&quot;, getpid());</span>
<span class="p_del">-	cat_into_file(&quot;0&quot;, TRACEDIR &quot;/tracing_on&quot;);</span>
<span class="p_del">-	cat_into_file(&quot;\n&quot;, TRACEDIR &quot;/trace&quot;);</span>
<span class="p_del">-	if (1) {</span>
<span class="p_del">-		cat_into_file(&quot;function_graph&quot;, TRACEDIR &quot;/current_tracer&quot;);</span>
<span class="p_del">-		cat_into_file(&quot;1&quot;, TRACEDIR &quot;/options/funcgraph-proc&quot;);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		cat_into_file(&quot;nop&quot;, TRACEDIR &quot;/current_tracer&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	cat_into_file(pidstr, TRACEDIR &quot;/set_ftrace_pid&quot;);</span>
<span class="p_del">-	cat_into_file(&quot;1&quot;, TRACEDIR &quot;/tracing_on&quot;);</span>
<span class="p_del">-	dprintf1(&quot;enabled tracing\n&quot;);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void tracing_off(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#if CONTROL_TRACING &gt; 0</span>
<span class="p_del">-	if (!tracing_root_ok())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	cat_into_file(&quot;0&quot;, &quot;/sys/kernel/debug/tracing/tracing_on&quot;);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void abort_hooks(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	fprintf(stderr, &quot;running %s()...\n&quot;, __func__);</span>
<span class="p_del">-	tracing_off();</span>
<span class="p_del">-#ifdef SLEEP_ON_ABORT</span>
<span class="p_del">-	sleep(SLEEP_ON_ABORT);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __page_o_noops(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* 8-bytes of instruction * 512 bytes = 1 page */</span>
<span class="p_del">-	asm(&quot;.rept 512 ; nopl 0x7eeeeeee(%eax) ; .endr&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This attempts to have roughly a page of instructions followed by a few</span>
<span class="p_del">- * instructions that do a write, and another page of instructions.  That</span>
<span class="p_del">- * way, we are pretty sure that the write is in the second page of</span>
<span class="p_del">- * instructions and has at least a page of padding behind it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * *That* lets us be sure to madvise() away the write instruction, which</span>
<span class="p_del">- * will then fault, which makes sure that the fault code handles</span>
<span class="p_del">- * execute-only memory properly.</span>
<span class="p_del">- */</span>
<span class="p_del">-__attribute__((__aligned__(PAGE_SIZE)))</span>
<span class="p_del">-void lots_o_noops_around_write(int *write_to_me)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintf3(&quot;running %s()\n&quot;, __func__);</span>
<span class="p_del">-	__page_o_noops();</span>
<span class="p_del">-	/* Assume this happens in the second page of instructions: */</span>
<span class="p_del">-	*write_to_me = __LINE__;</span>
<span class="p_del">-	/* pad out by another page: */</span>
<span class="p_del">-	__page_o_noops();</span>
<span class="p_del">-	dprintf3(&quot;%s() done\n&quot;, __func__);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Define some kernel-like types */</span>
<span class="p_del">-#define  u8 uint8_t</span>
<span class="p_del">-#define u16 uint16_t</span>
<span class="p_del">-#define u32 uint32_t</span>
<span class="p_del">-#define u64 uint64_t</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef __i386__</span>
<span class="p_del">-#define SYS_mprotect_key 380</span>
<span class="p_del">-#define SYS_pkey_alloc	 381</span>
<span class="p_del">-#define SYS_pkey_free	 382</span>
<span class="p_del">-#define REG_IP_IDX REG_EIP</span>
<span class="p_del">-#define si_pkey_offset 0x14</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define SYS_mprotect_key 329</span>
<span class="p_del">-#define SYS_pkey_alloc	 330</span>
<span class="p_del">-#define SYS_pkey_free	 331</span>
<span class="p_del">-#define REG_IP_IDX REG_RIP</span>
<span class="p_del">-#define si_pkey_offset 0x20</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-void dump_mem(void *dumpme, int len_bytes)</span>
<span class="p_del">-{</span>
<span class="p_del">-	char *c = (void *)dumpme;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; len_bytes; i += sizeof(u64)) {</span>
<span class="p_del">-		u64 *ptr = (u64 *)(c + i);</span>
<span class="p_del">-		dprintf1(&quot;dump[%03d][@%p]: %016jx\n&quot;, i, ptr, *ptr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define __SI_FAULT      (3 &lt;&lt; 16)</span>
<span class="p_del">-#define SEGV_BNDERR     (__SI_FAULT|3)  /* failed address bound checks */</span>
<span class="p_del">-#define SEGV_PKUERR     (__SI_FAULT|4)</span>
<span class="p_del">-</span>
<span class="p_del">-static char *si_code_str(int si_code)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (si_code &amp; SEGV_MAPERR)</span>
<span class="p_del">-		return &quot;SEGV_MAPERR&quot;;</span>
<span class="p_del">-	if (si_code &amp; SEGV_ACCERR)</span>
<span class="p_del">-		return &quot;SEGV_ACCERR&quot;;</span>
<span class="p_del">-	if (si_code &amp; SEGV_BNDERR)</span>
<span class="p_del">-		return &quot;SEGV_BNDERR&quot;;</span>
<span class="p_del">-	if (si_code &amp; SEGV_PKUERR)</span>
<span class="p_del">-		return &quot;SEGV_PKUERR&quot;;</span>
<span class="p_del">-	return &quot;UNKNOWN&quot;;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int pkru_faults;</span>
<span class="p_del">-int last_si_pkey = -1;</span>
<span class="p_del">-void signal_handler(int signum, siginfo_t *si, void *vucontext)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ucontext_t *uctxt = vucontext;</span>
<span class="p_del">-	int trapno;</span>
<span class="p_del">-	unsigned long ip;</span>
<span class="p_del">-	char *fpregs;</span>
<span class="p_del">-	u32 *pkru_ptr;</span>
<span class="p_del">-	u64 si_pkey;</span>
<span class="p_del">-	u32 *si_pkey_ptr;</span>
<span class="p_del">-	int pkru_offset;</span>
<span class="p_del">-	fpregset_t fpregset;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprint_in_signal = 1;</span>
<span class="p_del">-	dprintf1(&quot;&gt;&gt;&gt;&gt;===============SIGSEGV============================\n&quot;);</span>
<span class="p_del">-	dprintf1(&quot;%s()::%d, pkru: 0x%x shadow: %x\n&quot;, __func__, __LINE__,</span>
<span class="p_del">-			__rdpkru(), shadow_pkru);</span>
<span class="p_del">-</span>
<span class="p_del">-	trapno = uctxt-&gt;uc_mcontext.gregs[REG_TRAPNO];</span>
<span class="p_del">-	ip = uctxt-&gt;uc_mcontext.gregs[REG_IP_IDX];</span>
<span class="p_del">-	fpregset = uctxt-&gt;uc_mcontext.fpregs;</span>
<span class="p_del">-	fpregs = (void *)fpregset;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf2(&quot;%s() trapno: %d ip: 0x%lx info-&gt;si_code: %s/%d\n&quot;, __func__,</span>
<span class="p_del">-			trapno, ip, si_code_str(si-&gt;si_code), si-&gt;si_code);</span>
<span class="p_del">-#ifdef __i386__</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 32-bit has some extra padding so that userspace can tell whether</span>
<span class="p_del">-	 * the XSTATE header is present in addition to the &quot;legacy&quot; FPU</span>
<span class="p_del">-	 * state.  We just assume that it is here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	fpregs += 0x70;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pkru_offset = pkru_xstate_offset();</span>
<span class="p_del">-	pkru_ptr = (void *)(&amp;fpregs[pkru_offset]);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;siginfo: %p\n&quot;, si);</span>
<span class="p_del">-	dprintf1(&quot; fpregs: %p\n&quot;, fpregs);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If we got a PKRU fault, we *HAVE* to have at least one bit set in</span>
<span class="p_del">-	 * here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dprintf1(&quot;pkru_xstate_offset: %d\n&quot;, pkru_xstate_offset());</span>
<span class="p_del">-	if (DEBUG_LEVEL &gt; 4)</span>
<span class="p_del">-		dump_mem(pkru_ptr - 128, 256);</span>
<span class="p_del">-	pkey_assert(*pkru_ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	si_pkey_ptr = (u32 *)(((u8 *)si) + si_pkey_offset);</span>
<span class="p_del">-	dprintf1(&quot;si_pkey_ptr: %p\n&quot;, si_pkey_ptr);</span>
<span class="p_del">-	dump_mem(si_pkey_ptr - 8, 24);</span>
<span class="p_del">-	si_pkey = *si_pkey_ptr;</span>
<span class="p_del">-	pkey_assert(si_pkey &lt; NR_PKEYS);</span>
<span class="p_del">-	last_si_pkey = si_pkey;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((si-&gt;si_code == SEGV_MAPERR) ||</span>
<span class="p_del">-	    (si-&gt;si_code == SEGV_ACCERR) ||</span>
<span class="p_del">-	    (si-&gt;si_code == SEGV_BNDERR)) {</span>
<span class="p_del">-		printf(&quot;non-PK si_code, exiting...\n&quot;);</span>
<span class="p_del">-		exit(4);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;signal pkru from xsave: %08x\n&quot;, *pkru_ptr);</span>
<span class="p_del">-	/* need __rdpkru() version so we do not do shadow_pkru checking */</span>
<span class="p_del">-	dprintf1(&quot;signal pkru from  pkru: %08x\n&quot;, __rdpkru());</span>
<span class="p_del">-	dprintf1(&quot;si_pkey from siginfo: %jx\n&quot;, si_pkey);</span>
<span class="p_del">-	*(u64 *)pkru_ptr = 0x00000000;</span>
<span class="p_del">-	dprintf1(&quot;WARNING: set PRKU=0 to allow faulting instruction to continue\n&quot;);</span>
<span class="p_del">-	pkru_faults++;</span>
<span class="p_del">-	dprintf1(&quot;&lt;&lt;&lt;&lt;==================================================\n&quot;);</span>
<span class="p_del">-	return;</span>
<span class="p_del">-	if (trapno == 14) {</span>
<span class="p_del">-		fprintf(stderr,</span>
<span class="p_del">-			&quot;ERROR: In signal handler, page fault, trapno = %d, ip = %016lx\n&quot;,</span>
<span class="p_del">-			trapno, ip);</span>
<span class="p_del">-		fprintf(stderr, &quot;si_addr %p\n&quot;, si-&gt;si_addr);</span>
<span class="p_del">-		fprintf(stderr, &quot;REG_ERR: %lx\n&quot;,</span>
<span class="p_del">-				(unsigned long)uctxt-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="p_del">-		exit(1);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		fprintf(stderr, &quot;unexpected trap %d! at 0x%lx\n&quot;, trapno, ip);</span>
<span class="p_del">-		fprintf(stderr, &quot;si_addr %p\n&quot;, si-&gt;si_addr);</span>
<span class="p_del">-		fprintf(stderr, &quot;REG_ERR: %lx\n&quot;,</span>
<span class="p_del">-				(unsigned long)uctxt-&gt;uc_mcontext.gregs[REG_ERR]);</span>
<span class="p_del">-		exit(2);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dprint_in_signal = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int wait_all_children(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int status;</span>
<span class="p_del">-	return waitpid(-1, &amp;status, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void sig_chld(int x)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprint_in_signal = 1;</span>
<span class="p_del">-	dprintf2(&quot;[%d] SIGCHLD: %d\n&quot;, getpid(), x);</span>
<span class="p_del">-	dprint_in_signal = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void setup_sigsegv_handler(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int r, rs;</span>
<span class="p_del">-	struct sigaction newact;</span>
<span class="p_del">-	struct sigaction oldact;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* #PF is mapped to sigsegv */</span>
<span class="p_del">-	int signum  = SIGSEGV;</span>
<span class="p_del">-</span>
<span class="p_del">-	newact.sa_handler = 0;</span>
<span class="p_del">-	newact.sa_sigaction = signal_handler;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*sigset_t - signals to block while in the handler */</span>
<span class="p_del">-	/* get the old signal mask. */</span>
<span class="p_del">-	rs = sigprocmask(SIG_SETMASK, 0, &amp;newact.sa_mask);</span>
<span class="p_del">-	pkey_assert(rs == 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* call sa_sigaction, not sa_handler*/</span>
<span class="p_del">-	newact.sa_flags = SA_SIGINFO;</span>
<span class="p_del">-</span>
<span class="p_del">-	newact.sa_restorer = 0;  /* void(*)(), obsolete */</span>
<span class="p_del">-	r = sigaction(signum, &amp;newact, &amp;oldact);</span>
<span class="p_del">-	r = sigaction(SIGALRM, &amp;newact, &amp;oldact);</span>
<span class="p_del">-	pkey_assert(r == 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void setup_handlers(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	signal(SIGCHLD, &amp;sig_chld);</span>
<span class="p_del">-	setup_sigsegv_handler();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-pid_t fork_lazy_child(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pid_t forkret;</span>
<span class="p_del">-</span>
<span class="p_del">-	forkret = fork();</span>
<span class="p_del">-	pkey_assert(forkret &gt;= 0);</span>
<span class="p_del">-	dprintf3(&quot;[%d] fork() ret: %d\n&quot;, getpid(), forkret);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!forkret) {</span>
<span class="p_del">-		/* in the child */</span>
<span class="p_del">-		while (1) {</span>
<span class="p_del">-			dprintf1(&quot;child sleeping...\n&quot;);</span>
<span class="p_del">-			sleep(30);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return forkret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void davecmp(void *_a, void *_b, int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	unsigned long *a = _a;</span>
<span class="p_del">-	unsigned long *b = _b;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; len / sizeof(*a); i++) {</span>
<span class="p_del">-		if (a[i] == b[i])</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf3(&quot;[%3d]: a: %016lx b: %016lx\n&quot;, i, a[i], b[i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void dumpit(char *f)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int fd = open(f, O_RDONLY);</span>
<span class="p_del">-	char buf[100];</span>
<span class="p_del">-	int nr_read;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf2(&quot;maps fd: %d\n&quot;, fd);</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		nr_read = read(fd, &amp;buf[0], sizeof(buf));</span>
<span class="p_del">-		write(1, buf, nr_read);</span>
<span class="p_del">-	} while (nr_read &gt; 0);</span>
<span class="p_del">-	close(fd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define PKEY_DISABLE_ACCESS    0x1</span>
<span class="p_del">-#define PKEY_DISABLE_WRITE     0x2</span>
<span class="p_del">-</span>
<span class="p_del">-u32 pkey_get(int pkey, unsigned long flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 mask = (PKEY_DISABLE_ACCESS|PKEY_DISABLE_WRITE);</span>
<span class="p_del">-	u32 pkru = __rdpkru();</span>
<span class="p_del">-	u32 shifted_pkru;</span>
<span class="p_del">-	u32 masked_pkru;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s(pkey=%d, flags=%lx) = %x / %d\n&quot;,</span>
<span class="p_del">-			__func__, pkey, flags, 0, 0);</span>
<span class="p_del">-	dprintf2(&quot;%s() raw pkru: %x\n&quot;, __func__, pkru);</span>
<span class="p_del">-</span>
<span class="p_del">-	shifted_pkru = (pkru &gt;&gt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_del">-	dprintf2(&quot;%s() shifted_pkru: %x\n&quot;, __func__, shifted_pkru);</span>
<span class="p_del">-	masked_pkru = shifted_pkru &amp; mask;</span>
<span class="p_del">-	dprintf2(&quot;%s() masked  pkru: %x\n&quot;, __func__, masked_pkru);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * shift down the relevant bits to the lowest two, then</span>
<span class="p_del">-	 * mask off all the other high bits.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return masked_pkru;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int pkey_set(int pkey, unsigned long rights, unsigned long flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 mask = (PKEY_DISABLE_ACCESS|PKEY_DISABLE_WRITE);</span>
<span class="p_del">-	u32 old_pkru = __rdpkru();</span>
<span class="p_del">-	u32 new_pkru;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* make sure that &#39;rights&#39; only contains the bits we expect: */</span>
<span class="p_del">-	assert(!(rights &amp; ~mask));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* copy old pkru */</span>
<span class="p_del">-	new_pkru = old_pkru;</span>
<span class="p_del">-	/* mask out bits from pkey in old value: */</span>
<span class="p_del">-	new_pkru &amp;= ~(mask &lt;&lt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_del">-	/* OR in new bits for pkey: */</span>
<span class="p_del">-	new_pkru |= (rights &lt;&lt; (pkey * PKRU_BITS_PER_PKEY));</span>
<span class="p_del">-</span>
<span class="p_del">-	__wrpkru(new_pkru);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf3(&quot;%s(pkey=%d, rights=%lx, flags=%lx) = %x pkru now: %x old_pkru: %x\n&quot;,</span>
<span class="p_del">-			__func__, pkey, rights, flags, 0, __rdpkru(), old_pkru);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pkey_disable_set(int pkey, int flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long syscall_flags = 0;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int pkey_rights;</span>
<span class="p_del">-	u32 orig_pkru = rdpkru();</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;START-&gt;%s(%d, 0x%x)\n&quot;, __func__,</span>
<span class="p_del">-		pkey, flags);</span>
<span class="p_del">-	pkey_assert(flags &amp; (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_del">-			pkey, pkey, pkey_rights);</span>
<span class="p_del">-	pkey_assert(pkey_rights &gt;= 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_rights |= flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = pkey_set(pkey, pkey_rights, syscall_flags);</span>
<span class="p_del">-	assert(!ret);</span>
<span class="p_del">-	/*pkru and flags have the same format */</span>
<span class="p_del">-	shadow_pkru |= flags &lt;&lt; (pkey * 2);</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) shadow: 0x%x\n&quot;, __func__, pkey, shadow_pkru);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_assert(ret &gt;= 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_del">-			pkey, pkey, pkey_rights);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkru: 0x%x\n&quot;, __func__, pkey, rdpkru());</span>
<span class="p_del">-	if (flags)</span>
<span class="p_del">-		pkey_assert(rdpkru() &gt; orig_pkru);</span>
<span class="p_del">-	dprintf1(&quot;END&lt;---%s(%d, 0x%x)\n&quot;, __func__,</span>
<span class="p_del">-		pkey, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pkey_disable_clear(int pkey, int flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long syscall_flags = 0;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_del">-	u32 orig_pkru = rdpkru();</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_assert(flags &amp; (PKEY_DISABLE_ACCESS | PKEY_DISABLE_WRITE));</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_del">-			pkey, pkey, pkey_rights);</span>
<span class="p_del">-	pkey_assert(pkey_rights &gt;= 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_rights |= flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = pkey_set(pkey, pkey_rights, 0);</span>
<span class="p_del">-	/* pkru and flags have the same format */</span>
<span class="p_del">-	shadow_pkru &amp;= ~(flags &lt;&lt; (pkey * 2));</span>
<span class="p_del">-	pkey_assert(ret &gt;= 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_rights = pkey_get(pkey, syscall_flags);</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkey_get(%d): %x\n&quot;, __func__,</span>
<span class="p_del">-			pkey, pkey, pkey_rights);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s(%d) pkru: 0x%x\n&quot;, __func__, pkey, rdpkru());</span>
<span class="p_del">-	if (flags)</span>
<span class="p_del">-		assert(rdpkru() &gt; orig_pkru);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pkey_write_allow(int pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_disable_clear(pkey, PKEY_DISABLE_WRITE);</span>
<span class="p_del">-}</span>
<span class="p_del">-void pkey_write_deny(int pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_disable_set(pkey, PKEY_DISABLE_WRITE);</span>
<span class="p_del">-}</span>
<span class="p_del">-void pkey_access_allow(int pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_disable_clear(pkey, PKEY_DISABLE_ACCESS);</span>
<span class="p_del">-}</span>
<span class="p_del">-void pkey_access_deny(int pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_disable_set(pkey, PKEY_DISABLE_ACCESS);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int sys_mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,</span>
<span class="p_del">-		unsigned long pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf2(&quot;%s(0x%p, %zx, prot=%lx, pkey=%lx)\n&quot;, __func__,</span>
<span class="p_del">-			ptr, size, orig_prot, pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	errno = 0;</span>
<span class="p_del">-	sret = syscall(SYS_mprotect_key, ptr, size, orig_prot, pkey);</span>
<span class="p_del">-	if (errno) {</span>
<span class="p_del">-		dprintf2(&quot;SYS_mprotect_key sret: %d\n&quot;, sret);</span>
<span class="p_del">-		dprintf2(&quot;SYS_mprotect_key prot: 0x%lx\n&quot;, orig_prot);</span>
<span class="p_del">-		dprintf2(&quot;SYS_mprotect_key failed, errno: %d\n&quot;, errno);</span>
<span class="p_del">-		if (DEBUG_LEVEL &gt;= 2)</span>
<span class="p_del">-			perror(&quot;SYS_mprotect_pkey&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return sret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int sys_pkey_alloc(unsigned long flags, unsigned long init_val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret = syscall(SYS_pkey_alloc, flags, init_val);</span>
<span class="p_del">-	dprintf1(&quot;%s(flags=%lx, init_val=%lx) syscall ret: %d errno: %d\n&quot;,</span>
<span class="p_del">-			__func__, flags, init_val, ret, errno);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int alloc_pkey(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	unsigned long init_val = 0x0;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;alloc_pkey()::%d, pkru: 0x%x shadow: %x\n&quot;,</span>
<span class="p_del">-			__LINE__, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	ret = sys_pkey_alloc(0, init_val);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * pkey_alloc() sets PKRU, so we need to reflect it in</span>
<span class="p_del">-	 * shadow_pkru:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/* clear both the bits: */</span>
<span class="p_del">-		shadow_pkru &amp;= ~(0x3      &lt;&lt; (ret * 2));</span>
<span class="p_del">-		dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_del">-				__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * move the new state in from init_val</span>
<span class="p_del">-		 * (remember, we cheated and init_val == pkru format)</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		shadow_pkru |=  (init_val &lt;&lt; (ret * 2));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	dprintf1(&quot;alloc_pkey()::%d errno: %d\n&quot;, __LINE__, errno);</span>
<span class="p_del">-	/* for shadow checking: */</span>
<span class="p_del">-	rdpkru();</span>
<span class="p_del">-	dprintf4(&quot;alloc_pkey()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int sys_pkey_free(unsigned long pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret = syscall(SYS_pkey_free, pkey);</span>
<span class="p_del">-	dprintf1(&quot;%s(pkey=%ld) syscall ret: %d\n&quot;, __func__, pkey, ret);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * I had a bug where pkey bits could be set by mprotect() but</span>
<span class="p_del">- * not cleared.  This ensures we get lots of random bit sets</span>
<span class="p_del">- * and clears on the vma and pte pkey bits.</span>
<span class="p_del">- */</span>
<span class="p_del">-int alloc_random_pkey(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int max_nr_pkey_allocs;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	int alloced_pkeys[NR_PKEYS];</span>
<span class="p_del">-	int nr_alloced = 0;</span>
<span class="p_del">-	int random_index;</span>
<span class="p_del">-	memset(alloced_pkeys, 0, sizeof(alloced_pkeys));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* allocate every possible key and make a note of which ones we got */</span>
<span class="p_del">-	max_nr_pkey_allocs = NR_PKEYS;</span>
<span class="p_del">-	max_nr_pkey_allocs = 1;</span>
<span class="p_del">-	for (i = 0; i &lt; max_nr_pkey_allocs; i++) {</span>
<span class="p_del">-		int new_pkey = alloc_pkey();</span>
<span class="p_del">-		if (new_pkey &lt; 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		alloced_pkeys[nr_alloced++] = new_pkey;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_assert(nr_alloced &gt; 0);</span>
<span class="p_del">-	/* select a random one out of the allocated ones */</span>
<span class="p_del">-	random_index = rand() % nr_alloced;</span>
<span class="p_del">-	ret = alloced_pkeys[random_index];</span>
<span class="p_del">-	/* now zero it out so we don&#39;t free it next */</span>
<span class="p_del">-	alloced_pkeys[random_index] = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* go through the allocated ones that we did not want and free them */</span>
<span class="p_del">-	for (i = 0; i &lt; nr_alloced; i++) {</span>
<span class="p_del">-		int free_ret;</span>
<span class="p_del">-		if (!alloced_pkeys[i])</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		free_ret = sys_pkey_free(alloced_pkeys[i]);</span>
<span class="p_del">-		pkey_assert(!free_ret);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int mprotect_pkey(void *ptr, size_t size, unsigned long orig_prot,</span>
<span class="p_del">-		unsigned long pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int nr_iterations = random() % 100;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (0) {</span>
<span class="p_del">-		int rpkey = alloc_random_pkey();</span>
<span class="p_del">-		ret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);</span>
<span class="p_del">-		dprintf1(&quot;sys_mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\n&quot;,</span>
<span class="p_del">-				ptr, size, orig_prot, pkey, ret);</span>
<span class="p_del">-		if (nr_iterations-- &lt; 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-		sys_pkey_free(rpkey);</span>
<span class="p_del">-		dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = sys_mprotect_pkey(ptr, size, orig_prot, pkey);</span>
<span class="p_del">-	dprintf1(&quot;mprotect_pkey(%p, %zx, prot=0x%lx, pkey=%ld) ret: %d\n&quot;,</span>
<span class="p_del">-			ptr, size, orig_prot, pkey, ret);</span>
<span class="p_del">-	pkey_assert(!ret);</span>
<span class="p_del">-	dprintf1(&quot;%s()::%d, ret: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_del">-			__LINE__, ret, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-struct pkey_malloc_record {</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-	long size;</span>
<span class="p_del">-};</span>
<span class="p_del">-struct pkey_malloc_record *pkey_malloc_records;</span>
<span class="p_del">-long nr_pkey_malloc_records;</span>
<span class="p_del">-void record_pkey_malloc(void *ptr, long size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long i;</span>
<span class="p_del">-	struct pkey_malloc_record *rec = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; nr_pkey_malloc_records; i++) {</span>
<span class="p_del">-		rec = &amp;pkey_malloc_records[i];</span>
<span class="p_del">-		/* find a free record */</span>
<span class="p_del">-		if (rec)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!rec) {</span>
<span class="p_del">-		/* every record is full */</span>
<span class="p_del">-		size_t old_nr_records = nr_pkey_malloc_records;</span>
<span class="p_del">-		size_t new_nr_records = (nr_pkey_malloc_records * 2 + 1);</span>
<span class="p_del">-		size_t new_size = new_nr_records * sizeof(struct pkey_malloc_record);</span>
<span class="p_del">-		dprintf2(&quot;new_nr_records: %zd\n&quot;, new_nr_records);</span>
<span class="p_del">-		dprintf2(&quot;new_size: %zd\n&quot;, new_size);</span>
<span class="p_del">-		pkey_malloc_records = realloc(pkey_malloc_records, new_size);</span>
<span class="p_del">-		pkey_assert(pkey_malloc_records != NULL);</span>
<span class="p_del">-		rec = &amp;pkey_malloc_records[nr_pkey_malloc_records];</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * realloc() does not initialize memory, so zero it from</span>
<span class="p_del">-		 * the first new record all the way to the end.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		for (i = 0; i &lt; new_nr_records - old_nr_records; i++)</span>
<span class="p_del">-			memset(rec + i, 0, sizeof(*rec));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dprintf3(&quot;filling malloc record[%d/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_del">-		(int)(rec - pkey_malloc_records), rec, ptr, size);</span>
<span class="p_del">-	rec-&gt;ptr = ptr;</span>
<span class="p_del">-	rec-&gt;size = size;</span>
<span class="p_del">-	nr_pkey_malloc_records++;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void free_pkey_malloc(void *ptr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long i;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	dprintf3(&quot;%s(%p)\n&quot;, __func__, ptr);</span>
<span class="p_del">-	for (i = 0; i &lt; nr_pkey_malloc_records; i++) {</span>
<span class="p_del">-		struct pkey_malloc_record *rec = &amp;pkey_malloc_records[i];</span>
<span class="p_del">-		dprintf4(&quot;looking for ptr %p at record[%ld/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_del">-				ptr, i, rec, rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_del">-		if ((ptr &lt;  rec-&gt;ptr) ||</span>
<span class="p_del">-		    (ptr &gt;= rec-&gt;ptr + rec-&gt;size))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf3(&quot;found ptr %p at record[%ld/%p]: {%p, %ld}\n&quot;,</span>
<span class="p_del">-				ptr, i, rec, rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_del">-		nr_pkey_malloc_records--;</span>
<span class="p_del">-		ret = munmap(rec-&gt;ptr, rec-&gt;size);</span>
<span class="p_del">-		dprintf3(&quot;munmap ret: %d\n&quot;, ret);</span>
<span class="p_del">-		pkey_assert(!ret);</span>
<span class="p_del">-		dprintf3(&quot;clearing rec-&gt;ptr, rec: %p\n&quot;, rec);</span>
<span class="p_del">-		rec-&gt;ptr = NULL;</span>
<span class="p_del">-		dprintf3(&quot;done clearing rec-&gt;ptr, rec: %p\n&quot;, rec);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	pkey_assert(false);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-void *malloc_pkey_with_mprotect(long size, int prot, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	rdpkru();</span>
<span class="p_del">-	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_del">-			size, prot, pkey);</span>
<span class="p_del">-	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_del">-	ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_del">-	pkey_assert(ptr != (void *)-1);</span>
<span class="p_del">-	ret = mprotect_pkey((void *)ptr, PAGE_SIZE, prot, pkey);</span>
<span class="p_del">-	pkey_assert(!ret);</span>
<span class="p_del">-	record_pkey_malloc(ptr, size);</span>
<span class="p_del">-	rdpkru();</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;%s() for pkey %d @ %p\n&quot;, __func__, pkey, ptr);</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void *malloc_pkey_anon_huge(long size, int prot, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_del">-			size, prot, pkey);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Guarantee we can fit at least one huge page in the resulting</span>
<span class="p_del">-	 * allocation by allocating space for 2:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	size = ALIGN_UP(size, HPAGE_SIZE * 2);</span>
<span class="p_del">-	ptr = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_del">-	pkey_assert(ptr != (void *)-1);</span>
<span class="p_del">-	record_pkey_malloc(ptr, size);</span>
<span class="p_del">-	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;unaligned ptr: %p\n&quot;, ptr);</span>
<span class="p_del">-	ptr = ALIGN_PTR_UP(ptr, HPAGE_SIZE);</span>
<span class="p_del">-	dprintf1(&quot;  aligned ptr: %p\n&quot;, ptr);</span>
<span class="p_del">-	ret = madvise(ptr, HPAGE_SIZE, MADV_HUGEPAGE);</span>
<span class="p_del">-	dprintf1(&quot;MADV_HUGEPAGE ret: %d\n&quot;, ret);</span>
<span class="p_del">-	ret = madvise(ptr, HPAGE_SIZE, MADV_WILLNEED);</span>
<span class="p_del">-	dprintf1(&quot;MADV_WILLNEED ret: %d\n&quot;, ret);</span>
<span class="p_del">-	memset(ptr, 0, HPAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;mmap()&#39;d thp for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int hugetlb_setup_ok;</span>
<span class="p_del">-#define GET_NR_HUGE_PAGES 10</span>
<span class="p_del">-void setup_hugetlbfs(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	int fd;</span>
<span class="p_del">-	char buf[] = &quot;123&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (geteuid() != 0) {</span>
<span class="p_del">-		fprintf(stderr, &quot;WARNING: not run as root, can not do hugetlb test\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cat_into_file(__stringify(GET_NR_HUGE_PAGES), &quot;/proc/sys/vm/nr_hugepages&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now go make sure that we got the pages and that they</span>
<span class="p_del">-	 * are 2M pages.  Someone might have made 1G the default.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	fd = open(&quot;/sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages&quot;, O_RDONLY);</span>
<span class="p_del">-	if (fd &lt; 0) {</span>
<span class="p_del">-		perror(&quot;opening sysfs 2M hugetlb config&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* -1 to guarantee leaving the trailing \0 */</span>
<span class="p_del">-	err = read(fd, buf, sizeof(buf)-1);</span>
<span class="p_del">-	close(fd);</span>
<span class="p_del">-	if (err &lt;= 0) {</span>
<span class="p_del">-		perror(&quot;reading sysfs 2M hugetlb config&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (atoi(buf) != GET_NR_HUGE_PAGES) {</span>
<span class="p_del">-		fprintf(stderr, &quot;could not confirm 2M pages, got: &#39;%s&#39; expected %d\n&quot;,</span>
<span class="p_del">-			buf, GET_NR_HUGE_PAGES);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	hugetlb_setup_ok = 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void *malloc_pkey_hugetlb(long size, int prot, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-	int flags = MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!hugetlb_setup_ok)</span>
<span class="p_del">-		return PTR_ERR_ENOTSUP;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;doing %s(%ld, %x, %x)\n&quot;, __func__, size, prot, pkey);</span>
<span class="p_del">-	size = ALIGN_UP(size, HPAGE_SIZE * 2);</span>
<span class="p_del">-	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_del">-	ptr = mmap(NULL, size, PROT_NONE, flags, -1, 0);</span>
<span class="p_del">-	pkey_assert(ptr != (void *)-1);</span>
<span class="p_del">-	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	record_pkey_malloc(ptr, size);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;mmap()&#39;d hugetlbfs for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void *malloc_pkey_mmap_dax(long size, int prot, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-	int fd;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;doing %s(size=%ld, prot=0x%x, pkey=%d)\n&quot;, __func__,</span>
<span class="p_del">-			size, prot, pkey);</span>
<span class="p_del">-	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_del">-	fd = open(&quot;/dax/foo&quot;, O_RDWR);</span>
<span class="p_del">-	pkey_assert(fd &gt;= 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	ptr = mmap(0, size, prot, MAP_SHARED, fd, 0);</span>
<span class="p_del">-	pkey_assert(ptr != (void *)-1);</span>
<span class="p_del">-</span>
<span class="p_del">-	mprotect_pkey(ptr, size, prot, pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	record_pkey_malloc(ptr, size);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;mmap()&#39;d for pkey %d @ %p\n&quot;, pkey, ptr);</span>
<span class="p_del">-	close(fd);</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void *(*pkey_malloc[])(long size, int prot, u16 pkey) = {</span>
<span class="p_del">-</span>
<span class="p_del">-	malloc_pkey_with_mprotect,</span>
<span class="p_del">-	malloc_pkey_anon_huge,</span>
<span class="p_del">-	malloc_pkey_hugetlb</span>
<span class="p_del">-/* can not do direct with the pkey_mprotect() API:</span>
<span class="p_del">-	malloc_pkey_mmap_direct,</span>
<span class="p_del">-	malloc_pkey_mmap_dax,</span>
<span class="p_del">-*/</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-void *malloc_pkey(long size, int prot, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *ret;</span>
<span class="p_del">-	static int malloc_type;</span>
<span class="p_del">-	int nr_malloc_types = ARRAY_SIZE(pkey_malloc);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_assert(pkey &lt; NR_PKEYS);</span>
<span class="p_del">-</span>
<span class="p_del">-	while (1) {</span>
<span class="p_del">-		pkey_assert(malloc_type &lt; nr_malloc_types);</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = pkey_malloc[malloc_type](size, prot, pkey);</span>
<span class="p_del">-		pkey_assert(ret != (void *)-1);</span>
<span class="p_del">-</span>
<span class="p_del">-		malloc_type++;</span>
<span class="p_del">-		if (malloc_type &gt;= nr_malloc_types)</span>
<span class="p_del">-			malloc_type = (random()%nr_malloc_types);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* try again if the malloc_type we tried is unsupported */</span>
<span class="p_del">-		if (ret == PTR_ERR_ENOTSUP)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf3(&quot;%s(%ld, prot=%x, pkey=%x) returning: %p\n&quot;, __func__,</span>
<span class="p_del">-			size, prot, pkey, ret);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int last_pkru_faults;</span>
<span class="p_del">-void expected_pk_fault(int pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintf2(&quot;%s(): last_pkru_faults: %d pkru_faults: %d\n&quot;,</span>
<span class="p_del">-			__func__, last_pkru_faults, pkru_faults);</span>
<span class="p_del">-	dprintf2(&quot;%s(%d): last_si_pkey: %d\n&quot;, __func__, pkey, last_si_pkey);</span>
<span class="p_del">-	pkey_assert(last_pkru_faults + 1 == pkru_faults);</span>
<span class="p_del">-	pkey_assert(last_si_pkey == pkey);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The signal handler shold have cleared out PKRU to let the</span>
<span class="p_del">-	 * test program continue.  We now have to restore it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (__rdpkru() != 0)</span>
<span class="p_del">-		pkey_assert(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	__wrpkru(shadow_pkru);</span>
<span class="p_del">-	dprintf1(&quot;%s() set PKRU=%x to restore state after signal nuked it\n&quot;,</span>
<span class="p_del">-			__func__, shadow_pkru);</span>
<span class="p_del">-	last_pkru_faults = pkru_faults;</span>
<span class="p_del">-	last_si_pkey = -1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void do_not_expect_pk_fault(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_assert(last_pkru_faults == pkru_faults);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int test_fds[10] = { -1 };</span>
<span class="p_del">-int nr_test_fds;</span>
<span class="p_del">-void __save_test_fd(int fd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pkey_assert(fd &gt;= 0);</span>
<span class="p_del">-	pkey_assert(nr_test_fds &lt; ARRAY_SIZE(test_fds));</span>
<span class="p_del">-	test_fds[nr_test_fds] = fd;</span>
<span class="p_del">-	nr_test_fds++;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int get_test_read_fd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int test_fd = open(&quot;/etc/passwd&quot;, O_RDONLY);</span>
<span class="p_del">-	__save_test_fd(test_fd);</span>
<span class="p_del">-	return test_fd;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void close_test_fds(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; nr_test_fds; i++) {</span>
<span class="p_del">-		if (test_fds[i] &lt; 0)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		close(test_fds[i]);</span>
<span class="p_del">-		test_fds[i] = -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	nr_test_fds = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span>
<span class="p_del">-__attribute__((noinline)) int read_ptr(int *ptr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Keep GCC from optimizing this away somehow</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	barrier();</span>
<span class="p_del">-	return *ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_read_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ptr_contents;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;disabling write access to PKEY[1], doing read\n&quot;);</span>
<span class="p_del">-	pkey_write_deny(pkey);</span>
<span class="p_del">-	ptr_contents = read_ptr(ptr);</span>
<span class="p_del">-	dprintf1(&quot;*ptr: %d\n&quot;, ptr_contents);</span>
<span class="p_del">-	dprintf1(&quot;\n&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-void test_read_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ptr_contents;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;disabling access to PKEY[%02d], doing read @ %p\n&quot;, pkey, ptr);</span>
<span class="p_del">-	rdpkru();</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-	ptr_contents = read_ptr(ptr);</span>
<span class="p_del">-	dprintf1(&quot;*ptr: %d\n&quot;, ptr_contents);</span>
<span class="p_del">-	expected_pk_fault(pkey);</span>
<span class="p_del">-}</span>
<span class="p_del">-void test_write_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintf1(&quot;disabling write access to PKEY[%02d], doing write\n&quot;, pkey);</span>
<span class="p_del">-	pkey_write_deny(pkey);</span>
<span class="p_del">-	*ptr = __LINE__;</span>
<span class="p_del">-	expected_pk_fault(pkey);</span>
<span class="p_del">-}</span>
<span class="p_del">-void test_write_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintf1(&quot;disabling access to PKEY[%02d], doing write\n&quot;, pkey);</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-	*ptr = __LINE__;</span>
<span class="p_del">-	expected_pk_fault(pkey);</span>
<span class="p_del">-}</span>
<span class="p_del">-void test_kernel_write_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int test_fd = get_test_read_fd();</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;disabling access to PKEY[%02d], &quot;</span>
<span class="p_del">-		 &quot;having kernel read() to buffer\n&quot;, pkey);</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-	ret = read(test_fd, ptr, 1);</span>
<span class="p_del">-	dprintf1(&quot;read ret: %d\n&quot;, ret);</span>
<span class="p_del">-	pkey_assert(ret);</span>
<span class="p_del">-}</span>
<span class="p_del">-void test_kernel_write_of_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	int test_fd = get_test_read_fd();</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_write_deny(pkey);</span>
<span class="p_del">-	ret = read(test_fd, ptr, 100);</span>
<span class="p_del">-	dprintf1(&quot;read ret: %d\n&quot;, ret);</span>
<span class="p_del">-	if (ret &lt; 0 &amp;&amp; (DEBUG_LEVEL &gt; 0))</span>
<span class="p_del">-		perror(&quot;verbose read result (OK for this to be bad)&quot;);</span>
<span class="p_del">-	pkey_assert(ret);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_kernel_gup_of_access_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int pipe_ret, vmsplice_ret;</span>
<span class="p_del">-	struct iovec iov;</span>
<span class="p_del">-	int pipe_fds[2];</span>
<span class="p_del">-</span>
<span class="p_del">-	pipe_ret = pipe(pipe_fds);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_assert(pipe_ret == 0);</span>
<span class="p_del">-	dprintf1(&quot;disabling access to PKEY[%02d], &quot;</span>
<span class="p_del">-		 &quot;having kernel vmsplice from buffer\n&quot;, pkey);</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-	iov.iov_base = ptr;</span>
<span class="p_del">-	iov.iov_len = PAGE_SIZE;</span>
<span class="p_del">-	vmsplice_ret = vmsplice(pipe_fds[1], &amp;iov, 1, SPLICE_F_GIFT);</span>
<span class="p_del">-	dprintf1(&quot;vmsplice() ret: %d\n&quot;, vmsplice_ret);</span>
<span class="p_del">-	pkey_assert(vmsplice_ret == -1);</span>
<span class="p_del">-</span>
<span class="p_del">-	close(pipe_fds[0]);</span>
<span class="p_del">-	close(pipe_fds[1]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_kernel_gup_write_to_write_disabled_region(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ignored = 0xdada;</span>
<span class="p_del">-	int futex_ret;</span>
<span class="p_del">-	int some_int = __LINE__;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf1(&quot;disabling write to PKEY[%02d], &quot;</span>
<span class="p_del">-		 &quot;doing futex gunk in buffer\n&quot;, pkey);</span>
<span class="p_del">-	*ptr = some_int;</span>
<span class="p_del">-	pkey_write_deny(pkey);</span>
<span class="p_del">-	futex_ret = syscall(SYS_futex, ptr, FUTEX_WAIT, some_int-1, NULL,</span>
<span class="p_del">-			&amp;ignored, ignored);</span>
<span class="p_del">-	if (DEBUG_LEVEL &gt; 0)</span>
<span class="p_del">-		perror(&quot;futex&quot;);</span>
<span class="p_del">-	dprintf1(&quot;futex() ret: %d\n&quot;, futex_ret);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_del">-void test_pkey_syscalls_on_non_allocated_pkey(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Note: 0 is the default pkey, so don&#39;t mess with it */</span>
<span class="p_del">-	for (i = 1; i &lt; NR_PKEYS; i++) {</span>
<span class="p_del">-		if (pkey == i)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf1(&quot;trying get/set/free to non-allocated pkey: %2d\n&quot;, i);</span>
<span class="p_del">-		err = sys_pkey_free(i);</span>
<span class="p_del">-		pkey_assert(err);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = sys_pkey_free(i);</span>
<span class="p_del">-		pkey_assert(err);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, i);</span>
<span class="p_del">-		pkey_assert(err);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_del">-void test_pkey_syscalls_bad_args(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	int bad_pkey = NR_PKEYS+99;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* pass a known-invalid pkey in: */</span>
<span class="p_del">-	err = sys_mprotect_pkey(ptr, PAGE_SIZE, PROT_READ, bad_pkey);</span>
<span class="p_del">-	pkey_assert(err);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Assumes that all pkeys other than &#39;pkey&#39; are unallocated */</span>
<span class="p_del">-void test_pkey_alloc_exhaust(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	int allocated_pkeys[NR_PKEYS] = {0};</span>
<span class="p_del">-	int nr_allocated_pkeys = 0;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; NR_PKEYS*2; i++) {</span>
<span class="p_del">-		int new_pkey;</span>
<span class="p_del">-		dprintf1(&quot;%s() alloc loop: %d\n&quot;, __func__, i);</span>
<span class="p_del">-		new_pkey = alloc_pkey();</span>
<span class="p_del">-		dprintf4(&quot;%s()::%d, err: %d pkru: 0x%x shadow: 0x%x\n&quot;, __func__,</span>
<span class="p_del">-				__LINE__, err, __rdpkru(), shadow_pkru);</span>
<span class="p_del">-		rdpkru(); /* for shadow checking */</span>
<span class="p_del">-		dprintf2(&quot;%s() errno: %d ENOSPC: %d\n&quot;, __func__, errno, ENOSPC);</span>
<span class="p_del">-		if ((new_pkey == -1) &amp;&amp; (errno == ENOSPC)) {</span>
<span class="p_del">-			dprintf2(&quot;%s() failed to allocate pkey after %d tries\n&quot;,</span>
<span class="p_del">-				__func__, nr_allocated_pkeys);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pkey_assert(nr_allocated_pkeys &lt; NR_PKEYS);</span>
<span class="p_del">-		allocated_pkeys[nr_allocated_pkeys++] = new_pkey;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf3(&quot;%s()::%d\n&quot;, __func__, __LINE__);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * ensure it did not reach the end of the loop without</span>
<span class="p_del">-	 * failure:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pkey_assert(i &lt; NR_PKEYS*2);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There are 16 pkeys supported in hardware.  One is taken</span>
<span class="p_del">-	 * up for the default (0) and another can be taken up by</span>
<span class="p_del">-	 * an execute-only mapping.  Ensure that we can allocate</span>
<span class="p_del">-	 * at least 14 (16-2).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pkey_assert(i &gt;= NR_PKEYS-2);</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; nr_allocated_pkeys; i++) {</span>
<span class="p_del">-		err = sys_pkey_free(allocated_pkeys[i]);</span>
<span class="p_del">-		pkey_assert(!err);</span>
<span class="p_del">-		rdpkru(); /* for shadow checking */</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_ptrace_of_child(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__attribute__((__unused__)) int peek_result;</span>
<span class="p_del">-	pid_t child_pid;</span>
<span class="p_del">-	void *ignored = 0;</span>
<span class="p_del">-	long ret;</span>
<span class="p_del">-	int status;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is the &quot;control&quot; for our little expermient.  Make sure</span>
<span class="p_del">-	 * we can always access it when ptracing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	int *plain_ptr_unaligned = malloc(HPAGE_SIZE);</span>
<span class="p_del">-	int *plain_ptr = ALIGN_PTR_UP(plain_ptr_unaligned, PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Fork a child which is an exact copy of this process, of course.</span>
<span class="p_del">-	 * That means we can do all of our tests via ptrace() and then plain</span>
<span class="p_del">-	 * memory access and ensure they work differently.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	child_pid = fork_lazy_child();</span>
<span class="p_del">-	dprintf1(&quot;[%d] child pid: %d\n&quot;, getpid(), child_pid);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = ptrace(PTRACE_ATTACH, child_pid, ignored, ignored);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		perror(&quot;attach&quot;);</span>
<span class="p_del">-	dprintf1(&quot;[%d] attach ret: %ld %d\n&quot;, getpid(), ret, __LINE__);</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-	ret = waitpid(child_pid, &amp;status, WUNTRACED);</span>
<span class="p_del">-	if ((ret != child_pid) || !(WIFSTOPPED(status))) {</span>
<span class="p_del">-		fprintf(stderr, &quot;weird waitpid result %ld stat %x\n&quot;,</span>
<span class="p_del">-				ret, status);</span>
<span class="p_del">-		pkey_assert(0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dprintf2(&quot;waitpid ret: %ld\n&quot;, ret);</span>
<span class="p_del">-	dprintf2(&quot;waitpid status: %d\n&quot;, status);</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-	pkey_write_deny(pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Write access, untested for now:</span>
<span class="p_del">-	ret = ptrace(PTRACE_POKEDATA, child_pid, peek_at, data);</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-	dprintf1(&quot;poke at %p: %ld\n&quot;, peek_at, ret);</span>
<span class="p_del">-	*/</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Try to access the pkey-protected &quot;ptr&quot; via ptrace:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = ptrace(PTRACE_PEEKDATA, child_pid, ptr, ignored);</span>
<span class="p_del">-	/* expect it to work, without an error: */</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-	/* Now access from the current task, and expect an exception: */</span>
<span class="p_del">-	peek_result = read_ptr(ptr);</span>
<span class="p_del">-	expected_pk_fault(pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Try to access the NON-pkey-protected &quot;plain_ptr&quot; via ptrace:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = ptrace(PTRACE_PEEKDATA, child_pid, plain_ptr, ignored);</span>
<span class="p_del">-	/* expect it to work, without an error: */</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-	/* Now access from the current task, and expect NO exception: */</span>
<span class="p_del">-	peek_result = read_ptr(plain_ptr);</span>
<span class="p_del">-	do_not_expect_pk_fault();</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = ptrace(PTRACE_DETACH, child_pid, ignored, 0);</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = kill(child_pid, SIGKILL);</span>
<span class="p_del">-	pkey_assert(ret != -1);</span>
<span class="p_del">-</span>
<span class="p_del">-	wait(&amp;status);</span>
<span class="p_del">-</span>
<span class="p_del">-	free(plain_ptr_unaligned);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_executing_on_unreadable_memory(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *p1;</span>
<span class="p_del">-	int scratch;</span>
<span class="p_del">-	int ptr_contents;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	p1 = ALIGN_PTR_UP(&amp;lots_o_noops_around_write, PAGE_SIZE);</span>
<span class="p_del">-	dprintf3(&quot;&amp;lots_o_noops: %p\n&quot;, &amp;lots_o_noops_around_write);</span>
<span class="p_del">-	/* lots_o_noops_around_write should be page-aligned already */</span>
<span class="p_del">-	assert(p1 == &amp;lots_o_noops_around_write);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Point &#39;p1&#39; at the *second* page of the function: */</span>
<span class="p_del">-	p1 += PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	madvise(p1, PAGE_SIZE, MADV_DONTNEED);</span>
<span class="p_del">-	lots_o_noops_around_write(&amp;scratch);</span>
<span class="p_del">-	ptr_contents = read_ptr(p1);</span>
<span class="p_del">-	dprintf2(&quot;ptr (%p) contents@%d: %x\n&quot;, p1, __LINE__, ptr_contents);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = mprotect_pkey(p1, PAGE_SIZE, PROT_EXEC, (u64)pkey);</span>
<span class="p_del">-	pkey_assert(!ret);</span>
<span class="p_del">-	pkey_access_deny(pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintf2(&quot;pkru: %x\n&quot;, rdpkru());</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Make sure this is an *instruction* fault</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	madvise(p1, PAGE_SIZE, MADV_DONTNEED);</span>
<span class="p_del">-	lots_o_noops_around_write(&amp;scratch);</span>
<span class="p_del">-	do_not_expect_pk_fault();</span>
<span class="p_del">-	ptr_contents = read_ptr(p1);</span>
<span class="p_del">-	dprintf2(&quot;ptr (%p) contents@%d: %x\n&quot;, p1, __LINE__, ptr_contents);</span>
<span class="p_del">-	expected_pk_fault(pkey);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void test_mprotect_pkey_on_unsupported_cpu(int *ptr, u16 pkey)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int size = PAGE_SIZE;</span>
<span class="p_del">-	int sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpu_has_pku()) {</span>
<span class="p_del">-		dprintf1(&quot;SKIP: %s: no CPU support\n&quot;, __func__);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	sret = syscall(SYS_mprotect_key, ptr, size, PROT_READ, pkey);</span>
<span class="p_del">-	pkey_assert(sret &lt; 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void (*pkey_tests[])(int *ptr, u16 pkey) = {</span>
<span class="p_del">-	test_read_of_write_disabled_region,</span>
<span class="p_del">-	test_read_of_access_disabled_region,</span>
<span class="p_del">-	test_write_of_write_disabled_region,</span>
<span class="p_del">-	test_write_of_access_disabled_region,</span>
<span class="p_del">-	test_kernel_write_of_access_disabled_region,</span>
<span class="p_del">-	test_kernel_write_of_write_disabled_region,</span>
<span class="p_del">-	test_kernel_gup_of_access_disabled_region,</span>
<span class="p_del">-	test_kernel_gup_write_to_write_disabled_region,</span>
<span class="p_del">-	test_executing_on_unreadable_memory,</span>
<span class="p_del">-	test_ptrace_of_child,</span>
<span class="p_del">-	test_pkey_syscalls_on_non_allocated_pkey,</span>
<span class="p_del">-	test_pkey_syscalls_bad_args,</span>
<span class="p_del">-	test_pkey_alloc_exhaust,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-void run_tests_once(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int *ptr;</span>
<span class="p_del">-	int prot = PROT_READ|PROT_WRITE;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (test_nr = 0; test_nr &lt; ARRAY_SIZE(pkey_tests); test_nr++) {</span>
<span class="p_del">-		int pkey;</span>
<span class="p_del">-		int orig_pkru_faults = pkru_faults;</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf1(&quot;======================\n&quot;);</span>
<span class="p_del">-		dprintf1(&quot;test %d preparing...\n&quot;, test_nr);</span>
<span class="p_del">-</span>
<span class="p_del">-		tracing_on();</span>
<span class="p_del">-		pkey = alloc_random_pkey();</span>
<span class="p_del">-		dprintf1(&quot;test %d starting with pkey: %d\n&quot;, test_nr, pkey);</span>
<span class="p_del">-		ptr = malloc_pkey(PAGE_SIZE, prot, pkey);</span>
<span class="p_del">-		dprintf1(&quot;test %d starting...\n&quot;, test_nr);</span>
<span class="p_del">-		pkey_tests[test_nr](ptr, pkey);</span>
<span class="p_del">-		dprintf1(&quot;freeing test memory: %p\n&quot;, ptr);</span>
<span class="p_del">-		free_pkey_malloc(ptr);</span>
<span class="p_del">-		sys_pkey_free(pkey);</span>
<span class="p_del">-</span>
<span class="p_del">-		dprintf1(&quot;pkru_faults: %d\n&quot;, pkru_faults);</span>
<span class="p_del">-		dprintf1(&quot;orig_pkru_faults: %d\n&quot;, orig_pkru_faults);</span>
<span class="p_del">-</span>
<span class="p_del">-		tracing_off();</span>
<span class="p_del">-		close_test_fds();</span>
<span class="p_del">-</span>
<span class="p_del">-		printf(&quot;test %2d PASSED (iteration %d)\n&quot;, test_nr, iteration_nr);</span>
<span class="p_del">-		dprintf1(&quot;======================\n\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	iteration_nr++;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pkey_setup_shadow(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	shadow_pkru = __rdpkru();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int main(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int nr_iterations = 22;</span>
<span class="p_del">-</span>
<span class="p_del">-	setup_handlers();</span>
<span class="p_del">-</span>
<span class="p_del">-	printf(&quot;has pku: %d\n&quot;, cpu_has_pku());</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!cpu_has_pku()) {</span>
<span class="p_del">-		int size = PAGE_SIZE;</span>
<span class="p_del">-		int *ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		printf(&quot;running PKEY tests for unsupported CPU/OS\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		ptr  = mmap(NULL, size, PROT_NONE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);</span>
<span class="p_del">-		assert(ptr != (void *)-1);</span>
<span class="p_del">-		test_mprotect_pkey_on_unsupported_cpu(ptr, 1);</span>
<span class="p_del">-		exit(0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pkey_setup_shadow();</span>
<span class="p_del">-	printf(&quot;startup pkru: %x\n&quot;, rdpkru());</span>
<span class="p_del">-	setup_hugetlbfs();</span>
<span class="p_del">-</span>
<span class="p_del">-	while (nr_iterations-- &gt; 0)</span>
<span class="p_del">-		run_tests_once();</span>
<span class="p_del">-</span>
<span class="p_del">-	printf(&quot;done (all tests OK)\n&quot;);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



