
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[V5,2/2] ARM: imx: Add suspend codes for imx7D - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [V5,2/2] ARM: imx: Add suspend codes for imx7D</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 17, 2015, 4:25 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437150300-8134-3-git-send-email-shenwei.wang@freescale.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6817891/mbox/"
   >mbox</a>
|
   <a href="/patch/6817891/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6817891/">/patch/6817891/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id D8421C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Jul 2015 16:41:09 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5BD28207C6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Jul 2015 16:41:07 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id A5493207B4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Jul 2015 16:41:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754676AbbGQQkw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 17 Jul 2015 12:40:52 -0400
Received: from mail-bn1bbn0105.outbound.protection.outlook.com
	([157.56.111.105]:15520
	&quot;EHLO na01-bn1-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1751890AbbGQQkj (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 17 Jul 2015 12:40:39 -0400
Received: from BN3PR0301CA0060.namprd03.prod.outlook.com (10.160.152.156) by
	BLUPR03MB603.namprd03.prod.outlook.com (10.255.124.40) with
	Microsoft SMTP
	Server (TLS) id 15.1.207.19; Fri, 17 Jul 2015 16:25:15 +0000
Received: from BN1BFFO11FD002.protection.gbl (2a01:111:f400:7c10::1:103) by
	BN3PR0301CA0060.outlook.office365.com (2a01:111:e400:401e::28)
	with Microsoft
	SMTP Server (TLS) id 15.1.219.17 via Frontend Transport;
	Fri, 17 Jul 2015 16:25:15 +0000
Authentication-Results: spf=fail (sender IP is 192.88.168.50)
	smtp.mailfrom=freescale.com; vger.kernel.org;
	dkim=none (message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of freescale.com does not
	designate 192.88.168.50 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.168.50; helo=tx30smr01.am.freescale.net;
Received: from tx30smr01.am.freescale.net (192.88.168.50) by
	BN1BFFO11FD002.mail.protection.outlook.com (10.58.144.65) with
	Microsoft SMTP Server (TLS) id 15.1.213.8 via Frontend Transport;
	Fri, 17 Jul 2015 16:25:13 +0000
Received: from [tx30smr01.am.freescale.net (B38339-11.am.freescale.net
	[10.81.93.199])
	by tx30smr01.am.freescale.net (8.14.3/8.14.0) with ESMTP id
	t6HGP6Lc010503; Fri, 17 Jul 2015 09:25:13 -0700
From: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;
To: &lt;shawn.guo@linaro.org&gt;, &lt;tglx@linutronix.de&gt;,
	&lt;jason@lakedaemon.net&gt;
CC: &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;
Subject: [PATCH V5 2/2] ARM: imx: Add suspend codes for imx7D
Date: Fri, 17 Jul 2015 11:25:00 -0500
Message-ID: &lt;1437150300-8134-3-git-send-email-shenwei.wang@freescale.com&gt;
X-Mailer: git-send-email 2.5.0.rc2
In-Reply-To: &lt;1437150300-8134-1-git-send-email-shenwei.wang@freescale.com&gt;
References: &lt;1437150300-8134-1-git-send-email-shenwei.wang@freescale.com&gt;
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; BN1BFFO11FD002;
	1:DkDDLww1sFlVSVRI4znGYdkcRnPXGPKmTvbHMq2colBYdgLmLLAHaobdUPMMjX2HjqLAQPRS8X3U1neDEFgrCS0Ux+jEFxEI4TLasTVeOKsqlAYBbzKdT5veYL+KB5IpL5N/xo9lOLH30eqqUZPOEwS1ir7mIeG0HdmvfRffoXsQHxsdRX75yl3GLwWZsJOe5pWEtpB3CqM0DIJdMoc0Zm3DCDlXkXwI5OLDWtgDcoMiR9Rf5Zkz29+Yci5zTyTlQlfVacde7cZSiK8LfQfiyhwTpi+ll1Nzc6Leqwy5F09xiQbhC8fVPfjtcRpqySw3pv44wp2890Qyk0val5oXydFfMXOv/r8773KnGhaFoetfncditxU+apzxXFyUt0Np69D4k6rm/jQiufc+CKReuCfpIKzL6EXAy1xtcgrtE8c=
X-Forefront-Antispam-Report: CIP:192.88.168.50; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:NSPM;
	SFS:(10019020)(6009001)(2980300002)(339900001)(199003)(189002)(575784001)(50986999)(76176999)(87936001)(50466002)(2950100001)(5001770100001)(85426001)(48376002)(105606002)(2201001)(77096005)(47776003)(92566002)(19580395003)(15975445007)(19580405001)(86362001)(5001920100001)(36756003)(50226001)(5001960100002)(5003940100001)(77156002)(33646002)(6806004)(62966003)(189998001)(104016003)(229853001)(46102003)(106466001);
	DIR:OUT; SFP:1102; SCL:1; SRVR:BLUPR03MB603;
	H:tx30smr01.am.freescale.net; FPR:; SPF:Fail; MLV:sfv; A:1;
	MX:1; LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB603;
	2:l6lVpjLLkkyLrfIcHfcOX/1eEzko0TVKec0GJ7bADOlJAEDaYuZ2QKpa7gnVTY7H;
	3:gyVmh1ItpV4Y7uTRgey1EtWTfHrzutjpIuw6ZtZL5uN+Oqf0VY+qFbJcu4L1XVTWN67OS6LcOmhiebWyv+TD+oo7LGfJkN9Wr+AZ1ESdDvBwyzC4mXkt41n2XWwzqJTw4+bhfYaxLef71lGiAma5Q3zPBb8Pyy/CTYGA1pfmcfl9GipFUcoQzUipvrcnp4NRxMZdLFPXPIFLi9KNSWgAIkJ0F8WvAs2Vk0l0memvK7Y=;
	25:E3dM1lj5SWYxIF1t03gpDNr/wz6oejsJBJsvSODZR+mItTnw3v3NNbK+BOsuMjwZSwboWWjn512sAddfnQymQ7zSFB4Z9CND71BHzgYyvr7Cziz6zLQ5ujFtiWqj5NVBeOC+OFSxN0TE8A9ahPlj5c3WYA5f0AHyOPO7pCxMY/NEp9picPTx1w525WuWPpIjyS5aVaCmOxWPqvpSUti0/UQc6byBRRlWJKkfIro2pksD2b2xufY1QiErmENzIkm2jGThfDrGbr2GSP0GQnuD9A==;
	20:fKsLuKtQscQuxxbUl7koOdIHDawfGUr1KD9nA5R+jXICOUYddQ0j1+9JAEMDCXoRL4qgoiJ5XIyg05M4+pCBp/gGG7LSa7Q0Tgi6j1Vg5+ODlreM10NveQY8Ptk+NQnc2TN152lK9LVauXGHy23NVROshlll8PMW/ELvlOX6ZgxvWtUBf0Rgn1cJY4Z84Myd60SNsyoFjGQ24s1Y96PbJI+mi8CNN5aEuYvgWb8B2mlCBeszdwBpMdgVT9JIRkvXpsr2nef7QinA86eXETjuvmCKuDmdOtDpdlChdbxB4tvo6wT+4g9lNU/2LuIWZsYlr7GWDq3Sidi6OR98+BQG42QCW6o1
	ercjHlgVv4plCK0=
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:BLUPR03MB603;
X-Microsoft-Antispam-PRVS: &lt;BLUPR03MB60347C607D9E1301E47CD1083980@BLUPR03MB603.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(5005006)(3002001); SRVR:BLUPR03MB603; BCL:0;
	PCL:0; RULEID:; SRVR:BLUPR03MB603; 
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB603;
	4:ksCRcjvGpEmc6Ak2xeOaXaP/15of/6cZ5C+n8qO3ib57LQMYSSjq02n5HkBL4rbhwRHfo44WZGX8I+9vZ/2djtKx2vYV+0uVEtXqYZb5AL5PxDsd1ar9sbBjYIit8xs4l0D7I1tvleyQemUoIWRevuaJqdOuIAkZXSsRieWnJUAbnJjG732eb94pJMRKNYKu2TUFkzuCo2Y6PIJf7DUzxvovt5cSZitkjbVqBBt54FMJdaVXtfE/1uXf36yZdJdDNuKn2d93akp60PfxEuz4fUxk7yWjj087hVXgfIM1Wi8=
X-Forefront-PRVS: 06400060E1
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; BLUPR03MB603;
	23:GYJOtJJqpTY6qbqy+jb7aCa971oeoCPD7fUqpmpSjJ?=
	=?us-ascii?Q?ULoJXsa5k6Jo2AeXZ1ibYYuS1yC4XW8ZS3YDPZMjc9udTNk79h/GEOww99VC?=
	=?us-ascii?Q?4kiGW5xKchWa+Zrj9TQwjutxKSG7afUnq5J4ecSWv5SdemHfrYqgquGgJSyL?=
	=?us-ascii?Q?H0WlkSrqlpir3hVlEgcvrCTu5Gi3roPM8LnCa2/zKi8IexGpfttP9NJcds2f?=
	=?us-ascii?Q?PkFjVon1HEjuew1t1b1jhZ5uwLttnMSOry+a3gyMhZMELQQ4tlCCJgs1ZX17?=
	=?us-ascii?Q?Bgwy6YCmf8Ox3UY0TeOTCrSQbZxpdB1WggUW+aAecEgLGU+3GWtNCMZaQZKx?=
	=?us-ascii?Q?3p8AkEKnAOMDe/iuv9rMLwqgsdxuNSY6tKtMQRIG4he42MVQ84fXZEJD0veC?=
	=?us-ascii?Q?wwxM5TMNhkAhsl7DFOAjZxqcOvGJhERFdkPqyQFtZAtiE+Si2czXQAnDMarX?=
	=?us-ascii?Q?FicD4mRncaHfLILw3rbCf2Dp7cu6IQ7LuDEcX4TKNbex07UvwKYcZeKXtdlc?=
	=?us-ascii?Q?qtdE7KmyGQdMwFD53YZRoli54eQhCcc2nSAZXwFX5q7TRfy4Gxq7XAa1AEih?=
	=?us-ascii?Q?LJbB8PXoAGs7fHN1nVeYIe8Qc0UJCg2o5soxy83loqVj6FdjEnPfNzHVf6e9?=
	=?us-ascii?Q?dijjbK5D2/Ga1I3vfLF9HyCFbj11ErjXVB5nQM2wstmADAxsf0Lo4RKvWNKN?=
	=?us-ascii?Q?3ck6J+q7CtkNQsXZJ39PUw3hA+4rY5C61Z5Mj+8ICPjy5kYJ3FhhY1JbXnG8?=
	=?us-ascii?Q?ly+x0CMKwdOViu4Bl84gvQ5nLEIHZrm2Y+ddpnfSg9+aLk9woDuDNLGy1IJw?=
	=?us-ascii?Q?mJy10xaDMoqGzk2ttjTBKhbCctLaxqGaAYFh3/Ml4abUEhRX8WwIEBR+NUhS?=
	=?us-ascii?Q?1ftvZrwS9msDNlKCl15wadkFotQfDsxN7Ou83hiBi2N63fCVHEH3MI2vCdeU?=
	=?us-ascii?Q?PsBgPb29Zd3UGEoOwOw6mE/0k1aOsx0HlGJitYbdyGKuY+1xvQD4+Qm/NWBm?=
	=?us-ascii?Q?3c2sxPD/ry0pjHD0/3BBQx?=
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB603;
	5:L2W8Qn5EHw8xChKTeeL1pQkDTxzWGLHB+S8cBaFYGlMSfQYAk3RSu5pYXRYdTxfqbD4oajAQgfLl2E5VDc28kcJsg69xyKRdoFYOCAi+1OYSwGI06gXdmTF74CnoZ/tCznQJQoRKYI6forX1U8om7g==;
	24:j1mk1rFRE0L8q+cZ6URckOvWD6Q/DUxWHDizfu5A7Gh16emEae1tutRTbIoJUC8J2xGvfyHzRXR8A5ZEsVY364Cx/TakdTdjEmy5s/mR09o=;
	20:VNpysEAPUj6+4Tnouxdn5vl5dLUzzIx3L4I8djrocm3saRofXklQ7NiUtZz1YVoiZdowpm8DBiSWHmUXAP7PDg==
X-OriginatorOrg: freescale.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Jul 2015 16:25:13.8141
	(UTC)
X-MS-Exchange-CrossTenant-Id: 710a03f5-10f6-4d38-9ff4-a80b81da590d
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=710a03f5-10f6-4d38-9ff4-a80b81da590d;
	Ip=[192.88.168.50]; Helo=[tx30smr01.am.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BLUPR03MB603
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 17, 2015, 4:25 p.m.</div>
<pre class="content">
IMX7D contains a new version of GPC IP block (GPCv2). It has two
major functions: power management and wakeup source management.

GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4
domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.
After configuring the GPCv2 module, the platform can enter into a
selected mode either automatically triggered by ARM WFI instruction or
manually by software. The system will exit the low power states
by the predefined wakeup sources which are managed by the gpcv2
irqchip driver.

This patch adds a new suspend driver to manage the power states on IMX7D.
It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.
<span class="signed-off-by">
Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
---
 arch/arm/mach-imx/Kconfig        |   1 +
 arch/arm/mach-imx/Makefile       |   2 +
 arch/arm/mach-imx/pm-imx7.c      | 735 +++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/suspend-imx7.S | 529 ++++++++++++++++++++++++++++
 4 files changed, 1267 insertions(+)
 create mode 100644 arch/arm/mach-imx/pm-imx7.c
 create mode 100644 arch/arm/mach-imx/suspend-imx7.S
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">index 5ccc9ea..4269c1e 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Kconfig</span>
<span class="p_chunk">@@ -552,6 +552,7 @@</span> <span class="p_context"> config SOC_IMX7D</span>
 	bool &quot;i.MX7 Dual support&quot;
 	select PINCTRL_IMX7D
 	select ARM_GIC
<span class="p_add">+	select IMX_GPCV2</span>
 	select HAVE_IMX_ANATOP
 	select HAVE_IMX_MMDC
 	help
<span class="p_header">diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="p_header">index 37c502a..b2ad476 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Makefile</span>
<span class="p_chunk">@@ -87,6 +87,8 @@</span> <span class="p_context"> obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
 
 ifeq ($(CONFIG_SUSPEND),y)
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
<span class="p_add">+AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="p_add">+obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
 obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o
 obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o
 endif
<span class="p_header">diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
new file mode 100644
<span class="p_header">index 0000000..70e4424</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="p_chunk">@@ -0,0 +1,735 @@</span> <span class="p_context"></span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="p_add">+#include &lt;linux/regmap.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/fncpy.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static struct imx_irq_gpcv2 *gpcv2_get_chip_data(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct irq_data *data;</span>
<span class="p_add">+	int virq;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Since GPCv2 is the default IRQ domain, its private data can</span>
<span class="p_add">+	 * be gotten from any irq descriptor. Here we use interrupt #19</span>
<span class="p_add">+	 * which is for snvs-rtc.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	virq = irq_find_mapping(0, 19);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (data = irq_get_irq_data(virq); data;</span>
<span class="p_add">+	     data = data-&gt;parent_data) {</span>
<span class="p_add">+		if (!data-&gt;domain)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!strcmp(data-&gt;domain-&gt;name, &quot;GPCv2&quot;))</span>
<span class="p_add">+			return data-&gt;chip_data;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_clear_slots(struct imx_irq_gpcv2 *cd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_SLOT_NUMBER; i++)</span>
<span class="p_add">+		writel_relaxed(0x0, cd-&gt;gpc_base + GPC_SLOT0_CFG + i * 0x4);</span>
<span class="p_add">+	writel_relaxed(BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK |</span>
<span class="p_add">+		BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK,</span>
<span class="p_add">+		cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_enable_core(struct imx_irq_gpcv2 *cd,</span>
<span class="p_add">+			bool enable, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	writel_relaxed(enable, cd-&gt;gpc_base + offset);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_slot_setup(struct imx_irq_gpcv2 *cd,</span>
<span class="p_add">+		u32 index, enum gpcv2_slot m_core, bool mode, bool ack)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (index &gt;= MAX_SLOT_NUMBER)</span>
<span class="p_add">+		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	/* set slot */</span>
<span class="p_add">+	writel_relaxed((mode + 1) &lt;&lt; (m_core * 2), cd-&gt;gpc_base +</span>
<span class="p_add">+		GPC_SLOT0_CFG + index * 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack) {</span>
<span class="p_add">+		/* set ack */</span>
<span class="p_add">+		val = readl_relaxed(cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+		/* clear dummy ack */</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; (15 + (mode ? 16 : 0)));</span>
<span class="p_add">+		val |= 1 &lt;&lt; (m_core + (mode ? 16 : 0));</span>
<span class="p_add">+		writel_relaxed(val, cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_setup(struct imx_irq_gpcv2 *cd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* PLL and PFDs overwrite set */</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_ARM_PLL + REG_SET, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_DDR_PLL + REG_SET, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_SYS_PLL + REG_SET, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_ENET_PLL + REG_SET, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_clean(struct imx_irq_gpcv2 *cd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* PLL and PFDs overwrite clear */</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_ARM_PLL + REG_CLR, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_DDR_PLL + REG_CLR, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_SYS_PLL + REG_CLR, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_ENET_PLL + REG_CLR, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(cd-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_set_mode(struct imx_irq_gpcv2 *cd,</span>
<span class="p_add">+		enum gpcv2_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val1, val2;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	val2 = readl_relaxed(cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all cores&#39; LPM settings must be same */</span>
<span class="p_add">+	val1 &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+</span>
<span class="p_add">+	val2 &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * GPCv2: When improper low-power sequence is used,</span>
<span class="p_add">+	 * the SoC enters low power mode before the ARM core executes WFI.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Software workaround:</span>
<span class="p_add">+	 * 1) Software should trigger IRQ #32 (IOMUX) to be always pending</span>
<span class="p_add">+	 *    by setting IOMUX_GPR1_IRQ.</span>
<span class="p_add">+	 * 2) Software should then unmask IRQ #32 in GPC before setting GPC</span>
<span class="p_add">+	 *    Low-Power mode.</span>
<span class="p_add">+	 * 3) Software should mask IRQ #32 right after GPC Low-Power mode</span>
<span class="p_add">+	 *    is set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case WAIT_CLOCKED:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case WAIT_UNCLOCKED:</span>
<span class="p_add">+		val1 |= A7_LPM_WAIT &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_ON:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_OFF:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_SBYOS;</span>
<span class="p_add">+		val2 |= BM_SLPCR_VSTBY;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel_relaxed(val1, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	writel_relaxed(val2, cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_cpu_power_gate(struct imx_irq_gpcv2 *cd,</span>
<span class="p_add">+				u32 cpu, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+	const u32 val_pdn[2] = {</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= val_pdn[cpu];</span>
<span class="p_add">+	else</span>
<span class="p_add">+		val &amp;= ~val_pdn[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_lpm_plat_power_gate(struct imx_irq_gpcv2 *cd, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_standby(struct imx_irq_gpcv2 *cd)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_env_setup(cd);</span>
<span class="p_add">+	cd-&gt;set_mode(cd, STOP_POWER_OFF);</span>
<span class="p_add">+	/*cd-&gt;set_mode(cd, WAIT_UNCLOCKED);*/</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s %d\r\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+	/* Zzz ... */</span>
<span class="p_add">+	cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;set_mode(cd, WAIT_CLOCKED);</span>
<span class="p_add">+	cd-&gt;lpm_env_clean(cd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int gpcv2_suspend_finish(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_irq_gpcv2 *cd = (struct imx_irq_gpcv2 *)val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cd-&gt;suspend_fn_in_ocram) {</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * call low level suspend function in ocram,</span>
<span class="p_add">+		 * as we need to float DDR IO.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		local_flush_tlb_all();</span>
<span class="p_add">+		cd-&gt;suspend_fn_in_ocram(cd-&gt;ocram_vbase);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+static void imx_gpcv2_lpm_suspend(struct imx_irq_gpcv2 *cd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_env_setup(cd);</span>
<span class="p_add">+	cd-&gt;set_mode(cd, STOP_POWER_OFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0 power down/up with low power mode */</span>
<span class="p_add">+	cd-&gt;lpm_cpu_power_gate(cd, 0, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable plat power down with low power mode */</span>
<span class="p_add">+	cd-&gt;lpm_plat_power_gate(cd, true);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="p_add">+	 * slot 5~9 for power up.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power down slot sequence:</span>
<span class="p_add">+	 * Slot0 -&gt; CORE0</span>
<span class="p_add">+	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot2 -&gt; SCU</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power up slot sequence:</span>
<span class="p_add">+	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot6 -&gt; SCU</span>
<span class="p_add">+	 * Slot7 -&gt; CORE0</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cd-&gt;set_slot(cd, 0, CORE0_A7, false, false);</span>
<span class="p_add">+	cd-&gt;set_slot(cd, 2, SCU_A7, false, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; IMR_NUM; i++) {</span>
<span class="p_add">+		if ((~cd-&gt;wakeup_sources[i] &amp; cd-&gt;mfmix_mask[i]) != 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		cd-&gt;set_slot(cd, 1, FAST_MEGA_MIX, false, false);</span>
<span class="p_add">+		cd-&gt;set_slot(cd, 5, FAST_MEGA_MIX, true, false);</span>
<span class="p_add">+		cd-&gt;lpm_enable_core(cd, true, GPC_PGC_FM);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;set_slot(cd, 6, SCU_A7, true, false);</span>
<span class="p_add">+	cd-&gt;set_slot(cd, 7, CORE0_A7, true, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0, scu */</span>
<span class="p_add">+	cd-&gt;lpm_enable_core(cd, true, GPC_PGC_C0);</span>
<span class="p_add">+	cd-&gt;lpm_enable_core(cd, true, GPC_PGC_SCU);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Suspend to MEM has not been implemented yet */</span>
<span class="p_add">+	cpu_suspend((unsigned long)cd, gpcv2_suspend_finish);</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_env_clean(cd);</span>
<span class="p_add">+	cd-&gt;set_mode(cd, WAIT_CLOCKED);</span>
<span class="p_add">+	cd-&gt;lpm_cpu_power_gate(cd, 0, false);</span>
<span class="p_add">+	cd-&gt;lpm_plat_power_gate(cd, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_enable_core(cd, false, GPC_PGC_C0);</span>
<span class="p_add">+	cd-&gt;lpm_enable_core(cd, false, GPC_PGC_SCU);</span>
<span class="p_add">+	cd-&gt;lpm_enable_core(cd, false, GPC_PGC_FM);</span>
<span class="p_add">+	cd-&gt;clear_slots(cd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_irq_gpcv2 *cd;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd = gpcv2_get_chip_data();</span>
<span class="p_add">+	BUG_ON(!cd);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		cd-&gt;standby(cd);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		cd-&gt;suspend(cd);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="p_add">+	.enter = imx_gpcv2_pm_enter,</span>
<span class="p_add">+	.valid = imx_gpcv2_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_MAX_DDRC_NUM		32</span>
<span class="p_add">+#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_DATA_FROM_HARDWARE		0</span>
<span class="p_add">+#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_base {</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_socdata {</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+	const char *ddrc_compat;</span>
<span class="p_add">+	const char *ddrc_phy_compat;</span>
<span class="p_add">+	const char *src_compat;</span>
<span class="p_add">+	const char *iomuxc_gpr_compat;</span>
<span class="p_add">+	const char *ccm_compat;</span>
<span class="p_add">+	const char *gpc_compat;</span>
<span class="p_add">+	const char *anatop_compat;</span>
<span class="p_add">+	const u32 ddrc_num;</span>
<span class="p_add">+	const u32 (*ddrc_offset)[2];</span>
<span class="p_add">+	const u32 ddrc_phy_num;</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset)[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This structure is for passing necessary data for low level ocram</span>
<span class="p_add">+ * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="p_add">+ * definition is changed, the offset definition in</span>
<span class="p_add">+ * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="p_add">+ * otherwise, the suspend to ocram function will be broken!</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct imx7_cpu_pm_info {</span>
<span class="p_add">+	u32 m4_reserve0;</span>
<span class="p_add">+	u32 m4_reserve1;</span>
<span class="p_add">+	u32 m4_reserve2;</span>
<span class="p_add">+	phys_addr_t pbase; /* The physical address of pm_info. */</span>
<span class="p_add">+	phys_addr_t resume_addr; /* The physical resume address for asm code */</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+	u32 pm_info_size; /* Size of pm_info. */</span>
<span class="p_add">+	struct imx7_pm_base ddrc_base;</span>
<span class="p_add">+	struct imx7_pm_base ddrc_phy_base;</span>
<span class="p_add">+	struct imx7_pm_base src_base;</span>
<span class="p_add">+	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="p_add">+	struct imx7_pm_base ccm_base;</span>
<span class="p_add">+	struct imx7_pm_base gpc_base;</span>
<span class="p_add">+	struct imx7_pm_base l2_base;</span>
<span class="p_add">+	struct imx7_pm_base anatop_base;</span>
<span class="p_add">+	u32 ttbr1; /* Store TTBR1 */</span>
<span class="p_add">+	u32 ddrc_num; /* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_val[MX7_MAX_DDRC_NUM][2]; /* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_phy_num; /* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2]; /* To save offset and value */</span>
<span class="p_add">+} __aligned(8);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="p_add">+			struct imx7_pm_base *base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase) {</span>
<span class="p_add">+		iounmap(base-&gt;vbase);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res), false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x490, 0x00000001 },</span>
<span class="p_add">+	{ 0xd0, 0xc0020001 },</span>
<span class="p_add">+	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x120, 0x03030803 },</span>
<span class="p_add">+	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x240, 0x06000601 },</span>
<span class="p_add">+	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x50, 0x01000010 },</span>
<span class="p_add">+	{ 0x50, 0x00000010 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447306 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407306 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="p_add">+	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="p_add">+	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="p_add">+	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="p_add">+	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="p_add">+	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="p_add">+	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="p_add">+	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="p_add">+	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="p_add">+	.ddrc_offset = imx7d_ddrc_ddr3_setting,</span>
<span class="p_add">+	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="p_add">+	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_suspend_init(struct imx_irq_gpcv2 *cd,</span>
<span class="p_add">+			const struct imx7_pm_socdata *socdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct imx7_cpu_pm_info *pm_info;</span>
<span class="p_add">+	int i, ret = 0;</span>
<span class="p_add">+	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="p_add">+	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="p_add">+	const u32 (*ddrc_offset_array)[2];</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!socdata || !cd) {</span>
<span class="p_add">+		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	node = NULL;</span>
<span class="p_add">+	for (i = 0; i &lt; 3; i++) {</span>
<span class="p_add">+		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="p_add">+		if (!node) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="p_add">+					__func__, i);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="p_add">+					__func__, i, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="p_add">+				__func__, ret);</span>
<span class="p_add">+		goto lpm_sram_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info = sram_base.vbase;</span>
<span class="p_add">+	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="p_add">+	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="p_add">+	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ccm_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base, socdata-&gt;ddrc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="p_add">+				socdata-&gt;ddrc_phy_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_phy_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto src_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="p_add">+				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="p_add">+					__func__, ret);</span>
<span class="p_add">+		goto iomuxc_gpr_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto gpc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="p_add">+				socdata-&gt;anatop_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto anatop_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="p_add">+	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="p_add">+	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="p_add">+	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="p_add">+				ddrc_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC PHY settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="p_add">+			ddrc_phy_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="p_add">+				ddrc_phy_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				ddrc_phy_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="p_add">+		sram_base.vbase + sizeof(*pm_info),</span>
<span class="p_add">+		&amp;imx7_suspend,</span>
<span class="p_add">+		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="p_add">+	cd-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+anatop_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="p_add">+gpc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="p_add">+iomuxc_gpr_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="p_add">+src_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="p_add">+ddrc_phy_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="p_add">+ddrc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="p_add">+ccm_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="p_add">+lpm_sram_map_failed:</span>
<span class="p_add">+	iounmap(sram_base.vbase);</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_irq_gpcv2 *cd;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	cd = gpcv2_get_chip_data();</span>
<span class="p_add">+	if (!cd) {</span>
<span class="p_add">+		pr_debug(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	imx_gpcv2_suspend_init(cd, &amp;imx7d_pm_data_ddr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="p_add">+	cd-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="p_add">+	cd-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="p_add">+	cd-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="p_add">+	cd-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="p_add">+	cd-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="p_add">+	cd-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="p_add">+	cd-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s \r\n&quot;, __func__);</span>
<span class="p_add">+	cd-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="p_add">+	WARN_ON(!cd-&gt;anatop);</span>
<span class="p_add">+	cd-&gt;imx_src = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-src&quot;);</span>
<span class="p_add">+	WARN_ON(!cd-&gt;imx_src);</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;imx_gpcv2_pm_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+device_initcall(imx_gpcv2_pm_init);</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/arm/mach-imx/suspend-imx7.S b/arch/arm/mach-imx/suspend-imx7.S</span>
new file mode 100644
<span class="p_header">index 0000000..8c3f516</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="p_chunk">@@ -0,0 +1,529 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &quot;hardware.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ==================== low level suspend ====================</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Better to follow below rules to use ARM registers:</span>
<span class="p_add">+ * r0: pm_info structure address;</span>
<span class="p_add">+ * r1 ~ r4: for saving pm_info members;</span>
<span class="p_add">+ * r5 ~ r10: free registers;</span>
<span class="p_add">+ * r11: io base address.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      imx7_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(imx7_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below offsets are based on struct imx7_cpu_pm_info</span>
<span class="p_add">+ * which defined in arch/arm/mach-imx/pm-imx7.c, this</span>
<span class="p_add">+ * structure contains necessary pm info for low level</span>
<span class="p_add">+ * suspend related code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE0_OFFSET		0x0</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE1_OFFSET		0x4</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE2_OFFSET		0x8</span>
<span class="p_add">+#define PM_INFO_PBASE_OFFSET			0xc</span>
<span class="p_add">+#define PM_INFO_RESUME_ADDR_OFFSET		0x10</span>
<span class="p_add">+#define PM_INFO_DDR_TYPE_OFFSET			0x14</span>
<span class="p_add">+#define PM_INFO_PM_INFO_SIZE_OFFSET		0x18</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_P_OFFSET		0x1c</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_V_OFFSET		0x20</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_P_OFFSET		0x24</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_V_OFFSET		0x28</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_P_OFFSET		0x2c</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_V_OFFSET		0x30</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_P_OFFSET		0x34</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_V_OFFSET		0x38</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_P_OFFSET		0x3c</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_V_OFFSET		0x40</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_P_OFFSET		0x44</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_V_OFFSET		0x48</span>
<span class="p_add">+#define PM_INFO_MX7_L2_P_OFFSET			0x4c</span>
<span class="p_add">+#define PM_INFO_MX7_L2_V_OFFSET			0x50</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_P_OFFSET		0x54</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_V_OFFSET		0x58</span>
<span class="p_add">+#define PM_INFO_MX7_TTBR1_V_OFFSET		0x5c</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_NUM_OFFSET		0x60</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_OFFSET			0x64</span>
<span class="p_add">+#define PM_INFO_DDRC_VALUE_OFFSET		0x68</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_NUM_OFFSET		0x164</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_OFFSET		0x168</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_VALUE_OFFSET		0x16c</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_SRC_GPR1	0x74</span>
<span class="p_add">+#define MX7_SRC_GPR2	0x78</span>
<span class="p_add">+#define GPC_PGC_FM	0xa00</span>
<span class="p_add">+#define ANADIG_SNVS_MISC_CTRL	0x380</span>
<span class="p_add">+#define DDRC_STAT	0x4</span>
<span class="p_add">+#define DDRC_PWRCTL	0x30</span>
<span class="p_add">+#define DDRC_PSTAT	0x3fc</span>
<span class="p_add">+#define DDRC_PCTRL_0	0x490</span>
<span class="p_add">+#define DDRC_DFIMISC	0x1b0</span>
<span class="p_add">+#define DDRC_SWCTL	0x320</span>
<span class="p_add">+#define DDRC_SWSTAT	0x324</span>
<span class="p_add">+#define DDRPHY_LP_CON0	0x18</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 3</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Flush all data from the L1 data cache before disabling</span>
<span class="p_add">+	 * SCTLR.C bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable d-cache */</span>
<span class="p_add">+	mrc	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	bic	r7, r7, #(1 &lt;&lt; 2)</span>
<span class="p_add">+	mcr	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable L1 data cache. */</span>
<span class="p_add">+	mrc	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	orr	r6, r6, #0x4</span>
<span class="p_add">+	mcr	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_enter_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+2:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	2b</span>
<span class="p_add">+3:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_exit_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+4:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	beq	4b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable auto self-refresh */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 0)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro wait_delay</span>
<span class="p_add">+5:</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	5b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_enter_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+6:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	6b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+7:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	7b</span>
<span class="p_add">+8:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	8b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reset ddr_phy  */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* delay 7 us */</span>
<span class="p_add">+	ldr	r6, =6000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r11, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r11, r6]</span>
<span class="p_add">+	/* turn off ddr power */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_exit_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r1, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldrne	r1, [r0, #PM_INFO_MX7_ANATOP_P_OFFSET]</span>
<span class="p_add">+	ldreq	r2, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r2, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r3, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r3, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r4, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldrne	r4, [r0, #PM_INFO_MX7_DDRC_PHY_P_OFFSET]</span>
<span class="p_add">+	ldreq	r10, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	ldrne	r10, [r0, #PM_INFO_MX7_CCM_P_OFFSET]</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* turn on ddr power */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, =50</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x3</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+9:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r3, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	9b</span>
<span class="p_add">+	ldr	r7, =0x20</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do PHY, clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x2</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 30)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* need to delay ~5mS */</span>
<span class="p_add">+	ldr	r6, =0x100000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_PHY_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_PHY_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+10:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r4, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	10b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	beq	101f</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+101:</span>
<span class="p_add">+	ldr	r7, =0x2</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0xf</span>
<span class="p_add">+	str	r7, [r4, #DDRPHY_LP_CON0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+11:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	11b</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+12:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_SWSTAT]</span>
<span class="p_add">+	and	r7, r7, #0x1</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	12b</span>
<span class="p_add">+13:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x20</span>
<span class="p_add">+	cmp	r7, #0x20</span>
<span class="p_add">+	bne	13b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+14:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x30</span>
<span class="p_add">+	cmp	r7, #0x0</span>
<span class="p_add">+	bne	14b</span>
<span class="p_add">+</span>
<span class="p_add">+15:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	15b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable port */</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(imx7_suspend)</span>
<span class="p_add">+	push	{r4-r12}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The value of r0 is mapped the same in origin table and IRAM table,</span>
<span class="p_add">+	 * thus no need to care r0 here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="p_add">+	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	ldr	r3, [r0, #PM_INFO_DDR_TYPE_OFFSET]</span>
<span class="p_add">+	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * counting the resume address in iram</span>
<span class="p_add">+	 * to set it in SRC register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, =imx7_suspend</span>
<span class="p_add">+	ldr	r7, =resume</span>
<span class="p_add">+	sub	r7, r7, r6</span>
<span class="p_add">+	add	r8, r1, r4</span>
<span class="p_add">+	add	r9, r8, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	/* store physical resume addr and pm_info address. */</span>
<span class="p_add">+	str	r9, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r1, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure TLB contain the addr we want,</span>
<span class="p_add">+	 * as we will access them after DDR is in</span>
<span class="p_add">+	 * self-refresh mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r0, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	add	r6, #0x4000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	add	r6, #0x1000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r7, [r6, #0x490]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	ddr_only_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_enter_retention</span>
<span class="p_add">+	b	ddr_retention_enter_out</span>
<span class="p_add">+ddr_only_self_refresh:</span>
<span class="p_add">+	ddrc_enter_self_refresh</span>
<span class="p_add">+ddr_retention_enter_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz, enter stop mode */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x0</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	wfi_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	wfi_ddr_retention_out</span>
<span class="p_add">+wfi_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+wfi_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	{r4-r12}</span>
<span class="p_add">+	/* return to suspend finish */</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+</span>
<span class="p_add">+resume:</span>
<span class="p_add">+	/* invalidate L1 I-cache first */</span>
<span class="p_add">+	mov     r6, #0x0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="p_add">+	/* enable the Icache and branch prediction */</span>
<span class="p_add">+	mov     r6, #0x1800</span>
<span class="p_add">+	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get physical resume address from pm_info. */</span>
<span class="p_add">+	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x1</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_P_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	dsm_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	dsm_ddr_retention_out</span>
<span class="p_add">+dsm_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+dsm_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+ENDPROC(imx7_suspend)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ca7_cpu_resume)</span>
<span class="p_add">+	bl	v7_invalidate_l1</span>
<span class="p_add">+	b	cpu_resume</span>
<span class="p_add">+ENDPROC(ca7_cpu_resume)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



