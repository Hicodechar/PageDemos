
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v5,32/32] x86/mm: Add support to make use of Secure Memory Encryption - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v5,32/32] x86/mm: Add support to make use of Secure Memory Encryption</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 18, 2017, 9:22 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170418212223.10190.85121.stgit@tlendack-t1.amdoffice.net&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9686419/mbox/"
   >mbox</a>
|
   <a href="/patch/9686419/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9686419/">/patch/9686419/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	086EA602C2 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:23:49 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id ED0092094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:23:48 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E1A23269DA; Tue, 18 Apr 2017 21:23:48 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6BA3C2094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:23:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932970AbdDRVXl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 18 Apr 2017 17:23:41 -0400
Received: from mail-co1nam03on0082.outbound.protection.outlook.com
	([104.47.40.82]:17872
	&quot;EHLO NAM03-CO1-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1758147AbdDRVWd (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 18 Apr 2017 17:22:33 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=j1mMqTQqs9b2k3EDqykBsNoExJGboxHiwEairRHoLeA=;
	b=1uxjbj/D7JdrW1P57xMg2acqwRt3QZrz/hYsXXsP49C9ub/zwpZWU7koY3lgupnhIfySbeyUZ4hpiBOWPUCrdqa7BOs2tuFuxJZQ+J6GWTht77rVizghqLrno73C1aw5PHqbz/vG/wh1n4p4u8aEI7V0Ubg9vuajue5nYl78o7c=
Authentication-Results: vger.kernel.org; dkim=none (message not signed)
	header.d=none; vger.kernel.org;
	dmarc=none action=none header.from=amd.com; 
Received: from tlendack-t1.amdoffice.net (165.204.77.1) by
	CY4PR12MB1141.namprd12.prod.outlook.com (10.168.163.149) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1034.10; Tue, 18 Apr 2017 21:22:25 +0000
From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
Subject: [PATCH v5 32/32] x86/mm: Add support to make use of Secure Memory
	Encryption
To: &lt;linux-arch@vger.kernel.org&gt;, &lt;linux-efi@vger.kernel.org&gt;,
	&lt;kvm@vger.kernel.org&gt;, &lt;linux-doc@vger.kernel.org&gt;,
	&lt;x86@kernel.org&gt;, &lt;kexec@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;kasan-dev@googlegroups.com&gt;,
	&lt;linux-mm@kvack.org&gt;, &lt;iommu@lists.linux-foundation.org&gt;
CC: Rik van Riel &lt;riel@redhat.com&gt;,
	Radim =?utf-8?b?S3LEjW3DocWZ?= &lt;rkrcmar@redhat.com&gt;,
	Toshimitsu Kani &lt;toshi.kani@hpe.com&gt;, Arnd Bergmann &lt;arnd@arndb.de&gt;,
	Jonathan Corbet &lt;corbet@lwn.net&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	&quot;Michael S. Tsirkin&quot; &lt;mst@redhat.com&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Paolo Bonzini &lt;pbonzini@redhat.com&gt;, Larry Woodman &lt;lwoodman@redhat.com&gt;,
	Brijesh Singh &lt;brijesh.singh@amd.com&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	Alexander Potapenko &lt;glider@google.com&gt;, Dave Young &lt;dyoung@redhat.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Dmitry Vyukov &lt;dvyukov@google.com&gt;
Date: Tue, 18 Apr 2017 16:22:23 -0500
Message-ID: &lt;20170418212223.10190.85121.stgit@tlendack-t1.amdoffice.net&gt;
In-Reply-To: &lt;20170418211612.10190.82788.stgit@tlendack-t1.amdoffice.net&gt;
References: &lt;20170418211612.10190.82788.stgit@tlendack-t1.amdoffice.net&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: CY4PR19CA0033.namprd19.prod.outlook.com (10.172.173.147)
	To
	CY4PR12MB1141.namprd12.prod.outlook.com (10.168.163.149)
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 26ffeb69-dc79-4574-595a-08d486a10329
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(48565401081)(201703131423075)(201703031133081);
	SRVR:CY4PR12MB1141; 
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1141;
	3:BEzKyqPgsKHEc6jhNMmXb04LRc0sGFfa90MbAQK4c+UHOMrNoBH8lS1iCsJCb3Noc/6I6p4b1M8BQzi5l4EN+PGf+R9Jm221IjP5xjLR2J19dV0NM5KfdG0vHIztrq4k4xy0HkhBDRYgosufHUc91P/nFzIrACjZcmGTm/9G3lgM2avI2qdpYSgns2Ai6x/nm76mQRbuLy6/xla4eYhJjhqHHUgftcjE4vm3WEqUOc92VIQJUYlrVUASSMiUVVe1vwCoHSvcjUOdou86cYzSH22yWf8OUHIo6rBg/0FGyzELKH7zUorb+pR64XcSQRriEkodzckQKBK9NWlU6H57YOZ/+LcUCrGDSLcBwYrKoYs=;
	25:h9eUfz2UOOo4FJS7iS+iXoNjcJM2VWWyobBTZ1G7YSdUP6bAb+/dAistDC8oGxID9GtHoDonmE/s/1x4M7s7URWDqBuTFxL3MNZ29P8bvW/qHsmvtGE2+YXNgpShaGuKhqQmk4flMVyXTXXQbuOrWYgfZ3koao9QzcL6RJU55J/7qkpuO5n2iZxqdv54QqEHKOoSXNl6fcz4SXfHxCv2mzmlYiYr3oqoMZ7oKQKRa3nijwnkBM+Md9UwQCxdKvzgzS+SM9TyrK9GEPxgDdA8gWBbSzcqdhV55gCHoJwIr22sDzXhwjEzD9I5rQPh9P7xXUEV549OliivDPdSV1LYLqA7uO4uQP0pHBm3B1ixZWBpj9zgsq+5gG6cvnhMhUpjxl6V5xEfVRAu7FA2UzzYen6x1cM8kjMDDo5+7nzwXrLkiaP2AuEIVU4tKZFhNOV9A1Lq9fToj6VqRfY5Uum/Wg==
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1141;
	31:QR2/OxCyGsbMhDsJfLelUnIUYM0uSFAqbyqqe55ZKmCr6Hx7wBGV2jE7ujMEh8vfCv+4zpeK6D4YW8DKXRwz01MeGfq73PqDUpKyjfvPsmxwy1b8zGFLqH7+mEqiYgmZLIO/vdMjFqU45YlA9tZfyhsUsQe82fX+GPxF8VgsrLMB8atLIlYKtYXwyKDW3tikwOG4utd29de2T1RfQn4dFiKX5T1NS9WtOgMnS2wbuRg=;
	20:SF1cFYqoiTEhKd4dDvthTmxPurV52sXMIL9U/wrYiiIB4uAzVMK9gmBx147qKeVBMHbDvA1KG684YP3RD4lrca8LoLlo+A2sA0Vyx20sm9f3IDlolcFfWJDz2weaLJSIWV2o3qOMQJr5AWuN/cZbRUKgd3VgB3ibzovVm+K9e9uzzSvHAFsSXTCrx+J3RjC+Y+G2xcK9zmDTpmukwwiTKX37Iub+dUv+Z53rcoQHrwr/SN31flI+Djril4zDDJWX1h2To6u/HADFtjNg+ZbeiXmXr5Wm3gNqeNyVj8x87OAHY7k3kX92Fu8Fq0owy8CVgfIgKaeJuLt3iIYXJkzaPWeTyc/uOnnoGlD831KvR6Jn5vH+LoM/hmYkF46Q4/D8HJTHjBZoBZjDSGVu3vs/La+SJoErOoyl/McfyRQ9hXeySyP9bKWrT/uxgmoZqYQKqGGMQNEd7GQGURywalpgroOYoWONoVTQpmBgoFv+a9IRfhhg/QBKUdB4m/EDg/4d
X-Microsoft-Antispam-PRVS: &lt;CY4PR12MB1141555177F9C5B3A00B0F66EC190@CY4PR12MB1141.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(6040450)(601004)(2401047)(8121501046)(5005006)(10201501046)(93006095)(93001095)(3002001)(6055026)(6041248)(20161123562025)(20161123564025)(20161123560025)(201703131423075)(201702281528075)(201703061421075)(20161123555025)(6072148);
	SRVR:CY4PR12MB1141; BCL:0; PCL:0; RULEID:; SRVR:CY4PR12MB1141;
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1141;
	4:DR6w7cHEQ00eF56tQ//8zPLCQJqzv/ob0snWXL9/su/3p6inMfzlNqd2JS3M8C+SbL5rg/Tpuyl05jbjAM+evyWH7uG+iyvpTr1iwhQQ64WzekSD9kB1p9an5nPWy6ZmK277FNO7gT/NtHNDi/VZepwB5YPjejrmeVmrOVH3fLuXY2YhzVP8+Vj0CDhsfz2cpK2FqW5AuDNm3hK4QzViGEqdfS2Q+Dvpn5rPHvLeXCGSrzLWHwpRG2VDIuKEnBAMT4cbc2uotYPEoXMnscIxttawjqCxHul8D0xvZim70rTyNQg4zTTb3puNz5dro9oLHy45bl886vQD2qiP+7tfg8nsmQaQwtyPPIzv9avS/wTWFVD8tRYWrGrzY12WT20X34ZkEAPtUqi62613QDa2Wwdmeig/uQUSGYJUmjEEmYskHDICa1/N4T75gHF4twV/SrqeZosQptQI96vRfyjGGN4iZBMfz3kTynqy774EEtc++rzwRyQmOJnXVaXC1SJq80ryLkv026Ez0Ze/27o1aGmAwqPZkbhNO/5jV1Jh0wKBlOCIILCIfXN+b3TlC7zJY5dPqyCP+eqghcf9qgROkOvfl/Vmj2LYEyDEC9YoREOwBdZaLiJMaUBcxsWGSbA57rsbG6Li0B1VltxMko56qqcahdyJX+MACxiVz+lLzYsRew3kPaX11/Hm7R3V7wHzXzxvcy37wfZl3kj6UUqW6HtmV1sN3yYkLbp99rubq+F8yvuSHKCyB2I/w9BnNUz3+u93v1vueD6nzaC2u/d9bg==
X-Forefront-PRVS: 028166BF91
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6009001)(39450400003)(39860400002)(39850400002)(39840400002)(39400400002)(39410400002)(42186005)(3846002)(305945005)(25786009)(7406005)(50466002)(7736002)(38730400002)(2906002)(4001350100001)(230700001)(53416004)(86362001)(2950100002)(5660300001)(103116003)(23676002)(6116002)(7416002)(2201001)(33646002)(1076002)(50986999)(54356999)(81166006)(55016002)(76176999)(97746001)(83506001)(66066001)(189998001)(9686003)(4326008)(6506006)(47776003)(53936002)(54906002)(8676002)(921003)(71626007)(1121003);
	DIR:OUT; SFP:1101; SCL:1; SRVR:CY4PR12MB1141;
	H:tlendack-t1.amdoffice.net; FPR:; SPF:None; MLV:sfv; LANG:en;
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtDWTRQUjEyTUIxMTQxOzIzOlFUUEt5UDVCd2Ywb3JKVDJqQzJrNGhiSVFk?=
	=?utf-8?B?dmtpVzh6dERhK1cvZ3g4WkJWc3ZudFpxclV5MTVxMGJXeGUzcVVYeUVGWG9H?=
	=?utf-8?B?WWVzelE1M1NrdzdpQkJrK0R1bnduN00ySHN5eSs4amRMWElsVGRMOEtsd3VP?=
	=?utf-8?B?bGNnTFUxNVVYaUN2M1I0ZXQwbDVEL1gvZENKamxvaXJIdVFaaFZxbmFiMDla?=
	=?utf-8?B?cyt1OG5PdmNyTHNoMmtkWThTUWdtY2NxamttekU3UjRXK1A1OHcwZlZJVjFO?=
	=?utf-8?B?d0FQU01abEltS1RwekE5eFhYdno2VWVRT3plN0ZiZFFJTGo4c0VhRlByRlRv?=
	=?utf-8?B?a3BEeUtSUkw2YS9QTjUwNEhNd29jUS9FUi9FUG9hR3dBRG9waVFtTGlibDR1?=
	=?utf-8?B?VE40WXNsUEdTdU94ekt6b1Vzbm1Ld2JZMGVVZUNtbGhYMzQrakZxMHdjZG5C?=
	=?utf-8?B?ejJYWEtJMWZkd3p1QnUzb0ErS1lUM041RUpPSkZuV1Z6YmdOSFBYZzZBalhU?=
	=?utf-8?B?c3FaSkhaVFVpSGFoNDZxN0QxWG9rbmk1QUtKems2TmRaY3FlOFcvcW0xdkUz?=
	=?utf-8?B?aGk0bFBiSDIvTTV6aERkMy9vTVlja2VEOEIvdVprZjF4NDdZR2sxaEFhdG9n?=
	=?utf-8?B?aHFaMFRJMG10UmRHMm00N1piLzY5ejM3c2xmTVllNm1qRGh0SnN1aWVaeVVF?=
	=?utf-8?B?MXgzQ3R6Y1BCV1g2QXY3c2NVb3hQVVdlMmZBQmhtZ3ZwNjZTbjViMExMdVdD?=
	=?utf-8?B?dWtETmVDKzRFT0pLempvMXUxZ3BxYXBxeitLTHEvT3cxTmdHazh5NEt5SjBo?=
	=?utf-8?B?azQvSWJGVUQ2NUdEd25iOXVzdHY2bkVuaHo0aGg4OHBsb25NVlVsdjMya3A2?=
	=?utf-8?B?eTJmM2NkbkNON1NLL1BiSytFNEdWaFpLTXFnN1FqTWRreUxRQmM5bytIczk2?=
	=?utf-8?B?ekkxZFhmTUdjUjJmcmJEckNrM1QrNko0Ynp2c20yajhQN0p3WUNwbXlRV0Nx?=
	=?utf-8?B?RFVZeUI0UytPSHlFUXRUSCszRFQ5amRFb3dpTXo5WkJTbEhHaHBlK3BBRzdK?=
	=?utf-8?B?MlMyMFQ2bXFwT1Q1b2plZlVtaWdJeTA2ZFZPQ1diNmdtOXdnaFNzWGZidTdp?=
	=?utf-8?B?aHB2bmlXNkZydk5Vc0tIN2ladTlHNlpRVXBKTlZkMnBMRWtMRkRibUJaS25X?=
	=?utf-8?B?MmVLMXBNM2FxU0F1UUFzbWFaMTg1a2d3MXNOa0srUEVKN0JvUmFpMEdvNk5u?=
	=?utf-8?B?bUlQalpVbEJGcGxWejQ4YnpKTytZT21KWTArc2hxdXNSTEIyTzBtZ0V6UVlh?=
	=?utf-8?B?bGY4RlE5M1loODJzemxBZHZDZnRhMllTMGJ1Y2Rra3FMdzJXcFg2M3RvNmYv?=
	=?utf-8?B?YkVYYTczSG9zRDNXaDNrd09Vbm54OVhxeUpTMHhZTm8rV3RGSjlFOE1LOENz?=
	=?utf-8?B?OTU5aVB4WHVSZVBaRUJkcWxIV0dSd094Y0ZTZ3hPVnFkSHEvN1R0SWdOUFEw?=
	=?utf-8?B?c2RlUURzRVgwN3V0SUNDcldoSEd5RGRBRTNTaGFhc0tkdnFoSnZ4QXF0NTBa?=
	=?utf-8?B?WjhQdzJISlVOM3FsZlVQV1pUSHVsTm9zYVJkOG56OHFobGVndXQzKzhUV2Q0?=
	=?utf-8?Q?PrNS5a5kLUzEb2q+RRkz?=
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1141;
	6:kROBK4tfNLb52W6eodsw77cRRfzPu/6Xxfq+4ThPQkrn9mgY60TUTmwWgZ/eLqL70urvH9hZ70O6an97IEj0rwu7GrAbgux8mhUQSU/+aivJIVuEIQkynU1R/ZtEHq6DyJ35h077FQGAiwrn6+XeaBp0D1Y1ZXvCu/Luef1K4mfOlEFUoCKzGtEUiXMggCCk6IpdKKbUrfH/4sZnE5cZJXIXq0CCpvRl5ott3Quse9qUxJBoW0/10+oaDNpwIJvCLCvHQO3GCP5IjUBr50IirqlfGn+MP9RndOAxTO+WMNUYVHSWuWZ/ZbL1U9V6m9479J+BwsnZpMlRvoByjNBmhudEdmT0DezYRh0rKC6CvJCpaNG+/DqbTcNeqblnAgjyKZS78MtRgWudicDxs2hb682s36fZgbbBxi1gR37NyDX7SsiF8fvtVahROYLPf+74K3v6oCQ78vGLcMGQBLfuRhHVfcUu9YnHuUw013kQr5Y=;
	5:urghv0wHk/4sj0YMqWfmi0kOCOoSPopl044RCLF1KrX6rsLkJuPsgt4zEngCjWYfLfNTdgbHRWAB+9VqFtuB3D8mmg6+u7izvrjnUpuvuYJqMMHdZEEj0mCoJqtQUYd6ljRgL9vyqLi1UZo4Te+fDg==;
	24:R5To2zGNmggUaS7P4Fsz1dWR27YFWSo8rOBU+MKufPyw7Ac9QneyDs91QSgLKv9qGRdxYe+w2yHMqDc4UwXtaGqjKz53rSkN3ILm1RFGD9s=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1141;
	7:1kdVS2ywPhH3mxjynbAz8C0tP9wNr49kjGvhTtAeFX0/nZRDO25No+yezOAg8M0TL8CdeRk1ROskeMoXJ9VJqg0dIDrC4JhyHaGfg58M/9kCr3gTmaVPy2vp/JEVV6OqtcxF6MpdhF6MQAlIdB/RZeq0p/ZfBrQRWMOZzyjrOyRwma1712gDt9/3f/e8npiEnJgj87AsNzko820vQjckiORJlwJiWQEUPu9wL2DLNBtjfj7FAwjdO4t1HijXx//CwxpDR1/o4VCKm7iYYjtqkuzMZJLs0GyZe/TJalDLTZjhg3wSwFq9PWpKM9j5jYmXF/208P9oADflz64vyvG8Gw==;
	20:aH+8DZ/jr6z4z7U9P/P7g3YbrMp0usFu6xddKjhXEZ9mrf/bFcJgi/OsTjwZSQ8/LsI1LnRT51TYjaJ6syR6+CKtaVXQcQMaEPJj6+FhUncBINDRZFq2ijF8KqZi06g3/0iEavom1t0xH9auiSDjftJhNHHoVkgyFWl8utflme/BobE6KSo3g/vIdrAcoGcJL4qIGHPznUz9SNPrfurdZT6QLZVtm0zCZyOcknl0YEZt8e/a/zFeSHxJaEfOhKoF
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Apr 2017 21:22:25.6672
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY4PR12MB1141
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - April 18, 2017, 9:22 p.m.</div>
<pre class="content">
Add support to check if SME has been enabled and if memory encryption
should be activated (checking of command line option based on the
configuration of the default state).  If memory encryption is to be
activated, then the encryption mask is set and the kernel is encrypted
&quot;in place.&quot;
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
---
 arch/x86/kernel/head_64.S |    1 +
 arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 80 insertions(+), 4 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - April 21, 2017, 6:56 p.m.</div>
<pre class="content">
On 4/18/2017 4:22 PM, Tom Lendacky wrote:
<span class="quote">&gt; Add support to check if SME has been enabled and if memory encryption</span>
<span class="quote">&gt; should be activated (checking of command line option based on the</span>
<span class="quote">&gt; configuration of the default state).  If memory encryption is to be</span>
<span class="quote">&gt; activated, then the encryption mask is set and the kernel is encrypted</span>
<span class="quote">&gt; &quot;in place.&quot;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/kernel/head_64.S |    1 +</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt;  2 files changed, 80 insertions(+), 4 deletions(-)</span>
<span class="quote">&gt;</span>

...
<span class="quote">
&gt;</span>
<span class="quote">&gt; -unsigned long __init sme_enable(void)</span>
<span class="quote">&gt; +unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt; +	unsigned long me_mask;</span>
<span class="quote">&gt; +	bool active_by_default;</span>
<span class="quote">&gt; +	char buffer[16];</span>

So it turns out that when KASLR is enabled (CONFIG_RAMDOMIZE_BASE=y)
the stack-protector support causes issues with this function because
it is called so early. I can get past it by adding:

CFLAGS_mem_encrypt.o := $(nostackp)

in the arch/x86/mm/Makefile, but that obviously eliminates the support
for the whole file.  Would it be better to split out the sme_enable()
and other boot routines into a separate file or just apply the
$(nostackp) to the whole file?

Thanks,
Tom
<span class="quote">
&gt; +	u64 msr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check for the SME support leaf */</span>
<span class="quote">&gt; +	eax = 0x80000000;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (eax &lt; 0x8000001f)</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Check for the SME feature:</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt; +	 *     Secure Memory Encryption support</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	eax = 0x8000001f;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (!(eax &amp; 1))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check if SME is enabled */</span>
<span class="quote">&gt; +	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt; +	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Fixups have not been applied to phys_base yet, so we must obtain</span>
<span class="quote">&gt; +	 * the address to the SME command line option data in the following</span>
<span class="quote">&gt; +	 * way.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_arg(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_arg));</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_on(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_on)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_on));</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_off(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_off)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_off));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))</span>
<span class="quote">&gt; +		active_by_default = true;</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		active_by_default = false;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmdline_ptr = (const char *)((u64)bp-&gt;hdr.cmd_line_ptr |</span>
<span class="quote">&gt; +				     ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (strncmp(buffer, cmdline_on, sizeof(buffer)) == 0)</span>
<span class="quote">&gt; +		sme_me_mask = me_mask;</span>
<span class="quote">&gt; +	else if (strncmp(buffer, cmdline_off, sizeof(buffer)) == 0)</span>
<span class="quote">&gt; +		sme_me_mask = 0;</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		sme_me_mask = active_by_default ? me_mask : 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt;  	return sme_me_mask;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -543,9 +618,9 @@ unsigned long sme_get_me_mask(void)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  #else	/* !CONFIG_AMD_MEM_ENCRYPT */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -void __init sme_encrypt_kernel(void)	{ }</span>
<span class="quote">&gt; -unsigned long __init sme_enable(void)	{ return 0; }</span>
<span class="quote">&gt; +void __init sme_encrypt_kernel(void)			{ }</span>
<span class="quote">&gt; +unsigned long __init sme_enable(struct boot_params *bp)	{ return 0; }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -unsigned long sme_get_me_mask(void)	{ return 0; }</span>
<span class="quote">&gt; +unsigned long sme_get_me_mask(void)			{ return 0; }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  #endif	/* CONFIG_AMD_MEM_ENCRYPT */</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 19, 2017, 11:27 a.m.</div>
<pre class="content">
On Tue, Apr 18, 2017 at 04:22:23PM -0500, Tom Lendacky wrote:
<span class="quote">&gt; Add support to check if SME has been enabled and if memory encryption</span>
<span class="quote">&gt; should be activated (checking of command line option based on the</span>
<span class="quote">&gt; configuration of the default state).  If memory encryption is to be</span>
<span class="quote">&gt; activated, then the encryption mask is set and the kernel is encrypted</span>
<span class="quote">&gt; &quot;in place.&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/kernel/head_64.S |    1 +</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt;  2 files changed, 80 insertions(+), 4 deletions(-)</span>

...
<span class="quote">
&gt; +unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt; +	unsigned long me_mask;</span>
<span class="quote">&gt; +	bool active_by_default;</span>
<span class="quote">&gt; +	char buffer[16];</span>
<span class="quote">&gt; +	u64 msr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check for the SME support leaf */</span>
<span class="quote">&gt; +	eax = 0x80000000;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (eax &lt; 0x8000001f)</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Check for the SME feature:</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt; +	 *     Secure Memory Encryption support</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	eax = 0x8000001f;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	if (!(eax &amp; 1))</span>
<span class="quote">&gt; +		goto out;</span>

&lt;---- newline here.
<span class="quote">
&gt; +	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check if SME is enabled */</span>
<span class="quote">&gt; +	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt; +	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Fixups have not been applied to phys_base yet, so we must obtain</span>
<span class="quote">&gt; +	 * the address to the SME command line option data in the following</span>
<span class="quote">&gt; +	 * way.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_arg(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_arg));</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_on(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_on)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_on));</span>
<span class="quote">&gt; +	asm (&quot;lea sme_cmdline_off(%%rip), %0&quot;</span>
<span class="quote">&gt; +	     : &quot;=r&quot; (cmdline_off)</span>
<span class="quote">&gt; +	     : &quot;p&quot; (sme_cmdline_off));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))</span>
<span class="quote">&gt; +		active_by_default = true;</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		active_by_default = false;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmdline_ptr = (const char *)((u64)bp-&gt;hdr.cmd_line_ptr |</span>
<span class="quote">&gt; +				     ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (strncmp(buffer, cmdline_on, sizeof(buffer)) == 0)</span>
<span class="quote">&gt; +		sme_me_mask = me_mask;</span>

Why doesn&#39;t simply

	if (!strncmp(buffer, &quot;on&quot;, 2))
		...

work?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 19, 2017, 11:30 a.m.</div>
<pre class="content">
On Fri, Apr 21, 2017 at 01:56:13PM -0500, Tom Lendacky wrote:
<span class="quote">&gt; On 4/18/2017 4:22 PM, Tom Lendacky wrote:</span>
<span class="quote">&gt; &gt; Add support to check if SME has been enabled and if memory encryption</span>
<span class="quote">&gt; &gt; should be activated (checking of command line option based on the</span>
<span class="quote">&gt; &gt; configuration of the default state).  If memory encryption is to be</span>
<span class="quote">&gt; &gt; activated, then the encryption mask is set and the kernel is encrypted</span>
<span class="quote">&gt; &gt; &quot;in place.&quot;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/x86/kernel/head_64.S |    1 +</span>
<span class="quote">&gt; &gt;  arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt; &gt;  2 files changed, 80 insertions(+), 4 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; -unsigned long __init sme_enable(void)</span>
<span class="quote">&gt; &gt; +unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; +	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt; &gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt; &gt; +	unsigned long me_mask;</span>
<span class="quote">&gt; &gt; +	bool active_by_default;</span>
<span class="quote">&gt; &gt; +	char buffer[16];</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So it turns out that when KASLR is enabled (CONFIG_RAMDOMIZE_BASE=y)</span>
<span class="quote">&gt; the stack-protector support causes issues with this function because</span>

What issues?
<span class="quote">
&gt; it is called so early. I can get past it by adding:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; CFLAGS_mem_encrypt.o := $(nostackp)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; in the arch/x86/mm/Makefile, but that obviously eliminates the support</span>
<span class="quote">&gt; for the whole file.  Would it be better to split out the sme_enable()</span>
<span class="quote">&gt; and other boot routines into a separate file or just apply the</span>
<span class="quote">&gt; $(nostackp) to the whole file?</span>

Josh might have a better idea here... CCed.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=95791">Josh Poimboeuf</a> - May 19, 2017, 8:16 p.m.</div>
<pre class="content">
On Fri, May 19, 2017 at 01:30:05PM +0200, Borislav Petkov wrote:
<span class="quote">&gt; &gt; it is called so early. I can get past it by adding:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; CFLAGS_mem_encrypt.o := $(nostackp)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; in the arch/x86/mm/Makefile, but that obviously eliminates the support</span>
<span class="quote">&gt; &gt; for the whole file.  Would it be better to split out the sme_enable()</span>
<span class="quote">&gt; &gt; and other boot routines into a separate file or just apply the</span>
<span class="quote">&gt; &gt; $(nostackp) to the whole file?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Josh might have a better idea here... CCed.</span>

I&#39;m the stack validation guy, not the stack protection guy :-)

But there is a way to disable compiler options on a per-function basis
with the gcc __optimize__ function attribute.  For example:

  __attribute__((__optimize__(&quot;no-stack-protector&quot;)))
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 19, 2017, 8:29 p.m.</div>
<pre class="content">
On Fri, May 19, 2017 at 03:16:51PM -0500, Josh Poimboeuf wrote:
<span class="quote">&gt; I&#39;m the stack validation guy, not the stack protection guy :-)</span>

LOL. I thought you were *the* stacks guy. :-)))

But once you&#39;ve validated it, you could protect it then too. :-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 30, 2017, 2:38 p.m.</div>
<pre class="content">
On 5/19/2017 6:27 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Tue, Apr 18, 2017 at 04:22:23PM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; Add support to check if SME has been enabled and if memory encryption</span>
<span class="quote">&gt;&gt; should be activated (checking of command line option based on the</span>
<span class="quote">&gt;&gt; configuration of the default state).  If memory encryption is to be</span>
<span class="quote">&gt;&gt; activated, then the encryption mask is set and the kernel is encrypted</span>
<span class="quote">&gt;&gt; &quot;in place.&quot;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;   arch/x86/kernel/head_64.S |    1 +</span>
<span class="quote">&gt;&gt;   arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt;&gt;   2 files changed, 80 insertions(+), 4 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; +unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt; +	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt;&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt;&gt; +	unsigned long me_mask;</span>
<span class="quote">&gt;&gt; +	bool active_by_default;</span>
<span class="quote">&gt;&gt; +	char buffer[16];</span>
<span class="quote">&gt;&gt; +	u64 msr;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check for the SME support leaf */</span>
<span class="quote">&gt;&gt; +	eax = 0x80000000;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	if (eax &lt; 0x8000001f)</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Check for the SME feature:</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt;&gt; +	 *     Secure Memory Encryption support</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt;&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	eax = 0x8000001f;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	if (!(eax &amp; 1))</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &lt;---- newline here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; +	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check if SME is enabled */</span>
<span class="quote">&gt;&gt; +	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt;&gt; +	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt;&gt; +		goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Fixups have not been applied to phys_base yet, so we must obtain</span>
<span class="quote">&gt;&gt; +	 * the address to the SME command line option data in the following</span>
<span class="quote">&gt;&gt; +	 * way.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	asm (&quot;lea sme_cmdline_arg(%%rip), %0&quot;</span>
<span class="quote">&gt;&gt; +	     : &quot;=r&quot; (cmdline_arg)</span>
<span class="quote">&gt;&gt; +	     : &quot;p&quot; (sme_cmdline_arg));</span>
<span class="quote">&gt;&gt; +	asm (&quot;lea sme_cmdline_on(%%rip), %0&quot;</span>
<span class="quote">&gt;&gt; +	     : &quot;=r&quot; (cmdline_on)</span>
<span class="quote">&gt;&gt; +	     : &quot;p&quot; (sme_cmdline_on));</span>
<span class="quote">&gt;&gt; +	asm (&quot;lea sme_cmdline_off(%%rip), %0&quot;</span>
<span class="quote">&gt;&gt; +	     : &quot;=r&quot; (cmdline_off)</span>
<span class="quote">&gt;&gt; +	     : &quot;p&quot; (sme_cmdline_off));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))</span>
<span class="quote">&gt;&gt; +		active_by_default = true;</span>
<span class="quote">&gt;&gt; +	else</span>
<span class="quote">&gt;&gt; +		active_by_default = false;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	cmdline_ptr = (const char *)((u64)bp-&gt;hdr.cmd_line_ptr |</span>
<span class="quote">&gt;&gt; +				     ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (strncmp(buffer, cmdline_on, sizeof(buffer)) == 0)</span>
<span class="quote">&gt;&gt; +		sme_me_mask = me_mask;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why doesn&#39;t simply</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	if (!strncmp(buffer, &quot;on&quot;, 2))</span>
<span class="quote">&gt; 		...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; work?</span>

In this case we&#39;re running identity mapped and the &quot;on&quot; constant ends up
as kernel address (0xffffffff81...) which results in a segfault.

Thanks,
Tom
<span class="quote">
&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 30, 2017, 2:55 p.m.</div>
<pre class="content">
On Tue, May 30, 2017 at 09:38:36AM -0500, Tom Lendacky wrote:
<span class="quote">&gt; In this case we&#39;re running identity mapped and the &quot;on&quot; constant ends up</span>
<span class="quote">&gt; as kernel address (0xffffffff81...) which results in a segfault.</span>

Would

	static const char *__on_str = &quot;on&quot;;

	...

	if (!strncmp(buffer, __pa_nodebug(__on_str), 2))
		...

work?

__phys_addr_nodebug() seems to pay attention to phys_base and
PAGE_OFFSET and so on...

I&#39;d like to avoid that rip-relative address finding in inline asm which
looks fragile to me.

Thanks.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 30, 2017, 3:37 p.m.</div>
<pre class="content">
On 5/30/2017 9:55 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Tue, May 30, 2017 at 09:38:36AM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; In this case we&#39;re running identity mapped and the &quot;on&quot; constant ends up</span>
<span class="quote">&gt;&gt; as kernel address (0xffffffff81...) which results in a segfault.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Would</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	static const char *__on_str = &quot;on&quot;;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	if (!strncmp(buffer, __pa_nodebug(__on_str), 2))</span>
<span class="quote">&gt; 		...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; work?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; __phys_addr_nodebug() seems to pay attention to phys_base and</span>
<span class="quote">&gt; PAGE_OFFSET and so on...</span>

Except that phys_base hasn&#39;t been adjusted yet so that doesn&#39;t work
either.
<span class="quote">
&gt; </span>
<span class="quote">&gt; I&#39;d like to avoid that rip-relative address finding in inline asm which</span>
<span class="quote">&gt; looks fragile to me.</span>

I can define the command line option and the &quot;on&quot; and &quot;off&quot; values as
character buffers in the function and initialize them on a per character
basis (using a static string causes the same issues as referencing a
string constant), i.e.:

char cmdline_arg[] = {&#39;m&#39;, &#39;e&#39;, &#39;m&#39;, &#39;_&#39;, &#39;e&#39;, &#39;n&#39;, &#39;c&#39;, &#39;r&#39;, &#39;y&#39;, &#39;p&#39;, &#39;t&#39;, &#39;\0&#39;};
char cmdline_off[] = {&#39;o&#39;, &#39;f&#39;, &#39;f&#39;, &#39;\0&#39;};
char cmdline_on[] = {&#39;o&#39;, &#39;n&#39;, &#39;\0&#39;};

It doesn&#39;t look the greatest, but it works and removes the need for the
rip-relative addressing.

Thanks,
Tom
<span class="quote">
&gt; </span>
<span class="quote">&gt; Thanks.</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 30, 2017, 3:46 p.m.</div>
<pre class="content">
On 5/19/2017 6:30 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Fri, Apr 21, 2017 at 01:56:13PM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; On 4/18/2017 4:22 PM, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt;&gt; Add support to check if SME has been enabled and if memory encryption</span>
<span class="quote">&gt;&gt;&gt; should be activated (checking of command line option based on the</span>
<span class="quote">&gt;&gt;&gt; configuration of the default state).  If memory encryption is to be</span>
<span class="quote">&gt;&gt;&gt; activated, then the encryption mask is set and the kernel is encrypted</span>
<span class="quote">&gt;&gt;&gt; &quot;in place.&quot;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;   arch/x86/kernel/head_64.S |    1 +</span>
<span class="quote">&gt;&gt;&gt;   arch/x86/mm/mem_encrypt.c |   83 +++++++++++++++++++++++++++++++++++++++++++--</span>
<span class="quote">&gt;&gt;&gt;   2 files changed, 80 insertions(+), 4 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; -unsigned long __init sme_enable(void)</span>
<span class="quote">&gt;&gt;&gt; +unsigned long __init sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;&gt;&gt;   {</span>
<span class="quote">&gt;&gt;&gt; +	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt;&gt;&gt; +	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt;&gt;&gt; +	unsigned long me_mask;</span>
<span class="quote">&gt;&gt;&gt; +	bool active_by_default;</span>
<span class="quote">&gt;&gt;&gt; +	char buffer[16];</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So it turns out that when KASLR is enabled (CONFIG_RAMDOMIZE_BASE=y)</span>
<span class="quote">&gt;&gt; the stack-protector support causes issues with this function because</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What issues?</span>

The stack protection support makes use of the gs segment register and
at this point not everything is setup properly to allow it to work,
so it segfaults.

Thanks,
Tom
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; it is called so early. I can get past it by adding:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; CFLAGS_mem_encrypt.o := $(nostackp)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; in the arch/x86/mm/Makefile, but that obviously eliminates the support</span>
<span class="quote">&gt;&gt; for the whole file.  Would it be better to split out the sme_enable()</span>
<span class="quote">&gt;&gt; and other boot routines into a separate file or just apply the</span>
<span class="quote">&gt;&gt; $(nostackp) to the whole file?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Josh might have a better idea here... CCed.</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 30, 2017, 3:48 p.m.</div>
<pre class="content">
On 5/19/2017 3:16 PM, Josh Poimboeuf wrote:
<span class="quote">&gt; On Fri, May 19, 2017 at 01:30:05PM +0200, Borislav Petkov wrote:</span>
<span class="quote">&gt;&gt;&gt; it is called so early. I can get past it by adding:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; CFLAGS_mem_encrypt.o := $(nostackp)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; in the arch/x86/mm/Makefile, but that obviously eliminates the support</span>
<span class="quote">&gt;&gt;&gt; for the whole file.  Would it be better to split out the sme_enable()</span>
<span class="quote">&gt;&gt;&gt; and other boot routines into a separate file or just apply the</span>
<span class="quote">&gt;&gt;&gt; $(nostackp) to the whole file?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Josh might have a better idea here... CCed.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m the stack validation guy, not the stack protection guy :-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But there is a way to disable compiler options on a per-function basis</span>
<span class="quote">&gt; with the gcc __optimize__ function attribute.  For example:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;    __attribute__((__optimize__(&quot;no-stack-protector&quot;)))</span>
<span class="quote">&gt; </span>

I&#39;ll look at doing that instead of removing the support for the whole
file.

Thanks,
Tom
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 31, 2017, 8:49 a.m.</div>
<pre class="content">
On Tue, May 30, 2017 at 10:37:03AM -0500, Tom Lendacky wrote:
<span class="quote">&gt; I can define the command line option and the &quot;on&quot; and &quot;off&quot; values as</span>
<span class="quote">&gt; character buffers in the function and initialize them on a per character</span>
<span class="quote">&gt; basis (using a static string causes the same issues as referencing a</span>
<span class="quote">&gt; string constant), i.e.:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; char cmdline_arg[] = {&#39;m&#39;, &#39;e&#39;, &#39;m&#39;, &#39;_&#39;, &#39;e&#39;, &#39;n&#39;, &#39;c&#39;, &#39;r&#39;, &#39;y&#39;, &#39;p&#39;, &#39;t&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt; char cmdline_off[] = {&#39;o&#39;, &#39;f&#39;, &#39;f&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt; char cmdline_on[] = {&#39;o&#39;, &#39;n&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It doesn&#39;t look the greatest, but it works and removes the need for the</span>
<span class="quote">&gt; rip-relative addressing.</span>

Well, I&#39;m not thrilled about this one either. It&#39;s like being between a
rock and a hard place. :-\

On the one hand, we need the encryption mask before we do the fixups and
OTOH we need to do the fixups in order to access the strings properly.
Yuck.

Well, the only thing I can think of right now is maybe define
&quot;mem_encrypt=&quot; at the end of head_64.S and pass it in from asm to
sme_enable() and then do the &quot;on&quot;/&quot;off&quot; comparsion with local char
buffers. That could make it less ugly...
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 31, 2017, 9:15 a.m.</div>
<pre class="content">
On Tue, May 30, 2017 at 10:48:27AM -0500, Tom Lendacky wrote:
<span class="quote">&gt; I&#39;ll look at doing that instead of removing the support for the whole</span>
<span class="quote">&gt; file.</span>

Right, so I don&#39;t think the stack protector is even ready that early -
we do set it up later:

        /* Set up %gs.
         *
         * The base of %gs always points to the bottom of the irqstack
         * union.  If the stack protector canary is enabled, it is
         * located at %gs:40.  Note that, on SMP, the boot cpu uses
         * init data section till per cpu areas are set up.
         */
        movl    $MSR_GS_BASE,%ecx
        movl    initial_gs(%rip),%eax
        movl    initial_gs+4(%rip),%edx
        wrmsr

so I think marking the function &quot;no-stack-protector&quot; is the only option
right now. We can always look at fixing that later.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 31, 2017, 1:37 p.m.</div>
<pre class="content">
On 5/31/2017 3:49 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Tue, May 30, 2017 at 10:37:03AM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; I can define the command line option and the &quot;on&quot; and &quot;off&quot; values as</span>
<span class="quote">&gt;&gt; character buffers in the function and initialize them on a per character</span>
<span class="quote">&gt;&gt; basis (using a static string causes the same issues as referencing a</span>
<span class="quote">&gt;&gt; string constant), i.e.:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; char cmdline_arg[] = {&#39;m&#39;, &#39;e&#39;, &#39;m&#39;, &#39;_&#39;, &#39;e&#39;, &#39;n&#39;, &#39;c&#39;, &#39;r&#39;, &#39;y&#39;, &#39;p&#39;, &#39;t&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt;&gt; char cmdline_off[] = {&#39;o&#39;, &#39;f&#39;, &#39;f&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt;&gt; char cmdline_on[] = {&#39;o&#39;, &#39;n&#39;, &#39;\0&#39;};</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It doesn&#39;t look the greatest, but it works and removes the need for the</span>
<span class="quote">&gt;&gt; rip-relative addressing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Well, I&#39;m not thrilled about this one either. It&#39;s like being between a</span>
<span class="quote">&gt; rock and a hard place. :-\</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On the one hand, we need the encryption mask before we do the fixups and</span>
<span class="quote">&gt; OTOH we need to do the fixups in order to access the strings properly.</span>
<span class="quote">&gt; Yuck.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Well, the only thing I can think of right now is maybe define</span>
<span class="quote">&gt; &quot;mem_encrypt=&quot; at the end of head_64.S and pass it in from asm to</span>
<span class="quote">&gt; sme_enable() and then do the &quot;on&quot;/&quot;off&quot; comparsion with local char</span>
<span class="quote">&gt; buffers. That could make it less ugly...</span>

I like keeping the command line option and the values together. It may
not look the greatest but I like it more than defining the command line
option in head_64.S and passing it in as an argument.

OTOH, I don&#39;t think the rip-relative addressing was that bad, I can
always go back to that...

Thanks,
Tom
<span class="quote">
&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 31, 2017, 2:12 p.m.</div>
<pre class="content">
On Wed, May 31, 2017 at 08:37:50AM -0500, Tom Lendacky wrote:
<span class="quote">&gt; I like keeping the command line option and the values together. It may</span>
<span class="quote">&gt; not look the greatest but I like it more than defining the command line</span>
<span class="quote">&gt; option in head_64.S and passing it in as an argument.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; OTOH, I don&#39;t think the rip-relative addressing was that bad, I can</span>
<span class="quote">&gt; always go back to that...</span>

Yeah, no nice solution here. Having gone full circle, the rip-relative
thing doesn&#39;t look all that bad, all of a sudden. I&#39;d let you decide
what to do...
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/kernel/head_64.S b/arch/x86/kernel/head_64.S</span>
<span class="p_header">index abfe5ee..77d7495 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_64.S</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> startup_64:</span>
 	 * Save the returned mask in %r12 for later use.
 	 */
 	push	%rsi
<span class="p_add">+	movq	%rsi, %rdi</span>
 	call	sme_enable
 	pop	%rsi
 	movq	%rax, %r12
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index 7dc4e98..b517cbc 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -28,6 +28,13 @@</span> <span class="p_context"></span>
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/mem_encrypt.h&gt;
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr.h&gt;</span>
<span class="p_add">+#include &lt;asm/cmdline.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static char sme_cmdline_arg[] __initdata = &quot;mem_encrypt&quot;;</span>
<span class="p_add">+static char sme_cmdline_on[]  __initdata = &quot;on&quot;;</span>
<span class="p_add">+static char sme_cmdline_off[] __initdata = &quot;off&quot;;</span>
 
 /*
  * Since SME related variables are set early in the boot process they must
<span class="p_chunk">@@ -255,6 +262,8 @@</span> <span class="p_context"> void __init mem_encrypt_init(void)</span>
 
 	/* Call into SWIOTLB to update the SWIOTLB DMA buffers */
 	swiotlb_update_mem_attributes();
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);</span>
 }
 
 void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)
<span class="p_chunk">@@ -531,8 +540,74 @@</span> <span class="p_context"> void __init sme_encrypt_kernel(void)</span>
 	native_write_cr3(native_read_cr3());
 }
 
<span class="p_del">-unsigned long __init sme_enable(void)</span>
<span class="p_add">+unsigned long __init sme_enable(struct boot_params *bp)</span>
 {
<span class="p_add">+	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="p_add">+	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_add">+	unsigned long me_mask;</span>
<span class="p_add">+	bool active_by_default;</span>
<span class="p_add">+	char buffer[16];</span>
<span class="p_add">+	u64 msr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check for the SME support leaf */</span>
<span class="p_add">+	eax = 0x80000000;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (eax &lt; 0x8000001f)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for the SME feature:</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="p_add">+	 *     Secure Memory Encryption support</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="p_add">+	 *     Pagetable bit position used to indicate encryption</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	eax = 0x8000001f;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	if (!(eax &amp; 1))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if SME is enabled */</span>
<span class="p_add">+	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="p_add">+	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fixups have not been applied to phys_base yet, so we must obtain</span>
<span class="p_add">+	 * the address to the SME command line option data in the following</span>
<span class="p_add">+	 * way.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	asm (&quot;lea sme_cmdline_arg(%%rip), %0&quot;</span>
<span class="p_add">+	     : &quot;=r&quot; (cmdline_arg)</span>
<span class="p_add">+	     : &quot;p&quot; (sme_cmdline_arg));</span>
<span class="p_add">+	asm (&quot;lea sme_cmdline_on(%%rip), %0&quot;</span>
<span class="p_add">+	     : &quot;=r&quot; (cmdline_on)</span>
<span class="p_add">+	     : &quot;p&quot; (sme_cmdline_on));</span>
<span class="p_add">+	asm (&quot;lea sme_cmdline_off(%%rip), %0&quot;</span>
<span class="p_add">+	     : &quot;=r&quot; (cmdline_off)</span>
<span class="p_add">+	     : &quot;p&quot; (sme_cmdline_off));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT))</span>
<span class="p_add">+		active_by_default = true;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		active_by_default = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	cmdline_ptr = (const char *)((u64)bp-&gt;hdr.cmd_line_ptr |</span>
<span class="p_add">+				     ((u64)bp-&gt;ext_cmd_line_ptr &lt;&lt; 32));</span>
<span class="p_add">+</span>
<span class="p_add">+	cmdline_find_option(cmdline_ptr, cmdline_arg, buffer, sizeof(buffer));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strncmp(buffer, cmdline_on, sizeof(buffer)) == 0)</span>
<span class="p_add">+		sme_me_mask = me_mask;</span>
<span class="p_add">+	else if (strncmp(buffer, cmdline_off, sizeof(buffer)) == 0)</span>
<span class="p_add">+		sme_me_mask = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sme_me_mask = active_by_default ? me_mask : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	return sme_me_mask;
 }
 
<span class="p_chunk">@@ -543,9 +618,9 @@</span> <span class="p_context"> unsigned long sme_get_me_mask(void)</span>
 
 #else	/* !CONFIG_AMD_MEM_ENCRYPT */
 
<span class="p_del">-void __init sme_encrypt_kernel(void)	{ }</span>
<span class="p_del">-unsigned long __init sme_enable(void)	{ return 0; }</span>
<span class="p_add">+void __init sme_encrypt_kernel(void)			{ }</span>
<span class="p_add">+unsigned long __init sme_enable(struct boot_params *bp)	{ return 0; }</span>
 
<span class="p_del">-unsigned long sme_get_me_mask(void)	{ return 0; }</span>
<span class="p_add">+unsigned long sme_get_me_mask(void)			{ return 0; }</span>
 
 #endif	/* CONFIG_AMD_MEM_ENCRYPT */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



