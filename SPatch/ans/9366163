
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.7.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.7.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 7, 2016, 2:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161007143610.GB26598@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9366163/mbox/"
   >mbox</a>
|
   <a href="/patch/9366163/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9366163/">/patch/9366163/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E19106075E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C7AE3292D6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BAD0B2965B; Fri,  7 Oct 2016 14:36:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5CBA9292D6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756766AbcJGOgi (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 7 Oct 2016 10:36:38 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:57962 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756719AbcJGOgE (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 7 Oct 2016 10:36:04 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 313D992B;
	Fri,  7 Oct 2016 14:36:01 +0000 (UTC)
Date: Fri, 7 Oct 2016 16:36:10 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.7.7
Message-ID: &lt;20161007143610.GB26598@kroah.com&gt;
References: &lt;20161007143602.GA26598@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161007143602.GA26598@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 7, 2016, 2:36 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt b/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_header">index 46c6f3ed1a1c..0fa3b0fac129 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_chunk">@@ -113,9 +113,9 @@</span> <span class="p_context"> pm8916:</span>
 	l14, l15, l16, l17, l18
 
 pm8941:
<span class="p_del">-	s1, s2, s3, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14,</span>
<span class="p_del">-	l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, lvs1, lvs2, lvs3,</span>
<span class="p_del">-	mvs1, mvs2</span>
<span class="p_add">+	s1, s2, s3, s4, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13,</span>
<span class="p_add">+	l14, l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, lvs1, lvs2, lvs3,</span>
<span class="p_add">+	5vs1, 5vs2</span>
 
 pm8994:
 	s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, l1, l2, l3, l4, l5,
<span class="p_header">diff --git a/Documentation/pinctrl.txt b/Documentation/pinctrl.txt</span>
<span class="p_header">index 4976389e432d..dd15a699ee1c 100644</span>
<span class="p_header">--- a/Documentation/pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/pinctrl.txt</span>
<span class="p_chunk">@@ -831,7 +831,7 @@</span> <span class="p_context"> separate memory range only intended for GPIO driving, and the register</span>
 range dealing with pin config and pin multiplexing get placed into a
 different memory range and a separate section of the data sheet.
 
<span class="p_del">-A flag &quot;strict&quot; in struct pinctrl_desc is available to check and deny</span>
<span class="p_add">+A flag &quot;strict&quot; in struct pinmux_ops is available to check and deny</span>
 simultaneous access to the same pin from GPIO and pin multiplexing
 consumers on hardware of this type. The pinctrl driver should set this flag
 accordingly.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 48b0120be59b..320a9308470b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 7
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S</span>
<span class="p_header">index af11c2f8f3b7..fc6d541549a2 100644</span>
<span class="p_header">--- a/arch/arm/boot/compressed/head.S</span>
<span class="p_header">+++ b/arch/arm/boot/compressed/head.S</span>
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> __armv7_mmu_cache_on:</span>
 		orrne	r0, r0, #1		@ MMU enabled
 		movne	r1, #0xfffffffd		@ domain 0 = client
 		bic     r6, r6, #1 &lt;&lt; 31        @ 32-bit translation system
<span class="p_del">-		bic     r6, r6, #3 &lt;&lt; 0         @ use only ttbr0</span>
<span class="p_add">+		bic     r6, r6, #(7 &lt;&lt; 0) | (1 &lt;&lt; 4)	@ use only ttbr0</span>
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6sx-sabreauto.dts b/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_header">index 96ea936eeeb0..240a2864d044 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6sx-sabreauto.dts</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"></span>
 	cd-gpios = &lt;&amp;gpio7 11 GPIO_ACTIVE_LOW&gt;;
 	no-1-8-v;
 	keep-power-in-suspend;
<span class="p_del">-	enable-sdio-wakup;</span>
<span class="p_add">+	wakeup-source;</span>
 	status = &quot;okay&quot;;
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/sun5i-a13.dtsi b/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_header">index 263d46dbc7e6..2d78eee7cb55 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"></span>
 			trips {
 				cpu_alert0: cpu_alert0 {
 					/* milliCelsius */
<span class="p_del">-					temperature = &lt;850000&gt;;</span>
<span class="p_add">+					temperature = &lt;85000&gt;;</span>
 					hysteresis = &lt;2000&gt;;
 					type = &quot;passive&quot;;
 				};
<span class="p_header">diff --git a/arch/arm/common/sa1111.c b/arch/arm/common/sa1111.c</span>
<span class="p_header">index fb0a0a4dfea4..0e437189b095 100644</span>
<span class="p_header">--- a/arch/arm/common/sa1111.c</span>
<span class="p_header">+++ b/arch/arm/common/sa1111.c</span>
<span class="p_chunk">@@ -869,9 +869,9 @@</span> <span class="p_context"> struct sa1111_save_data {</span>
 
 #ifdef CONFIG_PM
 
<span class="p_del">-static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
<span class="p_add">+static int sa1111_suspend_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags;
 	unsigned int val;
<span class="p_chunk">@@ -934,9 +934,9 @@</span> <span class="p_context"> static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
  *	restored by their respective drivers, and must be called
  *	via LDM after this function.
  */
<span class="p_del">-static int sa1111_resume(struct platform_device *dev)</span>
<span class="p_add">+static int sa1111_resume_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags, id;
 	void __iomem *base;
<span class="p_chunk">@@ -952,7 +952,7 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 	id = sa1111_readl(sachip-&gt;base + SA1111_SKID);
 	if ((id &amp; SKID_ID_MASK) != SKID_SA1111_ID) {
 		__sa1111_remove(sachip);
<span class="p_del">-		platform_set_drvdata(dev, NULL);</span>
<span class="p_add">+		dev_set_drvdata(dev, NULL);</span>
 		kfree(save);
 		return 0;
 	}
<span class="p_chunk">@@ -1003,8 +1003,8 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 }
 
 #else
<span class="p_del">-#define sa1111_suspend NULL</span>
<span class="p_del">-#define sa1111_resume  NULL</span>
<span class="p_add">+#define sa1111_suspend_noirq NULL</span>
<span class="p_add">+#define sa1111_resume_noirq  NULL</span>
 #endif
 
 static int sa1111_probe(struct platform_device *pdev)
<span class="p_chunk">@@ -1038,6 +1038,11 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static struct dev_pm_ops sa1111_pm_ops = {</span>
<span class="p_add">+	.suspend_noirq = sa1111_suspend_noirq,</span>
<span class="p_add">+	.resume_noirq = sa1111_resume_noirq,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  *	Not sure if this should be on the system bus or not yet.
  *	We really want some way to register a system device at
<span class="p_chunk">@@ -1050,10 +1055,9 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 static struct platform_driver sa1111_device_driver = {
 	.probe		= sa1111_probe,
 	.remove		= sa1111_remove,
<span class="p_del">-	.suspend	= sa1111_suspend,</span>
<span class="p_del">-	.resume		= sa1111_resume,</span>
 	.driver		= {
 		.name	= &quot;sa1111&quot;,
<span class="p_add">+		.pm	= &amp;sa1111_pm_ops,</span>
 	},
 };
 
<span class="p_header">diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">index a83570f10124..8ec98fc4eb2a 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static inline dma_addr_t virt_to_dma(struct device *dev, void *addr)</span>
 /* The ARM override for dma_max_pfn() */
 static inline unsigned long dma_max_pfn(struct device *dev)
 {
<span class="p_del">-	return PHYS_PFN_OFFSET + dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
<span class="p_add">+	return dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
 }
 #define dma_max_pfn(dev) dma_max_pfn(dev)
 
<span class="p_header">diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c</span>
<span class="p_header">index 2e26016a91a5..5204978ec4fa 100644</span>
<span class="p_header">--- a/arch/arm/kernel/devtree.c</span>
<span class="p_header">+++ b/arch/arm/kernel/devtree.c</span>
<span class="p_chunk">@@ -87,6 +87,8 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		return;
 
 	for_each_child_of_node(cpus, cpu) {
<span class="p_add">+		const __be32 *cell;</span>
<span class="p_add">+		int prop_bytes;</span>
 		u32 hwid;
 
 		if (of_node_cmp(cpu-&gt;type, &quot;cpu&quot;))
<span class="p_chunk">@@ -98,7 +100,8 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		 * properties is considered invalid to build the
 		 * cpu_logical_map.
 		 */
<span class="p_del">-		if (of_property_read_u32(cpu, &quot;reg&quot;, &amp;hwid)) {</span>
<span class="p_add">+		cell = of_get_property(cpu, &quot;reg&quot;, &amp;prop_bytes);</span>
<span class="p_add">+		if (!cell || prop_bytes &lt; sizeof(*cell)) {</span>
 			pr_debug(&quot; * %s missing reg property\n&quot;,
 				     cpu-&gt;full_name);
 			of_node_put(cpu);
<span class="p_chunk">@@ -106,10 +109,15 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		}
 
 		/*
<span class="p_del">-		 * 8 MSBs must be set to 0 in the DT since the reg property</span>
<span class="p_add">+		 * Bits n:24 must be set to 0 in the DT since the reg property</span>
 		 * defines the MPIDR[23:0].
 		 */
<span class="p_del">-		if (hwid &amp; ~MPIDR_HWID_BITMASK) {</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			hwid = be32_to_cpu(*cell++);</span>
<span class="p_add">+			prop_bytes -= sizeof(*cell);</span>
<span class="p_add">+		} while (!hwid &amp;&amp; prop_bytes &gt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (prop_bytes || (hwid &amp; ~MPIDR_HWID_BITMASK)) {</span>
 			of_node_put(cpu);
 			return;
 		}
<span class="p_header">diff --git a/arch/arm/mach-sa1100/clock.c b/arch/arm/mach-sa1100/clock.c</span>
<span class="p_header">index cbf53bb9c814..0db46895c82a 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/clock.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/clock.c</span>
<span class="p_chunk">@@ -125,6 +125,8 @@</span> <span class="p_context"> static unsigned long clk_36864_get_rate(struct clk *clk)</span>
 }
 
 static struct clkops clk_36864_ops = {
<span class="p_add">+	.enable		= clk_cpu_enable,</span>
<span class="p_add">+	.disable	= clk_cpu_disable,</span>
 	.get_rate	= clk_36864_get_rate,
 };
 
<span class="p_chunk">@@ -140,9 +142,8 @@</span> <span class="p_context"> static struct clk_lookup sa11xx_clkregs[] = {</span>
 	CLKDEV_INIT(NULL, &quot;OSTIMER0&quot;, &amp;clk_36864),
 };
 
<span class="p_del">-static int __init sa11xx_clk_init(void)</span>
<span class="p_add">+int __init sa11xx_clk_init(void)</span>
 {
 	clkdev_add_table(sa11xx_clkregs, ARRAY_SIZE(sa11xx_clkregs));
 	return 0;
 }
<span class="p_del">-core_initcall(sa11xx_clk_init);</span>
<span class="p_header">diff --git a/arch/arm/mach-sa1100/generic.c b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">index 345e63f4eb71..3e09beddb6e8 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 
 #include &lt;mach/hardware.h&gt;
 #include &lt;mach/irqs.h&gt;
<span class="p_add">+#include &lt;mach/reset.h&gt;</span>
 
 #include &quot;generic.h&quot;
 #include &lt;clocksource/pxa.h&gt;
<span class="p_chunk">@@ -95,6 +96,8 @@</span> <span class="p_context"> static void sa1100_power_off(void)</span>
 
 void sa11x0_restart(enum reboot_mode mode, const char *cmd)
 {
<span class="p_add">+	clear_reset_status(RESET_STATUS_ALL);</span>
<span class="p_add">+</span>
 	if (mode == REBOOT_SOFT) {
 		/* Jump into ROM at address 0 */
 		soft_restart(0);
<span class="p_chunk">@@ -388,6 +391,7 @@</span> <span class="p_context"> void __init sa1100_init_irq(void)</span>
 	sa11x0_init_irq_nodt(IRQ_GPIO0_SC, irq_resource.start);
 
 	sa1100_init_gpio();
<span class="p_add">+	sa11xx_clk_init();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm/mach-sa1100/generic.h b/arch/arm/mach-sa1100/generic.h</span>
<span class="p_header">index 0d92e119b36b..68199b603ff7 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/generic.h</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/generic.h</span>
<span class="p_chunk">@@ -44,3 +44,5 @@</span> <span class="p_context"> int sa11x0_pm_init(void);</span>
 #else
 static inline int sa11x0_pm_init(void) { return 0; }
 #endif
<span class="p_add">+</span>
<span class="p_add">+int sa11xx_clk_init(void);</span>
<span class="p_header">diff --git a/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c b/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_header">index 62437b57813e..73e3adbc1330 100644</span>
<span class="p_header">--- a/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_header">+++ b/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_chunk">@@ -41,39 +41,26 @@</span> <span class="p_context"></span>
 
 #define REGULATOR_IRQ_MASK	BIT(2)	/* IRQ2, active low */
 
<span class="p_del">-static void __iomem *irqc;</span>
<span class="p_del">-</span>
<span class="p_del">-static const u8 da9063_mask_regs[] = {</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_A,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_B,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_C,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_D,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* DA9210 System Control and Event Registers */</span>
<span class="p_add">+/* start of DA9210 System Control and Event Registers */</span>
 #define DA9210_REG_MASK_A		0x54
<span class="p_del">-#define DA9210_REG_MASK_B		0x55</span>
<span class="p_del">-</span>
<span class="p_del">-static const u8 da9210_mask_regs[] = {</span>
<span class="p_del">-	DA9210_REG_MASK_A,</span>
<span class="p_del">-	DA9210_REG_MASK_B,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void da9xxx_mask_irqs(struct i2c_client *client, const u8 regs[],</span>
<span class="p_del">-			     unsigned int nregs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
 
<span class="p_del">-	dev_info(&amp;client-&gt;dev, &quot;Masking %s interrupt sources\n&quot;, client-&gt;name);</span>
<span class="p_add">+static void __iomem *irqc;</span>
 
<span class="p_del">-	for (i = 0; i &lt; nregs; i++) {</span>
<span class="p_del">-		int error = i2c_smbus_write_byte_data(client, regs[i], ~0);</span>
<span class="p_del">-		if (error) {</span>
<span class="p_del">-			dev_err(&amp;client-&gt;dev, &quot;i2c error %d\n&quot;, error);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_add">+/* first byte sets the memory pointer, following are consecutive reg values */</span>
<span class="p_add">+static u8 da9063_irq_clr[] = { DA9063_REG_IRQ_MASK_A, 0xff, 0xff, 0xff, 0xff };</span>
<span class="p_add">+static u8 da9210_irq_clr[] = { DA9210_REG_MASK_A, 0xff, 0xff };</span>
<span class="p_add">+</span>
<span class="p_add">+static struct i2c_msg da9xxx_msgs[2] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = 0x58,</span>
<span class="p_add">+		.len = ARRAY_SIZE(da9063_irq_clr),</span>
<span class="p_add">+		.buf = da9063_irq_clr,</span>
<span class="p_add">+	}, {</span>
<span class="p_add">+		.addr = 0x68,</span>
<span class="p_add">+		.len = ARRAY_SIZE(da9210_irq_clr),</span>
<span class="p_add">+		.buf = da9210_irq_clr,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
 
 static int regulator_quirk_notify(struct notifier_block *nb,
 				  unsigned long action, void *data)
<span class="p_chunk">@@ -93,12 +80,15 @@</span> <span class="p_context"> static int regulator_quirk_notify(struct notifier_block *nb,</span>
 	client = to_i2c_client(dev);
 	dev_dbg(dev, &quot;Detected %s\n&quot;, client-&gt;name);
 
<span class="p_del">-	if ((client-&gt;addr == 0x58 &amp;&amp; !strcmp(client-&gt;name, &quot;da9063&quot;)))</span>
<span class="p_del">-		da9xxx_mask_irqs(client, da9063_mask_regs,</span>
<span class="p_del">-				 ARRAY_SIZE(da9063_mask_regs));</span>
<span class="p_del">-	else if (client-&gt;addr == 0x68 &amp;&amp; !strcmp(client-&gt;name, &quot;da9210&quot;))</span>
<span class="p_del">-		da9xxx_mask_irqs(client, da9210_mask_regs,</span>
<span class="p_del">-				 ARRAY_SIZE(da9210_mask_regs));</span>
<span class="p_add">+	if ((client-&gt;addr == 0x58 &amp;&amp; !strcmp(client-&gt;name, &quot;da9063&quot;)) ||</span>
<span class="p_add">+	    (client-&gt;addr == 0x68 &amp;&amp; !strcmp(client-&gt;name, &quot;da9210&quot;))) {</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_info(&amp;client-&gt;dev, &quot;clearing da9063/da9210 interrupts\n&quot;);</span>
<span class="p_add">+		ret = i2c_transfer(client-&gt;adapter, da9xxx_msgs, ARRAY_SIZE(da9xxx_msgs));</span>
<span class="p_add">+		if (ret != ARRAY_SIZE(da9xxx_msgs))</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;i2c error %d\n&quot;, ret);</span>
<span class="p_add">+	}</span>
 
 	mon = ioread32(irqc + IRQC_MONITOR);
 	if (mon &amp; REGULATOR_IRQ_MASK)
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index 0800d23e2fdd..b463607bc816 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> int kernel_active_single_step(void)</span>
 /* ptrace API */
 void user_enable_single_step(struct task_struct *task)
 {
<span class="p_del">-	set_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);</span>
<span class="p_del">-	set_regs_spsr_ss(task_pt_regs(task));</span>
<span class="p_add">+	struct thread_info *ti = task_thread_info(task);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!test_and_set_ti_thread_flag(ti, TIF_SINGLESTEP))</span>
<span class="p_add">+		set_regs_spsr_ss(task_pt_regs(task));</span>
 }
 
 void user_disable_single_step(struct task_struct *task)
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/pio.c b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">index 83c2a0021b56..13d3fc4270b7 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> void __init at32_init_pio(struct platform_device *pdev)</span>
 	struct resource *regs;
 	struct pio_device *pio;
 
<span class="p_del">-	if (pdev-&gt;id &gt; MAX_NR_PIO_DEVICES) {</span>
<span class="p_add">+	if (pdev-&gt;id &gt;= MAX_NR_PIO_DEVICES) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;only %d PIO devices supported\n&quot;,
 			MAX_NR_PIO_DEVICES);
 		return;
<span class="p_header">diff --git a/arch/mips/include/asm/uprobes.h b/arch/mips/include/asm/uprobes.h</span>
<span class="p_header">index 34c325c674c4..70a4a2f173ff 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/uprobes.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/uprobes.h</span>
<span class="p_chunk">@@ -36,7 +36,6 @@</span> <span class="p_context"> struct arch_uprobe {</span>
 	unsigned long	resume_epc;
 	u32	insn[2];
 	u32	ixol[2];
<span class="p_del">-	union	mips_instruction orig_inst[MAX_UINSN_BYTES / 4];</span>
 };
 
 struct arch_uprobe_task {
<span class="p_header">diff --git a/arch/mips/kernel/uprobes.c b/arch/mips/kernel/uprobes.c</span>
<span class="p_header">index 8452d933a645..4e7b89f2e244 100644</span>
<span class="p_header">--- a/arch/mips/kernel/uprobes.c</span>
<span class="p_header">+++ b/arch/mips/kernel/uprobes.c</span>
<span class="p_chunk">@@ -157,7 +157,6 @@</span> <span class="p_context"> bool is_trap_insn(uprobe_opcode_t *insn)</span>
 int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)
 {
 	struct uprobe_task *utask = current-&gt;utask;
<span class="p_del">-	union mips_instruction insn;</span>
 
 	/*
 	 * Now find the EPC where to resume after the breakpoint has been
<span class="p_chunk">@@ -168,10 +167,10 @@</span> <span class="p_context"> int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)</span>
 		unsigned long epc;
 
 		epc = regs-&gt;cp0_epc;
<span class="p_del">-		__compute_return_epc_for_insn(regs, insn);</span>
<span class="p_add">+		__compute_return_epc_for_insn(regs,</span>
<span class="p_add">+			(union mips_instruction) aup-&gt;insn[0]);</span>
 		aup-&gt;resume_epc = regs-&gt;cp0_epc;
 	}
<span class="p_del">-</span>
 	utask-&gt;autask.saved_trap_nr = current-&gt;thread.trap_nr;
 	current-&gt;thread.trap_nr = UPROBE_TRAP_NR;
 	regs-&gt;cp0_epc = current-&gt;utask-&gt;xol_vaddr;
<span class="p_chunk">@@ -257,7 +256,7 @@</span> <span class="p_context"> unsigned long arch_uretprobe_hijack_return_addr(</span>
 	ra = regs-&gt;regs[31];
 
 	/* Replace the return address with the trampoline address */
<span class="p_del">-	regs-&gt;regs[31] = ra;</span>
<span class="p_add">+	regs-&gt;regs[31] = trampoline_vaddr;</span>
 
 	return ra;
 }
<span class="p_chunk">@@ -280,24 +279,6 @@</span> <span class="p_context"> int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm,</span>
 	return uprobe_write_opcode(mm, vaddr, UPROBE_SWBP_INSN);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * set_orig_insn - Restore the original instruction.</span>
<span class="p_del">- * @mm: the probed process address space.</span>
<span class="p_del">- * @auprobe: arch specific probepoint information.</span>
<span class="p_del">- * @vaddr: the virtual address to insert the opcode.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For mm @mm, restore the original opcode (opcode) at @vaddr.</span>
<span class="p_del">- * Return 0 (success) or a negative errno.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This overrides the weak version in kernel/events/uprobes.c.</span>
<span class="p_del">- */</span>
<span class="p_del">-int set_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,</span>
<span class="p_del">-		 unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return uprobe_write_opcode(mm, vaddr,</span>
<span class="p_del">-			*(uprobe_opcode_t *)&amp;auprobe-&gt;orig_inst[0].word);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 				  void *src, unsigned long len)
 {
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-setup.c b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">index 33d5ff5069e5..18b37a573eb4 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/console.h&gt;
 #endif
 
<span class="p_add">+#define ROCIT_CONFIG_GEN0		0x1f403000</span>
<span class="p_add">+#define  ROCIT_CONFIG_GEN0_PCI_IOCU	BIT(7)</span>
<span class="p_add">+</span>
 extern void malta_be_init(void);
 extern int malta_be_handler(struct pt_regs *regs, int is_fixup);
 
<span class="p_chunk">@@ -107,6 +110,8 @@</span> <span class="p_context"> static void __init fd_activate(void)</span>
 static int __init plat_enable_iocoherency(void)
 {
 	int supported = 0;
<span class="p_add">+	u32 cfg;</span>
<span class="p_add">+</span>
 	if (mips_revision_sconid == MIPS_REVISION_SCON_BONITO) {
 		if (BONITO_PCICACHECTRL &amp; BONITO_PCICACHECTRL_CPUCOH_PRES) {
 			BONITO_PCICACHECTRL |= BONITO_PCICACHECTRL_CPUCOH_EN;
<span class="p_chunk">@@ -129,7 +134,8 @@</span> <span class="p_context"> static int __init plat_enable_iocoherency(void)</span>
 	} else if (mips_cm_numiocu() != 0) {
 		/* Nothing special needs to be done to enable coherency */
 		pr_info(&quot;CMP IOCU detected\n&quot;);
<span class="p_del">-		if ((*(unsigned int *)0xbf403000 &amp; 0x81) != 0x81) {</span>
<span class="p_add">+		cfg = __raw_readl((u32 *)CKSEG1ADDR(ROCIT_CONFIG_GEN0));</span>
<span class="p_add">+		if (!(cfg &amp; ROCIT_CONFIG_GEN0_PCI_IOCU)) {</span>
 			pr_crit(&quot;IOCU OPERATION DISABLED BY SWITCH - DEFAULTING TO SW IO COHERENCY\n&quot;);
 			return 0;
 		}
<span class="p_header">diff --git a/arch/powerpc/kernel/prom_init.c b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">index 6ee4b72cda42..e97925ffa6c7 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_chunk">@@ -695,7 +695,7 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	OV4_MIN_ENT_CAP,		/* minimum VP entitled capacity */
 
 	/* option vector 5: PAPR/OF options */
<span class="p_del">-	VECTOR_LENGTH(18),		/* length */</span>
<span class="p_add">+	VECTOR_LENGTH(21),		/* length */</span>
 	0,				/* don&#39;t ignore, don&#39;t halt */
 	OV5_FEAT(OV5_LPAR) | OV5_FEAT(OV5_SPLPAR) | OV5_FEAT(OV5_LARGE_PAGES) |
 	OV5_FEAT(OV5_DRCONF_MEMORY) | OV5_FEAT(OV5_DONATE_DEDICATE_CPU) |
<span class="p_chunk">@@ -726,8 +726,11 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	0,
 	0,
 	OV5_FEAT(OV5_PFO_HW_RNG) | OV5_FEAT(OV5_PFO_HW_ENCR) |
<span class="p_del">-	OV5_FEAT(OV5_PFO_HW_842),</span>
<span class="p_del">-	OV5_FEAT(OV5_SUB_PROCESSORS),</span>
<span class="p_add">+	OV5_FEAT(OV5_PFO_HW_842),				/* Byte 17 */</span>
<span class="p_add">+	0,							/* Byte 18 */</span>
<span class="p_add">+	0,							/* Byte 19 */</span>
<span class="p_add">+	0,							/* Byte 20 */</span>
<span class="p_add">+	OV5_FEAT(OV5_SUB_PROCESSORS),				/* Byte 21 */</span>
 
 	/* option vector 6: IBM PAPR hints */
 	VECTOR_LENGTH(3),		/* length */
<span class="p_header">diff --git a/arch/tile/include/asm/elf.h b/arch/tile/include/asm/elf.h</span>
<span class="p_header">index c505d77e4d06..e9d54a06736f 100644</span>
<span class="p_header">--- a/arch/tile/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/tile/include/asm/elf.h</span>
<span class="p_chunk">@@ -129,6 +129,7 @@</span> <span class="p_context"> extern int dump_task_regs(struct task_struct *, elf_gregset_t *);</span>
 struct linux_binprm;
 extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 				       int executable_stack);
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO \
 do { \
 	NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_BASE); \
<span class="p_header">diff --git a/arch/tile/include/uapi/asm/auxvec.h b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">index c93e92709f14..f497123ed980 100644</span>
<span class="p_header">--- a/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -18,4 +18,6 @@</span> <span class="p_context"></span>
 /* The vDSO location. */
 #define AT_SYSINFO_EHDR         33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif /* _ASM_TILE_AUXVEC_H */
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 6fa85944af83..dee8a70382ba 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> DECLARE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate);</span>
 /* Initialize cr4 shadow for this CPU. */
 static inline void cr4_init_shadow(void)
 {
<span class="p_del">-	this_cpu_write(cpu_tlbstate.cr4, __read_cr4());</span>
<span class="p_add">+	this_cpu_write(cpu_tlbstate.cr4, __read_cr4_safe());</span>
 }
 
 /* Set in this cpu&#39;s CR4. */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 0fe6953f421c..41f3f7dd6323 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -804,21 +804,20 @@</span> <span class="p_context"> static void __init early_identify_cpu(struct cpuinfo_x86 *c)</span>
 		identify_cpu_without_cpuid(c);
 
 	/* cyrix could have cpuid enabled via c_identify()*/
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (have_cpuid_p()) {</span>
<span class="p_add">+		cpu_detect(c);</span>
<span class="p_add">+		get_cpu_vendor(c);</span>
<span class="p_add">+		get_cpu_cap(c);</span>
 
<span class="p_del">-	cpu_detect(c);</span>
<span class="p_del">-	get_cpu_vendor(c);</span>
<span class="p_del">-	get_cpu_cap(c);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (this_cpu-&gt;c_early_init)</span>
<span class="p_del">-		this_cpu-&gt;c_early_init(c);</span>
<span class="p_add">+		if (this_cpu-&gt;c_early_init)</span>
<span class="p_add">+			this_cpu-&gt;c_early_init(c);</span>
 
<span class="p_del">-	c-&gt;cpu_index = 0;</span>
<span class="p_del">-	filter_cpuid_features(c, false);</span>
<span class="p_add">+		c-&gt;cpu_index = 0;</span>
<span class="p_add">+		filter_cpuid_features(c, false);</span>
 
<span class="p_del">-	if (this_cpu-&gt;c_bsp_init)</span>
<span class="p_del">-		this_cpu-&gt;c_bsp_init(c);</span>
<span class="p_add">+		if (this_cpu-&gt;c_bsp_init)</span>
<span class="p_add">+			this_cpu-&gt;c_bsp_init(c);</span>
<span class="p_add">+	}</span>
 
 	setup_force_cpu_cap(X86_FEATURE_ALWAYS);
 	fpu__init_system(c);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 8326d6891395..9ed64d2b9ab1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -409,6 +409,7 @@</span> <span class="p_context"> struct nested_vmx {</span>
 	struct list_head vmcs02_pool;
 	int vmcs02_num;
 	u64 vmcs01_tsc_offset;
<span class="p_add">+	bool change_vmcs01_virtual_x2apic_mode;</span>
 	/* L2 must run next, and mustn&#39;t decide to exit to L1. */
 	bool nested_run_pending;
 	/*
<span class="p_chunk">@@ -8284,6 +8285,12 @@</span> <span class="p_context"> static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)</span>
 {
 	u32 sec_exec_control;
 
<span class="p_add">+	/* Postpone execution until vmcs01 is the current VMCS. */</span>
<span class="p_add">+	if (is_guest_mode(vcpu)) {</span>
<span class="p_add">+		to_vmx(vcpu)-&gt;nested.change_vmcs01_virtual_x2apic_mode = true;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * There is not point to enable virtualize x2apic without enable
 	 * apicv
<span class="p_chunk">@@ -10601,6 +10608,12 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 	/* Update TSC_OFFSET if TSC was changed while L2 ran */
 	vmcs_write64(TSC_OFFSET, vmx-&gt;nested.vmcs01_tsc_offset);
 
<span class="p_add">+	if (vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode) {</span>
<span class="p_add">+		vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode = false;</span>
<span class="p_add">+		vmx_set_virtual_x2apic_mode(vcpu,</span>
<span class="p_add">+				vcpu-&gt;arch.apic_base &amp; X2APIC_ENABLE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* This is needed for same reason as it was needed in prepare_vmcs02 */
 	vmx-&gt;host_rsp = 0;
 
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index f9b9049b1284..27dafb3a7a0e 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -784,7 +784,7 @@</span> <span class="p_context"> static void __blk_mq_run_hw_queue(struct blk_mq_hw_ctx *hctx)</span>
 		switch (ret) {
 		case BLK_MQ_RQ_QUEUE_OK:
 			queued++;
<span class="p_del">-			continue;</span>
<span class="p_add">+			break;</span>
 		case BLK_MQ_RQ_QUEUE_BUSY:
 			list_add(&amp;rq-&gt;queuelist, &amp;rq_list);
 			__blk_mq_requeue_request(rq);
<span class="p_header">diff --git a/drivers/base/regmap/regcache-rbtree.c b/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_header">index aa56af87d941..b11af3f2c1db 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regcache-rbtree.c</span>
<span class="p_chunk">@@ -404,6 +404,7 @@</span> <span class="p_context"> static int regcache_rbtree_write(struct regmap *map, unsigned int reg,</span>
 		unsigned int new_base_reg, new_top_reg;
 		unsigned int min, max;
 		unsigned int max_dist;
<span class="p_add">+		unsigned int dist, best_dist = UINT_MAX;</span>
 
 		max_dist = map-&gt;reg_stride * sizeof(*rbnode_tmp) /
 			map-&gt;cache_word_size;
<span class="p_chunk">@@ -423,24 +424,41 @@</span> <span class="p_context"> static int regcache_rbtree_write(struct regmap *map, unsigned int reg,</span>
 				&amp;base_reg, &amp;top_reg);
 
 			if (base_reg &lt;= max &amp;&amp; top_reg &gt;= min) {
<span class="p_del">-				new_base_reg = min(reg, base_reg);</span>
<span class="p_del">-				new_top_reg = max(reg, top_reg);</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				if (max &lt; base_reg)</span>
<span class="p_del">-					node = node-&gt;rb_left;</span>
<span class="p_add">+				if (reg &lt; base_reg)</span>
<span class="p_add">+					dist = base_reg - reg;</span>
<span class="p_add">+				else if (reg &gt; top_reg)</span>
<span class="p_add">+					dist = reg - top_reg;</span>
 				else
<span class="p_del">-					node = node-&gt;rb_right;</span>
<span class="p_del">-</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+					dist = 0;</span>
<span class="p_add">+				if (dist &lt; best_dist) {</span>
<span class="p_add">+					rbnode = rbnode_tmp;</span>
<span class="p_add">+					best_dist = dist;</span>
<span class="p_add">+					new_base_reg = min(reg, base_reg);</span>
<span class="p_add">+					new_top_reg = max(reg, top_reg);</span>
<span class="p_add">+				}</span>
 			}
 
<span class="p_del">-			ret = regcache_rbtree_insert_to_block(map, rbnode_tmp,</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Keep looking, we want to choose the closest block,</span>
<span class="p_add">+			 * otherwise we might end up creating overlapping</span>
<span class="p_add">+			 * blocks, which breaks the rbtree.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (reg &lt; base_reg)</span>
<span class="p_add">+				node = node-&gt;rb_left;</span>
<span class="p_add">+			else if (reg &gt; top_reg)</span>
<span class="p_add">+				node = node-&gt;rb_right;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (rbnode) {</span>
<span class="p_add">+			ret = regcache_rbtree_insert_to_block(map, rbnode,</span>
 							      new_base_reg,
 							      new_top_reg, reg,
 							      value);
 			if (ret)
 				return ret;
<span class="p_del">-			rbtree_ctx-&gt;cached_rbnode = rbnode_tmp;</span>
<span class="p_add">+			rbtree_ctx-&gt;cached_rbnode = rbnode;</span>
 			return 0;
 		}
 
<span class="p_header">diff --git a/drivers/char/hw_random/omap-rng.c b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">index 8a1432e8bb80..01d4be2c354b 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_chunk">@@ -384,7 +384,12 @@</span> <span class="p_context"> static int omap_rng_probe(struct platform_device *pdev)</span>
 	}
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span>
<span class="p_add">+		goto err_ioremap;</span>
<span class="p_add">+	}</span>
 
 	ret = (dev-&gt;of_node) ? of_get_omap_rng_device_details(priv, pdev) :
 				get_omap_rng_device_details(priv);
<span class="p_chunk">@@ -435,8 +440,15 @@</span> <span class="p_context"> static int __maybe_unused omap_rng_suspend(struct device *dev)</span>
 static int __maybe_unused omap_rng_resume(struct device *dev)
 {
 	struct omap_rng_dev *priv = dev_get_drvdata(dev);
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pm_runtime_get_sync(dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(dev);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	pm_runtime_get_sync(dev);</span>
 	priv-&gt;pdata-&gt;init(priv);
 
 	return 0;
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index b28e4da3d2cf..ca2d2386a4eb 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -703,7 +703,7 @@</span> <span class="p_context"> ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,</span>
 
 	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), desc);
 	if (!rc)
<span class="p_del">-		*value = cmd.params.get_tpm_pt_out.value;</span>
<span class="p_add">+		*value = be32_to_cpu(cmd.params.get_tpm_pt_out.value);</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index e9fd1d83f9f1..0f7ec0deed6c 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -77,7 +77,6 @@</span> <span class="p_context"> enum crb_flags {</span>
 
 struct crb_priv {
 	unsigned int flags;
<span class="p_del">-	struct resource res;</span>
 	void __iomem *iobase;
 	struct crb_control_area __iomem *cca;
 	u8 __iomem *cmd;
<span class="p_chunk">@@ -224,19 +223,19 @@</span> <span class="p_context"> static int crb_init(struct acpi_device *device, struct crb_priv *priv)</span>
 
 static int crb_check_resource(struct acpi_resource *ares, void *data)
 {
<span class="p_del">-	struct crb_priv *priv = data;</span>
<span class="p_add">+	struct resource *io_res = data;</span>
 	struct resource res;
 
 	if (acpi_dev_resource_memory(ares, &amp;res)) {
<span class="p_del">-		priv-&gt;res = res;</span>
<span class="p_del">-		priv-&gt;res.name = NULL;</span>
<span class="p_add">+		*io_res = res;</span>
<span class="p_add">+		io_res-&gt;name = NULL;</span>
 	}
 
 	return 1;
 }
 
 static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,
<span class="p_del">-				 u64 start, u32 size)</span>
<span class="p_add">+				 struct resource *io_res, u64 start, u32 size)</span>
 {
 	struct resource new_res = {
 		.start	= start,
<span class="p_chunk">@@ -248,51 +247,72 @@</span> <span class="p_context"> static void __iomem *crb_map_res(struct device *dev, struct crb_priv *priv,</span>
 	if (start != new_res.start)
 		return (void __iomem *) ERR_PTR(-EINVAL);
 
<span class="p_del">-	if (!resource_contains(&amp;priv-&gt;res, &amp;new_res))</span>
<span class="p_add">+	if (!resource_contains(io_res, &amp;new_res))</span>
 		return devm_ioremap_resource(dev, &amp;new_res);
 
<span class="p_del">-	return priv-&gt;iobase + (new_res.start - priv-&gt;res.start);</span>
<span class="p_add">+	return priv-&gt;iobase + (new_res.start - io_res-&gt;start);</span>
 }
 
 static int crb_map_io(struct acpi_device *device, struct crb_priv *priv,
 		      struct acpi_table_tpm2 *buf)
 {
 	struct list_head resources;
<span class="p_add">+	struct resource io_res;</span>
 	struct device *dev = &amp;device-&gt;dev;
<span class="p_del">-	u64 pa;</span>
<span class="p_add">+	u64 cmd_pa;</span>
<span class="p_add">+	u32 cmd_size;</span>
<span class="p_add">+	u64 rsp_pa;</span>
<span class="p_add">+	u32 rsp_size;</span>
 	int ret;
 
 	INIT_LIST_HEAD(&amp;resources);
 	ret = acpi_dev_get_resources(device, &amp;resources, crb_check_resource,
<span class="p_del">-				     priv);</span>
<span class="p_add">+				     &amp;io_res);</span>
 	if (ret &lt; 0)
 		return ret;
 	acpi_dev_free_resource_list(&amp;resources);
 
<span class="p_del">-	if (resource_type(&amp;priv-&gt;res) != IORESOURCE_MEM) {</span>
<span class="p_add">+	if (resource_type(&amp;io_res) != IORESOURCE_MEM) {</span>
 		dev_err(dev,
 			FW_BUG &quot;TPM2 ACPI table does not define a memory resource\n&quot;);
 		return -EINVAL;
 	}
 
<span class="p_del">-	priv-&gt;iobase = devm_ioremap_resource(dev, &amp;priv-&gt;res);</span>
<span class="p_add">+	priv-&gt;iobase = devm_ioremap_resource(dev, &amp;io_res);</span>
 	if (IS_ERR(priv-&gt;iobase))
 		return PTR_ERR(priv-&gt;iobase);
 
<span class="p_del">-	priv-&gt;cca = crb_map_res(dev, priv, buf-&gt;control_address, 0x1000);</span>
<span class="p_add">+	priv-&gt;cca = crb_map_res(dev, priv, &amp;io_res, buf-&gt;control_address,</span>
<span class="p_add">+				sizeof(struct crb_control_area));</span>
 	if (IS_ERR(priv-&gt;cca))
 		return PTR_ERR(priv-&gt;cca);
 
<span class="p_del">-	pa = ((u64) ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_high) &lt;&lt; 32) |</span>
<span class="p_del">-	      (u64) ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_low);</span>
<span class="p_del">-	priv-&gt;cmd = crb_map_res(dev, priv, pa, ioread32(&amp;priv-&gt;cca-&gt;cmd_size));</span>
<span class="p_add">+	cmd_pa = ((u64) ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_high) &lt;&lt; 32) |</span>
<span class="p_add">+		  (u64) ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_low);</span>
<span class="p_add">+	cmd_size = ioread32(&amp;priv-&gt;cca-&gt;cmd_size);</span>
<span class="p_add">+	priv-&gt;cmd = crb_map_res(dev, priv, &amp;io_res, cmd_pa, cmd_size);</span>
 	if (IS_ERR(priv-&gt;cmd))
 		return PTR_ERR(priv-&gt;cmd);
 
<span class="p_del">-	memcpy_fromio(&amp;pa, &amp;priv-&gt;cca-&gt;rsp_pa, 8);</span>
<span class="p_del">-	pa = le64_to_cpu(pa);</span>
<span class="p_del">-	priv-&gt;rsp = crb_map_res(dev, priv, pa, ioread32(&amp;priv-&gt;cca-&gt;rsp_size));</span>
<span class="p_del">-	return PTR_ERR_OR_ZERO(priv-&gt;rsp);</span>
<span class="p_add">+	memcpy_fromio(&amp;rsp_pa, &amp;priv-&gt;cca-&gt;rsp_pa, 8);</span>
<span class="p_add">+	rsp_pa = le64_to_cpu(rsp_pa);</span>
<span class="p_add">+	rsp_size = ioread32(&amp;priv-&gt;cca-&gt;rsp_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cmd_pa != rsp_pa) {</span>
<span class="p_add">+		priv-&gt;rsp = crb_map_res(dev, priv, &amp;io_res, rsp_pa, rsp_size);</span>
<span class="p_add">+		return PTR_ERR_OR_ZERO(priv-&gt;rsp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* According to the PTP specification, overlapping command and response</span>
<span class="p_add">+	 * buffer sizes must be identical.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cmd_size != rsp_size) {</span>
<span class="p_add">+		dev_err(dev, FW_BUG &quot;overlapping command and response buffer sizes are not identical&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;rsp = priv-&gt;cmd;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int crb_acpi_add(struct acpi_device *device)
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index 75bd6621dc5d..de9a3d7505a4 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -1195,8 +1195,8 @@</span> <span class="p_context"> static struct at_xdmac_desc *at_xdmac_memset_create_desc(struct dma_chan *chan,</span>
 	desc-&gt;lld.mbr_cfg = chan_cc;
 
 	dev_dbg(chan2dev(chan),
<span class="p_del">-		&quot;%s: lld: mbr_da=%pad, mbr_ds=%pad, mbr_ubc=0x%08x, mbr_cfg=0x%08x\n&quot;,</span>
<span class="p_del">-		__func__, &amp;desc-&gt;lld.mbr_da, &amp;desc-&gt;lld.mbr_ds, desc-&gt;lld.mbr_ubc,</span>
<span class="p_add">+		&quot;%s: lld: mbr_da=%pad, mbr_ds=0x%08x, mbr_ubc=0x%08x, mbr_cfg=0x%08x\n&quot;,</span>
<span class="p_add">+		__func__, &amp;desc-&gt;lld.mbr_da, desc-&gt;lld.mbr_ds, desc-&gt;lld.mbr_ubc,</span>
 		desc-&gt;lld.mbr_cfg);
 
 	return desc;
<span class="p_chunk">@@ -2067,7 +2067,7 @@</span> <span class="p_context"> err_dma_unregister:</span>
 err_clk_disable:
 	clk_disable_unprepare(atxdmac-&gt;clk);
 err_free_irq:
<span class="p_del">-	free_irq(atxdmac-&gt;irq, atxdmac-&gt;dma.dev);</span>
<span class="p_add">+	free_irq(atxdmac-&gt;irq, atxdmac);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -2081,7 +2081,7 @@</span> <span class="p_context"> static int at_xdmac_remove(struct platform_device *pdev)</span>
 	dma_async_device_unregister(&amp;atxdmac-&gt;dma);
 	clk_disable_unprepare(atxdmac-&gt;clk);
 
<span class="p_del">-	free_irq(atxdmac-&gt;irq, atxdmac-&gt;dma.dev);</span>
<span class="p_add">+	free_irq(atxdmac-&gt;irq, atxdmac);</span>
 
 	for (i = 0; i &lt; atxdmac-&gt;dma.chancnt; i++) {
 		struct at_xdmac_chan *atchan = &amp;atxdmac-&gt;chan[i];
<span class="p_header">diff --git a/drivers/dma/bcm2835-dma.c b/drivers/dma/bcm2835-dma.c</span>
<span class="p_header">index 6149b27c33ad..c8dd5b00c1b4 100644</span>
<span class="p_header">--- a/drivers/dma/bcm2835-dma.c</span>
<span class="p_header">+++ b/drivers/dma/bcm2835-dma.c</span>
<span class="p_chunk">@@ -393,11 +393,12 @@</span> <span class="p_context"> static void bcm2835_dma_fill_cb_chain_with_sg(</span>
 	unsigned int sg_len)
 {
 	struct bcm2835_chan *c = to_bcm2835_dma_chan(chan);
<span class="p_del">-	size_t max_len = bcm2835_dma_max_frame_length(c);</span>
<span class="p_del">-	unsigned int i, len;</span>
<span class="p_add">+	size_t len, max_len;</span>
<span class="p_add">+	unsigned int i;</span>
 	dma_addr_t addr;
 	struct scatterlist *sgent;
 
<span class="p_add">+	max_len = bcm2835_dma_max_frame_length(c);</span>
 	for_each_sg(sgl, sgent, sg_len, i) {
 		for (addr = sg_dma_address(sgent), len = sg_dma_len(sgent);
 		     len &gt; 0;
<span class="p_header">diff --git a/drivers/gpio/gpio-sa1100.c b/drivers/gpio/gpio-sa1100.c</span>
<span class="p_header">index 0c99e8fb9af3..8d8ee0ebf14c 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-sa1100.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-sa1100.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static int sa1100_gpio_irqdomain_map(struct irq_domain *d,</span>
 {
 	irq_set_chip_and_handler(irq, &amp;sa1100_gpio_irq_chip,
 				 handle_edge_irq);
<span class="p_del">-	irq_set_noprobe(irq);</span>
<span class="p_add">+	irq_set_probe(irq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_header">index edec30fd3ecd..0a7b6ed5ed28 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_chunk">@@ -37,7 +37,10 @@</span> <span class="p_context"> nv04_fifo_dma_object_dtor(struct nvkm_fifo_chan *base, int cookie)</span>
 {
 	struct nv04_fifo_chan *chan = nv04_fifo_chan(base);
 	struct nvkm_instmem *imem = chan-&gt;fifo-&gt;base.engine.subdev.device-&gt;imem;
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;chan-&gt;fifo-&gt;base.engine.subdev.mutex);</span>
 	nvkm_ramht_remove(imem-&gt;ramht, cookie);
<span class="p_add">+	mutex_unlock(&amp;chan-&gt;fifo-&gt;base.engine.subdev.mutex);</span>
 }
 
 static int
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index e6abc09b67e3..1f78ec2548ec 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -3015,6 +3015,12 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 	if (rdev-&gt;pdev-&gt;device == 0x6811 &amp;&amp;
 	    rdev-&gt;pdev-&gt;revision == 0x81)
 		max_mclk = 120000;
<span class="p_add">+	/* limit sclk/mclk on Jet parts for stability */</span>
<span class="p_add">+	if (rdev-&gt;pdev-&gt;device == 0x6665 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;revision == 0xc3) {</span>
<span class="p_add">+		max_sclk = 75000;</span>
<span class="p_add">+		max_mclk = 80000;</span>
<span class="p_add">+	}</span>
 
 	if (rps-&gt;vce_active) {
 		rps-&gt;evclk = rdev-&gt;pm.dpm.vce_states[rdev-&gt;pm.dpm.vce_level].evclk;
<span class="p_header">diff --git a/drivers/gpu/drm/udl/udl_fb.c b/drivers/gpu/drm/udl/udl_fb.c</span>
<span class="p_header">index d5df555aeba0..cc2dabab270b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/udl/udl_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/udl/udl_fb.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,</span>
 		return 0;
 	cmd = urb-&gt;transfer_buffer;
 
<span class="p_del">-	for (i = y; i &lt; height ; i++) {</span>
<span class="p_add">+	for (i = y; i &lt; y + height ; i++) {</span>
 		const int line_offset = fb-&gt;base.pitches[0] * i;
 		const int byte_offset = line_offset + (x * bpp);
 		const int dev_byte_offset = (fb-&gt;base.width * bpp * i) + (x * bpp);
<span class="p_header">diff --git a/drivers/hwmon/adt7411.c b/drivers/hwmon/adt7411.c</span>
<span class="p_header">index 827c03703128..a7f886961830 100644</span>
<span class="p_header">--- a/drivers/hwmon/adt7411.c</span>
<span class="p_header">+++ b/drivers/hwmon/adt7411.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 
 #define ADT7411_REG_CFG1			0x18
 #define ADT7411_CFG1_START_MONITOR		(1 &lt;&lt; 0)
<span class="p_add">+#define ADT7411_CFG1_RESERVED_BIT3		(1 &lt;&lt; 3)</span>
 
 #define ADT7411_REG_CFG2			0x19
 #define ADT7411_CFG2_DISABLE_AVG		(1 &lt;&lt; 5)
<span class="p_chunk">@@ -296,8 +297,10 @@</span> <span class="p_context"> static int adt7411_probe(struct i2c_client *client,</span>
 	mutex_init(&amp;data-&gt;device_lock);
 	mutex_init(&amp;data-&gt;update_lock);
 
<span class="p_add">+	/* According to the datasheet, we must only write 1 to bit 3 */</span>
 	ret = adt7411_modify_bit(client, ADT7411_REG_CFG1,
<span class="p_del">-				 ADT7411_CFG1_START_MONITOR, 1);</span>
<span class="p_add">+				 ADT7411_CFG1_RESERVED_BIT3</span>
<span class="p_add">+				 | ADT7411_CFG1_START_MONITOR, 1);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-demux-pinctrl.c b/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_header">index 215ac87f606d..e999125ce37d 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_chunk">@@ -37,8 +37,6 @@</span> <span class="p_context"> struct i2c_demux_pinctrl_priv {</span>
 	struct i2c_demux_pinctrl_chan chan[];
 };
 
<span class="p_del">-static struct property status_okay = { .name = &quot;status&quot;, .length = 3, .value = &quot;ok&quot; };</span>
<span class="p_del">-</span>
 static int i2c_demux_master_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 {
 	struct i2c_demux_pinctrl_priv *priv = adap-&gt;algo_data;
<span class="p_chunk">@@ -192,6 +190,7 @@</span> <span class="p_context"> static int i2c_demux_pinctrl_probe(struct platform_device *pdev)</span>
 {
 	struct device_node *np = pdev-&gt;dev.of_node;
 	struct i2c_demux_pinctrl_priv *priv;
<span class="p_add">+	struct property *props;</span>
 	int num_chan, i, j, err;
 
 	num_chan = of_count_phandle_with_args(np, &quot;i2c-parent&quot;, NULL);
<span class="p_chunk">@@ -202,7 +201,10 @@</span> <span class="p_context"> static int i2c_demux_pinctrl_probe(struct platform_device *pdev)</span>
 
 	priv = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*priv)
 			   + num_chan * sizeof(struct i2c_demux_pinctrl_chan), GFP_KERNEL);
<span class="p_del">-	if (!priv)</span>
<span class="p_add">+</span>
<span class="p_add">+	props = devm_kcalloc(&amp;pdev-&gt;dev, num_chan, sizeof(*props), GFP_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv || !props)</span>
 		return -ENOMEM;
 
 	err = of_property_read_string(np, &quot;i2c-bus-name&quot;, &amp;priv-&gt;bus_name);
<span class="p_chunk">@@ -220,8 +222,12 @@</span> <span class="p_context"> static int i2c_demux_pinctrl_probe(struct platform_device *pdev)</span>
 		}
 		priv-&gt;chan[i].parent_np = adap_np;
 
<span class="p_add">+		props[i].name = devm_kstrdup(&amp;pdev-&gt;dev, &quot;status&quot;, GFP_KERNEL);</span>
<span class="p_add">+		props[i].value = devm_kstrdup(&amp;pdev-&gt;dev, &quot;ok&quot;, GFP_KERNEL);</span>
<span class="p_add">+		props[i].length = 3;</span>
<span class="p_add">+</span>
 		of_changeset_init(&amp;priv-&gt;chan[i].chgset);
<span class="p_del">-		of_changeset_update_property(&amp;priv-&gt;chan[i].chgset, adap_np, &amp;status_okay);</span>
<span class="p_add">+		of_changeset_update_property(&amp;priv-&gt;chan[i].chgset, adap_np, &amp;props[i]);</span>
 	}
 
 	priv-&gt;num_chan = num_chan;
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index ad1b1adcf6f0..8b5abc4ce202 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -2452,18 +2452,24 @@</span> <span class="p_context"> static int cma_resolve_iboe_route(struct rdma_id_private *id_priv)</span>
 
 	if (addr-&gt;dev_addr.bound_dev_if) {
 		ndev = dev_get_by_index(&amp;init_net, addr-&gt;dev_addr.bound_dev_if);
<span class="p_del">-		if (!ndev)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (!ndev) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto err2;</span>
<span class="p_add">+		}</span>
 
 		if (ndev-&gt;flags &amp; IFF_LOOPBACK) {
 			dev_put(ndev);
<span class="p_del">-			if (!id_priv-&gt;id.device-&gt;get_netdev)</span>
<span class="p_del">-				return -EOPNOTSUPP;</span>
<span class="p_add">+			if (!id_priv-&gt;id.device-&gt;get_netdev) {</span>
<span class="p_add">+				ret = -EOPNOTSUPP;</span>
<span class="p_add">+				goto err2;</span>
<span class="p_add">+			}</span>
 
 			ndev = id_priv-&gt;id.device-&gt;get_netdev(id_priv-&gt;id.device,
 							      id_priv-&gt;id.port_num);
<span class="p_del">-			if (!ndev)</span>
<span class="p_del">-				return -ENODEV;</span>
<span class="p_add">+			if (!ndev) {</span>
<span class="p_add">+				ret = -ENODEV;</span>
<span class="p_add">+				goto err2;</span>
<span class="p_add">+			}</span>
 		}
 
 		route-&gt;path_rec-&gt;net = &amp;init_net;
<span class="p_header">diff --git a/drivers/infiniband/core/multicast.c b/drivers/infiniband/core/multicast.c</span>
<span class="p_header">index a83ec28a147b..365cb53cc8b2 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/multicast.c</span>
<span class="p_chunk">@@ -118,7 +118,6 @@</span> <span class="p_context"> struct mcast_group {</span>
 	atomic_t		refcount;
 	enum mcast_group_state	state;
 	struct ib_sa_query	*query;
<span class="p_del">-	int			query_id;</span>
 	u16			pkey_index;
 	u8			leave_state;
 	int			retries;
<span class="p_chunk">@@ -352,11 +351,7 @@</span> <span class="p_context"> static int send_join(struct mcast_group *group, struct mcast_member *member)</span>
 				       member-&gt;multicast.comp_mask,
 				       3000, GFP_KERNEL, join_handler, group,
 				       &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static int send_leave(struct mcast_group *group, u8 leave_state)
<span class="p_chunk">@@ -376,11 +371,7 @@</span> <span class="p_context"> static int send_leave(struct mcast_group *group, u8 leave_state)</span>
 				       IB_SA_MCMEMBER_REC_JOIN_STATE,
 				       3000, GFP_KERNEL, leave_handler,
 				       group, &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static void join_group(struct mcast_group *group, struct mcast_member *member,
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw.h b/drivers/infiniband/hw/i40iw/i40iw.h</span>
<span class="p_header">index b738acdb9b02..8ec09e470f84 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw.h</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> struct i40iw_device {</span>
 	struct i40e_client *client;
 	struct i40iw_hw hw;
 	struct i40iw_cm_core cm_core;
<span class="p_del">-	unsigned long *mem_resources;</span>
<span class="p_add">+	u8 *mem_resources;</span>
 	unsigned long *allocated_qps;
 	unsigned long *allocated_cqs;
 	unsigned long *allocated_mrs;
<span class="p_chunk">@@ -435,8 +435,8 @@</span> <span class="p_context"> static inline int i40iw_alloc_resource(struct i40iw_device *iwdev,</span>
 	*next = resource_num + 1;
 	if (*next == max_resources)
 		*next = 0;
<span class="p_del">-	spin_unlock_irqrestore(&amp;iwdev-&gt;resource_lock, flags);</span>
 	*req_resource_num = resource_num;
<span class="p_add">+	spin_unlock_irqrestore(&amp;iwdev-&gt;resource_lock, flags);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_cm.c b/drivers/infiniband/hw/i40iw/i40iw_cm.c</span>
<span class="p_header">index d2fa72516960..406a345227c3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_cm.c</span>
<span class="p_chunk">@@ -535,8 +535,8 @@</span> <span class="p_context"> static struct i40iw_puda_buf *i40iw_form_cm_frame(struct i40iw_cm_node *cm_node,</span>
 		buf += hdr_len;
 	}
 
<span class="p_del">-	if (pd_len)</span>
<span class="p_del">-		memcpy(buf, pdata-&gt;addr, pd_len);</span>
<span class="p_add">+	if (pdata &amp;&amp; pdata-&gt;addr)</span>
<span class="p_add">+		memcpy(buf, pdata-&gt;addr, pdata-&gt;size);</span>
 
 	atomic_set(&amp;sqbuf-&gt;refcount, 1);
 
<span class="p_chunk">@@ -3347,26 +3347,6 @@</span> <span class="p_context"> int i40iw_cm_disconn(struct i40iw_qp *iwqp)</span>
 }
 
 /**
<span class="p_del">- * i40iw_loopback_nop - Send a nop</span>
<span class="p_del">- * @qp: associated hw qp</span>
<span class="p_del">- */</span>
<span class="p_del">-static void i40iw_loopback_nop(struct i40iw_sc_qp *qp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u64 *wqe;</span>
<span class="p_del">-	u64 header;</span>
<span class="p_del">-</span>
<span class="p_del">-	wqe = qp-&gt;qp_uk.sq_base-&gt;elem;</span>
<span class="p_del">-	set_64bit_val(wqe, 0, 0);</span>
<span class="p_del">-	set_64bit_val(wqe, 8, 0);</span>
<span class="p_del">-	set_64bit_val(wqe, 16, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	header = LS_64(I40IWQP_OP_NOP, I40IWQPSQ_OPCODE) |</span>
<span class="p_del">-	    LS_64(0, I40IWQPSQ_SIGCOMPL) |</span>
<span class="p_del">-	    LS_64(qp-&gt;qp_uk.swqe_polarity, I40IWQPSQ_VALID);</span>
<span class="p_del">-	set_64bit_val(wqe, 24, header);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * i40iw_qp_disconnect - free qp and close cm
  * @iwqp: associate qp for the connection
  */
<span class="p_chunk">@@ -3638,7 +3618,7 @@</span> <span class="p_context"> int i40iw_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)</span>
 	} else {
 		if (iwqp-&gt;page)
 			iwqp-&gt;sc_qp.qp_uk.sq_base = kmap(iwqp-&gt;page);
<span class="p_del">-		i40iw_loopback_nop(&amp;iwqp-&gt;sc_qp);</span>
<span class="p_add">+		dev-&gt;iw_priv_qp_ops-&gt;qp_send_lsmm(&amp;iwqp-&gt;sc_qp, NULL, 0, 0);</span>
 	}
 
 	if (iwqp-&gt;page)
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_hw.c b/drivers/infiniband/hw/i40iw/i40iw_hw.c</span>
<span class="p_header">index 3ee0cad96bc6..0c92a40b3e86 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_hw.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_hw.c</span>
<span class="p_chunk">@@ -265,6 +265,7 @@</span> <span class="p_context"> void i40iw_next_iw_state(struct i40iw_qp *iwqp,</span>
 		info.dont_send_fin = false;
 	if (iwqp-&gt;sc_qp.term_flags &amp;&amp; (state == I40IW_QP_STATE_ERROR))
 		info.reset_tcp_conn = true;
<span class="p_add">+	iwqp-&gt;hw_iwarp_state = state;</span>
 	i40iw_hw_modify_qp(iwqp-&gt;iwdev, iwqp, &amp;info, 0);
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_main.c b/drivers/infiniband/hw/i40iw/i40iw_main.c</span>
<span class="p_header">index 6e9081380a27..445e230d5ff8 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_main.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static struct notifier_block i40iw_net_notifier = {</span>
 	.notifier_call = i40iw_net_event
 };
 
<span class="p_del">-static int i40iw_notifiers_registered;</span>
<span class="p_add">+static atomic_t i40iw_notifiers_registered;</span>
 
 /**
  * i40iw_find_i40e_handler - find a handler given a client info
<span class="p_chunk">@@ -1342,12 +1342,11 @@</span> <span class="p_context"> exit:</span>
  */
 static void i40iw_register_notifiers(void)
 {
<span class="p_del">-	if (!i40iw_notifiers_registered) {</span>
<span class="p_add">+	if (atomic_inc_return(&amp;i40iw_notifiers_registered) == 1) {</span>
 		register_inetaddr_notifier(&amp;i40iw_inetaddr_notifier);
 		register_inet6addr_notifier(&amp;i40iw_inetaddr6_notifier);
 		register_netevent_notifier(&amp;i40iw_net_notifier);
 	}
<span class="p_del">-	i40iw_notifiers_registered++;</span>
 }
 
 /**
<span class="p_chunk">@@ -1429,8 +1428,7 @@</span> <span class="p_context"> static void i40iw_deinit_device(struct i40iw_device *iwdev, bool reset, bool del</span>
 			i40iw_del_macip_entry(iwdev, (u8)iwdev-&gt;mac_ip_table_idx);
 		/* fallthrough */
 	case INET_NOTIFIER:
<span class="p_del">-		if (i40iw_notifiers_registered &gt; 0) {</span>
<span class="p_del">-			i40iw_notifiers_registered--;</span>
<span class="p_add">+		if (!atomic_dec_return(&amp;i40iw_notifiers_registered)) {</span>
 			unregister_netevent_notifier(&amp;i40iw_net_notifier);
 			unregister_inetaddr_notifier(&amp;i40iw_inetaddr_notifier);
 			unregister_inet6addr_notifier(&amp;i40iw_inetaddr6_notifier);
<span class="p_chunk">@@ -1558,6 +1556,10 @@</span> <span class="p_context"> static int i40iw_open(struct i40e_info *ldev, struct i40e_client *client)</span>
 	enum i40iw_status_code status;
 	struct i40iw_handler *hdl;
 
<span class="p_add">+	hdl = i40iw_find_netdev(ldev-&gt;netdev);</span>
<span class="p_add">+	if (hdl)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdl = kzalloc(sizeof(*hdl), GFP_KERNEL);
 	if (!hdl)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_utils.c b/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_header">index 0e8db0a35141..6fd043b1d714 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_chunk">@@ -673,8 +673,11 @@</span> <span class="p_context"> enum i40iw_status_code i40iw_free_virt_mem(struct i40iw_hw *hw,</span>
 {
 	if (!mem)
 		return I40IW_ERR_PARAM;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * mem-&gt;va points to the parent of mem, so both mem and mem-&gt;va</span>
<span class="p_add">+	 * can not be touched once mem-&gt;va is freed</span>
<span class="p_add">+	 */</span>
 	kfree(mem-&gt;va);
<span class="p_del">-	mem-&gt;va = NULL;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_verbs.c b/drivers/infiniband/hw/i40iw/i40iw_verbs.c</span>
<span class="p_header">index 283b64c942ee..f24bfbdddfaa 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_verbs.c</span>
<span class="p_chunk">@@ -794,7 +794,6 @@</span> <span class="p_context"> static struct ib_qp *i40iw_create_qp(struct ib_pd *ibpd,</span>
 	return &amp;iwqp-&gt;ibqp;
 error:
 	i40iw_free_qp_resources(iwdev, iwqp, qp_num);
<span class="p_del">-	kfree(mem);</span>
 	return ERR_PTR(err_code);
 }
 
<span class="p_chunk">@@ -1925,8 +1924,7 @@</span> <span class="p_context"> static int i40iw_dereg_mr(struct ib_mr *ib_mr)</span>
 		}
 		if (iwpbl-&gt;pbl_allocated)
 			i40iw_free_pble(iwdev-&gt;pble_rsrc, palloc);
<span class="p_del">-		kfree(iwpbl-&gt;iwmr);</span>
<span class="p_del">-		iwpbl-&gt;iwmr = NULL;</span>
<span class="p_add">+		kfree(iwmr);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 9c2e53d28f98..0f21c3a25552 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -1128,6 +1128,27 @@</span> <span class="p_context"> void handle_port_mgmt_change_event(struct work_struct *work)</span>
 
 		/* Generate GUID changed event */
 		if (changed_attr &amp; MLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK) {
<span class="p_add">+			if (mlx4_is_master(dev-&gt;dev)) {</span>
<span class="p_add">+				union ib_gid gid;</span>
<span class="p_add">+				int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (!eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix)</span>
<span class="p_add">+					err = __mlx4_ib_query_gid(&amp;dev-&gt;ib_dev, port, 0, &amp;gid, 1);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					gid.global.subnet_prefix =</span>
<span class="p_add">+						eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix;</span>
<span class="p_add">+				if (err) {</span>
<span class="p_add">+					pr_warn(&quot;Could not change QP1 subnet prefix for port %d: query_gid error (%d)\n&quot;,</span>
<span class="p_add">+						port, err);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					pr_debug(&quot;Changing QP1 subnet prefix for port %d. old=0x%llx. new=0x%llx\n&quot;,</span>
<span class="p_add">+						 port,</span>
<span class="p_add">+						 (u64)atomic64_read(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix),</span>
<span class="p_add">+						 be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+					atomic64_set(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix,</span>
<span class="p_add">+						     be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
 			mlx4_ib_dispatch_event(dev, port, IB_EVENT_GID_CHANGE);
 			/*if master, notify all slaves*/
 			if (mlx4_is_master(dev-&gt;dev))
<span class="p_chunk">@@ -2202,6 +2223,8 @@</span> <span class="p_context"> int mlx4_ib_init_sriov(struct mlx4_ib_dev *dev)</span>
 		if (err)
 			goto demux_err;
 		dev-&gt;sriov.demux[i].guid_cache[0] = gid.global.interface_id;
<span class="p_add">+		atomic64_set(&amp;dev-&gt;sriov.demux[i].subnet_prefix,</span>
<span class="p_add">+			     be64_to_cpu(gid.global.subnet_prefix));</span>
 		err = alloc_pv_object(dev, mlx4_master_func_num(dev-&gt;dev), i + 1,
 				      &amp;dev-&gt;sriov.sqps[i]);
 		if (err)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">index 8f7ad07915b0..097bfcc4ee99 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> static u8 get_leave_state(struct mcast_group *group)</span>
 		if (!group-&gt;members[i])
 			leave_state |= (1 &lt;&lt; i);
 
<span class="p_del">-	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 7);</span>
<span class="p_add">+	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 0xf);</span>
 }
 
 static int join_group(struct mcast_group *group, int slave, u8 join_mask)
<span class="p_chunk">@@ -564,8 +564,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_timeout_handler(struct work_struct *work)</span>
 		} else
 			mcg_warn_group(group, &quot;DRIVER BUG\n&quot;);
 	} else if (group-&gt;state == MCAST_LEAVE_SENT) {
<span class="p_del">-		if (group-&gt;rec.scope_join_state &amp; 7)</span>
<span class="p_del">-			group-&gt;rec.scope_join_state &amp;= 0xf8;</span>
<span class="p_add">+		if (group-&gt;rec.scope_join_state &amp; 0xf)</span>
<span class="p_add">+			group-&gt;rec.scope_join_state &amp;= 0xf0;</span>
 		group-&gt;state = MCAST_IDLE;
 		mutex_unlock(&amp;group-&gt;lock);
 		if (release_group(group, 1))
<span class="p_chunk">@@ -605,7 +605,7 @@</span> <span class="p_context"> static int handle_leave_req(struct mcast_group *group, u8 leave_mask,</span>
 static int handle_join_req(struct mcast_group *group, u8 join_mask,
 			   struct mcast_req *req)
 {
<span class="p_del">-	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 	int ref = 0;
 	u16 status;
 	struct ib_sa_mcmember_data *sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_chunk">@@ -690,8 +690,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_work_handler(struct work_struct *work)</span>
 			u8 cur_join_state;
 
 			resp_join_state = ((struct ib_sa_mcmember_data *)
<span class="p_del">-						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 7;</span>
<span class="p_del">-			cur_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 0xf;</span>
<span class="p_add">+			cur_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 
 			if (method == IB_MGMT_METHOD_GET_RESP) {
 				/* successfull join */
<span class="p_chunk">@@ -710,7 +710,7 @@</span> <span class="p_context"> process_requests:</span>
 		req = list_first_entry(&amp;group-&gt;pending_list, struct mcast_req,
 				       group_list);
 		sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_del">-		req_join_state = sa_data-&gt;scope_join_state &amp; 0x7;</span>
<span class="p_add">+		req_join_state = sa_data-&gt;scope_join_state &amp; 0xf;</span>
 
 		/* For a leave request, we will immediately answer the VF, and
 		 * update our internal counters. The actual leave will be sent
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">index 29acda249612..d4ca38103cec 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> struct mlx4_ib_demux_ctx {</span>
 	struct workqueue_struct *wq;
 	struct workqueue_struct *ud_wq;
 	spinlock_t ud_lock;
<span class="p_del">-	__be64 subnet_prefix;</span>
<span class="p_add">+	atomic64_t subnet_prefix;</span>
 	__be64 guid_cache[128];
 	struct mlx4_ib_dev *dev;
 	/* the following lock protects both mcg_table and mcg_mgid0_list */
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 8db8405c1e99..d995222e661f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2492,24 +2492,27 @@</span> <span class="p_context"> static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_ud_wr *wr,</span>
 		sqp-&gt;ud_header.grh.flow_label    =
 			ah-&gt;av.ib.sl_tclass_flowlabel &amp; cpu_to_be32(0xfffff);
 		sqp-&gt;ud_header.grh.hop_limit     = ah-&gt;av.ib.hop_limit;
<span class="p_del">-		if (is_eth)</span>
<span class="p_add">+		if (is_eth) {</span>
 			memcpy(sqp-&gt;ud_header.grh.source_gid.raw, sgid.raw, 16);
<span class="p_del">-		else {</span>
<span class="p_del">-		if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_del">-			/* When multi-function is enabled, the ib_core gid</span>
<span class="p_del">-			 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_del">-			 * we must use our own cache */</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-						       subnet_prefix;</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-					       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			ib_get_cached_gid(ib_dev,</span>
<span class="p_del">-					  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_del">-					  ah-&gt;av.ib.gid_index,</span>
<span class="p_del">-					  &amp;sqp-&gt;ud_header.grh.source_gid, NULL);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_add">+				/* When multi-function is enabled, the ib_core gid</span>
<span class="p_add">+				 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_add">+				 * we must use our own cache</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_add">+					cpu_to_be64(atomic64_read(&amp;(to_mdev(ib_dev)-&gt;sriov.</span>
<span class="p_add">+								    demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+								    subnet_prefix)));</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_add">+					to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+						       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ib_get_cached_gid(ib_dev,</span>
<span class="p_add">+						  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_add">+						  ah-&gt;av.ib.gid_index,</span>
<span class="p_add">+						  &amp;sqp-&gt;ud_header.grh.source_gid, NULL);</span>
<span class="p_add">+			}</span>
 		}
 		memcpy(sqp-&gt;ud_header.grh.destination_gid.raw,
 		       ah-&gt;av.ib.dgid, 16);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index b48ad85315dc..c90f57579a92 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -287,7 +287,9 @@</span> <span class="p_context"> __be16 mlx5_get_roce_udp_sport(struct mlx5_ib_dev *dev, u8 port_num,</span>
 
 static int mlx5_use_mad_ifc(struct mlx5_ib_dev *dev)
 {
<span class="p_del">-	return !MLX5_CAP_GEN(dev-&gt;mdev, ib_virt);</span>
<span class="p_add">+	if (MLX5_CAP_GEN(dev-&gt;mdev, port_type) == MLX5_CAP_PORT_TYPE_IB)</span>
<span class="p_add">+		return !MLX5_CAP_GEN(dev-&gt;mdev, ib_virt);</span>
<span class="p_add">+	return 0;</span>
 }
 
 enum {
<span class="p_chunk">@@ -1275,6 +1277,13 @@</span> <span class="p_context"> static int parse_flow_attr(u32 *match_c, u32 *match_v,</span>
 					     dmac_47_16),
 				ib_spec-&gt;eth.val.dst_mac);
 
<span class="p_add">+		ether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_c,</span>
<span class="p_add">+					     smac_47_16),</span>
<span class="p_add">+				ib_spec-&gt;eth.mask.src_mac);</span>
<span class="p_add">+		ether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, outer_headers_v,</span>
<span class="p_add">+					     smac_47_16),</span>
<span class="p_add">+				ib_spec-&gt;eth.val.src_mac);</span>
<span class="p_add">+</span>
 		if (ib_spec-&gt;eth.mask.vlan_tag) {
 			MLX5_SET(fte_match_set_lyr_2_4, outer_headers_c,
 				 vlan_tag, 1);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">index 4f7d9b48df64..9dbfcc0ab577 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_chunk">@@ -478,6 +478,7 @@</span> <span class="p_context"> void ipoib_send(struct net_device *dev, struct sk_buff *skb,</span>
 		struct ipoib_ah *address, u32 qpn);
 void ipoib_reap_ah(struct work_struct *work);
 
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid);</span>
 void ipoib_mark_paths_invalid(struct net_device *dev);
 void ipoib_flush_paths(struct net_device *dev);
 int ipoib_check_sm_sendonly_fullmember_support(struct ipoib_dev_priv *priv);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 951d9abcca8b..4ad297d3de89 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1318,6 +1318,8 @@</span> <span class="p_context"> void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx)</span>
 	}
 }
 
<span class="p_add">+#define QPN_AND_OPTIONS_OFFSET	4</span>
<span class="p_add">+</span>
 static void ipoib_cm_tx_start(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
<span class="p_chunk">@@ -1326,6 +1328,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 	struct ipoib_neigh *neigh;
 	struct ipoib_cm_tx *p;
 	unsigned long flags;
<span class="p_add">+	struct ipoib_path *path;</span>
 	int ret;
 
 	struct ib_sa_path_rec pathrec;
<span class="p_chunk">@@ -1338,7 +1341,19 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		p = list_entry(priv-&gt;cm.start_list.next, typeof(*p), list);
 		list_del_init(&amp;p-&gt;list);
 		neigh = p-&gt;neigh;
<span class="p_add">+</span>
 		qpn = IPOIB_QPN(neigh-&gt;daddr);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * As long as the search is with these 2 locks,</span>
<span class="p_add">+		 * path existence indicates its validity.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		path = __path_find(dev, neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+		if (!path) {</span>
<span class="p_add">+			pr_info(&quot;%s ignore not valid path %pI6\n&quot;,</span>
<span class="p_add">+				__func__,</span>
<span class="p_add">+				neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+			goto free_neigh;</span>
<span class="p_add">+		}</span>
 		memcpy(&amp;pathrec, &amp;p-&gt;path-&gt;pathrec, sizeof pathrec);
 
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1350,6 +1365,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
 		if (ret) {
<span class="p_add">+free_neigh:</span>
 			neigh = p-&gt;neigh;
 			if (neigh) {
 				neigh-&gt;cm = NULL;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index dc6d241b9406..be11d5d5b8c1 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -1161,8 +1161,17 @@</span> <span class="p_context"> static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv,</span>
 	}
 
 	if (level == IPOIB_FLUSH_LIGHT) {
<span class="p_add">+		int oper_up;</span>
 		ipoib_mark_paths_invalid(dev);
<span class="p_add">+		/* Set IPoIB operation as down to prevent races between:</span>
<span class="p_add">+		 * the flush flow which leaves MCG and on the fly joins</span>
<span class="p_add">+		 * which can happen during that time. mcast restart task</span>
<span class="p_add">+		 * should deal with join requests we missed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		oper_up = test_and_clear_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_mcast_dev_flush(dev);
<span class="p_add">+		if (oper_up)</span>
<span class="p_add">+			set_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_flush_ah(dev);
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 5f58c41ef787..ddebda53e147 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> int ipoib_set_mode(struct net_device *dev, const char *buf)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node *n = priv-&gt;path_tree.rb_node;
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index 2c5ba0e704bf..53891c34fe19 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -558,7 +558,7 @@</span> <span class="p_context"> static struct notifier_block gic_cpu_notifier = {</span>
 static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 				   unsigned long cluster_id)
 {
<span class="p_del">-	int cpu = *base_cpu;</span>
<span class="p_add">+	int next_cpu, cpu = *base_cpu;</span>
 	unsigned long mpidr = cpu_logical_map(cpu);
 	u16 tlist = 0;
 
<span class="p_chunk">@@ -572,9 +572,10 @@</span> <span class="p_context"> static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,</span>
 
 		tlist |= 1 &lt;&lt; (mpidr &amp; 0xf);
 
<span class="p_del">-		cpu = cpumask_next(cpu, mask);</span>
<span class="p_del">-		if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_add">+		next_cpu = cpumask_next(cpu, mask);</span>
<span class="p_add">+		if (next_cpu &gt;= nr_cpu_ids)</span>
 			goto out;
<span class="p_add">+		cpu = next_cpu;</span>
 
 		mpidr = cpu_logical_map(cpu);
 
<span class="p_header">diff --git a/drivers/mailbox/mailbox-test.c b/drivers/mailbox/mailbox-test.c</span>
<span class="p_header">index 58d04726cdd7..9ca96e9db6bf 100644</span>
<span class="p_header">--- a/drivers/mailbox/mailbox-test.c</span>
<span class="p_header">+++ b/drivers/mailbox/mailbox-test.c</span>
<span class="p_chunk">@@ -133,6 +133,7 @@</span> <span class="p_context"> static ssize_t mbox_test_message_write(struct file *filp,</span>
 out:
 	kfree(tdev-&gt;signal);
 	kfree(tdev-&gt;message);
<span class="p_add">+	tdev-&gt;signal = NULL;</span>
 
 	return ret &lt; 0 ? ret : count;
 }
<span class="p_header">diff --git a/drivers/md/dm-log-writes.c b/drivers/md/dm-log-writes.c</span>
<span class="p_header">index d8f8cc85f96c..dd230752b08a 100644</span>
<span class="p_header">--- a/drivers/md/dm-log-writes.c</span>
<span class="p_header">+++ b/drivers/md/dm-log-writes.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static int log_one_block(struct log_writes_c *lc,</span>
 	sector++;
 
 	atomic_inc(&amp;lc-&gt;io_blocks);
<span class="p_del">-	bio = bio_alloc(GFP_KERNEL, block-&gt;vec_cnt);</span>
<span class="p_add">+	bio = bio_alloc(GFP_KERNEL, min(block-&gt;vec_cnt, BIO_MAX_PAGES));</span>
 	if (!bio) {
 		DMERR(&quot;Couldn&#39;t alloc log bio&quot;);
 		goto error;
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static int log_one_block(struct log_writes_c *lc,</span>
 		if (ret != block-&gt;vecs[i].bv_len) {
 			atomic_inc(&amp;lc-&gt;io_blocks);
 			submit_bio(WRITE, bio);
<span class="p_del">-			bio = bio_alloc(GFP_KERNEL, block-&gt;vec_cnt - i);</span>
<span class="p_add">+			bio = bio_alloc(GFP_KERNEL, min(block-&gt;vec_cnt - i, BIO_MAX_PAGES));</span>
 			if (!bio) {
 				DMERR(&quot;Couldn&#39;t alloc log bio&quot;);
 				goto error;
<span class="p_header">diff --git a/drivers/media/platform/vsp1/vsp1_pipe.c b/drivers/media/platform/vsp1/vsp1_pipe.c</span>
<span class="p_header">index 4f3b4a1d028a..3c8f40bd8b9d 100644</span>
<span class="p_header">--- a/drivers/media/platform/vsp1/vsp1_pipe.c</span>
<span class="p_header">+++ b/drivers/media/platform/vsp1/vsp1_pipe.c</span>
<span class="p_chunk">@@ -172,13 +172,17 @@</span> <span class="p_context"> void vsp1_pipeline_reset(struct vsp1_pipeline *pipe)</span>
 			bru-&gt;inputs[i].rpf = NULL;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; pipe-&gt;num_inputs; ++i) {</span>
<span class="p_del">-		pipe-&gt;inputs[i]-&gt;pipe = NULL;</span>
<span class="p_del">-		pipe-&gt;inputs[i] = NULL;</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(pipe-&gt;inputs); ++i) {</span>
<span class="p_add">+		if (pipe-&gt;inputs[i]) {</span>
<span class="p_add">+			pipe-&gt;inputs[i]-&gt;pipe = NULL;</span>
<span class="p_add">+			pipe-&gt;inputs[i] = NULL;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	pipe-&gt;output-&gt;pipe = NULL;</span>
<span class="p_del">-	pipe-&gt;output = NULL;</span>
<span class="p_add">+	if (pipe-&gt;output) {</span>
<span class="p_add">+		pipe-&gt;output-&gt;pipe = NULL;</span>
<span class="p_add">+		pipe-&gt;output = NULL;</span>
<span class="p_add">+	}</span>
 
 	INIT_LIST_HEAD(&amp;pipe-&gt;entities);
 	pipe-&gt;state = VSP1_PIPELINE_STOPPED;
<span class="p_header">diff --git a/drivers/media/usb/em28xx/em28xx-i2c.c b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">index a19b5c8b56ff..1a9e1e556706 100644</span>
<span class="p_header">--- a/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">+++ b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_chunk">@@ -507,9 +507,8 @@</span> <span class="p_context"> static int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,</span>
 	if (dev-&gt;disconnected)
 		return -ENODEV;
 
<span class="p_del">-	rc = rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		return rc;</span>
<span class="p_add">+	if (!rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock))</span>
<span class="p_add">+		return -EAGAIN;</span>
 
 	/* Switch I2C bus if needed */
 	if (bus != dev-&gt;cur_i2c_bus &amp;&amp;
<span class="p_header">diff --git a/drivers/media/usb/gspca/cpia1.c b/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_header">index f23df4a9d8c5..52b88e9e656b 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_chunk">@@ -1624,7 +1624,7 @@</span> <span class="p_context"> static int sd_start(struct gspca_dev *gspca_dev)</span>
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 
 	command_pause(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/konica.c b/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">index 39c96bb4c985..0712b1bc90b4 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/konica.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static int sd_start(struct gspca_dev *gspca_dev)</span>
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 
 	konica_stream_off(gspca_dev);
 #if IS_ENABLED(CONFIG_INPUT)
<span class="p_header">diff --git a/drivers/media/usb/gspca/t613.c b/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">index e2cc4e5a0ccb..bb52fc1fe598 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/t613.c</span>
<span class="p_chunk">@@ -837,7 +837,7 @@</span> <span class="p_context"> static void sd_pkt_scan(struct gspca_dev *gspca_dev,</span>
 			u8 *data,			/* isoc packet */
 			int len)			/* iso packet length */
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 	int pkt_type;
 
 	if (data[0] == 0x5a) {
<span class="p_header">diff --git a/drivers/misc/cxl/guest.c b/drivers/misc/cxl/guest.c</span>
<span class="p_header">index bc8d0b9870eb..df651935ed6f 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/guest.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/guest.c</span>
<span class="p_chunk">@@ -1052,16 +1052,18 @@</span> <span class="p_context"> static void free_adapter(struct cxl *adapter)</span>
 	struct irq_avail *cur;
 	int i;
 
<span class="p_del">-	if (adapter-&gt;guest-&gt;irq_avail) {</span>
<span class="p_del">-		for (i = 0; i &lt; adapter-&gt;guest-&gt;irq_nranges; i++) {</span>
<span class="p_del">-			cur = &amp;adapter-&gt;guest-&gt;irq_avail[i];</span>
<span class="p_del">-			kfree(cur-&gt;bitmap);</span>
<span class="p_add">+	if (adapter-&gt;guest) {</span>
<span class="p_add">+		if (adapter-&gt;guest-&gt;irq_avail) {</span>
<span class="p_add">+			for (i = 0; i &lt; adapter-&gt;guest-&gt;irq_nranges; i++) {</span>
<span class="p_add">+				cur = &amp;adapter-&gt;guest-&gt;irq_avail[i];</span>
<span class="p_add">+				kfree(cur-&gt;bitmap);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			kfree(adapter-&gt;guest-&gt;irq_avail);</span>
 		}
<span class="p_del">-		kfree(adapter-&gt;guest-&gt;irq_avail);</span>
<span class="p_add">+		kfree(adapter-&gt;guest-&gt;status);</span>
<span class="p_add">+		kfree(adapter-&gt;guest);</span>
 	}
<span class="p_del">-	kfree(adapter-&gt;guest-&gt;status);</span>
 	cxl_remove_adapter_nr(adapter);
<span class="p_del">-	kfree(adapter-&gt;guest);</span>
 	kfree(adapter);
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-tegra.c b/drivers/mmc/host/sdhci-tegra.c</span>
<span class="p_header">index bcc0de47fe7e..bd1199825f9f 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-tegra.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-tegra.c</span>
<span class="p_chunk">@@ -148,28 +148,37 @@</span> <span class="p_context"> static void tegra_sdhci_reset(struct sdhci_host *host, u8 mask)</span>
 		return;
 
 	misc_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_MISC_CTRL);
<span class="p_del">-	/* Erratum: Enable SDHCI spec v3.00 support */</span>
<span class="p_del">-	if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDHCI_SPEC_300)</span>
<span class="p_del">-		misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300;</span>
<span class="p_del">-	/* Advertise UHS modes as supported by host */</span>
<span class="p_del">-	if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDR50)</span>
<span class="p_del">-		misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR50;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		misc_ctrl &amp;= ~SDHCI_MISC_CTRL_ENABLE_SDR50;</span>
<span class="p_del">-	if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_DDR50)</span>
<span class="p_del">-		misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_DDR50;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		misc_ctrl &amp;= ~SDHCI_MISC_CTRL_ENABLE_DDR50;</span>
<span class="p_del">-	if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDR104)</span>
<span class="p_del">-		misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR104;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		misc_ctrl &amp;= ~SDHCI_MISC_CTRL_ENABLE_SDR104;</span>
<span class="p_del">-	sdhci_writel(host, misc_ctrl, SDHCI_TEGRA_VENDOR_MISC_CTRL);</span>
<span class="p_del">-</span>
 	clk_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);
<span class="p_add">+</span>
<span class="p_add">+	misc_ctrl &amp;= ~(SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300 |</span>
<span class="p_add">+		       SDHCI_MISC_CTRL_ENABLE_SDR50 |</span>
<span class="p_add">+		       SDHCI_MISC_CTRL_ENABLE_DDR50 |</span>
<span class="p_add">+		       SDHCI_MISC_CTRL_ENABLE_SDR104);</span>
<span class="p_add">+</span>
 	clk_ctrl &amp;= ~SDHCI_CLOCK_CTRL_SPI_MODE_CLKEN_OVERRIDE;
<span class="p_del">-	if (soc_data-&gt;nvquirks &amp; SDHCI_MISC_CTRL_ENABLE_SDR50)</span>
<span class="p_del">-		clk_ctrl |= SDHCI_CLOCK_CTRL_SDR50_TUNING_OVERRIDE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the board does not define a regulator for the SDHCI</span>
<span class="p_add">+	 * IO voltage, then don&#39;t advertise support for UHS modes</span>
<span class="p_add">+	 * even if the device supports it because the IO voltage</span>
<span class="p_add">+	 * cannot be configured.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!IS_ERR(host-&gt;mmc-&gt;supply.vqmmc)) {</span>
<span class="p_add">+		/* Erratum: Enable SDHCI spec v3.00 support */</span>
<span class="p_add">+		if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDHCI_SPEC_300)</span>
<span class="p_add">+			misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300;</span>
<span class="p_add">+		/* Advertise UHS modes as supported by host */</span>
<span class="p_add">+		if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDR50)</span>
<span class="p_add">+			misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR50;</span>
<span class="p_add">+		if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_DDR50)</span>
<span class="p_add">+			misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_DDR50;</span>
<span class="p_add">+		if (soc_data-&gt;nvquirks &amp; NVQUIRK_ENABLE_SDR104)</span>
<span class="p_add">+			misc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR104;</span>
<span class="p_add">+		if (soc_data-&gt;nvquirks &amp; SDHCI_MISC_CTRL_ENABLE_SDR50)</span>
<span class="p_add">+			clk_ctrl |= SDHCI_CLOCK_CTRL_SDR50_TUNING_OVERRIDE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sdhci_writel(host, misc_ctrl, SDHCI_TEGRA_VENDOR_MISC_CTRL);</span>
 	sdhci_writel(host, clk_ctrl, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);
 
 	if (soc_data-&gt;nvquirks &amp; NVQUIRK_HAS_PADCALIB)
<span class="p_header">diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">index cc07ba0f044d..27fa8b87cd5f 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_chunk">@@ -240,6 +240,9 @@</span> <span class="p_context"> static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)</span>
 	unsigned long flags;
 	u32 val;
 
<span class="p_add">+	/* Reset ECC hardware */</span>
<span class="p_add">+	davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;davinci_nand_lock, flags);
 
 	/* Start 4-bit ECC calculation for read/write */
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index ad535a854e5c..eab132778e67 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/if_arp.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/can.h&gt;
 #include &lt;linux/can/dev.h&gt;
 #include &lt;linux/can/skb.h&gt;
<span class="p_chunk">@@ -471,9 +472,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(can_free_echo_skb);</span>
 /*
  * CAN device restart for bus-off recovery
  */
<span class="p_del">-static void can_restart(unsigned long data)</span>
<span class="p_add">+static void can_restart(struct net_device *dev)</span>
 {
<span class="p_del">-	struct net_device *dev = (struct net_device *)data;</span>
 	struct can_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -513,6 +513,14 @@</span> <span class="p_context"> restart:</span>
 		netdev_err(dev, &quot;Error %d during restart&quot;, err);
 }
 
<span class="p_add">+static void can_restart_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct delayed_work *dwork = to_delayed_work(work);</span>
<span class="p_add">+	struct can_priv *priv = container_of(dwork, struct can_priv, restart_work);</span>
<span class="p_add">+</span>
<span class="p_add">+	can_restart(priv-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int can_restart_now(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -526,8 +534,8 @@</span> <span class="p_context"> int can_restart_now(struct net_device *dev)</span>
 	if (priv-&gt;state != CAN_STATE_BUS_OFF)
 		return -EBUSY;
 
<span class="p_del">-	/* Runs as soon as possible in the timer context */</span>
<span class="p_del">-	mod_timer(&amp;priv-&gt;restart_timer, jiffies);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
<span class="p_add">+	can_restart(dev);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -548,8 +556,8 @@</span> <span class="p_context"> void can_bus_off(struct net_device *dev)</span>
 	netif_carrier_off(dev);
 
 	if (priv-&gt;restart_ms)
<span class="p_del">-		mod_timer(&amp;priv-&gt;restart_timer,</span>
<span class="p_del">-			  jiffies + (priv-&gt;restart_ms * HZ) / 1000);</span>
<span class="p_add">+		schedule_delayed_work(&amp;priv-&gt;restart_work,</span>
<span class="p_add">+				      msecs_to_jiffies(priv-&gt;restart_ms));</span>
 }
 EXPORT_SYMBOL_GPL(can_bus_off);
 
<span class="p_chunk">@@ -658,6 +666,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 		return NULL;
 
 	priv = netdev_priv(dev);
<span class="p_add">+	priv-&gt;dev = dev;</span>
 
 	if (echo_skb_max) {
 		priv-&gt;echo_skb_max = echo_skb_max;
<span class="p_chunk">@@ -667,7 +676,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 
 	priv-&gt;state = CAN_STATE_STOPPED;
 
<span class="p_del">-	init_timer(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;priv-&gt;restart_work, can_restart_work);</span>
 
 	return dev;
 }
<span class="p_chunk">@@ -748,8 +757,6 @@</span> <span class="p_context"> int open_candev(struct net_device *dev)</span>
 	if (!netif_carrier_ok(dev))
 		netif_carrier_on(dev);
 
<span class="p_del">-	setup_timer(&amp;priv-&gt;restart_timer, can_restart, (unsigned long)dev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(open_candev);
<span class="p_chunk">@@ -764,7 +771,7 @@</span> <span class="p_context"> void close_candev(struct net_device *dev)</span>
 {
 	struct can_priv *priv = netdev_priv(dev);
 
<span class="p_del">-	del_timer_sync(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
 	can_flush_echo_skb(dev);
 }
 EXPORT_SYMBOL_GPL(close_candev);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c</span>
<span class="p_header">index 9c0d87503977..9b5195435c87 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k_ethtool.c</span>
<span class="p_chunk">@@ -983,9 +983,10 @@</span> <span class="p_context"> void fm10k_write_reta(struct fm10k_intfc *interface, const u32 *indir)</span>
 		/* generate a new table if we weren&#39;t given one */
 		for (j = 0; j &lt; 4; j++) {
 			if (indir)
<span class="p_del">-				n = indir[i + j];</span>
<span class="p_add">+				n = indir[4 * i + j];</span>
 			else
<span class="p_del">-				n = ethtool_rxfh_indir_default(i + j, rss_i);</span>
<span class="p_add">+				n = ethtool_rxfh_indir_default(4 * i + j,</span>
<span class="p_add">+							       rss_i);</span>
 
 			table[j] = n;
 		}
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_header">index 422b41d61c9a..d5cb570d67b7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_chunk">@@ -297,13 +297,15 @@</span> <span class="p_context"> void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc,</span>
 		   void *buffer, u16 buf_len)
 {
 	struct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;
<span class="p_del">-	u16 len = le16_to_cpu(aq_desc-&gt;datalen);</span>
<span class="p_add">+	u16 len;</span>
 	u8 *buf = (u8 *)buffer;
 	u16 i = 0;
 
 	if ((!(mask &amp; hw-&gt;debug_mask)) || (desc == NULL))
 		return;
 
<span class="p_add">+	len = le16_to_cpu(aq_desc-&gt;datalen);</span>
<span class="p_add">+</span>
 	i40e_debug(hw, mask,
 		   &quot;AQ CMD: opcode 0x%04X, flags 0x%04X, datalen 0x%04X, retval 0x%04X\n&quot;,
 		   le16_to_cpu(aq_desc-&gt;opcode),
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_header">index 813cdd2621a1..d3f8b9f7756b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_chunk">@@ -1524,7 +1524,7 @@</span> <span class="p_context"> static void ath10k_htt_rx_h_filter(struct ath10k *ar,</span>
 static int ath10k_htt_rx_handle_amsdu(struct ath10k_htt *htt)
 {
 	struct ath10k *ar = htt-&gt;ar;
<span class="p_del">-	static struct ieee80211_rx_status rx_status;</span>
<span class="p_add">+	struct ieee80211_rx_status *rx_status = &amp;htt-&gt;rx_status;</span>
 	struct sk_buff_head amsdu;
 	int ret;
 
<span class="p_chunk">@@ -1548,11 +1548,11 @@</span> <span class="p_context"> static int ath10k_htt_rx_handle_amsdu(struct ath10k_htt *htt)</span>
 		return ret;
 	}
 
<span class="p_del">-	ath10k_htt_rx_h_ppdu(ar, &amp;amsdu, &amp;rx_status, 0xffff);</span>
<span class="p_add">+	ath10k_htt_rx_h_ppdu(ar, &amp;amsdu, rx_status, 0xffff);</span>
 	ath10k_htt_rx_h_unchain(ar, &amp;amsdu, ret &gt; 0);
<span class="p_del">-	ath10k_htt_rx_h_filter(ar, &amp;amsdu, &amp;rx_status);</span>
<span class="p_del">-	ath10k_htt_rx_h_mpdu(ar, &amp;amsdu, &amp;rx_status);</span>
<span class="p_del">-	ath10k_htt_rx_h_deliver(ar, &amp;amsdu, &amp;rx_status);</span>
<span class="p_add">+	ath10k_htt_rx_h_filter(ar, &amp;amsdu, rx_status);</span>
<span class="p_add">+	ath10k_htt_rx_h_mpdu(ar, &amp;amsdu, rx_status);</span>
<span class="p_add">+	ath10k_htt_rx_h_deliver(ar, &amp;amsdu, rx_status);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">index dec1a317a070..e2083f4d2d48 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_chunk">@@ -4176,7 +4176,7 @@</span> <span class="p_context"> static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,</span>
 	if (!AR_SREV_9330(ah) &amp;&amp; !AR_SREV_9340(ah) &amp;&amp; !AR_SREV_9531(ah))
 		ar9003_hw_internal_regulator_apply(ah);
 	ar9003_hw_apply_tuning_caps(ah);
<span class="p_del">-	ar9003_hw_apply_minccapwr_thresh(ah, chan);</span>
<span class="p_add">+	ar9003_hw_apply_minccapwr_thresh(ah, is2ghz);</span>
 	ar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);
 	ar9003_hw_thermometer_apply(ah);
 	ar9003_hw_thermo_cal_apply(ah);
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">index c7550dab6a23..570c80a5419d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_chunk">@@ -722,8 +722,10 @@</span> <span class="p_context"> int brcmf_sdiod_recv_chain(struct brcmf_sdio_dev *sdiodev,</span>
 			return -ENOMEM;
 		err = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr,
 					 glom_skb);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(glom_skb);</span>
 			goto done;
<span class="p_add">+		}</span>
 
 		skb_queue_walk(pktq, skb) {
 			memcpy(skb-&gt;data, glom_skb-&gt;data, skb-&gt;len);
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/dma.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">index 796f5f9d5d5a..b7df576bb84d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/dma.c</span>
<span class="p_chunk">@@ -1079,8 +1079,10 @@</span> <span class="p_context"> bool dma_rxfill(struct dma_pub *pub)</span>
 
 		pa = dma_map_single(di-&gt;dmadev, p-&gt;data, di-&gt;rxbufsize,
 				    DMA_FROM_DEVICE);
<span class="p_del">-		if (dma_mapping_error(di-&gt;dmadev, pa))</span>
<span class="p_add">+		if (dma_mapping_error(di-&gt;dmadev, pa)) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(p);</span>
 			return false;
<span class="p_add">+		}</span>
 
 		/* save the free packet pointer */
 		di-&gt;rxp[rxout] = p;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/stf.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">index dd9162722495..0ab865de1491 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/stf.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> void</span>
 brcms_c_stf_ss_algo_channel_get(struct brcms_c_info *wlc, u16 *ss_algo_channel,
 			    u16 chanspec)
 {
<span class="p_del">-	struct tx_power power;</span>
<span class="p_add">+	struct tx_power power = { };</span>
 	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/fw-dbg.c b/drivers/net/wireless/intel/iwlwifi/mvm/fw-dbg.c</span>
<span class="p_header">index e1b6b2c665eb..46b52bf705fb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/fw-dbg.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/fw-dbg.c</span>
<span class="p_chunk">@@ -288,7 +288,8 @@</span> <span class="p_context"> static void iwl_mvm_dump_fifos(struct iwl_mvm *mvm,</span>
 			fifo_hdr-&gt;fifo_num = cpu_to_le32(i);
 
 			/* Mark the number of TXF we&#39;re pulling now */
<span class="p_del">-			iwl_trans_write_prph(mvm-&gt;trans, TXF_CPU2_NUM, i);</span>
<span class="p_add">+			iwl_trans_write_prph(mvm-&gt;trans, TXF_CPU2_NUM, i +</span>
<span class="p_add">+				ARRAY_SIZE(mvm-&gt;shared_mem_cfg.txfifo_size));</span>
 
 			fifo_hdr-&gt;available_bytes =
 				cpu_to_le32(iwl_trans_read_prph(mvm-&gt;trans,
<span class="p_chunk">@@ -959,5 +960,6 @@</span> <span class="p_context"> int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm, u8 conf_id)</span>
 	}
 
 	mvm-&gt;fw_dbg_conf = conf_id;
<span class="p_del">-	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_header">index 7057f35cb2e7..fb71cf6910df 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -139,17 +139,21 @@</span> <span class="p_context"> void iwl_free_fw_paging(struct iwl_mvm *mvm)</span>
 		return;
 
 	for (i = 0; i &lt; NUM_OF_FW_PAGING_BLOCKS; i++) {
<span class="p_del">-		if (!mvm-&gt;fw_paging_db[i].fw_paging_block) {</span>
<span class="p_add">+		struct iwl_fw_paging *paging = &amp;mvm-&gt;fw_paging_db[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!paging-&gt;fw_paging_block) {</span>
 			IWL_DEBUG_FW(mvm,
 				     &quot;Paging: block %d already freed, continue to next page\n&quot;,
 				     i);
 
 			continue;
 		}
<span class="p_add">+		dma_unmap_page(mvm-&gt;trans-&gt;dev, paging-&gt;fw_paging_phys,</span>
<span class="p_add">+			       paging-&gt;fw_paging_size, DMA_BIDIRECTIONAL);</span>
 
<span class="p_del">-		__free_pages(mvm-&gt;fw_paging_db[i].fw_paging_block,</span>
<span class="p_del">-			     get_order(mvm-&gt;fw_paging_db[i].fw_paging_size));</span>
<span class="p_del">-		mvm-&gt;fw_paging_db[i].fw_paging_block = NULL;</span>
<span class="p_add">+		__free_pages(paging-&gt;fw_paging_block,</span>
<span class="p_add">+			     get_order(paging-&gt;fw_paging_size));</span>
<span class="p_add">+		paging-&gt;fw_paging_block = NULL;</span>
 	}
 	kfree(mvm-&gt;trans-&gt;paging_download_buf);
 	mvm-&gt;trans-&gt;paging_download_buf = NULL;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_header">index 25a98401a64f..0551a4bb163c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/nvm.c</span>
<span class="p_chunk">@@ -667,8 +667,7 @@</span> <span class="p_context"> iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,</span>
 		.mcc = cpu_to_le16(alpha2[0] &lt;&lt; 8 | alpha2[1]),
 		.source_id = (u8)src_id,
 	};
<span class="p_del">-	struct iwl_mcc_update_resp *mcc_resp, *resp_cp = NULL;</span>
<span class="p_del">-	struct iwl_mcc_update_resp_v1 *mcc_resp_v1 = NULL;</span>
<span class="p_add">+	struct iwl_mcc_update_resp *resp_cp;</span>
 	struct iwl_rx_packet *pkt;
 	struct iwl_host_cmd cmd = {
 		.id = MCC_UPDATE_CMD,
<span class="p_chunk">@@ -701,34 +700,36 @@</span> <span class="p_context"> iwl_mvm_update_mcc(struct iwl_mvm *mvm, const char *alpha2,</span>
 
 	/* Extract MCC response */
 	if (resp_v2) {
<span class="p_del">-		mcc_resp = (void *)pkt-&gt;data;</span>
<span class="p_add">+		struct iwl_mcc_update_resp *mcc_resp = (void *)pkt-&gt;data;</span>
<span class="p_add">+</span>
 		n_channels =  __le32_to_cpu(mcc_resp-&gt;n_channels);
<span class="p_add">+		resp_len = sizeof(struct iwl_mcc_update_resp) +</span>
<span class="p_add">+			   n_channels * sizeof(__le32);</span>
<span class="p_add">+		resp_cp = kmemdup(mcc_resp, resp_len, GFP_KERNEL);</span>
 	} else {
<span class="p_del">-		mcc_resp_v1 = (void *)pkt-&gt;data;</span>
<span class="p_add">+		struct iwl_mcc_update_resp_v1 *mcc_resp_v1 = (void *)pkt-&gt;data;</span>
<span class="p_add">+</span>
 		n_channels =  __le32_to_cpu(mcc_resp_v1-&gt;n_channels);
<span class="p_add">+		resp_len = sizeof(struct iwl_mcc_update_resp) +</span>
<span class="p_add">+			   n_channels * sizeof(__le32);</span>
<span class="p_add">+		resp_cp = kzalloc(resp_len, GFP_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (resp_cp) {</span>
<span class="p_add">+			resp_cp-&gt;status = mcc_resp_v1-&gt;status;</span>
<span class="p_add">+			resp_cp-&gt;mcc = mcc_resp_v1-&gt;mcc;</span>
<span class="p_add">+			resp_cp-&gt;cap = mcc_resp_v1-&gt;cap;</span>
<span class="p_add">+			resp_cp-&gt;source_id = mcc_resp_v1-&gt;source_id;</span>
<span class="p_add">+			resp_cp-&gt;n_channels = mcc_resp_v1-&gt;n_channels;</span>
<span class="p_add">+			memcpy(resp_cp-&gt;channels, mcc_resp_v1-&gt;channels,</span>
<span class="p_add">+			       n_channels * sizeof(__le32));</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	resp_len = sizeof(struct iwl_mcc_update_resp) + n_channels *</span>
<span class="p_del">-		sizeof(__le32);</span>
<span class="p_del">-</span>
<span class="p_del">-	resp_cp = kzalloc(resp_len, GFP_KERNEL);</span>
 	if (!resp_cp) {
 		ret = -ENOMEM;
 		goto exit;
 	}
 
<span class="p_del">-	if (resp_v2) {</span>
<span class="p_del">-		memcpy(resp_cp, mcc_resp, resp_len);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		resp_cp-&gt;status = mcc_resp_v1-&gt;status;</span>
<span class="p_del">-		resp_cp-&gt;mcc = mcc_resp_v1-&gt;mcc;</span>
<span class="p_del">-		resp_cp-&gt;cap = mcc_resp_v1-&gt;cap;</span>
<span class="p_del">-		resp_cp-&gt;source_id = mcc_resp_v1-&gt;source_id;</span>
<span class="p_del">-		resp_cp-&gt;n_channels = mcc_resp_v1-&gt;n_channels;</span>
<span class="p_del">-		memcpy(resp_cp-&gt;channels, mcc_resp_v1-&gt;channels,</span>
<span class="p_del">-		       n_channels * sizeof(__le32));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	status = le32_to_cpu(resp_cp-&gt;status);
 
 	mcc = le16_to_cpu(resp_cp-&gt;mcc);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/sf.c b/drivers/net/wireless/intel/iwlwifi/mvm/sf.c</span>
<span class="p_header">index 443a42855c9e..101fb04a8573 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/sf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sf.c</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> static int iwl_mvm_sf_config(struct iwl_mvm *mvm, u8 sta_id,</span>
 			     enum iwl_sf_state new_state)
 {
 	struct iwl_sf_cfg_cmd sf_cmd = {
<span class="p_del">-		.state = cpu_to_le32(SF_FULL_ON),</span>
<span class="p_add">+		.state = cpu_to_le32(new_state),</span>
 	};
 	struct ieee80211_sta *sta;
 	int ret = 0;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">index b23ab4a4504f..1822ad374be3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_chunk">@@ -1374,11 +1374,12 @@</span> <span class="p_context"> int iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,</span>
 		 */
 		WARN_ON(rcu_access_pointer(mvm-&gt;baid_map[baid]));
 		rcu_assign_pointer(mvm-&gt;baid_map[baid], baid_data);
<span class="p_del">-	} else if (mvm-&gt;rx_ba_sessions &gt; 0) {</span>
<span class="p_add">+	} else  {</span>
 		u8 baid = mvm_sta-&gt;tid_to_baid[tid];
 
<span class="p_del">-		/* check that restart flow didn&#39;t zero the counter */</span>
<span class="p_del">-		mvm-&gt;rx_ba_sessions--;</span>
<span class="p_add">+		if (mvm-&gt;rx_ba_sessions &gt; 0)</span>
<span class="p_add">+			/* check that restart flow didn&#39;t zero the counter */</span>
<span class="p_add">+			mvm-&gt;rx_ba_sessions--;</span>
 		if (!iwl_mvm_has_new_rx_api(mvm))
 			return 0;
 
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">index b92b75fea92f..6b8d9a5ab855 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -138,28 +138,19 @@</span> <span class="p_context"> static void iwl_mvm_tx_csum(struct iwl_mvm *mvm, struct sk_buff *skb,</span>
 
 		protocol = ipv6h-&gt;nexthdr;
 		while (protocol != NEXTHDR_NONE &amp;&amp; ipv6_ext_hdr(protocol)) {
<span class="p_add">+			struct ipv6_opt_hdr *hp;</span>
<span class="p_add">+</span>
 			/* only supported extension headers */
 			if (protocol != NEXTHDR_ROUTING &amp;&amp;
 			    protocol != NEXTHDR_HOP &amp;&amp;
<span class="p_del">-			    protocol != NEXTHDR_DEST &amp;&amp;</span>
<span class="p_del">-			    protocol != NEXTHDR_FRAGMENT) {</span>
<span class="p_add">+			    protocol != NEXTHDR_DEST) {</span>
 				skb_checksum_help(skb);
 				return;
 			}
 
<span class="p_del">-			if (protocol == NEXTHDR_FRAGMENT) {</span>
<span class="p_del">-				struct frag_hdr *hp =</span>
<span class="p_del">-					OPT_HDR(struct frag_hdr, skb, off);</span>
<span class="p_del">-</span>
<span class="p_del">-				protocol = hp-&gt;nexthdr;</span>
<span class="p_del">-				off += sizeof(struct frag_hdr);</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				struct ipv6_opt_hdr *hp =</span>
<span class="p_del">-					OPT_HDR(struct ipv6_opt_hdr, skb, off);</span>
<span class="p_del">-</span>
<span class="p_del">-				protocol = hp-&gt;nexthdr;</span>
<span class="p_del">-				off += ipv6_optlen(hp);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			hp = OPT_HDR(struct ipv6_opt_hdr, skb, off);</span>
<span class="p_add">+			protocol = hp-&gt;nexthdr;</span>
<span class="p_add">+			off += ipv6_optlen(hp);</span>
 		}
 		/* if we get here - protocol now should be TCP/UDP */
 #endif
<span class="p_chunk">@@ -1312,7 +1303,15 @@</span> <span class="p_context"> static void iwl_mvm_rx_tx_cmd_single(struct iwl_mvm *mvm,</span>
 			bool send_eosp_ndp = false;
 
 			spin_lock_bh(&amp;mvmsta-&gt;lock);
<span class="p_del">-			txq_agg = (mvmsta-&gt;tid_data[tid].state == IWL_AGG_ON);</span>
<span class="p_add">+			if (iwl_mvm_is_dqa_supported(mvm)) {</span>
<span class="p_add">+				enum iwl_mvm_agg_state state;</span>
<span class="p_add">+</span>
<span class="p_add">+				state = mvmsta-&gt;tid_data[tid].state;</span>
<span class="p_add">+				txq_agg = (state == IWL_AGG_ON ||</span>
<span class="p_add">+					state == IWL_EMPTYING_HW_QUEUE_DELBA);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				txq_agg = txq_id &gt;= mvm-&gt;first_agg_queue;</span>
<span class="p_add">+			}</span>
 
 			if (!is_ndp) {
 				tid_data-&gt;next_reclaimed = next_reclaimed;
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c</span>
<span class="p_header">index d6beac9af029..dec63a0aef6b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/pcie/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/pcie/tx.c</span>
<span class="p_chunk">@@ -1595,9 +1595,9 @@</span> <span class="p_context"> static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,</span>
 
 	/* start the TFD with the scratchbuf */
 	scratch_size = min_t(int, copy_size, IWL_HCMD_SCRATCHBUF_SIZE);
<span class="p_del">-	memcpy(&amp;txq-&gt;scratchbufs[q-&gt;write_ptr], &amp;out_cmd-&gt;hdr, scratch_size);</span>
<span class="p_add">+	memcpy(&amp;txq-&gt;scratchbufs[idx], &amp;out_cmd-&gt;hdr, scratch_size);</span>
 	iwl_pcie_txq_build_tfd(trans, txq,
<span class="p_del">-			       iwl_pcie_get_scratchbuf_dma(txq, q-&gt;write_ptr),</span>
<span class="p_add">+			       iwl_pcie_get_scratchbuf_dma(txq, idx),</span>
 			       scratch_size, true);
 
 	/* map first command fragment, if any remains */
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/uap_txrx.c b/drivers/net/wireless/marvell/mwifiex/uap_txrx.c</span>
<span class="p_header">index 666e91af59d7..bf5660eb27d3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/uap_txrx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/uap_txrx.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> int mwifiex_handle_uap_rx_forward(struct mwifiex_private *priv,</span>
 int mwifiex_uap_recv_packet(struct mwifiex_private *priv,
 			    struct sk_buff *skb)
 {
<span class="p_del">-	struct mwifiex_adapter *adapter = adapter;</span>
<span class="p_add">+	struct mwifiex_adapter *adapter = priv-&gt;adapter;</span>
 	struct mwifiex_sta_node *src_node;
 	struct ethhdr *p_ethhdr;
 	struct sk_buff *skb_uap;
<span class="p_header">diff --git a/drivers/nfc/fdp/fdp.c b/drivers/nfc/fdp/fdp.c</span>
<span class="p_header">index e44a7a2f4061..16427420b1a2 100644</span>
<span class="p_header">--- a/drivers/nfc/fdp/fdp.c</span>
<span class="p_header">+++ b/drivers/nfc/fdp/fdp.c</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static int fdp_nci_patch_otp(struct nci_dev *ndev)</span>
 {
 	struct fdp_nci_info *info = nci_get_drvdata(ndev);
 	struct device *dev = &amp;info-&gt;phy-&gt;i2c_dev-&gt;dev;
<span class="p_del">-	u8 conn_id;</span>
<span class="p_add">+	int conn_id;</span>
 	int r = 0;
 
 	if (info-&gt;otp_version &gt;= info-&gt;otp_patch_version)
<span class="p_chunk">@@ -424,7 +424,7 @@</span> <span class="p_context"> static int fdp_nci_patch_ram(struct nci_dev *ndev)</span>
 {
 	struct fdp_nci_info *info = nci_get_drvdata(ndev);
 	struct device *dev = &amp;info-&gt;phy-&gt;i2c_dev-&gt;dev;
<span class="p_del">-	u8 conn_id;</span>
<span class="p_add">+	int conn_id;</span>
 	int r = 0;
 
 	if (info-&gt;ram_version &gt;= info-&gt;ram_patch_version)
<span class="p_header">diff --git a/drivers/pcmcia/ds.c b/drivers/pcmcia/ds.c</span>
<span class="p_header">index 489ea1098c96..69b5e811ea2b 100644</span>
<span class="p_header">--- a/drivers/pcmcia/ds.c</span>
<span class="p_header">+++ b/drivers/pcmcia/ds.c</span>
<span class="p_chunk">@@ -977,7 +977,7 @@</span> <span class="p_context"> static int pcmcia_bus_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 
 /************************ runtime PM support ***************************/
 
<span class="p_del">-static int pcmcia_dev_suspend(struct device *dev, pm_message_t state);</span>
<span class="p_add">+static int pcmcia_dev_suspend(struct device *dev);</span>
 static int pcmcia_dev_resume(struct device *dev);
 
 static int runtime_suspend(struct device *dev)
<span class="p_chunk">@@ -985,7 +985,7 @@</span> <span class="p_context"> static int runtime_suspend(struct device *dev)</span>
 	int rc;
 
 	device_lock(dev);
<span class="p_del">-	rc = pcmcia_dev_suspend(dev, PMSG_SUSPEND);</span>
<span class="p_add">+	rc = pcmcia_dev_suspend(dev);</span>
 	device_unlock(dev);
 	return rc;
 }
<span class="p_chunk">@@ -1135,7 +1135,7 @@</span> <span class="p_context"> ATTRIBUTE_GROUPS(pcmcia_dev);</span>
 
 /* PM support, also needed for reset */
 
<span class="p_del">-static int pcmcia_dev_suspend(struct device *dev, pm_message_t state)</span>
<span class="p_add">+static int pcmcia_dev_suspend(struct device *dev)</span>
 {
 	struct pcmcia_device *p_dev = to_pcmcia_dev(dev);
 	struct pcmcia_driver *p_drv = NULL;
<span class="p_chunk">@@ -1410,6 +1410,9 @@</span> <span class="p_context"> static struct class_interface pcmcia_bus_interface __refdata = {</span>
 	.remove_dev = &amp;pcmcia_bus_remove_socket,
 };
 
<span class="p_add">+static const struct dev_pm_ops pcmcia_bus_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(pcmcia_dev_suspend, pcmcia_dev_resume)</span>
<span class="p_add">+};</span>
 
 struct bus_type pcmcia_bus_type = {
 	.name = &quot;pcmcia&quot;,
<span class="p_chunk">@@ -1418,8 +1421,7 @@</span> <span class="p_context"> struct bus_type pcmcia_bus_type = {</span>
 	.dev_groups = pcmcia_dev_groups,
 	.probe = pcmcia_device_probe,
 	.remove = pcmcia_device_remove,
<span class="p_del">-	.suspend = pcmcia_dev_suspend,</span>
<span class="p_del">-	.resume = pcmcia_dev_resume,</span>
<span class="p_add">+	.pm = &amp;pcmcia_bus_pm_ops,</span>
 };
 
 
<span class="p_header">diff --git a/drivers/perf/arm_pmu.c b/drivers/perf/arm_pmu.c</span>
<span class="p_header">index 140436a046c0..5824045fab46 100644</span>
<span class="p_header">--- a/drivers/perf/arm_pmu.c</span>
<span class="p_header">+++ b/drivers/perf/arm_pmu.c</span>
<span class="p_chunk">@@ -921,6 +921,7 @@</span> <span class="p_context"> static int of_pmu_irq_cfg(struct arm_pmu *pmu)</span>
 			if (i &gt; 0 &amp;&amp; spi != using_spi) {
 				pr_err(&quot;PPI/SPI IRQ type mismatch for %s!\n&quot;,
 					dn-&gt;name);
<span class="p_add">+				of_node_put(dn);</span>
 				kfree(irqs);
 				return -EINVAL;
 			}
<span class="p_header">diff --git a/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c b/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_header">index 967400971d45..5d08de0b13f5 100644</span>
<span class="p_header">--- a/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_chunk">@@ -73,6 +73,12 @@</span> <span class="p_context"> static void uniphier_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,</span>
 	case UNIPHIER_PIN_PULL_DOWN:
 		pull_dir = &quot;DOWN&quot;;
 		break;
<span class="p_add">+	case UNIPHIER_PIN_PULL_UP_FIXED:</span>
<span class="p_add">+		pull_dir = &quot;UP(FIXED)&quot;;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UNIPHIER_PIN_PULL_DOWN_FIXED:</span>
<span class="p_add">+		pull_dir = &quot;DOWN(FIXED)&quot;;</span>
<span class="p_add">+		break;</span>
 	case UNIPHIER_PIN_PULL_NONE:
 		pull_dir = &quot;NONE&quot;;
 		break;
<span class="p_header">diff --git a/drivers/regulator/pwm-regulator.c b/drivers/regulator/pwm-regulator.c</span>
<span class="p_header">index fafa3488e960..36e0c930ab49 100644</span>
<span class="p_header">--- a/drivers/regulator/pwm-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/pwm-regulator.c</span>
<span class="p_chunk">@@ -132,6 +132,7 @@</span> <span class="p_context"> static int pwm_regulator_set_voltage(struct regulator_dev *rdev,</span>
 	unsigned int duty_pulse;
 	u64 req_period;
 	u32 rem;
<span class="p_add">+	int old_uV = pwm_regulator_get_voltage(rdev);</span>
 	int ret;
 
 	pwm_get_args(drvdata-&gt;pwm, &amp;pargs);
<span class="p_chunk">@@ -166,8 +167,12 @@</span> <span class="p_context"> static int pwm_regulator_set_voltage(struct regulator_dev *rdev,</span>
 	}
 	drvdata-&gt;volt_uV = min_uV;
 
<span class="p_del">-	/* Delay required by PWM regulator to settle to the new voltage */</span>
<span class="p_del">-	usleep_range(ramp_delay, ramp_delay + 1000);</span>
<span class="p_add">+	if ((ramp_delay == 0) || !pwm_regulator_is_enabled(rdev))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ramp delay is in uV/uS. Adjust to uS and delay */</span>
<span class="p_add">+	ramp_delay = DIV_ROUND_UP(abs(min_uV - old_uV), ramp_delay);</span>
<span class="p_add">+	usleep_range(ramp_delay, ramp_delay + DIV_ROUND_UP(ramp_delay, 10));</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/regulator/qcom_smd-regulator.c b/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_header">index 6c7fe4778793..891ae44a49c2 100644</span>
<span class="p_header">--- a/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_chunk">@@ -178,20 +178,21 @@</span> <span class="p_context"> static const struct regulator_desc pma8084_hfsmps = {</span>
 static const struct regulator_desc pma8084_ftsmps = {
 	.linear_ranges = (struct regulator_linear_range[]) {
 		REGULATOR_LINEAR_RANGE(350000,  0, 184, 5000),
<span class="p_del">-		REGULATOR_LINEAR_RANGE(700000, 185, 339, 10000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1280000, 185, 261, 10000),</span>
 	},
 	.n_linear_ranges = 2,
<span class="p_del">-	.n_voltages = 340,</span>
<span class="p_add">+	.n_voltages = 262,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
 static const struct regulator_desc pma8084_pldo = {
 	.linear_ranges = (struct regulator_linear_range[]) {
<span class="p_del">-		REGULATOR_LINEAR_RANGE(750000,  0,  30, 25000),</span>
<span class="p_del">-		REGULATOR_LINEAR_RANGE(1500000, 31, 99, 50000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE( 750000,  0,  63, 12500),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1550000, 64, 126, 25000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(3100000, 127, 163, 50000),</span>
 	},
<span class="p_del">-	.n_linear_ranges = 2,</span>
<span class="p_del">-	.n_voltages = 100,</span>
<span class="p_add">+	.n_linear_ranges = 3,</span>
<span class="p_add">+	.n_voltages = 164,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
<span class="p_chunk">@@ -221,29 +222,30 @@</span> <span class="p_context"> static const struct regulator_desc pm8x41_hfsmps = {</span>
 static const struct regulator_desc pm8841_ftsmps = {
 	.linear_ranges = (struct regulator_linear_range[]) {
 		REGULATOR_LINEAR_RANGE(350000,  0, 184, 5000),
<span class="p_del">-		REGULATOR_LINEAR_RANGE(700000, 185, 339, 10000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1280000, 185, 261, 10000),</span>
 	},
 	.n_linear_ranges = 2,
<span class="p_del">-	.n_voltages = 340,</span>
<span class="p_add">+	.n_voltages = 262,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
 static const struct regulator_desc pm8941_boost = {
 	.linear_ranges = (struct regulator_linear_range[]) {
<span class="p_del">-		REGULATOR_LINEAR_RANGE(4000000, 0, 15, 100000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(4000000, 0, 30, 50000),</span>
 	},
 	.n_linear_ranges = 1,
<span class="p_del">-	.n_voltages = 16,</span>
<span class="p_add">+	.n_voltages = 31,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
 static const struct regulator_desc pm8941_pldo = {
 	.linear_ranges = (struct regulator_linear_range[]) {
<span class="p_del">-		REGULATOR_LINEAR_RANGE( 750000,  0,  30, 25000),</span>
<span class="p_del">-		REGULATOR_LINEAR_RANGE(1500000, 31, 99, 50000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE( 750000,  0,  63, 12500),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1550000, 64, 126, 25000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(3100000, 127, 163, 50000),</span>
 	},
<span class="p_del">-	.n_linear_ranges = 2,</span>
<span class="p_del">-	.n_voltages = 100,</span>
<span class="p_add">+	.n_linear_ranges = 3,</span>
<span class="p_add">+	.n_voltages = 164,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
<span class="p_header">diff --git a/drivers/regulator/qcom_spmi-regulator.c b/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_header">index 84cce21e98cd..16c5f84e06a7 100644</span>
<span class="p_header">--- a/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_chunk">@@ -1085,6 +1085,8 @@</span> <span class="p_context"> static struct regulator_ops spmi_vs_ops = {</span>
 	.set_pull_down		= spmi_regulator_common_set_pull_down,
 	.set_soft_start		= spmi_regulator_common_set_soft_start,
 	.set_over_current_protection = spmi_regulator_vs_ocp,
<span class="p_add">+	.set_mode		= spmi_regulator_common_set_mode,</span>
<span class="p_add">+	.get_mode		= spmi_regulator_common_get_mode,</span>
 };
 
 static struct regulator_ops spmi_boost_ops = {
<span class="p_chunk">@@ -1496,6 +1498,7 @@</span> <span class="p_context"> static const struct spmi_regulator_data pm8941_regulators[] = {</span>
 	{ &quot;s1&quot;, 0x1400, &quot;vdd_s1&quot;, },
 	{ &quot;s2&quot;, 0x1700, &quot;vdd_s2&quot;, },
 	{ &quot;s3&quot;, 0x1a00, &quot;vdd_s3&quot;, },
<span class="p_add">+	{ &quot;s4&quot;, 0xa000, },</span>
 	{ &quot;l1&quot;, 0x4000, &quot;vdd_l1_l3&quot;, },
 	{ &quot;l2&quot;, 0x4100, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;l3&quot;, 0x4200, &quot;vdd_l1_l3&quot;, },
<span class="p_chunk">@@ -1523,8 +1526,8 @@</span> <span class="p_context"> static const struct spmi_regulator_data pm8941_regulators[] = {</span>
 	{ &quot;lvs1&quot;, 0x8000, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;lvs2&quot;, 0x8100, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;lvs3&quot;, 0x8200, &quot;vdd_l2_lvs_1_2_3&quot;, },
<span class="p_del">-	{ &quot;mvs1&quot;, 0x8300, &quot;vin_5vs&quot;, },</span>
<span class="p_del">-	{ &quot;mvs2&quot;, 0x8400, &quot;vin_5vs&quot;, },</span>
<span class="p_add">+	{ &quot;5vs1&quot;, 0x8300, &quot;vin_5vs&quot;, &quot;ocp-5vs1&quot;, },</span>
<span class="p_add">+	{ &quot;5vs2&quot;, 0x8400, &quot;vin_5vs&quot;, &quot;ocp-5vs2&quot;, },</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_header">index 67669a9e73c1..f3a33312a9a6 100644</span>
<span class="p_header">--- a/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_header">+++ b/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_chunk">@@ -954,8 +954,8 @@</span> <span class="p_context"> int fnic_alloc_rq_frame(struct vnic_rq *rq)</span>
 	skb_put(skb, len);
 	pa = pci_map_single(fnic-&gt;pdev, skb-&gt;data, len, PCI_DMA_FROMDEVICE);
 
<span class="p_del">-	r = pci_dma_mapping_error(fnic-&gt;pdev, pa);</span>
<span class="p_del">-	if (r) {</span>
<span class="p_add">+	if (pci_dma_mapping_error(fnic-&gt;pdev, pa)) {</span>
<span class="p_add">+		r = -ENOMEM;</span>
 		printk(KERN_ERR &quot;PCI mapping failed with error %d\n&quot;, r);
 		goto free_skb;
 	}
<span class="p_chunk">@@ -1093,8 +1093,8 @@</span> <span class="p_context"> static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)</span>
 
 	pa = pci_map_single(fnic-&gt;pdev, eth_hdr, tot_len, PCI_DMA_TODEVICE);
 
<span class="p_del">-	ret = pci_dma_mapping_error(fnic-&gt;pdev, pa);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (pci_dma_mapping_error(fnic-&gt;pdev, pa)) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
 		printk(KERN_ERR &quot;DMA map failed with error %d\n&quot;, ret);
 		goto free_skb_on_err;
 	}
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_fw.h b/drivers/scsi/qla2xxx/qla_fw.h</span>
<span class="p_header">index 4c0f3a774799..8a2368b32dec 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_fw.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_fw.h</span>
<span class="p_chunk">@@ -1288,7 +1288,7 @@</span> <span class="p_context"> struct vp_rpt_id_entry_24xx {</span>
 
 	uint8_t vp_idx_map[16];
 
<span class="p_del">-	uint8_t reserved_4[28];</span>
<span class="p_add">+	uint8_t reserved_4[24];</span>
 	uint16_t bbcr;
 	uint8_t reserved_5[6];
 };
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index 53ef1cb6418e..1d82053a6a0c 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> static void ses_match_to_enclosure(struct enclosure_device *edev,</span>
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev-&gt;edev.parent), 0);
 
<span class="p_del">-	if (is_sas_attached(sdev))</span>
<span class="p_add">+	if (scsi_is_sas_rphy(&amp;sdev-&gt;sdev_gendev))</span>
 		efd.addr = sas_get_address(sdev);
 
 	if (efd.addr) {
<span class="p_header">diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">index a7934ab00b96..d22de4c8c399 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_chunk">@@ -263,6 +263,9 @@</span> <span class="p_context"> static void sh_msiof_spi_set_clk_regs(struct sh_msiof_spi_priv *p,</span>
 
 	for (k = 0; k &lt; ARRAY_SIZE(sh_msiof_spi_div_table); k++) {
 		brps = DIV_ROUND_UP(div, sh_msiof_spi_div_table[k].div);
<span class="p_add">+		/* SCR_BRDV_DIV_1 is valid only if BRPS is x 1/1 or x 1/2 */</span>
<span class="p_add">+		if (sh_msiof_spi_div_table[k].div == 1 &amp;&amp; brps &gt; 2)</span>
<span class="p_add">+			continue;</span>
 		if (brps &lt;= 32) /* max of brdv is 32 */
 			break;
 	}
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/adv_pci1760.c b/drivers/staging/comedi/drivers/adv_pci1760.c</span>
<span class="p_header">index d7dd1e55e347..9f525ff7290c 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/adv_pci1760.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/adv_pci1760.c</span>
<span class="p_chunk">@@ -196,6 +196,7 @@</span> <span class="p_context"> static int pci1760_pwm_ns_to_div(unsigned int flags, unsigned int ns)</span>
 		break;
 	case CMDF_ROUND_DOWN:
 		divisor = ns / PCI1760_PWM_TIMEBASE;
<span class="p_add">+		break;</span>
 	default:
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/staging/fbtft/fbtft-core.c b/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_header">index 0c1a77cafe14..4c281df16816 100644</span>
<span class="p_header">--- a/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_header">+++ b/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_chunk">@@ -391,11 +391,11 @@</span> <span class="p_context"> static void fbtft_update_display(struct fbtft_par *par, unsigned start_line,</span>
 
 	if (unlikely(timeit)) {
 		ts_end = ktime_get();
<span class="p_del">-		if (ktime_to_ns(par-&gt;update_time))</span>
<span class="p_add">+		if (!ktime_to_ns(par-&gt;update_time))</span>
 			par-&gt;update_time = ts_start;
 
<span class="p_del">-		par-&gt;update_time = ts_start;</span>
 		fps = ktime_us_delta(ts_start, par-&gt;update_time);
<span class="p_add">+		par-&gt;update_time = ts_start;</span>
 		fps = fps ? 1000000 / fps : 0;
 
 		throughput = ktime_us_delta(ts_end, ts_start);
<span class="p_header">diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c</span>
<span class="p_header">index 917a55c4480d..ffe9f8875311 100644</span>
<span class="p_header">--- a/drivers/usb/class/usbtmc.c</span>
<span class="p_header">+++ b/drivers/usb/class/usbtmc.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static void usbtmc_delete(struct kref *kref)</span>
 	struct usbtmc_device_data *data = to_usbtmc_data(kref);
 
 	usb_put_dev(data-&gt;usb_dev);
<span class="p_add">+	kfree(data);</span>
 }
 
 static int usbtmc_open(struct inode *inode, struct file *filp)
<span class="p_chunk">@@ -1379,7 +1380,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 
 	dev_dbg(&amp;intf-&gt;dev, &quot;%s called\n&quot;, __func__);
 
<span class="p_del">-	data = devm_kzalloc(&amp;intf-&gt;dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_qe_udc.c b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">index cf8819a5c5b2..8bb011ea78f7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -1878,11 +1878,8 @@</span> <span class="p_context"> static int qe_get_frame(struct usb_gadget *gadget)</span>
 
 	tmp = in_be16(&amp;udc-&gt;usb_param-&gt;frame_n);
 	if (tmp &amp; 0x8000)
<span class="p_del">-		tmp = tmp &amp; 0x07ff;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tmp = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (int)tmp;</span>
<span class="p_add">+		return tmp &amp; 0x07ff;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int fsl_qe_start(struct usb_gadget *gadget,
<span class="p_header">diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">index 7771be3ac178..4dd531ac5a7f 100644</span>
<span class="p_header">--- a/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">+++ b/drivers/usb/misc/legousbtower.c</span>
<span class="p_chunk">@@ -898,24 +898,6 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 	dev-&gt;interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev-&gt;interrupt_in_endpoint-&gt;bInterval;
 	dev-&gt;interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev-&gt;interrupt_out_endpoint-&gt;bInterval;
 
<span class="p_del">-	/* we can register the device now, as it is ready */</span>
<span class="p_del">-	usb_set_intfdata (interface, dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (retval) {</span>
<span class="p_del">-		/* something prevented us from registering this driver */</span>
<span class="p_del">-		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_del">-		usb_set_intfdata (interface, NULL);</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* let the user know what node this device is now attached to */</span>
<span class="p_del">-	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_del">-		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_del">-		 USB_MAJOR, dev-&gt;minor);</span>
<span class="p_del">-</span>
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
<span class="p_chunk">@@ -936,6 +918,23 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
<span class="p_add">+	/* we can register the device now, as it is ready */</span>
<span class="p_add">+	usb_set_intfdata (interface, dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (retval) {</span>
<span class="p_add">+		/* something prevented us from registering this driver */</span>
<span class="p_add">+		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_add">+		usb_set_intfdata (interface, NULL);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let the user know what node this device is now attached to */</span>
<span class="p_add">+	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_add">+		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_add">+		 USB_MAJOR, dev-&gt;minor);</span>
 
 exit:
 	return retval;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 96a70789b4c2..7e91ee27ac3a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -118,6 +118,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8411) }, /* Kyocera GPS Module */
 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8470) }, /* Juniper Networks BX Series System Console */</span>
 	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
 	{ USB_DEVICE(0x10C4, 0x84B6) }, /* Starizona Hyperion */
 	{ USB_DEVICE(0x10C4, 0x85EA) }, /* AC-Services IBUS-IF */
<span class="p_header">diff --git a/drivers/usb/usbip/vudc_rx.c b/drivers/usb/usbip/vudc_rx.c</span>
<span class="p_header">index 344bd9473475..e429b59f6f8a 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vudc_rx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vudc_rx.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> static int v_recv_cmd_submit(struct vudc *udc,</span>
 	urb_p-&gt;urb-&gt;status = -EINPROGRESS;
 
 	/* FIXME: more pipe setup to please usbip_common */
<span class="p_del">-	urb_p-&gt;urb-&gt;pipe &amp;= ~(11 &lt;&lt; 30);</span>
<span class="p_add">+	urb_p-&gt;urb-&gt;pipe &amp;= ~(3 &lt;&lt; 30);</span>
 	switch (urb_p-&gt;ep-&gt;type) {
 	case USB_ENDPOINT_XFER_BULK:
 		urb_p-&gt;urb-&gt;pipe |= (PIPE_BULK &lt;&lt; 30);
<span class="p_header">diff --git a/drivers/watchdog/watchdog_dev.c b/drivers/watchdog/watchdog_dev.c</span>
<span class="p_header">index 3595cffa24ea..cff8a65d7ef0 100644</span>
<span class="p_header">--- a/drivers/watchdog/watchdog_dev.c</span>
<span class="p_header">+++ b/drivers/watchdog/watchdog_dev.c</span>
<span class="p_chunk">@@ -258,10 +258,12 @@</span> <span class="p_context"> static int watchdog_stop(struct watchdog_device *wdd)</span>
 		return -EBUSY;
 	}
 
<span class="p_del">-	if (wdd-&gt;ops-&gt;stop)</span>
<span class="p_add">+	if (wdd-&gt;ops-&gt;stop) {</span>
<span class="p_add">+		clear_bit(WDOG_HW_RUNNING, &amp;wdd-&gt;status);</span>
 		err = wdd-&gt;ops-&gt;stop(wdd);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		set_bit(WDOG_HW_RUNNING, &amp;wdd-&gt;status);
<span class="p_add">+	}</span>
 
 	if (err == 0) {
 		clear_bit(WDOG_ACTIVE, &amp;wdd-&gt;status);
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index fb8e45b88cd4..4fe81d1c60f9 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -239,7 +239,12 @@</span> <span class="p_context"> static struct dentry *aio_mount(struct file_system_type *fs_type,</span>
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
<span class="p_del">-	return mount_pseudo(fs_type, &quot;aio:&quot;, NULL, &amp;ops, AIO_RING_MAGIC);</span>
<span class="p_add">+	struct dentry *root = mount_pseudo(fs_type, &quot;aio:&quot;, NULL, &amp;ops,</span>
<span class="p_add">+					   AIO_RING_MAGIC);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(root))</span>
<span class="p_add">+		root-&gt;d_sb-&gt;s_iflags |= SB_I_NOEXEC;</span>
<span class="p_add">+	return root;</span>
 }
 
 /* aio_setup
<span class="p_header">diff --git a/fs/ceph/dir.c b/fs/ceph/dir.c</span>
<span class="p_header">index 6e0fedf6713b..cf22f1e38fa3 100644</span>
<span class="p_header">--- a/fs/ceph/dir.c</span>
<span class="p_header">+++ b/fs/ceph/dir.c</span>
<span class="p_chunk">@@ -597,7 +597,7 @@</span> <span class="p_context"> static bool need_reset_readdir(struct ceph_file_info *fi, loff_t new_pos)</span>
 	if (is_hash_order(new_pos)) {
 		/* no need to reset last_name for a forward seek when
 		 * dentries are sotred in hash order */
<span class="p_del">-	} else if (fi-&gt;frag |= fpos_frag(new_pos)) {</span>
<span class="p_add">+	} else if (fi-&gt;frag != fpos_frag(new_pos)) {</span>
 		return true;
 	}
 	rinfo = fi-&gt;last_readdir ? &amp;fi-&gt;last_readdir-&gt;r_reply_info : NULL;
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index d81f96aacd51..656f68f7fe53 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -925,7 +925,7 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	if (hdr_arg.minorversion == 0) {
 		cps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);
 		if (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))
<span class="p_del">-			return rpc_drop_reply;</span>
<span class="p_add">+			goto out_invalidcred;</span>
 	}
 
 	cps.minorversion = hdr_arg.minorversion;
<span class="p_chunk">@@ -953,6 +953,10 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	nfs_put_client(cps.clp);
 	dprintk(&quot;%s: done, status = %u\n&quot;, __func__, ntohl(status));
 	return rpc_success;
<span class="p_add">+</span>
<span class="p_add">+out_invalidcred:</span>
<span class="p_add">+	pr_warn_ratelimited(&quot;NFS: NFSv4 callback contains invalid cred\n&quot;);</span>
<span class="p_add">+	return rpc_autherr_badcred;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayout.c b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">index aa59757389dc..b4c1407e8fe4 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_chunk">@@ -375,8 +375,7 @@</span> <span class="p_context"> static int filelayout_commit_done_cb(struct rpc_task *task,</span>
 		return -EAGAIN;
 	}
 
<span class="p_del">-	if (data-&gt;verf.committed == NFS_UNSTABLE)</span>
<span class="p_del">-		pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);</span>
<span class="p_add">+	pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 6da14aedde2b..1c15966c9f52 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> ff_layout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)</span>
 	if (ffl) {
 		INIT_LIST_HEAD(&amp;ffl-&gt;error_list);
 		INIT_LIST_HEAD(&amp;ffl-&gt;mirrors);
<span class="p_add">+		ffl-&gt;last_report_time = ktime_get();</span>
 		return &amp;ffl-&gt;generic_hdr;
 	} else
 		return NULL;
<span class="p_chunk">@@ -640,19 +641,18 @@</span> <span class="p_context"> nfs4_ff_layoutstat_start_io(struct nfs4_ff_layout_mirror *mirror,</span>
 {
 	static const ktime_t notime = {0};
 	s64 report_interval = FF_LAYOUTSTATS_REPORT_INTERVAL;
<span class="p_add">+	struct nfs4_flexfile_layout *ffl = FF_LAYOUT_FROM_HDR(mirror-&gt;layout);</span>
 
 	nfs4_ff_start_busy_timer(&amp;layoutstat-&gt;busy_timer, now);
 	if (ktime_equal(mirror-&gt;start_time, notime))
 		mirror-&gt;start_time = now;
<span class="p_del">-	if (ktime_equal(mirror-&gt;last_report_time, notime))</span>
<span class="p_del">-		mirror-&gt;last_report_time = now;</span>
 	if (mirror-&gt;report_interval != 0)
 		report_interval = (s64)mirror-&gt;report_interval * 1000LL;
 	else if (layoutstats_timer != 0)
 		report_interval = (s64)layoutstats_timer * 1000LL;
<span class="p_del">-	if (ktime_to_ms(ktime_sub(now, mirror-&gt;last_report_time)) &gt;=</span>
<span class="p_add">+	if (ktime_to_ms(ktime_sub(now, ffl-&gt;last_report_time)) &gt;=</span>
 			report_interval) {
<span class="p_del">-		mirror-&gt;last_report_time = now;</span>
<span class="p_add">+		ffl-&gt;last_report_time = now;</span>
 		return true;
 	}
 
<span class="p_chunk">@@ -1529,8 +1529,7 @@</span> <span class="p_context"> static int ff_layout_commit_done_cb(struct rpc_task *task,</span>
 		return -EAGAIN;
 	}
 
<span class="p_del">-	if (data-&gt;verf.committed == NFS_UNSTABLE</span>
<span class="p_del">-	    &amp;&amp; ff_layout_need_layoutcommit(data-&gt;lseg))</span>
<span class="p_add">+	if (ff_layout_need_layoutcommit(data-&gt;lseg))</span>
 		pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);
 
 	return 0;
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.h b/fs/nfs/flexfilelayout/flexfilelayout.h</span>
<span class="p_header">index 1bcdb15d0c41..3ee0c9fcea76 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.h</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.h</span>
<span class="p_chunk">@@ -84,7 +84,6 @@</span> <span class="p_context"> struct nfs4_ff_layout_mirror {</span>
 	struct nfs4_ff_layoutstat	read_stat;
 	struct nfs4_ff_layoutstat	write_stat;
 	ktime_t				start_time;
<span class="p_del">-	ktime_t				last_report_time;</span>
 	u32				report_interval;
 };
 
<span class="p_chunk">@@ -101,6 +100,7 @@</span> <span class="p_context"> struct nfs4_flexfile_layout {</span>
 	struct pnfs_ds_commit_info commit_info;
 	struct list_head	mirrors;
 	struct list_head	error_list; /* nfs4_ff_layout_ds_err */
<span class="p_add">+	ktime_t			last_report_time; /* Layoutstat report times */</span>
 };
 
 static inline struct nfs4_flexfile_layout *
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index e2320c643107..00fd0c716988 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -4393,7 +4393,8 @@</span> <span class="p_context"> static void nfs4_proc_read_setup(struct nfs_pgio_header *hdr,</span>
 				 struct rpc_message *msg)
 {
 	hdr-&gt;timestamp   = jiffies;
<span class="p_del">-	hdr-&gt;pgio_done_cb = nfs4_read_done_cb;</span>
<span class="p_add">+	if (!hdr-&gt;pgio_done_cb)</span>
<span class="p_add">+		hdr-&gt;pgio_done_cb = nfs4_read_done_cb;</span>
 	msg-&gt;rpc_proc = &amp;nfs4_procedures[NFSPROC4_CLNT_READ];
 	nfs4_init_sequence(&amp;hdr-&gt;args.seq_args, &amp;hdr-&gt;res.seq_res, 0);
 }
<span class="p_header">diff --git a/fs/pstore/inode.c b/fs/pstore/inode.c</span>
<span class="p_header">index 45d6110744cb..ec9ddef5ae75 100644</span>
<span class="p_header">--- a/fs/pstore/inode.c</span>
<span class="p_header">+++ b/fs/pstore/inode.c</span>
<span class="p_chunk">@@ -178,7 +178,6 @@</span> <span class="p_context"> static loff_t pstore_file_llseek(struct file *file, loff_t off, int whence)</span>
 }
 
 static const struct file_operations pstore_file_operations = {
<span class="p_del">-	.owner		= THIS_MODULE,</span>
 	.open		= pstore_file_open,
 	.read		= pstore_file_read,
 	.llseek		= pstore_file_llseek,
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index 5261751f6bd4..5f5270941ba0 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> enum can_mode {</span>
  * CAN common private data
  */
 struct can_priv {
<span class="p_add">+	struct net_device *dev;</span>
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming, data_bittiming;
<span class="p_chunk">@@ -47,7 +48,7 @@</span> <span class="p_context"> struct can_priv {</span>
 	u32 ctrlmode_static;	/* static enabled options for driver/hardware */
 
 	int restart_ms;
<span class="p_del">-	struct timer_list restart_timer;</span>
<span class="p_add">+	struct delayed_work restart_work;</span>
 
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_data_bittiming)(struct net_device *dev);
<span class="p_header">diff --git a/include/linux/nvmem-consumer.h b/include/linux/nvmem-consumer.h</span>
<span class="p_header">index 9bb77d3ed6e0..c2256d746543 100644</span>
<span class="p_header">--- a/include/linux/nvmem-consumer.h</span>
<span class="p_header">+++ b/include/linux/nvmem-consumer.h</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> static inline void nvmem_cell_put(struct nvmem_cell *cell)</span>
 {
 }
 
<span class="p_del">-static inline char *nvmem_cell_read(struct nvmem_cell *cell, size_t *len)</span>
<span class="p_add">+static inline void *nvmem_cell_read(struct nvmem_cell *cell, size_t *len)</span>
 {
 	return ERR_PTR(-ENOSYS);
 }
<span class="p_header">diff --git a/include/linux/slub_def.h b/include/linux/slub_def.h</span>
<span class="p_header">index d1faa019c02a..b71b2581811c 100644</span>
<span class="p_header">--- a/include/linux/slub_def.h</span>
<span class="p_header">+++ b/include/linux/slub_def.h</span>
<span class="p_chunk">@@ -114,15 +114,17 @@</span> <span class="p_context"> static inline void sysfs_slab_remove(struct kmem_cache *s)</span>
 void object_err(struct kmem_cache *s, struct page *page,
 		u8 *object, char *reason);
 
<span class="p_add">+void *fixup_red_left(struct kmem_cache *s, void *p);</span>
<span class="p_add">+</span>
 static inline void *nearest_obj(struct kmem_cache *cache, struct page *page,
 				void *x) {
 	void *object = x - (x - page_address(page)) % cache-&gt;size;
 	void *last_object = page_address(page) +
 		(page-&gt;objects - 1) * cache-&gt;size;
<span class="p_del">-	if (unlikely(object &gt; last_object))</span>
<span class="p_del">-		return last_object;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return object;</span>
<span class="p_add">+	void *result = (unlikely(object &gt; last_object)) ? last_object : object;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = fixup_red_left(cache, result);</span>
<span class="p_add">+	return result;</span>
 }
 
 #endif /* _LINUX_SLUB_DEF_H */
<span class="p_header">diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h</span>
<span class="p_header">index fa7bc29925c9..ef17db6caaed 100644</span>
<span class="p_header">--- a/include/linux/sysctl.h</span>
<span class="p_header">+++ b/include/linux/sysctl.h</span>
<span class="p_chunk">@@ -41,6 +41,8 @@</span> <span class="p_context"> extern int proc_dostring(struct ctl_table *, int,</span>
 			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec(struct ctl_table *, int,
 			 void __user *, size_t *, loff_t *);
<span class="p_add">+extern int proc_douintvec(struct ctl_table *, int,</span>
<span class="p_add">+			 void __user *, size_t *, loff_t *);</span>
 extern int proc_dointvec_minmax(struct ctl_table *, int,
 				void __user *, size_t *, loff_t *);
 extern int proc_dointvec_jiffies(struct ctl_table *, int,
<span class="p_header">diff --git a/include/scsi/scsi_transport_sas.h b/include/scsi/scsi_transport_sas.h</span>
<span class="p_header">index 13c0b2ba1b6c..31ae074dad9d 100644</span>
<span class="p_header">--- a/include/scsi/scsi_transport_sas.h</span>
<span class="p_header">+++ b/include/scsi/scsi_transport_sas.h</span>
<span class="p_chunk">@@ -15,8 +15,14 @@</span> <span class="p_context"> static inline int is_sas_attached(struct scsi_device *sdev)</span>
 {
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int scsi_is_sas_rphy(const struct device *sdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 #else
 extern int is_sas_attached(struct scsi_device *sdev);
<span class="p_add">+extern int scsi_is_sas_rphy(const struct device *);</span>
 #endif
 
 static inline int sas_protocol_ata(enum sas_protocol proto)
<span class="p_chunk">@@ -202,7 +208,6 @@</span> <span class="p_context"> extern int sas_rphy_add(struct sas_rphy *);</span>
 extern void sas_rphy_remove(struct sas_rphy *);
 extern void sas_rphy_delete(struct sas_rphy *);
 extern void sas_rphy_unlink(struct sas_rphy *);
<span class="p_del">-extern int scsi_is_sas_rphy(const struct device *);</span>
 
 struct sas_port *sas_port_alloc(struct device *, int);
 struct sas_port *sas_port_alloc_num(struct device *);
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index 129a7ca5f159..b1e0cbb8cf97 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -3452,9 +3452,28 @@</span> <span class="p_context"> static ssize_t cgroup_subtree_control_write(struct kernfs_open_file *of,</span>
 	 * Except for the root, subtree_control must be zero for a cgroup
 	 * with tasks so that child cgroups don&#39;t compete against tasks.
 	 */
<span class="p_del">-	if (enable &amp;&amp; cgroup_parent(cgrp) &amp;&amp; !list_empty(&amp;cgrp-&gt;cset_links)) {</span>
<span class="p_del">-		ret = -EBUSY;</span>
<span class="p_del">-		goto out_unlock;</span>
<span class="p_add">+	if (enable &amp;&amp; cgroup_parent(cgrp)) {</span>
<span class="p_add">+		struct cgrp_cset_link *link;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Because namespaces pin csets too, @cgrp-&gt;cset_links</span>
<span class="p_add">+		 * might not be empty even when @cgrp is empty.  Walk and</span>
<span class="p_add">+		 * verify each cset.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		spin_lock_irq(&amp;css_set_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		list_for_each_entry(link, &amp;cgrp-&gt;cset_links, cset_link) {</span>
<span class="p_add">+			if (css_set_populated(link-&gt;cset)) {</span>
<span class="p_add">+				ret = -EBUSY;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_unlock_irq(&amp;css_set_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_unlock;</span>
 	}
 
 	/* save and update control masks and prepare csses */
<span class="p_chunk">@@ -3905,7 +3924,9 @@</span> <span class="p_context"> void cgroup_file_notify(struct cgroup_file *cfile)</span>
  * cgroup_task_count - count the number of tasks in a cgroup.
  * @cgrp: the cgroup in question
  *
<span class="p_del">- * Return the number of tasks in the cgroup.</span>
<span class="p_add">+ * Return the number of tasks in the cgroup.  The returned number can be</span>
<span class="p_add">+ * higher than the actual number of tasks due to css_set references from</span>
<span class="p_add">+ * namespace roots and temporary usages.</span>
  */
 static int cgroup_task_count(const struct cgroup *cgrp)
 {
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index 40b6ed559448..8cee9627ac4b 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -325,8 +325,7 @@</span> <span class="p_context"> static struct file_system_type cpuset_fs_type = {</span>
 /*
  * Return in pmask the portion of a cpusets&#39;s cpus_allowed that
  * are online.  If none are online, walk up the cpuset hierarchy
<span class="p_del">- * until we find one that does have some online cpus.  The top</span>
<span class="p_del">- * cpuset always has some cpus online.</span>
<span class="p_add">+ * until we find one that does have some online cpus.</span>
  *
  * One way or another, we guarantee to return some non-empty subset
  * of cpu_online_mask.
<span class="p_chunk">@@ -335,8 +334,20 @@</span> <span class="p_context"> static struct file_system_type cpuset_fs_type = {</span>
  */
 static void guarantee_online_cpus(struct cpuset *cs, struct cpumask *pmask)
 {
<span class="p_del">-	while (!cpumask_intersects(cs-&gt;effective_cpus, cpu_online_mask))</span>
<span class="p_add">+	while (!cpumask_intersects(cs-&gt;effective_cpus, cpu_online_mask)) {</span>
 		cs = parent_cs(cs);
<span class="p_add">+		if (unlikely(!cs)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The top cpuset doesn&#39;t have any online cpu as a</span>
<span class="p_add">+			 * consequence of a race between cpuset_hotplug_work</span>
<span class="p_add">+			 * and cpu hotplug notifier.  But we know the top</span>
<span class="p_add">+			 * cpuset&#39;s effective_cpus is on its way to to be</span>
<span class="p_add">+			 * identical to cpu_online_mask.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cpumask_copy(pmask, cpu_online_mask);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	cpumask_and(pmask, cs-&gt;effective_cpus, cpu_online_mask);
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index e68c0a735c8f..31c1520b744d 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -6064,7 +6064,7 @@</span> <span class="p_context"> static int __perf_pmu_output_stop(void *info)</span>
 {
 	struct perf_event *event = info;
 	struct pmu *pmu = event-&gt;pmu;
<span class="p_del">-	struct perf_cpu_context *cpuctx = get_cpu_ptr(pmu-&gt;pmu_cpu_context);</span>
<span class="p_add">+	struct perf_cpu_context *cpuctx = this_cpu_ptr(pmu-&gt;pmu_cpu_context);</span>
 	struct remote_output ro = {
 		.rb	= event-&gt;rb,
 	};
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 74fd39079031..d6404ede47eb 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -938,14 +938,12 @@</span> <span class="p_context"> void mm_release(struct task_struct *tsk, struct mm_struct *mm)</span>
 	deactivate_mm(tsk, mm);
 
 	/*
<span class="p_del">-	 * If we&#39;re exiting normally, clear a user-space tid field if</span>
<span class="p_del">-	 * requested.  We leave this alone when dying by signal, to leave</span>
<span class="p_del">-	 * the value intact in a core dump, and to save the unnecessary</span>
<span class="p_del">-	 * trouble, say, a killed vfork parent shouldn&#39;t touch this mm.</span>
<span class="p_del">-	 * Userland only wants this done for a sys_exit.</span>
<span class="p_add">+	 * Signal userspace if we&#39;re not exiting with a core dump</span>
<span class="p_add">+	 * because we want to leave the value intact for debugging</span>
<span class="p_add">+	 * purposes.</span>
 	 */
 	if (tsk-&gt;clear_child_tid) {
<span class="p_del">-		if (!(tsk-&gt;flags &amp; PF_SIGNALED) &amp;&amp;</span>
<span class="p_add">+		if (!(tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &amp;&amp;</span>
 		    atomic_read(&amp;mm-&gt;mm_users) &gt; 1) {
 			/*
 			 * We don&#39;t check the error code - if userspace has
<span class="p_header">diff --git a/kernel/printk/braille.c b/kernel/printk/braille.c</span>
<span class="p_header">index 276762f3a460..d5760c42f042 100644</span>
<span class="p_header">--- a/kernel/printk/braille.c</span>
<span class="p_header">+++ b/kernel/printk/braille.c</span>
<span class="p_chunk">@@ -9,10 +9,10 @@</span> <span class="p_context"></span>
 
 char *_braille_console_setup(char **str, char **brl_options)
 {
<span class="p_del">-	if (!memcmp(*str, &quot;brl,&quot;, 4)) {</span>
<span class="p_add">+	if (!strncmp(*str, &quot;brl,&quot;, 4)) {</span>
 		*brl_options = &quot;&quot;;
 		*str += 4;
<span class="p_del">-	} else if (!memcmp(str, &quot;brl=&quot;, 4)) {</span>
<span class="p_add">+	} else if (!strncmp(*str, &quot;brl=&quot;, 4)) {</span>
 		*brl_options = *str + 4;
 		*str = strchr(*brl_options, &#39;,&#39;);
 		if (!*str)
<span class="p_header">diff --git a/kernel/rcu/rcuperf.c b/kernel/rcu/rcuperf.c</span>
<span class="p_header">index 3cee0d8393ed..8ce4eecff319 100644</span>
<span class="p_header">--- a/kernel/rcu/rcuperf.c</span>
<span class="p_header">+++ b/kernel/rcu/rcuperf.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> MODULE_AUTHOR(&quot;Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;&quot;);</span>
 #define VERBOSE_PERFOUT_ERRSTRING(s) \
 	do { if (verbose) pr_alert(&quot;%s&quot; PERF_FLAG &quot;!!! %s\n&quot;, perf_type, s); } while (0)
 
<span class="p_del">-torture_param(bool, gp_exp, true, &quot;Use expedited GP wait primitives&quot;);</span>
<span class="p_add">+torture_param(bool, gp_exp, false, &quot;Use expedited GP wait primitives&quot;);</span>
 torture_param(int, holdoff, 10, &quot;Holdoff time before test start (s)&quot;);
 torture_param(int, nreaders, -1, &quot;Number of RCU reader threads&quot;);
 torture_param(int, nwriters, -1, &quot;Number of RCU updater threads&quot;);
<span class="p_chunk">@@ -363,8 +363,6 @@</span> <span class="p_context"> rcu_perf_writer(void *arg)</span>
 	u64 *wdpp = writer_durations[me];
 
 	VERBOSE_PERFOUT_STRING(&quot;rcu_perf_writer task started&quot;);
<span class="p_del">-	WARN_ON(rcu_gp_is_expedited() &amp;&amp; !rcu_gp_is_normal() &amp;&amp; !gp_exp);</span>
<span class="p_del">-	WARN_ON(rcu_gp_is_normal() &amp;&amp; gp_exp);</span>
 	WARN_ON(!wdpp);
 	set_cpus_allowed_ptr(current, cpumask_of(me % nr_cpu_ids));
 	sp.sched_priority = 1;
<span class="p_chunk">@@ -631,6 +629,16 @@</span> <span class="p_context"> rcu_perf_init(void)</span>
 		firsterr = -ENOMEM;
 		goto unwind;
 	}
<span class="p_add">+	if (rcu_gp_is_expedited() &amp;&amp; !rcu_gp_is_normal() &amp;&amp; !gp_exp) {</span>
<span class="p_add">+		VERBOSE_PERFOUT_ERRSTRING(&quot;All grace periods expedited, no normal ones to measure!&quot;);</span>
<span class="p_add">+		firsterr = -EINVAL;</span>
<span class="p_add">+		goto unwind;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (rcu_gp_is_normal() &amp;&amp; gp_exp) {</span>
<span class="p_add">+		VERBOSE_PERFOUT_ERRSTRING(&quot;All grace periods normal, no expedited ones to measure!&quot;);</span>
<span class="p_add">+		firsterr = -EINVAL;</span>
<span class="p_add">+		goto unwind;</span>
<span class="p_add">+	}</span>
 	for (i = 0; i &lt; nrealwriters; i++) {
 		writer_durations[i] =
 			kcalloc(MAX_MEAS, sizeof(*writer_durations[i]),
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 38eacc323fdd..e1422c1f5a29 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -7255,7 +7255,6 @@</span> <span class="p_context"> static void sched_rq_cpu_starting(unsigned int cpu)</span>
 	struct rq *rq = cpu_rq(cpu);
 
 	rq-&gt;calc_load_update = calc_load_update;
<span class="p_del">-	account_reset_rq(rq);</span>
 	update_max_interval();
 }
 
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index 898c0d2f18fe..b4f3edf9a219 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -1809,16 +1809,3 @@</span> <span class="p_context"> static inline void cpufreq_trigger_update(u64 time) {}</span>
 #else /* arch_scale_freq_capacity */
 #define arch_scale_freq_invariant()	(false)
 #endif
<span class="p_del">-</span>
<span class="p_del">-static inline void account_reset_rq(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_irq_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_del">-	rq-&gt;prev_steal_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_steal_time_rq = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 87b2fc38398b..b58e447233bf 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -2122,6 +2122,21 @@</span> <span class="p_context"> static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,</span>
 	return 0;
 }
 
<span class="p_add">+static int do_proc_douintvec_conv(bool *negp, unsigned long *lvalp,</span>
<span class="p_add">+				 int *valp,</span>
<span class="p_add">+				 int write, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (write) {</span>
<span class="p_add">+		if (*negp)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		*valp = *lvalp;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		unsigned int val = *valp;</span>
<span class="p_add">+		*lvalp = (unsigned long)val;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const char proc_wspace_sep[] = { &#39; &#39;, &#39;\t&#39;, &#39;\n&#39; };
 
 static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
<span class="p_chunk">@@ -2241,8 +2256,27 @@</span> <span class="p_context"> static int do_proc_dointvec(struct ctl_table *table, int write,</span>
 int proc_dointvec(struct ctl_table *table, int write,
 		     void __user *buffer, size_t *lenp, loff_t *ppos)
 {
<span class="p_del">-    return do_proc_dointvec(table,write,buffer,lenp,ppos,</span>
<span class="p_del">-		    	    NULL,NULL);</span>
<span class="p_add">+	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * proc_douintvec - read a vector of unsigned integers</span>
<span class="p_add">+ * @table: the sysctl table</span>
<span class="p_add">+ * @write: %TRUE if this is a write to the sysctl file</span>
<span class="p_add">+ * @buffer: the user buffer</span>
<span class="p_add">+ * @lenp: the size of the user buffer</span>
<span class="p_add">+ * @ppos: file position</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer</span>
<span class="p_add">+ * values from/to the user buffer, treated as an ASCII string.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 on success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int proc_douintvec(struct ctl_table *table, int write,</span>
<span class="p_add">+		     void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return do_proc_dointvec(table, write, buffer, lenp, ppos,</span>
<span class="p_add">+				do_proc_douintvec_conv, NULL);</span>
 }
 
 /*
<span class="p_chunk">@@ -2840,6 +2874,12 @@</span> <span class="p_context"> int proc_dointvec(struct ctl_table *table, int write,</span>
 	return -ENOSYS;
 }
 
<span class="p_add">+int proc_douintvec(struct ctl_table *table, int write,</span>
<span class="p_add">+		  void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENOSYS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int proc_dointvec_minmax(struct ctl_table *table, int write,
 		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
<span class="p_chunk">@@ -2885,6 +2925,7 @@</span> <span class="p_context"> int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,</span>
  * exception granted :-)
  */
 EXPORT_SYMBOL(proc_dointvec);
<span class="p_add">+EXPORT_SYMBOL(proc_douintvec);</span>
 EXPORT_SYMBOL(proc_dointvec_jiffies);
 EXPORT_SYMBOL(proc_dointvec_minmax);
 EXPORT_SYMBOL(proc_dointvec_userhz_jiffies);
<span class="p_header">diff --git a/kernel/trace/Kconfig b/kernel/trace/Kconfig</span>
<span class="p_header">index fafeaf803bd0..f4b86e8ca1e7 100644</span>
<span class="p_header">--- a/kernel/trace/Kconfig</span>
<span class="p_header">+++ b/kernel/trace/Kconfig</span>
<span class="p_chunk">@@ -542,6 +542,7 @@</span> <span class="p_context"> config HIST_TRIGGERS</span>
 	bool &quot;Histogram triggers&quot;
 	depends on ARCH_HAVE_NMI_SAFE_CMPXCHG
 	select TRACING_MAP
<span class="p_add">+	select TRACING</span>
 	default n
 	help
 	  Hist triggers allow one or more arbitrary trace event fields
<span class="p_header">diff --git a/lib/test_hash.c b/lib/test_hash.c</span>
<span class="p_header">index c9549c8b4909..a06ac379ad42 100644</span>
<span class="p_header">--- a/lib/test_hash.c</span>
<span class="p_header">+++ b/lib/test_hash.c</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static int __init</span>
 test_hash_init(void)
 {
 	char buf[SIZE+1];
<span class="p_del">-	u32 string_or = 0, hash_or[2][33] = { 0 };</span>
<span class="p_add">+	u32 string_or = 0, hash_or[2][33] = { { 0, } };</span>
 	unsigned tests = 0;
 	unsigned long long h64 = 0;
 	int i, j;
<span class="p_chunk">@@ -219,21 +219,27 @@</span> <span class="p_context"> test_hash_init(void)</span>
 	}
 
 	/* Issue notices about skipped tests. */
<span class="p_del">-#ifndef HAVE_ARCH__HASH_32</span>
<span class="p_del">-	pr_info(&quot;__hash_32() has no arch implementation to test.&quot;);</span>
<span class="p_del">-#elif HAVE_ARCH__HASH_32 != 1</span>
<span class="p_add">+#ifdef HAVE_ARCH__HASH_32</span>
<span class="p_add">+#if HAVE_ARCH__HASH_32 != 1</span>
 	pr_info(&quot;__hash_32() is arch-specific; not compared to generic.&quot;);
 #endif
<span class="p_del">-#ifndef HAVE_ARCH_HASH_32</span>
<span class="p_del">-	pr_info(&quot;hash_32() has no arch implementation to test.&quot;);</span>
<span class="p_del">-#elif HAVE_ARCH_HASH_32 != 1</span>
<span class="p_add">+#else</span>
<span class="p_add">+	pr_info(&quot;__hash_32() has no arch implementation to test.&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef HAVE_ARCH_HASH_32</span>
<span class="p_add">+#if HAVE_ARCH_HASH_32 != 1</span>
 	pr_info(&quot;hash_32() is arch-specific; not compared to generic.&quot;);
 #endif
<span class="p_del">-#ifndef HAVE_ARCH_HASH_64</span>
<span class="p_del">-	pr_info(&quot;hash_64() has no arch implementation to test.&quot;);</span>
<span class="p_del">-#elif HAVE_ARCH_HASH_64 != 1</span>
<span class="p_add">+#else</span>
<span class="p_add">+	pr_info(&quot;hash_32() has no arch implementation to test.&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef HAVE_ARCH_HASH_64</span>
<span class="p_add">+#if HAVE_ARCH_HASH_64 != 1</span>
 	pr_info(&quot;hash_64() is arch-specific; not compared to generic.&quot;);
 #endif
<span class="p_add">+#else</span>
<span class="p_add">+	pr_info(&quot;hash_64() has no arch implementation to test.&quot;);</span>
<span class="p_add">+#endif</span>
 
 	pr_notice(&quot;%u tests passed.&quot;, tests);
 
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index 4786b4150f62..443bac35cd87 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -283,7 +283,8 @@</span> <span class="p_context"> static inline struct rmap_item *alloc_rmap_item(void)</span>
 {
 	struct rmap_item *rmap_item;
 
<span class="p_del">-	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL);</span>
<span class="p_add">+	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |</span>
<span class="p_add">+						__GFP_NORETRY | __GFP_NOWARN);</span>
 	if (rmap_item)
 		ksm_rmap_items++;
 	return rmap_item;
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 7a6d268840c0..b94fb362a018 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static inline int kmem_cache_debug(struct kmem_cache *s)</span>
 #endif
 }
 
<span class="p_del">-static inline void *fixup_red_left(struct kmem_cache *s, void *p)</span>
<span class="p_add">+inline void *fixup_red_left(struct kmem_cache *s, void *p)</span>
 {
 	if (kmem_cache_debug(s) &amp;&amp; s-&gt;flags &amp; SLAB_RED_ZONE)
 		p += s-&gt;red_left_pad;
<span class="p_header">diff --git a/net/batman-adv/bat_v_elp.c b/net/batman-adv/bat_v_elp.c</span>
<span class="p_header">index df42eb1365a0..63762b3df7c7 100644</span>
<span class="p_header">--- a/net/batman-adv/bat_v_elp.c</span>
<span class="p_header">+++ b/net/batman-adv/bat_v_elp.c</span>
<span class="p_chunk">@@ -334,7 +334,7 @@</span> <span class="p_context"> int batadv_v_elp_iface_enable(struct batadv_hard_iface *hard_iface)</span>
 		goto out;
 
 	skb_reserve(hard_iface-&gt;bat_v.elp_skb, ETH_HLEN + NET_IP_ALIGN);
<span class="p_del">-	elp_buff = skb_push(hard_iface-&gt;bat_v.elp_skb, BATADV_ELP_HLEN);</span>
<span class="p_add">+	elp_buff = skb_put(hard_iface-&gt;bat_v.elp_skb, BATADV_ELP_HLEN);</span>
 	elp_packet = (struct batadv_elp_packet *)elp_buff;
 	memset(elp_packet, 0, BATADV_ELP_HLEN);
 
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index ab8c4f9738fe..1da7bfc61ac6 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -251,10 +251,8 @@</span> <span class="p_context"> static void batadv_neigh_node_release(struct kref *ref)</span>
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_node *neigh_node;
 	struct batadv_neigh_ifinfo *neigh_ifinfo;
<span class="p_del">-	struct batadv_algo_ops *bao;</span>
 
 	neigh_node = container_of(ref, struct batadv_neigh_node, refcount);
<span class="p_del">-	bao = neigh_node-&gt;orig_node-&gt;bat_priv-&gt;bat_algo_ops;</span>
 
 	hlist_for_each_entry_safe(neigh_ifinfo, node_tmp,
 				  &amp;neigh_node-&gt;ifinfo_list, list) {
<span class="p_chunk">@@ -263,9 +261,6 @@</span> <span class="p_context"> static void batadv_neigh_node_release(struct kref *ref)</span>
 
 	batadv_hardif_neigh_put(neigh_node-&gt;hardif_neigh);
 
<span class="p_del">-	if (bao-&gt;bat_neigh_free)</span>
<span class="p_del">-		bao-&gt;bat_neigh_free(neigh_node);</span>
<span class="p_del">-</span>
 	batadv_hardif_put(neigh_node-&gt;if_incoming);
 
 	kfree_rcu(neigh_node, rcu);
<span class="p_header">diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c</span>
<span class="p_header">index bfac086b4d01..69d425d5729e 100644</span>
<span class="p_header">--- a/net/batman-adv/routing.c</span>
<span class="p_header">+++ b/net/batman-adv/routing.c</span>
<span class="p_chunk">@@ -456,6 +456,29 @@</span> <span class="p_context"> static int batadv_check_unicast_packet(struct batadv_priv *bat_priv,</span>
 }
 
 /**
<span class="p_add">+ * batadv_last_bonding_get - Get last_bonding_candidate of orig_node</span>
<span class="p_add">+ * @orig_node: originator node whose last bonding candidate should be retrieved</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: last bonding candidate of router or NULL if not found</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The object is returned with refcounter increased by 1.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct batadv_orig_ifinfo *</span>
<span class="p_add">+batadv_last_bonding_get(struct batadv_orig_node *orig_node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_orig_ifinfo *last_bonding_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+	last_bonding_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last_bonding_candidate)</span>
<span class="p_add">+		kref_get(&amp;last_bonding_candidate-&gt;refcount);</span>
<span class="p_add">+	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return last_bonding_candidate;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * batadv_last_bonding_replace - Replace last_bonding_candidate of orig_node
  * @orig_node: originator node whose bonding candidates should be replaced
  * @new_candidate: new bonding candidate or NULL
<span class="p_chunk">@@ -525,7 +548,7 @@</span> <span class="p_context"> batadv_find_router(struct batadv_priv *bat_priv,</span>
 	 * router - obviously there are no other candidates.
 	 */
 	rcu_read_lock();
<span class="p_del">-	last_candidate = orig_node-&gt;last_bonding_candidate;</span>
<span class="p_add">+	last_candidate = batadv_last_bonding_get(orig_node);</span>
 	if (last_candidate)
 		last_cand_router = rcu_dereference(last_candidate-&gt;router);
 
<span class="p_chunk">@@ -617,6 +640,9 @@</span> <span class="p_context"> next:</span>
 		batadv_orig_ifinfo_put(next_candidate);
 	}
 
<span class="p_add">+	if (last_candidate)</span>
<span class="p_add">+		batadv_orig_ifinfo_put(last_candidate);</span>
<span class="p_add">+</span>
 	return router;
 }
 
<span class="p_header">diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h</span>
<span class="p_header">index 74d865a4df46..40aed16fbc28 100644</span>
<span class="p_header">--- a/net/batman-adv/types.h</span>
<span class="p_header">+++ b/net/batman-adv/types.h</span>
<span class="p_chunk">@@ -1284,8 +1284,6 @@</span> <span class="p_context"> struct batadv_forw_packet {</span>
  *  better than neigh2 for their respective outgoing interface from the metric
  *  prospective
  * @bat_neigh_print: print the single hop neighbor list (optional)
<span class="p_del">- * @bat_neigh_free: free the resources allocated by the routing algorithm for a</span>
<span class="p_del">- *  neigh_node object</span>
  * @bat_orig_print: print the originator table (optional)
  * @bat_orig_free: free the resources allocated by the routing algorithm for an
  *  orig_node object
<span class="p_chunk">@@ -1316,7 +1314,6 @@</span> <span class="p_context"> struct batadv_algo_ops {</span>
 		 struct batadv_neigh_node *neigh2,
 		 struct batadv_hard_iface *if_outgoing2);
 	void (*bat_neigh_print)(struct batadv_priv *priv, struct seq_file *seq);
<span class="p_del">-	void (*bat_neigh_free)(struct batadv_neigh_node *neigh);</span>
 	/* orig_node handling API */
 	void (*bat_orig_print)(struct batadv_priv *priv, struct seq_file *seq,
 			       struct batadv_hard_iface *hard_iface);
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index eb4f5f24cbe3..106643e268ba 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/debugfs.h&gt;
 #include &lt;linux/crc16.h&gt;
<span class="p_add">+#include &lt;linux/filter.h&gt;</span>
 
 #include &lt;net/bluetooth/bluetooth.h&gt;
 #include &lt;net/bluetooth/hci_core.h&gt;
<span class="p_chunk">@@ -5835,6 +5836,9 @@</span> <span class="p_context"> static int l2cap_reassemble_sdu(struct l2cap_chan *chan, struct sk_buff *skb,</span>
 		if (chan-&gt;sdu)
 			break;
 
<span class="p_add">+		if (!pskb_may_pull(skb, L2CAP_SDULEN_SIZE))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		chan-&gt;sdu_len = get_unaligned_le16(skb-&gt;data);
 		skb_pull(skb, L2CAP_SDULEN_SIZE);
 
<span class="p_chunk">@@ -6610,6 +6614,10 @@</span> <span class="p_context"> static int l2cap_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)</span>
 		goto drop;
 	}
 
<span class="p_add">+	if ((chan-&gt;mode == L2CAP_MODE_ERTM ||</span>
<span class="p_add">+	     chan-&gt;mode == L2CAP_MODE_STREAMING) &amp;&amp; sk_filter(chan-&gt;data, skb))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (!control-&gt;sframe) {
 		int err;
 
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 1842141baedb..a8ba752732c9 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -1019,7 +1019,7 @@</span> <span class="p_context"> static int l2cap_sock_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 		goto done;
 
 	if (pi-&gt;rx_busy_skb) {
<span class="p_del">-		if (!sock_queue_rcv_skb(sk, pi-&gt;rx_busy_skb))</span>
<span class="p_add">+		if (!__sock_queue_rcv_skb(sk, pi-&gt;rx_busy_skb))</span>
 			pi-&gt;rx_busy_skb = NULL;
 		else
 			goto done;
<span class="p_chunk">@@ -1270,7 +1270,17 @@</span> <span class="p_context"> static int l2cap_sock_recv_cb(struct l2cap_chan *chan, struct sk_buff *skb)</span>
 		goto done;
 	}
 
<span class="p_del">-	err = sock_queue_rcv_skb(sk, skb);</span>
<span class="p_add">+	if (chan-&gt;mode != L2CAP_MODE_ERTM &amp;&amp;</span>
<span class="p_add">+	    chan-&gt;mode != L2CAP_MODE_STREAMING) {</span>
<span class="p_add">+		/* Even if no filter is attached, we could potentially</span>
<span class="p_add">+		 * get errors from security modules, etc.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = sk_filter(sk, skb);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	err = __sock_queue_rcv_skb(sk, skb);</span>
 
 	/* For ERTM, handle one skb that doesn&#39;t fit into the recv
 	 * buffer.  This is important to do because the data frames
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 8bad2ad81399..5f0ed8c6584d 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -1330,8 +1330,12 @@</span> <span class="p_context"> out:</span>
 	spin_unlock_bh(&amp;txqi-&gt;queue.lock);
 
 	if (skb &amp;&amp; skb_has_frag_list(skb) &amp;&amp;
<span class="p_del">-	    !ieee80211_hw_check(&amp;local-&gt;hw, TX_FRAG_LIST))</span>
<span class="p_del">-		skb_linearize(skb);</span>
<span class="p_add">+	    !ieee80211_hw_check(&amp;local-&gt;hw, TX_FRAG_LIST)) {</span>
<span class="p_add">+		if (skb_linearize(skb)) {</span>
<span class="p_add">+			ieee80211_free_txskb(&amp;local-&gt;hw, skb);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	return skb;
 }
<span class="p_header">diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c</span>
<span class="p_header">index 2808d550d273..0294ada6bc40 100644</span>
<span class="p_header">--- a/net/sunrpc/clnt.c</span>
<span class="p_header">+++ b/net/sunrpc/clnt.c</span>
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> static struct rpc_clnt *rpc_create_xprt(struct rpc_create_args *args,</span>
 	struct rpc_xprt_switch *xps;
 
 	if (args-&gt;bc_xprt &amp;&amp; args-&gt;bc_xprt-&gt;xpt_bc_xps) {
<span class="p_del">-		WARN_ON(args-&gt;protocol != XPRT_TRANSPORT_BC_TCP);</span>
<span class="p_add">+		WARN_ON_ONCE(!(args-&gt;protocol &amp; XPRT_TRANSPORT_BC));</span>
 		xps = args-&gt;bc_xprt-&gt;xpt_bc_xps;
 		xprt_switch_get(xps);
 	} else {
<span class="p_chunk">@@ -520,7 +520,7 @@</span> <span class="p_context"> struct rpc_clnt *rpc_create(struct rpc_create_args *args)</span>
 	char servername[48];
 
 	if (args-&gt;bc_xprt) {
<span class="p_del">-		WARN_ON(args-&gt;protocol != XPRT_TRANSPORT_BC_TCP);</span>
<span class="p_add">+		WARN_ON_ONCE(!(args-&gt;protocol &amp; XPRT_TRANSPORT_BC));</span>
 		xprt = args-&gt;bc_xprt-&gt;xpt_bc_xprt;
 		if (xprt) {
 			xprt_get(xprt);
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index cc9852897395..c5b0cb4f4056 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1188,11 +1188,17 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 		*statp = procp-&gt;pc_func(rqstp, rqstp-&gt;rq_argp, rqstp-&gt;rq_resp);
 
 		/* Encode reply */
<span class="p_del">-		if (test_bit(RQ_DROPME, &amp;rqstp-&gt;rq_flags)) {</span>
<span class="p_add">+		if (*statp == rpc_drop_reply ||</span>
<span class="p_add">+		    test_bit(RQ_DROPME, &amp;rqstp-&gt;rq_flags)) {</span>
 			if (procp-&gt;pc_release)
 				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);
 			goto dropit;
 		}
<span class="p_add">+		if (*statp == rpc_autherr_badcred) {</span>
<span class="p_add">+			if (procp-&gt;pc_release)</span>
<span class="p_add">+				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);</span>
<span class="p_add">+			goto err_bad_auth;</span>
<span class="p_add">+		}</span>
 		if (*statp == rpc_success &amp;&amp;
 		    (xdr = procp-&gt;pc_encode) &amp;&amp;
 		    !xdr(rqstp, resv-&gt;iov_base+resv-&gt;iov_len, rqstp-&gt;rq_resp)) {
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/fmr_ops.c b/net/sunrpc/xprtrdma/fmr_ops.c</span>
<span class="p_header">index 6326ebe8b595..c748ff6f6877 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/fmr_ops.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/fmr_ops.c</span>
<span class="p_chunk">@@ -63,9 +63,12 @@</span> <span class="p_context"> static int</span>
 __fmr_unmap(struct rpcrdma_mw *mw)
 {
 	LIST_HEAD(l);
<span class="p_add">+	int rc;</span>
 
 	list_add(&amp;mw-&gt;fmr.fmr-&gt;list, &amp;l);
<span class="p_del">-	return ib_unmap_fmr(&amp;l);</span>
<span class="p_add">+	rc = ib_unmap_fmr(&amp;l);</span>
<span class="p_add">+	list_del_init(&amp;mw-&gt;fmr.fmr-&gt;list);</span>
<span class="p_add">+	return rc;</span>
 }
 
 /* Deferred reset of a single FMR. Generate a fresh rkey by
<span class="p_chunk">@@ -267,7 +270,7 @@</span> <span class="p_context"> fmr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 		seg = &amp;req-&gt;rl_segments[i];
 		mw = seg-&gt;rl_mw;
 
<span class="p_del">-		list_add(&amp;mw-&gt;fmr.fmr-&gt;list, &amp;unmap_list);</span>
<span class="p_add">+		list_add_tail(&amp;mw-&gt;fmr.fmr-&gt;list, &amp;unmap_list);</span>
 
 		i += seg-&gt;mr_nsegs;
 	}
<span class="p_chunk">@@ -280,7 +283,9 @@</span> <span class="p_context"> fmr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)</span>
 	 */
 	for (i = 0, nchunks = req-&gt;rl_nchunks; nchunks; nchunks--) {
 		seg = &amp;req-&gt;rl_segments[i];
<span class="p_add">+		mw = seg-&gt;rl_mw;</span>
 
<span class="p_add">+		list_del_init(&amp;mw-&gt;fmr.fmr-&gt;list);</span>
 		__fmr_dma_unmap(r_xprt, seg);
 		rpcrdma_put_mw(r_xprt, seg-&gt;rl_mw);
 
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 42396a74405d..a68f03133df9 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -363,6 +363,7 @@</span> <span class="p_context"> is_mcounted_section_name(char const *const txtname)</span>
 		strcmp(&quot;.sched.text&quot;,    txtname) == 0 ||
 		strcmp(&quot;.spinlock.text&quot;, txtname) == 0 ||
 		strcmp(&quot;.irqentry.text&quot;, txtname) == 0 ||
<span class="p_add">+		strcmp(&quot;.softirqentry.text&quot;, txtname) == 0 ||</span>
 		strcmp(&quot;.kprobes.text&quot;, txtname) == 0 ||
 		strcmp(&quot;.text.unlikely&quot;, txtname) == 0;
 }
<span class="p_header">diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl</span>
<span class="p_header">index 96e2486a6fc4..2d48011bc362 100755</span>
<span class="p_header">--- a/scripts/recordmcount.pl</span>
<span class="p_header">+++ b/scripts/recordmcount.pl</span>
<span class="p_chunk">@@ -134,6 +134,7 @@</span> <span class="p_context"> my %text_sections = (</span>
      &quot;.sched.text&quot; =&gt; 1,
      &quot;.spinlock.text&quot; =&gt; 1,
      &quot;.irqentry.text&quot; =&gt; 1,
<span class="p_add">+     &quot;.softirqentry.text&quot; =&gt; 1,</span>
      &quot;.kprobes.text&quot; =&gt; 1,
      &quot;.text.unlikely&quot; =&gt; 1,
 );
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 56fefbd85782..ed62748a6d55 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> enum {</span>
 	CXT_FIXUP_HP_530,
 	CXT_FIXUP_CAP_MIX_AMP_5047,
 	CXT_FIXUP_MUTE_LED_EAPD,
<span class="p_add">+	CXT_FIXUP_HP_SPECTRE,</span>
 };
 
 /* for hda_fixup_thinkpad_acpi() */
<span class="p_chunk">@@ -765,6 +766,14 @@</span> <span class="p_context"> static const struct hda_fixup cxt_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cxt_fixup_mute_led_eapd,
 	},
<span class="p_add">+	[CXT_FIXUP_HP_SPECTRE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			/* enable NID 0x1d for the speaker on top */</span>
<span class="p_add">+			{ 0x1d, 0x91170111 },</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk cxt5045_fixups[] = {
<span class="p_chunk">@@ -814,6 +823,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0543, &quot;Acer Aspire One 522&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054c, &quot;Acer Aspire 3830TG&quot;, CXT_FIXUP_ASPIRE_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054f, &quot;Acer Aspire 4830T&quot;, CXT_FIXUP_ASPIRE_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),</span>
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
 	SND_PCI_QUIRK(0x152d, 0x0833, &quot;OLPC XO-1.5&quot;, CXT_FIXUP_OLPC_XO),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Lenovo T400&quot;, CXT_PINCFG_LENOVO_TP410),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index eaee626ab185..b1fa50aed888 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5790,6 +5790,13 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{0x14, 0x90170110}, \
 	{0x15, 0x0221401f}
 
<span class="p_add">+#define ALC295_STANDARD_PINS \</span>
<span class="p_add">+	{0x12, 0xb7a60130}, \</span>
<span class="p_add">+	{0x14, 0x90170110}, \</span>
<span class="p_add">+	{0x17, 0x21014020}, \</span>
<span class="p_add">+	{0x18, 0x21a19030}, \</span>
<span class="p_add">+	{0x21, 0x04211020}</span>
<span class="p_add">+</span>
 #define ALC298_STANDARD_PINS \
 	{0x12, 0x90a60130}, \
 	{0x21, 0x03211020}
<span class="p_chunk">@@ -5830,6 +5837,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170120},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x02011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170130},
 		{0x1b, 0x01014020},
 		{0x21, 0x0221103f}),
<span class="p_chunk">@@ -5895,6 +5906,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170120},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x12, 0xb7a60130},</span>
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x21, 0x02211020}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		ALC256_STANDARD_PINS),
 	SND_HDA_PIN_QUIRK(0x10ec0280, 0x103c, &quot;HP&quot;, ALC280_FIXUP_HP_GPIO4,
 		{0x12, 0x90a60130},
<span class="p_chunk">@@ -6005,6 +6020,8 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0293, 0x1028, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC292_STANDARD_PINS,
 		{0x13, 0x90a60140}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0295, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC295_STANDARD_PINS),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC298_STANDARD_PINS,
 		{0x17, 0x90170110}),
<span class="p_header">diff --git a/sound/soc/intel/skylake/skl.c b/sound/soc/intel/skylake/skl.c</span>
<span class="p_header">index 06d8c263c68f..d5a0327e8ff1 100644</span>
<span class="p_header">--- a/sound/soc/intel/skylake/skl.c</span>
<span class="p_header">+++ b/sound/soc/intel/skylake/skl.c</span>
<span class="p_chunk">@@ -659,8 +659,10 @@</span> <span class="p_context"> static int skl_probe(struct pci_dev *pci,</span>
 
 	skl-&gt;nhlt = skl_nhlt_init(bus-&gt;dev);
 
<span class="p_del">-	if (skl-&gt;nhlt == NULL)</span>
<span class="p_add">+	if (skl-&gt;nhlt == NULL) {</span>
<span class="p_add">+		err = -ENODEV;</span>
 		goto out_free;
<span class="p_add">+	}</span>
 
 	skl_nhlt_update_topology_bin(skl);
 
<span class="p_header">diff --git a/sound/soc/omap/omap-mcpdm.c b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">index b837265ac3e9..8d0d45d330e7 100644</span>
<span class="p_header">--- a/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">+++ b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_chunk">@@ -390,8 +390,8 @@</span> <span class="p_context"> static int omap_mcpdm_probe(struct snd_soc_dai *dai)</span>
 	pm_runtime_get_sync(mcpdm-&gt;dev);
 	omap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, 0x00);
 
<span class="p_del">-	ret = devm_request_irq(mcpdm-&gt;dev, mcpdm-&gt;irq, omap_mcpdm_irq_handler,</span>
<span class="p_del">-				0, &quot;McPDM&quot;, (void *)mcpdm);</span>
<span class="p_add">+	ret = request_irq(mcpdm-&gt;irq, omap_mcpdm_irq_handler, 0, &quot;McPDM&quot;,</span>
<span class="p_add">+			  (void *)mcpdm);</span>
 
 	pm_runtime_put_sync(mcpdm-&gt;dev);
 
<span class="p_chunk">@@ -416,6 +416,7 @@</span> <span class="p_context"> static int omap_mcpdm_remove(struct snd_soc_dai *dai)</span>
 {
 	struct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);
 
<span class="p_add">+	free_irq(mcpdm-&gt;irq, (void *)mcpdm);</span>
 	pm_runtime_disable(mcpdm-&gt;dev);
 
 	return 0;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



