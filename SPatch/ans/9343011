
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,1/3] powerpc: port 64 bits pgtable_cache to 32 bits - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,1/3] powerpc: port 64 bits pgtable_cache to 32 bits</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 21, 2016, 8:11 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;23a3735dcff5f26f55b8d6051d95c683b7f5947f.1474441302.git.christophe.leroy@c-s.fr&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9343011/mbox/"
   >mbox</a>
|
   <a href="/patch/9343011/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9343011/">/patch/9343011/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E1D55601C2 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 21 Sep 2016 08:14:29 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D06882A2A6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 21 Sep 2016 08:14:29 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C53842A2B1; Wed, 21 Sep 2016 08:14:29 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2D4222A2A6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 21 Sep 2016 08:14:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755940AbcIUINl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 21 Sep 2016 04:13:41 -0400
Received: from pegase1.c-s.fr ([93.17.236.30]:48858 &quot;EHLO pegase1.c-s.fr&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1754904AbcIUINR (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 21 Sep 2016 04:13:17 -0400
Received: from localhost (unknown [192.168.12.234])
	by localhost (Postfix) with ESMTP id 3sfC6r2hZtz9ttFF;
	Wed, 21 Sep 2016 10:13:08 +0200 (CEST)
X-Virus-Scanned: Debian amavisd-new at c-s.fr
Received: from pegase1.c-s.fr ([192.168.12.234])
	by localhost (pegase1.c-s.fr [192.168.12.234]) (amavisd-new,
	port 10024)
	with ESMTP id 8QcORQYBVyx6; Wed, 21 Sep 2016 10:13:08 +0200 (CEST)
Received: from messagerie.si.c-s.fr (messagerie.si.c-s.fr [192.168.25.192])
	by pegase1.c-s.fr (Postfix) with ESMTP id 3sfC6r0Fpjz9ttFC;
	Wed, 21 Sep 2016 10:13:08 +0200 (CEST)
Received: from localhost (localhost [127.0.0.1])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id 3C2758B78B;
	Wed, 21 Sep 2016 10:13:08 +0200 (CEST)
X-Virus-Scanned: amavisd-new at c-s.fr
Received: from messagerie.si.c-s.fr ([127.0.0.1])
	by localhost (messagerie.si.c-s.fr [127.0.0.1]) (amavisd-new,
	port 10023)
	with ESMTP id KXoWTH6ZOMnW; Wed, 21 Sep 2016 10:13:08 +0200 (CEST)
Received: from PO10863.localdomain (po10863.idsi0.si.c-s.fr [172.25.231.27])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id F04098B781;
	Wed, 21 Sep 2016 10:13:07 +0200 (CEST)
Received: by localhost.localdomain (Postfix, from userid 0)
	id EF6F81A2452; Wed, 21 Sep 2016 10:11:52 +0200 (CEST)
Message-Id: &lt;23a3735dcff5f26f55b8d6051d95c683b7f5947f.1474441302.git.christophe.leroy@c-s.fr&gt;
In-Reply-To: &lt;cover.1474441301.git.christophe.leroy@c-s.fr&gt;
References: &lt;cover.1474441301.git.christophe.leroy@c-s.fr&gt;
From: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;
Subject: [PATCH v3 1/3] powerpc: port 64 bits pgtable_cache to 32 bits
To: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;,
	Paul Mackerras &lt;paulus@samba.org&gt;, Michael Ellerman &lt;mpe@ellerman.id.au&gt;,
	Scott Wood &lt;oss@buserror.net&gt;
Cc: linux-kernel@vger.kernel.org, linuxppc-dev@lists.ozlabs.org
Date: Wed, 21 Sep 2016 10:11:52 +0200 (CEST)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a> - Sept. 21, 2016, 8:11 a.m.</div>
<pre class="content">
Today powerpc64 uses a set of pgtable_caches while powerpc32 uses
standard pages when using 4k pages and a single pgtable_cache
if using other size pages.

In preparation of implementing huge pages on the 8xx, this patch
replaces the specific powerpc32 handling by the 64 bits approach.

This is done by:
* moving 64 bits pgtable_cache_add() and pgtable_cache_init()
in a new file called init-common.c
* modifying pgtable_cache_init() to also handle the case
without PMD
* removing the 32 bits version of pgtable_cache_add() and
pgtable_cache_init()
* copying related header contents from 64 bits into both the
book3s/32 and nohash/32 header files

On the 8xx, the following cache sizes will be used:
* 4k pages mode:
- PGT_CACHE(10) for PGD
- PGT_CACHE(3) for 512k hugepage tables
* 16k pages mode:
- PGT_CACHE(6) for PGD
- PGT_CACHE(7) for 512k hugepage tables
- PGT_CACHE(3) for 8M hugepage tables
<span class="signed-off-by">
Signed-off-by: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;</span>
---
v2: in v1, hugepte_cache was wrongly replaced by PGT_CACHE(1).
This modification has been removed from v2.

v3:
- Not adding anymore MIN_HUGEPTE_SHIFT to 32 bits headers as
this constant was last used on kernel 2.6.32.
- Fixed PMD_TABLE_SIZE and PUD_TABLE_SIZE
- Removed unneccessary includes from init-common.c

 arch/powerpc/include/asm/book3s/32/pgalloc.h |  44 +++++++++--
 arch/powerpc/include/asm/book3s/32/pgtable.h |  40 +++++-----
 arch/powerpc/include/asm/book3s/64/pgtable.h |   3 -
 arch/powerpc/include/asm/nohash/32/pgalloc.h |  44 +++++++++--
 arch/powerpc/include/asm/nohash/32/pgtable.h |  42 +++++------
 arch/powerpc/include/asm/nohash/64/pgtable.h |   2 -
 arch/powerpc/include/asm/pgtable.h           |   2 +
 arch/powerpc/mm/Makefile                     |   3 +-
 arch/powerpc/mm/init-common.c                | 107 +++++++++++++++++++++++++++
 arch/powerpc/mm/init_64.c                    |  77 -------------------
 arch/powerpc/mm/pgtable_32.c                 |  37 ---------
 11 files changed, 227 insertions(+), 174 deletions(-)
 create mode 100644 arch/powerpc/mm/init-common.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/32/pgalloc.h b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_header">index 8e21bb4..d310546 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_chunk">@@ -2,14 +2,42 @@</span> <span class="p_context"></span>
 #define _ASM_POWERPC_BOOK3S_32_PGALLOC_H
 
 #include &lt;linux/threads.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
<span class="p_del">-/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="p_del">-#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Functions that deal with pagetables that could be at any level of</span>
<span class="p_add">+ * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="p_add">+ * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="p_add">+ * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="p_add">+ * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="p_add">+ * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The maximum index size needs to be big enough to allow any</span>
<span class="p_add">+ * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="p_add">+ * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="p_add">+ * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="p_add">+ * contain this value.  This value is also used as a mask, so it must</span>
<span class="p_add">+ * be one less than a power of two.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
 
 extern void __bad_pte(pmd_t *pmd);
 
<span class="p_del">-extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="p_del">-extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="p_add">+extern struct kmem_cache *pgtable_cache[];</span>
<span class="p_add">+#define PGT_CACHE(shift) ({				\</span>
<span class="p_add">+			BUG_ON(!(shift));		\</span>
<span class="p_add">+			pgtable_cache[(shift) - 1];	\</span>
<span class="p_add">+		})</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="p_add">+}</span>
 
 /*
  * We don&#39;t have any real pmd&#39;s, and this code never triggers because
<span class="p_chunk">@@ -68,8 +96,12 @@</span> <span class="p_context"> static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
 
 static inline void pgtable_free(void *table, unsigned index_size)
 {
<span class="p_del">-	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="p_del">-	free_page((unsigned long)table);</span>
<span class="p_add">+	if (!index_size) {</span>
<span class="p_add">+		free_page((unsigned long)table);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="p_add">+	}</span>
 }
 
 #define check_pgt_cache()	do { } while (0)
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/32/pgtable.h b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_header">index 6b8b2d5..388b052 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_chunk">@@ -8,6 +8,23 @@</span> <span class="p_context"></span>
 /* And here we include common definitions */
 #include &lt;asm/pte-common.h&gt;
 
<span class="p_add">+#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="p_add">+#define PMD_INDEX_SIZE	0</span>
<span class="p_add">+#define PUD_INDEX_SIZE	0</span>
<span class="p_add">+#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PMD_TABLE_SIZE	0</span>
<span class="p_add">+#define PUD_TABLE_SIZE	0</span>
<span class="p_add">+#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+</span>
 /*
  * The normal case is that PTEs are 32-bits and we have a 1-page
  * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus
<span class="p_chunk">@@ -19,14 +36,10 @@</span> <span class="p_context"></span>
  * -Matt
  */
 /* PGDIR_SHIFT determines what a top-level page table entry can map */
<span class="p_del">-#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="p_add">+#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
 #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
<span class="p_del">-#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PTRS_PER_PMD	1</span>
<span class="p_del">-#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_del">-</span>
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 /*
  * This is the bottom of the PKMAP area with HIGHMEM or an arbitrary
<span class="p_chunk">@@ -82,12 +95,8 @@</span> <span class="p_context"></span>
 
 extern unsigned long ioremap_bot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * entries per page directory level: our page-table tree is two-level, so</span>
<span class="p_del">- * we don&#39;t really have any PMD directory.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_add">+/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="p_add">+#define PGD_MASKED_BITS		0</span>
 
 #define pte_ERROR(e) \
 	pr_err(&quot;%s:%d: bad pte %llx.\n&quot;, __FILE__, __LINE__, \
<span class="p_chunk">@@ -283,15 +292,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(struct mm_struct *mm,</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })
 #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })
 
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-/*</span>
<span class="p_del">- * No page table caches to initialise</span>
<span class="p_del">- */</span>
<span class="p_del">-#define pgtable_cache_init()	do { } while (0)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,
 		      pmd_t **pmdp);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/pgtable.h b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">index 9fd77f8..0a46a5f 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_chunk">@@ -789,9 +789,6 @@</span> <span class="p_context"> extern struct page *pgd_page(pgd_t pgd);</span>
 #define pgd_ERROR(e) \
 	pr_err(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))
 
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-</span>
 static inline int map_kernel_page(unsigned long ea, unsigned long pa,
 				  unsigned long flags)
 {
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/32/pgalloc.h b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_header">index 76d6b9e..6331392 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_chunk">@@ -2,14 +2,42 @@</span> <span class="p_context"></span>
 #define _ASM_POWERPC_PGALLOC_32_H
 
 #include &lt;linux/threads.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
<span class="p_del">-/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="p_del">-#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Functions that deal with pagetables that could be at any level of</span>
<span class="p_add">+ * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="p_add">+ * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="p_add">+ * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="p_add">+ * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="p_add">+ * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The maximum index size needs to be big enough to allow any</span>
<span class="p_add">+ * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="p_add">+ * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="p_add">+ * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="p_add">+ * contain this value.  This value is also used as a mask, so it must</span>
<span class="p_add">+ * be one less than a power of two.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
 
 extern void __bad_pte(pmd_t *pmd);
 
<span class="p_del">-extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="p_del">-extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="p_add">+extern struct kmem_cache *pgtable_cache[];</span>
<span class="p_add">+#define PGT_CACHE(shift) ({				\</span>
<span class="p_add">+			BUG_ON(!(shift));		\</span>
<span class="p_add">+			pgtable_cache[(shift) - 1];	\</span>
<span class="p_add">+		})</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="p_add">+}</span>
 
 /*
  * We don&#39;t have any real pmd&#39;s, and this code never triggers because
<span class="p_chunk">@@ -68,8 +96,12 @@</span> <span class="p_context"> static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
 
 static inline void pgtable_free(void *table, unsigned index_size)
 {
<span class="p_del">-	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="p_del">-	free_page((unsigned long)table);</span>
<span class="p_add">+	if (!index_size) {</span>
<span class="p_add">+		free_page((unsigned long)table);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="p_add">+	}</span>
 }
 
 #define check_pgt_cache()	do { } while (0)
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/32/pgtable.h b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_header">index c219ef7..7bd916e 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_chunk">@@ -16,6 +16,23 @@</span> <span class="p_context"> extern int icache_44x_need_flush;</span>
 
 #endif /* __ASSEMBLY__ */
 
<span class="p_add">+#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="p_add">+#define PMD_INDEX_SIZE	0</span>
<span class="p_add">+#define PUD_INDEX_SIZE	0</span>
<span class="p_add">+#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PMD_TABLE_SIZE	0</span>
<span class="p_add">+#define PUD_TABLE_SIZE	0</span>
<span class="p_add">+#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+</span>
 /*
  * The normal case is that PTEs are 32-bits and we have a 1-page
  * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus
<span class="p_chunk">@@ -27,22 +44,12 @@</span> <span class="p_context"> extern int icache_44x_need_flush;</span>
  * -Matt
  */
 /* PGDIR_SHIFT determines what a top-level page table entry can map */
<span class="p_del">-#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="p_add">+#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
 #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
<span class="p_del">-/*</span>
<span class="p_del">- * entries per page directory level: our page-table tree is two-level, so</span>
<span class="p_del">- * we don&#39;t really have any PMD directory.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_del">-#endif	/* __ASSEMBLY__ */</span>
<span class="p_del">-</span>
<span class="p_del">-#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PTRS_PER_PMD	1</span>
<span class="p_del">-#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_add">+/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="p_add">+#define PGD_MASKED_BITS		0</span>
 
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 #define FIRST_USER_ADDRESS	0UL
<span class="p_chunk">@@ -328,15 +335,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(struct mm_struct *mm,</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })
 #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })
 
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-/*</span>
<span class="p_del">- * No page table caches to initialise</span>
<span class="p_del">- */</span>
<span class="p_del">-#define pgtable_cache_init()	do { } while (0)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,
 		      pmd_t **pmdp);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/64/pgtable.h b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_header">index 653a183..619018a 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_chunk">@@ -358,8 +358,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(struct mm_struct *mm,</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val((pte)) })
 #define __swp_entry_to_pte(x)		__pte((x).val)
 
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
 extern int map_kernel_page(unsigned long ea, unsigned long pa,
 			   unsigned long flags);
 extern int __meminit vmemmap_create_mapping(unsigned long start,
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgtable.h b/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_header">index 9bd87f2..dd01212 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -78,6 +78,8 @@</span> <span class="p_context"> static inline pte_t *find_linux_pte_or_hugepte(pgd_t *pgdir, unsigned long ea,</span>
 
 unsigned long vmalloc_to_phys(void *vmalloc_addr);
 
<span class="p_add">+void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_add">+void pgtable_cache_init(void);</span>
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_POWERPC_PGTABLE_H */
<span class="p_header">diff --git a/arch/powerpc/mm/Makefile b/arch/powerpc/mm/Makefile</span>
<span class="p_header">index 1a4e570..e8a86d2 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/mm/Makefile</span>
<span class="p_chunk">@@ -7,7 +7,8 @@</span> <span class="p_context"> subdir-ccflags-$(CONFIG_PPC_WERROR) := -Werror</span>
 ccflags-$(CONFIG_PPC64)	:= $(NO_MINIMAL_TOC)
 
 obj-y				:= fault.o mem.o pgtable.o mmap.o \
<span class="p_del">-				   init_$(BITS).o pgtable_$(BITS).o</span>
<span class="p_add">+				   init_$(BITS).o pgtable_$(BITS).o \</span>
<span class="p_add">+				   init-common.o</span>
 obj-$(CONFIG_PPC_MMU_NOHASH)	+= mmu_context_nohash.o tlb_nohash.o \
 				   tlb_nohash_low.o
 obj-$(CONFIG_PPC_BOOK3E)	+= tlb_low_$(BITS)e.o
<span class="p_header">diff --git a/arch/powerpc/mm/init-common.c b/arch/powerpc/mm/init-common.c</span>
new file mode 100644
<span class="p_header">index 0000000..a175cd8</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/mm/init-common.c</span>
<span class="p_chunk">@@ -0,0 +1,107 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  PowerPC version</span>
<span class="p_add">+ *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)</span>
<span class="p_add">+ *  and Cort Dougan (PReP) (cort@cs.nmt.edu)</span>
<span class="p_add">+ *    Copyright (C) 1996 Paul Mackerras</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Derived from &quot;arch/i386/mm/init.c&quot;</span>
<span class="p_add">+ *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Dave Engebretsen &lt;engebret@us.ibm.com&gt;</span>
<span class="p_add">+ *      Rework for PPC64 port.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *  modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *  as published by the Free Software Foundation; either version</span>
<span class="p_add">+ *  2 of the License, or (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#undef DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgalloc.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void pgd_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pud_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmd_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="p_add">+ * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="p_add">+ * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="p_add">+ * everything else.  Caches created by this function are used for all</span>
<span class="p_add">+ * the higher level pagetables, and for hugepage pagetables.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *name;</span>
<span class="p_add">+	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="p_add">+	unsigned long align = table_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="p_add">+	 * the index size in the low bits.  Table alignment must be</span>
<span class="p_add">+	 * big enough to fit it.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="p_add">+	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="p_add">+	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="p_add">+	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="p_add">+				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="p_add">+	struct kmem_cache *new;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="p_add">+	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="p_add">+	 * constant expression, so so much for that. */</span>
<span class="p_add">+	BUG_ON(!is_power_of_2(minalign));</span>
<span class="p_add">+	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PGT_CACHE(shift))</span>
<span class="p_add">+		return; /* Already have a cache of this size */</span>
<span class="p_add">+</span>
<span class="p_add">+	align = max_t(unsigned long, align, minalign);</span>
<span class="p_add">+	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="p_add">+	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="p_add">+	kfree(name);</span>
<span class="p_add">+	pgtable_cache[shift - 1] = new;</span>
<span class="p_add">+	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void pgtable_cache_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="p_add">+		pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="p_add">+	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="p_add">+	 * on book3s 64</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_add">+		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!PGT_CACHE(PGD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pgd cache&quot;);</span>
<span class="p_add">+	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pmd pgtable caches&quot;);</span>
<span class="p_add">+	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="p_header">index 16ada1e..a000c35 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_64.c</span>
<span class="p_chunk">@@ -80,83 +80,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(memstart_addr);</span>
 phys_addr_t kernstart_addr;
 EXPORT_SYMBOL_GPL(kernstart_addr);
 
<span class="p_del">-static void pgd_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pud_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmd_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="p_del">- * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="p_del">- * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="p_del">- * everything else.  Caches created by this function are used for all</span>
<span class="p_del">- * the higher level pagetables, and for hugepage pagetables.</span>
<span class="p_del">- */</span>
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="p_del">-{</span>
<span class="p_del">-	char *name;</span>
<span class="p_del">-	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="p_del">-	unsigned long align = table_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="p_del">-	 * the index size in the low bits.  Table alignment must be</span>
<span class="p_del">-	 * big enough to fit it.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="p_del">-	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="p_del">-	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="p_del">-	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="p_del">-				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="p_del">-	struct kmem_cache *new;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="p_del">-	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="p_del">-	 * constant expression, so so much for that. */</span>
<span class="p_del">-	BUG_ON(!is_power_of_2(minalign));</span>
<span class="p_del">-	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (PGT_CACHE(shift))</span>
<span class="p_del">-		return; /* Already have a cache of this size */</span>
<span class="p_del">-</span>
<span class="p_del">-	align = max_t(unsigned long, align, minalign);</span>
<span class="p_del">-	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="p_del">-	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="p_del">-	kfree(name);</span>
<span class="p_del">-	pgtable_cache[shift - 1] = new;</span>
<span class="p_del">-	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-void pgtable_cache_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="p_del">-	pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="p_del">-	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="p_del">-	 * on book3s 64</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_del">-		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!PGT_CACHE(PGD_INDEX_SIZE) || !PGT_CACHE(PMD_CACHE_INDEX))</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="p_del">-	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_SPARSEMEM_VMEMMAP
 /*
  * Given an address within the vmemmap, determine the pfn of the page that
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">index 0ae0572..a65c0b4 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -42,43 +42,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */</span>
 
 extern char etext[], _stext[], _sinittext[], _einittext[];
 
<span class="p_del">-#define PGDIR_ORDER	(32 + PGD_T_LOG2 - PGDIR_SHIFT)</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-static struct kmem_cache *pgtable_cache;</span>
<span class="p_del">-</span>
<span class="p_del">-void pgtable_cache_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgtable_cache = kmem_cache_create(&quot;PGDIR cache&quot;, 1 &lt;&lt; PGDIR_ORDER,</span>
<span class="p_del">-					  1 &lt;&lt; PGDIR_ORDER, 0, NULL);</span>
<span class="p_del">-	if (pgtable_cache == NULL)</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* pgdir take page or two with 4K pages and a page fraction otherwise */</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-	ret = kmem_cache_alloc(pgtable_cache, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="p_del">-			PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-	kmem_cache_free(pgtable_cache, (void *)pgd);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 __ref pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
 	pte_t *pte;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



