
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,2/3] MIPS: Setup an instruction emulation in VDSO protected page instead of user stack - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,2/3] MIPS: Setup an instruction emulation in VDSO protected page instead of user stack</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=66191">Leonid Yegoshin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 5, 2015, 11:49 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150805234928.20722.61455.stgit@ubuntu-yegoshin&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6955021/mbox/"
   >mbox</a>
|
   <a href="/patch/6955021/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6955021/">/patch/6955021/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 9E9AD9F358
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Aug 2015 23:49:54 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 871E420660
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Aug 2015 23:49:52 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 669A820607
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Aug 2015 23:49:50 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754084AbbHEXti (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 5 Aug 2015 19:49:38 -0400
Received: from mailapp01.imgtec.com ([195.59.15.196]:22332 &quot;EHLO
	mailapp01.imgtec.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753934AbbHEXte (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 5 Aug 2015 19:49:34 -0400
Received: from KLMAIL01.kl.imgtec.org (unknown [192.168.5.35])
	by Websense Email Security Gateway with ESMTPS id D9F626F95C4DB;
	Thu,  6 Aug 2015 00:49:26 +0100 (IST)
Received: from hhmail02.hh.imgtec.org (10.100.10.20) by
	KLMAIL01.kl.imgtec.org
	(192.168.5.35) with Microsoft SMTP Server (TLS) id 14.3.195.1;
	Thu, 6 Aug 2015 00:49:31 +0100
Received: from BAMAIL02.ba.imgtec.org (10.20.40.28) by hhmail02.hh.imgtec.org
	(10.100.10.20) with Microsoft SMTP Server (TLS) id 14.3.235.1;
	Thu, 6 Aug 2015 00:49:30 +0100
Received: from [127.0.1.1] (10.20.3.79) by bamail02.ba.imgtec.org
	(10.20.40.28) with Microsoft SMTP Server (TLS) id 14.3.174.1;
	Wed, 5 Aug 2015 16:49:27 -0700
Subject: [PATCH v4 2/3] MIPS: Setup an instruction emulation in VDSO
	protected page instead of user stack
From: Leonid Yegoshin &lt;Leonid.Yegoshin@imgtec.com&gt;
To: &lt;daniel.sanders@imgtec.com&gt;, &lt;linux-mips@linux-mips.org&gt;,
	&lt;cernekee@gmail.com&gt;, &lt;Zubair.Kakakhel@imgtec.com&gt;,
	&lt;geert+renesas@glider.be&gt;, &lt;david.daney@cavium.com&gt;,
	&lt;peterz@infradead.org&gt;, &lt;heiko.carstens@de.ibm.com&gt;,
	&lt;paul.gortmaker@windriver.com&gt;, &lt;behanw@converseincode.com&gt;,
	&lt;macro@linux-mips.org&gt;, &lt;cl@linux.com&gt;, &lt;pkarat@mvista.com&gt;,
	&lt;linux@roeck-us.net&gt;, &lt;tkhai@yandex.ru&gt;, &lt;james.hogan@imgtec.com&gt;,
	&lt;alexinbeijing@gmail.com&gt;, &lt;rusty@rustcorp.com.au&gt;,
	&lt;Steven.Hill@imgtec.com&gt;, &lt;lars.persson@axis.com&gt;,
	&lt;aleksey.makarov@auriga.com&gt;, &lt;paul.burton@imgtec.com&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;ralf@linux-mips.org&gt;,
	&lt;luto@amacapital.net&gt;, &lt;dahi@linux.vnet.ibm.com&gt;,
	&lt;markos.chandras@imgtec.com&gt;, &lt;eunb.song@samsung.com&gt;, &lt;kumba@gentoo.org&gt;
Date: Wed, 5 Aug 2015 16:49:28 -0700
Message-ID: &lt;20150805234928.20722.61455.stgit@ubuntu-yegoshin&gt;
In-Reply-To: &lt;20150805234348.20722.71740.stgit@ubuntu-yegoshin&gt;
References: &lt;20150805234348.20722.71740.stgit@ubuntu-yegoshin&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [10.20.3.79]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=66191">Leonid Yegoshin</a> - Aug. 5, 2015, 11:49 p.m.</div>
<pre class="content">
Historically, during FPU emulation MIPS runs live BD-slot instruction in stack.
This is needed because it was the only way to correctly handle branch
exceptions with unknown COP2 or ASE instructions in BD-slot. Now there is
an eXecuteInhibit feature and it is desirable to protect stack from execution
for security reasons.
This patch moves FPU emulation from stack area to VDSO-located page which is set
write-protected for application access. VDSO page itself is now per-thread and
it&#39;s addresses and offsets are stored in thread_info.
Small stack of emulation blocks is supported because nested traps are possible
in MIPS32/64 R6 emulation mix with FPU emulation.
Signal happend during run in emulation block is handled properly - EPC is
changed to before an emulated jump or to target address, depending from point of
signal.

Explanation of problem (current state before patch):

If I set eXecute-disabled stack in ELF binary initialisation then GLIBC ignores
it and may change stack protection at library load. If this library has
eXecute-disabled stack then anything is OK, but if this section (PT_GNU_STACK)
is just missed as usual, then GLIBC applies it&#39;s own default == eXecute-enabled
stack.
So, ssh_keygen is built explicitly with eXecute-disabled stack. But GLIBC
ignores it and set stack executable. And because of that - anything works,
FPU emulation and hacker tools.
However, if I use all *.SO libraries with eXecute-disabled stack in PT_GNU_STACK
section then GLIBC keeps stack non-executable but things fails at FPU emulation
later.

Here are two issues which are bind together and to solve an incorrect
behaviour of GLIBC (ignoring X ssh-keygen intention) the split of both issues
is needed. So, I did a kernel emulation protected and out of stack.
<span class="signed-off-by">
Signed-off-by: Leonid Yegoshin &lt;Leonid.Yegoshin@imgtec.com&gt;</span>
---
 arch/mips/include/asm/fpu_emulator.h  |    2 
 arch/mips/include/asm/mmu.h           |    3 +
 arch/mips/include/asm/processor.h     |    2 
 arch/mips/include/asm/switch_to.h     |   14 +++
 arch/mips/include/asm/thread_info.h   |    3 +
 arch/mips/include/asm/tlbmisc.h       |    1 
 arch/mips/include/asm/vdso.h          |    3 +
 arch/mips/kernel/mips-r2-to-r6-emul.c |   10 +-
 arch/mips/kernel/process.c            |    7 ++
 arch/mips/kernel/signal.c             |    4 +
 arch/mips/kernel/vdso.c               |   44 +++++++++
 arch/mips/math-emu/cp1emu.c           |    8 +-
 arch/mips/math-emu/dsemul.c           |  154 +++++++++++++++++++++++++++------
 arch/mips/mm/fault.c                  |    5 +
 arch/mips/mm/tlb-r4k.c                |   42 +++++++++
 15 files changed, 267 insertions(+), 35 deletions(-)


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/mips/include/asm/fpu_emulator.h b/arch/mips/include/asm/fpu_emulator.h</span>
<span class="p_header">index 2f021cdfba4f..0c8d1191fa44 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/fpu_emulator.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/fpu_emulator.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> do {									\</span>
 #endif /* CONFIG_DEBUG_FS */
 
 extern int mips_dsemul(struct pt_regs *regs, mips_instruction ir,
<span class="p_del">-	unsigned long cpc);</span>
<span class="p_add">+	unsigned long cpc, unsigned long bpc, unsigned long r31);</span>
 extern int do_dsemulret(struct pt_regs *xcp);
 extern int fpu_emulator_cop1Handler(struct pt_regs *xcp,
 				    struct mips_fpu_struct *ctx, int has_fpu,
<span class="p_header">diff --git a/arch/mips/include/asm/mmu.h b/arch/mips/include/asm/mmu.h</span>
<span class="p_header">index 1afa1f986df8..8d2ce4d34005 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mmu.h</span>
<span class="p_chunk">@@ -5,7 +5,10 @@</span> <span class="p_context"></span>
 
 typedef struct {
 	unsigned long asid[NR_CPUS];
<span class="p_add">+	unsigned long vdso_asid[NR_CPUS];</span>
<span class="p_add">+	struct page   *vdso_page[NR_CPUS];</span>
 	void *vdso;
<span class="p_add">+	struct vm_area_struct   *vdso_vma;</span>
 	atomic_t fp_mode_switching;
 } mm_context_t;
 
<span class="p_header">diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h</span>
<span class="p_header">index 59ee6dcf6eed..cfe2e686bf9e 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/processor.h</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> extern unsigned int vced_count, vcei_count;</span>
  * A special page (the vdso) is mapped into all processes at the very
  * top of the virtual memory space.
  */
<span class="p_del">-#define SPECIAL_PAGES_SIZE PAGE_SIZE</span>
<span class="p_add">+#define SPECIAL_PAGES_SIZE (PAGE_SIZE * 2)</span>
 
 #ifdef CONFIG_32BIT
 #ifdef CONFIG_KVM_GUEST
<span class="p_header">diff --git a/arch/mips/include/asm/switch_to.h b/arch/mips/include/asm/switch_to.h</span>
<span class="p_header">index 9733cd0266e4..d78469c68eef 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/dsp.h&gt;
 #include &lt;asm/cop2.h&gt;
 #include &lt;asm/msa.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 struct task_struct;
 
<span class="p_chunk">@@ -83,6 +84,18 @@</span> <span class="p_context"> do {	if (cpu_has_rw_llb) {						\</span>
 	}								\
 } while (0)
 
<span class="p_add">+static inline void flush_vdso_page(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = raw_smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;mm &amp;&amp; cpu_context(cpu, current-&gt;mm) &amp;&amp;</span>
<span class="p_add">+	    (current-&gt;mm-&gt;context.vdso_page[cpu] != current_thread_info()-&gt;vdso_page) &amp;&amp;</span>
<span class="p_add">+	    (current-&gt;mm-&gt;context.vdso_asid[cpu] == cpu_asid(cpu, current-&gt;mm))) {</span>
<span class="p_add">+		local_flush_tlb_page(current-&gt;mm-&gt;mmap, (unsigned long)current-&gt;mm-&gt;context.vdso);</span>
<span class="p_add">+		current-&gt;mm-&gt;context.vdso_asid[cpu] = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * For newly created kernel threads switch_to() will return to
  * ret_from_kernel_thread, newly created user threads to ret_from_fork.
<span class="p_chunk">@@ -117,6 +130,7 @@</span> <span class="p_context"> do {									\</span>
 		__fpsave = FP_SAVE_VECTOR;				\
 	if (cpu_has_userlocal)						\
 		write_c0_userlocal(task_thread_info(next)-&gt;tp_value);	\
<span class="p_add">+	flush_vdso_page();                                              \</span>
 	__restore_watch();						\
 	disable_msa();							\
 	(last) = resume(prev, next, task_thread_info(next), __fpsave);	\
<span class="p_header">diff --git a/arch/mips/include/asm/thread_info.h b/arch/mips/include/asm/thread_info.h</span>
<span class="p_header">index e309d8fcb516..e449b4ddb14f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/thread_info.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/thread_info.h</span>
<span class="p_chunk">@@ -33,6 +33,8 @@</span> <span class="p_context"> struct thread_info {</span>
 						 * 0x7fffffff for user-thead
 						 * 0xffffffff for kernel-thread
 						 */
<span class="p_add">+	unsigned long           vdso_offset;</span>
<span class="p_add">+	struct page             *vdso_page;</span>
 	struct pt_regs		*regs;
 	long			syscall;	/* syscall number */
 };
<span class="p_chunk">@@ -47,6 +49,7 @@</span> <span class="p_context"> struct thread_info {</span>
 	.cpu		= 0,			\
 	.preempt_count	= INIT_PREEMPT_COUNT,	\
 	.addr_limit	= KERNEL_DS,		\
<span class="p_add">+	.vdso_page      = NULL,                 \</span>
 }
 
 #define init_thread_info	(init_thread_union.thread_info)
<span class="p_header">diff --git a/arch/mips/include/asm/tlbmisc.h b/arch/mips/include/asm/tlbmisc.h</span>
<span class="p_header">index 3a452282cba0..abd7bf6ac2c6 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/tlbmisc.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/tlbmisc.h</span>
<span class="p_chunk">@@ -6,5 +6,6 @@</span> <span class="p_context"></span>
  */
 extern void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 	unsigned long entryhi, unsigned long pagemask);
<span class="p_add">+int install_vdso_tlb(void);</span>
 
 #endif /* __ASM_TLBMISC_H */
<span class="p_header">diff --git a/arch/mips/include/asm/vdso.h b/arch/mips/include/asm/vdso.h</span>
<span class="p_header">index cca56aa40ff4..77056fc38df6 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/vdso.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/vdso.h</span>
<span class="p_chunk">@@ -11,6 +11,9 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 
<span class="p_add">+void mips_thread_vdso(struct thread_info *ti);</span>
<span class="p_add">+void arch_release_thread_info(struct thread_info *info);</span>
<span class="p_add">+void vdso_epc_adjust(struct pt_regs *xcp);</span>
 
 #ifdef CONFIG_32BIT
 struct mips_vdso {
<span class="p_header">diff --git a/arch/mips/kernel/mips-r2-to-r6-emul.c b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">index f2977f00911b..040842a3aec4 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_chunk">@@ -245,6 +245,7 @@</span> <span class="p_context"> static int jr_func(struct pt_regs *regs, u32 ir)</span>
 {
 	int err;
 	unsigned long cepc, epc, nepc;
<span class="p_add">+	unsigned long r31;</span>
 	u32 nir;
 
 	if (delay_slot(regs))
<span class="p_chunk">@@ -255,6 +256,7 @@</span> <span class="p_context"> static int jr_func(struct pt_regs *regs, u32 ir)</span>
 	/* Roll back to the reserved R2 JR instruction */
 	regs-&gt;cp0_epc -= 4;
 	epc = regs-&gt;cp0_epc;
<span class="p_add">+	r31 = regs-&gt;regs[31];</span>
 	err = __compute_return_epc(regs);
 
 	if (err &lt; 0)
<span class="p_chunk">@@ -281,7 +283,7 @@</span> <span class="p_context"> static int jr_func(struct pt_regs *regs, u32 ir)</span>
 		err = mipsr6_emul(regs, nir);
 		if (err &gt; 0) {
 			regs-&gt;cp0_epc = nepc;
<span class="p_del">-			err = mips_dsemul(regs, nir, cepc);</span>
<span class="p_add">+			err = mips_dsemul(regs, nir, cepc, epc, r31);</span>
 			if (err == SIGILL)
 				err = SIGEMT;
 			MIPS_R2_STATS(dsemul);
<span class="p_chunk">@@ -1031,7 +1033,7 @@</span> <span class="p_context"> repeat:</span>
 			if (nir) {
 				err = mipsr6_emul(regs, nir);
 				if (err &gt; 0) {
<span class="p_del">-					err = mips_dsemul(regs, nir, cpc);</span>
<span class="p_add">+					err = mips_dsemul(regs, nir, cpc, epc, r31);</span>
 					if (err == SIGILL)
 						err = SIGEMT;
 					MIPS_R2_STATS(dsemul);
<span class="p_chunk">@@ -1080,7 +1082,7 @@</span> <span class="p_context"> repeat:</span>
 			if (nir) {
 				err = mipsr6_emul(regs, nir);
 				if (err &gt; 0) {
<span class="p_del">-					err = mips_dsemul(regs, nir, cpc);</span>
<span class="p_add">+					err = mips_dsemul(regs, nir, cpc, epc, r31);</span>
 					if (err == SIGILL)
 						err = SIGEMT;
 					MIPS_R2_STATS(dsemul);
<span class="p_chunk">@@ -1147,7 +1149,7 @@</span> <span class="p_context"> repeat:</span>
 		if (nir) {
 			err = mipsr6_emul(regs, nir);
 			if (err &gt; 0) {
<span class="p_del">-				err = mips_dsemul(regs, nir, cpc);</span>
<span class="p_add">+				err = mips_dsemul(regs, nir, cpc, epc, r31);</span>
 				if (err == SIGILL)
 					err = SIGEMT;
 				MIPS_R2_STATS(dsemul);
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index f2975d4d1e44..cbbb4430cf1d 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/inst.h&gt;
 #include &lt;asm/stacktrace.h&gt;
 #include &lt;asm/irq_regs.h&gt;
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
 
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
<span class="p_chunk">@@ -61,6 +62,8 @@</span> <span class="p_context"> void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)</span>
 {
 	unsigned long status;
 
<span class="p_add">+	mips_thread_vdso(current_thread_info());</span>
<span class="p_add">+</span>
 	/* New thread loses kernel privileges. */
 	status = regs-&gt;cp0_status &amp; ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
 	status |= KU_USER;
<span class="p_chunk">@@ -77,6 +80,7 @@</span> <span class="p_context"> void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)</span>
 
 void exit_thread(void)
 {
<span class="p_add">+	arch_release_thread_info(current_thread_info());</span>
 }
 
 void flush_thread(void)
<span class="p_chunk">@@ -120,6 +124,9 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long usp,</span>
 
 	childksp = (unsigned long)task_stack_page(p) + THREAD_SIZE - 32;
 
<span class="p_add">+	ti-&gt;vdso_page = NULL;</span>
<span class="p_add">+	mips_thread_vdso(ti);</span>
<span class="p_add">+</span>
 	/* set up new TSS. */
 	childregs = (struct pt_regs *) childksp - 1;
 	/*  Put the stack after the struct pt_regs.  */
<span class="p_header">diff --git a/arch/mips/kernel/signal.c b/arch/mips/kernel/signal.c</span>
<span class="p_header">index 2fec67bfc457..e88e164da5bb 100644</span>
<span class="p_header">--- a/arch/mips/kernel/signal.c</span>
<span class="p_header">+++ b/arch/mips/kernel/signal.c</span>
<span class="p_chunk">@@ -800,6 +800,10 @@</span> <span class="p_context"> static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
 		regs-&gt;regs[0] = 0;		/* Don&#39;t deal with this again.	*/
 	}
 
<span class="p_add">+	/* adjust emulation stack if signal happens during emulation */</span>
<span class="p_add">+	if (current_thread_info()-&gt;vdso_page)</span>
<span class="p_add">+		vdso_epc_adjust(regs);</span>
<span class="p_add">+</span>
 	if (sig_uses_siginfo(&amp;ksig-&gt;ka))
 		ret = abi-&gt;setup_rt_frame(vdso + abi-&gt;rt_signal_return_offset,
 					  ksig, regs, oldset);
<span class="p_header">diff --git a/arch/mips/kernel/vdso.c b/arch/mips/kernel/vdso.c</span>
<span class="p_header">index ed2a278722a9..ecc884e051a4 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vdso.c</span>
<span class="p_header">+++ b/arch/mips/kernel/vdso.c</span>
<span class="p_chunk">@@ -21,6 +21,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/vdso.h&gt;
 #include &lt;asm/uasm.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
 
 /*
  * Including &lt;asm/unistd.h&gt; would give use the 64-bit syscall numbers ...
<span class="p_chunk">@@ -101,14 +103,18 @@</span> <span class="p_context"> int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)</span>
 
 	ret = install_special_mapping(mm, addr, PAGE_SIZE,
 				      VM_READ|VM_EXEC|
<span class="p_del">-				      VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,</span>
<span class="p_add">+				      VM_MAYREAD|VM_MAYEXEC,</span>
 				      &amp;vdso_page);
 
 	if (ret)
 		goto up_fail;
 
 	mm-&gt;context.vdso = (void *)addr;
<span class="p_add">+	/* if cache aliasing - use a different cache flush later */</span>
<span class="p_add">+	if (cpu_has_rixi &amp;&amp; cpu_has_dc_aliases)</span>
<span class="p_add">+		mm-&gt;context.vdso_vma = find_vma(mm,addr);</span>
 
<span class="p_add">+	mips_thread_vdso(current_thread_info());</span>
 up_fail:
 	up_write(&amp;mm-&gt;mmap_sem);
 	return ret;
<span class="p_chunk">@@ -120,3 +126,39 @@</span> <span class="p_context"> const char *arch_vma_name(struct vm_area_struct *vma)</span>
 		return &quot;[vdso]&quot;;
 	return NULL;
 }
<span class="p_add">+</span>
<span class="p_add">+void mips_thread_vdso(struct thread_info *ti)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *vdso;</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpu_has_rixi &amp;&amp; ti-&gt;task-&gt;mm &amp;&amp; !ti-&gt;vdso_page) {</span>
<span class="p_add">+		vdso = alloc_page(GFP_USER);</span>
<span class="p_add">+		if (!vdso)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		ti-&gt;vdso_page = vdso;</span>
<span class="p_add">+		ti-&gt;vdso_offset = PAGE_SIZE;</span>
<span class="p_add">+		addr = (unsigned long)page_address(vdso);</span>
<span class="p_add">+		copy_page((void *)addr, (void *)page_address(vdso_page));</span>
<span class="p_add">+		if (!cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+			flush_data_cache_page(addr);</span>
<span class="p_add">+		/* any vma in mmap is used, just to get ASIDs back from mm */</span>
<span class="p_add">+		local_flush_tlb_page(ti-&gt;task-&gt;mm-&gt;mmap,</span>
<span class="p_add">+				    (unsigned long)ti-&gt;task-&gt;mm-&gt;context.vdso);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_release_thread_info(struct thread_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (info-&gt;vdso_page) {</span>
<span class="p_add">+		if (info-&gt;task-&gt;mm) {</span>
<span class="p_add">+			preempt_disable();</span>
<span class="p_add">+			/* any vma in mmap is used, just to get ASIDs */</span>
<span class="p_add">+			local_flush_tlb_page(info-&gt;task-&gt;mm-&gt;mmap,(unsigned long)info-&gt;task-&gt;mm-&gt;context.vdso);</span>
<span class="p_add">+			info-&gt;task-&gt;mm-&gt;context.vdso_asid[smp_processor_id()] = 0;</span>
<span class="p_add">+			preempt_enable();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		__free_page(info-&gt;vdso_page);</span>
<span class="p_add">+		info-&gt;vdso_page = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 8a5b0eb4ddef..ba91d4d01406 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -973,6 +973,8 @@</span> <span class="p_context"> static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 		struct mm_decoded_insn dec_insn, void *__user *fault_addr)
 {
 	unsigned long contpc = xcp-&gt;cp0_epc + dec_insn.pc_inc;
<span class="p_add">+	unsigned long r31;</span>
<span class="p_add">+	unsigned long s_epc;</span>
 	unsigned int cond, cbit;
 	mips_instruction ir;
 	int likely, pc_inc;
<span class="p_chunk">@@ -989,6 +991,8 @@</span> <span class="p_context"> static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 	if (!cpu_has_mmips &amp;&amp; dec_insn.micro_mips_mode)
 		unreachable();
 
<span class="p_add">+	s_epc = xcp-&gt;cp0_epc;</span>
<span class="p_add">+	r31 = xcp-&gt;regs[31];</span>
 	/* XXX NEC Vr54xx bug workaround */
 	if (delay_slot(xcp)) {
 		if (dec_insn.micro_mips_mode) {
<span class="p_chunk">@@ -1265,7 +1269,7 @@</span> <span class="p_context"> branch_common:</span>
 						 * instruction in the dslot.
 						 */
 						sig = mips_dsemul(xcp, ir,
<span class="p_del">-								  contpc);</span>
<span class="p_add">+							    contpc, s_epc, r31);</span>
 						if (sig)
 							xcp-&gt;cp0_epc = bcpc;
 						/*
<span class="p_chunk">@@ -1318,7 +1322,7 @@</span> <span class="p_context"> branch_common:</span>
 				 * Single step the non-cp1
 				 * instruction in the dslot
 				 */
<span class="p_del">-				sig = mips_dsemul(xcp, ir, contpc);</span>
<span class="p_add">+				sig = mips_dsemul(xcp, ir, contpc, s_epc, r31);</span>
 				if (sig)
 					xcp-&gt;cp0_epc = bcpc;
 				/* SIGILL forces out of the emulation loop.  */
<span class="p_header">diff --git a/arch/mips/math-emu/dsemul.c b/arch/mips/math-emu/dsemul.c</span>
<span class="p_header">index e0b5cc27d78b..eac76a09d822 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dsemul.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dsemul.c</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/fpu_emulator.h&gt;
 #include &lt;asm/inst.h&gt;
 #include &lt;asm/mipsregs.h&gt;
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
 #include &lt;asm/uaccess.h&gt;
 
 #include &quot;ieee754.h&quot;
<span class="p_chunk">@@ -29,13 +30,19 @@</span> <span class="p_context"> struct emuframe {</span>
 	mips_instruction	badinst;
 	mips_instruction	cookie;
 	unsigned long		epc;
<span class="p_add">+	unsigned long           bpc;</span>
<span class="p_add">+	unsigned long           r31;</span>
 };
<span class="p_add">+/* round structure size to N*8 to force a fit two instructions in a single cache line */</span>
<span class="p_add">+#define EMULFRAME_ROUNDED_SIZE  ((sizeof(struct emuframe) + 0x7) &amp; ~0x7)</span>
 
<span class="p_del">-int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)</span>
<span class="p_add">+int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc,</span>
<span class="p_add">+		unsigned long bpc, unsigned long r31)</span>
 {
 	extern asmlinkage void handle_dsemulret(void);
 	struct emuframe __user *fr;
 	int err;
<span class="p_add">+	unsigned char *pg_addr;</span>
 
 	if ((get_isa16_mode(regs-&gt;cp0_epc) &amp;&amp; ((ir &gt;&gt; 16) == MM_NOP16)) ||
 		(ir == 0)) {
<span class="p_chunk">@@ -48,7 +55,7 @@</span> <span class="p_context"> int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)</span>
 	pr_debug(&quot;dsemul %lx %lx\n&quot;, regs-&gt;cp0_epc, cpc);
 
 	/*
<span class="p_del">-	 * The strategy is to push the instruction onto the user stack</span>
<span class="p_add">+	 * The strategy is to push the instruction onto the user stack/VDSO page</span>
 	 * and put a trap after it which we can catch and jump to
 	 * the required address any alternative apart from full
 	 * instruction emulation!!.
<span class="p_chunk">@@ -65,36 +72,81 @@</span> <span class="p_context"> int mips_dsemul(struct pt_regs *regs, mips_instruction ir, unsigned long cpc)</span>
 	 * handler (single entry point).
 	 */
 
<span class="p_del">-	/* Ensure that the two instructions are in the same cache line */</span>
<span class="p_del">-	fr = (struct emuframe __user *)</span>
<span class="p_del">-		((regs-&gt;regs[29] - sizeof(struct emuframe)) &amp; ~0x7);</span>
<span class="p_add">+	if (current_thread_info()-&gt;vdso_page) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Use VDSO page and fill structure via kernel VA,</span>
<span class="p_add">+		 * user write is disabled</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pg_addr = (unsigned char *)page_address(current_thread_info()-&gt;vdso_page);</span>
<span class="p_add">+		fr = (struct emuframe __user *)</span>
<span class="p_add">+			    (pg_addr + current_thread_info()-&gt;vdso_offset -</span>
<span class="p_add">+			     EMULFRAME_ROUNDED_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* verify that we don&#39;t overflow into trampoline areas */</span>
<span class="p_add">+		if ((unsigned char *)fr &lt; (unsigned char *)(((struct mips_vdso *)pg_addr) + 1)) {</span>
<span class="p_add">+			MIPS_FPU_EMU_INC_STATS(errors);</span>
<span class="p_add">+			return SIGBUS;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		current_thread_info()-&gt;vdso_offset -= EMULFRAME_ROUNDED_SIZE;</span>
 
<span class="p_del">-	/* Verify that the stack pointer is not competely insane */</span>
<span class="p_del">-	if (unlikely(!access_ok(VERIFY_WRITE, fr, sizeof(struct emuframe))))</span>
<span class="p_del">-		return SIGBUS;</span>
<span class="p_add">+		if (get_isa16_mode(regs-&gt;cp0_epc)) {</span>
<span class="p_add">+			*(u16 *)&amp;fr-&gt;emul = (u16)(ir &gt;&gt; 16);</span>
<span class="p_add">+			*((u16 *)(&amp;fr-&gt;emul) + 1) = (u16)(ir &amp; 0xffff);</span>
<span class="p_add">+			*((u16 *)(&amp;fr-&gt;emul) + 2) = (u16)(BREAK_MATH &gt;&gt; 16);</span>
<span class="p_add">+			*((u16 *)(&amp;fr-&gt;emul) + 3) = (u16)(BREAK_MATH &amp;0xffff);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			fr-&gt;emul = ir;</span>
<span class="p_add">+			fr-&gt;badinst = (mips_instruction)BREAK_MATH;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fr-&gt;cookie = (mips_instruction)BD_COOKIE;</span>
<span class="p_add">+		fr-&gt;epc = cpc;</span>
<span class="p_add">+		fr-&gt;bpc = bpc;</span>
<span class="p_add">+		fr-&gt;r31 = r31;</span>
 
<span class="p_del">-	if (get_isa16_mode(regs-&gt;cp0_epc)) {</span>
<span class="p_del">-		err = __put_user(ir &gt;&gt; 16, (u16 __user *)(&amp;fr-&gt;emul));</span>
<span class="p_del">-		err |= __put_user(ir &amp; 0xffff, (u16 __user *)((long)(&amp;fr-&gt;emul) + 2));</span>
<span class="p_del">-		err |= __put_user(BREAK_MATH &gt;&gt; 16, (u16 __user *)(&amp;fr-&gt;badinst));</span>
<span class="p_del">-		err |= __put_user(BREAK_MATH &amp; 0xffff, (u16 __user *)((long)(&amp;fr-&gt;badinst) + 2));</span>
<span class="p_add">+		/* fill CP0_EPC with user VA */</span>
<span class="p_add">+		regs-&gt;cp0_epc = ((unsigned long)(current-&gt;mm-&gt;context.vdso +</span>
<span class="p_add">+				current_thread_info()-&gt;vdso_offset)) |</span>
<span class="p_add">+				get_isa16_mode(regs-&gt;cp0_epc);</span>
<span class="p_add">+		if (cpu_has_dc_aliases)</span>
<span class="p_add">+			mips_flush_data_cache_range(current-&gt;mm-&gt;context.vdso_vma,</span>
<span class="p_add">+				regs-&gt;cp0_epc, current_thread_info()-&gt;vdso_page,</span>
<span class="p_add">+				(unsigned long)fr, sizeof(struct emuframe));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			/* it is a less expensive on CPU with correct SYNCI */</span>
<span class="p_add">+			flush_cache_sigtramp((unsigned long)fr);</span>
 	} else {
<span class="p_del">-		err = __put_user(ir, &amp;fr-&gt;emul);</span>
<span class="p_del">-		err |= __put_user((mips_instruction)BREAK_MATH, &amp;fr-&gt;badinst);</span>
<span class="p_del">-	}</span>
<span class="p_add">+		/* Ensure that the two instructions are in the same cache line */</span>
<span class="p_add">+		fr = (struct emuframe __user *)</span>
<span class="p_add">+			((regs-&gt;regs[29] - sizeof(struct emuframe)) &amp; ~0x7);</span>
 
<span class="p_del">-	err |= __put_user((mips_instruction)BD_COOKIE, &amp;fr-&gt;cookie);</span>
<span class="p_del">-	err |= __put_user(cpc, &amp;fr-&gt;epc);</span>
<span class="p_add">+		/* Verify that the stack pointer is not competely insane */</span>
<span class="p_add">+		if (unlikely(!access_ok(VERIFY_WRITE, fr, sizeof(struct emuframe))))</span>
<span class="p_add">+			return SIGBUS;</span>
 
<span class="p_del">-	if (unlikely(err)) {</span>
<span class="p_del">-		MIPS_FPU_EMU_INC_STATS(errors);</span>
<span class="p_del">-		return SIGBUS;</span>
<span class="p_del">-	}</span>
<span class="p_add">+		if (get_isa16_mode(regs-&gt;cp0_epc)) {</span>
<span class="p_add">+			err = __put_user(ir &gt;&gt; 16, (u16 __user *)(&amp;fr-&gt;emul));</span>
<span class="p_add">+			err |= __put_user(ir &amp; 0xffff, (u16 __user *)((long)(&amp;fr-&gt;emul) + 2));</span>
<span class="p_add">+			err |= __put_user(BREAK_MATH &gt;&gt; 16, (u16 __user *)(&amp;fr-&gt;badinst));</span>
<span class="p_add">+			err |= __put_user(BREAK_MATH &amp; 0xffff, (u16 __user *)((long)(&amp;fr-&gt;badinst) + 2));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			err = __put_user(ir, &amp;fr-&gt;emul);</span>
<span class="p_add">+			err |= __put_user((mips_instruction)BREAK_MATH, &amp;fr-&gt;badinst);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	regs-&gt;cp0_epc = ((unsigned long) &amp;fr-&gt;emul) |</span>
<span class="p_del">-		get_isa16_mode(regs-&gt;cp0_epc);</span>
<span class="p_add">+		err |= __put_user((mips_instruction)BD_COOKIE, &amp;fr-&gt;cookie);</span>
<span class="p_add">+		err |= __put_user(cpc, &amp;fr-&gt;epc);</span>
 
<span class="p_del">-	flush_cache_sigtramp((unsigned long)&amp;fr-&gt;emul);</span>
<span class="p_add">+		if (unlikely(err)) {</span>
<span class="p_add">+			MIPS_FPU_EMU_INC_STATS(errors);</span>
<span class="p_add">+			return SIGBUS;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		regs-&gt;cp0_epc = ((unsigned long) &amp;fr-&gt;emul) |</span>
<span class="p_add">+			get_isa16_mode(regs-&gt;cp0_epc);</span>
<span class="p_add">+</span>
<span class="p_add">+		flush_cache_sigtramp((unsigned long)&amp;fr-&gt;emul);</span>
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -132,7 +184,10 @@</span> <span class="p_context"> int do_dsemulret(struct pt_regs *xcp)</span>
 	}
 	err |= __get_user(cookie, &amp;fr-&gt;cookie);
 
<span class="p_del">-	if (unlikely(err || (insn != BREAK_MATH) || (cookie != BD_COOKIE))) {</span>
<span class="p_add">+	if (unlikely(err || (insn != BREAK_MATH) || (cookie != BD_COOKIE) ||</span>
<span class="p_add">+	    (current_thread_info()-&gt;vdso_page &amp;&amp;</span>
<span class="p_add">+	     ((xcp-&gt;cp0_epc &amp; PAGE_MASK) !=</span>
<span class="p_add">+			(unsigned long)current-&gt;mm-&gt;context.vdso)))) {</span>
 		MIPS_FPU_EMU_INC_STATS(errors);
 		return 0;
 	}
<span class="p_chunk">@@ -156,8 +211,55 @@</span> <span class="p_context"> int do_dsemulret(struct pt_regs *xcp)</span>
 		return 0;
 	}
 
<span class="p_add">+	if (current_thread_info()-&gt;vdso_page) {</span>
<span class="p_add">+		/* restore VDSO stack level */</span>
<span class="p_add">+		current_thread_info()-&gt;vdso_offset += EMULFRAME_ROUNDED_SIZE;</span>
<span class="p_add">+		if (current_thread_info()-&gt;vdso_offset &gt; PAGE_SIZE) {</span>
<span class="p_add">+			/* This is not a good situation to be in */</span>
<span class="p_add">+			current_thread_info()-&gt;vdso_offset -= EMULFRAME_ROUNDED_SIZE;</span>
<span class="p_add">+			force_sig(SIGBUS, current);</span>
<span class="p_add">+</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Set EPC to return to post-branch instruction */
 	xcp-&gt;cp0_epc = epc;
 	MIPS_FPU_EMU_INC_STATS(ds_emul);
 	return 1;
 }
<span class="p_add">+</span>
<span class="p_add">+/* check and adjust an emulation stack before start a signal handler */</span>
<span class="p_add">+void vdso_epc_adjust(struct pt_regs *xcp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct emuframe __user *fr;</span>
<span class="p_add">+	unsigned long epc;</span>
<span class="p_add">+	unsigned long r31;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (current_thread_info()-&gt;vdso_offset &lt; PAGE_SIZE) {</span>
<span class="p_add">+		epc = msk_isa16_mode(xcp-&gt;cp0_epc);</span>
<span class="p_add">+		if ((epc &gt;= ((unsigned long)current-&gt;mm-&gt;context.vdso + PAGE_SIZE)) ||</span>
<span class="p_add">+		    (epc &lt; (unsigned long)((struct mips_vdso *)current-&gt;mm-&gt;context.vdso + 1)))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		fr = (struct emuframe __user *)</span>
<span class="p_add">+			((unsigned long)current-&gt;mm-&gt;context.vdso +</span>
<span class="p_add">+			 current_thread_info()-&gt;vdso_offset);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * epc must point to emul instruction or badinst</span>
<span class="p_add">+		 * in case of emul - it is not executed, so return to start</span>
<span class="p_add">+		 *                   and restore GPR31</span>
<span class="p_add">+		 * in case of badinst - instruction is executed, return to destination</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (epc == (unsigned long)&amp;fr-&gt;emul) {</span>
<span class="p_add">+			__get_user(r31, &amp;fr-&gt;r31);</span>
<span class="p_add">+			xcp-&gt;regs[31] = r31;</span>
<span class="p_add">+			__get_user(epc, &amp;fr-&gt;bpc);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			__get_user(epc, &amp;fr-&gt;epc);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		xcp-&gt;cp0_epc = epc;</span>
<span class="p_add">+		current_thread_info()-&gt;vdso_offset += EMULFRAME_ROUNDED_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c</span>
<span class="p_header">index 4b88fa031891..cdbf0cefe997 100644</span>
<span class="p_header">--- a/arch/mips/mm/fault.c</span>
<span class="p_header">+++ b/arch/mips/mm/fault.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/highmem.h&gt;		/* For VMALLOC_END */
<span class="p_add">+#include &lt;asm/tlbmisc.h&gt;</span>
 #include &lt;linux/kdebug.h&gt;
 
 int show_unhandled_signals = 1;
<span class="p_chunk">@@ -142,6 +143,9 @@</span> <span class="p_context"> good_area:</span>
 #endif
 				goto bad_area;
 			}
<span class="p_add">+			if (((address &amp; PAGE_MASK) == (unsigned long)(mm-&gt;context.vdso)) &amp;&amp;</span>
<span class="p_add">+			    install_vdso_tlb())</span>
<span class="p_add">+				goto up_return;</span>
 		} else {
 			if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_WRITE | VM_EXEC)))
 				goto bad_area;
<span class="p_chunk">@@ -192,6 +196,7 @@</span> <span class="p_context"> good_area:</span>
 		}
 	}
 
<span class="p_add">+up_return:</span>
 	up_read(&amp;mm-&gt;mmap_sem);
 	return;
 
<span class="p_header">diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c</span>
<span class="p_header">index 5037d5868cef..9e3f9d3235c7 100644</span>
<span class="p_header">--- a/arch/mips/mm/tlb-r4k.c</span>
<span class="p_header">+++ b/arch/mips/mm/tlb-r4k.c</span>
<span class="p_chunk">@@ -360,6 +360,48 @@</span> <span class="p_context"> void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)</span>
 	local_irq_restore(flags);
 }
 
<span class="p_add">+int install_vdso_tlb(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int tlbidx;</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!current_thread_info()-&gt;vdso_page)</span>
<span class="p_add">+		return(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	write_c0_entryhi(((unsigned long)current-&gt;mm-&gt;context.vdso &amp; (PAGE_MASK &lt;&lt; 1)) |</span>
<span class="p_add">+			 cpu_asid(cpu, current-&gt;mm));</span>
<span class="p_add">+</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+	tlb_probe();</span>
<span class="p_add">+	tlb_probe_hazard();</span>
<span class="p_add">+	tlbidx = read_c0_index();</span>
<span class="p_add">+#if defined(CONFIG_64BIT_PHYS_ADDR) &amp;&amp; defined(CONFIG_CPU_MIPS32)</span>
<span class="p_add">+		write_c0_entrylo0(pte_val(pfn_pte(</span>
<span class="p_add">+			page_to_pfn(current_thread_info()-&gt;vdso_page),</span>
<span class="p_add">+			__pgprot(_page_cachable_default|_PAGE_VALID)))&gt;&gt;32);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		write_c0_entrylo0(pte_to_entrylo(pte_val(pfn_pte(</span>
<span class="p_add">+			page_to_pfn(current_thread_info()-&gt;vdso_page),</span>
<span class="p_add">+			__pgprot(_page_cachable_default|_PAGE_VALID)))));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	write_c0_entrylo1(0);</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+	if (tlbidx &lt; 0)</span>
<span class="p_add">+		tlb_write_random();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tlb_write_indexed();</span>
<span class="p_add">+	tlbw_use_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	current-&gt;mm-&gt;context.vdso_asid[cpu] = cpu_asid(cpu, current-&gt;mm);</span>
<span class="p_add">+	current-&gt;mm-&gt;context.vdso_page[cpu] = current_thread_info()-&gt;vdso_page;</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return(1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 		     unsigned long entryhi, unsigned long pagemask)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



