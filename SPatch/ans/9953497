
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.12.13 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.12.13</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 14, 2017, 4:04 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170914160450.GB3577@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9953497/mbox/"
   >mbox</a>
|
   <a href="/patch/9953497/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9953497/">/patch/9953497/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	64D31602C9 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:05:01 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 61DBD1FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:05:01 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5325027F17; Thu, 14 Sep 2017 16:05:01 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5585F1FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:04:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752124AbdINQE4 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Sep 2017 12:04:56 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:44836 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752043AbdINQEw (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Sep 2017 12:04:52 -0400
Received: from localhost (unknown [12.145.98.253])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 75590A64;
	Thu, 14 Sep 2017 16:04:51 +0000 (UTC)
Date: Thu, 14 Sep 2017 09:04:50 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.12.13
Message-ID: &lt;20170914160450.GB3577@kroah.com&gt;
References: &lt;20170914160446.GA3577@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170914160446.GA3577@kroah.com&gt;
User-Agent: Mutt/1.9.0 (2017-09-02)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 14, 2017, 4:04 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index e96306381ee8..983224467a4d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 12
<span class="p_del">-SUBLEVEL = 12</span>
<span class="p_add">+SUBLEVEL = 13</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c</span>
<span class="p_header">index ff8b0aa2dfde..42f585379e19 100644</span>
<span class="p_header">--- a/arch/arm/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm/mm/fault.c</span>
<span class="p_chunk">@@ -315,8 +315,11 @@</span> <span class="p_context"> do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * signal first. We do not need to release the mmap_sem because
 	 * it would already be released in __lock_page_or_retry in
 	 * mm/filemap.c. */
<span class="p_del">-	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))</span>
<span class="p_add">+	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)) {</span>
<span class="p_add">+		if (!user_mode(regs))</span>
<span class="p_add">+			goto no_context;</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/*
 	 * Major/minor page fault accounting is only done on the
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">index b69e4a4ecdd8..1ce5e773dd30 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_chunk">@@ -312,6 +312,7 @@</span> <span class="p_context"></span>
 				interrupt-controller;
 				reg = &lt;0x1d00000 0x10000&gt;, /* GICD */
 				      &lt;0x1d40000 0x40000&gt;; /* GICR */
<span class="p_add">+				interrupts = &lt;GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
 			};
 		};
 
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index cb8225969255..97fc5f18b0a8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -4759,7 +4759,8 @@</span> <span class="p_context"> int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u64 error_code,</span>
 	 * Note: AMD only (since it supports the PFERR_GUEST_PAGE_MASK used
 	 *       in PFERR_NEXT_GUEST_PAGE)
 	 */
<span class="p_del">-	if (error_code == PFERR_NESTED_GUEST_PAGE) {</span>
<span class="p_add">+	if (vcpu-&gt;arch.mmu.direct_map &amp;&amp;</span>
<span class="p_add">+		error_code == PFERR_NESTED_GUEST_PAGE) {</span>
 		kvm_mmu_unprotect_page(vcpu-&gt;kvm, gpa_to_gfn(cr2));
 		return 1;
 	}
<span class="p_header">diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">index 61ca020c5272..d929111b5ebe 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_chunk">@@ -877,6 +877,8 @@</span> <span class="p_context"> static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)</span>
 	}
 }
 
<span class="p_add">+#define MXC_V1_ECCBYTES		5</span>
<span class="p_add">+</span>
 static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,
 				struct mtd_oob_region *oobregion)
 {
<span class="p_chunk">@@ -886,7 +888,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,</span>
 		return -ERANGE;
 
 	oobregion-&gt;offset = (section * 16) + 6;
<span class="p_del">-	oobregion-&gt;length = nand_chip-&gt;ecc.bytes;</span>
<span class="p_add">+	oobregion-&gt;length = MXC_V1_ECCBYTES;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -908,8 +910,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_free(struct mtd_info *mtd, int section,</span>
 			oobregion-&gt;length = 4;
 		}
 	} else {
<span class="p_del">-		oobregion-&gt;offset = ((section - 1) * 16) +</span>
<span class="p_del">-				    nand_chip-&gt;ecc.bytes + 6;</span>
<span class="p_add">+		oobregion-&gt;offset = ((section - 1) * 16) + MXC_V1_ECCBYTES + 6;</span>
 		if (section &lt; nand_chip-&gt;ecc.steps)
 			oobregion-&gt;length = (section * 16) + 6 -
 					    oobregion-&gt;offset;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 6f9771e82476..2be78d1bc195 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -3972,10 +3972,13 @@</span> <span class="p_context"> static void nand_manufacturer_detect(struct nand_chip *chip)</span>
 	 * nand_decode_ext_id() otherwise.
 	 */
 	if (chip-&gt;manufacturer.desc &amp;&amp; chip-&gt;manufacturer.desc-&gt;ops &amp;&amp;
<span class="p_del">-	    chip-&gt;manufacturer.desc-&gt;ops-&gt;detect)</span>
<span class="p_add">+	    chip-&gt;manufacturer.desc-&gt;ops-&gt;detect) {</span>
<span class="p_add">+		/* The 3rd id byte holds MLC / multichip data */</span>
<span class="p_add">+		chip-&gt;bits_per_cell = nand_get_bits_per_cell(chip-&gt;id.data[2]);</span>
 		chip-&gt;manufacturer.desc-&gt;ops-&gt;detect(chip);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		nand_decode_ext_id(chip);
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/mtd/nand/nand_hynix.c b/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_header">index b12dc7325378..bd9a6e343848 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> static void hynix_nand_extract_ecc_requirements(struct nand_chip *chip,</span>
 		 * The ECC requirements field meaning depends on the
 		 * NAND technology.
 		 */
<span class="p_del">-		u8 nand_tech = chip-&gt;id.data[5] &amp; 0x3;</span>
<span class="p_add">+		u8 nand_tech = chip-&gt;id.data[5] &amp; 0x7;</span>
 
 		if (nand_tech &lt; 3) {
 			/* &gt; 26nm, reference: H27UBG8T2A datasheet */
<span class="p_chunk">@@ -533,7 +533,7 @@</span> <span class="p_context"> static void hynix_nand_extract_scrambling_requirements(struct nand_chip *chip,</span>
 		if (nand_tech &gt; 0)
 			chip-&gt;options |= NAND_NEED_SCRAMBLING;
 	} else {
<span class="p_del">-		nand_tech = chip-&gt;id.data[5] &amp; 0x3;</span>
<span class="p_add">+		nand_tech = chip-&gt;id.data[5] &amp; 0x7;</span>
 
 		/* &lt; 32nm */
 		if (nand_tech &gt; 2)
<span class="p_header">diff --git a/drivers/mtd/nand/qcom_nandc.c b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">index 57d483ac5765..6f0fd1512ad2 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_chunk">@@ -109,7 +109,11 @@</span> <span class="p_context"></span>
 #define	READ_ADDR			0
 
 /* NAND_DEV_CMD_VLD bits */
<span class="p_del">-#define	READ_START_VLD			0</span>
<span class="p_add">+#define	READ_START_VLD			BIT(0)</span>
<span class="p_add">+#define	READ_STOP_VLD			BIT(1)</span>
<span class="p_add">+#define	WRITE_START_VLD			BIT(2)</span>
<span class="p_add">+#define	ERASE_START_VLD			BIT(3)</span>
<span class="p_add">+#define	SEQ_READ_START_VLD		BIT(4)</span>
 
 /* NAND_EBI2_ECC_BUF_CFG bits */
 #define	NUM_STEPS			0
<span class="p_chunk">@@ -148,6 +152,10 @@</span> <span class="p_context"></span>
 #define	FETCH_ID			0xb
 #define	RESET_DEVICE			0xd
 
<span class="p_add">+/* Default Value for NAND_DEV_CMD_VLD */</span>
<span class="p_add">+#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \</span>
<span class="p_add">+					 ERASE_START_VLD | SEQ_READ_START_VLD)</span>
<span class="p_add">+</span>
 /*
  * the NAND controller performs reads/writes with ECC in 516 byte chunks.
  * the driver calls the chunks &#39;step&#39; or &#39;codeword&#39; interchangeably
<span class="p_chunk">@@ -672,8 +680,7 @@</span> <span class="p_context"> static int nandc_param(struct qcom_nand_host *host)</span>
 
 	/* configure CMD1 and VLD for ONFI param probing */
 	nandc_set_reg(nandc, NAND_DEV_CMD_VLD,
<span class="p_del">-		      (nandc-&gt;vld &amp; ~(1 &lt;&lt; READ_START_VLD))</span>
<span class="p_del">-		      | 0 &lt;&lt; READ_START_VLD);</span>
<span class="p_add">+		      (nandc-&gt;vld &amp; ~READ_START_VLD));</span>
 	nandc_set_reg(nandc, NAND_DEV_CMD1,
 		      (nandc-&gt;cmd1 &amp; ~(0xFF &lt;&lt; READ_ADDR))
 		      | NAND_CMD_PARAM &lt;&lt; READ_ADDR);
<span class="p_chunk">@@ -1893,7 +1900,7 @@</span> <span class="p_context"> static int qcom_nand_host_setup(struct qcom_nand_host *host)</span>
 				| wide_bus &lt;&lt; WIDE_FLASH
 				| 1 &lt;&lt; DEV0_CFG1_ECC_DISABLE;
 
<span class="p_del">-	host-&gt;ecc_bch_cfg = host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
<span class="p_add">+	host-&gt;ecc_bch_cfg = !host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
 				| 0 &lt;&lt; ECC_SW_RESET
 				| host-&gt;cw_data &lt;&lt; ECC_NUM_DATA_BYTES
 				| 1 &lt;&lt; ECC_FORCE_CLK_OPEN
<span class="p_chunk">@@ -1972,13 +1979,14 @@</span> <span class="p_context"> static int qcom_nandc_setup(struct qcom_nand_controller *nandc)</span>
 {
 	/* kill onenand */
 	nandc_write(nandc, SFLASHC_BURST_CFG, 0);
<span class="p_add">+	nandc_write(nandc, NAND_DEV_CMD_VLD, NAND_DEV_CMD_VLD_VAL);</span>
 
 	/* enable ADM DMA */
 	nandc_write(nandc, NAND_FLASH_CHIP_SELECT, DM_EN);
 
 	/* save the original values of these registers */
 	nandc-&gt;cmd1 = nandc_read(nandc, NAND_DEV_CMD1);
<span class="p_del">-	nandc-&gt;vld = nandc_read(nandc, NAND_DEV_CMD_VLD);</span>
<span class="p_add">+	nandc-&gt;vld = NAND_DEV_CMD_VLD_VAL;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">index d11c7b210e81..5672aec48572 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_chunk">@@ -3699,7 +3699,10 @@</span> <span class="p_context"> static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,</span>
 	if (rt2x00_rt(rt2x00dev, RT3572))
 		rt2800_rfcsr_write(rt2x00dev, 8, 0);
 
<span class="p_del">-	rt2800_register_read(rt2x00dev, TX_PIN_CFG, &amp;tx_pin);</span>
<span class="p_add">+	if (rt2x00_rt(rt2x00dev, RT6352))</span>
<span class="p_add">+		rt2800_register_read(rt2x00dev, TX_PIN_CFG, &amp;tx_pin);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tx_pin = 0;</span>
 
 	switch (rt2x00dev-&gt;default_ant.tx_chain_num) {
 	case 3:
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">index 2f3946be4ce2..34cb46a0c904 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_chunk">@@ -1153,7 +1153,10 @@</span> <span class="p_context"> static void btc8723b2ant_set_ant_path(struct btc_coexist *btcoexist,</span>
 		}
 
 		/* fixed internal switch S1-&gt;WiFi, S0-&gt;BT */
<span class="p_del">-		btcoexist-&gt;btc_write_4byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		if (board_info-&gt;btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x280);</span>
 
 		switch (antpos_type) {
 		case BTC_ANT_WIFI_AT_MAIN:
<span class="p_header">diff --git a/drivers/nvme/host/fabrics.c b/drivers/nvme/host/fabrics.c</span>
<span class="p_header">index 990e6fb32a63..e353e151ffa9 100644</span>
<span class="p_header">--- a/drivers/nvme/host/fabrics.c</span>
<span class="p_header">+++ b/drivers/nvme/host/fabrics.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static struct nvmf_host *nvmf_host_default(void)</span>
 	kref_init(&amp;host-&gt;ref);
 	uuid_be_gen(&amp;host-&gt;id);
 	snprintf(host-&gt;nqn, NVMF_NQN_SIZE,
<span class="p_del">-		&quot;nqn.2014-08.org.nvmexpress:NVMf:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
<span class="p_add">+		&quot;nqn.2014-08.org.nvmexpress:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
 
 	mutex_lock(&amp;nvmf_hosts_mutex);
 	list_add_tail(&amp;host-&gt;list, &amp;nvmf_hosts);
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 4f1cdd5058f1..76209e7fb6e1 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -1828,6 +1828,8 @@</span> <span class="p_context"> static int btrfs_remount(struct super_block *sb, int *flags, char *data)</span>
 			goto restore;
 		}
 
<span class="p_add">+		btrfs_qgroup_rescan_resume(fs_info);</span>
<span class="p_add">+</span>
 		if (!fs_info-&gt;uuid_root) {
 			btrfs_info(fs_info, &quot;creating UUID tree&quot;);
 			ret = btrfs_create_uuid_tree(fs_info);
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index d264363559db..426e4e06b333 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -629,11 +629,11 @@</span> <span class="p_context"> ssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)</span>
 	if (result &lt;= 0)
 		goto out;
 
<span class="p_del">-	result = generic_write_sync(iocb, result);</span>
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		goto out;</span>
 	written = result;
 	iocb-&gt;ki_pos += written;
<span class="p_add">+	result = generic_write_sync(iocb, written);</span>
<span class="p_add">+	if (result &lt; 0)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Return error values */
 	if (nfs_need_check_write(file, inode)) {
<span class="p_header">diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h</span>
<span class="p_header">index 3e24392f2caa..4651bf48aa86 100644</span>
<span class="p_header">--- a/fs/nfs/internal.h</span>
<span class="p_header">+++ b/fs/nfs/internal.h</span>
<span class="p_chunk">@@ -248,7 +248,6 @@</span> <span class="p_context"> int nfs_iocounter_wait(struct nfs_lock_context *l_ctx);</span>
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *);</span>
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
 		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index 7ddba5022948..0e1d3f263f8c 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -515,16 +515,6 @@</span> <span class="p_context"> struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)</span>
 }
 EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
 
<span class="p_del">-/*</span>
<span class="p_del">- * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_del">- * @hdr: The header to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
<span class="p_del">-</span>
 /**
  * nfs_pgio_data_destroy - make @hdr suitable for reuse
  *
<span class="p_chunk">@@ -533,14 +523,24 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
  *
  * @hdr: A header that has had nfs_generic_pgio called
  */
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+static void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
 {
 	if (hdr-&gt;args.context)
 		put_nfs_open_context(hdr-&gt;args.context);
 	if (hdr-&gt;page_array.pagevec != hdr-&gt;page_array.page_array)
 		kfree(hdr-&gt;page_array.pagevec);
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_add">+ * @hdr: The header to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	nfs_pgio_data_destroy(hdr);</span>
<span class="p_add">+	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
 
 /**
  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
<span class="p_chunk">@@ -654,7 +654,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_initiate_pgio);</span>
 static void nfs_pgio_error(struct nfs_pgio_header *hdr)
 {
 	set_bit(NFS_IOHDR_REDO, &amp;hdr-&gt;flags);
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_chunk">@@ -665,7 +664,6 @@</span> <span class="p_context"> static void nfs_pgio_error(struct nfs_pgio_header *hdr)</span>
 static void nfs_pgio_release(void *calldata)
 {
 	struct nfs_pgio_header *hdr = calldata;
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_chunk">@@ -699,9 +697,6 @@</span> <span class="p_context"> void nfs_pageio_init(struct nfs_pageio_descriptor *desc,</span>
 		     int io_flags,
 		     gfp_t gfp_flags)
 {
<span class="p_del">-	struct nfs_pgio_mirror *new;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
 	desc-&gt;pg_moreio = 0;
 	desc-&gt;pg_inode = inode;
 	desc-&gt;pg_ops = pg_ops;
<span class="p_chunk">@@ -717,21 +712,9 @@</span> <span class="p_context"> void nfs_pageio_init(struct nfs_pageio_descriptor *desc,</span>
 	desc-&gt;pg_mirror_count = 1;
 	desc-&gt;pg_mirror_idx = 0;
 
<span class="p_del">-	if (pg_ops-&gt;pg_get_mirror_count) {</span>
<span class="p_del">-		/* until we have a request, we don&#39;t have an lseg and no</span>
<span class="p_del">-		 * idea how many mirrors there will be */</span>
<span class="p_del">-		new = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,</span>
<span class="p_del">-			      sizeof(struct nfs_pgio_mirror), gfp_flags);</span>
<span class="p_del">-		desc-&gt;pg_mirrors_dynamic = new;</span>
<span class="p_del">-		desc-&gt;pg_mirrors = new;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 0; i &lt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)</span>
<span class="p_del">-			nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[i], bsize);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_del">-		desc-&gt;pg_mirrors = desc-&gt;pg_mirrors_static;</span>
<span class="p_del">-		nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[0], bsize);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_add">+	desc-&gt;pg_mirrors = desc-&gt;pg_mirrors_static;</span>
<span class="p_add">+	nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[0], bsize);</span>
 }
 EXPORT_SYMBOL_GPL(nfs_pageio_init);
 
<span class="p_chunk">@@ -850,32 +833,52 @@</span> <span class="p_context"> static int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *desc)</span>
 	return ret;
 }
 
<span class="p_add">+static struct nfs_pgio_mirror *</span>
<span class="p_add">+nfs_pageio_alloc_mirrors(struct nfs_pageio_descriptor *desc,</span>
<span class="p_add">+		unsigned int mirror_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs_pgio_mirror *ret;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(desc-&gt;pg_mirrors_dynamic);</span>
<span class="p_add">+	desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_add">+	if (mirror_count == 1)</span>
<span class="p_add">+		return desc-&gt;pg_mirrors_static;</span>
<span class="p_add">+	ret = kmalloc_array(mirror_count, sizeof(*ret), GFP_NOFS);</span>
<span class="p_add">+	if (ret != NULL) {</span>
<span class="p_add">+		for (i = 0; i &lt; mirror_count; i++)</span>
<span class="p_add">+			nfs_pageio_mirror_init(&amp;ret[i], desc-&gt;pg_bsize);</span>
<span class="p_add">+		desc-&gt;pg_mirrors_dynamic = ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * nfs_pageio_setup_mirroring - determine if mirroring is to be used
  *				by calling the pg_get_mirror_count op
  */
<span class="p_del">-static int nfs_pageio_setup_mirroring(struct nfs_pageio_descriptor *pgio,</span>
<span class="p_add">+static void nfs_pageio_setup_mirroring(struct nfs_pageio_descriptor *pgio,</span>
 				       struct nfs_page *req)
 {
<span class="p_del">-	int mirror_count = 1;</span>
<span class="p_add">+	unsigned int mirror_count = 1;</span>
 
<span class="p_del">-	if (!pgio-&gt;pg_ops-&gt;pg_get_mirror_count)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	mirror_count = pgio-&gt;pg_ops-&gt;pg_get_mirror_count(pgio, req);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pgio-&gt;pg_error &lt; 0)</span>
<span class="p_del">-		return pgio-&gt;pg_error;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mirror_count || mirror_count &gt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (pgio-&gt;pg_ops-&gt;pg_get_mirror_count)</span>
<span class="p_add">+		mirror_count = pgio-&gt;pg_ops-&gt;pg_get_mirror_count(pgio, req);</span>
<span class="p_add">+	if (mirror_count == pgio-&gt;pg_mirror_count || pgio-&gt;pg_error &lt; 0)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	if (WARN_ON_ONCE(!pgio-&gt;pg_mirrors_dynamic))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!mirror_count || mirror_count &gt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX) {</span>
<span class="p_add">+		pgio-&gt;pg_error = -EINVAL;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	pgio-&gt;pg_mirrors = nfs_pageio_alloc_mirrors(pgio, mirror_count);</span>
<span class="p_add">+	if (pgio-&gt;pg_mirrors == NULL) {</span>
<span class="p_add">+		pgio-&gt;pg_error = -ENOMEM;</span>
<span class="p_add">+		pgio-&gt;pg_mirrors = pgio-&gt;pg_mirrors_static;</span>
<span class="p_add">+		mirror_count = 1;</span>
<span class="p_add">+	}</span>
 	pgio-&gt;pg_mirror_count = mirror_count;
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index c383d0913b54..64bb20130edf 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -2274,7 +2274,6 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_write_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_chunk">@@ -2398,7 +2397,6 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_read_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_header">diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h</span>
<span class="p_header">index 044fb0e15390..f6586691d989 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_linux.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_linux.h</span>
<span class="p_chunk">@@ -279,7 +279,14 @@</span> <span class="p_context"> static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)</span>
 #endif /* DEBUG */
 
 #ifdef CONFIG_XFS_RT
<span class="p_del">-#define XFS_IS_REALTIME_INODE(ip) ((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * make sure we ignore the inode flag if the filesystem doesn&#39;t have a</span>
<span class="p_add">+ * configured realtime device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define XFS_IS_REALTIME_INODE(ip)			\</span>
<span class="p_add">+	(((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME) &amp;&amp;	\</span>
<span class="p_add">+	 (ip)-&gt;i_mount-&gt;m_rtdev_targp)</span>
 #else
 #define XFS_IS_REALTIME_INODE(ip) (0)
 #endif
<span class="p_header">diff --git a/lib/radix-tree.c b/lib/radix-tree.c</span>
<span class="p_header">index 898e87998417..79a804f1aab9 100644</span>
<span class="p_header">--- a/lib/radix-tree.c</span>
<span class="p_header">+++ b/lib/radix-tree.c</span>
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> radix_tree_node_free(struct radix_tree_node *node)</span>
  * To make use of this facility, the radix tree must be initialised without
  * __GFP_DIRECT_RECLAIM being passed to INIT_RADIX_TREE().
  */
<span class="p_del">-static int __radix_tree_preload(gfp_t gfp_mask, unsigned nr)</span>
<span class="p_add">+static __must_check int __radix_tree_preload(gfp_t gfp_mask, unsigned nr)</span>
 {
 	struct radix_tree_preload *rtp;
 	struct radix_tree_node *node;
<span class="p_chunk">@@ -2103,7 +2103,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(radix_tree_tagged);</span>
  */
 void idr_preload(gfp_t gfp_mask)
 {
<span class="p_del">-	__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE);</span>
<span class="p_add">+	if (__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE))</span>
<span class="p_add">+		preempt_disable();</span>
 }
 EXPORT_SYMBOL(idr_preload);
 
<span class="p_chunk">@@ -2117,13 +2118,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(idr_preload);</span>
  */
 int ida_pre_get(struct ida *ida, gfp_t gfp)
 {
<span class="p_del">-	__radix_tree_preload(gfp, IDA_PRELOAD_SIZE);</span>
 	/*
 	 * The IDA API has no preload_end() equivalent.  Instead,
 	 * ida_get_new() can return -EAGAIN, prompting the caller
 	 * to return to the ida_pre_get() step.
 	 */
<span class="p_del">-	preempt_enable();</span>
<span class="p_add">+	if (!__radix_tree_preload(gfp, IDA_PRELOAD_SIZE))</span>
<span class="p_add">+		preempt_enable();</span>
 
 	if (!this_cpu_read(ida_bitmap)) {
 		struct ida_bitmap *bitmap = kmalloc(sizeof(*bitmap), gfp);
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 9e50ffcf9639..0a98a1a55dfa 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3843,6 +3843,11 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	/* do counter updates before entering really critical section. */
 	check_sync_rss_stat(current);
 
<span class="p_add">+	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_add">+		return VM_FAULT_SIGSEGV;</span>
<span class="p_add">+</span>
 	/*
 	 * Enable the memcg OOM handling for faults triggered in user
 	 * space.  Kernel faults are handled more gracefully.
<span class="p_chunk">@@ -3850,11 +3855,6 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	if (flags &amp; FAULT_FLAG_USER)
 		mem_cgroup_oom_enable();
 
<span class="p_del">-	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);
 	else
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index 4f6cba1b6632..2e09f67bc99b 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -2903,7 +2903,8 @@</span> <span class="p_context"> SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)</span>
 	p-&gt;flags = 0;
 	spin_unlock(&amp;swap_lock);
 	vfree(swap_map);
<span class="p_del">-	vfree(cluster_info);</span>
<span class="p_add">+	kvfree(cluster_info);</span>
<span class="p_add">+	kvfree(frontswap_map);</span>
 	if (swap_file) {
 		if (inode &amp;&amp; S_ISREG(inode-&gt;i_mode)) {
 			inode_unlock(inode);
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index f88ac99528ce..6754e93d2096 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,</span>
 				       u8 code, u8 ident, u16 dlen, void *data);
 static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
 			   void *data);
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);</span>
 static void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);
 
 static void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,
<span class="p_chunk">@@ -1473,7 +1473,7 @@</span> <span class="p_context"> static void l2cap_conn_start(struct l2cap_conn *conn)</span>
 
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 
<span class="p_chunk">@@ -2987,12 +2987,15 @@</span> <span class="p_context"> static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,</span>
 	return len;
 }
 
<span class="p_del">-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
<span class="p_add">+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)</span>
 {
 	struct l2cap_conf_opt *opt = *ptr;
 
 	BT_DBG(&quot;type 0x%2.2x len %u val 0x%lx&quot;, type, len, val);
 
<span class="p_add">+	if (size &lt; L2CAP_CONF_OPT_SIZE + len)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	opt-&gt;type = type;
 	opt-&gt;len  = len;
 
<span class="p_chunk">@@ -3017,7 +3020,7 @@</span> <span class="p_context"> static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
 	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
<span class="p_del">-static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
<span class="p_add">+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)</span>
 {
 	struct l2cap_conf_efs efs;
 
<span class="p_chunk">@@ -3045,7 +3048,7 @@</span> <span class="p_context"> static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
 	}
 
 	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-			   (unsigned long) &amp;efs);</span>
<span class="p_add">+			   (unsigned long) &amp;efs, size);</span>
 }
 
 static void l2cap_ack_timeout(struct work_struct *work)
<span class="p_chunk">@@ -3191,11 +3194,12 @@</span> <span class="p_context"> static inline void l2cap_txwin_setup(struct l2cap_chan *chan)</span>
 	chan-&gt;ack_win = chan-&gt;tx_win;
 }
 
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_req *req = data;
 	struct l2cap_conf_rfc rfc = { .mode = chan-&gt;mode };
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	u16 size;
 
 	BT_DBG(&quot;chan %p&quot;, chan);
<span class="p_chunk">@@ -3220,7 +3224,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 done:
 	if (chan-&gt;imtu != L2CAP_DEFAULT_MTU)
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 
 	switch (chan-&gt;mode) {
 	case L2CAP_MODE_BASIC:
<span class="p_chunk">@@ -3239,7 +3243,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size    = 0;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 		break;
 
 	case L2CAP_MODE_ERTM:
<span class="p_chunk">@@ -3259,21 +3263,21 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 				       L2CAP_DEFAULT_TX_WINDOW);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EXT_CTRL, &amp;chan-&gt;flags))
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 
<span class="p_chunk">@@ -3291,17 +3295,17 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size = cpu_to_le16(size);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 	}
<span class="p_chunk">@@ -3312,10 +3316,11 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 	return ptr - data;
 }
 
<span class="p_del">-static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	void *req = chan-&gt;conf_req;
 	int len = chan-&gt;conf_len;
 	int type, hint, olen;
<span class="p_chunk">@@ -3417,7 +3422,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			return -ECONNREFUSED;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 	}
 
 	if (result == L2CAP_CONF_SUCCESS) {
<span class="p_chunk">@@ -3430,7 +3435,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			chan-&gt;omtu = mtu;
 			set_bit(CONF_MTU_DONE, &amp;chan-&gt;conf_state);
 		}
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu, endptr - ptr);</span>
 
 		if (remote_efs) {
 			if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;
<span class="p_chunk">@@ -3444,7 +3449,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			} else {
 				/* Send PENDING Conf Rsp */
 				result = L2CAP_CONF_PENDING;
<span class="p_chunk">@@ -3477,7 +3482,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags)) {
 				chan-&gt;remote_id = efs.id;
<span class="p_chunk">@@ -3491,7 +3496,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 					le32_to_cpu(efs.sdu_itime);
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			}
 			break;
 
<span class="p_chunk">@@ -3505,7 +3510,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-					   (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			break;
 
<span class="p_chunk">@@ -3527,10 +3532,11 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 }
 
 static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
<span class="p_del">-				void *data, u16 *result)</span>
<span class="p_add">+				void *data, size_t size, u16 *result)</span>
 {
 	struct l2cap_conf_req *req = data;
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + size;</span>
 	int type, olen;
 	unsigned long val;
 	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
<span class="p_chunk">@@ -3548,13 +3554,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				chan-&gt;imtu = L2CAP_DEFAULT_MIN_MTU;
 			} else
 				chan-&gt;imtu = val;
<span class="p_del">-			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FLUSH_TO:
 			chan-&gt;flush_to = val;
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FLUSH_TO,
<span class="p_del">-					   2, chan-&gt;flush_to);</span>
<span class="p_add">+					   2, chan-&gt;flush_to, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_RFC:
<span class="p_chunk">@@ -3568,13 +3574,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 			chan-&gt;fcs = 0;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EWS:
 			chan-&gt;ack_win = min_t(u16, val, chan-&gt;ack_win);
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_chunk">@@ -3587,7 +3593,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				return -ECONNREFUSED;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-					   (unsigned long) &amp;efs);</span>
<span class="p_add">+					   (unsigned long) &amp;efs, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FCS:
<span class="p_chunk">@@ -3692,7 +3698,7 @@</span> <span class="p_context"> void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)</span>
 		return;
 
 	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-		       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+		       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 	chan-&gt;num_conf_req++;
 }
 
<span class="p_chunk">@@ -3900,7 +3906,7 @@</span> <span class="p_context"> static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,</span>
 		u8 buf[128];
 		set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -3978,7 +3984,7 @@</span> <span class="p_context"> static int l2cap_connect_create_rsp(struct l2cap_conn *conn,</span>
 			break;
 
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, req), req);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, req, sizeof(req)), req);</span>
 		chan-&gt;num_conf_req++;
 		break;
 
<span class="p_chunk">@@ -4090,7 +4096,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	}
 
 	/* Complete config. */
<span class="p_del">-	len = l2cap_parse_conf_req(chan, rsp);</span>
<span class="p_add">+	len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));</span>
 	if (len &lt; 0) {
 		l2cap_send_disconn_req(chan, ECONNRESET);
 		goto unlock;
<span class="p_chunk">@@ -4124,7 +4130,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	if (!test_and_set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state)) {
 		u8 buf[64];
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -4184,7 +4190,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			char buf[64];
 
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   buf, &amp;result);</span>
<span class="p_add">+						   buf, sizeof(buf), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4214,7 +4220,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			/* throw out any old stored conf requests */
 			result = L2CAP_CONF_SUCCESS;
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   req, &amp;result);</span>
<span class="p_add">+						   req, sizeof(req), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4791,7 +4797,7 @@</span> <span class="p_context"> static void l2cap_do_create(struct l2cap_chan *chan, int result,</span>
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(chan-&gt;conn, l2cap_get_ident(chan-&gt;conn),
 				       L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 	}
<span class="p_chunk">@@ -7465,7 +7471,7 @@</span> <span class="p_context"> static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)</span>
 				set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 				l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					       L2CAP_CONF_REQ,
<span class="p_del">-					       l2cap_build_conf_req(chan, buf),</span>
<span class="p_add">+					       l2cap_build_conf_req(chan, buf, sizeof(buf)),</span>
 					       buf);
 				chan-&gt;num_conf_req++;
 			}
<span class="p_header">diff --git a/sound/isa/msnd/msnd_midi.c b/sound/isa/msnd/msnd_midi.c</span>
<span class="p_header">index 912b5a9ccbab..013d8d1170fe 100644</span>
<span class="p_header">--- a/sound/isa/msnd/msnd_midi.c</span>
<span class="p_header">+++ b/sound/isa/msnd/msnd_midi.c</span>
<span class="p_chunk">@@ -120,24 +120,24 @@</span> <span class="p_context"> void snd_msndmidi_input_read(void *mpuv)</span>
 	unsigned long flags;
 	struct snd_msndmidi *mpu = mpuv;
 	void *pwMIDQData = mpu-&gt;dev-&gt;mappedbase + MIDQ_DATA_BUFF;
<span class="p_add">+	u16 head, tail, size;</span>
 
 	spin_lock_irqsave(&amp;mpu-&gt;input_lock, flags);
<span class="p_del">-	while (readw(mpu-&gt;dev-&gt;MIDQ + JQS_wTail) !=</span>
<span class="p_del">-	       readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead)) {</span>
<span class="p_del">-		u16 wTmp, val;</span>
<span class="p_del">-		val = readw(pwMIDQData + 2 * readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead));</span>
<span class="p_del">-</span>
<span class="p_del">-			if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,</span>
<span class="p_del">-				     &amp;mpu-&gt;mode))</span>
<span class="p_del">-				snd_rawmidi_receive(mpu-&gt;substream_input,</span>
<span class="p_del">-						    (unsigned char *)&amp;val, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-		wTmp = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead) + 1;</span>
<span class="p_del">-		if (wTmp &gt; readw(mpu-&gt;dev-&gt;MIDQ + JQS_wSize))</span>
<span class="p_del">-			writew(0,  mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			writew(wTmp,  mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_add">+	head = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_add">+	tail = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wTail);</span>
<span class="p_add">+	size = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wSize);</span>
<span class="p_add">+	if (head &gt; size || tail &gt; size)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	while (head != tail) {</span>
<span class="p_add">+		unsigned char val = readw(pwMIDQData + 2 * head);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &amp;mpu-&gt;mode))</span>
<span class="p_add">+			snd_rawmidi_receive(mpu-&gt;substream_input, &amp;val, 1);</span>
<span class="p_add">+		if (++head &gt; size)</span>
<span class="p_add">+			head = 0;</span>
<span class="p_add">+		writew(head, mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
 	}
<span class="p_add">+ out:</span>
 	spin_unlock_irqrestore(&amp;mpu-&gt;input_lock, flags);
 }
 EXPORT_SYMBOL(snd_msndmidi_input_read);
<span class="p_header">diff --git a/sound/isa/msnd/msnd_pinnacle.c b/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_header">index ad4897337df5..fc4fb1904aef 100644</span>
<span class="p_header">--- a/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_header">+++ b/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_chunk">@@ -170,23 +170,24 @@</span> <span class="p_context"> static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)</span>
 {
 	struct snd_msnd *chip = dev_id;
 	void *pwDSPQData = chip-&gt;mappedbase + DSPQ_DATA_BUFF;
<span class="p_add">+	u16 head, tail, size;</span>
 
 	/* Send ack to DSP */
 	/* inb(chip-&gt;io + HP_RXL); */
 
 	/* Evaluate queued DSP messages */
<span class="p_del">-	while (readw(chip-&gt;DSPQ + JQS_wTail) != readw(chip-&gt;DSPQ + JQS_wHead)) {</span>
<span class="p_del">-		u16 wTmp;</span>
<span class="p_del">-</span>
<span class="p_del">-		snd_msnd_eval_dsp_msg(chip,</span>
<span class="p_del">-			readw(pwDSPQData + 2 * readw(chip-&gt;DSPQ + JQS_wHead)));</span>
<span class="p_del">-</span>
<span class="p_del">-		wTmp = readw(chip-&gt;DSPQ + JQS_wHead) + 1;</span>
<span class="p_del">-		if (wTmp &gt; readw(chip-&gt;DSPQ + JQS_wSize))</span>
<span class="p_del">-			writew(0, chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			writew(wTmp, chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_add">+	head = readw(chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_add">+	tail = readw(chip-&gt;DSPQ + JQS_wTail);</span>
<span class="p_add">+	size = readw(chip-&gt;DSPQ + JQS_wSize);</span>
<span class="p_add">+	if (head &gt; size || tail &gt; size)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	while (head != tail) {</span>
<span class="p_add">+		snd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));</span>
<span class="p_add">+		if (++head &gt; size)</span>
<span class="p_add">+			head = 0;</span>
<span class="p_add">+		writew(head, chip-&gt;DSPQ + JQS_wHead);</span>
 	}
<span class="p_add">+ out:</span>
 	/* Send ack to DSP */
 	inb(chip-&gt;io + HP_RXL);
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/tools/testing/selftests/x86/fsgsbase.c b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">index b4967d875236..f249e042b3b5 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_chunk">@@ -285,9 +285,12 @@</span> <span class="p_context"> static void *threadproc(void *ctx)</span>
 	}
 }
 
<span class="p_del">-static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
<span class="p_add">+static void set_gs_and_switch_to(unsigned long local,</span>
<span class="p_add">+				 unsigned short force_sel,</span>
<span class="p_add">+				 unsigned long remote)</span>
 {
 	unsigned long base;
<span class="p_add">+	unsigned short sel_pre_sched, sel_post_sched;</span>
 
 	bool hard_zero = false;
 	if (local == HARD_ZERO) {
<span class="p_chunk">@@ -297,6 +300,8 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 
 	printf(&quot;[RUN]\tARCH_SET_GS(0x%lx)%s, then schedule to 0x%lx\n&quot;,
 	       local, hard_zero ? &quot; and clear gs&quot; : &quot;&quot;, remote);
<span class="p_add">+	if (force_sel)</span>
<span class="p_add">+		printf(&quot;\tBefore schedule, set selector to 0x%hx\n&quot;, force_sel);</span>
 	if (syscall(SYS_arch_prctl, ARCH_SET_GS, local) != 0)
 		err(1, &quot;ARCH_SET_GS&quot;);
 	if (hard_zero)
<span class="p_chunk">@@ -307,18 +312,35 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 		printf(&quot;[FAIL]\tGSBASE wasn&#39;t set as expected\n&quot;);
 	}
 
<span class="p_add">+	if (force_sel) {</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+		sel_pre_sched = force_sel;</span>
<span class="p_add">+		local = read_base(GS);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Signal delivery seems to mess up weird selectors.  Put it</span>
<span class="p_add">+		 * back.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_pre_sched));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	remote_base = remote;
 	ftx = 1;
 	syscall(SYS_futex, &amp;ftx, FUTEX_WAKE, 0, NULL, NULL, 0);
 	while (ftx != 0)
 		syscall(SYS_futex, &amp;ftx, FUTEX_WAIT, 1, NULL, NULL, 0);
 
<span class="p_add">+	asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_post_sched));</span>
 	base = read_base(GS);
<span class="p_del">-	if (base == local) {</span>
<span class="p_del">-		printf(&quot;[OK]\tGSBASE remained 0x%lx\n&quot;, local);</span>
<span class="p_add">+	if (base == local &amp;&amp; sel_pre_sched == sel_post_sched) {</span>
<span class="p_add">+		printf(&quot;[OK]\tGS/BASE remained 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local);</span>
 	} else {
 		nerrs++;
<span class="p_del">-		printf(&quot;[FAIL]\tGSBASE changed to 0x%lx\n&quot;, base);</span>
<span class="p_add">+		printf(&quot;[FAIL]\tGS/BASE changed from 0x%hx/0x%lx to 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local, sel_post_sched, base);</span>
 	}
 }
 
<span class="p_chunk">@@ -381,8 +403,15 @@</span> <span class="p_context"> int main()</span>
 
 	for (int local = 0; local &lt; 4; local++) {
 		for (int remote = 0; remote &lt; 4; remote++) {
<span class="p_del">-			set_gs_and_switch_to(bases_with_hard_zero[local],</span>
<span class="p_del">-					     bases_with_hard_zero[remote]);</span>
<span class="p_add">+			for (unsigned short s = 0; s &lt; 5; s++) {</span>
<span class="p_add">+				unsigned short sel = s;</span>
<span class="p_add">+				if (s == 4)</span>
<span class="p_add">+					asm (&quot;mov %%ss, %0&quot; : &quot;=rm&quot; (sel));</span>
<span class="p_add">+				set_gs_and_switch_to(</span>
<span class="p_add">+					bases_with_hard_zero[local],</span>
<span class="p_add">+					sel,</span>
<span class="p_add">+					bases_with_hard_zero[remote]);</span>
<span class="p_add">+			}</span>
 		}
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



