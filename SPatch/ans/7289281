
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.9 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.9</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 29, 2015, 6:16 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150929181608.GB15152@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7289281/mbox/"
   >mbox</a>
|
   <a href="/patch/7289281/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7289281/">/patch/7289281/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 50BD7BEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 29 Sep 2015 18:17:15 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 7D70A20672
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 29 Sep 2015 18:17:05 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 44542204A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 29 Sep 2015 18:16:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S935455AbbI2SQm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 29 Sep 2015 14:16:42 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:41517 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S935411AbbI2SQM (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 29 Sep 2015 14:16:12 -0400
Received: from localhost (unknown [83.145.64.161])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0D4EA1D54;
	Tue, 29 Sep 2015 18:16:09 +0000 (UTC)
Date: Tue, 29 Sep 2015 20:16:08 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.9
Message-ID: &lt;20150929181608.GB15152@kroah.com&gt;
References: &lt;20150929181602.GA15152@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150929181602.GA15152@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 29, 2015, 6:16 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dbf3baa5fabb..e071176b2ce6 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 8</span>
<span class="p_add">+SUBLEVEL = 9</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/boot/compressed/decompress.c b/arch/arm/boot/compressed/decompress.c</span>
<span class="p_header">index bd245d34952d..a0765e7ed6c7 100644</span>
<span class="p_header">--- a/arch/arm/boot/compressed/decompress.c</span>
<span class="p_header">+++ b/arch/arm/boot/compressed/decompress.c</span>
<span class="p_chunk">@@ -57,5 +57,5 @@</span> <span class="p_context"> extern char * strstr(const char * s1, const char *s2);</span>
 
 int do_decompress(u8 *input, int len, u8 *output, void (*error)(char *x))
 {
<span class="p_del">-	return decompress(input, len, NULL, NULL, output, NULL, error);</span>
<span class="p_add">+	return __decompress(input, len, NULL, NULL, output, 0, NULL, error);</span>
 }
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index d9631ecddd56..d6223cbcb661 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -450,7 +450,7 @@</span> <span class="p_context"> static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)</span>
 	 * Map the VGIC hardware resources before running a vcpu the first
 	 * time on this VM.
 	 */
<span class="p_del">-	if (unlikely(!vgic_ready(kvm))) {</span>
<span class="p_add">+	if (unlikely(irqchip_in_kernel(kvm) &amp;&amp; !vgic_ready(kvm))) {</span>
 		ret = kvm_vgic_map_resources(kvm);
 		if (ret)
 			return ret;
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index 7796af4b1d6f..6f0a3b41b009 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -101,6 +101,10 @@</span> <span class="p_context"> config NO_IOPORT_MAP</span>
 config STACKTRACE_SUPPORT
 	def_bool y
 
<span class="p_add">+config ILLEGAL_POINTER_VALUE</span>
<span class="p_add">+	hex</span>
<span class="p_add">+	default 0xdead000000000000</span>
<span class="p_add">+</span>
 config LOCKDEP_SUPPORT
 	def_bool y
 
<span class="p_chunk">@@ -409,6 +413,22 @@</span> <span class="p_context"> config ARM64_ERRATUM_845719</span>
 
 	  If unsure, say Y.
 
<span class="p_add">+config ARM64_ERRATUM_843419</span>
<span class="p_add">+	bool &quot;Cortex-A53: 843419: A load or store might access an incorrect address&quot;</span>
<span class="p_add">+	depends on MODULES</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This option builds kernel modules using the large memory model in</span>
<span class="p_add">+	  order to avoid the use of the ADRP instruction, which can cause</span>
<span class="p_add">+	  a subsequent memory access to use an incorrect address on Cortex-A53</span>
<span class="p_add">+	  parts up to r0p4.</span>
<span class="p_add">+</span>
<span class="p_add">+	  Note that the kernel itself must be linked with a version of ld</span>
<span class="p_add">+	  which fixes potentially affected ADRP instructions through the</span>
<span class="p_add">+	  use of veneers.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
 endmenu
 
 
<span class="p_header">diff --git a/arch/arm64/Makefile b/arch/arm64/Makefile</span>
<span class="p_header">index 4d2a925998f9..81151663ef38 100644</span>
<span class="p_header">--- a/arch/arm64/Makefile</span>
<span class="p_header">+++ b/arch/arm64/Makefile</span>
<span class="p_chunk">@@ -30,6 +30,10 @@</span> <span class="p_context"> endif</span>
 
 CHECKFLAGS	+= -D__aarch64__
 
<span class="p_add">+ifeq ($(CONFIG_ARM64_ERRATUM_843419), y)</span>
<span class="p_add">+CFLAGS_MODULE	+= -mcmodel=large</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 # Default value
 head-y		:= arch/arm64/kernel/head.o
 
<span class="p_header">diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h</span>
<span class="p_header">index f800d45ea226..44a59c20e773 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/memory.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/memory.h</span>
<span class="p_chunk">@@ -114,6 +114,14 @@</span> <span class="p_context"> extern phys_addr_t		memstart_addr;</span>
 #define PHYS_OFFSET		({ memstart_addr; })
 
 /*
<span class="p_add">+ * The maximum physical address that the linear direct mapping</span>
<span class="p_add">+ * of system RAM can cover. (PAGE_OFFSET can be interpreted as</span>
<span class="p_add">+ * a 2&#39;s complement signed quantity and negated to derive the</span>
<span class="p_add">+ * maximum size of the linear mapping.)</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_MEMBLOCK_ADDR	({ memstart_addr - PAGE_OFFSET - 1; })</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * PFNs are used to describe any physical page; this means
  * PFN 0 == physical address 0.
  *
<span class="p_header">diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c</span>
<span class="p_header">index 3dca15634e69..c31e59fe2cb8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/fpsimd.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/fpsimd.c</span>
<span class="p_chunk">@@ -157,6 +157,7 @@</span> <span class="p_context"> void fpsimd_thread_switch(struct task_struct *next)</span>
 void fpsimd_flush_thread(void)
 {
 	memset(&amp;current-&gt;thread.fpsimd_state, 0, sizeof(struct fpsimd_state));
<span class="p_add">+	fpsimd_flush_task_state(current);</span>
 	set_thread_flag(TIF_FOREIGN_FPSTATE);
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 19f915e8f6e0..36aa31ff2c06 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -565,6 +565,11 @@</span> <span class="p_context"> CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems</span>
 	msr	hstr_el2, xzr			// Disable CP15 traps to EL2
 #endif
 
<span class="p_add">+	/* EL2 debug */</span>
<span class="p_add">+	mrs	x0, pmcr_el0			// Disable debug access traps</span>
<span class="p_add">+	ubfx	x0, x0, #11, #5			// to EL2 and allow access to</span>
<span class="p_add">+	msr	mdcr_el2, x0			// all PMU counters from EL1</span>
<span class="p_add">+</span>
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
 
<span class="p_header">diff --git a/arch/arm64/kernel/module.c b/arch/arm64/kernel/module.c</span>
<span class="p_header">index 67bf4107f6ef..876eb8df50bf 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/module.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/module.c</span>
<span class="p_chunk">@@ -332,12 +332,14 @@</span> <span class="p_context"> int apply_relocate_add(Elf64_Shdr *sechdrs,</span>
 			ovf = reloc_insn_imm(RELOC_OP_PREL, loc, val, 0, 21,
 					     AARCH64_INSN_IMM_ADR);
 			break;
<span class="p_add">+#ifndef CONFIG_ARM64_ERRATUM_843419</span>
 		case R_AARCH64_ADR_PREL_PG_HI21_NC:
 			overflow_check = false;
 		case R_AARCH64_ADR_PREL_PG_HI21:
 			ovf = reloc_insn_imm(RELOC_OP_PAGE, loc, val, 12, 21,
 					     AARCH64_INSN_IMM_ADR);
 			break;
<span class="p_add">+#endif</span>
 		case R_AARCH64_ADD_ABS_LO12_NC:
 		case R_AARCH64_LDST8_ABS_LO12_NC:
 			overflow_check = false;
<span class="p_header">diff --git a/arch/arm64/kernel/signal32.c b/arch/arm64/kernel/signal32.c</span>
<span class="p_header">index c0cff3410166..c58aee062590 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/signal32.c</span>
<span class="p_chunk">@@ -212,14 +212,32 @@</span> <span class="p_context"> int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)</span>
 
 /*
  * VFP save/restore code.
<span class="p_add">+ *</span>
<span class="p_add">+ * We have to be careful with endianness, since the fpsimd context-switch</span>
<span class="p_add">+ * code operates on 128-bit (Q) register values whereas the compat ABI</span>
<span class="p_add">+ * uses an array of 64-bit (D) registers. Consequently, we need to swap</span>
<span class="p_add">+ * the two halves of each Q register when running on a big-endian CPU.</span>
  */
<span class="p_add">+union __fpsimd_vreg {</span>
<span class="p_add">+	__uint128_t	raw;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+#ifdef __AARCH64EB__</span>
<span class="p_add">+		u64	hi;</span>
<span class="p_add">+		u64	lo;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		u64	lo;</span>
<span class="p_add">+		u64	hi;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int compat_preserve_vfp_context(struct compat_vfp_sigframe __user *frame)
 {
 	struct fpsimd_state *fpsimd = &amp;current-&gt;thread.fpsimd_state;
 	compat_ulong_t magic = VFP_MAGIC;
 	compat_ulong_t size = VFP_STORAGE_SIZE;
 	compat_ulong_t fpscr, fpexc;
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int i, err = 0;</span>
 
 	/*
 	 * Save the hardware registers to the fpsimd_state structure.
<span class="p_chunk">@@ -235,10 +253,15 @@</span> <span class="p_context"> static int compat_preserve_vfp_context(struct compat_vfp_sigframe __user *frame)</span>
 	/*
 	 * Now copy the FP registers. Since the registers are packed,
 	 * we can copy the prefix we want (V0-V15) as it is.
<span class="p_del">-	 * FIXME: Won&#39;t work if big endian.</span>
 	 */
<span class="p_del">-	err |= __copy_to_user(&amp;frame-&gt;ufp.fpregs, fpsimd-&gt;vregs,</span>
<span class="p_del">-			      sizeof(frame-&gt;ufp.fpregs));</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(frame-&gt;ufp.fpregs); i += 2) {</span>
<span class="p_add">+		union __fpsimd_vreg vreg = {</span>
<span class="p_add">+			.raw = fpsimd-&gt;vregs[i &gt;&gt; 1],</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
<span class="p_add">+		__put_user_error(vreg.lo, &amp;frame-&gt;ufp.fpregs[i], err);</span>
<span class="p_add">+		__put_user_error(vreg.hi, &amp;frame-&gt;ufp.fpregs[i + 1], err);</span>
<span class="p_add">+	}</span>
 
 	/* Create an AArch32 fpscr from the fpsr and the fpcr. */
 	fpscr = (fpsimd-&gt;fpsr &amp; VFP_FPSCR_STAT_MASK) |
<span class="p_chunk">@@ -263,7 +286,7 @@</span> <span class="p_context"> static int compat_restore_vfp_context(struct compat_vfp_sigframe __user *frame)</span>
 	compat_ulong_t magic = VFP_MAGIC;
 	compat_ulong_t size = VFP_STORAGE_SIZE;
 	compat_ulong_t fpscr;
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int i, err = 0;</span>
 
 	__get_user_error(magic, &amp;frame-&gt;magic, err);
 	__get_user_error(size, &amp;frame-&gt;size, err);
<span class="p_chunk">@@ -273,12 +296,14 @@</span> <span class="p_context"> static int compat_restore_vfp_context(struct compat_vfp_sigframe __user *frame)</span>
 	if (magic != VFP_MAGIC || size != VFP_STORAGE_SIZE)
 		return -EINVAL;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copy the FP registers into the start of the fpsimd_state.</span>
<span class="p_del">-	 * FIXME: Won&#39;t work if big endian.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	err |= __copy_from_user(fpsimd.vregs, frame-&gt;ufp.fpregs,</span>
<span class="p_del">-				sizeof(frame-&gt;ufp.fpregs));</span>
<span class="p_add">+	/* Copy the FP registers into the start of the fpsimd_state. */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(frame-&gt;ufp.fpregs); i += 2) {</span>
<span class="p_add">+		union __fpsimd_vreg vreg;</span>
<span class="p_add">+</span>
<span class="p_add">+		__get_user_error(vreg.lo, &amp;frame-&gt;ufp.fpregs[i], err);</span>
<span class="p_add">+		__get_user_error(vreg.hi, &amp;frame-&gt;ufp.fpregs[i + 1], err);</span>
<span class="p_add">+		fpsimd.vregs[i &gt;&gt; 1] = vreg.raw;</span>
<span class="p_add">+	}</span>
 
 	/* Extract the fpsr and the fpcr from the fpscr */
 	__get_user_error(fpscr, &amp;frame-&gt;ufp.fpscr, err);
<span class="p_header">diff --git a/arch/arm64/kvm/hyp.S b/arch/arm64/kvm/hyp.S</span>
<span class="p_header">index 5befd010e232..64f9e60b31da 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp.S</span>
<span class="p_chunk">@@ -844,8 +844,6 @@</span> <span class="p_context"></span>
 	mrs	x3, cntv_ctl_el0
 	and	x3, x3, #3
 	str	w3, [x0, #VCPU_TIMER_CNTV_CTL]
<span class="p_del">-	bic	x3, x3, #1		// Clear Enable</span>
<span class="p_del">-	msr	cntv_ctl_el0, x3</span>
 
 	isb
 
<span class="p_chunk">@@ -853,6 +851,9 @@</span> <span class="p_context"></span>
 	str	x3, [x0, #VCPU_TIMER_CNTV_CVAL]
 
 1:
<span class="p_add">+	// Disable the virtual timer</span>
<span class="p_add">+	msr	cntv_ctl_el0, xzr</span>
<span class="p_add">+</span>
 	// Allow physical timer/counter access for the host
 	mrs	x2, cnthctl_el2
 	orr	x2, x2, #3
<span class="p_chunk">@@ -947,13 +948,15 @@</span> <span class="p_context"> ENTRY(__kvm_vcpu_run)</span>
 	// Guest context
 	add	x2, x0, #VCPU_CONTEXT
 
<span class="p_add">+	// We must restore the 32-bit state before the sysregs, thanks</span>
<span class="p_add">+	// to Cortex-A57 erratum #852523.</span>
<span class="p_add">+	restore_guest_32bit_state</span>
 	bl __restore_sysregs
 	bl __restore_fpsimd
 
 	skip_debug_state x3, 1f
 	bl	__restore_debug
 1:
<span class="p_del">-	restore_guest_32bit_state</span>
 	restore_guest_regs
 
 	// That&#39;s it, no more messing around.
<span class="p_header">diff --git a/arch/m32r/boot/compressed/misc.c b/arch/m32r/boot/compressed/misc.c</span>
<span class="p_header">index 28a09529f206..3a7692745868 100644</span>
<span class="p_header">--- a/arch/m32r/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/m32r/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> decompress_kernel(int mmu_on, unsigned char *zimage_data,</span>
 	free_mem_end_ptr = free_mem_ptr + BOOT_HEAP_SIZE;
 
 	puts(&quot;\nDecompressing Linux... &quot;);
<span class="p_del">-	decompress(input_data, input_len, NULL, NULL, output_data, NULL, error);</span>
<span class="p_add">+	__decompress(input_data, input_len, NULL, NULL, output_data, 0,</span>
<span class="p_add">+			NULL, error);</span>
 	puts(&quot;done.\nBooting the kernel.\n&quot;);
 }
<span class="p_header">diff --git a/arch/mips/boot/compressed/decompress.c b/arch/mips/boot/compressed/decompress.c</span>
<span class="p_header">index 54831069a206..080cd53bac36 100644</span>
<span class="p_header">--- a/arch/mips/boot/compressed/decompress.c</span>
<span class="p_header">+++ b/arch/mips/boot/compressed/decompress.c</span>
<span class="p_chunk">@@ -111,8 +111,8 @@</span> <span class="p_context"> void decompress_kernel(unsigned long boot_heap_start)</span>
 	puts(&quot;\n&quot;);
 
 	/* Decompress the kernel with according algorithm */
<span class="p_del">-	decompress((char *)zimage_start, zimage_size, 0, 0,</span>
<span class="p_del">-		   (void *)VMLINUX_LOAD_ADDRESS_ULL, 0, error);</span>
<span class="p_add">+	__decompress((char *)zimage_start, zimage_size, 0, 0,</span>
<span class="p_add">+		   (void *)VMLINUX_LOAD_ADDRESS_ULL, 0, 0, error);</span>
 
 	/* FIXME: should we flush cache here? */
 	puts(&quot;Now, booting the kernel...\n&quot;);
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 6983fcd48131..2b95e34fa9e8 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -1137,7 +1137,7 @@</span> <span class="p_context"> emul:</span>
 			break;
 
 		case mfhc_op:
<span class="p_del">-			if (!cpu_has_mips_r2)</span>
<span class="p_add">+			if (!cpu_has_mips_r2_r6)</span>
 				goto sigill;
 
 			/* copregister rd -&gt; gpr[rt] */
<span class="p_chunk">@@ -1148,7 +1148,7 @@</span> <span class="p_context"> emul:</span>
 			break;
 
 		case mthc_op:
<span class="p_del">-			if (!cpu_has_mips_r2)</span>
<span class="p_add">+			if (!cpu_has_mips_r2_r6)</span>
 				goto sigill;
 
 			/* copregister rd &lt;- gpr[rt] */
<span class="p_chunk">@@ -1181,6 +1181,24 @@</span> <span class="p_context"> emul:</span>
 			}
 			break;
 
<span class="p_add">+		case bc1eqz_op:</span>
<span class="p_add">+		case bc1nez_op:</span>
<span class="p_add">+			if (!cpu_has_mips_r6 || delay_slot(xcp))</span>
<span class="p_add">+				return SIGILL;</span>
<span class="p_add">+</span>
<span class="p_add">+			cond = likely = 0;</span>
<span class="p_add">+			switch (MIPSInst_RS(ir)) {</span>
<span class="p_add">+			case bc1eqz_op:</span>
<span class="p_add">+				if (get_fpr32(&amp;current-&gt;thread.fpu.fpr[MIPSInst_RT(ir)], 0) &amp; 0x1)</span>
<span class="p_add">+				    cond = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case bc1nez_op:</span>
<span class="p_add">+				if (!(get_fpr32(&amp;current-&gt;thread.fpu.fpr[MIPSInst_RT(ir)], 0) &amp; 0x1))</span>
<span class="p_add">+				    cond = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			goto branch_common;</span>
<span class="p_add">+</span>
 		case bc_op:
 			if (delay_slot(xcp))
 				return SIGILL;
<span class="p_chunk">@@ -1207,7 +1225,7 @@</span> <span class="p_context"> emul:</span>
 			case bct_op:
 				break;
 			}
<span class="p_del">-</span>
<span class="p_add">+branch_common:</span>
 			set_delay_slot(xcp);
 			if (cond) {
 				/*
<span class="p_header">diff --git a/arch/parisc/kernel/irq.c b/arch/parisc/kernel/irq.c</span>
<span class="p_header">index f3191db6e2e9..c0eab24f6a9e 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/irq.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/irq.c</span>
<span class="p_chunk">@@ -507,8 +507,8 @@</span> <span class="p_context"> void do_cpu_irq_mask(struct pt_regs *regs)</span>
 	struct pt_regs *old_regs;
 	unsigned long eirr_val;
 	int irq, cpu = smp_processor_id();
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	struct irq_desc *desc;
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	cpumask_t dest;
 #endif
 
<span class="p_chunk">@@ -521,8 +521,12 @@</span> <span class="p_context"> void do_cpu_irq_mask(struct pt_regs *regs)</span>
 		goto set_out;
 	irq = eirr_to_irq(eirr_val);
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+	/* Filter out spurious interrupts, mostly from serial port at bootup */</span>
 	desc = irq_to_desc(irq);
<span class="p_add">+	if (unlikely(!desc-&gt;action))</span>
<span class="p_add">+		goto set_out;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	cpumask_copy(&amp;dest, desc-&gt;irq_data.affinity);
 	if (irqd_is_per_cpu(&amp;desc-&gt;irq_data) &amp;&amp;
 	    !cpumask_test_cpu(smp_processor_id(), &amp;dest)) {
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index 7ef22e3387e0..0b8d26d3ba43 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -821,7 +821,7 @@</span> <span class="p_context"> cas2_action:</span>
 	/* 64bit CAS */
 #ifdef CONFIG_64BIT
 19:	ldd,ma	0(%sr3,%r26), %r29
<span class="p_del">-	sub,=	%r29, %r25, %r0</span>
<span class="p_add">+	sub,*=	%r29, %r25, %r0</span>
 	b,n	cas2_end
 20:	std,ma	%r24, 0(%sr3,%r26)
 	copy	%r0, %r28
<span class="p_header">diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile</span>
<span class="p_header">index 73eddda53b8e..4eec430d8fa8 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/boot/Makefile</span>
<span class="p_chunk">@@ -28,6 +28,9 @@</span> <span class="p_context"> BOOTCFLAGS	+= -m64</span>
 endif
 ifdef CONFIG_CPU_BIG_ENDIAN
 BOOTCFLAGS	+= -mbig-endian
<span class="p_add">+else</span>
<span class="p_add">+BOOTCFLAGS	+= -mlittle-endian</span>
<span class="p_add">+BOOTCFLAGS	+= $(call cc-option,-mabi=elfv2)</span>
 endif
 
 BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -traditional -nostdinc
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgtable-ppc64.h b/arch/powerpc/include/asm/pgtable-ppc64.h</span>
<span class="p_header">index 43e6ad424c7f..88d27e3258d2 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgtable-ppc64.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgtable-ppc64.h</span>
<span class="p_chunk">@@ -135,7 +135,19 @@</span> <span class="p_context"></span>
 #define pte_iterate_hashed_end() } while(0)
 
 #ifdef CONFIG_PPC_HAS_HASH_64K
<span class="p_del">-#define pte_pagesize_index(mm, addr, pte)	get_slice_psize(mm, addr)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We expect this to be called only for user addresses or kernel virtual</span>
<span class="p_add">+ * addresses other than the linear mapping.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define pte_pagesize_index(mm, addr, pte)			\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		unsigned int psize;				\</span>
<span class="p_add">+		if (is_kernel_addr(addr))			\</span>
<span class="p_add">+			psize = MMU_PAGE_4K;			\</span>
<span class="p_add">+		else						\</span>
<span class="p_add">+			psize = get_slice_psize(mm, addr);	\</span>
<span class="p_add">+		psize;						\</span>
<span class="p_add">+	})</span>
 #else
 #define pte_pagesize_index(mm, addr, pte)	MMU_PAGE_4K
 #endif
<span class="p_header">diff --git a/arch/powerpc/include/asm/rtas.h b/arch/powerpc/include/asm/rtas.h</span>
<span class="p_header">index 7a4ede16b283..b77ef369c0f0 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/rtas.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/rtas.h</span>
<span class="p_chunk">@@ -343,6 +343,7 @@</span> <span class="p_context"> extern void rtas_power_off(void);</span>
 extern void rtas_halt(void);
 extern void rtas_os_term(char *str);
 extern int rtas_get_sensor(int sensor, int index, int *state);
<span class="p_add">+extern int rtas_get_sensor_fast(int sensor, int index, int *state);</span>
 extern int rtas_get_power_level(int powerdomain, int *level);
 extern int rtas_set_power_level(int powerdomain, int level, int *setlevel);
 extern bool rtas_indicator_present(int token, int *maxindex);
<span class="p_header">diff --git a/arch/powerpc/include/asm/switch_to.h b/arch/powerpc/include/asm/switch_to.h</span>
<span class="p_header">index 58abeda64cb7..15cca17cba4b 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"> static inline void save_early_sprs(struct thread_struct *prev) {}</span>
 
 extern void enable_kernel_fp(void);
 extern void enable_kernel_altivec(void);
<span class="p_add">+extern void enable_kernel_vsx(void);</span>
 extern int emulate_altivec(struct pt_regs *);
 extern void __giveup_vsx(struct task_struct *);
 extern void giveup_vsx(struct task_struct *);
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">index 9ee61d15653d..cb565ad0a5b6 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh.c</span>
<span class="p_chunk">@@ -310,11 +310,26 @@</span> <span class="p_context"> void eeh_slot_error_detail(struct eeh_pe *pe, int severity)</span>
 	if (!(pe-&gt;type &amp; EEH_PE_PHB)) {
 		if (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))
 			eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The config space of some PCI devices can&#39;t be accessed</span>
<span class="p_add">+		 * when their PEs are in frozen state. Otherwise, fenced</span>
<span class="p_add">+		 * PHB might be seen. Those PEs are identified with flag</span>
<span class="p_add">+		 * EEH_PE_CFG_RESTRICTED, indicating EEH_PE_CFG_BLOCKED</span>
<span class="p_add">+		 * is set automatically when the PE is put to EEH_PE_ISOLATED.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Restoring BARs possibly triggers PCI config access in</span>
<span class="p_add">+		 * (OPAL) firmware and then causes fenced PHB. If the</span>
<span class="p_add">+		 * PCI config is blocked with flag EEH_PE_CFG_BLOCKED, it&#39;s</span>
<span class="p_add">+		 * pointless to restore BARs and dump config space.</span>
<span class="p_add">+		 */</span>
 		eeh_ops-&gt;configure_bridge(pe);
<span class="p_del">-		eeh_pe_restore_bars(pe);</span>
<span class="p_add">+		if (!(pe-&gt;state &amp; EEH_PE_CFG_BLOCKED)) {</span>
<span class="p_add">+			eeh_pe_restore_bars(pe);</span>
 
<span class="p_del">-		pci_regs_buf[0] = 0;</span>
<span class="p_del">-		eeh_pe_traverse(pe, eeh_dump_pe_log, &amp;loglen);</span>
<span class="p_add">+			pci_regs_buf[0] = 0;</span>
<span class="p_add">+			eeh_pe_traverse(pe, eeh_dump_pe_log, &amp;loglen);</span>
<span class="p_add">+		}</span>
 	}
 
 	eeh_ops-&gt;get_log(pe, severity, pci_regs_buf, loglen);
<span class="p_chunk">@@ -1118,9 +1133,6 @@</span> <span class="p_context"> void eeh_add_device_late(struct pci_dev *dev)</span>
 		return;
 	}
 
<span class="p_del">-	if (eeh_has_flag(EEH_PROBE_MODE_DEV))</span>
<span class="p_del">-		eeh_ops-&gt;probe(pdn, NULL);</span>
<span class="p_del">-</span>
 	/*
 	 * The EEH cache might not be removed correctly because of
 	 * unbalanced kref to the device during unplug time, which
<span class="p_chunk">@@ -1144,6 +1156,9 @@</span> <span class="p_context"> void eeh_add_device_late(struct pci_dev *dev)</span>
 		dev-&gt;dev.archdata.edev = NULL;
 	}
 
<span class="p_add">+	if (eeh_has_flag(EEH_PROBE_MODE_DEV))</span>
<span class="p_add">+		eeh_ops-&gt;probe(pdn, NULL);</span>
<span class="p_add">+</span>
 	edev-&gt;pdev = dev;
 	dev-&gt;dev.archdata.edev = edev;
 
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index febb50dd5328..0596373cd1c3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -204,8 +204,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(flush_altivec_to_thread);</span>
 #endif /* CONFIG_ALTIVEC */
 
 #ifdef CONFIG_VSX
<span class="p_del">-#if 0</span>
<span class="p_del">-/* not currently used, but some crazy RAID module might want to later */</span>
 void enable_kernel_vsx(void)
 {
 	WARN_ON(preemptible());
<span class="p_chunk">@@ -220,7 +218,6 @@</span> <span class="p_context"> void enable_kernel_vsx(void)</span>
 #endif /* CONFIG_SMP */
 }
 EXPORT_SYMBOL(enable_kernel_vsx);
<span class="p_del">-#endif</span>
 
 void giveup_vsx(struct task_struct *tsk)
 {
<span class="p_header">diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">index 7a488c108410..caffb10e7aa3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/rtas.c</span>
<span class="p_chunk">@@ -584,6 +584,23 @@</span> <span class="p_context"> int rtas_get_sensor(int sensor, int index, int *state)</span>
 }
 EXPORT_SYMBOL(rtas_get_sensor);
 
<span class="p_add">+int rtas_get_sensor_fast(int sensor, int index, int *state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int token = rtas_token(&quot;get-sensor-state&quot;);</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (token == RTAS_UNKNOWN_SERVICE)</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = rtas_call(token, 2, 2, state, sensor, index);</span>
<span class="p_add">+	WARN_ON(rc == RTAS_BUSY || (rc &gt;= RTAS_EXTENDED_DELAY_MIN &amp;&amp;</span>
<span class="p_add">+				    rc &lt;= RTAS_EXTENDED_DELAY_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		return rtas_error_rc(rc);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 bool rtas_indicator_present(int token, int *maxindex)
 {
 	int proplen, count, i;
<span class="p_header">diff --git a/arch/powerpc/mm/hugepage-hash64.c b/arch/powerpc/mm/hugepage-hash64.c</span>
<span class="p_header">index 43dafb9d6a46..4d87122cf6a7 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugepage-hash64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugepage-hash64.c</span>
<span class="p_chunk">@@ -85,7 +85,6 @@</span> <span class="p_context"> int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,</span>
 	BUG_ON(index &gt;= 4096);
 
 	vpn = hpt_vpn(ea, vsid, ssize);
<span class="p_del">-	hash = hpt_hash(vpn, shift, ssize);</span>
 	hpte_slot_array = get_hpte_slot_array(pmdp);
 	if (psize == MMU_PAGE_4K) {
 		/*
<span class="p_chunk">@@ -101,6 +100,7 @@</span> <span class="p_context"> int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,</span>
 	valid = hpte_valid(hpte_slot_array, index);
 	if (valid) {
 		/* update the hpte bits */
<span class="p_add">+		hash = hpt_hash(vpn, shift, ssize);</span>
 		hidx =  hpte_hash_index(hpte_slot_array, index);
 		if (hidx &amp; _PTEIDX_SECONDARY)
 			hash = ~hash;
<span class="p_chunk">@@ -126,6 +126,7 @@</span> <span class="p_context"> int __hash_page_thp(unsigned long ea, unsigned long access, unsigned long vsid,</span>
 	if (!valid) {
 		unsigned long hpte_group;
 
<span class="p_add">+		hash = hpt_hash(vpn, shift, ssize);</span>
 		/* insert new entry */
 		pa = pmd_pfn(__pmd(old_pmd)) &lt;&lt; PAGE_SHIFT;
 		new_pmd |= _PAGE_HASHPTE;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/ras.c b/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_header">index 02e4a1745516..3b6647e574b6 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_chunk">@@ -189,7 +189,8 @@</span> <span class="p_context"> static irqreturn_t ras_epow_interrupt(int irq, void *dev_id)</span>
 	int state;
 	int critical;
 
<span class="p_del">-	status = rtas_get_sensor(EPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX, &amp;state);</span>
<span class="p_add">+	status = rtas_get_sensor_fast(EPOW_SENSOR_TOKEN, EPOW_SENSOR_INDEX,</span>
<span class="p_add">+				      &amp;state);</span>
 
 	if (state &gt; 3)
 		critical = 1;		/* Time Critical */
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_header">index df6a7041922b..e6e8b241d717 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/setup.c</span>
<span class="p_chunk">@@ -268,6 +268,11 @@</span> <span class="p_context"> static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act</span>
 			eeh_dev_init(PCI_DN(np), pci-&gt;phb);
 		}
 		break;
<span class="p_add">+	case OF_RECONFIG_DETACH_NODE:</span>
<span class="p_add">+		pci = PCI_DN(np);</span>
<span class="p_add">+		if (pci)</span>
<span class="p_add">+			list_del(&amp;pci-&gt;list);</span>
<span class="p_add">+		break;</span>
 	default:
 		err = NOTIFY_DONE;
 		break;
<span class="p_header">diff --git a/arch/s390/boot/compressed/misc.c b/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">index 42506b371b74..4da604ebf6fd 100644</span>
<span class="p_header">--- a/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/s390/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> unsigned long decompress_kernel(void)</span>
 #endif
 
 	puts(&quot;Uncompressing Linux... &quot;);
<span class="p_del">-	decompress(input_data, input_len, NULL, NULL, output, NULL, error);</span>
<span class="p_add">+	__decompress(input_data, input_len, NULL, NULL, output, 0, NULL, error);</span>
 	puts(&quot;Ok, booting the kernel.\n&quot;);
 	return (unsigned long) output;
 }
<span class="p_header">diff --git a/arch/sh/boot/compressed/misc.c b/arch/sh/boot/compressed/misc.c</span>
<span class="p_header">index 95470a472d2c..208a9753ab38 100644</span>
<span class="p_header">--- a/arch/sh/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/sh/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> void decompress_kernel(void)</span>
 
 	puts(&quot;Uncompressing Linux... &quot;);
 	cache_control(CACHE_ENABLE);
<span class="p_del">-	decompress(input_data, input_len, NULL, NULL, output, NULL, error);</span>
<span class="p_add">+	__decompress(input_data, input_len, NULL, NULL, output, 0, NULL, error);</span>
 	cache_control(CACHE_DISABLE);
 	puts(&quot;Ok, booting the kernel.\n&quot;);
 }
<span class="p_header">diff --git a/arch/unicore32/boot/compressed/misc.c b/arch/unicore32/boot/compressed/misc.c</span>
<span class="p_header">index 176d5bda3559..5c65dfee278c 100644</span>
<span class="p_header">--- a/arch/unicore32/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/unicore32/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -119,8 +119,8 @@</span> <span class="p_context"> unsigned long decompress_kernel(unsigned long output_start,</span>
 	output_ptr = get_unaligned_le32(tmp);
 
 	arch_decomp_puts(&quot;Uncompressing Linux...&quot;);
<span class="p_del">-	decompress(input_data, input_data_end - input_data, NULL, NULL,</span>
<span class="p_del">-			output_data, NULL, error);</span>
<span class="p_add">+	__decompress(input_data, input_data_end - input_data, NULL, NULL,</span>
<span class="p_add">+			output_data, 0, NULL, error);</span>
 	arch_decomp_puts(&quot; done, booting the kernel.\n&quot;);
 	return output_ptr;
 }
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">index a107b935e22f..e28437e0f708 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -424,7 +424,8 @@</span> <span class="p_context"> asmlinkage __visible void *decompress_kernel(void *rmode, memptr heap,</span>
 #endif
 
 	debug_putstr(&quot;\nDecompressing Linux... &quot;);
<span class="p_del">-	decompress(input_data, input_len, NULL, NULL, output, NULL, error);</span>
<span class="p_add">+	__decompress(input_data, input_len, NULL, NULL, output, output_len,</span>
<span class="p_add">+			NULL, error);</span>
 	parse_elf(output);
 	/*
 	 * 32-bit always performs relocations. 64-bit relocations are only
<span class="p_header">diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c</span>
<span class="p_header">index c8140e12816a..c23ab1ee3a9a 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_32.c</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> page_table_range_init_count(unsigned long start, unsigned long end)</span>
 
 	vaddr = start;
 	pgd_idx = pgd_index(vaddr);
<span class="p_add">+	pmd_idx = pmd_index(vaddr);</span>
 
 	for ( ; (pgd_idx &lt; PTRS_PER_PGD) &amp;&amp; (vaddr != end); pgd_idx++) {
 		for (; (pmd_idx &lt; PTRS_PER_PMD) &amp;&amp; (vaddr != end);
<span class="p_header">diff --git a/block/blk-mq-sysfs.c b/block/blk-mq-sysfs.c</span>
<span class="p_header">index b79685e06b70..279c5d674edf 100644</span>
<span class="p_header">--- a/block/blk-mq-sysfs.c</span>
<span class="p_header">+++ b/block/blk-mq-sysfs.c</span>
<span class="p_chunk">@@ -141,15 +141,26 @@</span> <span class="p_context"> static ssize_t blk_mq_sysfs_completed_show(struct blk_mq_ctx *ctx, char *page)</span>
 
 static ssize_t sysfs_list_show(char *page, struct list_head *list, char *msg)
 {
<span class="p_del">-	char *start_page = page;</span>
 	struct request *rq;
<span class="p_add">+	int len = snprintf(page, PAGE_SIZE - 1, &quot;%s:\n&quot;, msg);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(rq, list, queuelist) {</span>
<span class="p_add">+		const int rq_len = 2 * sizeof(rq) + 2;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* if the output will be truncated */</span>
<span class="p_add">+		if (PAGE_SIZE - 1 &lt; len + rq_len) {</span>
<span class="p_add">+			/* backspacing if it can&#39;t hold &#39;\t...\n&#39; */</span>
<span class="p_add">+			if (PAGE_SIZE - 1 &lt; len + 5)</span>
<span class="p_add">+				len -= rq_len;</span>
<span class="p_add">+			len += snprintf(page + len, PAGE_SIZE - 1 - len,</span>
<span class="p_add">+					&quot;\t...\n&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		len += snprintf(page + len, PAGE_SIZE - 1 - len,</span>
<span class="p_add">+				&quot;\t%p\n&quot;, rq);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	page += sprintf(page, &quot;%s:\n&quot;, msg);</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(rq, list, queuelist)</span>
<span class="p_del">-		page += sprintf(page, &quot;\t%p\n&quot;, rq);</span>
<span class="p_del">-</span>
<span class="p_del">-	return page - start_page;</span>
<span class="p_add">+	return len;</span>
 }
 
 static ssize_t blk_mq_sysfs_rq_list_show(struct blk_mq_ctx *ctx, char *page)
<span class="p_header">diff --git a/drivers/base/node.c b/drivers/base/node.c</span>
<span class="p_header">index a2aa65b4215d..b10479c87357 100644</span>
<span class="p_header">--- a/drivers/base/node.c</span>
<span class="p_header">+++ b/drivers/base/node.c</span>
<span class="p_chunk">@@ -388,6 +388,16 @@</span> <span class="p_context"> int register_mem_sect_under_node(struct memory_block *mem_blk, int nid)</span>
 	for (pfn = sect_start_pfn; pfn &lt;= sect_end_pfn; pfn++) {
 		int page_nid;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * memory block could have several absent sections from start.</span>
<span class="p_add">+		 * skip pfn range from absent section</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!pfn_present(pfn)) {</span>
<span class="p_add">+			pfn = round_down(pfn + PAGES_PER_SECTION,</span>
<span class="p_add">+					 PAGES_PER_SECTION) - 1;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		page_nid = get_nid_for_pfn(pfn);
 		if (page_nid &lt; 0)
 			continue;
<span class="p_header">diff --git a/drivers/crypto/vmx/aes.c b/drivers/crypto/vmx/aes.c</span>
<span class="p_header">index ab300ea19434..41f93334cc44 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/aes.c</span>
<span class="p_header">+++ b/drivers/crypto/vmx/aes.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static int p8_aes_setkey(struct crypto_tfm *tfm, const u8 *key,</span>
 
     pagefault_disable();
     enable_kernel_altivec();
<span class="p_add">+    enable_kernel_vsx();</span>
     ret = aes_p8_set_encrypt_key(key, keylen * 8, &amp;ctx-&gt;enc_key);
     ret += aes_p8_set_decrypt_key(key, keylen * 8, &amp;ctx-&gt;dec_key);
     pagefault_enable();
<span class="p_chunk">@@ -97,6 +98,7 @@</span> <span class="p_context"> static void p8_aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)</span>
     } else {
         pagefault_disable();
         enable_kernel_altivec();
<span class="p_add">+        enable_kernel_vsx();</span>
         aes_p8_encrypt(src, dst, &amp;ctx-&gt;enc_key);
         pagefault_enable();
     }
<span class="p_chunk">@@ -111,6 +113,7 @@</span> <span class="p_context"> static void p8_aes_decrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)</span>
     } else {
         pagefault_disable();
         enable_kernel_altivec();
<span class="p_add">+        enable_kernel_vsx();</span>
         aes_p8_decrypt(src, dst, &amp;ctx-&gt;dec_key);
         pagefault_enable();
     }
<span class="p_header">diff --git a/drivers/crypto/vmx/aes_cbc.c b/drivers/crypto/vmx/aes_cbc.c</span>
<span class="p_header">index 1a559b7dddb5..c8e7f653e5d3 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/aes_cbc.c</span>
<span class="p_header">+++ b/drivers/crypto/vmx/aes_cbc.c</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> static int p8_aes_cbc_setkey(struct crypto_tfm *tfm, const u8 *key,</span>
 
     pagefault_disable();
     enable_kernel_altivec();
<span class="p_add">+    enable_kernel_vsx();</span>
     ret = aes_p8_set_encrypt_key(key, keylen * 8, &amp;ctx-&gt;enc_key);
     ret += aes_p8_set_decrypt_key(key, keylen * 8, &amp;ctx-&gt;dec_key);
     pagefault_enable();
<span class="p_chunk">@@ -108,6 +109,7 @@</span> <span class="p_context"> static int p8_aes_cbc_encrypt(struct blkcipher_desc *desc,</span>
     } else {
         pagefault_disable();
         enable_kernel_altivec();
<span class="p_add">+        enable_kernel_vsx();</span>
 
 	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
         ret = blkcipher_walk_virt(desc, &amp;walk);
<span class="p_chunk">@@ -143,6 +145,7 @@</span> <span class="p_context"> static int p8_aes_cbc_decrypt(struct blkcipher_desc *desc,</span>
     } else {
         pagefault_disable();
         enable_kernel_altivec();
<span class="p_add">+        enable_kernel_vsx();</span>
 
 	blkcipher_walk_init(&amp;walk, dst, src, nbytes);
         ret = blkcipher_walk_virt(desc, &amp;walk);
<span class="p_header">diff --git a/drivers/crypto/vmx/aes_ctr.c b/drivers/crypto/vmx/aes_ctr.c</span>
<span class="p_header">index 96dbee4bf4a6..266e708d63df 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/aes_ctr.c</span>
<span class="p_header">+++ b/drivers/crypto/vmx/aes_ctr.c</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"> static int p8_aes_ctr_setkey(struct crypto_tfm *tfm, const u8 *key,</span>
 
     pagefault_disable();
     enable_kernel_altivec();
<span class="p_add">+    enable_kernel_vsx();</span>
     ret = aes_p8_set_encrypt_key(key, keylen * 8, &amp;ctx-&gt;enc_key);
     pagefault_enable();
 
<span class="p_chunk">@@ -97,6 +98,7 @@</span> <span class="p_context"> static void p8_aes_ctr_final(struct p8_aes_ctr_ctx *ctx,</span>
 
     pagefault_disable();
     enable_kernel_altivec();
<span class="p_add">+    enable_kernel_vsx();</span>
     aes_p8_encrypt(ctrblk, keystream, &amp;ctx-&gt;enc_key);
     pagefault_enable();
 
<span class="p_chunk">@@ -127,6 +129,7 @@</span> <span class="p_context"> static int p8_aes_ctr_crypt(struct blkcipher_desc *desc,</span>
         while ((nbytes = walk.nbytes) &gt;= AES_BLOCK_SIZE) {
             pagefault_disable();
             enable_kernel_altivec();
<span class="p_add">+            enable_kernel_vsx();</span>
             aes_p8_ctr32_encrypt_blocks(walk.src.virt.addr, walk.dst.virt.addr,
                 (nbytes &amp; AES_BLOCK_MASK)/AES_BLOCK_SIZE, &amp;ctx-&gt;enc_key, walk.iv);
             pagefault_enable();
<span class="p_header">diff --git a/drivers/crypto/vmx/ghash.c b/drivers/crypto/vmx/ghash.c</span>
<span class="p_header">index d0ffe277af5c..917b3f09e724 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/ghash.c</span>
<span class="p_header">+++ b/drivers/crypto/vmx/ghash.c</span>
<span class="p_chunk">@@ -116,6 +116,7 @@</span> <span class="p_context"> static int p8_ghash_setkey(struct crypto_shash *tfm, const u8 *key,</span>
 
     pagefault_disable();
     enable_kernel_altivec();
<span class="p_add">+    enable_kernel_vsx();</span>
     enable_kernel_fp();
     gcm_init_p8(ctx-&gt;htable, (const u64 *) key);
     pagefault_enable();
<span class="p_chunk">@@ -142,6 +143,7 @@</span> <span class="p_context"> static int p8_ghash_update(struct shash_desc *desc,</span>
                     GHASH_DIGEST_SIZE - dctx-&gt;bytes);
             pagefault_disable();
             enable_kernel_altivec();
<span class="p_add">+            enable_kernel_vsx();</span>
             enable_kernel_fp();
             gcm_ghash_p8(dctx-&gt;shash, ctx-&gt;htable, dctx-&gt;buffer,
                     GHASH_DIGEST_SIZE);
<span class="p_chunk">@@ -154,6 +156,7 @@</span> <span class="p_context"> static int p8_ghash_update(struct shash_desc *desc,</span>
         if (len) {
             pagefault_disable();
             enable_kernel_altivec();
<span class="p_add">+            enable_kernel_vsx();</span>
             enable_kernel_fp();
             gcm_ghash_p8(dctx-&gt;shash, ctx-&gt;htable, src, len);
             pagefault_enable();
<span class="p_chunk">@@ -182,6 +185,7 @@</span> <span class="p_context"> static int p8_ghash_final(struct shash_desc *desc, u8 *out)</span>
                 dctx-&gt;buffer[i] = 0;
             pagefault_disable();
             enable_kernel_altivec();
<span class="p_add">+            enable_kernel_vsx();</span>
             enable_kernel_fp();
             gcm_ghash_p8(dctx-&gt;shash, ctx-&gt;htable, dctx-&gt;buffer,
                     GHASH_DIGEST_SIZE);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index c097d3a82bda..a9b01bcf7d0a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -3387,6 +3387,14 @@</span> <span class="p_context"> void radeon_combios_asic_init(struct drm_device *dev)</span>
 	    rdev-&gt;pdev-&gt;subsystem_device == 0x30ae)
 		return;
 
<span class="p_add">+	/* quirk for rs4xx HP Compaq dc5750 Small Form Factor to make it resume</span>
<span class="p_add">+	 * - it hangs on resume inside the dynclk 1 table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;family == CHIP_RS480 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_vendor == 0x103c &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_device == 0x280a)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* DYN CLK 1 */
 	table = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);
 	if (table)
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs.h b/drivers/infiniband/core/uverbs.h</span>
<span class="p_header">index b716b0815644..bebf11a6622a 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs.h</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs.h</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"></span>
  */
 
 struct ib_uverbs_device {
<span class="p_del">-	struct kref				ref;</span>
<span class="p_add">+	atomic_t				refcount;</span>
 	int					num_comp_vectors;
 	struct completion			comp;
 	struct device			       *dev;
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> struct ib_uverbs_device {</span>
 	struct cdev			        cdev;
 	struct rb_root				xrcd_tree;
 	struct mutex				xrcd_tree_mutex;
<span class="p_add">+	struct kobject				kobj;</span>
 };
 
 struct ib_uverbs_event_file {
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index a9f048990dfc..ccc2494b4ea7 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -2244,6 +2244,12 @@</span> <span class="p_context"> ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,</span>
 		next-&gt;send_flags = user_wr-&gt;send_flags;
 
 		if (is_ud) {
<span class="p_add">+			if (next-&gt;opcode != IB_WR_SEND &amp;&amp;</span>
<span class="p_add">+			    next-&gt;opcode != IB_WR_SEND_WITH_IMM) {</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out_put;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			next-&gt;wr.ud.ah = idr_read_ah(user_wr-&gt;wr.ud.ah,
 						     file-&gt;ucontext);
 			if (!next-&gt;wr.ud.ah) {
<span class="p_chunk">@@ -2283,9 +2289,11 @@</span> <span class="p_context"> ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,</span>
 					user_wr-&gt;wr.atomic.compare_add;
 				next-&gt;wr.atomic.swap = user_wr-&gt;wr.atomic.swap;
 				next-&gt;wr.atomic.rkey = user_wr-&gt;wr.atomic.rkey;
<span class="p_add">+			case IB_WR_SEND:</span>
 				break;
 			default:
<span class="p_del">-				break;</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out_put;</span>
 			}
 		}
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 88cce9bb72fe..09686d49d4c1 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -129,14 +129,18 @@</span> <span class="p_context"> static int (*uverbs_ex_cmd_table[])(struct ib_uverbs_file *file,</span>
 static void ib_uverbs_add_one(struct ib_device *device);
 static void ib_uverbs_remove_one(struct ib_device *device);
 
<span class="p_del">-static void ib_uverbs_release_dev(struct kref *ref)</span>
<span class="p_add">+static void ib_uverbs_release_dev(struct kobject *kobj)</span>
 {
 	struct ib_uverbs_device *dev =
<span class="p_del">-		container_of(ref, struct ib_uverbs_device, ref);</span>
<span class="p_add">+		container_of(kobj, struct ib_uverbs_device, kobj);</span>
 
<span class="p_del">-	complete(&amp;dev-&gt;comp);</span>
<span class="p_add">+	kfree(dev);</span>
 }
 
<span class="p_add">+static struct kobj_type ib_uverbs_dev_ktype = {</span>
<span class="p_add">+	.release = ib_uverbs_release_dev,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void ib_uverbs_release_event_file(struct kref *ref)
 {
 	struct ib_uverbs_event_file *file =
<span class="p_chunk">@@ -302,13 +306,19 @@</span> <span class="p_context"> static int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,</span>
 	return context-&gt;device-&gt;dealloc_ucontext(context);
 }
 
<span class="p_add">+static void ib_uverbs_comp_dev(struct ib_uverbs_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	complete(&amp;dev-&gt;comp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ib_uverbs_release_file(struct kref *ref)
 {
 	struct ib_uverbs_file *file =
 		container_of(ref, struct ib_uverbs_file, ref);
 
 	module_put(file-&gt;device-&gt;ib_dev-&gt;owner);
<span class="p_del">-	kref_put(&amp;file-&gt;device-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;file-&gt;device-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(file-&gt;device);</span>
 
 	kfree(file);
 }
<span class="p_chunk">@@ -742,9 +752,7 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 	int ret;
 
 	dev = container_of(inode-&gt;i_cdev, struct ib_uverbs_device, cdev);
<span class="p_del">-	if (dev)</span>
<span class="p_del">-		kref_get(&amp;dev-&gt;ref);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (!atomic_inc_not_zero(&amp;dev-&gt;refcount))</span>
 		return -ENXIO;
 
 	if (!try_module_get(dev-&gt;ib_dev-&gt;owner)) {
<span class="p_chunk">@@ -765,6 +773,7 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 	mutex_init(&amp;file-&gt;mutex);
 
 	filp-&gt;private_data = file;
<span class="p_add">+	kobject_get(&amp;dev-&gt;kobj);</span>
 
 	return nonseekable_open(inode, filp);
 
<span class="p_chunk">@@ -772,13 +781,16 @@</span> <span class="p_context"> err_module:</span>
 	module_put(dev-&gt;ib_dev-&gt;owner);
 
 err:
<span class="p_del">-	kref_put(&amp;dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(dev);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
 static int ib_uverbs_close(struct inode *inode, struct file *filp)
 {
 	struct ib_uverbs_file *file = filp-&gt;private_data;
<span class="p_add">+	struct ib_uverbs_device *dev = file-&gt;device;</span>
 
 	ib_uverbs_cleanup_ucontext(file, file-&gt;ucontext);
 
<span class="p_chunk">@@ -786,6 +798,7 @@</span> <span class="p_context"> static int ib_uverbs_close(struct inode *inode, struct file *filp)</span>
 		kref_put(&amp;file-&gt;async_file-&gt;ref, ib_uverbs_release_event_file);
 
 	kref_put(&amp;file-&gt;ref, ib_uverbs_release_file);
<span class="p_add">+	kobject_put(&amp;dev-&gt;kobj);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -881,10 +894,11 @@</span> <span class="p_context"> static void ib_uverbs_add_one(struct ib_device *device)</span>
 	if (!uverbs_dev)
 		return;
 
<span class="p_del">-	kref_init(&amp;uverbs_dev-&gt;ref);</span>
<span class="p_add">+	atomic_set(&amp;uverbs_dev-&gt;refcount, 1);</span>
 	init_completion(&amp;uverbs_dev-&gt;comp);
 	uverbs_dev-&gt;xrcd_tree = RB_ROOT;
 	mutex_init(&amp;uverbs_dev-&gt;xrcd_tree_mutex);
<span class="p_add">+	kobject_init(&amp;uverbs_dev-&gt;kobj, &amp;ib_uverbs_dev_ktype);</span>
 
 	spin_lock(&amp;map_lock);
 	devnum = find_first_zero_bit(dev_map, IB_UVERBS_MAX_DEVICES);
<span class="p_chunk">@@ -911,6 +925,7 @@</span> <span class="p_context"> static void ib_uverbs_add_one(struct ib_device *device)</span>
 	cdev_init(&amp;uverbs_dev-&gt;cdev, NULL);
 	uverbs_dev-&gt;cdev.owner = THIS_MODULE;
 	uverbs_dev-&gt;cdev.ops = device-&gt;mmap ? &amp;uverbs_mmap_fops : &amp;uverbs_fops;
<span class="p_add">+	uverbs_dev-&gt;cdev.kobj.parent = &amp;uverbs_dev-&gt;kobj;</span>
 	kobject_set_name(&amp;uverbs_dev-&gt;cdev.kobj, &quot;uverbs%d&quot;, uverbs_dev-&gt;devnum);
 	if (cdev_add(&amp;uverbs_dev-&gt;cdev, base, 1))
 		goto err_cdev;
<span class="p_chunk">@@ -941,9 +956,10 @@</span> <span class="p_context"> err_cdev:</span>
 		clear_bit(devnum, overflow_map);
 
 err:
<span class="p_del">-	kref_put(&amp;uverbs_dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;uverbs_dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(uverbs_dev);</span>
 	wait_for_completion(&amp;uverbs_dev-&gt;comp);
<span class="p_del">-	kfree(uverbs_dev);</span>
<span class="p_add">+	kobject_put(&amp;uverbs_dev-&gt;kobj);</span>
 	return;
 }
 
<span class="p_chunk">@@ -963,9 +979,10 @@</span> <span class="p_context"> static void ib_uverbs_remove_one(struct ib_device *device)</span>
 	else
 		clear_bit(uverbs_dev-&gt;devnum - IB_UVERBS_MAX_DEVICES, overflow_map);
 
<span class="p_del">-	kref_put(&amp;uverbs_dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;uverbs_dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(uverbs_dev);</span>
 	wait_for_completion(&amp;uverbs_dev-&gt;comp);
<span class="p_del">-	kfree(uverbs_dev);</span>
<span class="p_add">+	kobject_put(&amp;uverbs_dev-&gt;kobj);</span>
 }
 
 static char *uverbs_devnode(struct device *dev, umode_t *mode)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index f50a546224ad..33fdd50123f7 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -148,9 +148,13 @@</span> <span class="p_context"> int mlx4_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)</span>
 	enum rdma_link_layer ll;
 
 	memset(ah_attr, 0, sizeof *ah_attr);
<span class="p_del">-	ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.ib.sl_tclass_flowlabel) &gt;&gt; 28;</span>
 	ah_attr-&gt;port_num = be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24;
 	ll = rdma_port_get_link_layer(ibah-&gt;device, ah_attr-&gt;port_num);
<span class="p_add">+	if (ll == IB_LINK_LAYER_ETHERNET)</span>
<span class="p_add">+		ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.eth.sl_tclass_flowlabel) &gt;&gt; 29;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.ib.sl_tclass_flowlabel) &gt;&gt; 28;</span>
<span class="p_add">+</span>
 	ah_attr-&gt;dlid = ll == IB_LINK_LAYER_INFINIBAND ? be16_to_cpu(ah-&gt;av.ib.dlid) : 0;
 	if (ah-&gt;av.ib.stat_rate)
 		ah_attr-&gt;static_rate = ah-&gt;av.ib.stat_rate - MLX4_STAT_RATE_OFFSET;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/cq.c b/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_header">index 0176caa5792c..2857ed89725e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> static void mlx4_ib_poll_sw_comp(struct mlx4_ib_cq *cq, int num_entries,</span>
 	 * simulated FLUSH_ERR completions
 	 */
 	list_for_each_entry(qp, &amp;cq-&gt;send_qp_list, cq_send_list) {
<span class="p_del">-		mlx4_ib_qp_sw_comp(qp, num_entries, wc, npolled, 1);</span>
<span class="p_add">+		mlx4_ib_qp_sw_comp(qp, num_entries, wc + *npolled, npolled, 1);</span>
 		if (*npolled &gt;= num_entries)
 			goto out;
 	}
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">index ed327e6c8fdc..a0559a8af4f4 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_chunk">@@ -206,15 +206,16 @@</span> <span class="p_context"> static int send_mad_to_wire(struct mlx4_ib_demux_ctx *ctx, struct ib_mad *mad)</span>
 {
 	struct mlx4_ib_dev *dev = ctx-&gt;dev;
 	struct ib_ah_attr	ah_attr;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_del">-	spin_lock(&amp;dev-&gt;sm_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;sm_lock, flags);</span>
 	if (!dev-&gt;sm_ah[ctx-&gt;port - 1]) {
 		/* port is not yet Active, sm_ah not ready */
<span class="p_del">-		spin_unlock(&amp;dev-&gt;sm_lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;dev-&gt;sm_lock, flags);</span>
 		return -EAGAIN;
 	}
 	mlx4_ib_query_ah(dev-&gt;sm_ah[ctx-&gt;port - 1], &amp;ah_attr);
<span class="p_del">-	spin_unlock(&amp;dev-&gt;sm_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;sm_lock, flags);</span>
 	return mlx4_ib_send_to_wire(dev, mlx4_master_func_num(dev-&gt;dev),
 				    ctx-&gt;port, IB_QPT_GSI, 0, 1, IB_QP1_QKEY,
 				    &amp;ah_attr, NULL, mad);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/sysfs.c b/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_header">index 6797108ce873..69fb5ba94d0f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_chunk">@@ -640,6 +640,8 @@</span> <span class="p_context"> static int add_port(struct mlx4_ib_dev *dev, int port_num, int slave)</span>
 	struct mlx4_port *p;
 	int i;
 	int ret;
<span class="p_add">+	int is_eth = rdma_port_get_link_layer(&amp;dev-&gt;ib_dev, port_num) ==</span>
<span class="p_add">+			IB_LINK_LAYER_ETHERNET;</span>
 
 	p = kzalloc(sizeof *p, GFP_KERNEL);
 	if (!p)
<span class="p_chunk">@@ -657,7 +659,8 @@</span> <span class="p_context"> static int add_port(struct mlx4_ib_dev *dev, int port_num, int slave)</span>
 
 	p-&gt;pkey_group.name  = &quot;pkey_idx&quot;;
 	p-&gt;pkey_group.attrs =
<span class="p_del">-		alloc_group_attrs(show_port_pkey, store_port_pkey,</span>
<span class="p_add">+		alloc_group_attrs(show_port_pkey,</span>
<span class="p_add">+				  is_eth ? NULL : store_port_pkey,</span>
 				  dev-&gt;dev-&gt;caps.pkey_table_len[port_num]);
 	if (!p-&gt;pkey_group.attrs) {
 		ret = -ENOMEM;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index 71c593583864..0c52f078759c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -1119,19 +1119,7 @@</span> <span class="p_context"> struct ib_mr *mlx5_ib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,</span>
 	return &amp;mr-&gt;ibmr;
 
 error:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Destroy the umem *before* destroying the MR, to ensure we</span>
<span class="p_del">-	 * will not have any in-flight notifiers when destroying the</span>
<span class="p_del">-	 * MR.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * As the MR is completely invalid to begin with, and this</span>
<span class="p_del">-	 * error path is only taken if we can&#39;t push the mr entry into</span>
<span class="p_del">-	 * the pagefault tree, this is safe.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
 	ib_umem_release(umem);
<span class="p_del">-	/* Kill the MR, and return an error code. */</span>
<span class="p_del">-	clean_mr(mr);</span>
 	return ERR_PTR(err);
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_keys.c b/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_header">index ad843c786e72..5afaa218508d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_chunk">@@ -86,6 +86,10 @@</span> <span class="p_context"> int qib_alloc_lkey(struct qib_mregion *mr, int dma_region)</span>
 	 * unrestricted LKEY.
 	 */
 	rkt-&gt;gen++;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * bits are capped in qib_verbs.c to insure enough bits</span>
<span class="p_add">+	 * for generation number</span>
<span class="p_add">+	 */</span>
 	mr-&gt;lkey = (r &lt;&lt; (32 - ib_qib_lkey_table_size)) |
 		((((1 &lt;&lt; (24 - ib_qib_lkey_table_size)) - 1) &amp; rkt-&gt;gen)
 		 &lt;&lt; 8);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">index 4a3599890ea5..9dd5d9a0556b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rculist.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/random.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 
 #include &quot;qib.h&quot;
 #include &quot;qib_common.h&quot;
<span class="p_chunk">@@ -2089,10 +2090,16 @@</span> <span class="p_context"> int qib_register_ib_device(struct qib_devdata *dd)</span>
 	 * the LKEY).  The remaining bits act as a generation number or tag.
 	 */
 	spin_lock_init(&amp;dev-&gt;lk_table.lock);
<span class="p_add">+	/* insure generation is at least 4 bits see keys.c */</span>
<span class="p_add">+	if (ib_qib_lkey_table_size &gt; MAX_LKEY_TABLE_BITS) {</span>
<span class="p_add">+		qib_dev_warn(dd, &quot;lkey bits %u too large, reduced to %u\n&quot;,</span>
<span class="p_add">+			ib_qib_lkey_table_size, MAX_LKEY_TABLE_BITS);</span>
<span class="p_add">+		ib_qib_lkey_table_size = MAX_LKEY_TABLE_BITS;</span>
<span class="p_add">+	}</span>
 	dev-&gt;lk_table.max = 1 &lt;&lt; ib_qib_lkey_table_size;
 	lk_tab_size = dev-&gt;lk_table.max * sizeof(*dev-&gt;lk_table.table);
 	dev-&gt;lk_table.table = (struct qib_mregion __rcu **)
<span class="p_del">-		__get_free_pages(GFP_KERNEL, get_order(lk_tab_size));</span>
<span class="p_add">+		vmalloc(lk_tab_size);</span>
 	if (dev-&gt;lk_table.table == NULL) {
 		ret = -ENOMEM;
 		goto err_lk;
<span class="p_chunk">@@ -2265,7 +2272,7 @@</span> <span class="p_context"> err_tx:</span>
 					sizeof(struct qib_pio_header),
 				  dev-&gt;pio_hdrs, dev-&gt;pio_hdrs_phys);
 err_hdrs:
<span class="p_del">-	free_pages((unsigned long) dev-&gt;lk_table.table, get_order(lk_tab_size));</span>
<span class="p_add">+	vfree(dev-&gt;lk_table.table);</span>
 err_lk:
 	kfree(dev-&gt;qp_table);
 err_qpt:
<span class="p_chunk">@@ -2319,8 +2326,7 @@</span> <span class="p_context"> void qib_unregister_ib_device(struct qib_devdata *dd)</span>
 					sizeof(struct qib_pio_header),
 				  dev-&gt;pio_hdrs, dev-&gt;pio_hdrs_phys);
 	lk_tab_size = dev-&gt;lk_table.max * sizeof(*dev-&gt;lk_table.table);
<span class="p_del">-	free_pages((unsigned long) dev-&gt;lk_table.table,</span>
<span class="p_del">-		   get_order(lk_tab_size));</span>
<span class="p_add">+	vfree(dev-&gt;lk_table.table);</span>
 	kfree(dev-&gt;qp_table);
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs.h b/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_header">index bfc8948fdd35..44ca28c83fe6 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_chunk">@@ -647,6 +647,8 @@</span> <span class="p_context"> struct qib_qpn_table {</span>
 	struct qpn_map map[QPNMAP_ENTRIES];
 };
 
<span class="p_add">+#define MAX_LKEY_TABLE_BITS 23</span>
<span class="p_add">+</span>
 struct qib_lkey_table {
 	spinlock_t lock; /* protect changes in this struct */
 	u32 next;               /* next unused index (speeds search) */
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_header">index 6a594aac2290..c933d882c35c 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c</span>
<span class="p_chunk">@@ -201,6 +201,7 @@</span> <span class="p_context"> iser_initialize_task_headers(struct iscsi_task *task,</span>
 		goto out;
 	}
 
<span class="p_add">+	tx_desc-&gt;mapped = true;</span>
 	tx_desc-&gt;dma_addr = dma_addr;
 	tx_desc-&gt;tx_sg[0].addr   = tx_desc-&gt;dma_addr;
 	tx_desc-&gt;tx_sg[0].length = ISER_HEADERS_LEN;
<span class="p_chunk">@@ -360,16 +361,19 @@</span> <span class="p_context"> iscsi_iser_task_xmit(struct iscsi_task *task)</span>
 static void iscsi_iser_cleanup_task(struct iscsi_task *task)
 {
 	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
<span class="p_del">-	struct iser_tx_desc    *tx_desc   = &amp;iser_task-&gt;desc;</span>
<span class="p_del">-	struct iser_conn       *iser_conn	  = task-&gt;conn-&gt;dd_data;</span>
<span class="p_add">+	struct iser_tx_desc *tx_desc = &amp;iser_task-&gt;desc;</span>
<span class="p_add">+	struct iser_conn *iser_conn = task-&gt;conn-&gt;dd_data;</span>
 	struct iser_device *device = iser_conn-&gt;ib_conn.device;
 
 	/* DEVICE_REMOVAL event might have already released the device */
 	if (!device)
 		return;
 
<span class="p_del">-	ib_dma_unmap_single(device-&gt;ib_device,</span>
<span class="p_del">-		tx_desc-&gt;dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);</span>
<span class="p_add">+	if (likely(tx_desc-&gt;mapped)) {</span>
<span class="p_add">+		ib_dma_unmap_single(device-&gt;ib_device, tx_desc-&gt;dma_addr,</span>
<span class="p_add">+				    ISER_HEADERS_LEN, DMA_TO_DEVICE);</span>
<span class="p_add">+		tx_desc-&gt;mapped = false;</span>
<span class="p_add">+	}</span>
 
 	/* mgmt tasks do not need special cleanup */
 	if (!task-&gt;sc)
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">index 262ba1f8ee50..d2b6caf7694d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_chunk">@@ -270,6 +270,7 @@</span> <span class="p_context"> enum iser_desc_type {</span>
  *                 sg[1] optionally points to either of immediate data
  *                 unsolicited data-out or control
  * @num_sge:       number sges used on this TX task
<span class="p_add">+ * @mapped:        Is the task header mapped</span>
  */
 struct iser_tx_desc {
 	struct iser_hdr              iser_header;
<span class="p_chunk">@@ -278,6 +279,7 @@</span> <span class="p_context"> struct iser_tx_desc {</span>
 	u64		             dma_addr;
 	struct ib_sge		     tx_sg[2];
 	int                          num_sge;
<span class="p_add">+	bool			     mapped;</span>
 };
 
 #define ISER_RX_PAD_SIZE	(256 - (ISER_RX_PAYLOAD_SIZE + \
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">index 3e2118e8ed87..0a47f42fec24 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_chunk">@@ -454,7 +454,7 @@</span> <span class="p_context"> int iser_send_data_out(struct iscsi_conn *conn,</span>
 	unsigned long buf_offset;
 	unsigned long data_seg_len;
 	uint32_t itt;
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int err;</span>
 	struct ib_sge *tx_dsg;
 
 	itt = (__force uint32_t)hdr-&gt;itt;
<span class="p_chunk">@@ -475,7 +475,9 @@</span> <span class="p_context"> int iser_send_data_out(struct iscsi_conn *conn,</span>
 	memcpy(&amp;tx_desc-&gt;iscsi_header, hdr, sizeof(struct iscsi_hdr));
 
 	/* build the tx desc */
<span class="p_del">-	iser_initialize_task_headers(task, tx_desc);</span>
<span class="p_add">+	err = iser_initialize_task_headers(task, tx_desc);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto send_data_out_error;</span>
 
 	mem_reg = &amp;iser_task-&gt;rdma_reg[ISER_DIR_OUT];
 	tx_dsg = &amp;tx_desc-&gt;tx_sg[1];
<span class="p_chunk">@@ -502,7 +504,7 @@</span> <span class="p_context"> int iser_send_data_out(struct iscsi_conn *conn,</span>
 
 send_data_out_error:
 	kmem_cache_free(ig.desc_cache, tx_desc);
<span class="p_del">-	iser_err(&quot;conn %p failed err %d\n&quot;,conn, err);</span>
<span class="p_add">+	iser_err(&quot;conn %p failed err %d\n&quot;, conn, err);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 75c01b27bd0b..025f93105444 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -2761,6 +2761,13 @@</span> <span class="p_context"> static int srp_sdev_count(struct Scsi_Host *host)</span>
 	return c;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Return values:</span>
<span class="p_add">+ * &lt; 0 upon failure. Caller is responsible for SRP target port cleanup.</span>
<span class="p_add">+ * 0 and target-&gt;state == SRP_TARGET_REMOVED if asynchronous target port</span>
<span class="p_add">+ *    removal has been scheduled.</span>
<span class="p_add">+ * 0 and target-&gt;state != SRP_TARGET_REMOVED upon success.</span>
<span class="p_add">+ */</span>
 static int srp_add_target(struct srp_host *host, struct srp_target_port *target)
 {
 	struct srp_rport_identifiers ids;
<span class="p_chunk">@@ -3266,7 +3273,7 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 					srp_free_ch_ib(target, ch);
 					srp_free_req_data(target, ch);
 					target-&gt;ch_count = ch - target-&gt;ch;
<span class="p_del">-					break;</span>
<span class="p_add">+					goto connected;</span>
 				}
 			}
 
<span class="p_chunk">@@ -3276,6 +3283,7 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 		node_idx++;
 	}
 
<span class="p_add">+connected:</span>
 	target-&gt;scsi_host-&gt;nr_hw_queues = target-&gt;ch_count;
 
 	ret = srp_add_target(host, target);
<span class="p_chunk">@@ -3298,6 +3306,8 @@</span> <span class="p_context"> out:</span>
 	mutex_unlock(&amp;host-&gt;add_target_mutex);
 
 	scsi_host_put(target-&gt;scsi_host);
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		scsi_host_put(target-&gt;scsi_host);</span>
 
 	return ret;
 
<span class="p_header">diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c</span>
<span class="p_header">index a18f41b89b6a..2ae522f0d2b2 100644</span>
<span class="p_header">--- a/drivers/input/evdev.c</span>
<span class="p_header">+++ b/drivers/input/evdev.c</span>
<span class="p_chunk">@@ -290,19 +290,14 @@</span> <span class="p_context"> static int evdev_flush(struct file *file, fl_owner_t id)</span>
 {
 	struct evdev_client *client = file-&gt;private_data;
 	struct evdev *evdev = client-&gt;evdev;
<span class="p_del">-	int retval;</span>
 
<span class="p_del">-	retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span>
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		return retval;</span>
<span class="p_add">+	mutex_lock(&amp;evdev-&gt;mutex);</span>
 
<span class="p_del">-	if (!evdev-&gt;exist || client-&gt;revoked)</span>
<span class="p_del">-		retval = -ENODEV;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		retval = input_flush_device(&amp;evdev-&gt;handle, file);</span>
<span class="p_add">+	if (evdev-&gt;exist &amp;&amp; !client-&gt;revoked)</span>
<span class="p_add">+		input_flush_device(&amp;evdev-&gt;handle, file);</span>
 
 	mutex_unlock(&amp;evdev-&gt;mutex);
<span class="p_del">-	return retval;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void evdev_free(struct device *dev)
<span class="p_header">diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c</span>
<span class="p_header">index abeedc9a78c2..2570f2a25dc4 100644</span>
<span class="p_header">--- a/drivers/iommu/fsl_pamu.c</span>
<span class="p_header">+++ b/drivers/iommu/fsl_pamu.c</span>
<span class="p_chunk">@@ -41,7 +41,6 @@</span> <span class="p_context"> struct pamu_isr_data {</span>
 
 static struct paace *ppaact;
 static struct paace *spaact;
<span class="p_del">-static struct ome *omt __initdata;</span>
 
 /*
  * Table for matching compatible strings, for device tree
<span class="p_chunk">@@ -50,7 +49,7 @@</span> <span class="p_context"> static struct ome *omt __initdata;</span>
  * SOCs. For the older SOCs &quot;fsl,qoriq-device-config-1.0&quot;
  * string would be used.
  */
<span class="p_del">-static const struct of_device_id guts_device_ids[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id guts_device_ids[] = {</span>
 	{ .compatible = &quot;fsl,qoriq-device-config-1.0&quot;, },
 	{ .compatible = &quot;fsl,qoriq-device-config-2.0&quot;, },
 	{}
<span class="p_chunk">@@ -599,7 +598,7 @@</span> <span class="p_context"> found_cpu_node:</span>
  * Memory accesses to QMAN and BMAN private memory need not be coherent, so
  * clear the PAACE entry coherency attribute for them.
  */
<span class="p_del">-static void __init setup_qbman_paace(struct paace *ppaace, int  paace_type)</span>
<span class="p_add">+static void setup_qbman_paace(struct paace *ppaace, int  paace_type)</span>
 {
 	switch (paace_type) {
 	case QMAN_PAACE:
<span class="p_chunk">@@ -629,7 +628,7 @@</span> <span class="p_context"> static void __init setup_qbman_paace(struct paace *ppaace, int  paace_type)</span>
  * this table to translate device transaction to appropriate corenet
  * transaction.
  */
<span class="p_del">-static void __init setup_omt(struct ome *omt)</span>
<span class="p_add">+static void setup_omt(struct ome *omt)</span>
 {
 	struct ome *ome;
 
<span class="p_chunk">@@ -666,7 +665,7 @@</span> <span class="p_context"> static void __init setup_omt(struct ome *omt)</span>
  * Get the maximum number of PAACT table entries
  * and subwindows supported by PAMU
  */
<span class="p_del">-static void __init get_pamu_cap_values(unsigned long pamu_reg_base)</span>
<span class="p_add">+static void get_pamu_cap_values(unsigned long pamu_reg_base)</span>
 {
 	u32 pc_val;
 
<span class="p_chunk">@@ -676,9 +675,9 @@</span> <span class="p_context"> static void __init get_pamu_cap_values(unsigned long pamu_reg_base)</span>
 }
 
 /* Setup PAMU registers pointing to PAACT, SPAACT and OMT */
<span class="p_del">-static int __init setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,</span>
<span class="p_del">-				 phys_addr_t ppaact_phys, phys_addr_t spaact_phys,</span>
<span class="p_del">-				 phys_addr_t omt_phys)</span>
<span class="p_add">+static int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,</span>
<span class="p_add">+			  phys_addr_t ppaact_phys, phys_addr_t spaact_phys,</span>
<span class="p_add">+			  phys_addr_t omt_phys)</span>
 {
 	u32 *pc;
 	struct pamu_mmap_regs *pamu_regs;
<span class="p_chunk">@@ -720,7 +719,7 @@</span> <span class="p_context"> static int __init setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu</span>
 }
 
 /* Enable all device LIODNS */
<span class="p_del">-static void __init setup_liodns(void)</span>
<span class="p_add">+static void setup_liodns(void)</span>
 {
 	int i, len;
 	struct paace *ppaace;
<span class="p_chunk">@@ -846,7 +845,7 @@</span> <span class="p_context"> struct ccsr_law {</span>
 /*
  * Create a coherence subdomain for a given memory block.
  */
<span class="p_del">-static int __init create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)</span>
<span class="p_add">+static int create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)</span>
 {
 	struct device_node *np;
 	const __be32 *iprop;
<span class="p_chunk">@@ -988,7 +987,7 @@</span> <span class="p_context"> error:</span>
 static const struct {
 	u32 svr;
 	u32 port_id;
<span class="p_del">-} port_id_map[] __initconst = {</span>
<span class="p_add">+} port_id_map[] = {</span>
 	{(SVR_P2040 &lt;&lt; 8) | 0x10, 0xFF000000},	/* P2040 1.0 */
 	{(SVR_P2040 &lt;&lt; 8) | 0x11, 0xFF000000},	/* P2040 1.1 */
 	{(SVR_P2041 &lt;&lt; 8) | 0x10, 0xFF000000},	/* P2041 1.0 */
<span class="p_chunk">@@ -1006,7 +1005,7 @@</span> <span class="p_context"> static const struct {</span>
 
 #define SVR_SECURITY	0x80000	/* The Security (E) bit */
 
<span class="p_del">-static int __init fsl_pamu_probe(struct platform_device *pdev)</span>
<span class="p_add">+static int fsl_pamu_probe(struct platform_device *pdev)</span>
 {
 	struct device *dev = &amp;pdev-&gt;dev;
 	void __iomem *pamu_regs = NULL;
<span class="p_chunk">@@ -1022,6 +1021,7 @@</span> <span class="p_context"> static int __init fsl_pamu_probe(struct platform_device *pdev)</span>
 	int irq;
 	phys_addr_t ppaact_phys;
 	phys_addr_t spaact_phys;
<span class="p_add">+	struct ome *omt;</span>
 	phys_addr_t omt_phys;
 	size_t mem_size = 0;
 	unsigned int order = 0;
<span class="p_chunk">@@ -1200,7 +1200,7 @@</span> <span class="p_context"> error:</span>
 	return ret;
 }
 
<span class="p_del">-static struct platform_driver fsl_of_pamu_driver __initdata = {</span>
<span class="p_add">+static struct platform_driver fsl_of_pamu_driver = {</span>
 	.driver = {
 		.name = &quot;fsl-of-pamu&quot;,
 	},
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index c87c4b1bfc00..c23427951ec1 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -681,6 +681,7 @@</span> <span class="p_context"> static inline struct context_entry *iommu_context_addr(struct intel_iommu *iommu</span>
 	struct context_entry *context;
 	u64 *entry;
 
<span class="p_add">+	entry = &amp;root-&gt;lo;</span>
 	if (ecs_enabled(iommu)) {
 		if (devfn &gt;= 0x80) {
 			devfn -= 0x80;
<span class="p_chunk">@@ -688,7 +689,6 @@</span> <span class="p_context"> static inline struct context_entry *iommu_context_addr(struct intel_iommu *iommu</span>
 		}
 		devfn *= 2;
 	}
<span class="p_del">-	entry = &amp;root-&gt;lo;</span>
 	if (*entry &amp; 1)
 		context = phys_to_virt(*entry &amp; VTD_PAGE_MASK);
 	else {
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index 4e460216bd16..e29d5d7fe220 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -200,6 +200,10 @@</span> <span class="p_context"> typedef u64 arm_lpae_iopte;</span>
 
 static bool selftest_running = false;
 
<span class="p_add">+static int __arm_lpae_unmap(struct arm_lpae_io_pgtable *data,</span>
<span class="p_add">+			    unsigned long iova, size_t size, int lvl,</span>
<span class="p_add">+			    arm_lpae_iopte *ptep);</span>
<span class="p_add">+</span>
 static int arm_lpae_init_pte(struct arm_lpae_io_pgtable *data,
 			     unsigned long iova, phys_addr_t paddr,
 			     arm_lpae_iopte prot, int lvl,
<span class="p_chunk">@@ -207,10 +211,21 @@</span> <span class="p_context"> static int arm_lpae_init_pte(struct arm_lpae_io_pgtable *data,</span>
 {
 	arm_lpae_iopte pte = prot;
 
<span class="p_del">-	/* We require an unmap first */</span>
 	if (iopte_leaf(*ptep, lvl)) {
<span class="p_add">+		/* We require an unmap first */</span>
 		WARN_ON(!selftest_running);
 		return -EEXIST;
<span class="p_add">+	} else if (iopte_type(*ptep, lvl) == ARM_LPAE_PTE_TYPE_TABLE) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need to unmap and free the old table before</span>
<span class="p_add">+		 * overwriting it with a block entry.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		arm_lpae_iopte *tblp;</span>
<span class="p_add">+		size_t sz = ARM_LPAE_BLOCK_SIZE(lvl, data);</span>
<span class="p_add">+</span>
<span class="p_add">+		tblp = ptep - ARM_LPAE_LVL_IDX(iova, lvl, data);</span>
<span class="p_add">+		if (WARN_ON(__arm_lpae_unmap(data, iova, sz, lvl, tblp) != sz))</span>
<span class="p_add">+			return -EINVAL;</span>
 	}
 
 	if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)
<span class="p_header">diff --git a/drivers/iommu/tegra-smmu.c b/drivers/iommu/tegra-smmu.c</span>
<span class="p_header">index c845d99ecf6b..e0ff5f4d7fed 100644</span>
<span class="p_header">--- a/drivers/iommu/tegra-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/tegra-smmu.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> struct tegra_smmu {</span>
 	const struct tegra_smmu_soc *soc;
 
 	unsigned long pfn_mask;
<span class="p_add">+	unsigned long tlb_mask;</span>
 
 	unsigned long *asids;
 	struct mutex lock;
<span class="p_chunk">@@ -65,7 +66,8 @@</span> <span class="p_context"> static inline u32 smmu_readl(struct tegra_smmu *smmu, unsigned long offset)</span>
 #define SMMU_TLB_CONFIG 0x14
 #define  SMMU_TLB_CONFIG_HIT_UNDER_MISS (1 &lt;&lt; 29)
 #define  SMMU_TLB_CONFIG_ROUND_ROBIN_ARBITRATION (1 &lt;&lt; 28)
<span class="p_del">-#define  SMMU_TLB_CONFIG_ACTIVE_LINES(x) ((x) &amp; 0x3f)</span>
<span class="p_add">+#define  SMMU_TLB_CONFIG_ACTIVE_LINES(smmu) \</span>
<span class="p_add">+	((smmu)-&gt;soc-&gt;num_tlb_lines &amp; (smmu)-&gt;tlb_mask)</span>
 
 #define SMMU_PTC_CONFIG 0x18
 #define  SMMU_PTC_CONFIG_ENABLE (1 &lt;&lt; 29)
<span class="p_chunk">@@ -716,6 +718,9 @@</span> <span class="p_context"> struct tegra_smmu *tegra_smmu_probe(struct device *dev,</span>
 	smmu-&gt;pfn_mask = BIT_MASK(mc-&gt;soc-&gt;num_address_bits - PAGE_SHIFT) - 1;
 	dev_dbg(dev, &quot;address bits: %u, PFN mask: %#lx\n&quot;,
 		mc-&gt;soc-&gt;num_address_bits, smmu-&gt;pfn_mask);
<span class="p_add">+	smmu-&gt;tlb_mask = (smmu-&gt;soc-&gt;num_tlb_lines &lt;&lt; 1) - 1;</span>
<span class="p_add">+	dev_dbg(dev, &quot;TLB lines: %u, mask: %#lx\n&quot;, smmu-&gt;soc-&gt;num_tlb_lines,</span>
<span class="p_add">+		smmu-&gt;tlb_mask);</span>
 
 	value = SMMU_PTC_CONFIG_ENABLE | SMMU_PTC_CONFIG_INDEX_MAP(0x3f);
 
<span class="p_chunk">@@ -725,7 +730,7 @@</span> <span class="p_context"> struct tegra_smmu *tegra_smmu_probe(struct device *dev,</span>
 	smmu_writel(smmu, value, SMMU_PTC_CONFIG);
 
 	value = SMMU_TLB_CONFIG_HIT_UNDER_MISS |
<span class="p_del">-		SMMU_TLB_CONFIG_ACTIVE_LINES(0x20);</span>
<span class="p_add">+		SMMU_TLB_CONFIG_ACTIVE_LINES(smmu);</span>
 
 	if (soc-&gt;supports_round_robin_arbitration)
 		value |= SMMU_TLB_CONFIG_ROUND_ROBIN_ARBITRATION;
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 8c91fd5eb6fd..3ac9c4194814 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -524,9 +524,18 @@</span> <span class="p_context"> gigaset_tty_open(struct tty_struct *tty)</span>
 	cs-&gt;hw.ser-&gt;tty = tty;
 	atomic_set(&amp;cs-&gt;hw.ser-&gt;refcnt, 1);
 	init_completion(&amp;cs-&gt;hw.ser-&gt;dead_cmp);
<span class="p_del">-</span>
 	tty-&gt;disc_data = cs;
 
<span class="p_add">+	/* Set the amount of data we&#39;re willing to receive per call</span>
<span class="p_add">+	 * from the hardware driver to half of the input buffer size</span>
<span class="p_add">+	 * to leave some reserve.</span>
<span class="p_add">+	 * Note: We don&#39;t do flow control towards the hardware driver.</span>
<span class="p_add">+	 * If more data is received than will fit into the input buffer,</span>
<span class="p_add">+	 * it will be dropped and an error will be logged. This should</span>
<span class="p_add">+	 * never happen as the device is slow and the buffer size ample.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tty-&gt;receive_room = RBUFSIZE/2;</span>
<span class="p_add">+</span>
 	/* OK.. Initialization of the datastructures and the HW is done.. Now
 	 * startup system and notify the LL that we are ready to run
 	 */
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index e4621511d118..e8c44fcb1ad1 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5365,6 +5365,8 @@</span> <span class="p_context"> static void __md_stop(struct mddev *mddev)</span>
 {
 	struct md_personality *pers = mddev-&gt;pers;
 	mddev_detach(mddev);
<span class="p_add">+	/* Ensure -&gt;event_work is done */</span>
<span class="p_add">+	flush_workqueue(md_misc_wq);</span>
 	spin_lock(&amp;mddev-&gt;lock);
 	mddev-&gt;ready = 0;
 	mddev-&gt;pers = NULL;
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index f55c3f35b746..fe0122771642 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -3566,6 +3566,7 @@</span> <span class="p_context"> static struct r10conf *setup_conf(struct mddev *mddev)</span>
 			/* far_copies must be 1 */
 			conf-&gt;prev.stride = conf-&gt;dev_sectors;
 	}
<span class="p_add">+	conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 	spin_lock_init(&amp;conf-&gt;device_lock);
 	INIT_LIST_HEAD(&amp;conf-&gt;retry_list);
 
<span class="p_chunk">@@ -3770,7 +3771,6 @@</span> <span class="p_context"> static int run(struct mddev *mddev)</span>
 		}
 		conf-&gt;offset_diff = min_offset_diff;
 
<span class="p_del">-		conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 		clear_bit(MD_RECOVERY_SYNC, &amp;mddev-&gt;recovery);
 		clear_bit(MD_RECOVERY_CHECK, &amp;mddev-&gt;recovery);
 		set_bit(MD_RECOVERY_RESHAPE, &amp;mddev-&gt;recovery);
<span class="p_chunk">@@ -4113,6 +4113,7 @@</span> <span class="p_context"> static int raid10_start_reshape(struct mddev *mddev)</span>
 		conf-&gt;reshape_progress = size;
 	} else
 		conf-&gt;reshape_progress = 0;
<span class="p_add">+	conf-&gt;reshape_safe = conf-&gt;reshape_progress;</span>
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 
 	if (mddev-&gt;delta_disks &amp;&amp; mddev-&gt;bitmap) {
<span class="p_chunk">@@ -4180,6 +4181,7 @@</span> <span class="p_context"> abort:</span>
 		rdev-&gt;new_data_offset = rdev-&gt;data_offset;
 	smp_wmb();
 	conf-&gt;reshape_progress = MaxSector;
<span class="p_add">+	conf-&gt;reshape_safe = MaxSector;</span>
 	mddev-&gt;reshape_position = MaxSector;
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 	return ret;
<span class="p_chunk">@@ -4534,6 +4536,7 @@</span> <span class="p_context"> static void end_reshape(struct r10conf *conf)</span>
 	md_finish_reshape(conf-&gt;mddev);
 	smp_wmb();
 	conf-&gt;reshape_progress = MaxSector;
<span class="p_add">+	conf-&gt;reshape_safe = MaxSector;</span>
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 
 	/* read-ahead size must cover two whole stripes, which is
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index b6793d2e051f..23af6772f146 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -2151,6 +2151,9 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 	if (!sc)
 		return -ENOMEM;
 
<span class="p_add">+	/* Need to ensure auto-resizing doesn&#39;t interfere */</span>
<span class="p_add">+	mutex_lock(&amp;conf-&gt;cache_size_mutex);</span>
<span class="p_add">+</span>
 	for (i = conf-&gt;max_nr_stripes; i; i--) {
 		nsh = alloc_stripe(sc, GFP_KERNEL);
 		if (!nsh)
<span class="p_chunk">@@ -2167,6 +2170,7 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 			kmem_cache_free(sc, nsh);
 		}
 		kmem_cache_destroy(sc);
<span class="p_add">+		mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 		return -ENOMEM;
 	}
 	/* Step 2 - Must use GFP_NOIO now.
<span class="p_chunk">@@ -2213,6 +2217,7 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 	} else
 		err = -ENOMEM;
 
<span class="p_add">+	mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 	/* Step 4, return new stripes to service */
 	while(!list_empty(&amp;newstripes)) {
 		nsh = list_entry(newstripes.next, struct stripe_head, lru);
<span class="p_chunk">@@ -2240,7 +2245,7 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 static int drop_one_stripe(struct r5conf *conf)
 {
 	struct stripe_head *sh;
<span class="p_del">-	int hash = (conf-&gt;max_nr_stripes - 1) % NR_STRIPE_HASH_LOCKS;</span>
<span class="p_add">+	int hash = (conf-&gt;max_nr_stripes - 1) &amp; STRIPE_HASH_LOCKS_MASK;</span>
 
 	spin_lock_irq(conf-&gt;hash_locks + hash);
 	sh = get_free_stripe(conf, hash);
<span class="p_chunk">@@ -5846,12 +5851,14 @@</span> <span class="p_context"> static void raid5d(struct md_thread *thread)</span>
 	pr_debug(&quot;%d stripes handled\n&quot;, handled);
 
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
<span class="p_del">-	if (test_and_clear_bit(R5_ALLOC_MORE, &amp;conf-&gt;cache_state)) {</span>
<span class="p_add">+	if (test_and_clear_bit(R5_ALLOC_MORE, &amp;conf-&gt;cache_state) &amp;&amp;</span>
<span class="p_add">+	    mutex_trylock(&amp;conf-&gt;cache_size_mutex)) {</span>
 		grow_one_stripe(conf, __GFP_NOWARN);
 		/* Set flag even if allocation failed.  This helps
 		 * slow down allocation requests when mem is short
 		 */
 		set_bit(R5_DID_ALLOC, &amp;conf-&gt;cache_state);
<span class="p_add">+		mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 	}
 
 	async_tx_issue_pending_all();
<span class="p_chunk">@@ -5883,18 +5890,22 @@</span> <span class="p_context"> raid5_set_cache_size(struct mddev *mddev, int size)</span>
 		return -EINVAL;
 
 	conf-&gt;min_nr_stripes = size;
<span class="p_add">+	mutex_lock(&amp;conf-&gt;cache_size_mutex);</span>
 	while (size &lt; conf-&gt;max_nr_stripes &amp;&amp;
 	       drop_one_stripe(conf))
 		;
<span class="p_add">+	mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 
 
 	err = md_allow_write(mddev);
 	if (err)
 		return err;
 
<span class="p_add">+	mutex_lock(&amp;conf-&gt;cache_size_mutex);</span>
 	while (size &gt; conf-&gt;max_nr_stripes)
 		if (!grow_one_stripe(conf, GFP_KERNEL))
 			break;
<span class="p_add">+	mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -6360,11 +6371,19 @@</span> <span class="p_context"> static unsigned long raid5_cache_scan(struct shrinker *shrink,</span>
 				      struct shrink_control *sc)
 {
 	struct r5conf *conf = container_of(shrink, struct r5conf, shrinker);
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	while (ret &lt; sc-&gt;nr_to_scan) {</span>
<span class="p_del">-		if (drop_one_stripe(conf) == 0)</span>
<span class="p_del">-			return SHRINK_STOP;</span>
<span class="p_del">-		ret++;</span>
<span class="p_add">+	unsigned long ret = SHRINK_STOP;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mutex_trylock(&amp;conf-&gt;cache_size_mutex)) {</span>
<span class="p_add">+		ret= 0;</span>
<span class="p_add">+		while (ret &lt; sc-&gt;nr_to_scan &amp;&amp;</span>
<span class="p_add">+		       conf-&gt;max_nr_stripes &gt; conf-&gt;min_nr_stripes) {</span>
<span class="p_add">+			if (drop_one_stripe(conf) == 0) {</span>
<span class="p_add">+				ret = SHRINK_STOP;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			ret++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mutex_unlock(&amp;conf-&gt;cache_size_mutex);</span>
 	}
 	return ret;
 }
<span class="p_chunk">@@ -6433,6 +6452,7 @@</span> <span class="p_context"> static struct r5conf *setup_conf(struct mddev *mddev)</span>
 		goto abort;
 	spin_lock_init(&amp;conf-&gt;device_lock);
 	seqcount_init(&amp;conf-&gt;gen_lock);
<span class="p_add">+	mutex_init(&amp;conf-&gt;cache_size_mutex);</span>
 	init_waitqueue_head(&amp;conf-&gt;wait_for_stripe);
 	init_waitqueue_head(&amp;conf-&gt;wait_for_overlap);
 	INIT_LIST_HEAD(&amp;conf-&gt;handle_list);
<span class="p_header">diff --git a/drivers/md/raid5.h b/drivers/md/raid5.h</span>
<span class="p_header">index 896d603ad0da..03472fbbd882 100644</span>
<span class="p_header">--- a/drivers/md/raid5.h</span>
<span class="p_header">+++ b/drivers/md/raid5.h</span>
<span class="p_chunk">@@ -482,7 +482,8 @@</span> <span class="p_context"> struct r5conf {</span>
 	 */
 	int			active_name;
 	char			cache_name[2][32];
<span class="p_del">-	struct kmem_cache		*slab_cache; /* for allocating stripes */</span>
<span class="p_add">+	struct kmem_cache	*slab_cache; /* for allocating stripes */</span>
<span class="p_add">+	struct mutex		cache_size_mutex; /* Protect changes to cache size */</span>
 
 	int			seq_flush, seq_write;
 	int			quiesce;
<span class="p_header">diff --git a/drivers/media/platform/am437x/am437x-vpfe.c b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">index a30cc2f7e4f1..ddf59ee5ca40 100644</span>
<span class="p_header">--- a/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">+++ b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_chunk">@@ -1185,14 +1185,24 @@</span> <span class="p_context"> static int vpfe_initialize_device(struct vpfe_device *vpfe)</span>
 static int vpfe_release(struct file *file)
 {
 	struct vpfe_device *vpfe = video_drvdata(file);
<span class="p_add">+	bool fh_singular;</span>
 	int ret;
 
 	mutex_lock(&amp;vpfe-&gt;lock);
 
<span class="p_del">-	if (v4l2_fh_is_singular_file(file))</span>
<span class="p_del">-		vpfe_ccdc_close(&amp;vpfe-&gt;ccdc, vpfe-&gt;pdev);</span>
<span class="p_add">+	/* Save the singular status before we call the clean-up helper */</span>
<span class="p_add">+	fh_singular = v4l2_fh_is_singular_file(file);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the release helper will cleanup any on-going streaming */</span>
 	ret = _vb2_fop_release(file, NULL);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If this was the last open file.</span>
<span class="p_add">+	 * Then de-initialize hw module.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (fh_singular)</span>
<span class="p_add">+		vpfe_ccdc_close(&amp;vpfe-&gt;ccdc, vpfe-&gt;pdev);</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;vpfe-&gt;lock);
 
 	return ret;
<span class="p_chunk">@@ -1577,7 +1587,7 @@</span> <span class="p_context"> static int vpfe_s_fmt(struct file *file, void *priv,</span>
 		return -EBUSY;
 	}
 
<span class="p_del">-	ret = vpfe_try_fmt(file, priv, fmt);</span>
<span class="p_add">+	ret = vpfe_try_fmt(file, priv, &amp;format);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/media/platform/omap3isp/isp.c b/drivers/media/platform/omap3isp/isp.c</span>
<span class="p_header">index 18d0a871747f..947d8be7b245 100644</span>
<span class="p_header">--- a/drivers/media/platform/omap3isp/isp.c</span>
<span class="p_header">+++ b/drivers/media/platform/omap3isp/isp.c</span>
<span class="p_chunk">@@ -829,14 +829,14 @@</span> <span class="p_context"> static int isp_pipeline_link_notify(struct media_link *link, u32 flags,</span>
 	int ret;
 
 	if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &amp;&amp;
<span class="p_del">-	    !(link-&gt;flags &amp; MEDIA_LNK_FL_ENABLED)) {</span>
<span class="p_add">+	    !(flags &amp; MEDIA_LNK_FL_ENABLED)) {</span>
 		/* Powering off entities is assumed to never fail. */
 		isp_pipeline_pm_power(source, -sink_use);
 		isp_pipeline_pm_power(sink, -source_use);
 		return 0;
 	}
 
<span class="p_del">-	if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &amp;&amp;</span>
<span class="p_add">+	if (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &amp;&amp;</span>
 		(flags &amp; MEDIA_LNK_FL_ENABLED)) {
 
 		ret = isp_pipeline_pm_power(source, sink_use);
<span class="p_header">diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c</span>
<span class="p_header">index f8c5e47a30aa..0aba9ff92102 100644</span>
<span class="p_header">--- a/drivers/media/rc/rc-main.c</span>
<span class="p_header">+++ b/drivers/media/rc/rc-main.c</span>
<span class="p_chunk">@@ -1191,9 +1191,6 @@</span> <span class="p_context"> static int rc_dev_uevent(struct device *device, struct kobj_uevent_env *env)</span>
 {
 	struct rc_dev *dev = to_rc_dev(device);
 
<span class="p_del">-	if (!dev || !dev-&gt;input_dev)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
 	if (dev-&gt;rc_map.name)
 		ADD_HOTPLUG_VAR(&quot;NAME=%s&quot;, dev-&gt;rc_map.name);
 	if (dev-&gt;driver_name)
<span class="p_header">diff --git a/drivers/memory/tegra/tegra114.c b/drivers/memory/tegra/tegra114.c</span>
<span class="p_header">index 511e9a25c151..16c4d26f51e7 100644</span>
<span class="p_header">--- a/drivers/memory/tegra/tegra114.c</span>
<span class="p_header">+++ b/drivers/memory/tegra/tegra114.c</span>
<span class="p_chunk">@@ -935,6 +935,7 @@</span> <span class="p_context"> static const struct tegra_smmu_soc tegra114_smmu_soc = {</span>
 	.num_swgroups = ARRAY_SIZE(tegra114_swgroups),
 	.supports_round_robin_arbitration = false,
 	.supports_request_limit = false,
<span class="p_add">+	.num_tlb_lines = 32,</span>
 	.num_asids = 4,
 	.ops = &amp;tegra114_smmu_ops,
 };
<span class="p_header">diff --git a/drivers/memory/tegra/tegra124.c b/drivers/memory/tegra/tegra124.c</span>
<span class="p_header">index 278d40b854c1..b153d0b732cf 100644</span>
<span class="p_header">--- a/drivers/memory/tegra/tegra124.c</span>
<span class="p_header">+++ b/drivers/memory/tegra/tegra124.c</span>
<span class="p_chunk">@@ -981,6 +981,7 @@</span> <span class="p_context"> static const struct tegra_smmu_soc tegra124_smmu_soc = {</span>
 	.num_swgroups = ARRAY_SIZE(tegra124_swgroups),
 	.supports_round_robin_arbitration = true,
 	.supports_request_limit = true,
<span class="p_add">+	.num_tlb_lines = 32,</span>
 	.num_asids = 128,
 	.ops = &amp;tegra124_smmu_ops,
 };
<span class="p_header">diff --git a/drivers/memory/tegra/tegra30.c b/drivers/memory/tegra/tegra30.c</span>
<span class="p_header">index 71fe9376fe53..f422b18f45f3 100644</span>
<span class="p_header">--- a/drivers/memory/tegra/tegra30.c</span>
<span class="p_header">+++ b/drivers/memory/tegra/tegra30.c</span>
<span class="p_chunk">@@ -957,6 +957,7 @@</span> <span class="p_context"> static const struct tegra_smmu_soc tegra30_smmu_soc = {</span>
 	.num_swgroups = ARRAY_SIZE(tegra30_swgroups),
 	.supports_round_robin_arbitration = false,
 	.supports_request_limit = false,
<span class="p_add">+	.num_tlb_lines = 16,</span>
 	.num_asids = 4,
 	.ops = &amp;tegra30_smmu_ops,
 };
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index 1ef01647265f..4f1b0bdb9cf8 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -778,14 +778,9 @@</span> <span class="p_context"> int cxl_reset(struct cxl *adapter)</span>
 {
 	struct pci_dev *dev = to_pci_dev(adapter-&gt;dev.parent);
 	int rc;
<span class="p_del">-	int i;</span>
<span class="p_del">-	u32 val;</span>
 
 	dev_info(&amp;dev-&gt;dev, &quot;CXL reset\n&quot;);
 
<span class="p_del">-	for (i = 0; i &lt; adapter-&gt;slices; i++)</span>
<span class="p_del">-		cxl_remove_afu(adapter-&gt;afu[i]);</span>
<span class="p_del">-</span>
 	/* pcie_warm_reset requests a fundamental pci reset which includes a
 	 * PERST assert/deassert.  PERST triggers a loading of the image
 	 * if &quot;user&quot; or &quot;factory&quot; is selected in sysfs */
<span class="p_chunk">@@ -794,20 +789,6 @@</span> <span class="p_context"> int cxl_reset(struct cxl *adapter)</span>
 		return rc;
 	}
 
<span class="p_del">-	/* the PERST done above fences the PHB.  So, reset depends on EEH</span>
<span class="p_del">-	 * to unbind the driver, tell Sapphire to reinit the PHB, and rebind</span>
<span class="p_del">-	 * the driver.  Do an mmio read explictly to ensure EEH notices the</span>
<span class="p_del">-	 * fenced PHB.  Retry for a few seconds before giving up. */</span>
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	while (((val = mmio_read32be(adapter-&gt;p1_mmio)) != 0xffffffff) &amp;&amp;</span>
<span class="p_del">-		(i &lt; 5)) {</span>
<span class="p_del">-		msleep(500);</span>
<span class="p_del">-		i++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (val != 0xffffffff)</span>
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;cxl: PERST failed to trigger EEH\n&quot;);</span>
<span class="p_del">-</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -1062,8 +1043,6 @@</span> <span class="p_context"> static int cxl_probe(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	int slice;
 	int rc;
 
<span class="p_del">-	pci_dev_get(dev);</span>
<span class="p_del">-</span>
 	if (cxl_verbose)
 		dump_cxl_config_space(dev);
 
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 92e7671426eb..588fb7908642 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -330,8 +330,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(mmc_start_bkops);</span>
  */
 static void mmc_wait_data_done(struct mmc_request *mrq)
 {
<span class="p_del">-	mrq-&gt;host-&gt;context_info.is_done_rcv = true;</span>
<span class="p_del">-	wake_up_interruptible(&amp;mrq-&gt;host-&gt;context_info.wait);</span>
<span class="p_add">+	struct mmc_context_info *context_info = &amp;mrq-&gt;host-&gt;context_info;</span>
<span class="p_add">+</span>
<span class="p_add">+	context_info-&gt;is_done_rcv = true;</span>
<span class="p_add">+	wake_up_interruptible(&amp;context_info-&gt;wait);</span>
 }
 
 static void mmc_wait_done(struct mmc_request *mrq)
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">index 7a3fc16d0a6c..53cfc7cedefe 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_chunk">@@ -549,6 +549,7 @@</span> <span class="p_context"> static int jmicron_resume(struct sdhci_pci_chip *chip)</span>
 static const struct sdhci_pci_fixes sdhci_o2 = {
 	.probe = sdhci_pci_o2_probe,
 	.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
<span class="p_add">+	.quirks2 = SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD,</span>
 	.probe_slot = sdhci_pci_o2_probe_slot,
 	.resume = sdhci_pci_o2_resume,
 };
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index bec8a307f8cd..fd41b91436ec 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -1146,6 +1146,7 @@</span> <span class="p_context"> static u16 sdhci_get_preset_value(struct sdhci_host *host)</span>
 		preset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR104);
 		break;
 	case MMC_TIMING_UHS_DDR50:
<span class="p_add">+	case MMC_TIMING_MMC_DDR52:</span>
 		preset = sdhci_readw(host, SDHCI_PRESET_FOR_DDR50);
 		break;
 	case MMC_TIMING_MMC_HS400:
<span class="p_chunk">@@ -1598,7 +1599,8 @@</span> <span class="p_context"> static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)</span>
 				 (ios-&gt;timing == MMC_TIMING_UHS_SDR25) ||
 				 (ios-&gt;timing == MMC_TIMING_UHS_SDR50) ||
 				 (ios-&gt;timing == MMC_TIMING_UHS_SDR104) ||
<span class="p_del">-				 (ios-&gt;timing == MMC_TIMING_UHS_DDR50))) {</span>
<span class="p_add">+				 (ios-&gt;timing == MMC_TIMING_UHS_DDR50) ||</span>
<span class="p_add">+				 (ios-&gt;timing == MMC_TIMING_MMC_DDR52))) {</span>
 			u16 preset;
 
 			sdhci_enable_preset_value(host, true);
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index d5fe5d5f490f..16d87bf8ac3c 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -625,6 +625,23 @@</span> <span class="p_context"> static void bond_set_dev_addr(struct net_device *bond_dev,</span>
 	call_netdevice_notifiers(NETDEV_CHANGEADDR, bond_dev);
 }
 
<span class="p_add">+static struct slave *bond_get_old_active(struct bonding *bond,</span>
<span class="p_add">+					 struct slave *new_active)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct slave *slave;</span>
<span class="p_add">+	struct list_head *iter;</span>
<span class="p_add">+</span>
<span class="p_add">+	bond_for_each_slave(bond, slave, iter) {</span>
<span class="p_add">+		if (slave == new_active)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ether_addr_equal(bond-&gt;dev-&gt;dev_addr, slave-&gt;dev-&gt;dev_addr))</span>
<span class="p_add">+			return slave;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* bond_do_fail_over_mac
  *
  * Perform special MAC address swapping for fail_over_mac settings
<span class="p_chunk">@@ -652,6 +669,9 @@</span> <span class="p_context"> static void bond_do_fail_over_mac(struct bonding *bond,</span>
 		if (!new_active)
 			return;
 
<span class="p_add">+		if (!old_active)</span>
<span class="p_add">+			old_active = bond_get_old_active(bond, new_active);</span>
<span class="p_add">+</span>
 		if (old_active) {
 			ether_addr_copy(tmp_mac, new_active-&gt;dev-&gt;dev_addr);
 			ether_addr_copy(saddr.sa_data,
<span class="p_chunk">@@ -1902,6 +1922,7 @@</span> <span class="p_context"> static int  bond_release_and_destroy(struct net_device *bond_dev,</span>
 		bond_dev-&gt;priv_flags |= IFF_DISABLE_NETPOLL;
 		netdev_info(bond_dev, &quot;Destroying bond %s\n&quot;,
 			    bond_dev-&gt;name);
<span class="p_add">+		bond_remove_proc_entry(bond);</span>
 		unregister_netdevice(bond_dev);
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index 069952fa5d64..0d8af5bb5907 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -10757,7 +10757,7 @@</span> <span class="p_context"> static ssize_t tg3_show_temp(struct device *dev,</span>
 	tg3_ape_scratchpad_read(tp, &amp;temperature, attr-&gt;index,
 				sizeof(temperature));
 	spin_unlock_bh(&amp;tp-&gt;lock);
<span class="p_del">-	return sprintf(buf, &quot;%u\n&quot;, temperature);</span>
<span class="p_add">+	return sprintf(buf, &quot;%u\n&quot;, temperature * 1000);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_header">index caae6cb2bc1a..a1c30ee60888 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bnad.c</span>
<span class="p_chunk">@@ -675,6 +675,7 @@</span> <span class="p_context"> bnad_cq_process(struct bnad *bnad, struct bna_ccb *ccb, int budget)</span>
 			if (!next_cmpl-&gt;valid)
 				break;
 		}
<span class="p_add">+		packets++;</span>
 
 		/* TODO: BNA_CQ_EF_LOCAL ? */
 		if (unlikely(flags &amp; (BNA_CQ_EF_MAC_ERROR |
<span class="p_chunk">@@ -691,7 +692,6 @@</span> <span class="p_context"> bnad_cq_process(struct bnad *bnad, struct bna_ccb *ccb, int budget)</span>
 		else
 			bnad_cq_setup_skb_frags(rcb, skb, sop_ci, nvecs, len);
 
<span class="p_del">-		packets++;</span>
 		rcb-&gt;rxq-&gt;rx_packets++;
 		rcb-&gt;rxq-&gt;rx_bytes += totlen;
 		ccb-&gt;bytes_per_intr += totlen;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_main.c b/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_header">index c754b2027281..c9da1b5d4804 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static void fm10k_reuse_rx_page(struct fm10k_ring *rx_ring,</span>
 
 static inline bool fm10k_page_is_reserved(struct page *page)
 {
<span class="p_del">-	return (page_to_nid(page) != numa_mem_id()) || page-&gt;pfmemalloc;</span>
<span class="p_add">+	return (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);</span>
 }
 
 static bool fm10k_can_reuse_rx_page(struct fm10k_rx_buffer *rx_buffer,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb.h b/drivers/net/ethernet/intel/igb/igb.h</span>
<span class="p_header">index c2bd4f98a837..212d668dabb3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb.h</span>
<span class="p_chunk">@@ -540,6 +540,7 @@</span> <span class="p_context"> void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector, unsigned char *va,</span>
 			 struct sk_buff *skb);
 int igb_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr);
 int igb_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr);
<span class="p_add">+void igb_set_flag_queue_pairs(struct igb_adapter *, const u32);</span>
 #ifdef CONFIG_IGB_HWMON
 void igb_sysfs_exit(struct igb_adapter *adapter);
 int igb_sysfs_init(struct igb_adapter *adapter);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_ethtool.c b/drivers/net/ethernet/intel/igb/igb_ethtool.c</span>
<span class="p_header">index d5673eb90c54..0afc0913e5b9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_ethtool.c</span>
<span class="p_chunk">@@ -2991,6 +2991,7 @@</span> <span class="p_context"> static int igb_set_channels(struct net_device *netdev,</span>
 {
 	struct igb_adapter *adapter = netdev_priv(netdev);
 	unsigned int count = ch-&gt;combined_count;
<span class="p_add">+	unsigned int max_combined = 0;</span>
 
 	/* Verify they are not requesting separate vectors */
 	if (!count || ch-&gt;rx_count || ch-&gt;tx_count)
<span class="p_chunk">@@ -3001,11 +3002,13 @@</span> <span class="p_context"> static int igb_set_channels(struct net_device *netdev,</span>
 		return -EINVAL;
 
 	/* Verify the number of channels doesn&#39;t exceed hw limits */
<span class="p_del">-	if (count &gt; igb_max_channels(adapter))</span>
<span class="p_add">+	max_combined = igb_max_channels(adapter);</span>
<span class="p_add">+	if (count &gt; max_combined)</span>
 		return -EINVAL;
 
 	if (count != adapter-&gt;rss_queues) {
 		adapter-&gt;rss_queues = count;
<span class="p_add">+		igb_set_flag_queue_pairs(adapter, max_combined);</span>
 
 		/* Hardware has to reinitialize queues and interrupts to
 		 * match the new configuration.
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index a0a9b1fcb5e8..4f6bf996851e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -1205,10 +1205,14 @@</span> <span class="p_context"> static int igb_alloc_q_vector(struct igb_adapter *adapter,</span>
 
 	/* allocate q_vector and rings */
 	q_vector = adapter-&gt;q_vector[v_idx];
<span class="p_del">-	if (!q_vector)</span>
<span class="p_add">+	if (!q_vector) {</span>
 		q_vector = kzalloc(size, GFP_KERNEL);
<span class="p_del">-	else</span>
<span class="p_add">+	} else if (size &gt; ksize(q_vector)) {</span>
<span class="p_add">+		kfree_rcu(q_vector, rcu);</span>
<span class="p_add">+		q_vector = kzalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	} else {</span>
 		memset(q_vector, 0, size);
<span class="p_add">+	}</span>
 	if (!q_vector)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -2901,6 +2905,14 @@</span> <span class="p_context"> static void igb_init_queue_configuration(struct igb_adapter *adapter)</span>
 
 	adapter-&gt;rss_queues = min_t(u32, max_rss_queues, num_online_cpus());
 
<span class="p_add">+	igb_set_flag_queue_pairs(adapter, max_rss_queues);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void igb_set_flag_queue_pairs(struct igb_adapter *adapter,</span>
<span class="p_add">+			      const u32 max_rss_queues)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct e1000_hw *hw = &amp;adapter-&gt;hw;</span>
<span class="p_add">+</span>
 	/* Determine if we need to pair queues. */
 	switch (hw-&gt;mac.type) {
 	case e1000_82575:
<span class="p_chunk">@@ -6584,7 +6596,7 @@</span> <span class="p_context"> static void igb_reuse_rx_page(struct igb_ring *rx_ring,</span>
 
 static inline bool igb_page_is_reserved(struct page *page)
 {
<span class="p_del">-	return (page_to_nid(page) != numa_mem_id()) || page-&gt;pfmemalloc;</span>
<span class="p_add">+	return (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);</span>
 }
 
 static bool igb_can_reuse_rx_page(struct igb_rx_buffer *rx_buffer,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index 5be12a00e1f4..463ff47200f1 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -1829,7 +1829,7 @@</span> <span class="p_context"> static void ixgbe_reuse_rx_page(struct ixgbe_ring *rx_ring,</span>
 
 static inline bool ixgbe_page_is_reserved(struct page *page)
 {
<span class="p_del">-	return (page_to_nid(page) != numa_mem_id()) || page-&gt;pfmemalloc;</span>
<span class="p_add">+	return (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">index e71cdde9cb01..1d7b00b038a2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> static void ixgbevf_reuse_rx_page(struct ixgbevf_ring *rx_ring,</span>
 
 static inline bool ixgbevf_page_is_reserved(struct page *page)
 {
<span class="p_del">-	return (page_to_nid(page) != numa_mem_id()) || page-&gt;pfmemalloc;</span>
<span class="p_add">+	return (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index 2619c9fbf42d..983b1d51244d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -573,7 +573,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						mlx4_dbg(dev, &quot;%s: Sending MLX4_PORT_CHANGE_SUBTYPE_DOWN to slave: %d, port:%d\n&quot;,
 							 __func__, i, port);
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 							continue;
 						if (i == mlx4_master_func_num(dev))
 							continue;
<span class="p_del">-						s_info = &amp;priv-&gt;mfunc.master.vf_oper[slave].vport[port].state;</span>
<span class="p_add">+						s_info = &amp;priv-&gt;mfunc.master.vf_oper[i].vport[port].state;</span>
 						if (IFLA_VF_LINK_STATE_AUTO == s_info-&gt;link_state) {
 							eqe-&gt;event.port_change.port =
 								cpu_to_be32(
<span class="p_header">diff --git a/drivers/net/ethernet/rocker/rocker.c b/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_header">index cf98cc9bbc8d..73b6fc21ea00 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_chunk">@@ -4587,6 +4587,7 @@</span> <span class="p_context"> static void rocker_remove_ports(struct rocker *rocker)</span>
 		rocker_port = rocker-&gt;ports[i];
 		rocker_port_ig_tbl(rocker_port, ROCKER_OP_FLAG_REMOVE);
 		unregister_netdev(rocker_port-&gt;dev);
<span class="p_add">+		free_netdev(rocker_port-&gt;dev);</span>
 	}
 	kfree(rocker-&gt;ports);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">index ad3996038018..799c2929c536 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_chunk">@@ -158,6 +158,8 @@</span> <span class="p_context"> struct dma_desc {</span>
 			u32 buffer2_size:13;
 			u32 reserved4:3;
 		} etx;		/* -- enhanced -- */
<span class="p_add">+</span>
<span class="p_add">+		u64 all_flags;</span>
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c</span>
<span class="p_header">index 6249a4ec08f0..573708123338 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> struct rk_priv_data {</span>
 	bool clock_input;
 
 	struct clk *clk_mac;
<span class="p_del">-	struct clk *clk_mac_pll;</span>
 	struct clk *gmac_clkin;
 	struct clk *mac_clk_rx;
 	struct clk *mac_clk_tx;
<span class="p_chunk">@@ -208,7 +207,7 @@</span> <span class="p_context"> static int gmac_clk_init(struct rk_priv_data *bsp_priv)</span>
 		dev_info(dev, &quot;%s: clock input from PHY\n&quot;, __func__);
 	} else {
 		if (bsp_priv-&gt;phy_iface == PHY_INTERFACE_MODE_RMII)
<span class="p_del">-			clk_set_rate(bsp_priv-&gt;clk_mac_pll, 50000000);</span>
<span class="p_add">+			clk_set_rate(bsp_priv-&gt;clk_mac, 50000000);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">index 1e2bcf5f89e1..7d944449f5ef 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_chunk">@@ -240,6 +240,7 @@</span> <span class="p_context"> static int enh_desc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
 				  int mode, int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.erx.own = 1;
 	p-&gt;des01.erx.buffer1_size = BUF_SIZE_8KiB - 1;
 
<span class="p_chunk">@@ -254,7 +255,7 @@</span> <span class="p_context"> static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,</span>
 
 static void enh_desc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.etx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ehn_desc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">index 35ad4f427ae2..48c3456445b2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static int ndesc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
 			       int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.rx.own = 1;
 	p-&gt;des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
 
<span class="p_chunk">@@ -137,7 +138,7 @@</span> <span class="p_context"> static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,</span>
 
 static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.tx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ndesc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index 2c5ce2baca87..c274cdc5df1e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -829,8 +829,11 @@</span> <span class="p_context"> static int stmmac_init_phy(struct net_device *dev)</span>
 
 	phydev = phy_connect(dev, phy_id_fmt, &amp;stmmac_adjust_link, interface);
 
<span class="p_del">-	if (IS_ERR(phydev)) {</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(phydev)) {</span>
 		pr_err(&quot;%s: Could not attach to PHY\n&quot;, dev-&gt;name);
<span class="p_add">+		if (!phydev)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+</span>
 		return PTR_ERR(phydev);
 	}
 
<span class="p_chunk">@@ -1189,41 +1192,41 @@</span> <span class="p_context"> static int alloc_dma_desc_resources(struct stmmac_priv *priv)</span>
 		goto err_tx_skbuff;
 
 	if (priv-&gt;extend_desc) {
<span class="p_del">-		priv-&gt;dma_erx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_erx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_erx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_etx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_etx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_etx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_extended_desc),</span>
<span class="p_del">-					priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_extended_desc),</span>
<span class="p_add">+					  priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	} else {
<span class="p_del">-		priv-&gt;dma_rx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_rx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_rx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_tx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_tx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_tx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_desc),</span>
<span class="p_del">-					priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_desc),</span>
<span class="p_add">+					  priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	}
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index 63c7810e1545..7fbca37a1adf 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -1828,7 +1828,8 @@</span> <span class="p_context"> static int virtnet_probe(struct virtio_device *vdev)</span>
 	else
 		vi-&gt;hdr_len = sizeof(struct virtio_net_hdr);
 
<span class="p_del">-	if (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT))</span>
<span class="p_add">+	if (virtio_has_feature(vdev, VIRTIO_F_ANY_LAYOUT) ||</span>
<span class="p_add">+	    virtio_has_feature(vdev, VIRTIO_F_VERSION_1))</span>
 		vi-&gt;any_header_sg = true;
 
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_VQ))
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index 23806c243a53..fd4a5353d216 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0846, 0x9043, rtl92cu_hal_cfg)}, /*NG WNA1000Mv2*/</span>
 	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 57966e3c8e8d..3fa2fb7c8e4e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2180,7 +2180,7 @@</span> <span class="p_context"> static int _rtl8821ae_set_media_status(struct ieee80211_hw *hw,</span>
 
 	rtl_write_byte(rtlpriv, MSR, bt_msr);
 	rtlpriv-&gt;cfg-&gt;ops-&gt;led_control(hw, ledaction);
<span class="p_del">-	if ((bt_msr &amp; 0xfc) == MSR_AP)</span>
<span class="p_add">+	if ((bt_msr &amp; MSR_MASK) == MSR_AP)</span>
 		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);
 	else
 		rtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/reg.h b/drivers/net/wireless/rtlwifi/rtl8821ae/reg.h</span>
<span class="p_header">index 53668fc8f23e..1d6110f9c1fb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/reg.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/reg.h</span>
<span class="p_chunk">@@ -429,6 +429,7 @@</span> <span class="p_context"></span>
 #define	MSR_ADHOC				0x01
 #define	MSR_INFRA				0x02
 #define	MSR_AP					0x03
<span class="p_add">+#define MSR_MASK				0x03</span>
 
 #define	RRSR_RSC_OFFSET				21
 #define	RRSR_SHORT_OFFSET			23
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index 0d2594395ffb..0866c5dfdf87 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -1571,13 +1571,13 @@</span> <span class="p_context"> static inline void xenvif_tx_dealloc_action(struct xenvif_queue *queue)</span>
 		smp_rmb();
 
 		while (dc != dp) {
<span class="p_del">-			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt; MAX_PENDING_REQS);</span>
<span class="p_add">+			BUG_ON(gop - queue-&gt;tx_unmap_ops &gt;= MAX_PENDING_REQS);</span>
 			pending_idx =
 				queue-&gt;dealloc_ring[pending_index(dc++)];
 
<span class="p_del">-			pending_idx_release[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			pending_idx_release[gop - queue-&gt;tx_unmap_ops] =</span>
 				pending_idx;
<span class="p_del">-			queue-&gt;pages_to_unmap[gop-queue-&gt;tx_unmap_ops] =</span>
<span class="p_add">+			queue-&gt;pages_to_unmap[gop - queue-&gt;tx_unmap_ops] =</span>
 				queue-&gt;mmap_pages[pending_idx];
 			gnttab_set_unmap_op(gop,
 					    idx_to_kaddr(queue, pending_idx),
<span class="p_header">diff --git a/drivers/nfc/st21nfca/st21nfca.c b/drivers/nfc/st21nfca/st21nfca.c</span>
<span class="p_header">index d251f7229c4e..051286562fab 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfca/st21nfca.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfca/st21nfca.c</span>
<span class="p_chunk">@@ -148,14 +148,14 @@</span> <span class="p_context"> static int st21nfca_hci_load_session(struct nfc_hci_dev *hdev)</span>
 				ST21NFCA_DEVICE_MGNT_GATE,
 				ST21NFCA_DEVICE_MGNT_PIPE);
 	if (r &lt; 0)
<span class="p_del">-		goto free_info;</span>
<span class="p_add">+		return r;</span>
 
 	/* Get pipe list */
 	r = nfc_hci_send_cmd(hdev, ST21NFCA_DEVICE_MGNT_GATE,
 			ST21NFCA_DM_GETINFO, pipe_list, sizeof(pipe_list),
 			&amp;skb_pipe_list);
 	if (r &lt; 0)
<span class="p_del">-		goto free_info;</span>
<span class="p_add">+		return r;</span>
 
 	/* Complete the existing gate_pipe table */
 	for (i = 0; i &lt; skb_pipe_list-&gt;len; i++) {
<span class="p_chunk">@@ -181,6 +181,7 @@</span> <span class="p_context"> static int st21nfca_hci_load_session(struct nfc_hci_dev *hdev)</span>
 			info-&gt;src_host_id != ST21NFCA_ESE_HOST_ID) {
 			pr_err(&quot;Unexpected apdu_reader pipe on host %x\n&quot;,
 				info-&gt;src_host_id);
<span class="p_add">+			kfree_skb(skb_pipe_info);</span>
 			continue;
 		}
 
<span class="p_chunk">@@ -200,6 +201,7 @@</span> <span class="p_context"> static int st21nfca_hci_load_session(struct nfc_hci_dev *hdev)</span>
 			hdev-&gt;pipes[st21nfca_gates[j].pipe].dest_host =
 							info-&gt;src_host_id;
 		}
<span class="p_add">+		kfree_skb(skb_pipe_info);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -214,13 +216,12 @@</span> <span class="p_context"> static int st21nfca_hci_load_session(struct nfc_hci_dev *hdev)</span>
 					st21nfca_gates[i].gate,
 					st21nfca_gates[i].pipe);
 			if (r &lt; 0)
<span class="p_del">-				goto free_info;</span>
<span class="p_add">+				goto free_list;</span>
 		}
 	}
 
 	memcpy(hdev-&gt;init_data.gates, st21nfca_gates, sizeof(st21nfca_gates));
<span class="p_del">-free_info:</span>
<span class="p_del">-	kfree_skb(skb_pipe_info);</span>
<span class="p_add">+free_list:</span>
 	kfree_skb(skb_pipe_list);
 	return r;
 }
<span class="p_header">diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c</span>
<span class="p_header">index cde35c5d0191..d91f721a05b6 100644</span>
<span class="p_header">--- a/drivers/of/fdt.c</span>
<span class="p_header">+++ b/drivers/of/fdt.c</span>
<span class="p_chunk">@@ -955,7 +955,9 @@</span> <span class="p_context"> int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,</span>
 }
 
 #ifdef CONFIG_HAVE_MEMBLOCK
<span class="p_del">-#define MAX_PHYS_ADDR	((phys_addr_t)~0)</span>
<span class="p_add">+#ifndef MAX_MEMBLOCK_ADDR</span>
<span class="p_add">+#define MAX_MEMBLOCK_ADDR	((phys_addr_t)~0)</span>
<span class="p_add">+#endif</span>
 
 void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
 {
<span class="p_chunk">@@ -972,16 +974,16 @@</span> <span class="p_context"> void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)</span>
 	}
 	size &amp;= PAGE_MASK;
 
<span class="p_del">-	if (base &gt; MAX_PHYS_ADDR) {</span>
<span class="p_add">+	if (base &gt; MAX_MEMBLOCK_ADDR) {</span>
 		pr_warning(&quot;Ignoring memory block 0x%llx - 0x%llx\n&quot;,
 				base, base + size);
 		return;
 	}
 
<span class="p_del">-	if (base + size - 1 &gt; MAX_PHYS_ADDR) {</span>
<span class="p_add">+	if (base + size - 1 &gt; MAX_MEMBLOCK_ADDR) {</span>
 		pr_warning(&quot;Ignoring memory range 0x%llx - 0x%llx\n&quot;,
<span class="p_del">-				((u64)MAX_PHYS_ADDR) + 1, base + size);</span>
<span class="p_del">-		size = MAX_PHYS_ADDR - base + 1;</span>
<span class="p_add">+				((u64)MAX_MEMBLOCK_ADDR) + 1, base + size);</span>
<span class="p_add">+		size = MAX_MEMBLOCK_ADDR - base + 1;</span>
 	}
 
 	if (base + size &lt; phys_offset) {
<span class="p_header">diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c</span>
<span class="p_header">index dceb9ddfd99a..a32c1f6c252c 100644</span>
<span class="p_header">--- a/drivers/parisc/lba_pci.c</span>
<span class="p_header">+++ b/drivers/parisc/lba_pci.c</span>
<span class="p_chunk">@@ -1556,8 +1556,11 @@</span> <span class="p_context"> lba_driver_probe(struct parisc_device *dev)</span>
 	if (lba_dev-&gt;hba.lmmio_space.flags)
 		pci_add_resource_offset(&amp;resources, &amp;lba_dev-&gt;hba.lmmio_space,
 					lba_dev-&gt;hba.lmmio_space_offset);
<span class="p_del">-	if (lba_dev-&gt;hba.gmmio_space.flags)</span>
<span class="p_del">-		pci_add_resource(&amp;resources, &amp;lba_dev-&gt;hba.gmmio_space);</span>
<span class="p_add">+	if (lba_dev-&gt;hba.gmmio_space.flags) {</span>
<span class="p_add">+		/* pci_add_resource(&amp;resources, &amp;lba_dev-&gt;hba.gmmio_space); */</span>
<span class="p_add">+		pr_warn(&quot;LBA: Not registering GMMIO space %pR\n&quot;,</span>
<span class="p_add">+			&amp;lba_dev-&gt;hba.gmmio_space);</span>
<span class="p_add">+	}</span>
 
 	pci_add_resource(&amp;resources, &amp;lba_dev-&gt;hba.bus_num);
 
<span class="p_header">diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig</span>
<span class="p_header">index 944f50015ed0..73de4efcbe6e 100644</span>
<span class="p_header">--- a/drivers/pci/Kconfig</span>
<span class="p_header">+++ b/drivers/pci/Kconfig</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 # PCI configuration
 #
 config PCI_BUS_ADDR_T_64BIT
<span class="p_del">-	def_bool y if (ARCH_DMA_ADDR_T_64BIT || (64BIT &amp;&amp; !PARISC))</span>
<span class="p_add">+	def_bool y if (ARCH_DMA_ADDR_T_64BIT || 64BIT)</span>
 	depends on PCI
 
 config PCI_MSI
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-at91.c b/drivers/pinctrl/pinctrl-at91.c</span>
<span class="p_header">index 2f797cb7e205..774781450885 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-at91.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-at91.c</span>
<span class="p_chunk">@@ -320,6 +320,9 @@</span> <span class="p_context"> static const struct pinctrl_ops at91_pctrl_ops = {</span>
 static void __iomem *pin_to_controller(struct at91_pinctrl *info,
 				 unsigned int bank)
 {
<span class="p_add">+	if (!gpio_chips[bank])</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	return gpio_chips[bank]-&gt;regbase;
 }
 
<span class="p_chunk">@@ -729,6 +732,10 @@</span> <span class="p_context"> static int at91_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,</span>
 		pin = &amp;pins_conf[i];
 		at91_pin_dbg(info-&gt;dev, pin);
 		pio = pin_to_controller(info, pin-&gt;bank);
<span class="p_add">+</span>
<span class="p_add">+		if (!pio)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		mask = pin_to_mask(pin-&gt;pin);
 		at91_mux_disable_interrupt(pio, mask);
 		switch (pin-&gt;mux) {
<span class="p_chunk">@@ -848,6 +855,10 @@</span> <span class="p_context"> static int at91_pinconf_get(struct pinctrl_dev *pctldev,</span>
 	*config = 0;
 	dev_dbg(info-&gt;dev, &quot;%s:%d, pin_id=%d&quot;, __func__, __LINE__, pin_id);
 	pio = pin_to_controller(info, pin_to_bank(pin_id));
<span class="p_add">+</span>
<span class="p_add">+	if (!pio)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	pin = pin_id % MAX_NB_GPIO_PER_BANK;
 
 	if (at91_mux_get_multidrive(pio, pin))
<span class="p_chunk">@@ -889,6 +900,10 @@</span> <span class="p_context"> static int at91_pinconf_set(struct pinctrl_dev *pctldev,</span>
 			&quot;%s:%d, pin_id=%d, config=0x%lx&quot;,
 			__func__, __LINE__, pin_id, config);
 		pio = pin_to_controller(info, pin_to_bank(pin_id));
<span class="p_add">+</span>
<span class="p_add">+		if (!pio)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		pin = pin_id % MAX_NB_GPIO_PER_BANK;
 		mask = pin_to_mask(pin);
 
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index cb7cd8d79329..cd78f1166b33 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -852,6 +852,13 @@</span> <span class="p_context"> static const struct dmi_system_id no_hw_rfkill_list[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		.ident = &quot;Lenovo Yoga 3 14&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo Yoga 3 14&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 3 Pro 1370&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/rtc/rtc-abx80x.c b/drivers/rtc/rtc-abx80x.c</span>
<span class="p_header">index 4337c3bc6ace..afea84c7a155 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-abx80x.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-abx80x.c</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"></span>
 #define ABX8XX_REG_WD		0x07
 
 #define ABX8XX_REG_CTRL1	0x10
<span class="p_del">-#define ABX8XX_CTRL_WRITE	BIT(1)</span>
<span class="p_add">+#define ABX8XX_CTRL_WRITE	BIT(0)</span>
 #define ABX8XX_CTRL_12_24	BIT(6)
 
 #define ABX8XX_REG_CFG_KEY	0x1f
<span class="p_header">diff --git a/drivers/rtc/rtc-s3c.c b/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">index 76cbad7a99d3..c5a2523b0185 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s3c.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> struct s3c_rtc {</span>
 	void __iomem *base;
 	struct clk *rtc_clk;
 	struct clk *rtc_src_clk;
<span class="p_add">+	bool clk_disabled;</span>
 
 	struct s3c_rtc_data *data;
 
<span class="p_chunk">@@ -71,9 +72,12 @@</span> <span class="p_context"> static void s3c_rtc_enable_clk(struct s3c_rtc *info)</span>
 	unsigned long irq_flags;
 
 	spin_lock_irqsave(&amp;info-&gt;alarm_clk_lock, irq_flags);
<span class="p_del">-	clk_enable(info-&gt;rtc_clk);</span>
<span class="p_del">-	if (info-&gt;data-&gt;needs_src_clk)</span>
<span class="p_del">-		clk_enable(info-&gt;rtc_src_clk);</span>
<span class="p_add">+	if (info-&gt;clk_disabled) {</span>
<span class="p_add">+		clk_enable(info-&gt;rtc_clk);</span>
<span class="p_add">+		if (info-&gt;data-&gt;needs_src_clk)</span>
<span class="p_add">+			clk_enable(info-&gt;rtc_src_clk);</span>
<span class="p_add">+		info-&gt;clk_disabled = false;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;info-&gt;alarm_clk_lock, irq_flags);
 }
 
<span class="p_chunk">@@ -82,9 +86,12 @@</span> <span class="p_context"> static void s3c_rtc_disable_clk(struct s3c_rtc *info)</span>
 	unsigned long irq_flags;
 
 	spin_lock_irqsave(&amp;info-&gt;alarm_clk_lock, irq_flags);
<span class="p_del">-	if (info-&gt;data-&gt;needs_src_clk)</span>
<span class="p_del">-		clk_disable(info-&gt;rtc_src_clk);</span>
<span class="p_del">-	clk_disable(info-&gt;rtc_clk);</span>
<span class="p_add">+	if (!info-&gt;clk_disabled) {</span>
<span class="p_add">+		if (info-&gt;data-&gt;needs_src_clk)</span>
<span class="p_add">+			clk_disable(info-&gt;rtc_src_clk);</span>
<span class="p_add">+		clk_disable(info-&gt;rtc_clk);</span>
<span class="p_add">+		info-&gt;clk_disabled = true;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;info-&gt;alarm_clk_lock, irq_flags);
 }
 
<span class="p_chunk">@@ -128,6 +135,11 @@</span> <span class="p_context"> static int s3c_rtc_setaie(struct device *dev, unsigned int enabled)</span>
 
 	s3c_rtc_disable_clk(info);
 
<span class="p_add">+	if (enabled)</span>
<span class="p_add">+		s3c_rtc_enable_clk(info);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		s3c_rtc_disable_clk(info);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/rtc/rtc-s5m.c b/drivers/rtc/rtc-s5m.c</span>
<span class="p_header">index 8c70d785ba73..ab60287ee72d 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s5m.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s5m.c</span>
<span class="p_chunk">@@ -635,6 +635,16 @@</span> <span class="p_context"> static int s5m8767_rtc_init_reg(struct s5m_rtc_info *info)</span>
 	case S2MPS13X:
 		data[0] = (0 &lt;&lt; BCD_EN_SHIFT) | (1 &lt;&lt; MODEL24_SHIFT);
 		ret = regmap_write(info-&gt;regmap, info-&gt;regs-&gt;ctrl, data[0]);
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Should set WUDR &amp; (RUDR or AUDR) bits to high after writing</span>
<span class="p_add">+		 * RTC_CTRL register like writing Alarm registers. We can&#39;t find</span>
<span class="p_add">+		 * the description from datasheet but vendor code does that</span>
<span class="p_add">+		 * really.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = s5m8767_rtc_set_alarm_reg(info);</span>
 		break;
 
 	default:
<span class="p_header">diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c</span>
<span class="p_header">index 94e909c5a503..00d18c2bdb0f 100644</span>
<span class="p_header">--- a/fs/btrfs/transaction.c</span>
<span class="p_header">+++ b/fs/btrfs/transaction.c</span>
<span class="p_chunk">@@ -1875,8 +1875,11 @@</span> <span class="p_context"> int btrfs_commit_transaction(struct btrfs_trans_handle *trans,</span>
 			spin_unlock(&amp;root-&gt;fs_info-&gt;trans_lock);
 
 			wait_for_commit(root, prev_trans);
<span class="p_add">+			ret = prev_trans-&gt;aborted;</span>
 
 			btrfs_put_transaction(prev_trans);
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				goto cleanup_transaction;</span>
 		} else {
 			spin_unlock(&amp;root-&gt;fs_info-&gt;trans_lock);
 		}
<span class="p_header">diff --git a/fs/cifs/ioctl.c b/fs/cifs/ioctl.c</span>
<span class="p_header">index 8b7898b7670f..64a9bca976d0 100644</span>
<span class="p_header">--- a/fs/cifs/ioctl.c</span>
<span class="p_header">+++ b/fs/cifs/ioctl.c</span>
<span class="p_chunk">@@ -67,6 +67,12 @@</span> <span class="p_context"> static long cifs_ioctl_clone(unsigned int xid, struct file *dst_file,</span>
 		goto out_drop_write;
 	}
 
<span class="p_add">+	if (src_file.file-&gt;f_op-&gt;unlocked_ioctl != cifs_ioctl) {</span>
<span class="p_add">+		rc = -EBADF;</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;src file seems to be from a different filesystem type\n&quot;);</span>
<span class="p_add">+		goto out_fput;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((!src_file.file-&gt;private_data) || (!dst_file-&gt;private_data)) {
 		rc = -EBADF;
 		cifs_dbg(VFS, &quot;missing cifsFileInfo on copy range src file\n&quot;);
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index bbbe139ab280..8dd099dc5f9b 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -506,10 +506,10 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 	const struct cred *old_cred;
 	struct cred *cred;
 	int retval = 0;
<span class="p_del">-	int flag = 0;</span>
 	int ispipe;
 	struct files_struct *displaced;
<span class="p_del">-	bool need_nonrelative = false;</span>
<span class="p_add">+	/* require nonrelative corefile path and be extra careful */</span>
<span class="p_add">+	bool need_suid_safe = false;</span>
 	bool core_dumped = false;
 	static atomic_t core_dump_count = ATOMIC_INIT(0);
 	struct coredump_params cprm = {
<span class="p_chunk">@@ -543,9 +543,8 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 	 */
 	if (__get_dumpable(cprm.mm_flags) == SUID_DUMP_ROOT) {
 		/* Setuid core dump mode */
<span class="p_del">-		flag = O_EXCL;		/* Stop rewrite attacks */</span>
 		cred-&gt;fsuid = GLOBAL_ROOT_UID;	/* Dump root private */
<span class="p_del">-		need_nonrelative = true;</span>
<span class="p_add">+		need_suid_safe = true;</span>
 	}
 
 	retval = coredump_wait(siginfo-&gt;si_signo, &amp;core_state);
<span class="p_chunk">@@ -626,7 +625,7 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 		if (cprm.limit &lt; binfmt-&gt;min_coredump)
 			goto fail_unlock;
 
<span class="p_del">-		if (need_nonrelative &amp;&amp; cn.corename[0] != &#39;/&#39;) {</span>
<span class="p_add">+		if (need_suid_safe &amp;&amp; cn.corename[0] != &#39;/&#39;) {</span>
 			printk(KERN_WARNING &quot;Pid %d(%s) can only dump core &quot;\
 				&quot;to fully qualified path!\n&quot;,
 				task_tgid_vnr(current), current-&gt;comm);
<span class="p_chunk">@@ -634,8 +633,35 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 			goto fail_unlock;
 		}
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Unlink the file if it exists unless this is a SUID</span>
<span class="p_add">+		 * binary - in that case, we&#39;re running around with root</span>
<span class="p_add">+		 * privs and don&#39;t want to unlink another user&#39;s coredump.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!need_suid_safe) {</span>
<span class="p_add">+			mm_segment_t old_fs;</span>
<span class="p_add">+</span>
<span class="p_add">+			old_fs = get_fs();</span>
<span class="p_add">+			set_fs(KERNEL_DS);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If it doesn&#39;t exist, that&#39;s fine. If there&#39;s some</span>
<span class="p_add">+			 * other problem, we&#39;ll catch it at the filp_open().</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			(void) sys_unlink((const char __user *)cn.corename);</span>
<span class="p_add">+			set_fs(old_fs);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * There is a race between unlinking and creating the</span>
<span class="p_add">+		 * file, but if that causes an EEXIST here, that&#39;s</span>
<span class="p_add">+		 * fine - another process raced with us while creating</span>
<span class="p_add">+		 * the corefile, and the other process won. To userspace,</span>
<span class="p_add">+		 * what matters is that at least one of the two processes</span>
<span class="p_add">+		 * writes its coredump successfully, not which one.</span>
<span class="p_add">+		 */</span>
 		cprm.file = filp_open(cn.corename,
<span class="p_del">-				 O_CREAT | 2 | O_NOFOLLOW | O_LARGEFILE | flag,</span>
<span class="p_add">+				 O_CREAT | 2 | O_NOFOLLOW |</span>
<span class="p_add">+				 O_LARGEFILE | O_EXCL,</span>
 				 0600);
 		if (IS_ERR(cprm.file))
 			goto fail_unlock;
<span class="p_chunk">@@ -652,11 +678,15 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 		if (!S_ISREG(inode-&gt;i_mode))
 			goto close_fail;
 		/*
<span class="p_del">-		 * Dont allow local users get cute and trick others to coredump</span>
<span class="p_del">-		 * into their pre-created files.</span>
<span class="p_add">+		 * Don&#39;t dump core if the filesystem changed owner or mode</span>
<span class="p_add">+		 * of the file during file creation. This is an issue when</span>
<span class="p_add">+		 * a process dumps core while its cwd is e.g. on a vfat</span>
<span class="p_add">+		 * filesystem.</span>
 		 */
 		if (!uid_eq(inode-&gt;i_uid, current_fsuid()))
 			goto close_fail;
<span class="p_add">+		if ((inode-&gt;i_mode &amp; 0677) != 0600)</span>
<span class="p_add">+			goto close_fail;</span>
 		if (!(cprm.file-&gt;f_mode &amp; FMODE_CAN_WRITE))
 			goto close_fail;
 		if (do_truncate(cprm.file-&gt;f_path.dentry, 0, 0, cprm.file))
<span class="p_header">diff --git a/fs/ecryptfs/dentry.c b/fs/ecryptfs/dentry.c</span>
<span class="p_header">index 8db0b464483f..63cd2c147221 100644</span>
<span class="p_header">--- a/fs/ecryptfs/dentry.c</span>
<span class="p_header">+++ b/fs/ecryptfs/dentry.c</span>
<span class="p_chunk">@@ -45,20 +45,20 @@</span> <span class="p_context"></span>
 static int ecryptfs_d_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	struct dentry *lower_dentry = ecryptfs_dentry_to_lower(dentry);
<span class="p_del">-	int rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(lower_dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE))</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+	int rc = 1;</span>
 
 	if (flags &amp; LOOKUP_RCU)
 		return -ECHILD;
 
<span class="p_del">-	rc = lower_dentry-&gt;d_op-&gt;d_revalidate(lower_dentry, flags);</span>
<span class="p_add">+	if (lower_dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE)</span>
<span class="p_add">+		rc = lower_dentry-&gt;d_op-&gt;d_revalidate(lower_dentry, flags);</span>
<span class="p_add">+</span>
 	if (d_really_is_positive(dentry)) {
<span class="p_del">-		struct inode *lower_inode =</span>
<span class="p_del">-			ecryptfs_inode_to_lower(d_inode(dentry));</span>
<span class="p_add">+		struct inode *inode = d_inode(dentry);</span>
 
<span class="p_del">-		fsstack_copy_attr_all(d_inode(dentry), lower_inode);</span>
<span class="p_add">+		fsstack_copy_attr_all(inode, ecryptfs_inode_to_lower(inode));</span>
<span class="p_add">+		if (!inode-&gt;i_nlink)</span>
<span class="p_add">+			return 0;</span>
 	}
 	return rc;
 }
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 6b4eb94b04a5..ff89971e3ee0 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -324,6 +324,22 @@</span> <span class="p_context"> static void save_error_info(struct super_block *sb, const char *func,</span>
 	ext4_commit_super(sb, 1);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The del_gendisk() function uninitializes the disk-specific data</span>
<span class="p_add">+ * structures, including the bdi structure, without telling anyone</span>
<span class="p_add">+ * else.  Once this happens, any attempt to call mark_buffer_dirty()</span>
<span class="p_add">+ * (for example, by ext4_commit_super), will cause a kernel OOPS.</span>
<span class="p_add">+ * This is a kludge to prevent these oops until we can put in a proper</span>
<span class="p_add">+ * hook in del_gendisk() to inform the VFS and file system layers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int block_device_ejected(struct super_block *sb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *bd_inode = sb-&gt;s_bdev-&gt;bd_inode;</span>
<span class="p_add">+	struct backing_dev_info *bdi = inode_to_bdi(bd_inode);</span>
<span class="p_add">+</span>
<span class="p_add">+	return bdi-&gt;dev == NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)
 {
 	struct super_block		*sb = journal-&gt;j_private;
<span class="p_chunk">@@ -4591,7 +4607,7 @@</span> <span class="p_context"> static int ext4_commit_super(struct super_block *sb, int sync)</span>
 	struct buffer_head *sbh = EXT4_SB(sb)-&gt;s_sbh;
 	int error = 0;
 
<span class="p_del">-	if (!sbh)</span>
<span class="p_add">+	if (!sbh || block_device_ejected(sb))</span>
 		return error;
 	if (buffer_write_io_error(sbh)) {
 		/*
<span class="p_chunk">@@ -4807,10 +4823,11 @@</span> <span class="p_context"> static int ext4_freeze(struct super_block *sb)</span>
 		error = jbd2_journal_flush(journal);
 		if (error &lt; 0)
 			goto out;
<span class="p_add">+</span>
<span class="p_add">+		/* Journal blocked and flushed, clear needs_recovery flag. */</span>
<span class="p_add">+		EXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);</span>
 	}
 
<span class="p_del">-	/* Journal blocked and flushed, clear needs_recovery flag. */</span>
<span class="p_del">-	EXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);</span>
 	error = ext4_commit_super(sb, 1);
 out:
 	if (journal)
<span class="p_chunk">@@ -4828,8 +4845,11 @@</span> <span class="p_context"> static int ext4_unfreeze(struct super_block *sb)</span>
 	if (sb-&gt;s_flags &amp; MS_RDONLY)
 		return 0;
 
<span class="p_del">-	/* Reset the needs_recovery flag before the fs is unlocked. */</span>
<span class="p_del">-	EXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);</span>
<span class="p_add">+	if (EXT4_SB(sb)-&gt;s_journal) {</span>
<span class="p_add">+		/* Reset the needs_recovery flag before the fs is unlocked. */</span>
<span class="p_add">+		EXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ext4_commit_super(sb, 1);
 	return 0;
 }
<span class="p_header">diff --git a/fs/hfs/bnode.c b/fs/hfs/bnode.c</span>
<span class="p_header">index d3fa6bd9503e..221719eac5de 100644</span>
<span class="p_header">--- a/fs/hfs/bnode.c</span>
<span class="p_header">+++ b/fs/hfs/bnode.c</span>
<span class="p_chunk">@@ -288,7 +288,6 @@</span> <span class="p_context"> static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)</span>
 			page_cache_release(page);
 			goto fail;
 		}
<span class="p_del">-		page_cache_release(page);</span>
 		node-&gt;page[i] = page;
 	}
 
<span class="p_chunk">@@ -398,11 +397,11 @@</span> <span class="p_context"> node_error:</span>
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
<span class="p_del">-	//int i;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-	//for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)</span>
<span class="p_del">-	//	if (node-&gt;page[i])</span>
<span class="p_del">-	//		page_cache_release(node-&gt;page[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)</span>
<span class="p_add">+		if (node-&gt;page[i])</span>
<span class="p_add">+			page_cache_release(node-&gt;page[i]);</span>
 	kfree(node);
 }
 
<span class="p_header">diff --git a/fs/hfs/brec.c b/fs/hfs/brec.c</span>
<span class="p_header">index 9f4ee7f52026..6fc766df0461 100644</span>
<span class="p_header">--- a/fs/hfs/brec.c</span>
<span class="p_header">+++ b/fs/hfs/brec.c</span>
<span class="p_chunk">@@ -131,13 +131,16 @@</span> <span class="p_context"> skip:</span>
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
<span class="p_del">-	if (new_node) {</span>
<span class="p_del">-		/* update parent key if we inserted a key</span>
<span class="p_del">-		 * at the start of the first node</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!rec &amp;&amp; new_node != node)</span>
<span class="p_del">-			hfs_brec_update_parent(fd);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * update parent key if we inserted a key</span>
<span class="p_add">+	 * at the start of the node and it is not the new node</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!rec &amp;&amp; new_node != node) {</span>
<span class="p_add">+		hfs_bnode_read_key(node, fd-&gt;search_key, data_off + size);</span>
<span class="p_add">+		hfs_brec_update_parent(fd);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (new_node) {</span>
 		hfs_bnode_put(fd-&gt;bnode);
 		if (!new_node-&gt;parent) {
 			hfs_btree_inc_height(tree);
<span class="p_chunk">@@ -166,9 +169,6 @@</span> <span class="p_context"> skip:</span>
 		goto again;
 	}
 
<span class="p_del">-	if (!rec)</span>
<span class="p_del">-		hfs_brec_update_parent(fd);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -366,6 +366,8 @@</span> <span class="p_context"> again:</span>
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
<span class="p_add">+	if (fd-&gt;record &lt; 0)</span>
<span class="p_add">+		return -ENOENT;</span>
 	hfs_bnode_dump(parent);
 	rec = fd-&gt;record;
 
<span class="p_header">diff --git a/fs/hfsplus/bnode.c b/fs/hfsplus/bnode.c</span>
<span class="p_header">index 759708fd9331..63924662aaf3 100644</span>
<span class="p_header">--- a/fs/hfsplus/bnode.c</span>
<span class="p_header">+++ b/fs/hfsplus/bnode.c</span>
<span class="p_chunk">@@ -454,7 +454,6 @@</span> <span class="p_context"> static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)</span>
 			page_cache_release(page);
 			goto fail;
 		}
<span class="p_del">-		page_cache_release(page);</span>
 		node-&gt;page[i] = page;
 	}
 
<span class="p_chunk">@@ -566,13 +565,11 @@</span> <span class="p_context"> node_error:</span>
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
<span class="p_del">-#if 0</span>
 	int i;
 
 	for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)
 		if (node-&gt;page[i])
 			page_cache_release(node-&gt;page[i]);
<span class="p_del">-#endif</span>
 	kfree(node);
 }
 
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 4227dc4f7437..8c44654ce274 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -417,12 +417,12 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
  * journal_clean_one_cp_list
  *
  * Find all the written-back checkpoint buffers in the given list and
<span class="p_del">- * release them.</span>
<span class="p_add">+ * release them. If &#39;destroy&#39; is set, clean all buffers unconditionally.</span>
  *
  * Called with j_list_lock held.
  * Returns 1 if we freed the transaction, 0 otherwise.
  */
<span class="p_del">-static int journal_clean_one_cp_list(struct journal_head *jh)</span>
<span class="p_add">+static int journal_clean_one_cp_list(struct journal_head *jh, bool destroy)</span>
 {
 	struct journal_head *last_jh;
 	struct journal_head *next_jh = jh;
<span class="p_chunk">@@ -436,7 +436,10 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh)</span>
 	do {
 		jh = next_jh;
 		next_jh = jh-&gt;b_cpnext;
<span class="p_del">-		ret = __try_to_free_cp_buf(jh);</span>
<span class="p_add">+		if (!destroy)</span>
<span class="p_add">+			ret = __try_to_free_cp_buf(jh);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = __jbd2_journal_remove_checkpoint(jh) + 1;</span>
 		if (!ret)
 			return freed;
 		if (ret == 2)
<span class="p_chunk">@@ -459,10 +462,11 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh)</span>
  * journal_clean_checkpoint_list
  *
  * Find all the written-back checkpoint buffers in the journal and release them.
<span class="p_add">+ * If &#39;destroy&#39; is set, release all buffers unconditionally.</span>
  *
  * Called with j_list_lock held.
  */
<span class="p_del">-void __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
<span class="p_add">+void __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy)</span>
 {
 	transaction_t *transaction, *last_transaction, *next_transaction;
 	int ret;
<span class="p_chunk">@@ -476,7 +480,8 @@</span> <span class="p_context"> void __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
 	do {
 		transaction = next_transaction;
 		next_transaction = transaction-&gt;t_cpnext;
<span class="p_del">-		ret = journal_clean_one_cp_list(transaction-&gt;t_checkpoint_list);</span>
<span class="p_add">+		ret = journal_clean_one_cp_list(transaction-&gt;t_checkpoint_list,</span>
<span class="p_add">+						destroy);</span>
 		/*
 		 * This function only frees up some memory if possible so we
 		 * dont have an obligation to finish processing. Bail out if
<span class="p_chunk">@@ -492,7 +497,7 @@</span> <span class="p_context"> void __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
 		 * we can possibly see not yet submitted buffers on io_list
 		 */
 		ret = journal_clean_one_cp_list(transaction-&gt;
<span class="p_del">-				t_checkpoint_io_list);</span>
<span class="p_add">+				t_checkpoint_io_list, destroy);</span>
 		if (need_resched())
 			return;
 		/*
<span class="p_chunk">@@ -506,6 +511,28 @@</span> <span class="p_context"> void __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
 }
 
 /*
<span class="p_add">+ * Remove buffers from all checkpoint lists as journal is aborted and we just</span>
<span class="p_add">+ * need to free memory</span>
<span class="p_add">+ */</span>
<span class="p_add">+void jbd2_journal_destroy_checkpoint(journal_t *journal)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We loop because __jbd2_journal_clean_checkpoint_list() may abort</span>
<span class="p_add">+	 * early due to a need of rescheduling.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+		if (!journal-&gt;j_checkpoint_transactions) {</span>
<span class="p_add">+			spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		__jbd2_journal_clean_checkpoint_list(journal, true);</span>
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * journal_remove_checkpoint: called after a buffer has been committed
  * to disk (either by being write-back flushed to disk, or being
  * committed to the log).
<span class="p_header">diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c</span>
<span class="p_header">index b73e0215baa7..362e5f614450 100644</span>
<span class="p_header">--- a/fs/jbd2/commit.c</span>
<span class="p_header">+++ b/fs/jbd2/commit.c</span>
<span class="p_chunk">@@ -510,7 +510,7 @@</span> <span class="p_context"> void jbd2_journal_commit_transaction(journal_t *journal)</span>
 	 * frees some memory
 	 */
 	spin_lock(&amp;journal-&gt;j_list_lock);
<span class="p_del">-	__jbd2_journal_clean_checkpoint_list(journal);</span>
<span class="p_add">+	__jbd2_journal_clean_checkpoint_list(journal, false);</span>
 	spin_unlock(&amp;journal-&gt;j_list_lock);
 
 	jbd_debug(3, &quot;JBD2: commit phase 1\n&quot;);
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 112fad9e1e20..7003c0925760 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -1708,8 +1708,17 @@</span> <span class="p_context"> int jbd2_journal_destroy(journal_t *journal)</span>
 	while (journal-&gt;j_checkpoint_transactions != NULL) {
 		spin_unlock(&amp;journal-&gt;j_list_lock);
 		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-		jbd2_log_do_checkpoint(journal);</span>
<span class="p_add">+		err = jbd2_log_do_checkpoint(journal);</span>
 		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If checkpointing failed, just free the buffers to avoid</span>
<span class="p_add">+		 * looping forever</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			jbd2_journal_destroy_checkpoint(journal);</span>
<span class="p_add">+			spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		spin_lock(&amp;journal-&gt;j_list_lock);
 	}
 
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 6f5f0f425e86..fecd9201dbad 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -1039,6 +1039,11 @@</span> <span class="p_context"> static int ff_layout_write_done_cb(struct rpc_task *task,</span>
 	    hdr-&gt;res.verf-&gt;committed == NFS_DATA_SYNC)
 		ff_layout_set_layoutcommit(hdr);
 
<span class="p_add">+	/* zero out fattr since we don&#39;t care DS attr at all */</span>
<span class="p_add">+	hdr-&gt;fattr.valid = 0;</span>
<span class="p_add">+	if (task-&gt;tk_status &gt;= 0)</span>
<span class="p_add">+		nfs_writeback_update_inode(hdr);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayoutdev.c b/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_header">index f13e1969eedd..b28fa4cbea52 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_chunk">@@ -500,16 +500,19 @@</span> <span class="p_context"> int ff_layout_encode_ds_ioerr(struct nfs4_flexfile_layout *flo,</span>
 					   range-&gt;offset, range-&gt;length))
 			continue;
 		/* offset(8) + length(8) + stateid(NFS4_STATEID_SIZE)
<span class="p_del">-		 * + deviceid(NFS4_DEVICEID4_SIZE) + status(4) + opnum(4)</span>
<span class="p_add">+		 * + array length + deviceid(NFS4_DEVICEID4_SIZE)</span>
<span class="p_add">+		 * + status(4) + opnum(4)</span>
 		 */
 		p = xdr_reserve_space(xdr,
<span class="p_del">-				24 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);</span>
<span class="p_add">+				28 + NFS4_STATEID_SIZE + NFS4_DEVICEID4_SIZE);</span>
 		if (unlikely(!p))
 			return -ENOBUFS;
 		p = xdr_encode_hyper(p, err-&gt;offset);
 		p = xdr_encode_hyper(p, err-&gt;length);
 		p = xdr_encode_opaque_fixed(p, &amp;err-&gt;stateid,
 					    NFS4_STATEID_SIZE);
<span class="p_add">+		/* Encode 1 error */</span>
<span class="p_add">+		*p++ = cpu_to_be32(1);</span>
 		p = xdr_encode_opaque_fixed(p, &amp;err-&gt;deviceid,
 					    NFS4_DEVICEID4_SIZE);
 		*p++ = cpu_to_be32(err-&gt;status);
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index 5d25b9d97c29..976ba792fbc6 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1270,13 +1270,6 @@</span> <span class="p_context"> static int nfs_check_inode_attributes(struct inode *inode, struct nfs_fattr *fat</span>
 	return 0;
 }
 
<span class="p_del">-static int nfs_ctime_need_update(const struct inode *inode, const struct nfs_fattr *fattr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!(fattr-&gt;valid &amp; NFS_ATTR_FATTR_CTIME))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	return timespec_compare(&amp;fattr-&gt;ctime, &amp;inode-&gt;i_ctime) &gt; 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static atomic_long_t nfs_attr_generation_counter;
 
 static unsigned long nfs_read_attr_generation_counter(void)
<span class="p_chunk">@@ -1425,7 +1418,6 @@</span> <span class="p_context"> static int nfs_inode_attrs_need_update(const struct inode *inode, const struct n</span>
 	const struct nfs_inode *nfsi = NFS_I(inode);
 
 	return ((long)fattr-&gt;gencount - (long)nfsi-&gt;attr_gencount) &gt; 0 ||
<span class="p_del">-		nfs_ctime_need_update(inode, fattr) ||</span>
 		((long)nfsi-&gt;attr_gencount - (long)nfs_read_attr_generation_counter() &gt; 0);
 }
 
<span class="p_chunk">@@ -1488,6 +1480,13 @@</span> <span class="p_context"> static int nfs_post_op_update_inode_locked(struct inode *inode, struct nfs_fattr</span>
 {
 	unsigned long invalid = NFS_INO_INVALID_ATTR|NFS_INO_REVAL_PAGECACHE;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t revalidate the pagecache if we hold a delegation, but do</span>
<span class="p_add">+	 * force an attribute update</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (NFS_PROTO(inode)-&gt;have_delegation(inode, FMODE_READ))</span>
<span class="p_add">+		invalid = NFS_INO_INVALID_ATTR|NFS_INO_REVAL_FORCED;</span>
<span class="p_add">+</span>
 	if (S_ISDIR(inode-&gt;i_mode))
 		invalid |= NFS_INO_INVALID_DATA;
 	nfs_set_cache_invalid(inode, invalid);
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index d3f205126609..c245874d7e9d 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -1152,6 +1152,8 @@</span> <span class="p_context"> static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)</span>
 		return 0;
 	if ((delegation-&gt;type &amp; fmode) != fmode)
 		return 0;
<span class="p_add">+	if (test_bit(NFS_DELEGATION_NEED_RECLAIM, &amp;delegation-&gt;flags))</span>
<span class="p_add">+		return 0;</span>
 	if (test_bit(NFS_DELEGATION_RETURNING, &amp;delegation-&gt;flags))
 		return 0;
 	nfs_mark_delegation_referenced(delegation);
<span class="p_chunk">@@ -1216,6 +1218,7 @@</span> <span class="p_context"> static void nfs_resync_open_stateid_locked(struct nfs4_state *state)</span>
 }
 
 static void nfs_clear_open_stateid_locked(struct nfs4_state *state,
<span class="p_add">+		nfs4_stateid *arg_stateid,</span>
 		nfs4_stateid *stateid, fmode_t fmode)
 {
 	clear_bit(NFS_O_RDWR_STATE, &amp;state-&gt;flags);
<span class="p_chunk">@@ -1234,8 +1237,9 @@</span> <span class="p_context"> static void nfs_clear_open_stateid_locked(struct nfs4_state *state,</span>
 	if (stateid == NULL)
 		return;
 	/* Handle races with OPEN */
<span class="p_del">-	if (!nfs4_stateid_match_other(stateid, &amp;state-&gt;open_stateid) ||</span>
<span class="p_del">-	    !nfs4_stateid_is_newer(stateid, &amp;state-&gt;open_stateid)) {</span>
<span class="p_add">+	if (!nfs4_stateid_match_other(arg_stateid, &amp;state-&gt;open_stateid) ||</span>
<span class="p_add">+	    (nfs4_stateid_match_other(stateid, &amp;state-&gt;open_stateid) &amp;&amp;</span>
<span class="p_add">+	    !nfs4_stateid_is_newer(stateid, &amp;state-&gt;open_stateid))) {</span>
 		nfs_resync_open_stateid_locked(state);
 		return;
 	}
<span class="p_chunk">@@ -1244,10 +1248,12 @@</span> <span class="p_context"> static void nfs_clear_open_stateid_locked(struct nfs4_state *state,</span>
 	nfs4_stateid_copy(&amp;state-&gt;open_stateid, stateid);
 }
 
<span class="p_del">-static void nfs_clear_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)</span>
<span class="p_add">+static void nfs_clear_open_stateid(struct nfs4_state *state,</span>
<span class="p_add">+	nfs4_stateid *arg_stateid,</span>
<span class="p_add">+	nfs4_stateid *stateid, fmode_t fmode)</span>
 {
 	write_seqlock(&amp;state-&gt;seqlock);
<span class="p_del">-	nfs_clear_open_stateid_locked(state, stateid, fmode);</span>
<span class="p_add">+	nfs_clear_open_stateid_locked(state, arg_stateid, stateid, fmode);</span>
 	write_sequnlock(&amp;state-&gt;seqlock);
 	if (test_bit(NFS_STATE_RECLAIM_NOGRACE, &amp;state-&gt;flags))
 		nfs4_schedule_state_manager(state-&gt;owner-&gt;so_server-&gt;nfs_client);
<span class="p_chunk">@@ -2413,7 +2419,7 @@</span> <span class="p_context"> static int _nfs4_do_open(struct inode *dir,</span>
 		goto err_free_label;
 	state = ctx-&gt;state;
 
<span class="p_del">-	if ((opendata-&gt;o_arg.open_flags &amp; O_EXCL) &amp;&amp;</span>
<span class="p_add">+	if ((opendata-&gt;o_arg.open_flags &amp; (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL) &amp;&amp;</span>
 	    (opendata-&gt;o_arg.createmode != NFS4_CREATE_GUARDED)) {
 		nfs4_exclusive_attrset(opendata, sattr);
 
<span class="p_chunk">@@ -2672,7 +2678,8 @@</span> <span class="p_context"> static void nfs4_close_done(struct rpc_task *task, void *data)</span>
 				goto out_release;
 			}
 	}
<span class="p_del">-	nfs_clear_open_stateid(state, res_stateid, calldata-&gt;arg.fmode);</span>
<span class="p_add">+	nfs_clear_open_stateid(state, &amp;calldata-&gt;arg.stateid,</span>
<span class="p_add">+			res_stateid, calldata-&gt;arg.fmode);</span>
 out_release:
 	nfs_release_seqid(calldata-&gt;arg.seqid);
 	nfs_refresh_inode(calldata-&gt;inode, calldata-&gt;res.fattr);
<span class="p_chunk">@@ -8571,6 +8578,7 @@</span> <span class="p_context"> static const struct nfs4_minor_version_ops nfs_v4_2_minor_ops = {</span>
 	.reboot_recovery_ops = &amp;nfs41_reboot_recovery_ops,
 	.nograce_recovery_ops = &amp;nfs41_nograce_recovery_ops,
 	.state_renewal_ops = &amp;nfs41_state_renewal_ops,
<span class="p_add">+	.mig_recovery_ops = &amp;nfs41_mig_recovery_ops,</span>
 };
 #endif
 
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index 7b4552678536..069914ce7641 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -77,8 +77,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_pgheader_init);</span>
 void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos)
 {
 	spin_lock(&amp;hdr-&gt;lock);
<span class="p_del">-	if (pos &lt; hdr-&gt;io_start + hdr-&gt;good_bytes) {</span>
<span class="p_del">-		set_bit(NFS_IOHDR_ERROR, &amp;hdr-&gt;flags);</span>
<span class="p_add">+	if (!test_and_set_bit(NFS_IOHDR_ERROR, &amp;hdr-&gt;flags)</span>
<span class="p_add">+	    || pos &lt; hdr-&gt;io_start + hdr-&gt;good_bytes) {</span>
 		clear_bit(NFS_IOHDR_EOF, &amp;hdr-&gt;flags);
 		hdr-&gt;good_bytes = pos - hdr-&gt;io_start;
 		hdr-&gt;error = error;
<span class="p_header">diff --git a/fs/nfs/pnfs_nfs.c b/fs/nfs/pnfs_nfs.c</span>
<span class="p_header">index f37e25b6311c..1705c78ee2d8 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs_nfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs_nfs.c</span>
<span class="p_chunk">@@ -359,26 +359,31 @@</span> <span class="p_context"> same_sockaddr(struct sockaddr *addr1, struct sockaddr *addr2)</span>
 	return false;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Checks if &#39;dsaddrs1&#39; contains a subset of &#39;dsaddrs2&#39;. If it does,</span>
<span class="p_add">+ * declare a match.</span>
<span class="p_add">+ */</span>
 static bool
 _same_data_server_addrs_locked(const struct list_head *dsaddrs1,
 			       const struct list_head *dsaddrs2)
 {
 	struct nfs4_pnfs_ds_addr *da1, *da2;
<span class="p_del">-</span>
<span class="p_del">-	/* step through both lists, comparing as we go */</span>
<span class="p_del">-	for (da1 = list_first_entry(dsaddrs1, typeof(*da1), da_node),</span>
<span class="p_del">-	     da2 = list_first_entry(dsaddrs2, typeof(*da2), da_node);</span>
<span class="p_del">-	     da1 != NULL &amp;&amp; da2 != NULL;</span>
<span class="p_del">-	     da1 = list_entry(da1-&gt;da_node.next, typeof(*da1), da_node),</span>
<span class="p_del">-	     da2 = list_entry(da2-&gt;da_node.next, typeof(*da2), da_node)) {</span>
<span class="p_del">-		if (!same_sockaddr((struct sockaddr *)&amp;da1-&gt;da_addr,</span>
<span class="p_del">-				   (struct sockaddr *)&amp;da2-&gt;da_addr))</span>
<span class="p_del">-			return false;</span>
<span class="p_add">+	struct sockaddr *sa1, *sa2;</span>
<span class="p_add">+	bool match = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(da1, dsaddrs1, da_node) {</span>
<span class="p_add">+		sa1 = (struct sockaddr *)&amp;da1-&gt;da_addr;</span>
<span class="p_add">+		match = false;</span>
<span class="p_add">+		list_for_each_entry(da2, dsaddrs2, da_node) {</span>
<span class="p_add">+			sa2 = (struct sockaddr *)&amp;da2-&gt;da_addr;</span>
<span class="p_add">+			match = same_sockaddr(sa1, sa2);</span>
<span class="p_add">+			if (match)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!match)</span>
<span class="p_add">+			break;</span>
 	}
<span class="p_del">-	if (da1 == NULL &amp;&amp; da2 == NULL)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_add">+	return match;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index daf355642845..07115b9b1ad2 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1383,24 +1383,27 @@</span> <span class="p_context"> static void nfs_writeback_check_extend(struct nfs_pgio_header *hdr,</span>
 {
 	struct nfs_pgio_args *argp = &amp;hdr-&gt;args;
 	struct nfs_pgio_res *resp = &amp;hdr-&gt;res;
<span class="p_add">+	u64 size = argp-&gt;offset + resp-&gt;count;</span>
 
 	if (!(fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE))
<span class="p_add">+		fattr-&gt;size = size;</span>
<span class="p_add">+	if (nfs_size_to_loff_t(fattr-&gt;size) &lt; i_size_read(hdr-&gt;inode)) {</span>
<span class="p_add">+		fattr-&gt;valid &amp;= ~NFS_ATTR_FATTR_SIZE;</span>
 		return;
<span class="p_del">-	if (argp-&gt;offset + resp-&gt;count != fattr-&gt;size)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (nfs_size_to_loff_t(fattr-&gt;size) &lt; i_size_read(hdr-&gt;inode))</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (size != fattr-&gt;size)</span>
 		return;
 	/* Set attribute barrier */
 	nfs_fattr_set_barrier(fattr);
<span class="p_add">+	/* ...and update size */</span>
<span class="p_add">+	fattr-&gt;valid |= NFS_ATTR_FATTR_SIZE;</span>
 }
 
 void nfs_writeback_update_inode(struct nfs_pgio_header *hdr)
 {
<span class="p_del">-	struct nfs_fattr *fattr = hdr-&gt;res.fattr;</span>
<span class="p_add">+	struct nfs_fattr *fattr = &amp;hdr-&gt;fattr;</span>
 	struct inode *inode = hdr-&gt;inode;
 
<span class="p_del">-	if (fattr == NULL)</span>
<span class="p_del">-		return;</span>
 	spin_lock(&amp;inode-&gt;i_lock);
 	nfs_writeback_check_extend(hdr, fattr);
 	nfs_post_op_update_inode_force_wcc_locked(inode, fattr);
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 6e13504f736e..397798368b1a 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -777,13 +777,16 @@</span> <span class="p_context"> hash_delegation_locked(struct nfs4_delegation *dp, struct nfs4_file *fp)</span>
 	list_add(&amp;dp-&gt;dl_perclnt, &amp;dp-&gt;dl_stid.sc_client-&gt;cl_delegations);
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static bool</span>
 unhash_delegation_locked(struct nfs4_delegation *dp)
 {
 	struct nfs4_file *fp = dp-&gt;dl_stid.sc_file;
 
 	lockdep_assert_held(&amp;state_lock);
 
<span class="p_add">+	if (list_empty(&amp;dp-&gt;dl_perfile))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	dp-&gt;dl_stid.sc_type = NFS4_CLOSED_DELEG_STID;
 	/* Ensure that deleg break won&#39;t try to requeue it */
 	++dp-&gt;dl_time;
<span class="p_chunk">@@ -792,16 +795,21 @@</span> <span class="p_context"> unhash_delegation_locked(struct nfs4_delegation *dp)</span>
 	list_del_init(&amp;dp-&gt;dl_recall_lru);
 	list_del_init(&amp;dp-&gt;dl_perfile);
 	spin_unlock(&amp;fp-&gt;fi_lock);
<span class="p_add">+	return true;</span>
 }
 
 static void destroy_delegation(struct nfs4_delegation *dp)
 {
<span class="p_add">+	bool unhashed;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;state_lock);
<span class="p_del">-	unhash_delegation_locked(dp);</span>
<span class="p_add">+	unhashed = unhash_delegation_locked(dp);</span>
 	spin_unlock(&amp;state_lock);
<span class="p_del">-	put_clnt_odstate(dp-&gt;dl_clnt_odstate);</span>
<span class="p_del">-	nfs4_put_deleg_lease(dp-&gt;dl_stid.sc_file);</span>
<span class="p_del">-	nfs4_put_stid(&amp;dp-&gt;dl_stid);</span>
<span class="p_add">+	if (unhashed) {</span>
<span class="p_add">+		put_clnt_odstate(dp-&gt;dl_clnt_odstate);</span>
<span class="p_add">+		nfs4_put_deleg_lease(dp-&gt;dl_stid.sc_file);</span>
<span class="p_add">+		nfs4_put_stid(&amp;dp-&gt;dl_stid);</span>
<span class="p_add">+	}</span>
 }
 
 static void revoke_delegation(struct nfs4_delegation *dp)
<span class="p_chunk">@@ -1004,16 +1012,20 @@</span> <span class="p_context"> static void nfs4_put_stateowner(struct nfs4_stateowner *sop)</span>
 	sop-&gt;so_ops-&gt;so_free(sop);
 }
 
<span class="p_del">-static void unhash_ol_stateid(struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+static bool unhash_ol_stateid(struct nfs4_ol_stateid *stp)</span>
 {
 	struct nfs4_file *fp = stp-&gt;st_stid.sc_file;
 
 	lockdep_assert_held(&amp;stp-&gt;st_stateowner-&gt;so_client-&gt;cl_lock);
 
<span class="p_add">+	if (list_empty(&amp;stp-&gt;st_perfile))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;fp-&gt;fi_lock);
<span class="p_del">-	list_del(&amp;stp-&gt;st_perfile);</span>
<span class="p_add">+	list_del_init(&amp;stp-&gt;st_perfile);</span>
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	list_del(&amp;stp-&gt;st_perstateowner);
<span class="p_add">+	return true;</span>
 }
 
 static void nfs4_free_ol_stateid(struct nfs4_stid *stid)
<span class="p_chunk">@@ -1063,25 +1075,27 @@</span> <span class="p_context"> static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,</span>
 	list_add(&amp;stp-&gt;st_locks, reaplist);
 }
 
<span class="p_del">-static void unhash_lock_stateid(struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)</span>
 {
 	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);
 
 	lockdep_assert_held(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 
 	list_del_init(&amp;stp-&gt;st_locks);
<span class="p_del">-	unhash_ol_stateid(stp);</span>
 	nfs4_unhash_stid(&amp;stp-&gt;st_stid);
<span class="p_add">+	return unhash_ol_stateid(stp);</span>
 }
 
 static void release_lock_stateid(struct nfs4_ol_stateid *stp)
 {
 	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);
<span class="p_add">+	bool unhashed;</span>
 
 	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
<span class="p_del">-	unhash_lock_stateid(stp);</span>
<span class="p_add">+	unhashed = unhash_lock_stateid(stp);</span>
 	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
<span class="p_del">-	nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	if (unhashed)</span>
<span class="p_add">+		nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
 }
 
 static void unhash_lockowner_locked(struct nfs4_lockowner *lo)
<span class="p_chunk">@@ -1129,7 +1143,7 @@</span> <span class="p_context"> static void release_lockowner(struct nfs4_lockowner *lo)</span>
 	while (!list_empty(&amp;lo-&gt;lo_owner.so_stateids)) {
 		stp = list_first_entry(&amp;lo-&gt;lo_owner.so_stateids,
 				struct nfs4_ol_stateid, st_perstateowner);
<span class="p_del">-		unhash_lock_stateid(stp);</span>
<span class="p_add">+		WARN_ON(!unhash_lock_stateid(stp));</span>
 		put_ol_stateid_locked(stp, &amp;reaplist);
 	}
 	spin_unlock(&amp;clp-&gt;cl_lock);
<span class="p_chunk">@@ -1142,21 +1156,26 @@</span> <span class="p_context"> static void release_open_stateid_locks(struct nfs4_ol_stateid *open_stp,</span>
 {
 	struct nfs4_ol_stateid *stp;
 
<span class="p_add">+	lockdep_assert_held(&amp;open_stp-&gt;st_stid.sc_client-&gt;cl_lock);</span>
<span class="p_add">+</span>
 	while (!list_empty(&amp;open_stp-&gt;st_locks)) {
 		stp = list_entry(open_stp-&gt;st_locks.next,
 				struct nfs4_ol_stateid, st_locks);
<span class="p_del">-		unhash_lock_stateid(stp);</span>
<span class="p_add">+		WARN_ON(!unhash_lock_stateid(stp));</span>
 		put_ol_stateid_locked(stp, reaplist);
 	}
 }
 
<span class="p_del">-static void unhash_open_stateid(struct nfs4_ol_stateid *stp,</span>
<span class="p_add">+static bool unhash_open_stateid(struct nfs4_ol_stateid *stp,</span>
 				struct list_head *reaplist)
 {
<span class="p_add">+	bool unhashed;</span>
<span class="p_add">+</span>
 	lockdep_assert_held(&amp;stp-&gt;st_stid.sc_client-&gt;cl_lock);
 
<span class="p_del">-	unhash_ol_stateid(stp);</span>
<span class="p_add">+	unhashed = unhash_ol_stateid(stp);</span>
 	release_open_stateid_locks(stp, reaplist);
<span class="p_add">+	return unhashed;</span>
 }
 
 static void release_open_stateid(struct nfs4_ol_stateid *stp)
<span class="p_chunk">@@ -1164,8 +1183,8 @@</span> <span class="p_context"> static void release_open_stateid(struct nfs4_ol_stateid *stp)</span>
 	LIST_HEAD(reaplist);
 
 	spin_lock(&amp;stp-&gt;st_stid.sc_client-&gt;cl_lock);
<span class="p_del">-	unhash_open_stateid(stp, &amp;reaplist);</span>
<span class="p_del">-	put_ol_stateid_locked(stp, &amp;reaplist);</span>
<span class="p_add">+	if (unhash_open_stateid(stp, &amp;reaplist))</span>
<span class="p_add">+		put_ol_stateid_locked(stp, &amp;reaplist);</span>
 	spin_unlock(&amp;stp-&gt;st_stid.sc_client-&gt;cl_lock);
 	free_ol_stateid_reaplist(&amp;reaplist);
 }
<span class="p_chunk">@@ -1210,8 +1229,8 @@</span> <span class="p_context"> static void release_openowner(struct nfs4_openowner *oo)</span>
 	while (!list_empty(&amp;oo-&gt;oo_owner.so_stateids)) {
 		stp = list_first_entry(&amp;oo-&gt;oo_owner.so_stateids,
 				struct nfs4_ol_stateid, st_perstateowner);
<span class="p_del">-		unhash_open_stateid(stp, &amp;reaplist);</span>
<span class="p_del">-		put_ol_stateid_locked(stp, &amp;reaplist);</span>
<span class="p_add">+		if (unhash_open_stateid(stp, &amp;reaplist))</span>
<span class="p_add">+			put_ol_stateid_locked(stp, &amp;reaplist);</span>
 	}
 	spin_unlock(&amp;clp-&gt;cl_lock);
 	free_ol_stateid_reaplist(&amp;reaplist);
<span class="p_chunk">@@ -1714,7 +1733,7 @@</span> <span class="p_context"> __destroy_client(struct nfs4_client *clp)</span>
 	spin_lock(&amp;state_lock);
 	while (!list_empty(&amp;clp-&gt;cl_delegations)) {
 		dp = list_entry(clp-&gt;cl_delegations.next, struct nfs4_delegation, dl_perclnt);
<span class="p_del">-		unhash_delegation_locked(dp);</span>
<span class="p_add">+		WARN_ON(!unhash_delegation_locked(dp));</span>
 		list_add(&amp;dp-&gt;dl_recall_lru, &amp;reaplist);
 	}
 	spin_unlock(&amp;state_lock);
<span class="p_chunk">@@ -4346,7 +4365,7 @@</span> <span class="p_context"> nfs4_laundromat(struct nfsd_net *nn)</span>
 			new_timeo = min(new_timeo, t);
 			break;
 		}
<span class="p_del">-		unhash_delegation_locked(dp);</span>
<span class="p_add">+		WARN_ON(!unhash_delegation_locked(dp));</span>
 		list_add(&amp;dp-&gt;dl_recall_lru, &amp;reaplist);
 	}
 	spin_unlock(&amp;state_lock);
<span class="p_chunk">@@ -4714,7 +4733,7 @@</span> <span class="p_context"> nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 		if (check_for_locks(stp-&gt;st_stid.sc_file,
 				    lockowner(stp-&gt;st_stateowner)))
 			break;
<span class="p_del">-		unhash_lock_stateid(stp);</span>
<span class="p_add">+		WARN_ON(!unhash_lock_stateid(stp));</span>
 		spin_unlock(&amp;cl-&gt;cl_lock);
 		nfs4_put_stid(s);
 		ret = nfs_ok;
<span class="p_chunk">@@ -4930,20 +4949,23 @@</span> <span class="p_context"> out:</span>
 static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)
 {
 	struct nfs4_client *clp = s-&gt;st_stid.sc_client;
<span class="p_add">+	bool unhashed;</span>
 	LIST_HEAD(reaplist);
 
 	s-&gt;st_stid.sc_type = NFS4_CLOSED_STID;
 	spin_lock(&amp;clp-&gt;cl_lock);
<span class="p_del">-	unhash_open_stateid(s, &amp;reaplist);</span>
<span class="p_add">+	unhashed = unhash_open_stateid(s, &amp;reaplist);</span>
 
 	if (clp-&gt;cl_minorversion) {
<span class="p_del">-		put_ol_stateid_locked(s, &amp;reaplist);</span>
<span class="p_add">+		if (unhashed)</span>
<span class="p_add">+			put_ol_stateid_locked(s, &amp;reaplist);</span>
 		spin_unlock(&amp;clp-&gt;cl_lock);
 		free_ol_stateid_reaplist(&amp;reaplist);
 	} else {
 		spin_unlock(&amp;clp-&gt;cl_lock);
 		free_ol_stateid_reaplist(&amp;reaplist);
<span class="p_del">-		move_to_close_lru(s, clp-&gt;net);</span>
<span class="p_add">+		if (unhashed)</span>
<span class="p_add">+			move_to_close_lru(s, clp-&gt;net);</span>
 	}
 }
 
<span class="p_chunk">@@ -5982,7 +6004,7 @@</span> <span class="p_context"> nfsd_inject_add_lock_to_list(struct nfs4_ol_stateid *lst,</span>
 
 static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,
 				    struct list_head *collect,
<span class="p_del">-				    void (*func)(struct nfs4_ol_stateid *))</span>
<span class="p_add">+				    bool (*func)(struct nfs4_ol_stateid *))</span>
 {
 	struct nfs4_openowner *oop;
 	struct nfs4_ol_stateid *stp, *st_next;
<span class="p_chunk">@@ -5996,9 +6018,9 @@</span> <span class="p_context"> static u64 nfsd_foreach_client_lock(struct nfs4_client *clp, u64 max,</span>
 			list_for_each_entry_safe(lst, lst_next,
 					&amp;stp-&gt;st_locks, st_locks) {
 				if (func) {
<span class="p_del">-					func(lst);</span>
<span class="p_del">-					nfsd_inject_add_lock_to_list(lst,</span>
<span class="p_del">-								collect);</span>
<span class="p_add">+					if (func(lst))</span>
<span class="p_add">+						nfsd_inject_add_lock_to_list(lst,</span>
<span class="p_add">+									collect);</span>
 				}
 				++count;
 				/*
<span class="p_chunk">@@ -6268,7 +6290,7 @@</span> <span class="p_context"> static u64 nfsd_find_all_delegations(struct nfs4_client *clp, u64 max,</span>
 				continue;
 
 			atomic_inc(&amp;clp-&gt;cl_refcount);
<span class="p_del">-			unhash_delegation_locked(dp);</span>
<span class="p_add">+			WARN_ON(!unhash_delegation_locked(dp));</span>
 			list_add(&amp;dp-&gt;dl_recall_lru, victims);
 		}
 		++count;
<span class="p_chunk">@@ -6598,7 +6620,7 @@</span> <span class="p_context"> nfs4_state_shutdown_net(struct net *net)</span>
 	spin_lock(&amp;state_lock);
 	list_for_each_safe(pos, next, &amp;nn-&gt;del_recall_lru) {
 		dp = list_entry (pos, struct nfs4_delegation, dl_recall_lru);
<span class="p_del">-		unhash_delegation_locked(dp);</span>
<span class="p_add">+		WARN_ON(!unhash_delegation_locked(dp));</span>
 		list_add(&amp;dp-&gt;dl_recall_lru, &amp;reaplist);
 	}
 	spin_unlock(&amp;state_lock);
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index d4d84451e0e6..3dd1b616b92b 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -2139,6 +2139,27 @@</span> <span class="p_context"> nfsd4_encode_aclname(struct xdr_stream *xdr, struct svc_rqst *rqstp,</span>
 		return nfsd4_encode_user(xdr, rqstp, ace-&gt;who_uid);
 }
 
<span class="p_add">+static inline __be32</span>
<span class="p_add">+nfsd4_encode_layout_type(struct xdr_stream *xdr, enum pnfs_layouttype layout_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layout_type) {</span>
<span class="p_add">+		p = xdr_reserve_space(xdr, 8);</span>
<span class="p_add">+		if (!p)</span>
<span class="p_add">+			return nfserr_resource;</span>
<span class="p_add">+		*p++ = cpu_to_be32(1);</span>
<span class="p_add">+		*p++ = cpu_to_be32(layout_type);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		p = xdr_reserve_space(xdr, 4);</span>
<span class="p_add">+		if (!p)</span>
<span class="p_add">+			return nfserr_resource;</span>
<span class="p_add">+		*p++ = cpu_to_be32(0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define WORD0_ABSENT_FS_ATTRS (FATTR4_WORD0_FS_LOCATIONS | FATTR4_WORD0_FSID | \
 			      FATTR4_WORD0_RDATTR_ERROR)
 #define WORD1_ABSENT_FS_ATTRS FATTR4_WORD1_MOUNTED_ON_FILEID
<span class="p_chunk">@@ -2692,20 +2713,16 @@</span> <span class="p_context"> out_acl:</span>
 		p = xdr_encode_hyper(p, stat.ino);
 	}
 #ifdef CONFIG_NFSD_PNFS
<span class="p_del">-	if ((bmval1 &amp; FATTR4_WORD1_FS_LAYOUT_TYPES) ||</span>
<span class="p_del">-	    (bmval2 &amp; FATTR4_WORD2_LAYOUT_TYPES)) {</span>
<span class="p_del">-		if (exp-&gt;ex_layout_type) {</span>
<span class="p_del">-			p = xdr_reserve_space(xdr, 8);</span>
<span class="p_del">-			if (!p)</span>
<span class="p_del">-				goto out_resource;</span>
<span class="p_del">-			*p++ = cpu_to_be32(1);</span>
<span class="p_del">-			*p++ = cpu_to_be32(exp-&gt;ex_layout_type);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			p = xdr_reserve_space(xdr, 4);</span>
<span class="p_del">-			if (!p)</span>
<span class="p_del">-				goto out_resource;</span>
<span class="p_del">-			*p++ = cpu_to_be32(0);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (bmval1 &amp; FATTR4_WORD1_FS_LAYOUT_TYPES) {</span>
<span class="p_add">+		status = nfsd4_encode_layout_type(xdr, exp-&gt;ex_layout_type);</span>
<span class="p_add">+		if (status)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bmval2 &amp; FATTR4_WORD2_LAYOUT_TYPES) {</span>
<span class="p_add">+		status = nfsd4_encode_layout_type(xdr, exp-&gt;ex_layout_type);</span>
<span class="p_add">+		if (status)</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	if (bmval2 &amp; FATTR4_WORD2_LAYOUT_BLKSIZE) {
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index edb640ae9a94..eb1cebed3f36 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1042,8 +1042,9 @@</span> <span class="p_context"> void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 extern void jbd2_journal_commit_transaction(journal_t *);
 
 /* Checkpoint list management */
<span class="p_del">-void __jbd2_journal_clean_checkpoint_list(journal_t *journal);</span>
<span class="p_add">+void __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy);</span>
 int __jbd2_journal_remove_checkpoint(struct journal_head *);
<span class="p_add">+void jbd2_journal_destroy_checkpoint(journal_t *journal);</span>
 void __jbd2_journal_insert_checkpoint(struct journal_head *, transaction_t *);
 
 
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 0755b9fd03a7..b2085582d44e 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1002,6 +1002,34 @@</span> <span class="p_context"> static inline int page_mapped(struct page *page)</span>
 }
 
 /*
<span class="p_add">+ * Return true only if the page has been allocated with</span>
<span class="p_add">+ * ALLOC_NO_WATERMARKS and the low watermark was not</span>
<span class="p_add">+ * met implying that the system is under some pressure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool page_is_pfmemalloc(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Page index cannot be this large so this must be</span>
<span class="p_add">+	 * a pfmemalloc page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return page-&gt;index == -1UL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Only to be called by the page allocator on a freshly allocated</span>
<span class="p_add">+ * page.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void set_page_pfmemalloc(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	page-&gt;index = -1UL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void clear_page_pfmemalloc(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	page-&gt;index = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Different kinds of faults, as returned by handle_mm_fault().
  * Used to decide whether a process gets delivered SIGBUS or
  * just gets major/minor fault counters bumped up.
<span class="p_header">diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h</span>
<span class="p_header">index 8d37e26a1007..c0c6b33535fb 100644</span>
<span class="p_header">--- a/include/linux/mm_types.h</span>
<span class="p_header">+++ b/include/linux/mm_types.h</span>
<span class="p_chunk">@@ -63,15 +63,6 @@</span> <span class="p_context"> struct page {</span>
 		union {
 			pgoff_t index;		/* Our offset within mapping. */
 			void *freelist;		/* sl[aou]b first free object */
<span class="p_del">-			bool pfmemalloc;	/* If set by the page allocator,</span>
<span class="p_del">-						 * ALLOC_NO_WATERMARKS was set</span>
<span class="p_del">-						 * and the low watermark was not</span>
<span class="p_del">-						 * met implying that the system</span>
<span class="p_del">-						 * is under some pressure. The</span>
<span class="p_del">-						 * caller should try ensure</span>
<span class="p_del">-						 * this page is only used to</span>
<span class="p_del">-						 * free other pages.</span>
<span class="p_del">-						 */</span>
 		};
 
 		union {
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index f15154a879c7..eb1c55b8255a 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -1590,20 +1590,16 @@</span> <span class="p_context"> static inline void __skb_fill_page_desc(struct sk_buff *skb, int i,</span>
 	skb_frag_t *frag = &amp;skb_shinfo(skb)-&gt;frags[i];
 
 	/*
<span class="p_del">-	 * Propagate page-&gt;pfmemalloc to the skb if we can. The problem is</span>
<span class="p_del">-	 * that not all callers have unique ownership of the page. If</span>
<span class="p_del">-	 * pfmemalloc is set, we check the mapping as a mapping implies</span>
<span class="p_del">-	 * page-&gt;index is set (index and pfmemalloc share space).</span>
<span class="p_del">-	 * If it&#39;s a valid mapping, we cannot use page-&gt;pfmemalloc but we</span>
<span class="p_del">-	 * do not lose pfmemalloc information as the pages would not be</span>
<span class="p_del">-	 * allocated using __GFP_MEMALLOC.</span>
<span class="p_add">+	 * Propagate page pfmemalloc to the skb if we can. The problem is</span>
<span class="p_add">+	 * that not all callers have unique ownership of the page but rely</span>
<span class="p_add">+	 * on page_is_pfmemalloc doing the right thing(tm).</span>
 	 */
 	frag-&gt;page.p		  = page;
 	frag-&gt;page_offset	  = off;
 	skb_frag_size_set(frag, size);
 
 	page = compound_head(page);
<span class="p_del">-	if (page-&gt;pfmemalloc &amp;&amp; !page-&gt;mapping)</span>
<span class="p_add">+	if (page_is_pfmemalloc(page))</span>
 		skb-&gt;pfmemalloc	= true;
 }
 
<span class="p_chunk">@@ -2250,7 +2246,7 @@</span> <span class="p_context"> static inline struct page *dev_alloc_page(void)</span>
 static inline void skb_propagate_pfmemalloc(struct page *page,
 					     struct sk_buff *skb)
 {
<span class="p_del">-	if (page &amp;&amp; page-&gt;pfmemalloc)</span>
<span class="p_add">+	if (page_is_pfmemalloc(page))</span>
 		skb-&gt;pfmemalloc = true;
 }
 
<span class="p_header">diff --git a/include/linux/sunrpc/xprtsock.h b/include/linux/sunrpc/xprtsock.h</span>
<span class="p_header">index 7591788e9fbf..357e44c1a46b 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/xprtsock.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/xprtsock.h</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> struct sock_xprt {</span>
 	/*
 	 * Connection of transports
 	 */
<span class="p_add">+	unsigned long		sock_state;</span>
 	struct delayed_work	connect_worker;
 	struct sockaddr_storage	srcaddr;
 	unsigned short		srcport;
<span class="p_chunk">@@ -76,6 +77,8 @@</span> <span class="p_context"> struct sock_xprt {</span>
  */
 #define TCP_RPC_REPLY		(1UL &lt;&lt; 6)
 
<span class="p_add">+#define XPRT_SOCK_CONNECTING	1U</span>
<span class="p_add">+</span>
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_SUNRPC_XPRTSOCK_H */
<span class="p_header">diff --git a/include/net/act_api.h b/include/net/act_api.h</span>
<span class="p_header">index 3ee4c92afd1b..931738bc5bba 100644</span>
<span class="p_header">--- a/include/net/act_api.h</span>
<span class="p_header">+++ b/include/net/act_api.h</span>
<span class="p_chunk">@@ -99,7 +99,6 @@</span> <span class="p_context"> struct tc_action_ops {</span>
 
 int tcf_hash_search(struct tc_action *a, u32 index);
 void tcf_hash_destroy(struct tc_action *a);
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind);</span>
 u32 tcf_hash_new_index(struct tcf_hashinfo *hinfo);
 int tcf_hash_check(u32 index, struct tc_action *a, int bind);
 int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,
<span class="p_chunk">@@ -107,6 +106,13 @@</span> <span class="p_context"> int tcf_hash_create(u32 index, struct nlattr *est, struct tc_action *a,</span>
 void tcf_hash_cleanup(struct tc_action *a, struct nlattr *est);
 void tcf_hash_insert(struct tc_action *a);
 
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int tcf_hash_release(struct tc_action *a, bool bind)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __tcf_hash_release(a, bind, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int tcf_register_action(struct tc_action_ops *a, unsigned int mask);
 int tcf_unregister_action(struct tc_action_ops *a);
 int tcf_action_destroy(struct list_head *actions, int bind);
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index d14af7edd197..f41fc497b21b 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -161,6 +161,7 @@</span> <span class="p_context"> static inline __u8 get_rtconn_flags(struct ipcm_cookie* ipc, struct sock* sk)</span>
 }
 
 /* datagram.c */
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);</span>
 int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 
 void ip4_datagram_release_cb(struct sock *sk);
<span class="p_header">diff --git a/include/soc/tegra/mc.h b/include/soc/tegra/mc.h</span>
<span class="p_header">index 63deb8d9f82a..d298857cd845 100644</span>
<span class="p_header">--- a/include/soc/tegra/mc.h</span>
<span class="p_header">+++ b/include/soc/tegra/mc.h</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> struct tegra_smmu_soc {</span>
 	bool supports_round_robin_arbitration;
 	bool supports_request_limit;
 
<span class="p_add">+	unsigned int num_tlb_lines;</span>
 	unsigned int num_asids;
 
 	const struct tegra_smmu_ops *ops;
<span class="p_header">diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h</span>
<span class="p_header">index fd1a02cb3c82..003dca933803 100644</span>
<span class="p_header">--- a/include/trace/events/sunrpc.h</span>
<span class="p_header">+++ b/include/trace/events/sunrpc.h</span>
<span class="p_chunk">@@ -529,18 +529,21 @@</span> <span class="p_context"> TRACE_EVENT(svc_xprt_do_enqueue,</span>
 
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
<span class="p_del">-		__field(struct svc_rqst *, rqst)</span>
<span class="p_add">+		__field_struct(struct sockaddr_storage, ss)</span>
<span class="p_add">+		__field(int, pid)</span>
<span class="p_add">+		__field(unsigned long, flags)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_del">-		__entry-&gt;rqst = rqst;</span>
<span class="p_add">+		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
<span class="p_add">+		__entry-&gt;pid = rqst? rqst-&gt;rq_task-&gt;pid : 0;</span>
<span class="p_add">+		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp pid=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;xprt-&gt;xpt_remote,</span>
<span class="p_del">-		__entry-&gt;rqst ? __entry-&gt;rqst-&gt;rq_task-&gt;pid : 0,</span>
<span class="p_del">-		show_svc_xprt_flags(__entry-&gt;xprt-&gt;xpt_flags))</span>
<span class="p_add">+		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__entry-&gt;pid, show_svc_xprt_flags(__entry-&gt;flags))</span>
 );
 
 TRACE_EVENT(svc_xprt_dequeue,
<span class="p_chunk">@@ -589,16 +592,20 @@</span> <span class="p_context"> TRACE_EVENT(svc_handle_xprt,</span>
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
 		__field(int, len)
<span class="p_add">+		__field_struct(struct sockaddr_storage, ss)</span>
<span class="p_add">+		__field(unsigned long, flags)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_add">+		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
 		__entry-&gt;len = len;
<span class="p_add">+		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp len=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;xprt-&gt;xpt_remote, __entry-&gt;len,</span>
<span class="p_del">-		show_svc_xprt_flags(__entry-&gt;xprt-&gt;xpt_flags))</span>
<span class="p_add">+		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__entry-&gt;len, show_svc_xprt_flags(__entry-&gt;flags))</span>
 );
 #endif /* _TRACE_SUNRPC_H */
 
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 03c1eaaa6ef5..8209fa2d36ef 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -1854,13 +1854,21 @@</span> <span class="p_context"> static int check_unshare_flags(unsigned long unshare_flags)</span>
 				CLONE_NEWUSER|CLONE_NEWPID))
 		return -EINVAL;
 	/*
<span class="p_del">-	 * Not implemented, but pretend it works if there is nothing to</span>
<span class="p_del">-	 * unshare. Note that unsharing CLONE_THREAD or CLONE_SIGHAND</span>
<span class="p_del">-	 * needs to unshare vm.</span>
<span class="p_add">+	 * Not implemented, but pretend it works if there is nothing</span>
<span class="p_add">+	 * to unshare.  Note that unsharing the address space or the</span>
<span class="p_add">+	 * signal handlers also need to unshare the signal queues (aka</span>
<span class="p_add">+	 * CLONE_THREAD).</span>
 	 */
 	if (unshare_flags &amp; (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {
<span class="p_del">-		/* FIXME: get_task_mm() increments -&gt;mm_users */</span>
<span class="p_del">-		if (atomic_read(&amp;current-&gt;mm-&gt;mm_users) &gt; 1)</span>
<span class="p_add">+		if (!thread_group_empty(current))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (unshare_flags &amp; (CLONE_SIGHAND | CLONE_VM)) {</span>
<span class="p_add">+		if (atomic_read(&amp;current-&gt;sighand-&gt;count) &gt; 1)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (unshare_flags &amp; CLONE_VM) {</span>
<span class="p_add">+		if (!current_is_single_threaded())</span>
 			return -EINVAL;
 	}
 
<span class="p_chunk">@@ -1929,16 +1937,16 @@</span> <span class="p_context"> SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)</span>
 	if (unshare_flags &amp; CLONE_NEWUSER)
 		unshare_flags |= CLONE_THREAD | CLONE_FS;
 	/*
<span class="p_del">-	 * If unsharing a thread from a thread group, must also unshare vm.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unshare_flags &amp; CLONE_THREAD)</span>
<span class="p_del">-		unshare_flags |= CLONE_VM;</span>
<span class="p_del">-	/*</span>
 	 * If unsharing vm, must also unshare signal handlers.
 	 */
 	if (unshare_flags &amp; CLONE_VM)
 		unshare_flags |= CLONE_SIGHAND;
 	/*
<span class="p_add">+	 * If unsharing a signal handlers, must also unshare the signal queues.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unshare_flags &amp; CLONE_SIGHAND)</span>
<span class="p_add">+		unshare_flags |= CLONE_THREAD;</span>
<span class="p_add">+	/*</span>
 	 * If unsharing namespace, must also unshare filesystem information.
 	 */
 	if (unshare_flags &amp; CLONE_NEWNS)
<span class="p_header">diff --git a/lib/decompress_bunzip2.c b/lib/decompress_bunzip2.c</span>
<span class="p_header">index 6dd0335ea61b..0234361b24b8 100644</span>
<span class="p_header">--- a/lib/decompress_bunzip2.c</span>
<span class="p_header">+++ b/lib/decompress_bunzip2.c</span>
<span class="p_chunk">@@ -743,12 +743,12 @@</span> <span class="p_context"> exit_0:</span>
 }
 
 #ifdef PREBOOT
<span class="p_del">-STATIC int INIT decompress(unsigned char *buf, long len,</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long len,</span>
 			long (*fill)(void*, unsigned long),
 			long (*flush)(void*, unsigned long),
<span class="p_del">-			unsigned char *outbuf,</span>
<span class="p_add">+			unsigned char *outbuf, long olen,</span>
 			long *pos,
<span class="p_del">-			void(*error)(char *x))</span>
<span class="p_add">+			void (*error)(char *x))</span>
 {
 	return bunzip2(buf, len - 4, fill, flush, outbuf, pos, error);
 }
<span class="p_header">diff --git a/lib/decompress_inflate.c b/lib/decompress_inflate.c</span>
<span class="p_header">index d4c7891635ec..555c06bf20da 100644</span>
<span class="p_header">--- a/lib/decompress_inflate.c</span>
<span class="p_header">+++ b/lib/decompress_inflate.c</span>
<span class="p_chunk">@@ -1,4 +1,5 @@</span> <span class="p_context"></span>
 #ifdef STATIC
<span class="p_add">+#define PREBOOT</span>
 /* Pre-boot environment: included */
 
 /* prevent inclusion of _LINUX_KERNEL_H in pre-boot environment: lots
<span class="p_chunk">@@ -33,23 +34,23 @@</span> <span class="p_context"> static long INIT nofill(void *buffer, unsigned long len)</span>
 }
 
 /* Included from initramfs et al code */
<span class="p_del">-STATIC int INIT gunzip(unsigned char *buf, long len,</span>
<span class="p_add">+STATIC int INIT __gunzip(unsigned char *buf, long len,</span>
 		       long (*fill)(void*, unsigned long),
 		       long (*flush)(void*, unsigned long),
<span class="p_del">-		       unsigned char *out_buf,</span>
<span class="p_add">+		       unsigned char *out_buf, long out_len,</span>
 		       long *pos,
 		       void(*error)(char *x)) {
 	u8 *zbuf;
 	struct z_stream_s *strm;
 	int rc;
<span class="p_del">-	size_t out_len;</span>
 
 	rc = -1;
 	if (flush) {
 		out_len = 0x8000; /* 32 K */
 		out_buf = malloc(out_len);
 	} else {
<span class="p_del">-		out_len = ((size_t)~0) - (size_t)out_buf; /* no limit */</span>
<span class="p_add">+		if (!out_len)</span>
<span class="p_add">+			out_len = ((size_t)~0) - (size_t)out_buf; /* no limit */</span>
 	}
 	if (!out_buf) {
 		error(&quot;Out of memory while allocating output buffer&quot;);
<span class="p_chunk">@@ -181,4 +182,24 @@</span> <span class="p_context"> gunzip_nomem1:</span>
 	return rc; /* returns Z_OK (0) if successful */
 }
 
<span class="p_del">-#define decompress gunzip</span>
<span class="p_add">+#ifndef PREBOOT</span>
<span class="p_add">+STATIC int INIT gunzip(unsigned char *buf, long len,</span>
<span class="p_add">+		       long (*fill)(void*, unsigned long),</span>
<span class="p_add">+		       long (*flush)(void*, unsigned long),</span>
<span class="p_add">+		       unsigned char *out_buf,</span>
<span class="p_add">+		       long *pos,</span>
<span class="p_add">+		       void (*error)(char *x))</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __gunzip(buf, len, fill, flush, out_buf, 0, pos, error);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long len,</span>
<span class="p_add">+			   long (*fill)(void*, unsigned long),</span>
<span class="p_add">+			   long (*flush)(void*, unsigned long),</span>
<span class="p_add">+			   unsigned char *out_buf, long out_len,</span>
<span class="p_add">+			   long *pos,</span>
<span class="p_add">+			   void (*error)(char *x))</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __gunzip(buf, len, fill, flush, out_buf, out_len, pos, error);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/lib/decompress_unlz4.c b/lib/decompress_unlz4.c</span>
<span class="p_header">index 40f66ebe57b7..036fc882cd72 100644</span>
<span class="p_header">--- a/lib/decompress_unlz4.c</span>
<span class="p_header">+++ b/lib/decompress_unlz4.c</span>
<span class="p_chunk">@@ -196,12 +196,12 @@</span> <span class="p_context"> exit_0:</span>
 }
 
 #ifdef PREBOOT
<span class="p_del">-STATIC int INIT decompress(unsigned char *buf, long in_len,</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long in_len,</span>
 			      long (*fill)(void*, unsigned long),
 			      long (*flush)(void*, unsigned long),
<span class="p_del">-			      unsigned char *output,</span>
<span class="p_add">+			      unsigned char *output, long out_len,</span>
 			      long *posp,
<span class="p_del">-			      void(*error)(char *x)</span>
<span class="p_add">+			      void (*error)(char *x)</span>
 	)
 {
 	return unlz4(buf, in_len - 4, fill, flush, output, posp, error);
<span class="p_header">diff --git a/lib/decompress_unlzma.c b/lib/decompress_unlzma.c</span>
<span class="p_header">index 0be83af62b88..decb64629c14 100644</span>
<span class="p_header">--- a/lib/decompress_unlzma.c</span>
<span class="p_header">+++ b/lib/decompress_unlzma.c</span>
<span class="p_chunk">@@ -667,13 +667,12 @@</span> <span class="p_context"> exit_0:</span>
 }
 
 #ifdef PREBOOT
<span class="p_del">-STATIC int INIT decompress(unsigned char *buf, long in_len,</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long in_len,</span>
 			      long (*fill)(void*, unsigned long),
 			      long (*flush)(void*, unsigned long),
<span class="p_del">-			      unsigned char *output,</span>
<span class="p_add">+			      unsigned char *output, long out_len,</span>
 			      long *posp,
<span class="p_del">-			      void(*error)(char *x)</span>
<span class="p_del">-	)</span>
<span class="p_add">+			      void (*error)(char *x))</span>
 {
 	return unlzma(buf, in_len - 4, fill, flush, output, posp, error);
 }
<span class="p_header">diff --git a/lib/decompress_unlzo.c b/lib/decompress_unlzo.c</span>
<span class="p_header">index b94a31bdd87d..f4c158e3a022 100644</span>
<span class="p_header">--- a/lib/decompress_unlzo.c</span>
<span class="p_header">+++ b/lib/decompress_unlzo.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
  */
 
 #ifdef STATIC
<span class="p_add">+#define PREBOOT</span>
 #include &quot;lzo/lzo1x_decompress_safe.c&quot;
 #else
 #include &lt;linux/decompress/unlzo.h&gt;
<span class="p_chunk">@@ -287,4 +288,14 @@</span> <span class="p_context"> exit:</span>
 	return ret;
 }
 
<span class="p_del">-#define decompress unlzo</span>
<span class="p_add">+#ifdef PREBOOT</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long len,</span>
<span class="p_add">+			   long (*fill)(void*, unsigned long),</span>
<span class="p_add">+			   long (*flush)(void*, unsigned long),</span>
<span class="p_add">+			   unsigned char *out_buf, long olen,</span>
<span class="p_add">+			   long *pos,</span>
<span class="p_add">+			   void (*error)(char *x))</span>
<span class="p_add">+{</span>
<span class="p_add">+	return unlzo(buf, len, fill, flush, out_buf, pos, error);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/lib/decompress_unxz.c b/lib/decompress_unxz.c</span>
<span class="p_header">index b07a78340e9d..25d59a95bd66 100644</span>
<span class="p_header">--- a/lib/decompress_unxz.c</span>
<span class="p_header">+++ b/lib/decompress_unxz.c</span>
<span class="p_chunk">@@ -394,4 +394,14 @@</span> <span class="p_context"> error_alloc_state:</span>
  * This macro is used by architecture-specific files to decompress
  * the kernel image.
  */
<span class="p_del">-#define decompress unxz</span>
<span class="p_add">+#ifdef XZ_PREBOOT</span>
<span class="p_add">+STATIC int INIT __decompress(unsigned char *buf, long len,</span>
<span class="p_add">+			   long (*fill)(void*, unsigned long),</span>
<span class="p_add">+			   long (*flush)(void*, unsigned long),</span>
<span class="p_add">+			   unsigned char *out_buf, long olen,</span>
<span class="p_add">+			   long *pos,</span>
<span class="p_add">+			   void (*error)(char *x))</span>
<span class="p_add">+{</span>
<span class="p_add">+	return unxz(buf, len, fill, flush, out_buf, pos, error);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/lib/rhashtable.c b/lib/rhashtable.c</span>
<span class="p_header">index 8609378e6505..cf910e48f8f2 100644</span>
<span class="p_header">--- a/lib/rhashtable.c</span>
<span class="p_header">+++ b/lib/rhashtable.c</span>
<span class="p_chunk">@@ -612,6 +612,8 @@</span> <span class="p_context"> next:</span>
 		iter-&gt;skip = 0;
 	}
 
<span class="p_add">+	iter-&gt;p = NULL;</span>
<span class="p_add">+</span>
 	/* Ensure we see any new tables. */
 	smp_rmb();
 
<span class="p_chunk">@@ -622,8 +624,6 @@</span> <span class="p_context"> next:</span>
 		return ERR_PTR(-EAGAIN);
 	}
 
<span class="p_del">-	iter-&gt;p = NULL;</span>
<span class="p_del">-</span>
 out:
 
 	return obj;
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index ebffa0e4a9c0..18490f3bd7f1 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -983,12 +983,15 @@</span> <span class="p_context"> static int prep_new_page(struct page *page, unsigned int order, gfp_t gfp_flags,</span>
 	set_page_owner(page, order, gfp_flags);
 
 	/*
<span class="p_del">-	 * page-&gt;pfmemalloc is set when ALLOC_NO_WATERMARKS was necessary to</span>
<span class="p_add">+	 * page is set pfmemalloc when ALLOC_NO_WATERMARKS was necessary to</span>
 	 * allocate the page. The expectation is that the caller is taking
 	 * steps that will free more memory. The caller should avoid the page
 	 * being used for !PFMEMALLOC purposes.
 	 */
<span class="p_del">-	page-&gt;pfmemalloc = !!(alloc_flags &amp; ALLOC_NO_WATERMARKS);</span>
<span class="p_add">+	if (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span>
<span class="p_add">+		set_page_pfmemalloc(page);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clear_page_pfmemalloc(page);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index 7eb38dd1cefa..3dd2d1ff9d5d 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -1602,7 +1602,7 @@</span> <span class="p_context"> static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,</span>
 	}
 
 	/* Record if ALLOC_NO_WATERMARKS was set when allocating the slab */
<span class="p_del">-	if (unlikely(page-&gt;pfmemalloc))</span>
<span class="p_add">+	if (page_is_pfmemalloc(page))</span>
 		pfmemalloc_active = true;
 
 	nr_pages = (1 &lt;&lt; cachep-&gt;gfporder);
<span class="p_chunk">@@ -1613,7 +1613,7 @@</span> <span class="p_context"> static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,</span>
 		add_zone_page_state(page_zone(page),
 			NR_SLAB_UNRECLAIMABLE, nr_pages);
 	__SetPageSlab(page);
<span class="p_del">-	if (page-&gt;pfmemalloc)</span>
<span class="p_add">+	if (page_is_pfmemalloc(page))</span>
 		SetPageSlabPfmemalloc(page);
 
 	if (kmemcheck_enabled &amp;&amp; !(cachep-&gt;flags &amp; SLAB_NOTRACK)) {
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 54c0876b43d5..08342c523a85 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -1427,7 +1427,7 @@</span> <span class="p_context"> static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)</span>
 	inc_slabs_node(s, page_to_nid(page), page-&gt;objects);
 	page-&gt;slab_cache = s;
 	__SetPageSlab(page);
<span class="p_del">-	if (page-&gt;pfmemalloc)</span>
<span class="p_add">+	if (page_is_pfmemalloc(page))</span>
 		SetPageSlabPfmemalloc(page);
 
 	start = page_address(page);
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 0d024fc8aa8e..1a17bd7c0ce5 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -1153,7 +1153,7 @@</span> <span class="p_context"> cull_mlocked:</span>
 		if (PageSwapCache(page))
 			try_to_free_swap(page);
 		unlock_page(page);
<span class="p_del">-		putback_lru_page(page);</span>
<span class="p_add">+		list_add(&amp;page-&gt;lru, &amp;ret_pages);</span>
 		continue;
 
 activate_locked:
<span class="p_header">diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c</span>
<span class="p_header">index e97572b5d2cc..0ff6e1bbca91 100644</span>
<span class="p_header">--- a/net/bridge/br_forward.c</span>
<span class="p_header">+++ b/net/bridge/br_forward.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb)</span>
 	} else {
 		skb_push(skb, ETH_HLEN);
 		br_drop_fake_rtable(skb);
<span class="p_add">+		skb_sender_cpu_clear(skb);</span>
 		dev_queue_xmit(skb);
 	}
 
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index e29ad70b3000..d1f910c0d586 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -348,7 +348,6 @@</span> <span class="p_context"> static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,</span>
 		return -ENOMEM;
 	rcu_assign_pointer(*pp, p);
 
<span class="p_del">-	br_mdb_notify(br-&gt;dev, port, group, RTM_NEWMDB);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -371,6 +370,7 @@</span> <span class="p_context"> static int __br_mdb_add(struct net *net, struct net_bridge *br,</span>
 	if (!p || p-&gt;br != br || p-&gt;state == BR_STATE_DISABLED)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;ip, 0, sizeof(ip));</span>
 	ip.proto = entry-&gt;addr.proto;
 	if (ip.proto == htons(ETH_P_IP))
 		ip.u.ip4 = entry-&gt;addr.u.ip4;
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)</span>
 	if (!netif_running(br-&gt;dev) || br-&gt;multicast_disabled)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;ip, 0, sizeof(ip));</span>
 	ip.proto = entry-&gt;addr.proto;
 	if (ip.proto == htons(ETH_P_IP)) {
 		if (timer_pending(&amp;br-&gt;ip4_other_query.timer))
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index 4b5c236998ff..a7559ef312bd 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -112,6 +112,8 @@</span> <span class="p_context"> static inline size_t br_port_info_size(void)</span>
 		+ nla_total_size(1)	/* IFLA_BRPORT_FAST_LEAVE */
 		+ nla_total_size(1)	/* IFLA_BRPORT_LEARNING */
 		+ nla_total_size(1)	/* IFLA_BRPORT_UNICAST_FLOOD */
<span class="p_add">+		+ nla_total_size(1)	/* IFLA_BRPORT_PROXYARP */</span>
<span class="p_add">+		+ nla_total_size(1)	/* IFLA_BRPORT_PROXYARP_WIFI */</span>
 		+ 0;
 }
 
<span class="p_chunk">@@ -504,6 +506,8 @@</span> <span class="p_context"> static const struct nla_policy br_port_policy[IFLA_BRPORT_MAX + 1] = {</span>
 	[IFLA_BRPORT_FAST_LEAVE]= { .type = NLA_U8 },
 	[IFLA_BRPORT_LEARNING]	= { .type = NLA_U8 },
 	[IFLA_BRPORT_UNICAST_FLOOD] = { .type = NLA_U8 },
<span class="p_add">+	[IFLA_BRPORT_PROXYARP]	= { .type = NLA_U8 },</span>
<span class="p_add">+	[IFLA_BRPORT_PROXYARP_WIFI] = { .type = NLA_U8 },</span>
 };
 
 /* Change the state of the port and notify spanning tree */
<span class="p_chunk">@@ -711,9 +715,17 @@</span> <span class="p_context"> static int br_port_slave_changelink(struct net_device *brdev,</span>
 				    struct nlattr *tb[],
 				    struct nlattr *data[])
 {
<span class="p_add">+	struct net_bridge *br = netdev_priv(brdev);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (!data)
 		return 0;
<span class="p_del">-	return br_setport(br_port_get_rtnl(dev), data);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
<span class="p_add">+	ret = br_setport(br_port_get_rtnl(dev), data);</span>
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int br_port_fill_slave_info(struct sk_buff *skb,
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index b80fb91bb3f7..617088aee21d 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -131,6 +131,35 @@</span> <span class="p_context"> out_noerr:</span>
 	goto out;
 }
 
<span class="p_add">+static struct sk_buff *skb_set_peeked(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb-&gt;peeked)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have to unshare an skb before modifying it. */</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	nskb = skb_clone(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!nskb)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skb-&gt;prev-&gt;next = nskb;</span>
<span class="p_add">+	skb-&gt;next-&gt;prev = nskb;</span>
<span class="p_add">+	nskb-&gt;prev = skb-&gt;prev;</span>
<span class="p_add">+	nskb-&gt;next = skb-&gt;next;</span>
<span class="p_add">+</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	skb = nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+done:</span>
<span class="p_add">+	skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	__skb_recv_datagram - Receive a datagram skbuff
  *	@sk: socket
<span class="p_chunk">@@ -165,7 +194,9 @@</span> <span class="p_context"> out_noerr:</span>
 struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
 				    int *peeked, int *off, int *err)
 {
<span class="p_add">+	struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 	struct sk_buff *skb, *last;
<span class="p_add">+	unsigned long cpu_flags;</span>
 	long timeo;
 	/*
 	 * Caller is allowed not to check sk-&gt;sk_err before skb_recv_datagram()
<span class="p_chunk">@@ -184,8 +215,6 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 		 * Look at current nfs client by the way...
 		 * However, this function was correct in any case. 8)
 		 */
<span class="p_del">-		unsigned long cpu_flags;</span>
<span class="p_del">-		struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 		int _off = *off;
 
 		last = (struct sk_buff *)queue;
<span class="p_chunk">@@ -199,7 +228,12 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 					_off -= skb-&gt;len;
 					continue;
 				}
<span class="p_del">-				skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+				skb = skb_set_peeked(skb);</span>
<span class="p_add">+				error = PTR_ERR(skb);</span>
<span class="p_add">+				if (IS_ERR(skb))</span>
<span class="p_add">+					goto unlock_err;</span>
<span class="p_add">+</span>
 				atomic_inc(&amp;skb-&gt;users);
 			} else
 				__skb_unlink(skb, queue);
<span class="p_chunk">@@ -223,6 +257,8 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,</span>
 
 	return NULL;
 
<span class="p_add">+unlock_err:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;queue-&gt;lock, cpu_flags);</span>
 no_packet:
 	*err = error;
 	return NULL;
<span class="p_chunk">@@ -622,7 +658,8 @@</span> <span class="p_context"> __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)</span>
 		    !skb-&gt;csum_complete_sw)
 			netdev_rx_csum_fault(skb-&gt;dev);
 	}
<span class="p_del">-	skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		skb-&gt;csum_valid = !sum;</span>
 	return sum;
 }
 EXPORT_SYMBOL(__skb_checksum_complete_head);
<span class="p_chunk">@@ -642,11 +679,13 @@</span> <span class="p_context"> __sum16 __skb_checksum_complete(struct sk_buff *skb)</span>
 			netdev_rx_csum_fault(skb-&gt;dev);
 	}
 
<span class="p_del">-	/* Save full packet checksum */</span>
<span class="p_del">-	skb-&gt;csum = csum;</span>
<span class="p_del">-	skb-&gt;ip_summed = CHECKSUM_COMPLETE;</span>
<span class="p_del">-	skb-&gt;csum_complete_sw = 1;</span>
<span class="p_del">-	skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	if (!skb_shared(skb)) {</span>
<span class="p_add">+		/* Save full packet checksum */</span>
<span class="p_add">+		skb-&gt;csum = csum;</span>
<span class="p_add">+		skb-&gt;ip_summed = CHECKSUM_COMPLETE;</span>
<span class="p_add">+		skb-&gt;csum_complete_sw = 1;</span>
<span class="p_add">+		skb-&gt;csum_valid = !sum;</span>
<span class="p_add">+	}</span>
 
 	return sum;
 }
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index aa82f9ab6a36..a42b232805a5 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -672,10 +672,6 @@</span> <span class="p_context"> int dev_get_iflink(const struct net_device *dev)</span>
 	if (dev-&gt;netdev_ops &amp;&amp; dev-&gt;netdev_ops-&gt;ndo_get_iflink)
 		return dev-&gt;netdev_ops-&gt;ndo_get_iflink(dev);
 
<span class="p_del">-	/* If dev-&gt;rtnl_link_ops is set, it&#39;s a virtual interface. */</span>
<span class="p_del">-	if (dev-&gt;rtnl_link_ops)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	return dev-&gt;ifindex;
 }
 EXPORT_SYMBOL(dev_get_iflink);
<span class="p_chunk">@@ -3341,6 +3337,8 @@</span> <span class="p_context"> static int enqueue_to_backlog(struct sk_buff *skb, int cpu,</span>
 	local_irq_save(flags);
 
 	rps_lock(sd);
<span class="p_add">+	if (!netif_running(skb-&gt;dev))</span>
<span class="p_add">+		goto drop;</span>
 	qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue);
 	if (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) {
 		if (qlen) {
<span class="p_chunk">@@ -3362,6 +3360,7 @@</span> <span class="p_context"> enqueue:</span>
 		goto enqueue;
 	}
 
<span class="p_add">+drop:</span>
 	sd-&gt;dropped++;
 	rps_unlock(sd);
 
<span class="p_chunk">@@ -3667,8 +3666,6 @@</span> <span class="p_context"> static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)</span>
 
 	pt_prev = NULL;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-</span>
 another_round:
 	skb-&gt;skb_iif = skb-&gt;dev-&gt;ifindex;
 
<span class="p_chunk">@@ -3678,7 +3675,7 @@</span> <span class="p_context"> another_round:</span>
 	    skb-&gt;protocol == cpu_to_be16(ETH_P_8021AD)) {
 		skb = skb_vlan_untag(skb);
 		if (unlikely(!skb))
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 	}
 
 #ifdef CONFIG_NET_CLS_ACT
<span class="p_chunk">@@ -3708,7 +3705,7 @@</span> <span class="p_context"> skip_taps:</span>
 	if (static_key_false(&amp;ingress_needed)) {
 		skb = handle_ing(skb, &amp;pt_prev, &amp;ret, orig_dev);
 		if (!skb)
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	skb-&gt;tc_verd = 0;
<span class="p_chunk">@@ -3725,7 +3722,7 @@</span> <span class="p_context"> ncls:</span>
 		if (vlan_do_receive(&amp;skb))
 			goto another_round;
 		else if (unlikely(!skb))
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	rx_handler = rcu_dereference(skb-&gt;dev-&gt;rx_handler);
<span class="p_chunk">@@ -3737,7 +3734,7 @@</span> <span class="p_context"> ncls:</span>
 		switch (rx_handler(&amp;skb)) {
 		case RX_HANDLER_CONSUMED:
 			ret = NET_RX_SUCCESS;
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			goto out;</span>
 		case RX_HANDLER_ANOTHER:
 			goto another_round;
 		case RX_HANDLER_EXACT:
<span class="p_chunk">@@ -3791,8 +3788,7 @@</span> <span class="p_context"> drop:</span>
 		ret = NET_RX_DROP;
 	}
 
<span class="p_del">-unlock:</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+out:</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3823,29 +3819,30 @@</span> <span class="p_context"> static int __netif_receive_skb(struct sk_buff *skb)</span>
 
 static int netif_receive_skb_internal(struct sk_buff *skb)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	net_timestamp_check(netdev_tstamp_prequeue, skb);
 
 	if (skb_defer_rx_timestamp(skb))
 		return NET_RX_SUCCESS;
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+</span>
 #ifdef CONFIG_RPS
 	if (static_key_false(&amp;rps_needed)) {
 		struct rps_dev_flow voidflow, *rflow = &amp;voidflow;
<span class="p_del">-		int cpu, ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		rcu_read_lock();</span>
<span class="p_del">-</span>
<span class="p_del">-		cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
<span class="p_add">+		int cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow);</span>
 
 		if (cpu &gt;= 0) {
 			ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail);
 			rcu_read_unlock();
 			return ret;
 		}
<span class="p_del">-		rcu_read_unlock();</span>
 	}
 #endif
<span class="p_del">-	return __netif_receive_skb(skb);</span>
<span class="p_add">+	ret = __netif_receive_skb(skb);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -4390,8 +4387,10 @@</span> <span class="p_context"> static int process_backlog(struct napi_struct *napi, int quota)</span>
 		struct sk_buff *skb;
 
 		while ((skb = __skb_dequeue(&amp;sd-&gt;process_queue))) {
<span class="p_add">+			rcu_read_lock();</span>
 			local_irq_enable();
 			__netif_receive_skb(skb);
<span class="p_add">+			rcu_read_unlock();</span>
 			local_irq_disable();
 			input_queue_head_incr(sd);
 			if (++work &gt;= quota) {
<span class="p_chunk">@@ -6027,6 +6026,7 @@</span> <span class="p_context"> static void rollback_registered_many(struct list_head *head)</span>
 		unlist_netdevice(dev);
 
 		dev-&gt;reg_state = NETREG_UNREGISTERING;
<span class="p_add">+		on_each_cpu(flush_backlog, dev, 1);</span>
 	}
 
 	synchronize_net();
<span class="p_chunk">@@ -6297,7 +6297,8 @@</span> <span class="p_context"> static int netif_alloc_netdev_queues(struct net_device *dev)</span>
 	struct netdev_queue *tx;
 	size_t sz = count * sizeof(*tx);
 
<span class="p_del">-	BUG_ON(count &lt; 1 || count &gt; 0xffff);</span>
<span class="p_add">+	if (count &lt; 1 || count &gt; 0xffff)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	tx = kzalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
 	if (!tx) {
<span class="p_chunk">@@ -6650,8 +6651,6 @@</span> <span class="p_context"> void netdev_run_todo(void)</span>
 
 		dev-&gt;reg_state = NETREG_UNREGISTERED;
 
<span class="p_del">-		on_each_cpu(flush_backlog, dev, 1);</span>
<span class="p_del">-</span>
 		netdev_wait_allrefs(dev);
 
 		/* paranoia */
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 508155b283dd..043ea1867d0f 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -3490,8 +3490,10 @@</span> <span class="p_context"> static int pktgen_thread_worker(void *arg)</span>
 	pktgen_rem_thread(t);
 
 	/* Wait for kthread_stop */
<span class="p_del">-	while (!kthread_should_stop()) {</span>
<span class="p_add">+	for (;;) {</span>
 		set_current_state(TASK_INTERRUPTIBLE);
<span class="p_add">+		if (kthread_should_stop())</span>
<span class="p_add">+			break;</span>
 		schedule();
 	}
 	__set_current_state(TASK_RUNNING);
<span class="p_header">diff --git a/net/core/request_sock.c b/net/core/request_sock.c</span>
<span class="p_header">index 87b22c0bc08c..b42f0e26f89e 100644</span>
<span class="p_header">--- a/net/core/request_sock.c</span>
<span class="p_header">+++ b/net/core/request_sock.c</span>
<span class="p_chunk">@@ -103,10 +103,16 @@</span> <span class="p_context"> void reqsk_queue_destroy(struct request_sock_queue *queue)</span>
 			spin_lock_bh(&amp;queue-&gt;syn_wait_lock);
 			while ((req = lopt-&gt;syn_table[i]) != NULL) {
 				lopt-&gt;syn_table[i] = req-&gt;dl_next;
<span class="p_add">+				/* Because of following del_timer_sync(),</span>
<span class="p_add">+				 * we must release the spinlock here</span>
<span class="p_add">+				 * or risk a dead lock.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				spin_unlock_bh(&amp;queue-&gt;syn_wait_lock);</span>
 				atomic_inc(&amp;lopt-&gt;qlen_dec);
<span class="p_del">-				if (del_timer(&amp;req-&gt;rsk_timer))</span>
<span class="p_add">+				if (del_timer_sync(&amp;req-&gt;rsk_timer))</span>
 					reqsk_put(req);
 				reqsk_put(req);
<span class="p_add">+				spin_lock_bh(&amp;queue-&gt;syn_wait_lock);</span>
 			}
 			spin_unlock_bh(&amp;queue-&gt;syn_wait_lock);
 		}
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 8de36824018d..fe95cb704aaa 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1287,10 +1287,6 @@</span> <span class="p_context"> static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {</span>
 	[IFLA_INFO_SLAVE_DATA]	= { .type = NLA_NESTED },
 };
 
<span class="p_del">-static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {</span>
<span class="p_del">-	[IFLA_VF_INFO]		= { .type = NLA_NESTED },</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
 	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
 	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
<span class="p_chunk">@@ -1437,96 +1433,98 @@</span> <span class="p_context"> static int validate_linkmsg(struct net_device *dev, struct nlattr *tb[])</span>
 	return 0;
 }
 
<span class="p_del">-static int do_setvfinfo(struct net_device *dev, struct nlattr *attr)</span>
<span class="p_add">+static int do_setvfinfo(struct net_device *dev, struct nlattr **tb)</span>
 {
<span class="p_del">-	int rem, err = -EINVAL;</span>
<span class="p_del">-	struct nlattr *vf;</span>
 	const struct net_device_ops *ops = dev-&gt;netdev_ops;
<span class="p_add">+	int err = -EINVAL;</span>
 
<span class="p_del">-	nla_for_each_nested(vf, attr, rem) {</span>
<span class="p_del">-		switch (nla_type(vf)) {</span>
<span class="p_del">-		case IFLA_VF_MAC: {</span>
<span class="p_del">-			struct ifla_vf_mac *ivm;</span>
<span class="p_del">-			ivm = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_del">-							  ivm-&gt;mac);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_VLAN: {</span>
<span class="p_del">-			struct ifla_vf_vlan *ivv;</span>
<span class="p_del">-			ivv = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf,</span>
<span class="p_del">-							   ivv-&gt;vlan,</span>
<span class="p_del">-							   ivv-&gt;qos);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_TX_RATE: {</span>
<span class="p_del">-			struct ifla_vf_tx_rate *ivt;</span>
<span class="p_del">-			struct ifla_vf_info ivf;</span>
<span class="p_del">-			ivt = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_get_vf_config)</span>
<span class="p_del">-				err = ops-&gt;ndo_get_vf_config(dev, ivt-&gt;vf,</span>
<span class="p_del">-							     &amp;ivf);</span>
<span class="p_del">-			if (err)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_del">-							   ivf.min_tx_rate,</span>
<span class="p_del">-							   ivt-&gt;rate);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_RATE: {</span>
<span class="p_del">-			struct ifla_vf_rate *ivt;</span>
<span class="p_del">-			ivt = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_del">-							   ivt-&gt;min_tx_rate,</span>
<span class="p_del">-							   ivt-&gt;max_tx_rate);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_SPOOFCHK: {</span>
<span class="p_del">-			struct ifla_vf_spoofchk *ivs;</span>
<span class="p_del">-			ivs = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_del">-							       ivs-&gt;setting);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_LINK_STATE: {</span>
<span class="p_del">-			struct ifla_vf_link_state *ivl;</span>
<span class="p_del">-			ivl = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_link_state)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_link_state(dev, ivl-&gt;vf,</span>
<span class="p_del">-								 ivl-&gt;link_state);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		case IFLA_VF_RSS_QUERY_EN: {</span>
<span class="p_del">-			struct ifla_vf_rss_query_en *ivrssq_en;</span>
<span class="p_add">+	if (tb[IFLA_VF_MAC]) {</span>
<span class="p_add">+		struct ifla_vf_mac *ivm = nla_data(tb[IFLA_VF_MAC]);</span>
 
<span class="p_del">-			ivrssq_en = nla_data(vf);</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			if (ops-&gt;ndo_set_vf_rss_query_en)</span>
<span class="p_del">-				err = ops-&gt;ndo_set_vf_rss_query_en(dev,</span>
<span class="p_del">-							    ivrssq_en-&gt;vf,</span>
<span class="p_del">-							    ivrssq_en-&gt;setting);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			err = -EINVAL;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_mac)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_mac(dev, ivm-&gt;vf,</span>
<span class="p_add">+						  ivm-&gt;mac);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_VLAN]) {</span>
<span class="p_add">+		struct ifla_vf_vlan *ivv = nla_data(tb[IFLA_VF_VLAN]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_vlan)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_vlan(dev, ivv-&gt;vf, ivv-&gt;vlan,</span>
<span class="p_add">+						   ivv-&gt;qos);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_TX_RATE]) {</span>
<span class="p_add">+		struct ifla_vf_tx_rate *ivt = nla_data(tb[IFLA_VF_TX_RATE]);</span>
<span class="p_add">+		struct ifla_vf_info ivf;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_get_vf_config)</span>
<span class="p_add">+			err = ops-&gt;ndo_get_vf_config(dev, ivt-&gt;vf, &amp;ivf);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_add">+						   ivf.min_tx_rate,</span>
<span class="p_add">+						   ivt-&gt;rate);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_RATE]) {</span>
<span class="p_add">+		struct ifla_vf_rate *ivt = nla_data(tb[IFLA_VF_RATE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_rate)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_rate(dev, ivt-&gt;vf,</span>
<span class="p_add">+						   ivt-&gt;min_tx_rate,</span>
<span class="p_add">+						   ivt-&gt;max_tx_rate);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_SPOOFCHK]) {</span>
<span class="p_add">+		struct ifla_vf_spoofchk *ivs = nla_data(tb[IFLA_VF_SPOOFCHK]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_spoofchk)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_spoofchk(dev, ivs-&gt;vf,</span>
<span class="p_add">+						       ivs-&gt;setting);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_LINK_STATE]) {</span>
<span class="p_add">+		struct ifla_vf_link_state *ivl = nla_data(tb[IFLA_VF_LINK_STATE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_link_state)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_link_state(dev, ivl-&gt;vf,</span>
<span class="p_add">+							 ivl-&gt;link_state);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb[IFLA_VF_RSS_QUERY_EN]) {</span>
<span class="p_add">+		struct ifla_vf_rss_query_en *ivrssq_en;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
<span class="p_add">+		ivrssq_en = nla_data(tb[IFLA_VF_RSS_QUERY_EN]);</span>
<span class="p_add">+		if (ops-&gt;ndo_set_vf_rss_query_en)</span>
<span class="p_add">+			err = ops-&gt;ndo_set_vf_rss_query_en(dev, ivrssq_en-&gt;vf,</span>
<span class="p_add">+							   ivrssq_en-&gt;setting);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1722,14 +1720,21 @@</span> <span class="p_context"> static int do_setlink(const struct sk_buff *skb,</span>
 	}
 
 	if (tb[IFLA_VFINFO_LIST]) {
<span class="p_add">+		struct nlattr *vfinfo[IFLA_VF_MAX + 1];</span>
 		struct nlattr *attr;
 		int rem;
<span class="p_add">+</span>
 		nla_for_each_nested(attr, tb[IFLA_VFINFO_LIST], rem) {
<span class="p_del">-			if (nla_type(attr) != IFLA_VF_INFO) {</span>
<span class="p_add">+			if (nla_type(attr) != IFLA_VF_INFO ||</span>
<span class="p_add">+			    nla_len(attr) &lt; NLA_HDRLEN) {</span>
 				err = -EINVAL;
 				goto errout;
 			}
<span class="p_del">-			err = do_setvfinfo(dev, attr);</span>
<span class="p_add">+			err = nla_parse_nested(vfinfo, IFLA_VF_MAX, attr,</span>
<span class="p_add">+					       ifla_vf_policy);</span>
<span class="p_add">+			if (err &lt; 0)</span>
<span class="p_add">+				goto errout;</span>
<span class="p_add">+			err = do_setvfinfo(dev, vfinfo);</span>
 			if (err &lt; 0)
 				goto errout;
 			status |= DO_SETLINK_NOTIFY;
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 41ec02242ea7..a2e4e47b2839 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	if (skb &amp;&amp; frag_size) {
 		skb-&gt;head_frag = 1;
<span class="p_del">-		if (virt_to_head_page(data)-&gt;pfmemalloc)</span>
<span class="p_add">+		if (page_is_pfmemalloc(virt_to_head_page(data)))</span>
 			skb-&gt;pfmemalloc = 1;
 	}
 	return skb;
<span class="p_header">diff --git a/net/dsa/slave.c b/net/dsa/slave.c</span>
<span class="p_header">index 827cda560a55..57978c5b2c91 100644</span>
<span class="p_header">--- a/net/dsa/slave.c</span>
<span class="p_header">+++ b/net/dsa/slave.c</span>
<span class="p_chunk">@@ -732,7 +732,8 @@</span> <span class="p_context"> static int dsa_slave_phy_connect(struct dsa_slave_priv *p,</span>
 		return -ENODEV;
 
 	/* Use already configured phy mode */
<span class="p_del">-	p-&gt;phy_interface = p-&gt;phy-&gt;interface;</span>
<span class="p_add">+	if (p-&gt;phy_interface == PHY_INTERFACE_MODE_NA)</span>
<span class="p_add">+		p-&gt;phy_interface = p-&gt;phy-&gt;interface;</span>
 	phy_connect_direct(slave_dev, p-&gt;phy, dsa_slave_adjust_link,
 			   p-&gt;phy_interface);
 
<span class="p_header">diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c</span>
<span class="p_header">index 90c0e8386116..574fad9cca05 100644</span>
<span class="p_header">--- a/net/ipv4/datagram.c</span>
<span class="p_header">+++ b/net/ipv4/datagram.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;net/route.h&gt;
 #include &lt;net/tcp_states.h&gt;
 
<span class="p_del">-int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sockaddr_in *usin = (struct sockaddr_in *) uaddr;
<span class="p_chunk">@@ -39,8 +39,6 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 
 	sk_dst_reset(sk);
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-</span>
 	oif = sk-&gt;sk_bound_dev_if;
 	saddr = inet-&gt;inet_saddr;
 	if (ipv4_is_multicast(usin-&gt;sin_addr.s_addr)) {
<span class="p_chunk">@@ -82,9 +80,19 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	sk_dst_set(sk, &amp;rt-&gt;dst);
 	err = 0;
 out:
<span class="p_del">-	release_sock(sk);</span>
 	return err;
 }
<span class="p_add">+EXPORT_SYMBOL(__ip4_datagram_connect);</span>
<span class="p_add">+</span>
<span class="p_add">+int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(ip4_datagram_connect);
 
 /* Because UDP xmit path can manipulate sk_dst_cache without holding
<span class="p_header">diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c</span>
<span class="p_header">index 09b62e17dd8c..0ca933db1b41 100644</span>
<span class="p_header">--- a/net/ipv4/fib_trie.c</span>
<span class="p_header">+++ b/net/ipv4/fib_trie.c</span>
<span class="p_chunk">@@ -1780,8 +1780,6 @@</span> <span class="p_context"> void fib_table_flush_external(struct fib_table *tb)</span>
 		if (hlist_empty(&amp;n-&gt;leaf)) {
 			put_child_root(pn, n-&gt;key, NULL);
 			node_free(n);
<span class="p_del">-		} else {</span>
<span class="p_del">-			leaf_pull_suffix(pn, n);</span>
 		}
 	}
 }
<span class="p_chunk">@@ -1852,8 +1850,6 @@</span> <span class="p_context"> int fib_table_flush(struct fib_table *tb)</span>
 		if (hlist_empty(&amp;n-&gt;leaf)) {
 			put_child_root(pn, n-&gt;key, NULL);
 			node_free(n);
<span class="p_del">-		} else {</span>
<span class="p_del">-			leaf_pull_suffix(pn, n);</span>
 		}
 	}
 
<span class="p_chunk">@@ -2457,7 +2453,7 @@</span> <span class="p_context"> static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,</span>
 		key = l-&gt;key + 1;
 		iter-&gt;pos++;
 
<span class="p_del">-		if (pos-- &lt;= 0)</span>
<span class="p_add">+		if (--pos &lt;= 0)</span>
 			break;
 
 		l = NULL;
<span class="p_header">diff --git a/net/ipv4/inet_connection_sock.c b/net/ipv4/inet_connection_sock.c</span>
<span class="p_header">index 8976ca423a07..b27fc401c6a9 100644</span>
<span class="p_header">--- a/net/ipv4/inet_connection_sock.c</span>
<span class="p_header">+++ b/net/ipv4/inet_connection_sock.c</span>
<span class="p_chunk">@@ -584,7 +584,7 @@</span> <span class="p_context"> static bool reqsk_queue_unlink(struct request_sock_queue *queue,</span>
 	}
 
 	spin_unlock(&amp;queue-&gt;syn_wait_lock);
<span class="p_del">-	if (del_timer(&amp;req-&gt;rsk_timer))</span>
<span class="p_add">+	if (del_timer_sync(&amp;req-&gt;rsk_timer))</span>
 		reqsk_put(req);
 	return found;
 }
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index cc1da6d9cb35..cae22a1a8777 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -342,7 +342,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 	ihl = ip_hdrlen(skb);
 
 	/* Determine the position of this fragment. */
<span class="p_del">-	end = offset + skb-&gt;len - ihl;</span>
<span class="p_add">+	end = offset + skb-&gt;len - skb_network_offset(skb) - ihl;</span>
 	err = -EINVAL;
 
 	/* Is this the final fragment? */
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> static int ip_frag_queue(struct ipq *qp, struct sk_buff *skb)</span>
 		goto err;
 
 	err = -ENOMEM;
<span class="p_del">-	if (!pskb_pull(skb, ihl))</span>
<span class="p_add">+	if (!pskb_pull(skb, skb_network_offset(skb) + ihl))</span>
 		goto err;
 
 	err = pskb_trim_rcsum(skb, end - offset);
<span class="p_chunk">@@ -613,6 +613,9 @@</span> <span class="p_context"> static int ip_frag_reasm(struct ipq *qp, struct sk_buff *prev,</span>
 	iph-&gt;frag_off = qp-&gt;q.max_size ? htons(IP_DF) : 0;
 	iph-&gt;tot_len = htons(len);
 	iph-&gt;tos |= ecn;
<span class="p_add">+</span>
<span class="p_add">+	ip_send_check(iph);</span>
<span class="p_add">+</span>
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMOKS);
 	qp-&gt;q.fragments = NULL;
 	qp-&gt;q.fragments_tail = NULL;
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index 4c2c3ba4ba65..626d9e56a6bd 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -586,7 +586,8 @@</span> <span class="p_context"> int ip_tunnel_encap(struct sk_buff *skb, struct ip_tunnel *t,</span>
 EXPORT_SYMBOL(ip_tunnel_encap);
 
 static int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,
<span class="p_del">-			    struct rtable *rt, __be16 df)</span>
<span class="p_add">+			    struct rtable *rt, __be16 df,</span>
<span class="p_add">+			    const struct iphdr *inner_iph)</span>
 {
 	struct ip_tunnel *tunnel = netdev_priv(dev);
 	int pkt_size = skb-&gt;len - tunnel-&gt;hlen - dev-&gt;hard_header_len;
<span class="p_chunk">@@ -603,7 +604,8 @@</span> <span class="p_context"> static int tnl_update_pmtu(struct net_device *dev, struct sk_buff *skb,</span>
 
 	if (skb-&gt;protocol == htons(ETH_P_IP)) {
 		if (!skb_is_gso(skb) &amp;&amp;
<span class="p_del">-		    (df &amp; htons(IP_DF)) &amp;&amp; mtu &lt; pkt_size) {</span>
<span class="p_add">+		    (inner_iph-&gt;frag_off &amp; htons(IP_DF)) &amp;&amp;</span>
<span class="p_add">+		    mtu &lt; pkt_size) {</span>
 			memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, htonl(mtu));
 			return -E2BIG;
<span class="p_chunk">@@ -737,7 +739,7 @@</span> <span class="p_context"> void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 		goto tx_error;
 	}
 
<span class="p_del">-	if (tnl_update_pmtu(dev, skb, rt, tnl_params-&gt;frag_off)) {</span>
<span class="p_add">+	if (tnl_update_pmtu(dev, skb, rt, tnl_params-&gt;frag_off, inner_iph)) {</span>
 		ip_rt_put(rt);
 		goto tx_error;
 	}
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index fc1c658ec6c1..441ca6f38981 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -1348,7 +1348,7 @@</span> <span class="p_context"> static struct sock *tcp_v4_hnd_req(struct sock *sk, struct sk_buff *skb)</span>
 	req = inet_csk_search_req(sk, th-&gt;source, iph-&gt;saddr, iph-&gt;daddr);
 	if (req) {
 		nsk = tcp_check_req(sk, skb, req, false);
<span class="p_del">-		if (!nsk)</span>
<span class="p_add">+		if (!nsk || nsk == sk)</span>
 			reqsk_put(req);
 		return nsk;
 	}
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 83aa604f9273..1b8c5ba7d5f7 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1995,12 +1995,19 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 
 	skb-&gt;sk = sk;
 	skb-&gt;destructor = sock_efree;
<span class="p_del">-	dst = sk-&gt;sk_rx_dst;</span>
<span class="p_add">+	dst = READ_ONCE(sk-&gt;sk_rx_dst);</span>
 
 	if (dst)
 		dst = dst_check(dst, 0);
<span class="p_del">-	if (dst)</span>
<span class="p_del">-		skb_dst_set_noref(skb, dst);</span>
<span class="p_add">+	if (dst) {</span>
<span class="p_add">+		/* DST_NOCACHE can not be used without taking a reference */</span>
<span class="p_add">+		if (dst-&gt;flags &amp; DST_NOCACHE) {</span>
<span class="p_add">+			if (likely(atomic_inc_not_zero(&amp;dst-&gt;__refcnt)))</span>
<span class="p_add">+				skb_dst_set(skb, dst);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			skb_dst_set_noref(skb, dst);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 }
 
 int udp_rcv(struct sk_buff *skb)
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 62d908e64eeb..b10a88986a98 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> static bool ipv6_mapped_addr_any(const struct in6_addr *a)</span>
 	return ipv6_addr_v4mapped(a) &amp;&amp; (a-&gt;s6_addr32[3] == 0);
 }
 
<span class="p_del">-int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 	struct inet_sock	*inet = inet_sk(sk);
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	if (usin-&gt;sin6_family == AF_INET) {
 		if (__ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
<span class="p_del">-		err = ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
 		goto ipv4_connected;
 	}
 
<span class="p_chunk">@@ -98,9 +98,9 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 		sin.sin_addr.s_addr = daddr-&gt;s6_addr32[3];
 		sin.sin_port = usin-&gt;sin6_port;
 
<span class="p_del">-		err = ip4_datagram_connect(sk,</span>
<span class="p_del">-					   (struct sockaddr *) &amp;sin,</span>
<span class="p_del">-					   sizeof(sin));</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk,</span>
<span class="p_add">+					     (struct sockaddr *) &amp;sin,</span>
<span class="p_add">+					     sizeof(sin));</span>
 
 ipv4_connected:
 		if (err)
<span class="p_chunk">@@ -204,6 +204,16 @@</span> <span class="p_context"> out:</span>
 	fl6_sock_release(flowlabel);
 	return err;
 }
<span class="p_add">+</span>
<span class="p_add">+int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip6_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(ip6_datagram_connect);
 
 int ip6_datagram_connect_v6_only(struct sock *sk, struct sockaddr *uaddr,
<span class="p_header">diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c</span>
<span class="p_header">index f2e464eba5ef..57990c929cd8 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_input.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_input.c</span>
<span class="p_chunk">@@ -331,10 +331,10 @@</span> <span class="p_context"> int ip6_mc_input(struct sk_buff *skb)</span>
 				if (offset &lt; 0)
 					goto out;
 
<span class="p_del">-				if (!ipv6_is_mld(skb, nexthdr, offset))</span>
<span class="p_del">-					goto out;</span>
<span class="p_add">+				if (ipv6_is_mld(skb, nexthdr, offset))</span>
<span class="p_add">+					deliver = true;</span>
 
<span class="p_del">-				deliver = true;</span>
<span class="p_add">+				goto out;</span>
 			}
 			/* unknown RA - process it normally */
 		}
<span class="p_header">diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c</span>
<span class="p_header">index e893cd18612f..08b62047c67f 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_offload.c</span>
<span class="p_chunk">@@ -292,8 +292,6 @@</span> <span class="p_context"> static struct packet_offload ipv6_packet_offload __read_mostly = {</span>
 static const struct net_offload sit_offload = {
 	.callbacks = {
 		.gso_segment	= ipv6_gso_segment,
<span class="p_del">-		.gro_receive	= ipv6_gro_receive,</span>
<span class="p_del">-		.gro_complete	= ipv6_gro_complete,</span>
 	},
 };
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 3adffb300238..e541d68dba8b 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -946,7 +946,7 @@</span> <span class="p_context"> static struct sock *tcp_v6_hnd_req(struct sock *sk, struct sk_buff *skb)</span>
 				   &amp;ipv6_hdr(skb)-&gt;daddr, tcp_v6_iif(skb));
 	if (req) {
 		nsk = tcp_check_req(sk, skb, req, false);
<span class="p_del">-		if (!nsk)</span>
<span class="p_add">+		if (!nsk || nsk == sk)</span>
 			reqsk_put(req);
 		return nsk;
 	}
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 667111ee6a20..5787f15a3a12 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -301,9 +301,6 @@</span> <span class="p_context"> ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)</span>
 	if (tx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_WDS)
 		return TX_CONTINUE;
 
<span class="p_del">-	if (tx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_MESH_POINT)</span>
<span class="p_del">-		return TX_CONTINUE;</span>
<span class="p_del">-</span>
 	if (tx-&gt;flags &amp; IEEE80211_TX_PS_BUFFERED)
 		return TX_CONTINUE;
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index bf6e76643f78..4856d975492d 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -355,25 +355,52 @@</span> <span class="p_context"> err1:</span>
 	return NULL;
 }
 
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+__netlink_set_ring(struct sock *sk, struct nl_mmap_req *req, bool tx_ring, void **pg_vec,</span>
<span class="p_add">+		   unsigned int order)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct netlink_sock *nlk = nlk_sk(sk);</span>
<span class="p_add">+	struct sk_buff_head *queue;</span>
<span class="p_add">+	struct netlink_ring *ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span>
<span class="p_add">+	ring  = tx_ring ? &amp;nlk-&gt;tx_ring : &amp;nlk-&gt;rx_ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;queue-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	ring-&gt;frame_max		= req-&gt;nm_frame_nr - 1;</span>
<span class="p_add">+	ring-&gt;head		= 0;</span>
<span class="p_add">+	ring-&gt;frame_size	= req-&gt;nm_frame_size;</span>
<span class="p_add">+	ring-&gt;pg_vec_pages	= req-&gt;nm_block_size / PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	swap(ring-&gt;pg_vec_len, req-&gt;nm_block_nr);</span>
<span class="p_add">+	swap(ring-&gt;pg_vec_order, order);</span>
<span class="p_add">+	swap(ring-&gt;pg_vec, pg_vec);</span>
<span class="p_add">+</span>
<span class="p_add">+	__skb_queue_purge(queue);</span>
<span class="p_add">+	spin_unlock_bh(&amp;queue-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(atomic_read(&amp;nlk-&gt;mapped));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pg_vec)</span>
<span class="p_add">+		free_pg_vec(pg_vec, order, req-&gt;nm_block_nr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,
<span class="p_del">-			    bool closing, bool tx_ring)</span>
<span class="p_add">+			    bool tx_ring)</span>
 {
 	struct netlink_sock *nlk = nlk_sk(sk);
 	struct netlink_ring *ring;
<span class="p_del">-	struct sk_buff_head *queue;</span>
 	void **pg_vec = NULL;
 	unsigned int order = 0;
<span class="p_del">-	int err;</span>
 
 	ring  = tx_ring ? &amp;nlk-&gt;tx_ring : &amp;nlk-&gt;rx_ring;
<span class="p_del">-	queue = tx_ring ? &amp;sk-&gt;sk_write_queue : &amp;sk-&gt;sk_receive_queue;</span>
 
<span class="p_del">-	if (!closing) {</span>
<span class="p_del">-		if (atomic_read(&amp;nlk-&gt;mapped))</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-		if (atomic_read(&amp;ring-&gt;pending))</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (atomic_read(&amp;nlk-&gt;mapped))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	if (atomic_read(&amp;ring-&gt;pending))</span>
<span class="p_add">+		return -EBUSY;</span>
 
 	if (req-&gt;nm_block_nr) {
 		if (ring-&gt;pg_vec != NULL)
<span class="p_chunk">@@ -405,31 +432,19 @@</span> <span class="p_context"> static int netlink_set_ring(struct sock *sk, struct nl_mmap_req *req,</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	err = -EBUSY;</span>
 	mutex_lock(&amp;nlk-&gt;pg_vec_lock);
<span class="p_del">-	if (closing || atomic_read(&amp;nlk-&gt;mapped) == 0) {</span>
<span class="p_del">-		err = 0;</span>
<span class="p_del">-		spin_lock_bh(&amp;queue-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		ring-&gt;frame_max		= req-&gt;nm_frame_nr - 1;</span>
<span class="p_del">-		ring-&gt;head		= 0;</span>
<span class="p_del">-		ring-&gt;frame_size	= req-&gt;nm_frame_size;</span>
<span class="p_del">-		ring-&gt;pg_vec_pages	= req-&gt;nm_block_size / PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-		swap(ring-&gt;pg_vec_len, req-&gt;nm_block_nr);</span>
<span class="p_del">-		swap(ring-&gt;pg_vec_order, order);</span>
<span class="p_del">-		swap(ring-&gt;pg_vec, pg_vec);</span>
<span class="p_del">-</span>
<span class="p_del">-		__skb_queue_purge(queue);</span>
<span class="p_del">-		spin_unlock_bh(&amp;queue-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		WARN_ON(atomic_read(&amp;nlk-&gt;mapped));</span>
<span class="p_add">+	if (atomic_read(&amp;nlk-&gt;mapped) == 0) {</span>
<span class="p_add">+		__netlink_set_ring(sk, req, tx_ring, pg_vec, order);</span>
<span class="p_add">+		mutex_unlock(&amp;nlk-&gt;pg_vec_lock);</span>
<span class="p_add">+		return 0;</span>
 	}
<span class="p_add">+</span>
 	mutex_unlock(&amp;nlk-&gt;pg_vec_lock);
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req-&gt;nm_block_nr);
<span class="p_del">-	return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EBUSY;</span>
 }
 
 static void netlink_mm_open(struct vm_area_struct *vma)
<span class="p_chunk">@@ -898,10 +913,10 @@</span> <span class="p_context"> static void netlink_sock_destruct(struct sock *sk)</span>
 
 		memset(&amp;req, 0, sizeof(req));
 		if (nlk-&gt;rx_ring.pg_vec)
<span class="p_del">-			netlink_set_ring(sk, &amp;req, true, false);</span>
<span class="p_add">+			__netlink_set_ring(sk, &amp;req, false, NULL, 0);</span>
 		memset(&amp;req, 0, sizeof(req));
 		if (nlk-&gt;tx_ring.pg_vec)
<span class="p_del">-			netlink_set_ring(sk, &amp;req, true, true);</span>
<span class="p_add">+			__netlink_set_ring(sk, &amp;req, true, NULL, 0);</span>
 	}
 #endif /* CONFIG_NETLINK_MMAP */
 
<span class="p_chunk">@@ -1079,6 +1094,11 @@</span> <span class="p_context"> static int netlink_insert(struct sock *sk, u32 portid)</span>
 
 	err = __netlink_insert(table, sk);
 	if (err) {
<span class="p_add">+		/* In case the hashtable backend returns with -EBUSY</span>
<span class="p_add">+		 * from here, it must not escape to the caller.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (unlikely(err == -EBUSY))</span>
<span class="p_add">+			err = -EOVERFLOW;</span>
 		if (err == -EEXIST)
 			err = -EADDRINUSE;
 		nlk_sk(sk)-&gt;portid = 0;
<span class="p_chunk">@@ -2197,7 +2217,7 @@</span> <span class="p_context"> static int netlink_setsockopt(struct socket *sock, int level, int optname,</span>
 			return -EINVAL;
 		if (copy_from_user(&amp;req, optval, sizeof(req)))
 			return -EFAULT;
<span class="p_del">-		err = netlink_set_ring(sk, &amp;req, false,</span>
<span class="p_add">+		err = netlink_set_ring(sk, &amp;req,</span>
 				       optname == NETLINK_TX_RING);
 		break;
 	}
<span class="p_header">diff --git a/net/nfc/nci/hci.c b/net/nfc/nci/hci.c</span>
<span class="p_header">index ed54ec533836..b33fed6d1584 100644</span>
<span class="p_header">--- a/net/nfc/nci/hci.c</span>
<span class="p_header">+++ b/net/nfc/nci/hci.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> int nci_hci_send_cmd(struct nci_dev *ndev, u8 gate, u8 cmd,</span>
 	r = nci_request(ndev, nci_hci_send_data_req, (unsigned long)&amp;data,
 			msecs_to_jiffies(NCI_DATA_TIMEOUT));
 
<span class="p_del">-	if (r == NCI_STATUS_OK)</span>
<span class="p_add">+	if (r == NCI_STATUS_OK &amp;&amp; skb)</span>
 		*skb = conn_info-&gt;rx_skb;
 
 	return r;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index fe1610ddeacf..e1ea5d43b01e 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -2307,7 +2307,8 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 		}
 		tp_len = tpacket_fill_skb(po, skb, ph, dev, size_max, proto,
 					  addr, hlen);
<span class="p_del">-		if (tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
<span class="p_add">+		if (likely(tp_len &gt;= 0) &amp;&amp;</span>
<span class="p_add">+		    tp_len &gt; dev-&gt;mtu + dev-&gt;hard_header_len) {</span>
 			struct ethhdr *ehdr;
 			/* Earlier code assumed this would be a VLAN pkt,
 			 * double-check this now that we have the actual
<span class="p_chunk">@@ -2688,7 +2689,7 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
 static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)
 {
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_del">-	const struct net_device *dev_curr;</span>
<span class="p_add">+	struct net_device *dev_curr;</span>
 	__be16 proto_curr;
 	bool need_rehook;
 
<span class="p_chunk">@@ -2712,15 +2713,13 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 proto)</span>
 
 		po-&gt;num = proto;
 		po-&gt;prot_hook.type = proto;
<span class="p_del">-</span>
<span class="p_del">-		if (po-&gt;prot_hook.dev)</span>
<span class="p_del">-			dev_put(po-&gt;prot_hook.dev);</span>
<span class="p_del">-</span>
 		po-&gt;prot_hook.dev = dev;
 
 		po-&gt;ifindex = dev ? dev-&gt;ifindex : 0;
 		packet_cached_dev_assign(po, dev);
 	}
<span class="p_add">+	if (dev_curr)</span>
<span class="p_add">+		dev_put(dev_curr);</span>
 
 	if (proto == 0 || !need_rehook)
 		goto out_unlock;
<span class="p_header">diff --git a/net/rds/info.c b/net/rds/info.c</span>
<span class="p_header">index 9a6b4f66187c..140a44a5f7b7 100644</span>
<span class="p_header">--- a/net/rds/info.c</span>
<span class="p_header">+++ b/net/rds/info.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,</span>
 
 	/* check for all kinds of wrapping and the like */
 	start = (unsigned long)optval;
<span class="p_del">-	if (len &lt; 0 || len + PAGE_SIZE - 1 &lt; len || start + len &lt; start) {</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; INT_MAX - PAGE_SIZE + 1 || start + len &lt; start) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/net/sched/act_api.c b/net/sched/act_api.c</span>
<span class="p_header">index 3d43e4979f27..f8d9c2a2c451 100644</span>
<span class="p_header">--- a/net/sched/act_api.c</span>
<span class="p_header">+++ b/net/sched/act_api.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> void tcf_hash_destroy(struct tc_action *a)</span>
 }
 EXPORT_SYMBOL(tcf_hash_destroy);
 
<span class="p_del">-int tcf_hash_release(struct tc_action *a, int bind)</span>
<span class="p_add">+int __tcf_hash_release(struct tc_action *a, bool bind, bool strict)</span>
 {
 	struct tcf_common *p = a-&gt;priv;
 	int ret = 0;
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 	if (p) {
 		if (bind)
 			p-&gt;tcfc_bindcnt--;
<span class="p_del">-		else if (p-&gt;tcfc_bindcnt &gt; 0)</span>
<span class="p_add">+		else if (strict &amp;&amp; p-&gt;tcfc_bindcnt &gt; 0)</span>
 			return -EPERM;
 
 		p-&gt;tcfc_refcnt--;
<span class="p_chunk">@@ -64,9 +64,10 @@</span> <span class="p_context"> int tcf_hash_release(struct tc_action *a, int bind)</span>
 			ret = 1;
 		}
 	}
<span class="p_add">+</span>
 	return ret;
 }
<span class="p_del">-EXPORT_SYMBOL(tcf_hash_release);</span>
<span class="p_add">+EXPORT_SYMBOL(__tcf_hash_release);</span>
 
 static int tcf_dump_walker(struct sk_buff *skb, struct netlink_callback *cb,
 			   struct tc_action *a)
<span class="p_chunk">@@ -136,7 +137,7 @@</span> <span class="p_context"> static int tcf_del_walker(struct sk_buff *skb, struct tc_action *a)</span>
 		head = &amp;hinfo-&gt;htab[tcf_hash(i, hinfo-&gt;hmask)];
 		hlist_for_each_entry_safe(p, n, head, tcfc_head) {
 			a-&gt;priv = p;
<span class="p_del">-			ret = tcf_hash_release(a, 0);</span>
<span class="p_add">+			ret = __tcf_hash_release(a, false, true);</span>
 			if (ret == ACT_P_DELETED) {
 				module_put(a-&gt;ops-&gt;owner);
 				n_i++;
<span class="p_chunk">@@ -413,7 +414,7 @@</span> <span class="p_context"> int tcf_action_destroy(struct list_head *actions, int bind)</span>
 	int ret = 0;
 
 	list_for_each_entry_safe(a, tmp, actions, list) {
<span class="p_del">-		ret = tcf_hash_release(a, bind);</span>
<span class="p_add">+		ret = __tcf_hash_release(a, bind, true);</span>
 		if (ret == ACT_P_DELETED)
 			module_put(a-&gt;ops-&gt;owner);
 		else if (ret &lt; 0)
<span class="p_header">diff --git a/net/sched/act_bpf.c b/net/sched/act_bpf.c</span>
<span class="p_header">index dc6a2d324bd8..521ffca91228 100644</span>
<span class="p_header">--- a/net/sched/act_bpf.c</span>
<span class="p_header">+++ b/net/sched/act_bpf.c</span>
<span class="p_chunk">@@ -27,9 +27,10 @@</span> <span class="p_context"></span>
 struct tcf_bpf_cfg {
 	struct bpf_prog *filter;
 	struct sock_filter *bpf_ops;
<span class="p_del">-	char *bpf_name;</span>
<span class="p_add">+	const char *bpf_name;</span>
 	u32 bpf_fd;
 	u16 bpf_num_ops;
<span class="p_add">+	bool is_ebpf;</span>
 };
 
 static int tcf_bpf(struct sk_buff *skb, const struct tc_action *act,
<span class="p_chunk">@@ -200,6 +201,7 @@</span> <span class="p_context"> static int tcf_bpf_init_from_ops(struct nlattr **tb, struct tcf_bpf_cfg *cfg)</span>
 	cfg-&gt;bpf_ops = bpf_ops;
 	cfg-&gt;bpf_num_ops = bpf_num_ops;
 	cfg-&gt;filter = fp;
<span class="p_add">+	cfg-&gt;is_ebpf = false;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -234,18 +236,40 @@</span> <span class="p_context"> static int tcf_bpf_init_from_efd(struct nlattr **tb, struct tcf_bpf_cfg *cfg)</span>
 	cfg-&gt;bpf_fd = bpf_fd;
 	cfg-&gt;bpf_name = name;
 	cfg-&gt;filter = fp;
<span class="p_add">+	cfg-&gt;is_ebpf = true;</span>
 
 	return 0;
 }
 
<span class="p_add">+static void tcf_bpf_cfg_cleanup(const struct tcf_bpf_cfg *cfg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (cfg-&gt;is_ebpf)</span>
<span class="p_add">+		bpf_prog_put(cfg-&gt;filter);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		bpf_prog_destroy(cfg-&gt;filter);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(cfg-&gt;bpf_ops);</span>
<span class="p_add">+	kfree(cfg-&gt;bpf_name);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void tcf_bpf_prog_fill_cfg(const struct tcf_bpf *prog,</span>
<span class="p_add">+				  struct tcf_bpf_cfg *cfg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cfg-&gt;is_ebpf = tcf_bpf_is_ebpf(prog);</span>
<span class="p_add">+	cfg-&gt;filter = prog-&gt;filter;</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg-&gt;bpf_ops = prog-&gt;bpf_ops;</span>
<span class="p_add">+	cfg-&gt;bpf_name = prog-&gt;bpf_name;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int tcf_bpf_init(struct net *net, struct nlattr *nla,
 			struct nlattr *est, struct tc_action *act,
 			int replace, int bind)
 {
 	struct nlattr *tb[TCA_ACT_BPF_MAX + 1];
<span class="p_add">+	struct tcf_bpf_cfg cfg, old;</span>
 	struct tc_act_bpf *parm;
 	struct tcf_bpf *prog;
<span class="p_del">-	struct tcf_bpf_cfg cfg;</span>
 	bool is_bpf, is_ebpf;
 	int ret;
 
<span class="p_chunk">@@ -294,6 +318,9 @@</span> <span class="p_context"> static int tcf_bpf_init(struct net *net, struct nlattr *nla,</span>
 	prog = to_bpf(act);
 	spin_lock_bh(&amp;prog-&gt;tcf_lock);
 
<span class="p_add">+	if (ret != ACT_P_CREATED)</span>
<span class="p_add">+		tcf_bpf_prog_fill_cfg(prog, &amp;old);</span>
<span class="p_add">+</span>
 	prog-&gt;bpf_ops = cfg.bpf_ops;
 	prog-&gt;bpf_name = cfg.bpf_name;
 
<span class="p_chunk">@@ -309,29 +336,22 @@</span> <span class="p_context"> static int tcf_bpf_init(struct net *net, struct nlattr *nla,</span>
 
 	if (ret == ACT_P_CREATED)
 		tcf_hash_insert(act);
<span class="p_add">+	else</span>
<span class="p_add">+		tcf_bpf_cfg_cleanup(&amp;old);</span>
 
 	return ret;
 
 destroy_fp:
<span class="p_del">-	if (is_ebpf)</span>
<span class="p_del">-		bpf_prog_put(cfg.filter);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		bpf_prog_destroy(cfg.filter);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(cfg.bpf_ops);</span>
<span class="p_del">-	kfree(cfg.bpf_name);</span>
<span class="p_del">-</span>
<span class="p_add">+	tcf_bpf_cfg_cleanup(&amp;cfg);</span>
 	return ret;
 }
 
 static void tcf_bpf_cleanup(struct tc_action *act, int bind)
 {
<span class="p_del">-	const struct tcf_bpf *prog = act-&gt;priv;</span>
<span class="p_add">+	struct tcf_bpf_cfg tmp;</span>
 
<span class="p_del">-	if (tcf_bpf_is_ebpf(prog))</span>
<span class="p_del">-		bpf_prog_put(prog-&gt;filter);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		bpf_prog_destroy(prog-&gt;filter);</span>
<span class="p_add">+	tcf_bpf_prog_fill_cfg(act-&gt;priv, &amp;tmp);</span>
<span class="p_add">+	tcf_bpf_cfg_cleanup(&amp;tmp);</span>
 }
 
 static struct tc_action_ops act_bpf_ops __read_mostly = {
<span class="p_header">diff --git a/net/sched/cls_bpf.c b/net/sched/cls_bpf.c</span>
<span class="p_header">index 91bd9c19471d..c0b86f2bfe22 100644</span>
<span class="p_header">--- a/net/sched/cls_bpf.c</span>
<span class="p_header">+++ b/net/sched/cls_bpf.c</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> static int cls_bpf_change(struct net *net, struct sk_buff *in_skb,</span>
 		goto errout;
 
 	if (oldprog) {
<span class="p_del">-		list_replace_rcu(&amp;prog-&gt;link, &amp;oldprog-&gt;link);</span>
<span class="p_add">+		list_replace_rcu(&amp;oldprog-&gt;link, &amp;prog-&gt;link);</span>
 		tcf_unbind_filter(tp, &amp;oldprog-&gt;res);
 		call_rcu(&amp;oldprog-&gt;rcu, __cls_bpf_delete_prog);
 	} else {
<span class="p_header">diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c</span>
<span class="p_header">index a620c4e288a5..75df923f5c03 100644</span>
<span class="p_header">--- a/net/sched/cls_flow.c</span>
<span class="p_header">+++ b/net/sched/cls_flow.c</span>
<span class="p_chunk">@@ -419,6 +419,8 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 	if (!fnew)
 		goto err2;
 
<span class="p_add">+	tcf_exts_init(&amp;fnew-&gt;exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);</span>
<span class="p_add">+</span>
 	fold = (struct flow_filter *)*arg;
 	if (fold) {
 		err = -EINVAL;
<span class="p_chunk">@@ -480,7 +482,6 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 		fnew-&gt;mask  = ~0U;
 		fnew-&gt;tp = tp;
 		get_random_bytes(&amp;fnew-&gt;hashrnd, 4);
<span class="p_del">-		tcf_exts_init(&amp;fnew-&gt;exts, TCA_FLOW_ACT, TCA_FLOW_POLICE);</span>
 	}
 
 	fnew-&gt;perturb_timer.function = flow_perturbation;
<span class="p_chunk">@@ -520,7 +521,7 @@</span> <span class="p_context"> static int flow_change(struct net *net, struct sk_buff *in_skb,</span>
 	if (*arg == 0)
 		list_add_tail_rcu(&amp;fnew-&gt;list, &amp;head-&gt;filters);
 	else
<span class="p_del">-		list_replace_rcu(&amp;fnew-&gt;list, &amp;fold-&gt;list);</span>
<span class="p_add">+		list_replace_rcu(&amp;fold-&gt;list, &amp;fnew-&gt;list);</span>
 
 	*arg = (unsigned long)fnew;
 
<span class="p_header">diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c</span>
<span class="p_header">index c244c45b78d7..9291598b5aad 100644</span>
<span class="p_header">--- a/net/sched/sch_fq_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_fq_codel.c</span>
<span class="p_chunk">@@ -162,10 +162,10 @@</span> <span class="p_context"> static unsigned int fq_codel_drop(struct Qdisc *sch)</span>
 	skb = dequeue_head(flow);
 	len = qdisc_pkt_len(skb);
 	q-&gt;backlogs[idx] -= len;
<span class="p_del">-	kfree_skb(skb);</span>
 	sch-&gt;q.qlen--;
 	qdisc_qstats_drop(sch);
 	qdisc_qstats_backlog_dec(sch, skb);
<span class="p_add">+	kfree_skb(skb);</span>
 	flow-&gt;dropped++;
 	return idx;
 }
<span class="p_header">diff --git a/net/sunrpc/xprt.c b/net/sunrpc/xprt.c</span>
<span class="p_header">index 1d4fe24af06a..d109d308ec3a 100644</span>
<span class="p_header">--- a/net/sunrpc/xprt.c</span>
<span class="p_header">+++ b/net/sunrpc/xprt.c</span>
<span class="p_chunk">@@ -611,6 +611,7 @@</span> <span class="p_context"> static void xprt_autoclose(struct work_struct *work)</span>
 	xprt-&gt;ops-&gt;close(xprt);
 	clear_bit(XPRT_CLOSE_WAIT, &amp;xprt-&gt;state);
 	xprt_release_write(xprt, NULL);
<span class="p_add">+	wake_up_bit(&amp;xprt-&gt;state, XPRT_LOCKED);</span>
 }
 
 /**
<span class="p_chunk">@@ -720,6 +721,7 @@</span> <span class="p_context"> void xprt_unlock_connect(struct rpc_xprt *xprt, void *cookie)</span>
 	xprt-&gt;ops-&gt;release_xprt(xprt, NULL);
 out:
 	spin_unlock_bh(&amp;xprt-&gt;transport_lock);
<span class="p_add">+	wake_up_bit(&amp;xprt-&gt;state, XPRT_LOCKED);</span>
 }
 
 /**
<span class="p_chunk">@@ -1389,6 +1391,10 @@</span> <span class="p_context"> out:</span>
 static void xprt_destroy(struct rpc_xprt *xprt)
 {
 	dprintk(&quot;RPC:       destroying transport %p\n&quot;, xprt);
<span class="p_add">+</span>
<span class="p_add">+	/* Exclude transport connect/disconnect handlers */</span>
<span class="p_add">+	wait_on_bit_lock(&amp;xprt-&gt;state, XPRT_LOCKED, TASK_UNINTERRUPTIBLE);</span>
<span class="p_add">+</span>
 	del_timer_sync(&amp;xprt-&gt;timer);
 
 	rpc_xprt_debugfs_unregister(xprt);
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index 66891e32c5e3..5e3ad598d3f5 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -834,6 +834,7 @@</span> <span class="p_context"> static void xs_reset_transport(struct sock_xprt *transport)</span>
 	sk-&gt;sk_user_data = NULL;
 
 	xs_restore_old_callbacks(transport, sk);
<span class="p_add">+	xprt_clear_connected(xprt);</span>
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 	xs_sock_reset_connection_flags(xprt);
 
<span class="p_chunk">@@ -1433,6 +1434,7 @@</span> <span class="p_context"> out:</span>
 static void xs_tcp_state_change(struct sock *sk)
 {
 	struct rpc_xprt *xprt;
<span class="p_add">+	struct sock_xprt *transport;</span>
 
 	read_lock_bh(&amp;sk-&gt;sk_callback_lock);
 	if (!(xprt = xprt_from_sock(sk)))
<span class="p_chunk">@@ -1444,13 +1446,12 @@</span> <span class="p_context"> static void xs_tcp_state_change(struct sock *sk)</span>
 			sock_flag(sk, SOCK_ZAPPED),
 			sk-&gt;sk_shutdown);
 
<span class="p_add">+	transport = container_of(xprt, struct sock_xprt, xprt);</span>
 	trace_rpc_socket_state_change(xprt, sk-&gt;sk_socket);
 	switch (sk-&gt;sk_state) {
 	case TCP_ESTABLISHED:
 		spin_lock(&amp;xprt-&gt;transport_lock);
 		if (!xprt_test_and_set_connected(xprt)) {
<span class="p_del">-			struct sock_xprt *transport = container_of(xprt,</span>
<span class="p_del">-					struct sock_xprt, xprt);</span>
 
 			/* Reset TCP record info */
 			transport-&gt;tcp_offset = 0;
<span class="p_chunk">@@ -1459,6 +1460,8 @@</span> <span class="p_context"> static void xs_tcp_state_change(struct sock *sk)</span>
 			transport-&gt;tcp_flags =
 				TCP_RCV_COPY_FRAGHDR | TCP_RCV_COPY_XID;
 			xprt-&gt;connect_cookie++;
<span class="p_add">+			clear_bit(XPRT_SOCK_CONNECTING, &amp;transport-&gt;sock_state);</span>
<span class="p_add">+			xprt_clear_connecting(xprt);</span>
 
 			xprt_wake_pending_tasks(xprt, -EAGAIN);
 		}
<span class="p_chunk">@@ -1494,6 +1497,9 @@</span> <span class="p_context"> static void xs_tcp_state_change(struct sock *sk)</span>
 		smp_mb__after_atomic();
 		break;
 	case TCP_CLOSE:
<span class="p_add">+		if (test_and_clear_bit(XPRT_SOCK_CONNECTING,</span>
<span class="p_add">+					&amp;transport-&gt;sock_state))</span>
<span class="p_add">+			xprt_clear_connecting(xprt);</span>
 		xs_sock_mark_closed(xprt);
 	}
  out:
<span class="p_chunk">@@ -2110,6 +2116,7 @@</span> <span class="p_context"> static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)</span>
 	/* Tell the socket layer to start connecting... */
 	xprt-&gt;stat.connect_count++;
 	xprt-&gt;stat.connect_start = jiffies;
<span class="p_add">+	set_bit(XPRT_SOCK_CONNECTING, &amp;transport-&gt;sock_state);</span>
 	ret = kernel_connect(sock, xs_addr(xprt), xprt-&gt;addrlen, O_NONBLOCK);
 	switch (ret) {
 	case 0:
<span class="p_chunk">@@ -2174,7 +2181,6 @@</span> <span class="p_context"> static void xs_tcp_setup_socket(struct work_struct *work)</span>
 	case -EINPROGRESS:
 	case -EALREADY:
 		xprt_unlock_connect(xprt, transport);
<span class="p_del">-		xprt_clear_connecting(xprt);</span>
 		return;
 	case -EINVAL:
 		/* Happens, for instance, if the user specified a link
<span class="p_chunk">@@ -2216,13 +2222,14 @@</span> <span class="p_context"> static void xs_connect(struct rpc_xprt *xprt, struct rpc_task *task)</span>
 
 	WARN_ON_ONCE(!xprt_lock_connect(xprt, task, transport));
 
<span class="p_del">-	/* Start by resetting any existing state */</span>
<span class="p_del">-	xs_reset_transport(transport);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (transport-&gt;sock != NULL &amp;&amp; !RPC_IS_SOFTCONN(task)) {</span>
<span class="p_add">+	if (transport-&gt;sock != NULL) {</span>
 		dprintk(&quot;RPC:       xs_connect delayed xprt %p for %lu &quot;
 				&quot;seconds\n&quot;,
 				xprt, xprt-&gt;reestablish_timeout / HZ);
<span class="p_add">+</span>
<span class="p_add">+		/* Start by resetting any existing state */</span>
<span class="p_add">+		xs_reset_transport(transport);</span>
<span class="p_add">+</span>
 		queue_delayed_work(rpciod_workqueue,
 				   &amp;transport-&gt;connect_worker,
 				   xprt-&gt;reestablish_timeout);
<span class="p_header">diff --git a/net/tipc/socket.c b/net/tipc/socket.c</span>
<span class="p_header">index f485600c4507..20cc6df07157 100644</span>
<span class="p_header">--- a/net/tipc/socket.c</span>
<span class="p_header">+++ b/net/tipc/socket.c</span>
<span class="p_chunk">@@ -2009,6 +2009,7 @@</span> <span class="p_context"> static int tipc_accept(struct socket *sock, struct socket *new_sock, int flags)</span>
 	res = tipc_sk_create(sock_net(sock-&gt;sk), new_sock, 0, 1);
 	if (res)
 		goto exit;
<span class="p_add">+	security_sk_clone(sock-&gt;sk, new_sock-&gt;sk);</span>
 
 	new_sk = new_sock-&gt;sk;
 	new_tsock = tipc_sk(new_sk);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 91f6928560e1..6fe862594e9b 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -1134,7 +1134,7 @@</span> <span class="p_context"> static const struct hda_fixup alc880_fixups[] = {</span>
 		/* override all pins as BIOS on old Amilo is broken */
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_del">-			{ 0x14, 0x0121411f }, /* HP */</span>
<span class="p_add">+			{ 0x14, 0x0121401f }, /* HP */</span>
 			{ 0x15, 0x99030120 }, /* speaker */
 			{ 0x16, 0x99030130 }, /* bass speaker */
 			{ 0x17, 0x411111f0 }, /* N/A */
<span class="p_chunk">@@ -1154,7 +1154,7 @@</span> <span class="p_context"> static const struct hda_fixup alc880_fixups[] = {</span>
 		/* almost compatible with FUJITSU, but no bass and SPDIF */
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_del">-			{ 0x14, 0x0121411f }, /* HP */</span>
<span class="p_add">+			{ 0x14, 0x0121401f }, /* HP */</span>
 			{ 0x15, 0x99030120 }, /* speaker */
 			{ 0x16, 0x411111f0 }, /* N/A */
 			{ 0x17, 0x411111f0 }, /* N/A */
<span class="p_chunk">@@ -1363,7 +1363,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc880_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x161f, 0x203d, &quot;W810&quot;, ALC880_FIXUP_W810),
 	SND_PCI_QUIRK(0x161f, 0x205d, &quot;Medion Rim 2150&quot;, ALC880_FIXUP_MEDION_RIM),
 	SND_PCI_QUIRK(0x1631, 0xe011, &quot;PB 13201056&quot;, ALC880_FIXUP_6ST_AUTOMUTE),
<span class="p_del">-	SND_PCI_QUIRK(0x1734, 0x107c, &quot;FSC F1734&quot;, ALC880_FIXUP_F1734),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1734, 0x107c, &quot;FSC Amilo M1437&quot;, ALC880_FIXUP_FUJITSU),</span>
 	SND_PCI_QUIRK(0x1734, 0x1094, &quot;FSC Amilo M1451G&quot;, ALC880_FIXUP_FUJITSU),
 	SND_PCI_QUIRK(0x1734, 0x10ac, &quot;FSC AMILO Xi 1526&quot;, ALC880_FIXUP_F1734),
 	SND_PCI_QUIRK(0x1734, 0x10b0, &quot;FSC Amilo Pi1556&quot;, ALC880_FIXUP_FUJITSU),
<span class="p_chunk">@@ -5118,8 +5118,11 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06c7, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06d9, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x06da, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x1028, 0x06db, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06dd, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06df, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x06e0, &quot;Dell&quot;, ALC292_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -6454,6 +6457,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x05db, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x05fe, &quot;Dell XPS 15&quot;, ALC668_FIXUP_DELL_XPS13),
 	SND_PCI_QUIRK(0x1028, 0x060a, &quot;Dell XPS 13&quot;, ALC668_FIXUP_DELL_XPS13),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x060d, &quot;Dell M3800&quot;, ALC668_FIXUP_DELL_XPS13),</span>
 	SND_PCI_QUIRK(0x1028, 0x0625, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0626, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0696, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 8b7e391dd0b8..cd8ed2e393a2 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -2522,7 +2522,7 @@</span> <span class="p_context"> static int restore_mixer_value(struct usb_mixer_elem_list *list)</span>
 		for (c = 0; c &lt; MAX_CHANNELS; c++) {
 			if (!(cval-&gt;cmask &amp; (1 &lt;&lt; c)))
 				continue;
<span class="p_del">-			if (cval-&gt;cached &amp; (1 &lt;&lt; c)) {</span>
<span class="p_add">+			if (cval-&gt;cached &amp; (1 &lt;&lt; (c + 1))) {</span>
 				err = snd_usb_set_cur_mix_value(cval, c + 1, idx,
 							cval-&gt;cache_val[idx]);
 				if (err &lt; 0)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



