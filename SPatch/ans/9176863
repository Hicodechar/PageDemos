
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4.2.y-ckt,stable] Linux 4.2.8-ckt12 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4.2.y-ckt,stable] Linux 4.2.8-ckt12</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 14, 2016, 8:20 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1465935629-24549-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9176863/mbox/"
   >mbox</a>
|
   <a href="/patch/9176863/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9176863/">/patch/9176863/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5C9926021C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Jun 2016 20:21:17 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 39CD12793B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Jun 2016 20:21:17 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2D08C2823D; Tue, 14 Jun 2016 20:21:17 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 458AD2793B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Jun 2016 20:21:05 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932345AbcFNUU5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 14 Jun 2016 16:20:57 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:58147 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752790AbcFNUUh (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 14 Jun 2016 16:20:37 -0400
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1bCup7-00022y-U4; Tue, 14 Jun 2016 20:20:34 +0000
Received: from kamal by fourier with local (Exim 4.86_2)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1bCup5-0006Ot-6V; Tue, 14 Jun 2016 13:20:31 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [4.2.y-ckt stable] Linux 4.2.8-ckt12
Date: Tue, 14 Jun 2016 13:20:29 -0700
Message-Id: &lt;1465935629-24549-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1465935629-24549-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1465935629-24549-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 4.2
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - June 14, 2016, 8:20 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/accounting/getdelays.c b/Documentation/accounting/getdelays.c</span>
<span class="p_header">index f405780..9497d20 100644</span>
<span class="p_header">--- a/Documentation/accounting/getdelays.c</span>
<span class="p_header">+++ b/Documentation/accounting/getdelays.c</span>
<span class="p_chunk">@@ -504,6 +504,8 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 						if (!loop)
 							goto done;
 						break;
<span class="p_add">+					case TASKSTATS_TYPE_NULL:</span>
<span class="p_add">+						break;</span>
 					default:
 						fprintf(stderr, &quot;Unknown nested&quot;
 							&quot; nla_type %d\n&quot;,
<span class="p_chunk">@@ -511,7 +513,8 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 						break;
 					}
 					len2 += NLA_ALIGN(na-&gt;nla_len);
<span class="p_del">-					na = (struct nlattr *) ((char *) na + len2);</span>
<span class="p_add">+					na = (struct nlattr *)((char *)na +</span>
<span class="p_add">+							       NLA_ALIGN(na-&gt;nla_len));</span>
 				}
 				break;
 
<span class="p_header">diff --git a/Documentation/serial/driver b/Documentation/serial/driver</span>
<span class="p_header">index c415b0e..7bff80876 100644</span>
<span class="p_header">--- a/Documentation/serial/driver</span>
<span class="p_header">+++ b/Documentation/serial/driver</span>
<span class="p_chunk">@@ -28,11 +28,6 @@</span> <span class="p_context"> The serial core provides a few helper functions.  This includes identifing</span>
 the correct port structure (via uart_get_console) and decoding command line
 arguments (uart_parse_options).
 
<span class="p_del">-There is also a helper function (uart_write_console) which performs a</span>
<span class="p_del">-character by character write, translating newlines to CRLF sequences.</span>
<span class="p_del">-Driver writers are recommended to use this function rather than implementing</span>
<span class="p_del">-their own version.</span>
<span class="p_del">-</span>
 
 Locking
 -------
<span class="p_header">diff --git a/Documentation/serial/tty.txt b/Documentation/serial/tty.txt</span>
<span class="p_header">index 973c8ad..849e81a 100644</span>
<span class="p_header">--- a/Documentation/serial/tty.txt</span>
<span class="p_header">+++ b/Documentation/serial/tty.txt</span>
<span class="p_chunk">@@ -195,9 +195,6 @@</span> <span class="p_context"> TTY_IO_ERROR		If set, causes all subsequent userspace read/write</span>
 
 TTY_OTHER_CLOSED	Device is a pty and the other side has closed.
 
<span class="p_del">-TTY_OTHER_DONE		Device is a pty and the other side has closed and</span>
<span class="p_del">-			all pending input processing has been completed.</span>
<span class="p_del">-</span>
 TTY_NO_WRITE_SPLIT	Prevent driver from splitting up writes into
 			smaller chunks.
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index daa93e8..ff59f01 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 2
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt11</span>
<span class="p_add">+EXTRAVERSION = -ckt12</span>
 NAME = Hare&#39;s hurried rump
 
 # *DOCUMENTATION*
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> AFLAGS_MODULE   =</span>
 LDFLAGS_MODULE  =
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
<span class="p_del">-CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage</span>
<span class="p_add">+CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage -fno-tree-loop-im</span>
 
 
 # Use USERINCLUDE when you must reference the UAPI directories only.
<span class="p_chunk">@@ -688,9 +688,10 @@</span> <span class="p_context"> KBUILD_CFLAGS += $(call cc-option, -mno-global-merge,)</span>
 KBUILD_CFLAGS += $(call cc-option, -fcatch-undefined-behavior)
 else
 
<span class="p_del">-# This warning generated too much noise in a regular build.</span>
<span class="p_del">-# Use make W=1 to enable this warning (see scripts/Makefile.build)</span>
<span class="p_add">+# These warnings generated too much noise in a regular build.</span>
<span class="p_add">+# Use make W=1 to enable them (see scripts/Makefile.build)</span>
 KBUILD_CFLAGS += $(call cc-disable-warning, unused-but-set-variable)
<span class="p_add">+KBUILD_CFLAGS += $(call cc-disable-warning, unused-const-variable)</span>
 endif
 
 ifdef CONFIG_FRAME_POINTER
<span class="p_header">diff --git a/arch/alpha/kernel/pci-sysfs.c b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">index 99e8d47..92c0d46 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_chunk">@@ -77,10 +77,10 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj,</span>
 	if (i &gt;= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
<span class="p_del">-	if (!__pci_mmap_fits(pdev, i, vma, sparse))</span>
<span class="p_add">+	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(res-&gt;start))</span>
 		return -EINVAL;
 
<span class="p_del">-	if (iomem_is_exclusive(res-&gt;start))</span>
<span class="p_add">+	if (!__pci_mmap_fits(pdev, i, vma, sparse))</span>
 		return -EINVAL;
 
 	pcibios_resource_to_bus(pdev-&gt;bus, &amp;bar, res);
<span class="p_header">diff --git a/arch/arm/Kconfig.debug b/arch/arm/Kconfig.debug</span>
<span class="p_header">index 55ef850..0b967a1 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig.debug</span>
<span class="p_header">+++ b/arch/arm/Kconfig.debug</span>
<span class="p_chunk">@@ -277,14 +277,6 @@</span> <span class="p_context"> choice</span>
 		  Say Y here if you want kernel low-level debugging support
 		  on HI3620 UART.
 
<span class="p_del">-	config DEBUG_HI3716_UART</span>
<span class="p_del">-		bool &quot;Hisilicon Hi3716 Debug UART&quot;</span>
<span class="p_del">-		depends on ARCH_HI3xxx</span>
<span class="p_del">-		select DEBUG_UART_PL01X</span>
<span class="p_del">-		help</span>
<span class="p_del">-		  Say Y here if you want kernel low-level debugging support</span>
<span class="p_del">-		  on HI3716 UART.</span>
<span class="p_del">-</span>
 	config DEBUG_HIGHBANK_UART
 		bool &quot;Kernel low-level debugging messages via Highbank UART&quot;
 		depends on ARCH_HIGHBANK
<span class="p_header">diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile</span>
<span class="p_header">index 246473a..908c288 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/Makefile</span>
<span class="p_header">+++ b/arch/arm/boot/dts/Makefile</span>
<span class="p_chunk">@@ -158,6 +158,7 @@</span> <span class="p_context"> dtb-$(CONFIG_MACH_KIRKWOOD) += \</span>
 	kirkwood-ds109.dtb \
 	kirkwood-ds110jv10.dtb \
 	kirkwood-ds111.dtb \
<span class="p_add">+	kirkwood-ds112.dtb \</span>
 	kirkwood-ds209.dtb \
 	kirkwood-ds210.dtb \
 	kirkwood-ds212.dtb \
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-385-linksys.dtsi b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">index 1ce7a1e..cb37e88 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-385-linksys.dtsi</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"></span>
 		button@2 {
 			label = &quot;Factory Reset Button&quot;;
 			linux,code = &lt;KEY_RESTART&gt;;
<span class="p_del">-			gpios = &lt;&amp;gpio1 15 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio0 29 GPIO_ACTIVE_LOW&gt;;</span>
 		};
 	};
 
<span class="p_chunk">@@ -258,7 +258,7 @@</span> <span class="p_context"></span>
 		};
 
 		sata {
<span class="p_del">-			gpios = &lt;&amp;gpio1 22 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio1 22 GPIO_ACTIVE_LOW&gt;;</span>
 			default-state = &quot;off&quot;;
 		};
 	};
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"></span>
 
 &amp;pinctrl {
 	keys_pin: keys-pin {
<span class="p_del">-		marvell,pins = &quot;mpp24&quot;, &quot;mpp47&quot;;</span>
<span class="p_add">+		marvell,pins = &quot;mpp24&quot;, &quot;mpp29&quot;;</span>
 		marvell,function = &quot;gpio&quot;;
 	};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts</span>
<span class="p_header">index fdd187c..e767735 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-linksys-mamba.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-linksys-mamba.dts</span>
<span class="p_chunk">@@ -302,13 +302,13 @@</span> <span class="p_context"></span>
 		button@1 {
 			label = &quot;WPS&quot;;
 			linux,code = &lt;KEY_WPS_BUTTON&gt;;
<span class="p_del">-			gpios = &lt;&amp;gpio1 0 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio1 0 GPIO_ACTIVE_LOW&gt;;</span>
 		};
 
 		button@2 {
 			label = &quot;Factory Reset Button&quot;;
 			linux,code = &lt;KEY_RESTART&gt;;
<span class="p_del">-			gpios = &lt;&amp;gpio1 1 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio1 1 GPIO_ACTIVE_LOW&gt;;</span>
 		};
 	};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4210-trats.dts b/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_header">index ba34886..60efd46 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4210-trats.dts</span>
<span class="p_chunk">@@ -296,6 +296,8 @@</span> <span class="p_context"></span>
 		compatible = &quot;maxim,max8997-pmic&quot;;
 
 		reg = &lt;0x66&gt;;
<span class="p_add">+		interrupt-parent = &lt;&amp;gpx0&gt;;</span>
<span class="p_add">+		interrupts = &lt;7 0&gt;;</span>
 
 		max8997,pmic-buck1-uses-gpio-dvs;
 		max8997,pmic-buck2-uses-gpio-dvs;
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 61d96a6..12d727fa 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -886,11 +886,14 @@</span> <span class="p_context"> static int stage2_set_pmd_huge(struct kvm *kvm, struct kvm_mmu_memory_cache</span>
 	VM_BUG_ON(pmd_present(*pmd) &amp;&amp; pmd_pfn(*pmd) != pmd_pfn(*new_pmd));
 
 	old_pmd = *pmd;
<span class="p_del">-	kvm_set_pmd(pmd, *new_pmd);</span>
<span class="p_del">-	if (pmd_present(old_pmd))</span>
<span class="p_add">+	if (pmd_present(old_pmd)) {</span>
<span class="p_add">+		pmd_clear(pmd);</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pmd));
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_set_pmd(pmd, *new_pmd);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -939,12 +942,14 @@</span> <span class="p_context"> static int stage2_set_pte(struct kvm *kvm, struct kvm_mmu_memory_cache *cache,</span>
 
 	/* Create 2nd stage page table mapping - Level 3 */
 	old_pte = *pte;
<span class="p_del">-	kvm_set_pte(pte, *new_pte);</span>
<span class="p_del">-	if (pte_present(old_pte))</span>
<span class="p_add">+	if (pte_present(old_pte)) {</span>
<span class="p_add">+		kvm_set_pte(pte, __pte(0));</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pte));
<span class="p_add">+	}</span>
 
<span class="p_add">+	kvm_set_pte(pte, *new_pte);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">index 0325041..11bf8f9 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod.c</span>
<span class="p_chunk">@@ -2187,15 +2187,15 @@</span> <span class="p_context"> static int _idle(struct omap_hwmod *oh)</span>
 
 	pr_debug(&quot;omap_hwmod: %s: idling\n&quot;, oh-&gt;name);
 
<span class="p_add">+	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (oh-&gt;_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, &quot;omap_hwmod: %s: idle state can only be entered from enabled state\n&quot;,
 			oh-&gt;name);
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	if (oh-&gt;class-&gt;sysc)
 		_idle_sysc(oh);
 	_del_initiator_dep(oh, mpu_oh);
<span class="p_chunk">@@ -2242,6 +2242,9 @@</span> <span class="p_context"> static int _shutdown(struct omap_hwmod *oh)</span>
 	int ret, i;
 	u8 prev_state;
 
<span class="p_add">+	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (oh-&gt;_state != _HWMOD_STATE_IDLE &amp;&amp;
 	    oh-&gt;_state != _HWMOD_STATE_ENABLED) {
 		WARN(1, &quot;omap_hwmod: %s: disabled state can only be entered from idle, or enabled state\n&quot;,
<span class="p_chunk">@@ -2249,9 +2252,6 @@</span> <span class="p_context"> static int _shutdown(struct omap_hwmod *oh)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (_are_all_hardreset_lines_asserted(oh))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	pr_debug(&quot;omap_hwmod: %s: disabling\n&quot;, oh-&gt;name);
 
 	if (oh-&gt;class-&gt;pre_shutdown) {
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">index 59bfae7..d007a7b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_chunk">@@ -77,7 +77,6 @@</span> <span class="p_context"></span>
  * Section
  */
 #define PMD_SECT_VALID		(_AT(pmdval_t, 1) &lt;&lt; 0)
<span class="p_del">-#define PMD_SECT_PROT_NONE	(_AT(pmdval_t, 1) &lt;&lt; 58)</span>
 #define PMD_SECT_USER		(_AT(pmdval_t, 1) &lt;&lt; 6)		/* AP[1] */
 #define PMD_SECT_RDONLY		(_AT(pmdval_t, 1) &lt;&lt; 7)		/* AP[2] */
 #define PMD_SECT_S		(_AT(pmdval_t, 3) &lt;&lt; 8)
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index 526a9cb..f1fc314 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -285,6 +285,7 @@</span> <span class="p_context"> void pmdp_splitting_flush(struct vm_area_struct *vma, unsigned long address,</span>
 #endif /* CONFIG_HAVE_RCU_TABLE_FREE */
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 
<span class="p_add">+#define pmd_present(pmd)	pte_present(pmd_pte(pmd))</span>
 #define pmd_dirty(pmd)		pte_dirty(pmd_pte(pmd))
 #define pmd_young(pmd)		pte_young(pmd_pte(pmd))
 #define pmd_wrprotect(pmd)	pte_pmd(pte_wrprotect(pmd_pte(pmd)))
<span class="p_chunk">@@ -293,7 +294,7 @@</span> <span class="p_context"> void pmdp_splitting_flush(struct vm_area_struct *vma, unsigned long address,</span>
 #define pmd_mkwrite(pmd)	pte_pmd(pte_mkwrite(pmd_pte(pmd)))
 #define pmd_mkdirty(pmd)	pte_pmd(pte_mkdirty(pmd_pte(pmd)))
 #define pmd_mkyoung(pmd)	pte_pmd(pte_mkyoung(pmd_pte(pmd)))
<span class="p_del">-#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_TYPE_MASK))</span>
<span class="p_add">+#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_SECT_VALID))</span>
 
 #define __HAVE_ARCH_PMD_WRITE
 #define pmd_write(pmd)		pte_write(pmd_pte(pmd))
<span class="p_chunk">@@ -332,7 +333,6 @@</span> <span class="p_context"> extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,</span>
 				     unsigned long size, pgprot_t vma_prot);
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
<span class="p_del">-#define pmd_present(pmd)	(pmd_val(pmd))</span>
 
 #define pmd_bad(pmd)		(!(pmd_val(pmd) &amp; 2))
 
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index f3067d4..448b501 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -482,7 +482,8 @@</span> <span class="p_context"> static const char *compat_hwcap_str[] = {</span>
 	&quot;idivt&quot;,
 	&quot;vfpd32&quot;,
 	&quot;lpae&quot;,
<span class="p_del">-	&quot;evtstrm&quot;</span>
<span class="p_add">+	&quot;evtstrm&quot;,</span>
<span class="p_add">+	NULL</span>
 };
 
 static const char *compat_hwcap2_str[] = {
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 648112e..3972e65 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static void inject_abt64(struct kvm_vcpu *vcpu, bool is_iabt, unsigned long addr</span>
 		esr |= (ESR_ELx_EC_IABT_CUR &lt;&lt; ESR_ELx_EC_SHIFT);
 
 	if (!is_iabt)
<span class="p_del">-		esr |= ESR_ELx_EC_DABT_LOW;</span>
<span class="p_add">+		esr |= ESR_ELx_EC_DABT_LOW &lt;&lt; ESR_ELx_EC_SHIFT;</span>
 
 	vcpu_sys_reg(vcpu, ESR_EL1) = esr | ESR_ELx_FSC_EXTABT;
 }
<span class="p_header">diff --git a/arch/metag/include/asm/atomic_lnkget.h b/arch/metag/include/asm/atomic_lnkget.h</span>
<span class="p_header">index 948d868..d0bdc28 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/atomic_lnkget.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/atomic_lnkget.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
 		&quot;	CMPT	%0, #HI(0x02000000)\n&quot;			\
 		&quot;	BNZ 1b\n&quot;					\
 		: &quot;=&amp;d&quot; (temp), &quot;=&amp;da&quot; (result)				\
<span class="p_del">-		: &quot;da&quot; (&amp;v-&gt;counter), &quot;bd&quot; (i)				\</span>
<span class="p_add">+		: &quot;da&quot; (&amp;v-&gt;counter), &quot;br&quot; (i)				\</span>
 		: &quot;cc&quot;);						\
 									\
 	smp_mb();							\
<span class="p_header">diff --git a/arch/mips/ath79/common.c b/arch/mips/ath79/common.c</span>
<span class="p_header">index 3cedd1f..8ae4067 100644</span>
<span class="p_header">--- a/arch/mips/ath79/common.c</span>
<span class="p_header">+++ b/arch/mips/ath79/common.c</span>
<span class="p_chunk">@@ -76,14 +76,14 @@</span> <span class="p_context"> void ath79_ddr_set_pci_windows(void)</span>
 {
 	BUG_ON(!ath79_ddr_pci_win_base);
 
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN0_OFFS, ath79_ddr_pci_win_base + 0);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN1_OFFS, ath79_ddr_pci_win_base + 1);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN2_OFFS, ath79_ddr_pci_win_base + 2);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN3_OFFS, ath79_ddr_pci_win_base + 3);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN4_OFFS, ath79_ddr_pci_win_base + 4);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN5_OFFS, ath79_ddr_pci_win_base + 5);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN6_OFFS, ath79_ddr_pci_win_base + 6);</span>
<span class="p_del">-	__raw_writel(AR71XX_PCI_WIN7_OFFS, ath79_ddr_pci_win_base + 7);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN0_OFFS, ath79_ddr_pci_win_base + 0x0);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN1_OFFS, ath79_ddr_pci_win_base + 0x4);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN2_OFFS, ath79_ddr_pci_win_base + 0x8);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN3_OFFS, ath79_ddr_pci_win_base + 0xc);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN4_OFFS, ath79_ddr_pci_win_base + 0x10);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN5_OFFS, ath79_ddr_pci_win_base + 0x14);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN6_OFFS, ath79_ddr_pci_win_base + 0x18);</span>
<span class="p_add">+	__raw_writel(AR71XX_PCI_WIN7_OFFS, ath79_ddr_pci_win_base + 0x1c);</span>
 }
 EXPORT_SYMBOL_GPL(ath79_ddr_set_pci_windows);
 
<span class="p_header">diff --git a/arch/mips/ath79/early_printk.c b/arch/mips/ath79/early_printk.c</span>
<span class="p_header">index b955faf..d1adc59 100644</span>
<span class="p_header">--- a/arch/mips/ath79/early_printk.c</span>
<span class="p_header">+++ b/arch/mips/ath79/early_printk.c</span>
<span class="p_chunk">@@ -31,13 +31,15 @@</span> <span class="p_context"> static inline void prom_putchar_wait(void __iomem *reg, u32 mask, u32 val)</span>
 	} while (1);
 }
 
<span class="p_add">+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)</span>
<span class="p_add">+</span>
 static void prom_putchar_ar71xx(unsigned char ch)
 {
 	void __iomem *base = (void __iomem *)(KSEG1ADDR(AR71XX_UART_BASE));
 
<span class="p_del">-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);</span>
<span class="p_add">+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);</span>
 	__raw_writel(ch, base + UART_TX * 4);
<span class="p_del">-	prom_putchar_wait(base + UART_LSR * 4, UART_LSR_THRE, UART_LSR_THRE);</span>
<span class="p_add">+	prom_putchar_wait(base + UART_LSR * 4, BOTH_EMPTY, BOTH_EMPTY);</span>
 }
 
 static void prom_putchar_ar933x(unsigned char ch)
<span class="p_header">diff --git a/arch/mips/boot/dts/brcm/bcm7435.dtsi b/arch/mips/boot/dts/brcm/bcm7435.dtsi</span>
<span class="p_header">index 8b9432c..27b2b8e 100644</span>
<span class="p_header">--- a/arch/mips/boot/dts/brcm/bcm7435.dtsi</span>
<span class="p_header">+++ b/arch/mips/boot/dts/brcm/bcm7435.dtsi</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
 		#address-cells = &lt;1&gt;;
 		#size-cells = &lt;0&gt;;
 
<span class="p_del">-		mips-hpt-frequency = &lt;163125000&gt;;</span>
<span class="p_add">+		mips-hpt-frequency = &lt;175625000&gt;;</span>
 
 		cpu@0 {
 			compatible = &quot;brcm,bmips5200&quot;;
<span class="p_header">diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">index 723229f..176de58 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -51,7 +51,6 @@</span> <span class="p_context"> extern void (*flush_cache_range)(struct vm_area_struct *vma,</span>
 	unsigned long start, unsigned long end);
 extern void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
 extern void __flush_dcache_page(struct page *page);
<span class="p_del">-extern void __flush_icache_page(struct vm_area_struct *vma, struct page *page);</span>
 
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
<span class="p_chunk">@@ -77,11 +76,6 @@</span> <span class="p_context"> static inline void flush_anon_page(struct vm_area_struct *vma,</span>
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
<span class="p_del">-	if (!cpu_has_ic_fills_f_dc &amp;&amp; (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp;</span>
<span class="p_del">-	    Page_dcache_dirty(page)) {</span>
<span class="p_del">-		__flush_icache_page(vma, page);</span>
<span class="p_del">-		ClearPageDcacheDirty(page);</span>
<span class="p_del">-	}</span>
 }
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index e8c8d9d..4afe1ec 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -782,7 +782,7 @@</span> <span class="p_context"> extern enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 
 uint32_t kvm_mips_read_count(struct kvm_vcpu *vcpu);
 void kvm_mips_write_count(struct kvm_vcpu *vcpu, uint32_t count);
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare);</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack);</span>
 void kvm_mips_init_count(struct kvm_vcpu *vcpu);
 int kvm_mips_set_count_ctl(struct kvm_vcpu *vcpu, s64 count_ctl);
 int kvm_mips_set_count_resume(struct kvm_vcpu *vcpu, s64 count_resume);
<span class="p_header">diff --git a/arch/mips/include/asm/msa.h b/arch/mips/include/asm/msa.h</span>
<span class="p_header">index af5638b..38bbeda 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/msa.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/msa.h</span>
<span class="p_chunk">@@ -67,6 +67,19 @@</span> <span class="p_context"> static inline void restore_msa(struct task_struct *t)</span>
 		_restore_msa(t);
 }
 
<span class="p_add">+static inline void init_msa_upper(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check cpu_has_msa only if it&#39;s a constant. This will allow the</span>
<span class="p_add">+	 * compiler to optimise out code for CPUs without MSA without adding</span>
<span class="p_add">+	 * an extra redundant check for CPUs with MSA.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__builtin_constant_p(cpu_has_msa) &amp;&amp; !cpu_has_msa)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	_init_msa_upper();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef TOOLCHAIN_SUPPORTS_MSA
 
 #define __BUILD_MSA_CTL_REG(name, cs)				\
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index 6bc427f..29a9de2 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -127,10 +127,14 @@</span> <span class="p_context"> do {									\</span>
 	}								\
 } while(0)
 
<span class="p_add">+static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			      pte_t *ptep, pte_t pteval);</span>
<span class="p_add">+</span>
 #if defined(CONFIG_PHYS_ADDR_T_64BIT) &amp;&amp; defined(CONFIG_CPU_MIPS32)
 
 #define pte_none(pte)		(!(((pte).pte_high) &amp; ~_PAGE_GLOBAL))
 #define pte_present(pte)	((pte).pte_low &amp; _PAGE_PRESENT)
<span class="p_add">+#define pte_no_exec(pte)	((pte).pte_low &amp; _PAGE_NO_EXEC)</span>
 
 static inline void set_pte(pte_t *ptep, pte_t pte)
 {
<span class="p_chunk">@@ -148,7 +152,6 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pte)</span>
 			buddy-&gt;pte_high |= _PAGE_GLOBAL;
 	}
 }
<span class="p_del">-#define set_pte_at(mm, addr, ptep, pteval) set_pte(ptep, pteval)</span>
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
<span class="p_chunk">@@ -166,6 +169,7 @@</span> <span class="p_context"> static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *pt</span>
 
 #define pte_none(pte)		(!(pte_val(pte) &amp; ~_PAGE_GLOBAL))
 #define pte_present(pte)	(pte_val(pte) &amp; _PAGE_PRESENT)
<span class="p_add">+#define pte_no_exec(pte)	(pte_val(pte) &amp; _PAGE_NO_EXEC)</span>
 
 /*
  * Certain architectures need to do special things when pte&#39;s
<span class="p_chunk">@@ -218,7 +222,6 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 	}
 #endif
 }
<span class="p_del">-#define set_pte_at(mm, addr, ptep, pteval) set_pte(ptep, pteval)</span>
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
<span class="p_chunk">@@ -234,6 +237,22 @@</span> <span class="p_context"> static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *pt</span>
 }
 #endif
 
<span class="p_add">+static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			      pte_t *ptep, pte_t pteval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern void __update_cache(unsigned long address, pte_t pte);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pte_present(pteval))</span>
<span class="p_add">+		goto cache_sync_done;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pte_present(*ptep) &amp;&amp; (pte_pfn(*ptep) == pte_pfn(pteval)))</span>
<span class="p_add">+		goto cache_sync_done;</span>
<span class="p_add">+</span>
<span class="p_add">+	__update_cache(addr, pteval);</span>
<span class="p_add">+cache_sync_done:</span>
<span class="p_add">+	set_pte(ptep, pteval);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * (pmds are folded into puds so this doesn&#39;t get actually called,
  * but the define is needed for a generic inline function.)
<span class="p_chunk">@@ -428,15 +447,12 @@</span> <span class="p_context"> static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)</span>
 
 extern void __update_tlb(struct vm_area_struct *vma, unsigned long address,
 	pte_t pte);
<span class="p_del">-extern void __update_cache(struct vm_area_struct *vma, unsigned long address,</span>
<span class="p_del">-	pte_t pte);</span>
 
 static inline void update_mmu_cache(struct vm_area_struct *vma,
 	unsigned long address, pte_t *ptep)
 {
 	pte_t pte = *ptep;
 	__update_tlb(vma, address, pte);
<span class="p_del">-	__update_cache(vma, address, pte);</span>
 }
 
 static inline void update_mmu_cache_pmd(struct vm_area_struct *vma,
<span class="p_header">diff --git a/arch/mips/include/uapi/asm/siginfo.h b/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_header">index 2cb7fde..e2b5337 100644</span>
<span class="p_header">--- a/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/mips/include/uapi/asm/siginfo.h</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"></span>
 
 #define __ARCH_SIGSYS
 
<span class="p_del">-#include &lt;uapi/asm-generic/siginfo.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/siginfo.h&gt;</span>
 
 /* We can&#39;t use generic siginfo_t, because our si_code and si_errno are swapped */
 typedef struct siginfo {
<span class="p_chunk">@@ -42,13 +42,13 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 
 		/* kill() */
 		struct {
<span class="p_del">-			pid_t _pid;		/* sender&#39;s pid */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* sender&#39;s pid */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 		} _kill;
 
 		/* POSIX.1b timers */
 		struct {
<span class="p_del">-			timer_t _tid;		/* timer id */</span>
<span class="p_add">+			__kernel_timer_t _tid;	/* timer id */</span>
 			int _overrun;		/* overrun count */
 			char _pad[sizeof( __ARCH_SI_UID_T) - sizeof(int)];
 			sigval_t _sigval;	/* same as below */
<span class="p_chunk">@@ -57,26 +57,26 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 
 		/* POSIX.1b signals */
 		struct {
<span class="p_del">-			pid_t _pid;		/* sender&#39;s pid */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* sender&#39;s pid */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 			sigval_t _sigval;
 		} _rt;
 
 		/* SIGCHLD */
 		struct {
<span class="p_del">-			pid_t _pid;		/* which child */</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* which child */</span>
 			__ARCH_SI_UID_T _uid;	/* sender&#39;s uid */
 			int _status;		/* exit code */
<span class="p_del">-			clock_t _utime;</span>
<span class="p_del">-			clock_t _stime;</span>
<span class="p_add">+			__kernel_clock_t _utime;</span>
<span class="p_add">+			__kernel_clock_t _stime;</span>
 		} _sigchld;
 
 		/* IRIX SIGCHLD */
 		struct {
<span class="p_del">-			pid_t _pid;		/* which child */</span>
<span class="p_del">-			clock_t _utime;</span>
<span class="p_add">+			__kernel_pid_t _pid;	/* which child */</span>
<span class="p_add">+			__kernel_clock_t _utime;</span>
 			int _status;		/* exit code */
<span class="p_del">-			clock_t _stime;</span>
<span class="p_add">+			__kernel_clock_t _stime;</span>
 		} _irix_sigchld;
 
 		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
<span class="p_chunk">@@ -118,6 +118,4 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 #define SI_TIMER __SI_CODE(__SI_TIMER, -3) /* sent by timer expiration */
 #define SI_MESGQ __SI_CODE(__SI_MESGQ, -4) /* sent by real time mesq state change */
 
<span class="p_del">-#include &lt;asm-generic/siginfo.h&gt;</span>
<span class="p_del">-</span>
 #endif /* _UAPI_ASM_SIGINFO_H */
<span class="p_header">diff --git a/arch/mips/kernel/bmips_vec.S b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">index 8649507..d9495f3 100644</span>
<span class="p_header">--- a/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">+++ b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_chunk">@@ -93,7 +93,8 @@</span> <span class="p_context"> NESTED(bmips_reset_nmi_vec, PT_SIZE, sp)</span>
 #if defined(CONFIG_CPU_BMIPS5000)
 	mfc0	k0, CP0_PRID
 	li	k1, PRID_IMP_BMIPS5000
<span class="p_del">-	andi	k0, 0xff00</span>
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
<span class="p_add">+	andi	k0, PRID_IMP_BMIPS5000</span>
 	bne	k0, k1, 1f
 
 	/* if we&#39;re not on core 0, this must be the SMP boot signal */
<span class="p_chunk">@@ -166,10 +167,12 @@</span> <span class="p_context"> bmips_smp_entry:</span>
 2:
 #endif /* CONFIG_CPU_BMIPS4350 || CONFIG_CPU_BMIPS4380 */
 #if defined(CONFIG_CPU_BMIPS5000)
<span class="p_del">-	/* set exception vector base */</span>
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
 	li	k1, PRID_IMP_BMIPS5000
<span class="p_add">+	andi	k0, PRID_IMP_BMIPS5000</span>
 	bne	k0, k1, 3f
 
<span class="p_add">+	/* set exception vector base */</span>
 	la	k0, ebase
 	lw	k0, 0(k0)
 	mtc0	k0, $15, 1
<span class="p_chunk">@@ -263,6 +266,8 @@</span> <span class="p_context"> LEAF(bmips_enable_xks01)</span>
 #endif /* CONFIG_CPU_BMIPS4380 */
 #if defined(CONFIG_CPU_BMIPS5000)
 	li	t1, PRID_IMP_BMIPS5000
<span class="p_add">+	/* mask with PRID_IMP_BMIPS5000 to cover both variants */</span>
<span class="p_add">+	andi	t2, PRID_IMP_BMIPS5000</span>
 	bne	t2, t1, 2f
 
 	mfc0	t0, $22, 5
<span class="p_header">diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c</span>
<span class="p_header">index d8f9b35..ceca6cc 100644</span>
<span class="p_header">--- a/arch/mips/kernel/branch.c</span>
<span class="p_header">+++ b/arch/mips/kernel/branch.c</span>
<span class="p_chunk">@@ -688,21 +688,9 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 			}
 			lose_fpu(1);    /* Save FPU state for the emulator. */
 			reg = insn.i_format.rt;
<span class="p_del">-			bit = 0;</span>
<span class="p_del">-			switch (insn.i_format.rs) {</span>
<span class="p_del">-			case bc1eqz_op:</span>
<span class="p_del">-				/* Test bit 0 */</span>
<span class="p_del">-				if (get_fpr32(&amp;current-&gt;thread.fpu.fpr[reg], 0)</span>
<span class="p_del">-				    &amp; 0x1)</span>
<span class="p_del">-					bit = 1;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case bc1nez_op:</span>
<span class="p_del">-				/* Test bit 0 */</span>
<span class="p_del">-				if (!(get_fpr32(&amp;current-&gt;thread.fpu.fpr[reg], 0)</span>
<span class="p_del">-				      &amp; 0x1))</span>
<span class="p_del">-					bit = 1;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			bit = get_fpr32(&amp;current-&gt;thread.fpu.fpr[reg], 0) &amp; 0x1;</span>
<span class="p_add">+			if (insn.i_format.rs == bc1eqz_op)</span>
<span class="p_add">+				bit = !bit;</span>
 			own_fpu(1);
 			if (bit)
 				epc = epc + 4 +
<span class="p_header">diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c</span>
<span class="p_header">index dbe0792..cbd4c43 100644</span>
<span class="p_header">--- a/arch/mips/kernel/cpu-probe.c</span>
<span class="p_header">+++ b/arch/mips/kernel/cpu-probe.c</span>
<span class="p_chunk">@@ -1248,7 +1248,10 @@</span> <span class="p_context"> static inline void cpu_probe_broadcom(struct cpuinfo_mips *c, unsigned int cpu)</span>
 	case PRID_IMP_BMIPS5000:
 	case PRID_IMP_BMIPS5200:
 		c-&gt;cputype = CPU_BMIPS5000;
<span class="p_del">-		__cpu_name[cpu] = &quot;Broadcom BMIPS5000&quot;;</span>
<span class="p_add">+		if ((c-&gt;processor_id &amp; PRID_IMP_MASK) == PRID_IMP_BMIPS5200)</span>
<span class="p_add">+			__cpu_name[cpu] = &quot;Broadcom BMIPS5200&quot;;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__cpu_name[cpu] = &quot;Broadcom BMIPS5000&quot;;</span>
 		set_elf_platform(cpu, &quot;bmips5000&quot;);
 		c-&gt;options |= MIPS_CPU_ULRI;
 		break;
<span class="p_header">diff --git a/arch/mips/kernel/mips-r2-to-r6-emul.c b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">index f2977f0..e19fa36 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/inst.h&gt;
 #include &lt;asm/mips-r2-to-r6-emul.h&gt;
 #include &lt;asm/local.h&gt;
<span class="p_add">+#include &lt;asm/mipsregs.h&gt;</span>
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_chunk">@@ -1250,10 +1251,10 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	10b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section	__ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1325,10 +1326,10 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	10b\n&quot;
 			&quot;       .previous\n&quot;
 			&quot;	.section	__ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1396,10 +1397,10 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	9b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1466,10 +1467,10 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	9b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1581,14 +1582,14 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	9b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	5b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	6b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	7b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	0b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 5b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 6b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 7b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 0b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1700,14 +1701,14 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j      9b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word  1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  4b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  5b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  6b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  7b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word  0b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 5b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 6b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 7b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 0b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set    pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1819,14 +1820,14 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;	j	9b\n&quot;
 			&quot;	.previous\n&quot;
 			&quot;	.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;	.word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	4b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	5b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	6b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	7b,8b\n&quot;</span>
<span class="p_del">-			&quot;	.word	0b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 5b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 6b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 7b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 0b,8b\n&quot;</span>
 			&quot;	.previous\n&quot;
 			&quot;	.set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1937,14 +1938,14 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;       j	9b\n&quot;
 			&quot;       .previous\n&quot;
 			&quot;       .section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;       .word	1b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	2b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	3b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	4b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	5b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	6b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	7b,8b\n&quot;</span>
<span class="p_del">-			&quot;       .word	0b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 2b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 3b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 4b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 5b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 6b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 7b,8b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 0b,8b\n&quot;</span>
 			&quot;       .previous\n&quot;
 			&quot;       .set	pop\n&quot;
 			: &quot;+&amp;r&quot;(rt), &quot;=&amp;r&quot;(rs),
<span class="p_chunk">@@ -1999,7 +2000,7 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;j	2b\n&quot;
 			&quot;.previous\n&quot;
 			&quot;.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;.word  1b, 3b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,3b\n&quot;</span>
 			&quot;.previous\n&quot;
 			: &quot;=&amp;r&quot;(res), &quot;+&amp;r&quot;(err)
 			: &quot;r&quot;(vaddr), &quot;i&quot;(SIGSEGV)
<span class="p_chunk">@@ -2057,7 +2058,7 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;j	2b\n&quot;
 			&quot;.previous\n&quot;
 			&quot;.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;.word	1b, 3b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,3b\n&quot;</span>
 			&quot;.previous\n&quot;
 			: &quot;+&amp;r&quot;(res), &quot;+&amp;r&quot;(err)
 			: &quot;r&quot;(vaddr), &quot;i&quot;(SIGSEGV));
<span class="p_chunk">@@ -2118,7 +2119,7 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;j	2b\n&quot;
 			&quot;.previous\n&quot;
 			&quot;.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;.word  1b, 3b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,3b\n&quot;</span>
 			&quot;.previous\n&quot;
 			: &quot;=&amp;r&quot;(res), &quot;+&amp;r&quot;(err)
 			: &quot;r&quot;(vaddr), &quot;i&quot;(SIGSEGV)
<span class="p_chunk">@@ -2181,7 +2182,7 @@</span> <span class="p_context"> fpu_emul:</span>
 			&quot;j	2b\n&quot;
 			&quot;.previous\n&quot;
 			&quot;.section        __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-			&quot;.word	1b, 3b\n&quot;</span>
<span class="p_add">+			STR(PTR) &quot; 1b,3b\n&quot;</span>
 			&quot;.previous\n&quot;
 			: &quot;+&amp;r&quot;(res), &quot;+&amp;r&quot;(err)
 			: &quot;r&quot;(vaddr), &quot;i&quot;(SIGSEGV));
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index f2975d4..ac84ac8 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 		    *sp + sizeof(*regs) &lt;= stack_page + THREAD_SIZE - 32) {
 			regs = (struct pt_regs *)*sp;
 			pc = regs-&gt;cp0_epc;
<span class="p_del">-			if (__kernel_text_address(pc)) {</span>
<span class="p_add">+			if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
 				*sp = regs-&gt;regs[29];
 				*ra = regs-&gt;regs[31];
 				return pc;
<span class="p_chunk">@@ -582,11 +582,19 @@</span> <span class="p_context"> int mips_get_process_fp_mode(struct task_struct *task)</span>
 	return value;
 }
 
<span class="p_add">+static void prepare_for_fp_mode_switch(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;mm == mm)</span>
<span class="p_add">+		lose_fpu(1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 {
 	const unsigned int known_bits = PR_FP_MODE_FR | PR_FP_MODE_FRE;
<span class="p_del">-	unsigned long switch_count;</span>
 	struct task_struct *t;
<span class="p_add">+	int max_users;</span>
 
 	/* Check the value is valid */
 	if (value &amp; ~known_bits)
<span class="p_chunk">@@ -603,6 +611,9 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 	if (!(value &amp; PR_FP_MODE_FR) &amp;&amp; cpu_has_fpu &amp;&amp; cpu_has_mips_r6)
 		return -EOPNOTSUPP;
 
<span class="p_add">+	/* Proceed with the mode switch */</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
 	/* Save FP &amp; vector context, then disable FPU &amp; MSA */
 	if (task-&gt;signal == current-&gt;signal)
 		lose_fpu(1);
<span class="p_chunk">@@ -612,31 +623,17 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 	smp_mb__after_atomic();
 
 	/*
<span class="p_del">-	 * If there are multiple online CPUs then wait until all threads whose</span>
<span class="p_del">-	 * FP mode is about to change have been context switched. This approach</span>
<span class="p_del">-	 * allows us to only worry about whether an FP mode switch is in</span>
<span class="p_del">-	 * progress when FP is first used in a tasks time slice. Pretty much all</span>
<span class="p_del">-	 * of the mode switch overhead can thus be confined to cases where mode</span>
<span class="p_del">-	 * switches are actually occuring. That is, to here. However for the</span>
<span class="p_del">-	 * thread performing the mode switch it may take a while...</span>
<span class="p_add">+	 * If there are multiple online CPUs then force any which are running</span>
<span class="p_add">+	 * threads in this process to lose their FPU context, which they can&#39;t</span>
<span class="p_add">+	 * regain until fp_mode_switching is cleared later.</span>
 	 */
 	if (num_online_cpus() &gt; 1) {
<span class="p_del">-		spin_lock_irq(&amp;task-&gt;sighand-&gt;siglock);</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_thread(task, t) {</span>
<span class="p_del">-			if (t == current)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			switch_count = t-&gt;nvcsw + t-&gt;nivcsw;</span>
<span class="p_add">+		/* No need to send an IPI for the local CPU */</span>
<span class="p_add">+		max_users = (task-&gt;mm == current-&gt;mm) ? 1 : 0;</span>
 
<span class="p_del">-			do {</span>
<span class="p_del">-				spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);</span>
<span class="p_del">-				cond_resched();</span>
<span class="p_del">-				spin_lock_irq(&amp;task-&gt;sighand-&gt;siglock);</span>
<span class="p_del">-			} while ((t-&gt;nvcsw + t-&gt;nivcsw) == switch_count);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);</span>
<span class="p_add">+		if (atomic_read(&amp;current-&gt;mm-&gt;mm_users) &gt; max_users)</span>
<span class="p_add">+			smp_call_function(prepare_for_fp_mode_switch,</span>
<span class="p_add">+					  (void *)current-&gt;mm, 1);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -661,6 +658,7 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 
 	/* Allow threads to use FP again */
 	atomic_set(&amp;task-&gt;mm-&gt;context.fp_mode_switching, 0);
<span class="p_add">+	preempt_enable();</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c</span>
<span class="p_header">index e933a30..f7968b5 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace.c</span>
<span class="p_chunk">@@ -56,8 +56,7 @@</span> <span class="p_context"> static void init_fp_ctx(struct task_struct *target)</span>
 	/* Begin with data registers set to all 1s... */
 	memset(&amp;target-&gt;thread.fpu.fpr, ~0, sizeof(target-&gt;thread.fpu.fpr));
 
<span class="p_del">-	/* ...and FCSR zeroed */</span>
<span class="p_del">-	target-&gt;thread.fpu.fcr31 = 0;</span>
<span class="p_add">+	/* FCSR has been preset by `mips_set_personality_nan&#39;.  */</span>
 
 	/*
 	 * Record that the target has &quot;used&quot; math, such that the context
<span class="p_chunk">@@ -79,6 +78,22 @@</span> <span class="p_context"> void ptrace_disable(struct task_struct *child)</span>
 }
 
 /*
<span class="p_add">+ * Poke at FCSR according to its mask.  Don&#39;t set the cause bits as</span>
<span class="p_add">+ * this is currently not handled correctly in FP context restoration</span>
<span class="p_add">+ * and will cause an oops if a corresponding enable bit is set.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void ptrace_setfcr31(struct task_struct *child, u32 value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 fcr31;</span>
<span class="p_add">+	u32 mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	value &amp;= ~FPU_CSR_ALL_X;</span>
<span class="p_add">+	fcr31 = child-&gt;thread.fpu.fcr31;</span>
<span class="p_add">+	mask = boot_cpu_data.fpu_msk31;</span>
<span class="p_add">+	child-&gt;thread.fpu.fcr31 = (value &amp; ~mask) | (fcr31 &amp; mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Read a general register set.	 We always use the 64-bit format, even
  * for 32-bit kernels and for 32-bit processes on a 64-bit kernel.
  * Registers are sign extended to fill the available space.
<span class="p_chunk">@@ -158,9 +173,7 @@</span> <span class="p_context"> int ptrace_setfpregs(struct task_struct *child, __u32 __user *data)</span>
 {
 	union fpureg *fregs;
 	u64 fpr_val;
<span class="p_del">-	u32 fcr31;</span>
 	u32 value;
<span class="p_del">-	u32 mask;</span>
 	int i;
 
 	if (!access_ok(VERIFY_READ, data, 33 * 8))
<span class="p_chunk">@@ -175,9 +188,7 @@</span> <span class="p_context"> int ptrace_setfpregs(struct task_struct *child, __u32 __user *data)</span>
 	}
 
 	__get_user(value, data + 64);
<span class="p_del">-	fcr31 = child-&gt;thread.fpu.fcr31;</span>
<span class="p_del">-	mask = boot_cpu_data.fpu_msk31;</span>
<span class="p_del">-	child-&gt;thread.fpu.fcr31 = (value &amp; ~mask) | (fcr31 &amp; mask);</span>
<span class="p_add">+	ptrace_setfcr31(child, value);</span>
 
 	/* FIR may not be written.  */
 
<span class="p_chunk">@@ -720,7 +731,7 @@</span> <span class="p_context"> long arch_ptrace(struct task_struct *child, long request,</span>
 			break;
 #endif
 		case FPC_CSR:
<span class="p_del">-			child-&gt;thread.fpu.fcr31 = data &amp; ~FPU_CSR_ALL_X;</span>
<span class="p_add">+			ptrace_setfcr31(child, data);</span>
 			break;
 		case DSP_BASE ... DSP_BASE + 5: {
 			dspreg_t *dregs;
<span class="p_header">diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c</span>
<span class="p_header">index 4ceac5c..c737bc1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/setup.c</span>
<span class="p_header">+++ b/arch/mips/kernel/setup.c</span>
<span class="p_chunk">@@ -691,6 +691,9 @@</span> <span class="p_context"> static void __init arch_mem_init(char **cmdline_p)</span>
 	for_each_memblock(reserved, reg)
 		if (reg-&gt;size != 0)
 			reserve_bootmem(reg-&gt;base, reg-&gt;size, BOOTMEM_DEFAULT);
<span class="p_add">+</span>
<span class="p_add">+	reserve_bootmem_region(__pa_symbol(&amp;__nosave_begin),</span>
<span class="p_add">+			__pa_symbol(&amp;__nosave_end)); /* Reserve for hibernation */</span>
 }
 
 static void __init resource_init(void)
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index ef1e9d3..4f1d297 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static void show_backtrace(struct task_struct *task, const struct pt_regs *regs)</span>
 	if (!task)
 		task = current;
 
<span class="p_del">-	if (raw_show_trace || !__kernel_text_address(pc)) {</span>
<span class="p_add">+	if (raw_show_trace || user_mode(regs) || !__kernel_text_address(pc)) {</span>
 		show_raw_backtrace(sp);
 		return;
 	}
<span class="p_chunk">@@ -1229,7 +1229,7 @@</span> <span class="p_context"> static int enable_restore_fp_context(int msa)</span>
 		err = init_fpu();
 		if (msa &amp;&amp; !err) {
 			enable_msa();
<span class="p_del">-			_init_msa_upper();</span>
<span class="p_add">+			init_msa_upper();</span>
 			set_thread_flag(TIF_USEDMSA);
 			set_thread_flag(TIF_MSA_CTX_LIVE);
 		}
<span class="p_chunk">@@ -1292,7 +1292,7 @@</span> <span class="p_context"> static int enable_restore_fp_context(int msa)</span>
 	 */
 	prior_msa = test_and_set_thread_flag(TIF_MSA_CTX_LIVE);
 	if (!prior_msa &amp;&amp; was_fpu_owner) {
<span class="p_del">-		_init_msa_upper();</span>
<span class="p_add">+		init_msa_upper();</span>
 
 		goto out;
 	}
<span class="p_chunk">@@ -1309,7 +1309,7 @@</span> <span class="p_context"> static int enable_restore_fp_context(int msa)</span>
 		 * of each vector register such that it cannot see data left
 		 * behind by another task.
 		 */
<span class="p_del">-		_init_msa_upper();</span>
<span class="p_add">+		init_msa_upper();</span>
 	} else {
 		/* We need to restore the vector context. */
 		restore_msa(current);
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 41b1b09..dc10c77 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -302,12 +302,31 @@</span> <span class="p_context"> static inline ktime_t kvm_mips_count_time(struct kvm_vcpu *vcpu)</span>
  */
 static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)
 {
<span class="p_del">-	ktime_t expires;</span>
<span class="p_add">+	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;</span>
<span class="p_add">+	ktime_t expires, threshold;</span>
<span class="p_add">+	uint32_t count, compare;</span>
 	int running;
 
<span class="p_del">-	/* Is the hrtimer pending? */</span>
<span class="p_add">+	/* Calculate the biased and scaled guest CP0_Count */</span>
<span class="p_add">+	count = vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find whether CP0_Count has reached the closest timer interrupt. If</span>
<span class="p_add">+	 * not, we shouldn&#39;t inject it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((int32_t)(count - compare) &lt; 0)</span>
<span class="p_add">+		return count;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The CP0_Count we&#39;re going to return has already reached the closest</span>
<span class="p_add">+	 * timer interrupt. Quickly check if it really is a new interrupt by</span>
<span class="p_add">+	 * looking at whether the interval until the hrtimer expiry time is</span>
<span class="p_add">+	 * less than 1/4 of the timer period.</span>
<span class="p_add">+	 */</span>
 	expires = hrtimer_get_expires(&amp;vcpu-&gt;arch.comparecount_timer);
<span class="p_del">-	if (ktime_compare(now, expires) &gt;= 0) {</span>
<span class="p_add">+	threshold = ktime_add_ns(now, vcpu-&gt;arch.count_period / 4);</span>
<span class="p_add">+	if (ktime_before(expires, threshold)) {</span>
 		/*
 		 * Cancel it while we handle it so there&#39;s no chance of
 		 * interference with the timeout handler.
<span class="p_chunk">@@ -329,8 +348,7 @@</span> <span class="p_context"> static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)</span>
 		}
 	}
 
<span class="p_del">-	/* Return the biased and scaled guest CP0_Count */</span>
<span class="p_del">-	return vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	return count;</span>
 }
 
 /**
<span class="p_chunk">@@ -420,32 +438,6 @@</span> <span class="p_context"> static void kvm_mips_resume_hrtimer(struct kvm_vcpu *vcpu,</span>
 }
 
 /**
<span class="p_del">- * kvm_mips_update_hrtimer() - Update next expiry time of hrtimer.</span>
<span class="p_del">- * @vcpu:	Virtual CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Recalculates and updates the expiry time of the hrtimer. This can be used</span>
<span class="p_del">- * after timer parameters have been altered which do not depend on the time that</span>
<span class="p_del">- * the change occurs (in those cases kvm_mips_freeze_hrtimer() and</span>
<span class="p_del">- * kvm_mips_resume_hrtimer() are used directly).</span>
<span class="p_del">- *</span>
<span class="p_del">- * It is guaranteed that no timer interrupts will be lost in the process.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Assumes !kvm_mips_count_disabled(@vcpu) (guest CP0_Count timer is running).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void kvm_mips_update_hrtimer(struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ktime_t now;</span>
<span class="p_del">-	uint32_t count;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * freeze_hrtimer takes care of a timer interrupts &lt;= count, and</span>
<span class="p_del">-	 * resume_hrtimer the hrtimer takes care of a timer interrupts &gt; count.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_del">-	kvm_mips_resume_hrtimer(vcpu, now, count);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * kvm_mips_write_count() - Modify the count and update timer.
  * @vcpu:	Virtual CPU.
  * @count:	Guest CP0_Count value to set.
<span class="p_chunk">@@ -540,23 +532,42 @@</span> <span class="p_context"> int kvm_mips_set_count_hz(struct kvm_vcpu *vcpu, s64 count_hz)</span>
  * kvm_mips_write_compare() - Modify compare and update timer.
  * @vcpu:	Virtual CPU.
  * @compare:	New CP0_Compare value.
<span class="p_add">+ * @ack:	Whether to acknowledge timer interrupt.</span>
  *
  * Update CP0_Compare to a new value and update the timeout.
<span class="p_add">+ * If @ack, atomically acknowledge any pending timer interrupt, otherwise ensure</span>
<span class="p_add">+ * any pending timer interrupt is preserved.</span>
  */
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare)</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack)</span>
 {
 	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;
<span class="p_add">+	int dc;</span>
<span class="p_add">+	u32 old_compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+	ktime_t now;</span>
<span class="p_add">+	uint32_t count;</span>
 
 	/* if unchanged, must just be an ack */
<span class="p_del">-	if (kvm_read_c0_guest_compare(cop0) == compare)</span>
<span class="p_add">+	if (old_compare == compare) {</span>
<span class="p_add">+		if (!ack)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
<span class="p_add">+		kvm_write_c0_guest_compare(cop0, compare);</span>
 		return;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* freeze_hrtimer() takes care of timer interrupts &lt;= count */</span>
<span class="p_add">+	dc = kvm_mips_count_disabled(vcpu);</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack)</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 
<span class="p_del">-	/* Update compare */</span>
 	kvm_write_c0_guest_compare(cop0, compare);
 
<span class="p_del">-	/* Update timeout if count enabled */</span>
<span class="p_del">-	if (!kvm_mips_count_disabled(vcpu))</span>
<span class="p_del">-		kvm_mips_update_hrtimer(vcpu);</span>
<span class="p_add">+	/* resume_hrtimer() takes care of timer interrupts &gt; count */</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		kvm_mips_resume_hrtimer(vcpu, now, count);</span>
 }
 
 /**
<span class="p_chunk">@@ -1095,9 +1106,9 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 
 				/* If we are writing to COMPARE */
 				/* Clear pending timer interrupt, if any */
<span class="p_del">-				kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 				kvm_mips_write_compare(vcpu,
<span class="p_del">-						       vcpu-&gt;arch.gprs[rt]);</span>
<span class="p_add">+						       vcpu-&gt;arch.gprs[rt],</span>
<span class="p_add">+						       true);</span>
 			} else if ((rd == MIPS_CP0_STATUS) &amp;&amp; (sel == 0)) {
 				unsigned int old_val, val, change;
 
<span class="p_header">diff --git a/arch/mips/kvm/trap_emul.c b/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">index d836ed5..307cc4c 100644</span>
<span class="p_header">--- a/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/trap_emul.c</span>
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static int kvm_trap_emul_set_one_reg(struct kvm_vcpu *vcpu,</span>
 		kvm_mips_write_count(vcpu, v);
 		break;
 	case KVM_REG_MIPS_CP0_COMPARE:
<span class="p_del">-		kvm_mips_write_compare(vcpu, v);</span>
<span class="p_add">+		kvm_mips_write_compare(vcpu, v, false);</span>
 		break;
 	case KVM_REG_MIPS_CP0_CAUSE:
 		/*
<span class="p_header">diff --git a/arch/mips/lib/ashldi3.c b/arch/mips/lib/ashldi3.c</span>
<span class="p_header">index beb80f31..927dc94 100644</span>
<span class="p_header">--- a/arch/mips/lib/ashldi3.c</span>
<span class="p_header">+++ b/arch/mips/lib/ashldi3.c</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 
 #include &quot;libgcc.h&quot;
 
<span class="p_del">-long long __ashldi3(long long u, word_type b)</span>
<span class="p_add">+long long notrace __ashldi3(long long u, word_type b)</span>
 {
 	DWunion uu, w;
 	word_type bm;
<span class="p_header">diff --git a/arch/mips/lib/ashrdi3.c b/arch/mips/lib/ashrdi3.c</span>
<span class="p_header">index c884a91..9fdf1a5 100644</span>
<span class="p_header">--- a/arch/mips/lib/ashrdi3.c</span>
<span class="p_header">+++ b/arch/mips/lib/ashrdi3.c</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 
 #include &quot;libgcc.h&quot;
 
<span class="p_del">-long long __ashrdi3(long long u, word_type b)</span>
<span class="p_add">+long long notrace __ashrdi3(long long u, word_type b)</span>
 {
 	DWunion uu, w;
 	word_type bm;
<span class="p_header">diff --git a/arch/mips/lib/cmpdi2.c b/arch/mips/lib/cmpdi2.c</span>
<span class="p_header">index 8c13064..06857da 100644</span>
<span class="p_header">--- a/arch/mips/lib/cmpdi2.c</span>
<span class="p_header">+++ b/arch/mips/lib/cmpdi2.c</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 
 #include &quot;libgcc.h&quot;
 
<span class="p_del">-word_type __cmpdi2(long long a, long long b)</span>
<span class="p_add">+word_type notrace __cmpdi2(long long a, long long b)</span>
 {
 	const DWunion au = {
 		.ll = a
<span class="p_header">diff --git a/arch/mips/lib/lshrdi3.c b/arch/mips/lib/lshrdi3.c</span>
<span class="p_header">index dcf8d68..3645474 100644</span>
<span class="p_header">--- a/arch/mips/lib/lshrdi3.c</span>
<span class="p_header">+++ b/arch/mips/lib/lshrdi3.c</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 
 #include &quot;libgcc.h&quot;
 
<span class="p_del">-long long __lshrdi3(long long u, word_type b)</span>
<span class="p_add">+long long notrace __lshrdi3(long long u, word_type b)</span>
 {
 	DWunion uu, w;
 	word_type bm;
<span class="p_header">diff --git a/arch/mips/lib/ucmpdi2.c b/arch/mips/lib/ucmpdi2.c</span>
<span class="p_header">index bb4cb2f..bd599f5 100644</span>
<span class="p_header">--- a/arch/mips/lib/ucmpdi2.c</span>
<span class="p_header">+++ b/arch/mips/lib/ucmpdi2.c</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 
 #include &quot;libgcc.h&quot;
 
<span class="p_del">-word_type __ucmpdi2(unsigned long long a, unsigned long long b)</span>
<span class="p_add">+word_type notrace __ucmpdi2(unsigned long long a, unsigned long long b)</span>
 {
 	const DWunion au = {.ll = a};
 	const DWunion bu = {.ll = b};
<span class="p_header">diff --git a/arch/mips/loongson64/loongson-3/numa.c b/arch/mips/loongson64/loongson-3/numa.c</span>
<span class="p_header">index 6f9e010..282c5a8 100644</span>
<span class="p_header">--- a/arch/mips/loongson64/loongson-3/numa.c</span>
<span class="p_header">+++ b/arch/mips/loongson64/loongson-3/numa.c</span>
<span class="p_chunk">@@ -213,10 +213,10 @@</span> <span class="p_context"> static void __init node_mem_init(unsigned int node)</span>
 		BOOTMEM_DEFAULT);
 
 	if (node == 0 &amp;&amp; node_end_pfn(0) &gt;= (0xffffffff &gt;&gt; PAGE_SHIFT)) {
<span class="p_del">-		/* Reserve 0xff800000~0xffffffff for RS780E integrated GPU */</span>
<span class="p_add">+		/* Reserve 0xfe000000~0xffffffff for RS780E integrated GPU */</span>
 		reserve_bootmem_node(NODE_DATA(node),
<span class="p_del">-				(node_addrspace_offset | 0xff800000),</span>
<span class="p_del">-				8 &lt;&lt; 20, BOOTMEM_DEFAULT);</span>
<span class="p_add">+				(node_addrspace_offset | 0xfe000000),</span>
<span class="p_add">+				32 &lt;&lt; 20, BOOTMEM_DEFAULT);</span>
 	}
 
 	sparse_memory_present_with_active_regions(node);
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index f0f1b98..8d9133f 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -445,9 +445,11 @@</span> <span class="p_context"> static int isBranchInstr(struct pt_regs *regs, struct mm_decoded_insn dec_insn,</span>
 	case spec_op:
 		switch (insn.r_format.func) {
 		case jalr_op:
<span class="p_del">-			regs-&gt;regs[insn.r_format.rd] =</span>
<span class="p_del">-				regs-&gt;cp0_epc + dec_insn.pc_inc +</span>
<span class="p_del">-				dec_insn.next_pc_inc;</span>
<span class="p_add">+			if (insn.r_format.rd != 0) {</span>
<span class="p_add">+				regs-&gt;regs[insn.r_format.rd] =</span>
<span class="p_add">+					regs-&gt;cp0_epc + dec_insn.pc_inc +</span>
<span class="p_add">+					dec_insn.next_pc_inc;</span>
<span class="p_add">+			}</span>
 			/* Fall through */
 		case jr_op:
 			/* For R6, JR already emulated in jalr_op */
<span class="p_chunk">@@ -973,9 +975,10 @@</span> <span class="p_context"> static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 		struct mm_decoded_insn dec_insn, void *__user *fault_addr)
 {
 	unsigned long contpc = xcp-&gt;cp0_epc + dec_insn.pc_inc;
<span class="p_del">-	unsigned int cond, cbit;</span>
<span class="p_add">+	unsigned int cond, cbit, bit0;</span>
 	mips_instruction ir;
 	int likely, pc_inc;
<span class="p_add">+	union fpureg *fpr;</span>
 	u32 __user *wva;
 	u64 __user *dva;
 	u32 wval;
<span class="p_chunk">@@ -1187,14 +1190,14 @@</span> <span class="p_context"> emul:</span>
 				return SIGILL;
 
 			cond = likely = 0;
<span class="p_add">+			fpr = &amp;current-&gt;thread.fpu.fpr[MIPSInst_RT(ir)];</span>
<span class="p_add">+			bit0 = get_fpr32(fpr, 0) &amp; 0x1;</span>
 			switch (MIPSInst_RS(ir)) {
 			case bc1eqz_op:
<span class="p_del">-				if (get_fpr32(&amp;current-&gt;thread.fpu.fpr[MIPSInst_RT(ir)], 0) &amp; 0x1)</span>
<span class="p_del">-				    cond = 1;</span>
<span class="p_add">+				cond = bit0 == 0;</span>
 				break;
 			case bc1nez_op:
<span class="p_del">-				if (!(get_fpr32(&amp;current-&gt;thread.fpu.fpr[MIPSInst_RT(ir)], 0) &amp; 0x1))</span>
<span class="p_del">-				    cond = 1;</span>
<span class="p_add">+				cond = bit0 != 0;</span>
 				break;
 			}
 			goto branch_common;
<span class="p_header">diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c</span>
<span class="p_header">index fbea443..a50011a 100644</span>
<span class="p_header">--- a/arch/mips/mm/c-r4k.c</span>
<span class="p_header">+++ b/arch/mips/mm/c-r4k.c</span>
<span class="p_chunk">@@ -447,6 +447,11 @@</span> <span class="p_context"> static inline void local_r4k___flush_cache_all(void * args)</span>
 		r4k_blast_scache();
 		break;
 
<span class="p_add">+	case CPU_BMIPS5000:</span>
<span class="p_add">+		r4k_blast_scache();</span>
<span class="p_add">+		__sync();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	default:
 		r4k_blast_dcache();
 		r4k_blast_icache();
<span class="p_chunk">@@ -1305,6 +1310,12 @@</span> <span class="p_context"> static void probe_pcache(void)</span>
 		c-&gt;icache.flags |= MIPS_CACHE_IC_F_DC;
 		break;
 
<span class="p_add">+	case CPU_BMIPS5000:</span>
<span class="p_add">+		c-&gt;icache.flags |= MIPS_CACHE_IC_F_DC;</span>
<span class="p_add">+		/* Cache aliases are handled in hardware; allow HIGHMEM */</span>
<span class="p_add">+		c-&gt;dcache.flags &amp;= ~MIPS_CACHE_ALIASES;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	case CPU_LOONGSON2:
 		/*
 		 * LOONGSON2 has 4 way icache, but when using indexed cache op,
<span class="p_chunk">@@ -1742,8 +1753,6 @@</span> <span class="p_context"> void r4k_cache_init(void)</span>
 		flush_icache_range = (void *)b5k_instruction_hazard;
 		local_flush_icache_range = (void *)b5k_instruction_hazard;
 
<span class="p_del">-		/* Cache aliases are handled in hardware; allow HIGHMEM */</span>
<span class="p_del">-		current_cpu_data.dcache.flags &amp;= ~MIPS_CACHE_ALIASES;</span>
 
 		/* Optimization: an L2 flush implicitly flushes the L1 */
 		current_cpu_data.options |= MIPS_CPU_INCLUSIVE_CACHES;
<span class="p_header">diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c</span>
<span class="p_header">index aab218c..48e8172 100644</span>
<span class="p_header">--- a/arch/mips/mm/cache.c</span>
<span class="p_header">+++ b/arch/mips/mm/cache.c</span>
<span class="p_chunk">@@ -119,33 +119,28 @@</span> <span class="p_context"> void __flush_anon_page(struct page *page, unsigned long vmaddr)</span>
 
 EXPORT_SYMBOL(__flush_anon_page);
 
<span class="p_del">-void __flush_icache_page(struct vm_area_struct *vma, struct page *page)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (PageHighMem(page))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	addr = (unsigned long) page_address(page);</span>
<span class="p_del">-	flush_data_cache_page(addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(__flush_icache_page);</span>
<span class="p_del">-</span>
<span class="p_del">-void __update_cache(struct vm_area_struct *vma, unsigned long address,</span>
<span class="p_del">-	pte_t pte)</span>
<span class="p_add">+void __update_cache(unsigned long address, pte_t pte)</span>
 {
 	struct page *page;
 	unsigned long pfn, addr;
<span class="p_del">-	int exec = (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp; !cpu_has_ic_fills_f_dc;</span>
<span class="p_add">+	int exec = !pte_no_exec(pte) &amp;&amp; !cpu_has_ic_fills_f_dc;</span>
 
 	pfn = pte_pfn(pte);
 	if (unlikely(!pfn_valid(pfn)))
 		return;
 	page = pfn_to_page(pfn);
<span class="p_del">-	if (page_mapping(page) &amp;&amp; Page_dcache_dirty(page)) {</span>
<span class="p_del">-		addr = (unsigned long) page_address(page);</span>
<span class="p_add">+	if (Page_dcache_dirty(page)) {</span>
<span class="p_add">+		if (PageHighMem(page))</span>
<span class="p_add">+			addr = (unsigned long)kmap_atomic(page);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			addr = (unsigned long)page_address(page);</span>
<span class="p_add">+</span>
 		if (exec || pages_do_alias(addr, address &amp; PAGE_MASK))
 			flush_data_cache_page(addr);
<span class="p_add">+</span>
<span class="p_add">+		if (PageHighMem(page))</span>
<span class="p_add">+			__kunmap_atomic((void *)addr);</span>
<span class="p_add">+</span>
 		ClearPageDcacheDirty(page);
 	}
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">index 01c961d..1109964 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh.c</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"> void eeh_add_device_early(struct pci_dn *pdn)</span>
 	struct pci_controller *phb;
 	struct eeh_dev *edev = pdn_to_eeh_dev(pdn);
 
<span class="p_del">-	if (!edev || !eeh_enabled())</span>
<span class="p_add">+	if (!edev)</span>
 		return;
 
 	if (!eeh_has_flag(EEH_PROBE_MODE_DEVTREE))
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index afeb2bd..16f315f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -166,6 +166,16 @@</span> <span class="p_context"> static void *eeh_dev_save_state(void *data, void *userdata)</span>
 	if (!edev)
 		return NULL;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We cannot access the config space on some adapters.</span>
<span class="p_add">+	 * Otherwise, it will cause fenced PHB. We don&#39;t save</span>
<span class="p_add">+	 * the content in their config space and will restore</span>
<span class="p_add">+	 * from the initial config space saved when the EEH</span>
<span class="p_add">+	 * device is created.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (edev-&gt;pe &amp;&amp; (edev-&gt;pe-&gt;state &amp; EEH_PE_CFG_RESTRICTED))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	pdev = eeh_dev_to_pci_dev(edev);
 	if (!pdev)
 		return NULL;
<span class="p_chunk">@@ -305,6 +315,19 @@</span> <span class="p_context"> static void *eeh_dev_restore_state(void *data, void *userdata)</span>
 	if (!edev)
 		return NULL;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The content in the config space isn&#39;t saved because</span>
<span class="p_add">+	 * the blocked config space on some adapters. We have</span>
<span class="p_add">+	 * to restore the initial saved config space when the</span>
<span class="p_add">+	 * EEH device is created.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (edev-&gt;pe &amp;&amp; (edev-&gt;pe-&gt;state &amp; EEH_PE_CFG_RESTRICTED)) {</span>
<span class="p_add">+		if (list_is_last(&amp;edev-&gt;list, &amp;edev-&gt;pe-&gt;edevs))</span>
<span class="p_add">+			eeh_pe_restore_bars(edev-&gt;pe);</span>
<span class="p_add">+</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pdev = eeh_dev_to_pci_dev(edev);
 	if (!pdev)
 		return NULL;
<span class="p_chunk">@@ -502,9 +525,6 @@</span> <span class="p_context"> int eeh_pe_reset_and_recover(struct eeh_pe *pe)</span>
 	/* Save states */
 	eeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);
 
<span class="p_del">-	/* Report error */</span>
<span class="p_del">-	eeh_pe_dev_traverse(pe, eeh_report_error, &amp;result);</span>
<span class="p_del">-</span>
 	/* Issue reset */
 	ret = eeh_reset_pe(pe);
 	if (ret) {
<span class="p_header">diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">index 0a0399c2..b81ccc5 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_chunk">@@ -962,11 +962,6 @@</span> <span class="p_context"> hv_facility_unavailable_relon_trampoline:</span>
 #endif
 	STD_RELON_EXCEPTION_PSERIES(0x5700, 0x1700, altivec_assist)
 
<span class="p_del">-	/* Other future vectors */</span>
<span class="p_del">-	.align	7</span>
<span class="p_del">-	.globl	__end_interrupts</span>
<span class="p_del">-__end_interrupts:</span>
<span class="p_del">-</span>
 	.align	7
 system_call_entry:
 	b	system_call_common
<span class="p_chunk">@@ -1253,6 +1248,17 @@</span> <span class="p_context"> __end_handlers:</span>
 	STD_RELON_EXCEPTION_PSERIES_OOL(0xf60, facility_unavailable)
 	STD_RELON_EXCEPTION_HV_OOL(0xf80, hv_facility_unavailable)
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The __end_interrupts marker must be past the out-of-line (OOL)</span>
<span class="p_add">+	 * handlers, so that they are copied to real address 0x100 when running</span>
<span class="p_add">+	 * a relocatable kernel. This ensures they can be reached from the short</span>
<span class="p_add">+	 * trampoline handlers (like 0x4f00, 0x4f20, etc.) which branch</span>
<span class="p_add">+	 * directly, without using LOAD_HANDLER().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.align	7</span>
<span class="p_add">+	.globl	__end_interrupts</span>
<span class="p_add">+__end_interrupts:</span>
<span class="p_add">+</span>
 #if defined(CONFIG_PPC_PSERIES) || defined(CONFIG_PPC_POWERNV)
 /*
  * Data area reserved for FWNMI option.
<span class="p_header">diff --git a/arch/powerpc/lib/sstep.c b/arch/powerpc/lib/sstep.c</span>
<span class="p_header">index dc885b3..6d34310 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/sstep.c</span>
<span class="p_header">+++ b/arch/powerpc/lib/sstep.c</span>
<span class="p_chunk">@@ -1818,9 +1818,11 @@</span> <span class="p_context"> int __kprobes emulate_step(struct pt_regs *regs, unsigned int instr)</span>
 		case 4:
 			__get_user_asmx(val, op.ea, err, &quot;lwarx&quot;);
 			break;
<span class="p_add">+#ifdef __powerpc64__</span>
 		case 8:
 			__get_user_asmx(val, op.ea, err, &quot;ldarx&quot;);
 			break;
<span class="p_add">+#endif</span>
 		default:
 			return 0;
 		}
<span class="p_chunk">@@ -1841,9 +1843,11 @@</span> <span class="p_context"> int __kprobes emulate_step(struct pt_regs *regs, unsigned int instr)</span>
 		case 4:
 			__put_user_asmx(op.val, op.ea, err, &quot;stwcx.&quot;, cr);
 			break;
<span class="p_add">+#ifdef __powerpc64__</span>
 		case 8:
 			__put_user_asmx(op.val, op.ea, err, &quot;stdcx.&quot;, cr);
 			break;
<span class="p_add">+#endif</span>
 		default:
 			return 0;
 		}
<span class="p_header">diff --git a/arch/s390/mm/vmem.c b/arch/s390/mm/vmem.c</span>
<span class="p_header">index ef7d6c8..f354fd8 100644</span>
<span class="p_header">--- a/arch/s390/mm/vmem.c</span>
<span class="p_header">+++ b/arch/s390/mm/vmem.c</span>
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> void __init vmem_map_init(void)</span>
 	ro_end = (unsigned long)&amp;_eshared &amp; PAGE_MASK;
 	for_each_memblock(memory, reg) {
 		start = reg-&gt;base;
<span class="p_del">-		end = reg-&gt;base + reg-&gt;size - 1;</span>
<span class="p_add">+		end = reg-&gt;base + reg-&gt;size;</span>
 		if (start &gt;= ro_end || end &lt;= ro_start)
 			vmem_add_mem(start, end - start, 0);
 		else if (start &gt;= ro_start &amp;&amp; end &lt;= ro_end)
<span class="p_header">diff --git a/arch/x86/kvm/mtrr.c b/arch/x86/kvm/mtrr.c</span>
<span class="p_header">index 3f8c732..c146f3c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mtrr.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mtrr.c</span>
<span class="p_chunk">@@ -44,8 +44,6 @@</span> <span class="p_context"> static bool msr_mtrr_valid(unsigned msr)</span>
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
<span class="p_del">-	case 0x2f8:</span>
<span class="p_del">-		return true;</span>
 	}
 	return false;
 }
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index c832c7d..8f30efc 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -4795,8 +4795,8 @@</span> <span class="p_context"> static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)</span>
 		vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx-&gt;vpid);
 
 	cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;
<span class="p_del">-	vmx_set_cr0(vcpu, cr0); /* enter rmode */</span>
 	vmx-&gt;vcpu.arch.cr0 = cr0;
<span class="p_add">+	vmx_set_cr0(vcpu, cr0); /* enter rmode */</span>
 	vmx_set_cr4(vcpu, 0);
 	vmx_set_efer(vcpu, 0);
 	vmx_fpu_activate(vcpu);
<span class="p_header">diff --git a/arch/x86/pci/fixup.c b/arch/x86/pci/fixup.c</span>
<span class="p_header">index f16af96..156fbb6 100644</span>
<span class="p_header">--- a/arch/x86/pci/fixup.c</span>
<span class="p_header">+++ b/arch/x86/pci/fixup.c</span>
<span class="p_chunk">@@ -554,9 +554,16 @@</span> <span class="p_context"> static void twinhead_reserve_killing_zone(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Broadwell EP Home Agent BARs erroneously return non-zero values when read.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See http://www.intel.com/content/www/us/en/processors/xeon/xeon-e5-v4-spec-update.html</span>
<span class="p_add">+ * entry BDF2.</span>
<span class="p_add">+ */</span>
 static void pci_bdwep_bar(struct pci_dev *dev)
 {
 	dev-&gt;non_compliant_bars = 1;
 }
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6f60, pci_bdwep_bar);</span>
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_bdwep_bar);
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_bdwep_bar);
<span class="p_header">diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c</span>
<span class="p_header">index d22f4b5..6b8b107 100644</span>
<span class="p_header">--- a/arch/x86/pci/xen.c</span>
<span class="p_header">+++ b/arch/x86/pci/xen.c</span>
<span class="p_chunk">@@ -488,8 +488,11 @@</span> <span class="p_context"> int __init pci_xen_initial_domain(void)</span>
 #endif
 	__acpi_register_gsi = acpi_register_gsi_xen;
 	__acpi_unregister_gsi = NULL;
<span class="p_del">-	/* Pre-allocate legacy irqs */</span>
<span class="p_del">-	for (irq = 0; irq &lt; nr_legacy_irqs(); irq++) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pre-allocate the legacy IRQs.  Use NR_LEGACY_IRQS here</span>
<span class="p_add">+	 * because we don&#39;t have a PIC and thus nr_legacy_irqs() is zero.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (irq = 0; irq &lt; NR_IRQS_LEGACY; irq++) {</span>
 		int trigger, polarity;
 
 		if (acpi_get_override_irq(irq, &amp;trigger, &amp;polarity) == -1)
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 0990d4c..7d5f8cb 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1488,7 +1488,7 @@</span> <span class="p_context"> static struct blk_mq_tags *blk_mq_init_rq_map(struct blk_mq_tag_set *set,</span>
 		int to_do;
 		void *p;
 
<span class="p_del">-		while (left &lt; order_to_size(this_order - 1) &amp;&amp; this_order)</span>
<span class="p_add">+		while (this_order &amp;&amp; left &lt; order_to_size(this_order - 1))</span>
 			this_order--;
 
 		do {
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 9d5436f..111ec4a 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> static struct osi_linux {</span>
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
<span class="p_del">-	unsigned int	default_disabling:1;</span>
<span class="p_add">+	u8		default_disabling;</span>
 } osi_linux = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
<span class="p_chunk">@@ -1473,10 +1473,13 @@</span> <span class="p_context"> void __init acpi_osi_setup(char *str)</span>
 	if (*str == &#39;!&#39;) {
 		str++;
 		if (*str == &#39;\0&#39;) {
<span class="p_del">-			osi_linux.default_disabling = 1;</span>
<span class="p_add">+			/* Do not override acpi_osi=!* */</span>
<span class="p_add">+			if (!osi_linux.default_disabling)</span>
<span class="p_add">+				osi_linux.default_disabling =</span>
<span class="p_add">+					ACPI_DISABLE_ALL_VENDOR_STRINGS;</span>
 			return;
 		} else if (*str == &#39;*&#39;) {
<span class="p_del">-			acpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);</span>
<span class="p_add">+			osi_linux.default_disabling = ACPI_DISABLE_ALL_STRINGS;</span>
 			for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
 				osi = &amp;osi_setup_entries[i];
 				osi-&gt;enable = false;
<span class="p_chunk">@@ -1549,10 +1552,13 @@</span> <span class="p_context"> static void __init acpi_osi_setup_late(void)</span>
 	acpi_status status;
 
 	if (osi_linux.default_disabling) {
<span class="p_del">-		status = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);</span>
<span class="p_add">+		status = acpi_update_interfaces(osi_linux.default_disabling);</span>
 
 		if (ACPI_SUCCESS(status))
<span class="p_del">-			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors\n&quot;);</span>
<span class="p_add">+			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors%s\n&quot;,</span>
<span class="p_add">+				osi_linux.default_disabling ==</span>
<span class="p_add">+				ACPI_DISABLE_ALL_STRINGS ?</span>
<span class="p_add">+				&quot; and feature groups&quot; : &quot;&quot;);</span>
 	}
 
 	for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
<span class="p_header">diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c</span>
<span class="p_header">index 0876d77b..f56e27c 100644</span>
<span class="p_header">--- a/drivers/acpi/sysfs.c</span>
<span class="p_header">+++ b/drivers/acpi/sysfs.c</span>
<span class="p_chunk">@@ -492,23 +492,22 @@</span> <span class="p_context"> static void acpi_global_event_handler(u32 event_type, acpi_handle device,</span>
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
 	if (index &gt;= num_gpes + ACPI_NUM_FIXED_EVENTS)
<span class="p_del">-		goto end;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (index &lt; num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					&quot;Invalid GPE 0x%x&quot;, index));
<span class="p_del">-			goto end;</span>
<span class="p_add">+			return result;</span>
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index &lt; (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
<span class="p_del">-end:</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/ata/sata_dwc_460ex.c b/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_header">index 9020349..7a7faca 100644</span>
<span class="p_header">--- a/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_header">+++ b/drivers/ata/sata_dwc_460ex.c</span>
<span class="p_chunk">@@ -924,15 +924,13 @@</span> <span class="p_context"> static void sata_dwc_exec_command_by_tag(struct ata_port *ap,</span>
 					 struct ata_taskfile *tf,
 					 u8 tag, u32 cmd_issued)
 {
<span class="p_del">-	unsigned long flags;</span>
 	struct sata_dwc_device_port *hsdevp = HSDEVP_FROM_AP(ap);
 
 	dev_dbg(ap-&gt;dev, &quot;%s cmd(0x%02x): %s tag=%d\n&quot;, __func__, tf-&gt;command,
 		ata_get_cmd_descript(tf-&gt;command), tag);
 
<span class="p_del">-	spin_lock_irqsave(&amp;ap-&gt;host-&gt;lock, flags);</span>
 	hsdevp-&gt;cmd_issued[tag] = cmd_issued;
<span class="p_del">-	spin_unlock_irqrestore(&amp;ap-&gt;host-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	/*
 	 * Clear SError before executing a new command.
 	 * sata_dwc_scr_write and read can not be used here. Clearing the PM
<span class="p_header">diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c</span>
<span class="p_header">index 30b7bbf..964d5e4 100644</span>
<span class="p_header">--- a/drivers/base/power/main.c</span>
<span class="p_header">+++ b/drivers/base/power/main.c</span>
<span class="p_chunk">@@ -1262,14 +1262,15 @@</span> <span class="p_context"> int dpm_suspend_late(pm_message_t state)</span>
 		error = device_suspend_late(dev);
 
 		mutex_lock(&amp;dpm_list_mtx);
<span class="p_add">+		if (!list_empty(&amp;dev-&gt;power.entry))</span>
<span class="p_add">+			list_move(&amp;dev-&gt;power.entry, &amp;dpm_late_early_list);</span>
<span class="p_add">+</span>
 		if (error) {
 			pm_dev_err(dev, state, &quot; late&quot;, error);
 			dpm_save_failed_dev(dev_name(dev));
 			put_device(dev);
 			break;
 		}
<span class="p_del">-		if (!list_empty(&amp;dev-&gt;power.entry))</span>
<span class="p_del">-			list_move(&amp;dev-&gt;power.entry, &amp;dpm_late_early_list);</span>
 		put_device(dev);
 
 		if (async_error)
<span class="p_header">diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c</span>
<span class="p_header">index e1a10a0..9796a1a 100644</span>
<span class="p_header">--- a/drivers/base/power/runtime.c</span>
<span class="p_header">+++ b/drivers/base/power/runtime.c</span>
<span class="p_chunk">@@ -1468,11 +1468,16 @@</span> <span class="p_context"> int pm_runtime_force_resume(struct device *dev)</span>
 		goto out;
 	}
 
<span class="p_del">-	ret = callback(dev);</span>
<span class="p_add">+	ret = pm_runtime_set_active(dev);</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	pm_runtime_set_active(dev);</span>
<span class="p_add">+	ret = callback(dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pm_runtime_set_suspended(dev);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pm_runtime_mark_last_busy(dev);
 out:
 	pm_runtime_enable(dev);
<span class="p_header">diff --git a/drivers/base/regmap/regcache.c b/drivers/base/regmap/regcache.c</span>
<span class="p_header">index b9862d7..bc2c94d 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regcache.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regcache.c</span>
<span class="p_chunk">@@ -502,7 +502,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(regcache_mark_dirty);</span>
  * regcache_cache_bypass: Put a register map into cache bypass mode
  *
  * @map: map to configure
<span class="p_del">- * @cache_bypass: flag if changes should not be written to the hardware</span>
<span class="p_add">+ * @cache_bypass: flag if changes should not be written to the cache</span>
  *
  * When a register map is marked with the cache bypass option, writes
  * to the register map API will only update the hardware and not the
<span class="p_header">diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">index 78653db..4c4aa7d 100644</span>
<span class="p_header">--- a/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">+++ b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> struct vhci_data {</span>
 	wait_queue_head_t read_wait;
 	struct sk_buff_head readq;
 
<span class="p_add">+	struct mutex open_mutex;</span>
 	struct delayed_work open_timeout;
 };
 
<span class="p_chunk">@@ -95,12 +96,15 @@</span> <span class="p_context"> static int vhci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)</span>
 	return 0;
 }
 
<span class="p_del">-static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
<span class="p_add">+static int __vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
 {
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
 	__u8 dev_type;
 
<span class="p_add">+	if (data-&gt;hdev)</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	/* bits 0-1 are dev_type (BR/EDR or AMP) */
 	dev_type = opcode &amp; 0x03;
 
<span class="p_chunk">@@ -159,6 +163,17 @@</span> <span class="p_context"> static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
 	return 0;
 }
 
<span class="p_add">+static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+	err = __vhci_create_device(data, opcode);</span>
<span class="p_add">+	mutex_unlock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline ssize_t vhci_get_user(struct vhci_data *data,
 				    struct iov_iter *from)
 {
<span class="p_chunk">@@ -197,11 +212,6 @@</span> <span class="p_context"> static inline ssize_t vhci_get_user(struct vhci_data *data,</span>
 		break;
 
 	case HCI_VENDOR_PKT:
<span class="p_del">-		if (data-&gt;hdev) {</span>
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_del">-			return -EBADFD;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
 		opcode = *((__u8 *) skb-&gt;data);
<span class="p_chunk">@@ -328,6 +338,7 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 	skb_queue_head_init(&amp;data-&gt;readq);
 	init_waitqueue_head(&amp;data-&gt;read_wait);
 
<span class="p_add">+	mutex_init(&amp;data-&gt;open_mutex);</span>
 	INIT_DELAYED_WORK(&amp;data-&gt;open_timeout, vhci_open_timeout);
 
 	file-&gt;private_data = data;
<span class="p_chunk">@@ -341,15 +352,18 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 static int vhci_release(struct inode *inode, struct file *file)
 {
 	struct vhci_data *data = file-&gt;private_data;
<span class="p_del">-	struct hci_dev *hdev = data-&gt;hdev;</span>
<span class="p_add">+	struct hci_dev *hdev;</span>
 
 	cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
<span class="p_add">+	hdev = data-&gt;hdev;</span>
<span class="p_add">+</span>
 	if (hdev) {
 		hci_unregister_dev(hdev);
 		hci_free_dev(hdev);
 	}
 
<span class="p_add">+	skb_queue_purge(&amp;data-&gt;readq);</span>
 	file-&gt;private_data = NULL;
 	kfree(data);
 
<span class="p_header">diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig</span>
<span class="p_header">index a043107..b130d38 100644</span>
<span class="p_header">--- a/drivers/char/Kconfig</span>
<span class="p_header">+++ b/drivers/char/Kconfig</span>
<span class="p_chunk">@@ -584,7 +584,6 @@</span> <span class="p_context"> config TELCLOCK</span>
 
 config DEVPORT
 	bool
<span class="p_del">-	depends on !M68K</span>
 	depends on ISA || PCI
 	default y
 
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-msm8916.c b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">index 5d75bff..36d21eb 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_chunk">@@ -1996,6 +1996,7 @@</span> <span class="p_context"> static struct clk_branch gcc_crypto_clk = {</span>
 				&quot;crypto_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_chunk">@@ -2285,6 +2286,7 @@</span> <span class="p_context"> static struct clk_branch gcc_prng_ahb_clk = {</span>
 				&quot;pcnoc_bfdcd_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_userspace.c b/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_header">index 4dbf1db..9cc8abd 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_userspace.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
 static DEFINE_PER_CPU(unsigned int, cpu_is_managed);
 static DEFINE_MUTEX(userspace_mutex);
<span class="p_chunk">@@ -31,6 +32,7 @@</span> <span class="p_context"> static DEFINE_MUTEX(userspace_mutex);</span>
 static int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)
 {
 	int ret = -EINVAL;
<span class="p_add">+	unsigned int *setspeed = policy-&gt;governor_data;</span>
 
 	pr_debug(&quot;cpufreq_set for cpu %u, freq %u kHz\n&quot;, policy-&gt;cpu, freq);
 
<span class="p_chunk">@@ -38,6 +40,8 @@</span> <span class="p_context"> static int cpufreq_set(struct cpufreq_policy *policy, unsigned int freq)</span>
 	if (!per_cpu(cpu_is_managed, policy-&gt;cpu))
 		goto err;
 
<span class="p_add">+	*setspeed = freq;</span>
<span class="p_add">+</span>
 	ret = __cpufreq_driver_target(policy, freq, CPUFREQ_RELATION_L);
  err:
 	mutex_unlock(&amp;userspace_mutex);
<span class="p_chunk">@@ -49,19 +53,45 @@</span> <span class="p_context"> static ssize_t show_speed(struct cpufreq_policy *policy, char *buf)</span>
 	return sprintf(buf, &quot;%u\n&quot;, policy-&gt;cur);
 }
 
<span class="p_add">+static int cpufreq_userspace_policy_init(struct cpufreq_policy *policy)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int *setspeed;</span>
<span class="p_add">+</span>
<span class="p_add">+	setspeed = kzalloc(sizeof(*setspeed), GFP_KERNEL);</span>
<span class="p_add">+	if (!setspeed)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	policy-&gt;governor_data = setspeed;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cpufreq_governor_userspace(struct cpufreq_policy *policy,
 				   unsigned int event)
 {
<span class="p_add">+	unsigned int *setspeed = policy-&gt;governor_data;</span>
 	unsigned int cpu = policy-&gt;cpu;
 	int rc = 0;
 
<span class="p_add">+	if (event == CPUFREQ_GOV_POLICY_INIT)</span>
<span class="p_add">+		return cpufreq_userspace_policy_init(policy);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!setspeed)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	switch (event) {
<span class="p_add">+	case CPUFREQ_GOV_POLICY_EXIT:</span>
<span class="p_add">+		mutex_lock(&amp;userspace_mutex);</span>
<span class="p_add">+		policy-&gt;governor_data = NULL;</span>
<span class="p_add">+		kfree(setspeed);</span>
<span class="p_add">+		mutex_unlock(&amp;userspace_mutex);</span>
<span class="p_add">+		break;</span>
 	case CPUFREQ_GOV_START:
 		BUG_ON(!policy-&gt;cur);
 		pr_debug(&quot;started managing cpu %u\n&quot;, cpu);
 
 		mutex_lock(&amp;userspace_mutex);
 		per_cpu(cpu_is_managed, cpu) = 1;
<span class="p_add">+		*setspeed = policy-&gt;cur;</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	case CPUFREQ_GOV_STOP:
<span class="p_chunk">@@ -69,20 +99,23 @@</span> <span class="p_context"> static int cpufreq_governor_userspace(struct cpufreq_policy *policy,</span>
 
 		mutex_lock(&amp;userspace_mutex);
 		per_cpu(cpu_is_managed, cpu) = 0;
<span class="p_add">+		*setspeed = 0;</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	case CPUFREQ_GOV_LIMITS:
 		mutex_lock(&amp;userspace_mutex);
<span class="p_del">-		pr_debug(&quot;limit event for cpu %u: %u - %u kHz, currently %u kHz\n&quot;,</span>
<span class="p_del">-			cpu, policy-&gt;min, policy-&gt;max,</span>
<span class="p_del">-			policy-&gt;cur);</span>
<span class="p_add">+		pr_debug(&quot;limit event for cpu %u: %u - %u kHz, currently %u kHz, last set to %u kHz\n&quot;,</span>
<span class="p_add">+			cpu, policy-&gt;min, policy-&gt;max, policy-&gt;cur, *setspeed);</span>
 
<span class="p_del">-		if (policy-&gt;max &lt; policy-&gt;cur)</span>
<span class="p_add">+		if (policy-&gt;max &lt; *setspeed)</span>
 			__cpufreq_driver_target(policy, policy-&gt;max,
 						CPUFREQ_RELATION_H);
<span class="p_del">-		else if (policy-&gt;min &gt; policy-&gt;cur)</span>
<span class="p_add">+		else if (policy-&gt;min &gt; *setspeed)</span>
 			__cpufreq_driver_target(policy, policy-&gt;min,
 						CPUFREQ_RELATION_L);
<span class="p_add">+		else</span>
<span class="p_add">+			__cpufreq_driver_target(policy, *setspeed,</span>
<span class="p_add">+						CPUFREQ_RELATION_L);</span>
 		mutex_unlock(&amp;userspace_mutex);
 		break;
 	}
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index 48b7228..d17881f 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -210,7 +210,7 @@</span> <span class="p_context"> int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,</span>
 		tick_broadcast_exit();
 	}
 
<span class="p_del">-	if (!cpuidle_state_is_coupled(dev, drv, entered_state))</span>
<span class="p_add">+	if (!cpuidle_state_is_coupled(dev, drv, index))</span>
 		local_irq_enable();
 
 	diff = ktime_to_us(ktime_sub(time_end, time_start));
<span class="p_chunk">@@ -429,6 +429,8 @@</span> <span class="p_context"> static void __cpuidle_unregister_device(struct cpuidle_device *dev)</span>
 	list_del(&amp;dev-&gt;device_list);
 	per_cpu(cpuidle_devices, dev-&gt;cpu) = NULL;
 	module_put(drv-&gt;owner);
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;registered = 0;</span>
 }
 
 static void __cpuidle_device_init(struct cpuidle_device *dev)
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index b8b5d47..9bfd410 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> static void caam_jr_dequeue(unsigned long devarg)</span>
 struct device *caam_jr_alloc(void)
 {
 	struct caam_drv_private_jr *jrpriv, *min_jrpriv = NULL;
<span class="p_del">-	struct device *dev = NULL;</span>
<span class="p_add">+	struct device *dev = ERR_PTR(-ENODEV);</span>
 	int min_tfm_cnt	= INT_MAX;
 	int tfm_cnt;
 
<span class="p_header">diff --git a/drivers/crypto/s5p-sss.c b/drivers/crypto/s5p-sss.c</span>
<span class="p_header">index f214a87..8a9256b 100644</span>
<span class="p_header">--- a/drivers/crypto/s5p-sss.c</span>
<span class="p_header">+++ b/drivers/crypto/s5p-sss.c</span>
<span class="p_chunk">@@ -313,43 +313,55 @@</span> <span class="p_context"> static int s5p_set_indata(struct s5p_aes_dev *dev, struct scatterlist *sg)</span>
 	return err;
 }
 
<span class="p_del">-static void s5p_aes_tx(struct s5p_aes_dev *dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if new transmitting (output) data is ready and its</span>
<span class="p_add">+ * address+length have to be written to device (by calling</span>
<span class="p_add">+ * s5p_set_dma_outdata()). False otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool s5p_aes_tx(struct s5p_aes_dev *dev)</span>
 {
 	int err = 0;
<span class="p_add">+	bool ret = false;</span>
 
 	s5p_unset_outdata(dev);
 
 	if (!sg_is_last(dev-&gt;sg_dst)) {
 		err = s5p_set_outdata(dev, sg_next(dev-&gt;sg_dst));
<span class="p_del">-		if (err) {</span>
<span class="p_add">+		if (err)</span>
 			s5p_aes_complete(dev, err);
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		s5p_set_dma_outdata(dev, dev-&gt;sg_dst);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = true;</span>
 	} else {
 		s5p_aes_complete(dev, err);
 
 		dev-&gt;busy = true;
 		tasklet_schedule(&amp;dev-&gt;tasklet);
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-static void s5p_aes_rx(struct s5p_aes_dev *dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if new receiving (input) data is ready and its</span>
<span class="p_add">+ * address+length have to be written to device (by calling</span>
<span class="p_add">+ * s5p_set_dma_indata()). False otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool s5p_aes_rx(struct s5p_aes_dev *dev)</span>
 {
 	int err;
<span class="p_add">+	bool ret = false;</span>
 
 	s5p_unset_indata(dev);
 
 	if (!sg_is_last(dev-&gt;sg_src)) {
 		err = s5p_set_indata(dev, sg_next(dev-&gt;sg_src));
<span class="p_del">-		if (err) {</span>
<span class="p_add">+		if (err)</span>
 			s5p_aes_complete(dev, err);
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		s5p_set_dma_indata(dev, dev-&gt;sg_src);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = true;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static irqreturn_t s5p_aes_interrupt(int irq, void *dev_id)
<span class="p_chunk">@@ -358,19 +370,32 @@</span> <span class="p_context"> static irqreturn_t s5p_aes_interrupt(int irq, void *dev_id)</span>
 	struct s5p_aes_dev     *dev  = platform_get_drvdata(pdev);
 	uint32_t                status;
 	unsigned long           flags;
<span class="p_add">+	bool			set_dma_tx = false;</span>
<span class="p_add">+	bool			set_dma_rx = false;</span>
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 
 	if (irq == dev-&gt;irq_fc) {
 		status = SSS_READ(dev, FCINTSTAT);
 		if (status &amp; SSS_FCINTSTAT_BRDMAINT)
<span class="p_del">-			s5p_aes_rx(dev);</span>
<span class="p_add">+			set_dma_rx = s5p_aes_rx(dev);</span>
 		if (status &amp; SSS_FCINTSTAT_BTDMAINT)
<span class="p_del">-			s5p_aes_tx(dev);</span>
<span class="p_add">+			set_dma_tx = s5p_aes_tx(dev);</span>
 
 		SSS_WRITE(dev, FCINTPEND, status);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Writing length of DMA block (either receiving or transmitting)</span>
<span class="p_add">+	 * will start the operation immediately, so this should be done</span>
<span class="p_add">+	 * at the end (even after clearing pending interrupts to not miss the</span>
<span class="p_add">+	 * interrupt).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (set_dma_tx)</span>
<span class="p_add">+		s5p_set_dma_outdata(dev, dev-&gt;sg_dst);</span>
<span class="p_add">+	if (set_dma_rx)</span>
<span class="p_add">+		s5p_set_dma_indata(dev, dev-&gt;sg_src);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index e315e5e..aa7f137 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -966,7 +966,7 @@</span> <span class="p_context"> static void edac_inc_ue_error(struct mem_ctl_info *mci,</span>
 	mci-&gt;ue_mc += count;
 
 	if (!enable_per_layer_report) {
<span class="p_del">-		mci-&gt;ce_noinfo_count += count;</span>
<span class="p_add">+		mci-&gt;ue_noinfo_count += count;</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">index 119cdc2..7ef2c13 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_chunk">@@ -194,12 +194,12 @@</span> <span class="p_context"> int amdgpu_connector_get_monitor_bpc(struct drm_connector *connector)</span>
 				bpc = 8;
 				DRM_DEBUG(&quot;%s: HDMI deep color 10 bpc exceeds max tmds clock. Using %d bpc.\n&quot;,
 					  connector-&gt;name, bpc);
<span class="p_del">-			} else if (bpc &gt; 8) {</span>
<span class="p_del">-				/* max_tmds_clock missing, but hdmi spec mandates it for deep color. */</span>
<span class="p_del">-				DRM_DEBUG(&quot;%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\n&quot;,</span>
<span class="p_del">-					  connector-&gt;name);</span>
<span class="p_del">-				bpc = 8;</span>
 			}
<span class="p_add">+		} else if (bpc &gt; 8) {</span>
<span class="p_add">+			/* max_tmds_clock missing, but hdmi spec mandates it for deep color. */</span>
<span class="p_add">+			DRM_DEBUG(&quot;%s: Required max tmds clock for HDMI deep color missing. Using 8 bpc.\n&quot;,</span>
<span class="p_add">+				  connector-&gt;name);</span>
<span class="p_add">+			bpc = 8;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">index 7b7f4ab..fe36caf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> u32 amdgpu_dpm_get_vrefresh(struct amdgpu_device *adev)</span>
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			amdgpu_crtc = to_amdgpu_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				vrefresh = amdgpu_crtc-&gt;hw_mode.vrefresh;</span>
<span class="p_add">+				vrefresh = drm_mode_vrefresh(&amp;amdgpu_crtc-&gt;hw_mode);</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">index cac4229..c8b90b3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_chunk">@@ -1549,7 +1549,6 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 			  int n, int width, int height)
 {
 	int c, o;
<span class="p_del">-	struct drm_device *dev = fb_helper-&gt;dev;</span>
 	struct drm_connector *connector;
 	const struct drm_connector_helper_funcs *connector_funcs;
 	struct drm_encoder *encoder;
<span class="p_chunk">@@ -1568,7 +1567,7 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 	if (modes[n] == NULL)
 		return best_score;
 
<span class="p_del">-	crtcs = kzalloc(dev-&gt;mode_config.num_connector *</span>
<span class="p_add">+	crtcs = kzalloc(fb_helper-&gt;connector_count *</span>
 			sizeof(struct drm_fb_helper_crtc *), GFP_KERNEL);
 	if (!crtcs)
 		return best_score;
<span class="p_chunk">@@ -1614,7 +1613,7 @@</span> <span class="p_context"> static int drm_pick_crtcs(struct drm_fb_helper *fb_helper,</span>
 		if (score &gt; best_score) {
 			best_score = score;
 			memcpy(best_crtcs, crtcs,
<span class="p_del">-			       dev-&gt;mode_config.num_connector *</span>
<span class="p_add">+			       fb_helper-&gt;connector_count *</span>
 			       sizeof(struct drm_fb_helper_crtc *));
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_header">index 6b43ae3..1616af2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/gma500/mdfld_dsi_pkg_sender.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> static const char *const dsi_errors[] = {</span>
 	&quot;RX Prot Violation&quot;,
 	&quot;HS Generic Write FIFO Full&quot;,
 	&quot;LP Generic Write FIFO Full&quot;,
<span class="p_del">-	&quot;Generic Read Data Avail&quot;</span>
<span class="p_add">+	&quot;Generic Read Data Avail&quot;,</span>
 	&quot;Special Packet Sent&quot;,
 	&quot;Tearing Effect&quot;,
 };
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index 9d42aeb..2188b7f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -762,12 +762,12 @@</span> <span class="p_context"> static int i915_drm_resume(struct drm_device *dev)</span>
 		dev_priv-&gt;display.hpd_irq_setup(dev);
 	spin_unlock_irq(&amp;dev_priv-&gt;irq_lock);
 
<span class="p_add">+	intel_dp_mst_resume(dev);</span>
<span class="p_add">+</span>
 	drm_modeset_lock_all(dev);
 	intel_modeset_setup_hw_state(dev, true);
 	drm_modeset_unlock_all(dev);
 
<span class="p_del">-	intel_dp_mst_resume(dev);</span>
<span class="p_del">-</span>
 	/*
 	 * ... but also need to make sure that hotplug processing
 	 * doesn&#39;t cause havoc. Like in the driver load code we don&#39;t
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp_mst.c b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">index 8c127201..7feec0f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp_mst.c</span>
<span class="p_chunk">@@ -470,14 +470,13 @@</span> <span class="p_context"> static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,</span>
 {
 	struct intel_connector *intel_connector = to_intel_connector(connector);
 	struct drm_device *dev = connector-&gt;dev;
<span class="p_del">-	/* need to nuke the connector */</span>
<span class="p_del">-	mutex_lock(&amp;dev-&gt;mode_config.mutex);</span>
<span class="p_del">-	intel_connector_dpms(connector, DRM_MODE_DPMS_OFF);</span>
<span class="p_del">-	mutex_unlock(&amp;dev-&gt;mode_config.mutex);</span>
 
 	intel_connector-&gt;unregister(intel_connector);
 
<span class="p_add">+	/* need to nuke the connector */</span>
 	mutex_lock(&amp;dev-&gt;mode_config.mutex);
<span class="p_add">+	intel_connector_dpms(connector, DRM_MODE_DPMS_OFF);</span>
<span class="p_add">+</span>
 	intel_connector_remove_from_fbdev(intel_connector);
 	drm_connector_cleanup(connector);
 	mutex_unlock(&amp;dev-&gt;mode_config.mutex);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dsi.c b/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_header">index 68b25dd..d03690e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_chunk">@@ -600,12 +600,12 @@</span> <span class="p_context"> static bool intel_dsi_get_hw_state(struct intel_encoder *encoder,</span>
 		dpi_enabled = I915_READ(MIPI_PORT_CTRL(port)) &amp;
 							DPI_ENABLE;
 
<span class="p_del">-		/* Due to some hardware limitations on BYT, MIPI Port C DPI</span>
<span class="p_del">-		 * Enable bit does not get set. To check whether DSI Port C</span>
<span class="p_del">-		 * was enabled in BIOS, check the Pipe B enable bit</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Due to some hardware limitations on VLV/CHV, the DPI enable</span>
<span class="p_add">+		 * bit in port C control register does not get set. As a</span>
<span class="p_add">+		 * workaround, check pipe B conf instead.</span>
 		 */
<span class="p_del">-		if (IS_VALLEYVIEW(dev) &amp;&amp; !IS_CHERRYVIEW(dev) &amp;&amp;</span>
<span class="p_del">-		    (port == PORT_C))</span>
<span class="p_add">+		if ((IS_VALLEYVIEW(dev) || IS_CHERRYVIEW(dev)) &amp;&amp; port == PORT_C)</span>
 			dpi_enabled = I915_READ(PIPECONF(PIPE_B)) &amp;
 							PIPECONF_ENABLE;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_fbdev.c b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">index 6372cfc..b39fdf7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_fbdev.c</span>
<span class="p_chunk">@@ -387,12 +387,12 @@</span> <span class="p_context"> static bool intel_fb_initial_config(struct drm_fb_helper *fb_helper,</span>
 	uint64_t conn_configured = 0, mask;
 	int pass = 0;
 
<span class="p_del">-	save_enabled = kcalloc(dev-&gt;mode_config.num_connector, sizeof(bool),</span>
<span class="p_add">+	save_enabled = kcalloc(fb_helper-&gt;connector_count, sizeof(bool),</span>
 			       GFP_KERNEL);
 	if (!save_enabled)
 		return false;
 
<span class="p_del">-	memcpy(save_enabled, enabled, dev-&gt;mode_config.num_connector);</span>
<span class="p_add">+	memcpy(save_enabled, enabled, fb_helper-&gt;connector_count);</span>
 	mask = (1 &lt;&lt; fb_helper-&gt;connector_count) - 1;
 retry:
 	for (i = 0; i &lt; fb_helper-&gt;connector_count; i++) {
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> retry:</span>
 	if (fallback) {
 bail:
 		DRM_DEBUG_KMS(&quot;Not using firmware configuration\n&quot;);
<span class="p_del">-		memcpy(enabled, save_enabled, dev-&gt;mode_config.num_connector);</span>
<span class="p_add">+		memcpy(enabled, save_enabled, fb_helper-&gt;connector_count);</span>
 		kfree(save_enabled);
 		return false;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 6907a1b..d4b6c20 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -3656,6 +3656,8 @@</span> <span class="p_context"> static void ilk_pipe_wm_get_hw_state(struct drm_crtc *crtc)</span>
 	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		hw-&gt;wm_linetime[pipe] = I915_READ(PIPE_WM_LINETIME(pipe));
 
<span class="p_add">+	memset(active, 0, sizeof(*active));</span>
<span class="p_add">+</span>
 	active-&gt;pipe_enabled = intel_crtc-&gt;active;
 
 	if (active-&gt;pipe_enabled) {
<span class="p_header">diff --git a/drivers/hv/ring_buffer.c b/drivers/hv/ring_buffer.c</span>
<span class="p_header">index 6361d12..14d45c7 100644</span>
<span class="p_header">--- a/drivers/hv/ring_buffer.c</span>
<span class="p_header">+++ b/drivers/hv/ring_buffer.c</span>
<span class="p_chunk">@@ -103,19 +103,30 @@</span> <span class="p_context"> static bool hv_need_to_signal(u32 old_write, struct hv_ring_buffer_info *rbi)</span>
  *    there is room for the producer to send the pending packet.
  */
 
<span class="p_del">-static bool hv_need_to_signal_on_read(u32 old_rd,</span>
<span class="p_del">-					 struct hv_ring_buffer_info *rbi)</span>
<span class="p_add">+static bool hv_need_to_signal_on_read(struct hv_ring_buffer_info *rbi)</span>
 {
<span class="p_del">-	u32 prev_write_sz;</span>
 	u32 cur_write_sz;
 	u32 r_size;
<span class="p_del">-	u32 write_loc = rbi-&gt;ring_buffer-&gt;write_index;</span>
<span class="p_add">+	u32 write_loc;</span>
 	u32 read_loc = rbi-&gt;ring_buffer-&gt;read_index;
<span class="p_del">-	u32 pending_sz = rbi-&gt;ring_buffer-&gt;pending_send_sz;</span>
<span class="p_add">+	u32 pending_sz;</span>
 
 	/*
<span class="p_del">-	 * If the other end is not blocked on write don&#39;t bother.</span>
<span class="p_add">+	 * Issue a full memory barrier before making the signaling decision.</span>
<span class="p_add">+	 * Here is the reason for having this barrier:</span>
<span class="p_add">+	 * If the reading of the pend_sz (in this function)</span>
<span class="p_add">+	 * were to be reordered and read before we commit the new read</span>
<span class="p_add">+	 * index (in the calling function)  we could</span>
<span class="p_add">+	 * have a problem. If the host were to set the pending_sz after we</span>
<span class="p_add">+	 * have sampled pending_sz and go to sleep before we commit the</span>
<span class="p_add">+	 * read index, we could miss sending the interrupt. Issue a full</span>
<span class="p_add">+	 * memory barrier to address this.</span>
 	 */
<span class="p_add">+	mb();</span>
<span class="p_add">+</span>
<span class="p_add">+	pending_sz = rbi-&gt;ring_buffer-&gt;pending_send_sz;</span>
<span class="p_add">+	write_loc = rbi-&gt;ring_buffer-&gt;write_index;</span>
<span class="p_add">+	/* If the other end is not blocked on write don&#39;t bother. */</span>
 	if (pending_sz == 0)
 		return false;
 
<span class="p_chunk">@@ -123,22 +134,13 @@</span> <span class="p_context"> static bool hv_need_to_signal_on_read(u32 old_rd,</span>
 	cur_write_sz = write_loc &gt;= read_loc ? r_size - (write_loc - read_loc) :
 			read_loc - write_loc;
 
<span class="p_del">-	prev_write_sz = write_loc &gt;= old_rd ? r_size - (write_loc - old_rd) :</span>
<span class="p_del">-			old_rd - write_loc;</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((prev_write_sz &lt; pending_sz) &amp;&amp; (cur_write_sz &gt;= pending_sz))</span>
<span class="p_add">+	if (cur_write_sz &gt;= pending_sz)</span>
 		return true;
 
 	return false;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * hv_get_next_write_location()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get the next write location for the specified ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get the next write location for the specified ring buffer. */</span>
 static inline u32
 hv_get_next_write_location(struct hv_ring_buffer_info *ring_info)
 {
<span class="p_chunk">@@ -147,12 +149,7 @@</span> <span class="p_context"> hv_get_next_write_location(struct hv_ring_buffer_info *ring_info)</span>
 	return next;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * hv_set_next_write_location()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Set the next write location for the specified ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Set the next write location for the specified ring buffer. */</span>
 static inline void
 hv_set_next_write_location(struct hv_ring_buffer_info *ring_info,
 		     u32 next_write_location)
<span class="p_chunk">@@ -160,11 +157,7 @@</span> <span class="p_context"> hv_set_next_write_location(struct hv_ring_buffer_info *ring_info,</span>
 	ring_info-&gt;ring_buffer-&gt;write_index = next_write_location;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * hv_get_next_read_location()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get the next read location for the specified ring buffer</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get the next read location for the specified ring buffer. */</span>
 static inline u32
 hv_get_next_read_location(struct hv_ring_buffer_info *ring_info)
 {
<span class="p_chunk">@@ -174,10 +167,8 @@</span> <span class="p_context"> hv_get_next_read_location(struct hv_ring_buffer_info *ring_info)</span>
 }
 
 /*
<span class="p_del">- * hv_get_next_readlocation_withoffset()</span>
<span class="p_del">- *</span>
  * Get the next read location + offset for the specified ring buffer.
<span class="p_del">- * This allows the caller to skip</span>
<span class="p_add">+ * This allows the caller to skip.</span>
  */
 static inline u32
 hv_get_next_readlocation_withoffset(struct hv_ring_buffer_info *ring_info,
<span class="p_chunk">@@ -191,13 +182,7 @@</span> <span class="p_context"> hv_get_next_readlocation_withoffset(struct hv_ring_buffer_info *ring_info,</span>
 	return next;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_set_next_read_location()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Set the next read location for the specified ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Set the next read location for the specified ring buffer. */</span>
 static inline void
 hv_set_next_read_location(struct hv_ring_buffer_info *ring_info,
 		    u32 next_read_location)
<span class="p_chunk">@@ -206,12 +191,7 @@</span> <span class="p_context"> hv_set_next_read_location(struct hv_ring_buffer_info *ring_info,</span>
 }
 
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_get_ring_buffer()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get the start of the ring buffer</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get the start of the ring buffer. */</span>
 static inline void *
 hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)
 {
<span class="p_chunk">@@ -219,25 +199,14 @@</span> <span class="p_context"> hv_get_ring_buffer(struct hv_ring_buffer_info *ring_info)</span>
 }
 
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_get_ring_buffersize()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get the size of the ring buffer</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get the size of the ring buffer. */</span>
 static inline u32
 hv_get_ring_buffersize(struct hv_ring_buffer_info *ring_info)
 {
 	return ring_info-&gt;ring_datasize;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_get_ring_bufferindices()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get the read and write indices as u64 of the specified ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get the read and write indices as u64 of the specified ring buffer. */</span>
 static inline u64
 hv_get_ring_bufferindices(struct hv_ring_buffer_info *ring_info)
 {
<span class="p_chunk">@@ -245,12 +214,8 @@</span> <span class="p_context"> hv_get_ring_bufferindices(struct hv_ring_buffer_info *ring_info)</span>
 }
 
 /*
<span class="p_del">- *</span>
<span class="p_del">- * hv_copyfrom_ringbuffer()</span>
<span class="p_del">- *</span>
  * Helper routine to copy to source from ring buffer.
  * Assume there is enough room. Handles wrap-around in src case only!!
<span class="p_del">- *</span>
  */
 static u32 hv_copyfrom_ringbuffer(
 	struct hv_ring_buffer_info	*ring_info,
<span class="p_chunk">@@ -282,12 +247,8 @@</span> <span class="p_context"> static u32 hv_copyfrom_ringbuffer(</span>
 
 
 /*
<span class="p_del">- *</span>
<span class="p_del">- * hv_copyto_ringbuffer()</span>
<span class="p_del">- *</span>
  * Helper routine to copy from source to ring buffer.
  * Assume there is enough room. Handles wrap-around in dest case only!!
<span class="p_del">- *</span>
  */
 static u32 hv_copyto_ringbuffer(
 	struct hv_ring_buffer_info	*ring_info,
<span class="p_chunk">@@ -313,13 +274,7 @@</span> <span class="p_context"> static u32 hv_copyto_ringbuffer(</span>
 	return start_write_offset;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_get_debuginfo()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Get various debug metrics for the specified ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Get various debug metrics for the specified ring buffer. */</span>
 void hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,
 			    struct hv_ring_buffer_debug_info *debug_info)
 {
<span class="p_chunk">@@ -342,13 +297,7 @@</span> <span class="p_context"> void hv_ringbuffer_get_debuginfo(struct hv_ring_buffer_info *ring_info,</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_init()</span>
<span class="p_del">- *</span>
<span class="p_del">- *Initialize the ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Initialize the ring buffer. */</span>
 int hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info,
 		   void *buffer, u32 buflen)
 {
<span class="p_chunk">@@ -361,9 +310,7 @@</span> <span class="p_context"> int hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info,</span>
 	ring_info-&gt;ring_buffer-&gt;read_index =
 		ring_info-&gt;ring_buffer-&gt;write_index = 0;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set the feature bit for enabling flow control.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Set the feature bit for enabling flow control. */</span>
 	ring_info-&gt;ring_buffer-&gt;feature_bits.value = 1;
 
 	ring_info-&gt;ring_size = buflen;
<span class="p_chunk">@@ -374,24 +321,12 @@</span> <span class="p_context"> int hv_ringbuffer_init(struct hv_ring_buffer_info *ring_info,</span>
 	return 0;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_cleanup()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Cleanup the ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Cleanup the ring buffer. */</span>
 void hv_ringbuffer_cleanup(struct hv_ring_buffer_info *ring_info)
 {
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_write()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Write to the ring buffer</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Write to the ring buffer. */</span>
 int hv_ringbuffer_write(struct hv_ring_buffer_info *outring_info,
 		    struct kvec *kv_list, u32 kv_count, bool *signal)
 {
<span class="p_chunk">@@ -416,10 +351,11 @@</span> <span class="p_context"> int hv_ringbuffer_write(struct hv_ring_buffer_info *outring_info,</span>
 				&amp;bytes_avail_toread,
 				&amp;bytes_avail_towrite);
 
<span class="p_del">-</span>
<span class="p_del">-	/* If there is only room for the packet, assume it is full. */</span>
<span class="p_del">-	/* Otherwise, the next time around, we think the ring buffer */</span>
<span class="p_del">-	/* is empty since the read index == write index */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If there is only room for the packet, assume it is full.</span>
<span class="p_add">+	 * Otherwise, the next time around, we think the ring buffer</span>
<span class="p_add">+	 * is empty since the read index == write index.</span>
<span class="p_add">+	 */</span>
 	if (bytes_avail_towrite &lt;= totalbytes_towrite) {
 		spin_unlock_irqrestore(&amp;outring_info-&gt;ring_lock, flags);
 		return -EAGAIN;
<span class="p_chunk">@@ -459,13 +395,7 @@</span> <span class="p_context"> int hv_ringbuffer_write(struct hv_ring_buffer_info *outring_info,</span>
 }
 
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_peek()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Read without advancing the read index</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Read without advancing the read index. */</span>
 int hv_ringbuffer_peek(struct hv_ring_buffer_info *Inring_info,
 		   void *Buffer, u32 buflen)
 {
<span class="p_chunk">@@ -502,13 +432,7 @@</span> <span class="p_context"> int hv_ringbuffer_peek(struct hv_ring_buffer_info *Inring_info,</span>
 }
 
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * hv_ringbuffer_read()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Read and advance the read index</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* Read and advance the read index. */</span>
 int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,
 		   u32 buflen, u32 offset, bool *signal)
 {
<span class="p_chunk">@@ -517,7 +441,6 @@</span> <span class="p_context"> int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,</span>
 	u32 next_read_location = 0;
 	u64 prev_indices = 0;
 	unsigned long flags;
<span class="p_del">-	u32 old_read;</span>
 
 	if (buflen &lt;= 0)
 		return -EINVAL;
<span class="p_chunk">@@ -528,8 +451,6 @@</span> <span class="p_context"> int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,</span>
 				&amp;bytes_avail_toread,
 				&amp;bytes_avail_towrite);
 
<span class="p_del">-	old_read = bytes_avail_toread;</span>
<span class="p_del">-</span>
 	/* Make sure there is something to read */
 	if (bytes_avail_toread &lt; buflen) {
 		spin_unlock_irqrestore(&amp;inring_info-&gt;ring_lock, flags);
<span class="p_chunk">@@ -550,9 +471,11 @@</span> <span class="p_context"> int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,</span>
 						sizeof(u64),
 						next_read_location);
 
<span class="p_del">-	/* Make sure all reads are done before we update the read index since */</span>
<span class="p_del">-	/* the writer may start writing to the read area once the read index */</span>
<span class="p_del">-	/*is updated */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure all reads are done before we update the read index since</span>
<span class="p_add">+	 * the writer may start writing to the read area once the read index</span>
<span class="p_add">+	 * is updated.</span>
<span class="p_add">+	 */</span>
 	mb();
 
 	/* Update the read index */
<span class="p_chunk">@@ -560,7 +483,7 @@</span> <span class="p_context"> int hv_ringbuffer_read(struct hv_ring_buffer_info *inring_info, void *buffer,</span>
 
 	spin_unlock_irqrestore(&amp;inring_info-&gt;ring_lock, flags);
 
<span class="p_del">-	*signal = hv_need_to_signal_on_read(old_read, inring_info);</span>
<span class="p_add">+	*signal = hv_need_to_signal_on_read(inring_info);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/hwmon/ads7828.c b/drivers/hwmon/ads7828.c</span>
<span class="p_header">index 6c99ee7..ee396ff 100644</span>
<span class="p_header">--- a/drivers/hwmon/ads7828.c</span>
<span class="p_header">+++ b/drivers/hwmon/ads7828.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> static int ads7828_probe(struct i2c_client *client,</span>
 	unsigned int vref_mv = ADS7828_INT_VREF_MV;
 	bool diff_input = false;
 	bool ext_vref = false;
<span class="p_add">+	unsigned int regval;</span>
 
 	data = devm_kzalloc(dev, sizeof(struct ads7828_data), GFP_KERNEL);
 	if (!data)
<span class="p_chunk">@@ -154,6 +155,15 @@</span> <span class="p_context"> static int ads7828_probe(struct i2c_client *client,</span>
 	if (!diff_input)
 		data-&gt;cmd_byte |= ADS7828_CMD_SD_SE;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Datasheet specifies internal reference voltage is disabled by</span>
<span class="p_add">+	 * default. The internal reference voltage needs to be enabled and</span>
<span class="p_add">+	 * voltage needs to settle before getting valid ADC data. So perform a</span>
<span class="p_add">+	 * dummy read to enable the internal reference voltage.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ext_vref)</span>
<span class="p_add">+		regmap_read(data-&gt;regmap, data-&gt;cmd_byte, &amp;regval);</span>
<span class="p_add">+</span>
 	hwmon_dev = devm_hwmon_device_register_with_groups(dev, client-&gt;name,
 							   data,
 							   ads7828_groups);
<span class="p_header">diff --git a/drivers/hwspinlock/hwspinlock_core.c b/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_header">index d50c701..4074441 100644</span>
<span class="p_header">--- a/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_header">+++ b/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> int of_hwspin_lock_get_id(struct device_node *np, int index)</span>
 		hwlock = radix_tree_deref_slot(slot);
 		if (unlikely(!hwlock))
 			continue;
<span class="p_del">-		if (radix_tree_is_indirect_ptr(hwlock)) {</span>
<span class="p_add">+		if (radix_tree_deref_retry(hwlock)) {</span>
 			slot = radix_tree_iter_retry(&amp;iter);
 			continue;
 		}
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_util.c b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">index 5fb089e..fb43a24 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_chunk">@@ -634,6 +634,7 @@</span> <span class="p_context"> static int send_nlmsg_done(struct sk_buff *skb, u8 nl_client, int iwpm_pid)</span>
 	if (!(ibnl_put_msg(skb, &amp;nlh, 0, 0, nl_client,
 			   RDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {
 		pr_warn(&quot;%s Unable to put NLMSG_DONE\n&quot;, __func__);
<span class="p_add">+		dev_kfree_skb(skb);</span>
 		return -ENOMEM;
 	}
 	nlh-&gt;nlmsg_type = NLMSG_DONE;
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/cxio_hal.c b/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_header">index de1c61b4..ada2e50 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/cxio_hal.c</span>
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> int cxio_destroy_cq(struct cxio_rdev *rdev_p, struct t3_cq *cq)</span>
 	kfree(cq-&gt;sw_queue);
 	dma_free_coherent(&amp;(rdev_p-&gt;rnic_info.pdev-&gt;dev),
 			  (1UL &lt;&lt; (cq-&gt;size_log2))
<span class="p_del">-			  * sizeof(struct t3_cqe), cq-&gt;queue,</span>
<span class="p_add">+			  * sizeof(struct t3_cqe) + 1, cq-&gt;queue,</span>
 			  dma_unmap_addr(cq, mapping));
 	cxio_hal_put_cqid(rdev_p-&gt;rscp, cq-&gt;cqid);
 	return err;
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index bdcb72e..fdf808e 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -2807,7 +2807,7 @@</span> <span class="p_context"> static int srp_add_target(struct srp_host *host, struct srp_target_port *target)</span>
 		goto out;
 	}
 
<span class="p_del">-	pr_debug(PFX &quot;%s: SCSI scan succeeded - detected %d LUNs\n&quot;,</span>
<span class="p_add">+	pr_debug(&quot;%s: SCSI scan succeeded - detected %d LUNs\n&quot;,</span>
 		 dev_name(&amp;target-&gt;scsi_host-&gt;shost_gendev),
 		 srp_sdev_count(target-&gt;scsi_host));
 
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index 38fd7b7..8aea29c 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -432,6 +432,10 @@</span> <span class="p_context"> static void xpad360_process_packet(struct usb_xpad *xpad,</span>
 {
 	struct input_dev *dev = xpad-&gt;dev;
 
<span class="p_add">+	/* valid pad data */</span>
<span class="p_add">+	if (data[0] != 0x00)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* digital pad */
 	if (xpad-&gt;mapping &amp; MAP_DPAD_TO_BUTTONS) {
 		/* dpad as buttons (left, right, up, down) */
<span class="p_header">diff --git a/drivers/input/misc/pwm-beeper.c b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">index e82edf8..9021725 100644</span>
<span class="p_header">--- a/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">+++ b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_chunk">@@ -20,21 +20,40 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pwm.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 
 struct pwm_beeper {
 	struct input_dev *input;
 	struct pwm_device *pwm;
<span class="p_add">+	struct work_struct work;</span>
 	unsigned long period;
 };
 
 #define HZ_TO_NANOSECONDS(x) (1000000000UL/(x))
 
<span class="p_add">+static void __pwm_beeper_set(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long period = beeper-&gt;period;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (period) {</span>
<span class="p_add">+		pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_add">+		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper =</span>
<span class="p_add">+		container_of(work, struct pwm_beeper, work);</span>
<span class="p_add">+</span>
<span class="p_add">+	__pwm_beeper_set(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_event(struct input_dev *input,
 			    unsigned int type, unsigned int code, int value)
 {
<span class="p_del">-	int ret = 0;</span>
 	struct pwm_beeper *beeper = input_get_drvdata(input);
<span class="p_del">-	unsigned long period;</span>
 
 	if (type != EV_SND || value &lt; 0)
 		return -EINVAL;
<span class="p_chunk">@@ -49,22 +68,31 @@</span> <span class="p_context"> static int pwm_beeper_event(struct input_dev *input,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (value == 0) {</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_del">-		ret = pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		ret = pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		beeper-&gt;period = period;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (value == 0)</span>
<span class="p_add">+		beeper-&gt;period = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		beeper-&gt;period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_add">+</span>
<span class="p_add">+	schedule_work(&amp;beeper-&gt;work);</span>
 
 	return 0;
 }
 
<span class="p_add">+static void pwm_beeper_stop(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cancel_work_sync(&amp;beeper-&gt;work);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_close(struct input_dev *input)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper = input_get_drvdata(input);</span>
<span class="p_add">+</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_probe(struct platform_device *pdev)
 {
 	unsigned long pwm_id = (unsigned long)dev_get_platdata(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -87,6 +115,8 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 		goto err_free;
 	}
 
<span class="p_add">+	INIT_WORK(&amp;beeper-&gt;work, pwm_beeper_work);</span>
<span class="p_add">+</span>
 	beeper-&gt;input = input_allocate_device();
 	if (!beeper-&gt;input) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to allocate input device\n&quot;);
<span class="p_chunk">@@ -106,6 +136,7 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 	beeper-&gt;input-&gt;sndbit[0] = BIT(SND_TONE) | BIT(SND_BELL);
 
 	beeper-&gt;input-&gt;event = pwm_beeper_event;
<span class="p_add">+	beeper-&gt;input-&gt;close = pwm_beeper_close;</span>
 
 	input_set_drvdata(beeper-&gt;input, beeper);
 
<span class="p_chunk">@@ -135,7 +166,6 @@</span> <span class="p_context"> static int pwm_beeper_remove(struct platform_device *pdev)</span>
 
 	input_unregister_device(beeper-&gt;input);
 
<span class="p_del">-	pwm_disable(beeper-&gt;pwm);</span>
 	pwm_free(beeper-&gt;pwm);
 
 	kfree(beeper);
<span class="p_chunk">@@ -147,8 +177,7 @@</span> <span class="p_context"> static int __maybe_unused pwm_beeper_suspend(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period)</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -157,10 +186,8 @@</span> <span class="p_context"> static int __maybe_unused pwm_beeper_resume(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period) {</span>
<span class="p_del">-		pwm_config(beeper-&gt;pwm, beeper-&gt;period / 2, beeper-&gt;period);</span>
<span class="p_del">-		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		__pwm_beeper_set(beeper);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/misc/uinput.c b/drivers/input/misc/uinput.c</span>
<span class="p_header">index 421e29e..5221450 100644</span>
<span class="p_header">--- a/drivers/input/misc/uinput.c</span>
<span class="p_header">+++ b/drivers/input/misc/uinput.c</span>
<span class="p_chunk">@@ -895,9 +895,15 @@</span> <span class="p_context"> static long uinput_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_add">+</span>
<span class="p_add">+#define UI_SET_PHYS_COMPAT	_IOW(UINPUT_IOCTL_BASE, 108, compat_uptr_t)</span>
<span class="p_add">+</span>
 static long uinput_compat_ioctl(struct file *file,
 				unsigned int cmd, unsigned long arg)
 {
<span class="p_add">+	if (cmd == UI_SET_PHYS_COMPAT)</span>
<span class="p_add">+		cmd = UI_SET_PHYS;</span>
<span class="p_add">+</span>
 	return uinput_ioctl_handler(file, cmd, arg, compat_ptr(arg));
 }
 #endif
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index b526875..c4a55d8 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -1552,18 +1552,14 @@</span> <span class="p_context"> static int dmar_fault_do_one(struct intel_iommu *iommu, int type,</span>
 	reason = dmar_get_fault_reason(fault_reason, &amp;fault_type);
 
 	if (fault_type == INTR_REMAP)
<span class="p_del">-		pr_err(&quot;INTR-REMAP: Request device [[%02x:%02x.%d] &quot;</span>
<span class="p_del">-		       &quot;fault index %llx\n&quot;</span>
<span class="p_del">-			&quot;INTR-REMAP:[fault reason %02d] %s\n&quot;,</span>
<span class="p_del">-			(source_id &gt;&gt; 8), PCI_SLOT(source_id &amp; 0xFF),</span>
<span class="p_add">+		pr_err(&quot;[INTR-REMAP] Request device [%02x:%02x.%d] fault index %llx [fault reason %02d] %s\n&quot;,</span>
<span class="p_add">+			source_id &gt;&gt; 8, PCI_SLOT(source_id &amp; 0xFF),</span>
 			PCI_FUNC(source_id &amp; 0xFF), addr &gt;&gt; 48,
 			fault_reason, reason);
 	else
<span class="p_del">-		pr_err(&quot;DMAR:[%s] Request device [%02x:%02x.%d] &quot;</span>
<span class="p_del">-		       &quot;fault addr %llx \n&quot;</span>
<span class="p_del">-		       &quot;DMAR:[fault reason %02d] %s\n&quot;,</span>
<span class="p_del">-		       (type ? &quot;DMA Read&quot; : &quot;DMA Write&quot;),</span>
<span class="p_del">-		       (source_id &gt;&gt; 8), PCI_SLOT(source_id &amp; 0xFF),</span>
<span class="p_add">+		pr_err(&quot;[%s] Request device [%02x:%02x.%d] fault addr %llx [fault reason %02d] %s\n&quot;,</span>
<span class="p_add">+		       type ? &quot;DMA Read&quot; : &quot;DMA Write&quot;,</span>
<span class="p_add">+		       source_id &gt;&gt; 8, PCI_SLOT(source_id &amp; 0xFF),</span>
 		       PCI_FUNC(source_id &amp; 0xFF), addr, fault_reason, reason);
 	return 0;
 }
<span class="p_chunk">@@ -1575,10 +1571,17 @@</span> <span class="p_context"> irqreturn_t dmar_fault(int irq, void *dev_id)</span>
 	int reg, fault_index;
 	u32 fault_status;
 	unsigned long flag;
<span class="p_add">+	bool ratelimited;</span>
<span class="p_add">+	static DEFINE_RATELIMIT_STATE(rs,</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_INTERVAL,</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_BURST);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable printing, simply clear the fault when ratelimited */</span>
<span class="p_add">+	ratelimited = !__ratelimit(&amp;rs);</span>
 
 	raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flag);
 	fault_status = readl(iommu-&gt;reg + DMAR_FSTS_REG);
<span class="p_del">-	if (fault_status)</span>
<span class="p_add">+	if (fault_status &amp;&amp; !ratelimited)</span>
 		pr_err(&quot;DRHD: handling fault status reg %x\n&quot;, fault_status);
 
 	/* TBD: ignore advanced fault log currently */
<span class="p_chunk">@@ -1600,24 +1603,28 @@</span> <span class="p_context"> irqreturn_t dmar_fault(int irq, void *dev_id)</span>
 		if (!(data &amp; DMA_FRCD_F))
 			break;
 
<span class="p_del">-		fault_reason = dma_frcd_fault_reason(data);</span>
<span class="p_del">-		type = dma_frcd_type(data);</span>
<span class="p_add">+		if (!ratelimited) {</span>
<span class="p_add">+			fault_reason = dma_frcd_fault_reason(data);</span>
<span class="p_add">+			type = dma_frcd_type(data);</span>
 
<span class="p_del">-		data = readl(iommu-&gt;reg + reg +</span>
<span class="p_del">-				fault_index * PRIMARY_FAULT_REG_LEN + 8);</span>
<span class="p_del">-		source_id = dma_frcd_source_id(data);</span>
<span class="p_add">+			data = readl(iommu-&gt;reg + reg +</span>
<span class="p_add">+				     fault_index * PRIMARY_FAULT_REG_LEN + 8);</span>
<span class="p_add">+			source_id = dma_frcd_source_id(data);</span>
<span class="p_add">+</span>
<span class="p_add">+			guest_addr = dmar_readq(iommu-&gt;reg + reg +</span>
<span class="p_add">+					fault_index * PRIMARY_FAULT_REG_LEN);</span>
<span class="p_add">+			guest_addr = dma_frcd_page_addr(guest_addr);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		guest_addr = dmar_readq(iommu-&gt;reg + reg +</span>
<span class="p_del">-				fault_index * PRIMARY_FAULT_REG_LEN);</span>
<span class="p_del">-		guest_addr = dma_frcd_page_addr(guest_addr);</span>
 		/* clear the fault */
 		writel(DMA_FRCD_F, iommu-&gt;reg + reg +
 			fault_index * PRIMARY_FAULT_REG_LEN + 12);
 
 		raw_spin_unlock_irqrestore(&amp;iommu-&gt;register_lock, flag);
 
<span class="p_del">-		dmar_fault_do_one(iommu, type, fault_reason,</span>
<span class="p_del">-				source_id, guest_addr);</span>
<span class="p_add">+		if (!ratelimited)</span>
<span class="p_add">+			dmar_fault_do_one(iommu, type, fault_reason,</span>
<span class="p_add">+					  source_id, guest_addr);</span>
 
 		fault_index++;
 		if (fault_index &gt;= cap_num_fault_regs(iommu-&gt;cap))
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index c52f7ba..0daa31d 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -353,6 +353,13 @@</span> <span class="p_context"> static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs</span>
 		if (irqnr &lt; 16) {
 			gic_write_eoir(irqnr);
 #ifdef CONFIG_SMP
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Unlike GICv2, we don&#39;t need an smp_rmb() here.</span>
<span class="p_add">+			 * The control dependency from gic_read_iar to</span>
<span class="p_add">+			 * the ISB in gic_write_eoir is enough to ensure</span>
<span class="p_add">+			 * that any shared data read by handle_IPI will</span>
<span class="p_add">+			 * be read after the ACK.</span>
<span class="p_add">+			 */</span>
 			handle_IPI(irqnr, regs);
 #else
 			WARN_ONCE(true, &quot;Unexpected SGI received!\n&quot;);
<span class="p_chunk">@@ -372,6 +379,15 @@</span> <span class="p_context"> static void __init gic_dist_init(void)</span>
 	writel_relaxed(0, base + GICD_CTLR);
 	gic_dist_wait_for_rwp();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Configure SPIs as non-secure Group-1. This will only matter</span>
<span class="p_add">+	 * if the GIC only has a single security state. This will not</span>
<span class="p_add">+	 * do the right thing if the kernel is running in secure mode,</span>
<span class="p_add">+	 * but that&#39;s not the intended use case anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 32; i &lt; gic_data.irq_nr; i += 32)</span>
<span class="p_add">+		writel_relaxed(~0, base + GICD_IGROUPR + i / 8);</span>
<span class="p_add">+</span>
 	gic_dist_config(base, gic_data.irq_nr, gic_dist_wait_for_rwp);
 
 	/* Enable distributor with ARE, Group1 */
<span class="p_chunk">@@ -475,6 +491,9 @@</span> <span class="p_context"> static void gic_cpu_init(void)</span>
 
 	rbase = gic_data_rdist_sgi_base();
 
<span class="p_add">+	/* Configure SGIs/PPIs as non-secure Group-1 */</span>
<span class="p_add">+	writel_relaxed(~0, rbase + GICR_IGROUPR0);</span>
<span class="p_add">+</span>
 	gic_cpu_config(rbase, gic_redist_wait_for_rwp);
 
 	/* Give LPIs a spin */
<span class="p_header">diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c</span>
<span class="p_header">index 4dd8826..374b9fa 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic.c</span>
<span class="p_chunk">@@ -278,6 +278,14 @@</span> <span class="p_context"> static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)</span>
 		if (irqnr &lt; 16) {
 			writel_relaxed(irqstat, cpu_base + GIC_CPU_EOI);
 #ifdef CONFIG_SMP
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Ensure any shared data written by the CPU sending</span>
<span class="p_add">+			 * the IPI is read after we&#39;ve read the ACK register</span>
<span class="p_add">+			 * on the GIC.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * Pairs with the write barrier in gic_raise_softirq</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			smp_rmb();</span>
 			handle_IPI(irqnr, regs);
 #endif
 			continue;
<span class="p_header">diff --git a/drivers/mcb/mcb-parse.c b/drivers/mcb/mcb-parse.c</span>
<span class="p_header">index 0049269..b0155b0 100644</span>
<span class="p_header">--- a/drivers/mcb/mcb-parse.c</span>
<span class="p_header">+++ b/drivers/mcb/mcb-parse.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static int chameleon_parse_gdd(struct mcb_bus *bus,</span>
 	mdev-&gt;id = GDD_DEV(reg1);
 	mdev-&gt;rev = GDD_REV(reg1);
 	mdev-&gt;var = GDD_VAR(reg1);
<span class="p_del">-	mdev-&gt;bar = GDD_BAR(reg1);</span>
<span class="p_add">+	mdev-&gt;bar = GDD_BAR(reg2);</span>
 	mdev-&gt;group = GDD_GRP(reg2);
 	mdev-&gt;inst = GDD_INS(reg2);
 
<span class="p_header">diff --git a/drivers/media/pci/cx23885/cx23885-av.c b/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_header">index 877dad8..e7d4406 100644</span>
<span class="p_header">--- a/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_header">+++ b/drivers/media/pci/cx23885/cx23885-av.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> void cx23885_av_work_handler(struct work_struct *work)</span>
 {
 	struct cx23885_dev *dev =
 			   container_of(work, struct cx23885_dev, cx25840_work);
<span class="p_del">-	bool handled;</span>
<span class="p_add">+	bool handled = false;</span>
 
 	v4l2_subdev_call(dev-&gt;sd_cx25840, core, interrupt_service_routine,
 			 PCI_MSK_AV_CORE, &amp;handled);
<span class="p_header">diff --git a/drivers/media/platform/am437x/am437x-vpfe.c b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">index c8447fa..10ed94f 100644</span>
<span class="p_header">--- a/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">+++ b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_chunk">@@ -1046,7 +1046,7 @@</span> <span class="p_context"> static int vpfe_get_ccdc_image_format(struct vpfe_device *vpfe,</span>
 static int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe)
 {
 	enum ccdc_frmfmt frm_fmt = CCDC_FRMFMT_INTERLACED;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	vpfe_dbg(2, vpfe, &quot;vpfe_config_ccdc_image_format\n&quot;);
 
<span class="p_chunk">@@ -1705,7 +1705,7 @@</span> <span class="p_context"> static int vpfe_get_app_input_index(struct vpfe_device *vpfe,</span>
 		sdinfo = &amp;cfg-&gt;sub_devs[i];
 		client = v4l2_get_subdevdata(sdinfo-&gt;sd);
 		if (client-&gt;addr == curr_client-&gt;addr &amp;&amp;
<span class="p_del">-		    client-&gt;adapter-&gt;nr == client-&gt;adapter-&gt;nr) {</span>
<span class="p_add">+		    client-&gt;adapter-&gt;nr == curr_client-&gt;adapter-&gt;nr) {</span>
 			if (vpfe-&gt;current_input &gt;= 1)
 				return -1;
 			*app_input_index = j + vpfe-&gt;current_input;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index 73138a3..da9883a 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -259,7 +259,8 @@</span> <span class="p_context"> static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user</span>
 static int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)
 {
 	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_create_buffers32)) ||
<span class="p_del">-	    copy_to_user(up, kp, offsetof(struct v4l2_create_buffers32, format)))</span>
<span class="p_add">+	    copy_to_user(up, kp, offsetof(struct v4l2_create_buffers32, format)) ||</span>
<span class="p_add">+	    copy_to_user(up-&gt;reserved, kp-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
 		return -EFAULT;
 	return __put_v4l2_format32(&amp;kp-&gt;format, &amp;up-&gt;format);
 }
<span class="p_header">diff --git a/drivers/mfd/intel_quark_i2c_gpio.c b/drivers/mfd/intel_quark_i2c_gpio.c</span>
<span class="p_header">index 1ce1603..340ff40 100644</span>
<span class="p_header">--- a/drivers/mfd/intel_quark_i2c_gpio.c</span>
<span class="p_header">+++ b/drivers/mfd/intel_quark_i2c_gpio.c</span>
<span class="p_chunk">@@ -48,8 +48,6 @@</span> <span class="p_context"></span>
 /* The Quark I2C controller source clock */
 #define INTEL_QUARK_I2C_CLK_HZ	33000000
 
<span class="p_del">-#define INTEL_QUARK_I2C_NCLK	1</span>
<span class="p_del">-</span>
 struct intel_quark_mfd {
 	struct pci_dev		*pdev;
 	struct clk		*i2c_clk;
<span class="p_chunk">@@ -114,37 +112,32 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(pci, intel_quark_mfd_ids);</span>
 static int intel_quark_register_i2c_clk(struct intel_quark_mfd *quark_mfd)
 {
 	struct pci_dev *pdev = quark_mfd-&gt;pdev;
<span class="p_del">-	struct clk_lookup *i2c_clk_lookup;</span>
 	struct clk *i2c_clk;
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	i2c_clk_lookup = devm_kcalloc(&amp;pdev-&gt;dev, INTEL_QUARK_I2C_NCLK,</span>
<span class="p_del">-				      sizeof(*i2c_clk_lookup), GFP_KERNEL);</span>
<span class="p_del">-	if (!i2c_clk_lookup)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	i2c_clk_lookup[0].dev_id = INTEL_QUARK_I2C_CONTROLLER_CLK;</span>
 
 	i2c_clk = clk_register_fixed_rate(&amp;pdev-&gt;dev,
 					  INTEL_QUARK_I2C_CONTROLLER_CLK, NULL,
 					  CLK_IS_ROOT, INTEL_QUARK_I2C_CLK_HZ);
<span class="p_add">+	if (IS_ERR(i2c_clk))</span>
<span class="p_add">+		return PTR_ERR(i2c_clk);</span>
 
<span class="p_del">-	quark_mfd-&gt;i2c_clk_lookup = i2c_clk_lookup;</span>
 	quark_mfd-&gt;i2c_clk = i2c_clk;
<span class="p_add">+	quark_mfd-&gt;i2c_clk_lookup = clkdev_create(i2c_clk, NULL,</span>
<span class="p_add">+						INTEL_QUARK_I2C_CONTROLLER_CLK);</span>
 
<span class="p_del">-	ret = clk_register_clkdevs(i2c_clk, i2c_clk_lookup,</span>
<span class="p_del">-				   INTEL_QUARK_I2C_NCLK);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Fixed clk register failed: %d\n&quot;, ret);</span>
<span class="p_add">+	if (!quark_mfd-&gt;i2c_clk_lookup) {</span>
<span class="p_add">+		clk_unregister(quark_mfd-&gt;i2c_clk);</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;Fixed clk register failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void intel_quark_unregister_i2c_clk(struct pci_dev *pdev)
 {
 	struct intel_quark_mfd *quark_mfd = dev_get_drvdata(&amp;pdev-&gt;dev);
 
<span class="p_del">-	if (!quark_mfd-&gt;i2c_clk || !quark_mfd-&gt;i2c_clk_lookup)</span>
<span class="p_add">+	if (!quark_mfd-&gt;i2c_clk_lookup)</span>
 		return;
 
 	clkdev_drop(quark_mfd-&gt;i2c_clk_lookup);
<span class="p_chunk">@@ -240,26 +233,34 @@</span> <span class="p_context"> static int intel_quark_mfd_probe(struct pci_dev *pdev,</span>
 	quark_mfd = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*quark_mfd), GFP_KERNEL);
 	if (!quark_mfd)
 		return -ENOMEM;
<span class="p_add">+</span>
 	quark_mfd-&gt;pdev = pdev;
<span class="p_add">+	dev_set_drvdata(&amp;pdev-&gt;dev, quark_mfd);</span>
 
 	ret = intel_quark_register_i2c_clk(quark_mfd);
 	if (ret)
 		return ret;
 
<span class="p_del">-	dev_set_drvdata(&amp;pdev-&gt;dev, quark_mfd);</span>
<span class="p_del">-</span>
 	ret = intel_quark_i2c_setup(pdev, &amp;intel_quark_mfd_cells[MFD_I2C_BAR]);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_unregister_i2c_clk;</span>
 
 	ret = intel_quark_gpio_setup(pdev,
 				     &amp;intel_quark_mfd_cells[MFD_GPIO_BAR]);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_unregister_i2c_clk;</span>
 
<span class="p_del">-	return mfd_add_devices(&amp;pdev-&gt;dev, 0, intel_quark_mfd_cells,</span>
<span class="p_del">-			       ARRAY_SIZE(intel_quark_mfd_cells), NULL, 0,</span>
<span class="p_del">-			       NULL);</span>
<span class="p_add">+	ret = mfd_add_devices(&amp;pdev-&gt;dev, 0, intel_quark_mfd_cells,</span>
<span class="p_add">+			      ARRAY_SIZE(intel_quark_mfd_cells), NULL, 0,</span>
<span class="p_add">+			      NULL);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_unregister_i2c_clk;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_unregister_i2c_clk:</span>
<span class="p_add">+	intel_quark_unregister_i2c_clk(pdev);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void intel_quark_mfd_remove(struct pci_dev *pdev)
<span class="p_header">diff --git a/drivers/mfd/lp8788-irq.c b/drivers/mfd/lp8788-irq.c</span>
<span class="p_header">index a87f2b5..ff4f845 100644</span>
<span class="p_header">--- a/drivers/mfd/lp8788-irq.c</span>
<span class="p_header">+++ b/drivers/mfd/lp8788-irq.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static irqreturn_t lp8788_irq_handler(int irq, void *ptr)</span>
 	struct lp8788_irq_data *irqd = ptr;
 	struct lp8788 *lp = irqd-&gt;lp;
 	u8 status[NUM_REGS], addr, mask;
<span class="p_del">-	bool handled;</span>
<span class="p_add">+	bool handled = false;</span>
 	int i;
 
 	if (lp8788_read_multi_bytes(lp, LP8788_INT_1, status, NUM_REGS))
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index b7b3e8e..c30290f 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -269,6 +269,8 @@</span> <span class="p_context"> static int usbtll_omap_probe(struct platform_device *pdev)</span>
 
 		if (IS_ERR(tll-&gt;ch_clk[i]))
 			dev_dbg(dev, &quot;can&#39;t get clock : %s\n&quot;, clkname);
<span class="p_add">+		else</span>
<span class="p_add">+			clk_prepare(tll-&gt;ch_clk[i]);</span>
 	}
 
 	pm_runtime_put_sync(dev);
<span class="p_chunk">@@ -301,9 +303,12 @@</span> <span class="p_context"> static int usbtll_omap_remove(struct platform_device *pdev)</span>
 	tll_dev = NULL;
 	spin_unlock(&amp;tll_lock);
 
<span class="p_del">-	for (i = 0; i &lt; tll-&gt;nch; i++)</span>
<span class="p_del">-		if (!IS_ERR(tll-&gt;ch_clk[i]))</span>
<span class="p_add">+	for (i = 0; i &lt; tll-&gt;nch; i++) {</span>
<span class="p_add">+		if (!IS_ERR(tll-&gt;ch_clk[i])) {</span>
<span class="p_add">+			clk_unprepare(tll-&gt;ch_clk[i]);</span>
 			clk_put(tll-&gt;ch_clk[i]);
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	return 0;
<span class="p_chunk">@@ -420,7 +425,7 @@</span> <span class="p_context"> int omap_tll_enable(struct usbhs_omap_platform_data *pdata)</span>
 			if (IS_ERR(tll-&gt;ch_clk[i]))
 				continue;
 
<span class="p_del">-			r = clk_prepare_enable(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+			r = clk_enable(tll-&gt;ch_clk[i]);</span>
 			if (r) {
 				dev_err(tll_dev,
 				 &quot;Error enabling ch %d clock: %d\n&quot;, i, r);
<span class="p_chunk">@@ -448,7 +453,7 @@</span> <span class="p_context"> int omap_tll_disable(struct usbhs_omap_platform_data *pdata)</span>
 	for (i = 0; i &lt; tll-&gt;nch; i++) {
 		if (omap_usb_mode_needs_tll(pdata-&gt;port_mode[i])) {
 			if (!IS_ERR(tll-&gt;ch_clk[i]))
<span class="p_del">-				clk_disable_unprepare(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+				clk_disable(tll-&gt;ch_clk[i]);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/misc/cxl/fault.c b/drivers/misc/cxl/fault.c</span>
<span class="p_header">index 25a5418..e4080ce 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/fault.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/fault.c</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static void cxl_handle_page_fault(struct cxl_context *ctx,</span>
 	access = _PAGE_PRESENT;
 	if (dsisr &amp; CXL_PSL_DSISR_An_S)
 		access |= _PAGE_RW;
<span class="p_del">-	if ((!ctx-&gt;kernel) || ~(dar &amp; (1ULL &lt;&lt; 63)))</span>
<span class="p_add">+	if ((!ctx-&gt;kernel) || (REGION_ID(dar) == USER_REGION_ID))</span>
 		access |= _PAGE_USER;
 
 	if (dsisr &amp; DSISR_NOHPTE)
<span class="p_header">diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c</span>
<span class="p_header">index 1e42781..eee1a96 100644</span>
<span class="p_header">--- a/drivers/misc/mei/amthif.c</span>
<span class="p_header">+++ b/drivers/misc/mei/amthif.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> int mei_amthif_irq_read_msg(struct mei_cl *cl,</span>
 
 	dev = cl-&gt;dev;
 
<span class="p_del">-	if (dev-&gt;iamthif_state != MEI_IAMTHIF_READING)</span>
<span class="p_add">+	if (dev-&gt;iamthif_state != MEI_IAMTHIF_READING) {</span>
<span class="p_add">+		mei_irq_discard_msg(dev, mei_hdr);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	ret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);
 	if (ret)
<span class="p_header">diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c</span>
<span class="p_header">index 6decbe1..b364117 100644</span>
<span class="p_header">--- a/drivers/misc/mei/client.c</span>
<span class="p_header">+++ b/drivers/misc/mei/client.c</span>
<span class="p_chunk">@@ -1490,6 +1490,10 @@</span> <span class="p_context"> void mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb)</span>
 			wake_up(&amp;cl-&gt;wait);
 
 		break;
<span class="p_add">+	case MEI_FOP_DISCONNECT_RSP:</span>
<span class="p_add">+		mei_io_cb_free(cb);</span>
<span class="p_add">+		mei_cl_set_disconnected(cl);</span>
<span class="p_add">+		break;</span>
 	default:
 		BUG_ON(0);
 	}
<span class="p_header">diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c</span>
<span class="p_header">index a4f2831..070c9bc 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hbm.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hbm.c</span>
<span class="p_chunk">@@ -687,8 +687,7 @@</span> <span class="p_context"> static int mei_hbm_fw_disconnect_req(struct mei_device *dev,</span>
 		cb = mei_io_cb_init(cl, MEI_FOP_DISCONNECT_RSP, NULL);
 		if (!cb)
 			return -ENOMEM;
<span class="p_del">-		cl_dbg(dev, cl, &quot;add disconnect response as first\n&quot;);</span>
<span class="p_del">-		list_add(&amp;cb-&gt;list, &amp;dev-&gt;ctrl_wr_list.list);</span>
<span class="p_add">+		list_add_tail(&amp;cb-&gt;list, &amp;dev-&gt;ctrl_wr_list.list);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c</span>
<span class="p_header">index 3f34052..c879823 100644</span>
<span class="p_header">--- a/drivers/misc/mei/interrupt.c</span>
<span class="p_header">+++ b/drivers/misc/mei/interrupt.c</span>
<span class="p_chunk">@@ -75,7 +75,6 @@</span> <span class="p_context"> static inline int mei_cl_hbm_equal(struct mei_cl *cl,</span>
  * @dev: mei device
  * @hdr: message header
  */
<span class="p_del">-static inline</span>
 void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr)
 {
 	/*
<span class="p_chunk">@@ -180,10 +179,7 @@</span> <span class="p_context"> static int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 		return -EMSGSIZE;
 
 	ret = mei_hbm_cl_disconnect_rsp(dev, cl);
<span class="p_del">-	mei_cl_set_disconnected(cl);</span>
<span class="p_del">-	mei_io_cb_free(cb);</span>
<span class="p_del">-	mei_me_cl_put(cl-&gt;me_cl);</span>
<span class="p_del">-	cl-&gt;me_cl = NULL;</span>
<span class="p_add">+	list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">index bc65fb4..aa040f9 100644</span>
<span class="p_header">--- a/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">+++ b/drivers/misc/mei/mei_dev.h</span>
<span class="p_chunk">@@ -768,6 +768,8 @@</span> <span class="p_context"> bool mei_hbuf_acquire(struct mei_device *dev);</span>
 
 bool mei_write_is_idle(struct mei_device *dev);
 
<span class="p_add">+void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr);</span>
<span class="p_add">+</span>
 #if IS_ENABLED(CONFIG_DEBUG_FS)
 int mei_dbgfs_register(struct mei_device *dev, const char *name);
 void mei_dbgfs_deregister(struct mei_device *dev);
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 88c4e08..18fb6cd 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -2411,11 +2411,12 @@</span> <span class="p_context"> static const struct mmc_fixup blk_fixups[] =</span>
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
<span class="p_del">-	 * Some Micron MMC cards needs longer data read timeout than</span>
<span class="p_del">-	 * indicated in CSD.</span>
<span class="p_add">+	 * Some MMC cards need longer data read timeout than indicated in CSD.</span>
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
<span class="p_add">+	MMC_FIXUP(&quot;008GE0&quot;, CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,</span>
<span class="p_add">+		  MMC_QUIRK_LONG_READ_TIME),</span>
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 2f4503a..1f1c42a 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -866,11 +866,11 @@</span> <span class="p_context"> void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)</span>
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a &quot;reasonably high&quot;
<span class="p_del">-	 * value. For the cards tested, 300ms has proven enough. If necessary,</span>
<span class="p_add">+	 * value. For the cards tested, 600ms has proven enough. If necessary,</span>
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) &amp;&amp; data-&gt;flags &amp; MMC_DATA_READ) {
<span class="p_del">-		data-&gt;timeout_ns = 300000000;</span>
<span class="p_add">+		data-&gt;timeout_ns = 600000000;</span>
 		data-&gt;timeout_clks = 0;
 	}
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index c3c48b1..863b673 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -333,6 +333,9 @@</span> <span class="p_context"> static void mmc_manage_gp_partitions(struct mmc_card *card, u8 *ext_csd)</span>
 	}
 }
 
<span class="p_add">+/* Minimum partition switch timeout in milliseconds */</span>
<span class="p_add">+#define MMC_MIN_PART_SWITCH_TIME	300</span>
<span class="p_add">+</span>
 /*
  * Decode extended CSD.
  */
<span class="p_chunk">@@ -397,6 +400,10 @@</span> <span class="p_context"> static int mmc_decode_ext_csd(struct mmc_card *card, u8 *ext_csd)</span>
 
 		/* EXT_CSD value is in units of 10ms, but we store in ms */
 		card-&gt;ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
<span class="p_add">+		/* Some eMMC set the value too low so set a minimum */</span>
<span class="p_add">+		if (card-&gt;ext_csd.part_time &amp;&amp;</span>
<span class="p_add">+		    card-&gt;ext_csd.part_time &lt; MMC_MIN_PART_SWITCH_TIME)</span>
<span class="p_add">+			card-&gt;ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;</span>
 
 		/* Sleep / awake timeout in 100ns units */
 		if (sa_shift &gt; 0 &amp;&amp; sa_shift &lt;= 0x17)
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index 22d929f..5d4b8a6 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {</span>
 	.chip    = &amp;sdhci_acpi_chip_int,
 	.caps    = MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 		   MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
<span class="p_del">-		   MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+		   MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.caps2   = MMC_CAP2_HC_ERASE_SZ,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {</span>
 		   SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
 	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD |
<span class="p_del">-		   MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+		   MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.pm_caps = MMC_PM_KEEP_POWER,
 	.probe_slot	= sdhci_acpi_sdio_probe_slot,
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sd = {</span>
 	.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
 	.quirks2 = SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON |
 		   SDHCI_QUIRK2_STOP_WITH_TC,
<span class="p_del">-	.caps    = MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+	.caps    = MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.probe_slot	= sdhci_acpi_sd_probe_slot,
 };
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">index 5d2e222..2580f02 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci.c</span>
<span class="p_chunk">@@ -334,7 +334,6 @@</span> <span class="p_context"> static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
 {
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 				 MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
<span class="p_del">-				 MMC_CAP_BUS_WIDTH_TEST |</span>
 				 MMC_CAP_WAIT_WHILE_BUSY;
 	slot-&gt;host-&gt;mmc-&gt;caps2 |= MMC_CAP2_HC_ERASE_SZ;
 	slot-&gt;hw_reset = sdhci_pci_int_hw_reset;
<span class="p_chunk">@@ -350,15 +349,13 @@</span> <span class="p_context"> static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
 static int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)
 {
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |
<span class="p_del">-				 MMC_CAP_BUS_WIDTH_TEST |</span>
 				 MMC_CAP_WAIT_WHILE_BUSY;
 	return 0;
 }
 
 static int byt_sd_probe_slot(struct sdhci_pci_slot *slot)
 {
<span class="p_del">-	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_BUS_WIDTH_TEST |</span>
<span class="p_del">-				 MMC_CAP_WAIT_WHILE_BUSY;</span>
<span class="p_add">+	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_WAIT_WHILE_BUSY;</span>
 	slot-&gt;cd_con_id = NULL;
 	slot-&gt;cd_idx = 0;
 	slot-&gt;cd_override_level = true;
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 51bca03..1c73ba6 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -426,8 +426,25 @@</span> <span class="p_context"> retry:</span>
 						 pnum, vol_id, lnum);
 					err = -EBADMSG;
 				} else {
<span class="p_del">-					err = -EINVAL;</span>
<span class="p_del">-					ubi_ro_mode(ubi);</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * Ending up here in the non-Fastmap case</span>
<span class="p_add">+					 * is a clear bug as the VID header had to</span>
<span class="p_add">+					 * be present at scan time to have it referenced.</span>
<span class="p_add">+					 * With fastmap the story is more complicated.</span>
<span class="p_add">+					 * Fastmap has the mapping info without the need</span>
<span class="p_add">+					 * of a full scan. So the LEB could have been</span>
<span class="p_add">+					 * unmapped, Fastmap cannot know this and keeps</span>
<span class="p_add">+					 * the LEB referenced.</span>
<span class="p_add">+					 * This is valid and works as the layer above UBI</span>
<span class="p_add">+					 * has to do bookkeeping about used/referenced</span>
<span class="p_add">+					 * LEBs in any case.</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					if (ubi-&gt;fast_attach) {</span>
<span class="p_add">+						err = -EBADMSG;</span>
<span class="p_add">+					} else {</span>
<span class="p_add">+						err = -EINVAL;</span>
<span class="p_add">+						ubi_ro_mode(ubi);</span>
<span class="p_add">+					}</span>
 				}
 			}
 			goto out_free;
<span class="p_header">diff --git a/drivers/mtd/ubi/fastmap.c b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">index 4aa2fd8..370a0e2 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_chunk">@@ -1058,6 +1058,7 @@</span> <span class="p_context"> int ubi_scan_fastmap(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 	ubi_msg(ubi, &quot;fastmap WL pool size: %d&quot;,
 		ubi-&gt;fm_wl_pool.max_size);
 	ubi-&gt;fm_disabled = 0;
<span class="p_add">+	ubi-&gt;fast_attach = 1;</span>
 
 	ubi_free_vid_hdr(ubi, vh);
 	kfree(ech);
<span class="p_header">diff --git a/drivers/mtd/ubi/ubi.h b/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">index 2974b67..de1ea2e4 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">+++ b/drivers/mtd/ubi/ubi.h</span>
<span class="p_chunk">@@ -462,6 +462,7 @@</span> <span class="p_context"> struct ubi_debug_info {</span>
  * @fm_eba_sem: allows ubi_update_fastmap() to block EBA table changes
  * @fm_work: fastmap work queue
  * @fm_work_scheduled: non-zero if fastmap work was scheduled
<span class="p_add">+ * @fast_attach: non-zero if UBI was attached by fastmap</span>
  *
  * @used: RB-tree of used physical eraseblocks
  * @erroneous: RB-tree of erroneous used physical eraseblocks
<span class="p_chunk">@@ -570,6 +571,7 @@</span> <span class="p_context"> struct ubi_device {</span>
 	size_t fm_size;
 	struct work_struct fm_work;
 	int fm_work_scheduled;
<span class="p_add">+	int fast_attach;</span>
 
 	/* Wear-leveling sub-system&#39;s stuff */
 	struct rb_root used;
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index 141c2a4..910c12e 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -696,11 +696,17 @@</span> <span class="p_context"> int can_change_mtu(struct net_device *dev, int new_mtu)</span>
 	/* allow change of MTU according to the CANFD ability of the device */
 	switch (new_mtu) {
 	case CAN_MTU:
<span class="p_add">+		/* &#39;CANFD-only&#39; controllers can not switch to CAN_MTU */</span>
<span class="p_add">+		if (priv-&gt;ctrlmode_static &amp; CAN_CTRLMODE_FD)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		priv-&gt;ctrlmode &amp;= ~CAN_CTRLMODE_FD;
 		break;
 
 	case CANFD_MTU:
<span class="p_del">-		if (!(priv-&gt;ctrlmode_supported &amp; CAN_CTRLMODE_FD))</span>
<span class="p_add">+		/* check for potential CANFD ability */</span>
<span class="p_add">+		if (!(priv-&gt;ctrlmode_supported &amp; CAN_CTRLMODE_FD) &amp;&amp;</span>
<span class="p_add">+		    !(priv-&gt;ctrlmode_static &amp; CAN_CTRLMODE_FD))</span>
 			return -EINVAL;
 
 		priv-&gt;ctrlmode |= CAN_CTRLMODE_FD;
<span class="p_chunk">@@ -782,6 +788,35 @@</span> <span class="p_context"> static const struct nla_policy can_policy[IFLA_CAN_MAX + 1] = {</span>
 				= { .len = sizeof(struct can_bittiming_const) },
 };
 
<span class="p_add">+static int can_validate(struct nlattr *tb[], struct nlattr *data[])</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool is_can_fd = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make sure that valid CAN FD configurations always consist of</span>
<span class="p_add">+	 * - nominal/arbitration bittiming</span>
<span class="p_add">+	 * - data bittiming</span>
<span class="p_add">+	 * - control mode with CAN_CTRLMODE_FD set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data[IFLA_CAN_CTRLMODE]) {</span>
<span class="p_add">+		struct can_ctrlmode *cm = nla_data(data[IFLA_CAN_CTRLMODE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		is_can_fd = cm-&gt;flags &amp; cm-&gt;mask &amp; CAN_CTRLMODE_FD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_can_fd) {</span>
<span class="p_add">+		if (!data[IFLA_CAN_BITTIMING] || !data[IFLA_CAN_DATA_BITTIMING])</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data[IFLA_CAN_DATA_BITTIMING]) {</span>
<span class="p_add">+		if (!is_can_fd || !data[IFLA_CAN_BITTIMING])</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int can_changelink(struct net_device *dev,
 			  struct nlattr *tb[], struct nlattr *data[])
 {
<span class="p_chunk">@@ -813,19 +848,31 @@</span> <span class="p_context"> static int can_changelink(struct net_device *dev,</span>
 
 	if (data[IFLA_CAN_CTRLMODE]) {
 		struct can_ctrlmode *cm;
<span class="p_add">+		u32 ctrlstatic;</span>
<span class="p_add">+		u32 maskedflags;</span>
 
 		/* Do not allow changing controller mode while running */
 		if (dev-&gt;flags &amp; IFF_UP)
 			return -EBUSY;
 		cm = nla_data(data[IFLA_CAN_CTRLMODE]);
<span class="p_add">+		ctrlstatic = priv-&gt;ctrlmode_static;</span>
<span class="p_add">+		maskedflags = cm-&gt;flags &amp; cm-&gt;mask;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* check whether provided bits are allowed to be passed */</span>
<span class="p_add">+		if (cm-&gt;mask &amp; ~(priv-&gt;ctrlmode_supported | ctrlstatic))</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* do not check for static fd-non-iso if &#39;fd&#39; is disabled */</span>
<span class="p_add">+		if (!(maskedflags &amp; CAN_CTRLMODE_FD))</span>
<span class="p_add">+			ctrlstatic &amp;= ~CAN_CTRLMODE_FD_NON_ISO;</span>
 
<span class="p_del">-		/* check whether changed bits are allowed to be modified */</span>
<span class="p_del">-		if (cm-&gt;mask &amp; ~priv-&gt;ctrlmode_supported)</span>
<span class="p_add">+		/* make sure static options are provided by configuration */</span>
<span class="p_add">+		if ((maskedflags &amp; ctrlstatic) != ctrlstatic)</span>
 			return -EOPNOTSUPP;
 
 		/* clear bits to be modified and copy the flag values */
 		priv-&gt;ctrlmode &amp;= ~cm-&gt;mask;
<span class="p_del">-		priv-&gt;ctrlmode |= (cm-&gt;flags &amp; cm-&gt;mask);</span>
<span class="p_add">+		priv-&gt;ctrlmode |= maskedflags;</span>
 
 		/* CAN_CTRLMODE_FD can only be set when driver supports FD */
 		if (priv-&gt;ctrlmode &amp; CAN_CTRLMODE_FD)
<span class="p_chunk">@@ -966,6 +1013,7 @@</span> <span class="p_context"> static struct rtnl_link_ops can_link_ops __read_mostly = {</span>
 	.maxtype	= IFLA_CAN_MAX,
 	.policy		= can_policy,
 	.setup		= can_setup,
<span class="p_add">+	.validate	= can_validate,</span>
 	.newlink	= can_newlink,
 	.changelink	= can_changelink,
 	.get_size	= can_get_size,
<span class="p_header">diff --git a/drivers/net/can/m_can/m_can.c b/drivers/net/can/m_can/m_can.c</span>
<span class="p_header">index ef65517..37f15eb 100644</span>
<span class="p_header">--- a/drivers/net/can/m_can/m_can.c</span>
<span class="p_header">+++ b/drivers/net/can/m_can/m_can.c</span>
<span class="p_chunk">@@ -958,7 +958,7 @@</span> <span class="p_context"> static struct net_device *alloc_m_can_dev(void)</span>
 	priv-&gt;can.do_get_berr_counter = m_can_get_berr_counter;
 
 	/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.0.1 */
<span class="p_del">-	priv-&gt;can.ctrlmode = CAN_CTRLMODE_FD_NON_ISO;</span>
<span class="p_add">+	can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);</span>
 
 	/* CAN_CTRLMODE_FD_NON_ISO can not be changed with M_CAN IP v3.0.1 */
 	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ehea/ehea_main.c b/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_header">index 2a0dc12..54efa9a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ehea/ehea_main.c</span>
<span class="p_chunk">@@ -1169,16 +1169,15 @@</span> <span class="p_context"> static void ehea_parse_eqe(struct ehea_adapter *adapter, u64 eqe)</span>
 	ec = EHEA_BMASK_GET(NEQE_EVENT_CODE, eqe);
 	portnum = EHEA_BMASK_GET(NEQE_PORTNUM, eqe);
 	port = ehea_get_port(adapter, portnum);
<span class="p_add">+	if (!port) {</span>
<span class="p_add">+		netdev_err(NULL, &quot;unknown portnum %x\n&quot;, portnum);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	dev = port-&gt;netdev;
 
 	switch (ec) {
 	case EHEA_EC_PORTSTATE_CHG:	/* port state change */
 
<span class="p_del">-		if (!port) {</span>
<span class="p_del">-			netdev_err(dev, &quot;unknown portnum %x\n&quot;, portnum);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		if (EHEA_BMASK_GET(NEQE_PORT_UP, eqe)) {
 			if (!netif_carrier_ok(dev)) {
 				ret = ehea_sense_port_attr(port);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_hmc.c b/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_header">index 9b987cc..a915030 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_hmc.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> i40e_status i40e_add_sd_table_entry(struct i40e_hw *hw,</span>
 	struct i40e_hmc_sd_entry *sd_entry;
 	bool dma_mem_alloc_done = false;
 	struct i40e_dma_mem mem;
<span class="p_del">-	i40e_status ret_code;</span>
<span class="p_add">+	i40e_status ret_code = I40E_SUCCESS;</span>
 	u64 alloc_len;
 
 	if (NULL == hmc_info-&gt;sd_table.sd_entry) {
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 6049086..2405f4e 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -567,11 +567,13 @@</span> <span class="p_context"> static void tun_detach_all(struct net_device *dev)</span>
 	for (i = 0; i &lt; n; i++) {
 		tfile = rtnl_dereference(tun-&gt;tfiles[i]);
 		BUG_ON(!tfile);
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 		--tun-&gt;numqueues;
 	}
 	list_for_each_entry(tfile, &amp;tun-&gt;disabled, next) {
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 	}
<span class="p_chunk">@@ -627,6 +629,7 @@</span> <span class="p_context"> static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filte</span>
 			goto out;
 	}
 	tfile-&gt;queue_index = tun-&gt;numqueues;
<span class="p_add">+	tfile-&gt;socket.sk-&gt;sk_shutdown &amp;= ~RCV_SHUTDOWN;</span>
 	rcu_assign_pointer(tfile-&gt;tun, tun);
 	rcu_assign_pointer(tun-&gt;tfiles[tun-&gt;numqueues], tfile);
 	tun-&gt;numqueues++;
<span class="p_chunk">@@ -1409,9 +1412,6 @@</span> <span class="p_context"> static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,</span>
 	if (!iov_iter_count(to))
 		return 0;
 
<span class="p_del">-	if (tun-&gt;dev-&gt;reg_state != NETREG_REGISTERED)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	/* Read frames from queue */
 	skb = __skb_recv_datagram(tfile-&gt;socket.sk, noblock ? MSG_DONTWAIT : 0,
 				  &amp;peeked, &amp;off, &amp;err);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">index 59496a9..b67cdec 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_chunk">@@ -1214,6 +1214,10 @@</span> <span class="p_context"> int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode)</span>
 		goto err_hif_stop;
 	}
 
<span class="p_add">+	ar-&gt;free_vdev_map = (1LL &lt;&lt; ar-&gt;max_num_vdevs) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;ar-&gt;arvifs);</span>
<span class="p_add">+</span>
 	/* we don&#39;t care about HTT in UTF mode */
 	if (mode == ATH10K_FIRMWARE_MODE_NORMAL) {
 		status = ath10k_htt_setup(&amp;ar-&gt;htt);
<span class="p_chunk">@@ -1227,10 +1231,6 @@</span> <span class="p_context"> int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode)</span>
 	if (status)
 		goto err_hif_stop;
 
<span class="p_del">-	ar-&gt;free_vdev_map = (1LL &lt;&lt; ar-&gt;max_num_vdevs) - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;ar-&gt;arvifs);</span>
<span class="p_del">-</span>
 	return 0;
 
 err_hif_stop:
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/debug.c b/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_header">index 8fa606a..bfb605b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_chunk">@@ -2004,7 +2004,12 @@</span> <span class="p_context"> static ssize_t ath10k_write_pktlog_filter(struct file *file,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (filter &amp;&amp; (filter != ar-&gt;debug.pktlog_filter)) {</span>
<span class="p_add">+	if (filter == ar-&gt;debug.pktlog_filter) {</span>
<span class="p_add">+		ret = count;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (filter) {</span>
 		ret = ath10k_wmi_pdev_pktlog_enable(ar, filter);
 		if (ret) {
 			ath10k_warn(ar, &quot;failed to enable pktlog filter %x: %d\n&quot;,
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index a5ea8a9..fb84cf0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -4194,7 +4194,10 @@</span> <span class="p_context"> static int ath10k_add_interface(struct ieee80211_hw *hw,</span>
 		goto err_vdev_delete;
 	}
 
<span class="p_del">-	if (ar-&gt;cfg_tx_chainmask) {</span>
<span class="p_add">+	/* Configuring number of spatial stream for monitor interface is causing</span>
<span class="p_add">+	 * target assert in qca9888 and qca6174.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ar-&gt;cfg_tx_chainmask &amp;&amp; (vif-&gt;type != NL80211_IFTYPE_MONITOR)) {</span>
 		u16 nss = get_nss_from_chainmask(ar-&gt;cfg_tx_chainmask);
 
 		vdev_param = ar-&gt;wmi.vdev_param-&gt;nss;
<span class="p_chunk">@@ -6120,7 +6123,13 @@</span> <span class="p_context"> ath10k_mac_update_rx_channel(struct ath10k *ar,</span>
 			def = &amp;vifs[0].new_ctx-&gt;def;
 
 		ar-&gt;rx_channel = def-&gt;chan;
<span class="p_del">-	} else if (ctx &amp;&amp; ath10k_mac_num_chanctxs(ar) == 0) {</span>
<span class="p_add">+	} else if ((ctx &amp;&amp; ath10k_mac_num_chanctxs(ar) == 0) ||</span>
<span class="p_add">+		   (ctx &amp;&amp; (ar-&gt;state == ATH10K_STATE_RESTARTED))) {</span>
<span class="p_add">+		/* During driver restart due to firmware assert, since mac80211</span>
<span class="p_add">+		 * already has valid channel context for given radio, channel</span>
<span class="p_add">+		 * context iteration return num_chanctx &gt; 0. So fix rx_channel</span>
<span class="p_add">+		 * when restart is in progress.</span>
<span class="p_add">+		 */</span>
 		ar-&gt;rx_channel = ctx-&gt;def.chan;
 	} else {
 		ar-&gt;rx_channel = NULL;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath5k/led.c b/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_header">index 803030f..6a2a168 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath5k/led.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static const struct pci_device_id ath5k_led_devices[] = {</span>
 	/* HP Compaq CQ60-206US (ddreggors@jumptv.com) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137a), ATH_LED(3, 1) },
 	/* HP Compaq C700 (nitrousnrg@gmail.com) */
<span class="p_del">-	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 1) },</span>
<span class="p_add">+	{ ATH_SDEVICE(PCI_VENDOR_ID_HP, 0x0137b), ATH_LED(3, 0) },</span>
 	/* LiteOn AR5BXB63 (magooz@salug.it) */
 	{ ATH_SDEVICE(PCI_VENDOR_ID_ATHEROS, 0x3067), ATH_LED(3, 0) },
 	/* IBM-specific AR5212 (all others) */
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">index fc6dc52..6a571d8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_chunk">@@ -49,6 +49,10 @@</span> <span class="p_context"> int ath9k_led_blink;</span>
 module_param_named(blink, ath9k_led_blink, int, 0444);
 MODULE_PARM_DESC(blink, &quot;Enable LED blink on activity&quot;);
 
<span class="p_add">+static int ath9k_led_active_high = -1;</span>
<span class="p_add">+module_param_named(led_active_high, ath9k_led_active_high, int, 0444);</span>
<span class="p_add">+MODULE_PARM_DESC(led_active_high, &quot;Invert LED polarity&quot;);</span>
<span class="p_add">+</span>
 static int ath9k_btcoex_enable;
 module_param_named(btcoex_enable, ath9k_btcoex_enable, int, 0444);
 MODULE_PARM_DESC(btcoex_enable, &quot;Enable wifi-BT coexistence&quot;);
<span class="p_chunk">@@ -600,6 +604,9 @@</span> <span class="p_context"> static int ath9k_init_softc(u16 devid, struct ath_softc *sc,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	if (ath9k_led_active_high != -1)</span>
<span class="p_add">+		ah-&gt;config.led_active_high = ath9k_led_active_high == 1;</span>
<span class="p_add">+</span>
 	/*
 	 * Enable WLAN/BT RX Antenna diversity only when:
 	 *
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c</span>
<span class="p_header">index e6fef1b..7cdaf40 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/pci.c</span>
<span class="p_chunk">@@ -28,6 +28,16 @@</span> <span class="p_context"> static const struct pci_device_id ath_pci_id_table[] = {</span>
 	{ PCI_VDEVICE(ATHEROS, 0x0024) }, /* PCI-E */
 	{ PCI_VDEVICE(ATHEROS, 0x0027) }, /* PCI   */
 	{ PCI_VDEVICE(ATHEROS, 0x0029) }, /* PCI   */
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ATH9K_PCOEM</span>
<span class="p_add">+	/* Mini PCI AR9220 MB92 cards: Compex WLM200NX, Wistron DNMA-92 */</span>
<span class="p_add">+	{ PCI_DEVICE_SUB(PCI_VENDOR_ID_ATHEROS,</span>
<span class="p_add">+			 0x0029,</span>
<span class="p_add">+			 PCI_VENDOR_ID_ATHEROS,</span>
<span class="p_add">+			 0x2096),</span>
<span class="p_add">+	  .driver_data = ATH9K_PCI_LED_ACT_HI },</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	{ PCI_VDEVICE(ATHEROS, 0x002A) }, /* PCI-E */
 
 #ifdef CONFIG_ATH9K_PCOEM
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/base.c b/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_header">index 0517a4f..7a40d8d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/base.c</span>
<span class="p_chunk">@@ -1660,9 +1660,9 @@</span> <span class="p_context"> void rtl_watchdog_wq_callback(void *data)</span>
 		if (((rtlpriv-&gt;link_info.num_rx_inperiod +
 		      rtlpriv-&gt;link_info.num_tx_inperiod) &gt; 8) ||
 		    (rtlpriv-&gt;link_info.num_rx_inperiod &gt; 2))
<span class="p_del">-			rtl_lps_enter(hw);</span>
<span class="p_del">-		else</span>
 			rtl_lps_leave(hw);
<span class="p_add">+		else</span>
<span class="p_add">+			rtl_lps_enter(hw);</span>
 	}
 
 	rtlpriv-&gt;link_info.num_rx_inperiod = 0;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/btcoexist/halbtc8723b2ant.c b/drivers/net/wireless/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">index f2b9d11..e85f165 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_chunk">@@ -1203,7 +1203,6 @@</span> <span class="p_context"> static void btc8723b2ant_set_ant_path(struct btc_coexist *btcoexist,</span>
 
 		/* Force GNT_BT to low */
 		btcoexist-&gt;btc_write_1byte_bitmask(btcoexist, 0x765, 0x18, 0x0);
<span class="p_del">-		btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
 
 		if (board_info-&gt;btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT) {
 			/* tell firmware &quot;no antenna inverse&quot; */
<span class="p_chunk">@@ -1211,19 +1210,25 @@</span> <span class="p_context"> static void btc8723b2ant_set_ant_path(struct btc_coexist *btcoexist,</span>
 			h2c_parameter[1] = 1;  /* ext switch type */
 			btcoexist-&gt;btc_fill_h2c(btcoexist, 0x65, 2,
 						h2c_parameter);
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
 		} else {
 			/* tell firmware &quot;antenna inverse&quot; */
 			h2c_parameter[0] = 1;
 			h2c_parameter[1] = 1;  /* ext switch type */
 			btcoexist-&gt;btc_fill_h2c(btcoexist, 0x65, 2,
 						h2c_parameter);
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x280);</span>
 		}
 	}
 
 	/* ext switch setting */
 	if (use_ext_switch) {
 		/* fixed internal switch S1-&gt;WiFi, S0-&gt;BT */
<span class="p_del">-		btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		if (board_info-&gt;btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x280);</span>
<span class="p_add">+</span>
 		switch (antpos_type) {
 		case BTC_ANT_WIFI_AT_MAIN:
 			/* ext switch main at wifi */
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.c b/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_header">index b2791c8..babd149 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_chunk">@@ -965,13 +965,38 @@</span> <span class="p_context"> void exhalbtc_set_chip_type(u8 chip_type)</span>
 	}
 }
 
<span class="p_del">-void exhalbtc_set_ant_num(u8 type, u8 ant_num)</span>
<span class="p_add">+void exhalbtc_set_ant_num(struct rtl_priv *rtlpriv, u8 type, u8 ant_num)</span>
 {
 	if (BT_COEX_ANT_TYPE_PG == type) {
 		gl_bt_coexist.board_info.pg_ant_num = ant_num;
 		gl_bt_coexist.board_info.btdm_ant_num = ant_num;
<span class="p_add">+		/* The antenna position:</span>
<span class="p_add">+		 * Main (default) or Aux for pgAntNum=2 &amp;&amp; btdmAntNum =1.</span>
<span class="p_add">+		 * The antenna position should be determined by</span>
<span class="p_add">+		 * auto-detect mechanism.</span>
<span class="p_add">+		 * The following is assumed to main,</span>
<span class="p_add">+		 * and those must be modified</span>
<span class="p_add">+		 * if y auto-detect mechanism is ready</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((gl_bt_coexist.board_info.pg_ant_num == 2) &amp;&amp;</span>
<span class="p_add">+		    (gl_bt_coexist.board_info.btdm_ant_num == 1))</span>
<span class="p_add">+			gl_bt_coexist.board_info.btdm_ant_pos =</span>
<span class="p_add">+						       BTC_ANTENNA_AT_MAIN_PORT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			gl_bt_coexist.board_info.btdm_ant_pos =</span>
<span class="p_add">+						       BTC_ANTENNA_AT_MAIN_PORT;</span>
 	} else if (BT_COEX_ANT_TYPE_ANTDIV == type) {
 		gl_bt_coexist.board_info.btdm_ant_num = ant_num;
<span class="p_add">+		gl_bt_coexist.board_info.btdm_ant_pos =</span>
<span class="p_add">+						       BTC_ANTENNA_AT_MAIN_PORT;</span>
<span class="p_add">+	} else if (type == BT_COEX_ANT_TYPE_DETECTED) {</span>
<span class="p_add">+		gl_bt_coexist.board_info.btdm_ant_num = ant_num;</span>
<span class="p_add">+		if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;ant_sel == 1)</span>
<span class="p_add">+			gl_bt_coexist.board_info.btdm_ant_pos =</span>
<span class="p_add">+				BTC_ANTENNA_AT_AUX_PORT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			gl_bt_coexist.board_info.btdm_ant_pos =</span>
<span class="p_add">+				BTC_ANTENNA_AT_MAIN_PORT;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.h b/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.h</span>
<span class="p_header">index 0a903ea..f41ca57 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/btcoexist/halbtcoutsrc.h</span>
<span class="p_chunk">@@ -535,7 +535,7 @@</span> <span class="p_context"> void exhalbtc_set_bt_patch_version(u16 bt_hci_version, u16 bt_patch_version);</span>
 void exhalbtc_update_min_bt_rssi(char bt_rssi);
 void exhalbtc_set_bt_exist(bool bt_exist);
 void exhalbtc_set_chip_type(u8 chip_type);
<span class="p_del">-void exhalbtc_set_ant_num(u8 type, u8 ant_num);</span>
<span class="p_add">+void exhalbtc_set_ant_num(struct rtl_priv *rtlpriv, u8 type, u8 ant_num);</span>
 void exhalbtc_display_bt_coex_info(struct btc_coexist *btcoexist);
 void exhalbtc_signal_compensation(struct btc_coexist *btcoexist,
 				  u8 *rssi_wifi, u8 *rssi_bt);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/btcoexist/rtl_btc.c b/drivers/net/wireless/rtlwifi/btcoexist/rtl_btc.c</span>
<span class="p_header">index b9b0cb7..d3fd921 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/btcoexist/rtl_btc.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/btcoexist/rtl_btc.c</span>
<span class="p_chunk">@@ -72,7 +72,10 @@</span> <span class="p_context"> void rtl_btc_init_hal_vars(struct rtl_priv *rtlpriv)</span>
 		 __func__, bt_type);
 	exhalbtc_set_chip_type(bt_type);
 
<span class="p_del">-	exhalbtc_set_ant_num(BT_COEX_ANT_TYPE_PG, ant_num);</span>
<span class="p_add">+	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;ant_sel == 1)</span>
<span class="p_add">+		exhalbtc_set_ant_num(rtlpriv, BT_COEX_ANT_TYPE_DETECTED, 1);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		exhalbtc_set_ant_num(rtlpriv, BT_COEX_ANT_TYPE_PG, ant_num);</span>
 }
 
 void rtl_btc_init_hw_config(struct rtl_priv *rtlpriv)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/pci.c b/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_header">index 7f471bf..5b40480 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/pci.c</span>
<span class="p_chunk">@@ -1573,7 +1573,7 @@</span> <span class="p_context"> int rtl_pci_reset_trx_ring(struct ieee80211_hw *hw)</span>
 							 true,
 							 HW_DESC_TXBUFF_ADDR),
 						 skb-&gt;len, PCI_DMA_TODEVICE);
<span class="p_del">-				kfree_skb(skb);</span>
<span class="p_add">+				dev_kfree_skb_irq(skb);</span>
 				ring-&gt;idx = (ring-&gt;idx + 1) % ring-&gt;entries;
 			}
 			ring-&gt;idx = 0;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">index c983d2f..5a3df91 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_chunk">@@ -2684,6 +2684,7 @@</span> <span class="p_context"> void rtl8723be_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,</span>
 					      bool auto_load_fail, u8 *hwinfo)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
<span class="p_add">+	struct rtl_mod_params *mod_params = rtlpriv-&gt;cfg-&gt;mod_params;</span>
 	u8 value;
 	u32 tmpu_32;
 
<span class="p_chunk">@@ -2702,6 +2703,10 @@</span> <span class="p_context"> void rtl8723be_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,</span>
 		rtlpriv-&gt;btcoexist.btc_info.ant_num = ANT_X2;
 	}
 
<span class="p_add">+	/* override ant_num / ant_path */</span>
<span class="p_add">+	if (mod_params-&gt;ant_sel)</span>
<span class="p_add">+		rtlpriv-&gt;btcoexist.btc_info.ant_num =</span>
<span class="p_add">+			(mod_params-&gt;ant_sel == 1 ? ANT_X2 : ANT_X1);</span>
 }
 
 void rtl8723be_bt_reg_init(struct ieee80211_hw *hw)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723be/sw.c b/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_header">index 9df94b2..8de5626 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723be/sw.c</span>
<span class="p_chunk">@@ -273,6 +273,7 @@</span> <span class="p_context"> static struct rtl_mod_params rtl8723be_mod_params = {</span>
 	.msi_support = false,
 	.disable_watchdog = false,
 	.debug = DBG_EMERG,
<span class="p_add">+	.ant_sel = 0,</span>
 };
 
 static struct rtl_hal_cfg rtl8723be_hal_cfg = {
<span class="p_chunk">@@ -394,6 +395,7 @@</span> <span class="p_context"> module_param_named(fwlps, rtl8723be_mod_params.fwctrl_lps, bool, 0444);</span>
 module_param_named(msi, rtl8723be_mod_params.msi_support, bool, 0444);
 module_param_named(disable_watchdog, rtl8723be_mod_params.disable_watchdog,
 		   bool, 0444);
<span class="p_add">+module_param_named(ant_sel, rtl8723be_mod_params.ant_sel, int, 0444);</span>
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
 MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);
<span class="p_chunk">@@ -402,6 +404,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 0)\n&quot;);</span>
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog,
 		 &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
<span class="p_add">+MODULE_PARM_DESC(ant_sel, &quot;Set to 1 or 2 to force antenna number (default 0)\n&quot;);</span>
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/wifi.h b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">index 0a3570a..d593474 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_chunk">@@ -2237,6 +2237,9 @@</span> <span class="p_context"> struct rtl_mod_params {</span>
 
 	/* default 0: 1 means do not disable interrupts */
 	bool int_clear;
<span class="p_add">+</span>
<span class="p_add">+	/* select antenna */</span>
<span class="p_add">+	int ant_sel;</span>
 };
 
 struct rtl_hal_usbint_cfg {
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index eead54c..5f7cbea 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -1013,6 +1013,9 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,</span>
 	if (i &gt;= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
<span class="p_add">+	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(res-&gt;start))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!pci_mmap_fits(pdev, i, vma, PCI_MMAP_SYSFS)) {
 		WARN(1, &quot;process \&quot;%s\&quot; tried to map 0x%08lx bytes at page 0x%08lx on %s BAR %d (start 0x%16Lx, size 0x%16Lx)\n&quot;,
 			current-&gt;comm, vma-&gt;vm_end-vma-&gt;vm_start, vma-&gt;vm_pgoff,
<span class="p_chunk">@@ -1029,10 +1032,6 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj, struct bin_attribute *attr,</span>
 	pci_resource_to_user(pdev, i, res, &amp;start, &amp;end);
 	vma-&gt;vm_pgoff += start &gt;&gt; PAGE_SHIFT;
 	mmap_type = res-&gt;flags &amp; IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
<span class="p_del">-</span>
<span class="p_del">-	if (res-&gt;flags &amp; IORESOURCE_MEM &amp;&amp; iomem_is_exclusive(start))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	return pci_mmap_page_range(pdev, vma, mmap_type, write_combine);
 }
 
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index 8cb5197..ea55f82 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -176,9 +176,6 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 
<span class="p_del">-	if (dev-&gt;non_compliant_bars)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
<span class="p_chunk">@@ -319,6 +316,9 @@</span> <span class="p_context"> static void pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)</span>
 {
 	unsigned int pos, reg;
 
<span class="p_add">+	if (dev-&gt;non_compliant_bars)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (pos = 0; pos &lt; howmany; pos++) {
 		struct resource *res = &amp;dev-&gt;resource[pos];
 		reg = PCI_BASE_ADDRESS_0 + (pos &lt;&lt; 2);
<span class="p_header">diff --git a/drivers/pinctrl/samsung/pinctrl-exynos5440.c b/drivers/pinctrl/samsung/pinctrl-exynos5440.c</span>
<span class="p_header">index f5619fb..1882353 100644</span>
<span class="p_header">--- a/drivers/pinctrl/samsung/pinctrl-exynos5440.c</span>
<span class="p_header">+++ b/drivers/pinctrl/samsung/pinctrl-exynos5440.c</span>
<span class="p_chunk">@@ -109,6 +109,7 @@</span> <span class="p_context"> struct exynos5440_pmx_func {</span>
  * @nr_groups: number of pin groups available.
  * @pmx_functions: list of pin functions parsed from device tree.
  * @nr_functions: number of pin functions available.
<span class="p_add">+ * @range: gpio range to register with pinctrl</span>
  */
 struct exynos5440_pinctrl_priv_data {
 	void __iomem			*reg_base;
<span class="p_chunk">@@ -119,6 +120,7 @@</span> <span class="p_context"> struct exynos5440_pinctrl_priv_data {</span>
 	unsigned int			nr_groups;
 	const struct exynos5440_pmx_func	*pmx_functions;
 	unsigned int			nr_functions;
<span class="p_add">+	struct pinctrl_gpio_range	range;</span>
 };
 
 /**
<span class="p_chunk">@@ -769,7 +771,6 @@</span> <span class="p_context"> static int exynos5440_pinctrl_register(struct platform_device *pdev,</span>
 	struct pinctrl_desc *ctrldesc;
 	struct pinctrl_dev *pctl_dev;
 	struct pinctrl_pin_desc *pindesc, *pdesc;
<span class="p_del">-	struct pinctrl_gpio_range grange;</span>
 	char *pin_names;
 	int pin, ret;
 
<span class="p_chunk">@@ -827,12 +828,12 @@</span> <span class="p_context"> static int exynos5440_pinctrl_register(struct platform_device *pdev,</span>
 		return PTR_ERR(pctl_dev);
 	}
 
<span class="p_del">-	grange.name = &quot;exynos5440-pctrl-gpio-range&quot;;</span>
<span class="p_del">-	grange.id = 0;</span>
<span class="p_del">-	grange.base = 0;</span>
<span class="p_del">-	grange.npins = EXYNOS5440_MAX_PINS;</span>
<span class="p_del">-	grange.gc = priv-&gt;gc;</span>
<span class="p_del">-	pinctrl_add_gpio_range(pctl_dev, &amp;grange);</span>
<span class="p_add">+	priv-&gt;range.name = &quot;exynos5440-pctrl-gpio-range&quot;;</span>
<span class="p_add">+	priv-&gt;range.id = 0;</span>
<span class="p_add">+	priv-&gt;range.base = 0;</span>
<span class="p_add">+	priv-&gt;range.npins = EXYNOS5440_MAX_PINS;</span>
<span class="p_add">+	priv-&gt;range.gc = priv-&gt;gc;</span>
<span class="p_add">+	pinctrl_add_gpio_range(pctl_dev, &amp;priv-&gt;range);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/platform/x86/dell-rbtn.c b/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_header">index cd410e3..d33e9ad 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> struct rbtn_data {</span>
 	enum rbtn_type type;
 	struct rfkill *rfkill;
 	struct input_dev *input_dev;
<span class="p_add">+	bool suspended;</span>
 };
 
 
<span class="p_chunk">@@ -220,9 +221,55 @@</span> <span class="p_context"> static const struct acpi_device_id rbtn_ids[] = {</span>
 	{ &quot;&quot;, 0 },
 };
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+static void ACPI_SYSTEM_XFACE rbtn_clear_suspended_flag(void *context)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = context;</span>
<span class="p_add">+</span>
<span class="p_add">+	rbtn_data-&gt;suspended = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rbtn_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_device *device = to_acpi_device(dev);</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = acpi_driver_data(device);</span>
<span class="p_add">+</span>
<span class="p_add">+	rbtn_data-&gt;suspended = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rbtn_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_device *device = to_acpi_device(dev);</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = acpi_driver_data(device);</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Upon resume, some BIOSes send an ACPI notification thet triggers</span>
<span class="p_add">+	 * an unwanted input event. In order to ignore it, we use a flag</span>
<span class="p_add">+	 * that we set at suspend and clear once we have received the extra</span>
<span class="p_add">+	 * ACPI notification. Since ACPI notifications are delivered</span>
<span class="p_add">+	 * asynchronously to drivers, we clear the flag from the workqueue</span>
<span class="p_add">+	 * used to deliver the notifications. This should be enough</span>
<span class="p_add">+	 * to have the flag cleared only after we received the extra</span>
<span class="p_add">+	 * notification, if any.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	status = acpi_os_execute(OSL_NOTIFY_HANDLER,</span>
<span class="p_add">+			 rbtn_clear_suspended_flag, rbtn_data);</span>
<span class="p_add">+	if (ACPI_FAILURE(status))</span>
<span class="p_add">+		rbtn_clear_suspended_flag(rbtn_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(rbtn_pm_ops, rbtn_suspend, rbtn_resume);</span>
<span class="p_add">+</span>
 static struct acpi_driver rbtn_driver = {
 	.name = &quot;dell-rbtn&quot;,
 	.ids = rbtn_ids,
<span class="p_add">+	.drv.pm = &amp;rbtn_pm_ops,</span>
 	.ops = {
 		.add = rbtn_add,
 		.remove = rbtn_remove,
<span class="p_chunk">@@ -384,6 +431,15 @@</span> <span class="p_context"> static void rbtn_notify(struct acpi_device *device, u32 event)</span>
 {
 	struct rbtn_data *rbtn_data = device-&gt;driver_data;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some BIOSes send a notification at resume.</span>
<span class="p_add">+	 * Ignore it to prevent unwanted input events.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rbtn_data-&gt;suspended) {</span>
<span class="p_add">+		dev_dbg(&amp;device-&gt;dev, &quot;ACPI notification ignored\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (event != 0x80) {
 		dev_info(&amp;device-&gt;dev, &quot;Received unknown event (0x%x)\n&quot;,
 			 event);
<span class="p_header">diff --git a/drivers/power/ipaq_micro_battery.c b/drivers/power/ipaq_micro_battery.c</span>
<span class="p_header">index f03014e..65e9921 100644</span>
<span class="p_header">--- a/drivers/power/ipaq_micro_battery.c</span>
<span class="p_header">+++ b/drivers/power/ipaq_micro_battery.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int micro_batt_probe(struct platform_device *pdev)</span>
 	return 0;
 
 ac_err:
<span class="p_del">-	power_supply_unregister(micro_ac_power);</span>
<span class="p_add">+	power_supply_unregister(micro_batt_power);</span>
 batt_err:
 	cancel_delayed_work_sync(&amp;mb-&gt;update);
 	destroy_workqueue(mb-&gt;wq);
<span class="p_header">diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_header">index 18c9c06..3e8e92b 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"> enum {</span>
 #define AAC_INT_MODE_MSI		(1&lt;&lt;1)
 #define AAC_INT_MODE_AIF		(1&lt;&lt;2)
 #define AAC_INT_MODE_SYNC		(1&lt;&lt;3)
<span class="p_add">+#define AAC_INT_MODE_MSIX		(1&lt;&lt;16)</span>
 
 #define AAC_INT_ENABLE_TYPE1_INTX	0xfffffffb
 #define AAC_INT_ENABLE_TYPE1_MSIX	0xfffffffa
<span class="p_header">diff --git a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c</span>
<span class="p_header">index 45db84a..e736ecb 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/comminit.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/comminit.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/blkdev.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
<span class="p_chunk">@@ -49,6 +50,20 @@</span> <span class="p_context"> struct aac_common aac_config = {</span>
 	.irq_mod = 1
 };
 
<span class="p_add">+static inline int aac_is_msix_mode(struct aac_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 status;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = src_readl(dev, MUnit.OMR);</span>
<span class="p_add">+	return (status &amp; AAC_INT_MODE_MSIX);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void aac_change_to_intx(struct aac_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	aac_src_access_devreg(dev, AAC_DISABLE_MSIX);</span>
<span class="p_add">+	aac_src_access_devreg(dev, AAC_ENABLE_INTX);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int aac_alloc_comm(struct aac_dev *dev, void **commaddr, unsigned long commsize, unsigned long commalign)
 {
 	unsigned char *base;
<span class="p_chunk">@@ -358,6 +373,15 @@</span> <span class="p_context"> struct aac_dev *aac_init_adapter(struct aac_dev *dev)</span>
 	dev-&gt;comm_interface = AAC_COMM_PRODUCER;
 	dev-&gt;raw_io_interface = dev-&gt;raw_io_64 = 0;
 
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Enable INTX mode, if not done already Enabled</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (aac_is_msix_mode(dev)) {</span>
<span class="p_add">+		aac_change_to_intx(dev);</span>
<span class="p_add">+		dev_info(&amp;dev-&gt;pdev-&gt;dev, &quot;Changed firmware to INTX mode&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((!aac_adapter_sync_cmd(dev, GET_ADAPTER_PROPERTIES,
 		0, 0, 0, 0, 0, 0,
 		status+0, status+1, status+2, status+3, NULL)) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">index 4b79d95..9410ffe 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_chunk">@@ -611,10 +611,10 @@</span> <span class="p_context"> int aac_fib_send(u16 command, struct fib *fibptr, unsigned long size,</span>
 					}
 					return -EFAULT;
 				}
<span class="p_del">-				/* We used to udelay() here but that absorbed</span>
<span class="p_del">-				 * a CPU when a timeout occured. Not very</span>
<span class="p_del">-				 * useful. */</span>
<span class="p_del">-				cpu_relax();</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Allow other processes / CPUS to use core</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				schedule();</span>
 			}
 		} else if (down_interruptible(&amp;fibptr-&gt;event_wait)) {
 			/* Do nothing ... satisfy
<span class="p_chunk">@@ -1999,6 +1999,10 @@</span> <span class="p_context"> int aac_command_thread(void *data)</span>
 		if (difference &lt;= 0)
 			difference = 1;
 		set_current_state(TASK_INTERRUPTIBLE);
<span class="p_add">+</span>
<span class="p_add">+		if (kthread_should_stop())</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		schedule_timeout(difference);
 
 		if (kthread_should_stop())
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index f9f3f82..f16829f 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> static void scsi_target_destroy(struct scsi_target *starget)</span>
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
 	unsigned long flags;
 
<span class="p_add">+	BUG_ON(starget-&gt;state == STARGET_DEL);</span>
 	starget-&gt;state = STARGET_DEL;
 	transport_destroy_device(dev);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index 168a509..64f11fa 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1148,18 +1148,18 @@</span> <span class="p_context"> static void __scsi_remove_target(struct scsi_target *starget)</span>
 void scsi_remove_target(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
<span class="p_del">-	struct scsi_target *starget, *last_target = NULL;</span>
<span class="p_add">+	struct scsi_target *starget;</span>
 	unsigned long flags;
 
 restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_for_each_entry(starget, &amp;shost-&gt;__targets, siblings) {
 		if (starget-&gt;state == STARGET_DEL ||
<span class="p_del">-		    starget == last_target)</span>
<span class="p_add">+		    starget-&gt;state == STARGET_REMOVE)</span>
 			continue;
 		if (starget-&gt;dev.parent == dev || &amp;starget-&gt;dev == dev) {
 			kref_get(&amp;starget-&gt;reap_ref);
<span class="p_del">-			last_target = starget;</span>
<span class="p_add">+			starget-&gt;state = STARGET_REMOVE;</span>
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 			__scsi_remove_target(starget);
 			scsi_target_reap(starget);
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_header">index 94078118..3be1096 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_chunk">@@ -567,14 +567,17 @@</span> <span class="p_context"> static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)</span>
 	struct comedi_isadma_desc *desc;
 	int i;
 
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_STATUS);	/* disable conversions */</span>
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */</span>
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_del">-		desc = &amp;dma-&gt;desc[i];</span>
<span class="p_del">-		if (desc-&gt;chan)</span>
<span class="p_del">-			comedi_isadma_disable(desc-&gt;chan);</span>
<span class="p_add">+	/* disable and stop conversions */</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_STATUS);</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_B);</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_A);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dma) {</span>
<span class="p_add">+		for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+			desc = &amp;dma-&gt;desc[i];</span>
<span class="p_add">+			if (desc-&gt;chan)</span>
<span class="p_add">+				comedi_isadma_disable(desc-&gt;chan);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -934,13 +937,14 @@</span> <span class="p_context"> static void das1800_ai_setup_dma(struct comedi_device *dev,</span>
 {
 	struct das1800_private *devpriv = dev-&gt;private;
 	struct comedi_isadma *dma = devpriv-&gt;dma;
<span class="p_del">-	struct comedi_isadma_desc *desc = &amp;dma-&gt;desc[0];</span>
<span class="p_add">+	struct comedi_isadma_desc *desc;</span>
 	unsigned int bytes;
 
 	if ((devpriv-&gt;irq_dma_bits &amp; DMA_ENABLED) == 0)
 		return;
 
 	dma-&gt;cur_dma = 0;
<span class="p_add">+	desc = &amp;dma-&gt;desc[0];</span>
 
 	/* determine a dma transfer size to fill buffer in 0.3 sec */
 	bytes = das1800_ai_transfer_size(dev, s, desc-&gt;maxsize, 300000000);
<span class="p_header">diff --git a/drivers/thunderbolt/eeprom.c b/drivers/thunderbolt/eeprom.c</span>
<span class="p_header">index 0dde34e..545c60c 100644</span>
<span class="p_header">--- a/drivers/thunderbolt/eeprom.c</span>
<span class="p_header">+++ b/drivers/thunderbolt/eeprom.c</span>
<span class="p_chunk">@@ -444,6 +444,7 @@</span> <span class="p_context"> int tb_drom_read(struct tb_switch *sw)</span>
 	return tb_drom_parse_entries(sw);
 err:
 	kfree(sw-&gt;drom);
<span class="p_add">+	sw-&gt;drom = NULL;</span>
 	return -EIO;
 
 }
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index 382d3fc..25444a1 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -2045,7 +2045,9 @@</span> <span class="p_context"> static void gsm_cleanup_mux(struct gsm_mux *gsm)</span>
 		}
 	}
 	spin_unlock(&amp;gsm_mux_lock);
<span class="p_del">-	WARN_ON(i == MAX_MUX);</span>
<span class="p_add">+	/* open failed before registering =&gt; nothing to do */</span>
<span class="p_add">+	if (i == MAX_MUX)</span>
<span class="p_add">+		return;</span>
 
 	/* In theory disconnecting DLCI 0 is sufficient but for some
 	   modems this is apparently not the case. */
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index bbc4ce6..644ddb8 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,</span>
 	add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);
 
 	for (;;) {
<span class="p_del">-		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		/* set bits for operations that won&#39;t block */
 		if (n_hdlc-&gt;rx_buf_list.head)
 			mask |= POLLIN | POLLRDNORM;	/* readable */
<span class="p_del">-		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags))</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index a0398a8..a717fdb 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> static void n_tty_kick_worker(struct tty_struct *tty)</span>
 		 */
 		WARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &amp;tty-&gt;flags),
 			       &quot;scheduling buffer work for halted ldisc\n&quot;);
<span class="p_del">-		queue_work(system_unbound_wq, &amp;tty-&gt;port-&gt;buf.work);</span>
<span class="p_add">+		tty_buffer_restart_work(tty-&gt;port);</span>
 	}
 }
 
<span class="p_chunk">@@ -1959,18 +1959,6 @@</span> <span class="p_context"> static inline int input_available_p(struct tty_struct *tty, int poll)</span>
 		return ldata-&gt;commit_head - ldata-&gt;read_tail &gt;= amt;
 }
 
<span class="p_del">-static inline int check_other_done(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int done = test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags);</span>
<span class="p_del">-	if (done) {</span>
<span class="p_del">-		/* paired with cmpxchg() in check_other_closed(); ensures</span>
<span class="p_del">-		 * read buffer head index is not stale</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		smp_mb__after_atomic();</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return done;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  *	copy_from_read_buf	-	copy read data directly
  *	@tty: terminal device
<span class="p_chunk">@@ -2188,7 +2176,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 	unsigned char __user *b = buf;
 	DEFINE_WAIT_FUNC(wait, woken_wake_function);
<span class="p_del">-	int c, done;</span>
<span class="p_add">+	int c;</span>
 	int minimum, time;
 	ssize_t retval = 0;
 	long timeout;
<span class="p_chunk">@@ -2256,32 +2244,35 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 		    ((minimum - (b - buf)) &gt;= 1))
 			ldata-&gt;minimum_to_wake = (minimum - (b - buf));
 
<span class="p_del">-		done = check_other_done(tty);</span>
<span class="p_del">-</span>
 		if (!input_available_p(tty, 0)) {
<span class="p_del">-			if (done) {</span>
<span class="p_del">-				retval = -EIO;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tty_hung_up_p(file))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			if (!timeout)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			if (file-&gt;f_flags &amp; O_NONBLOCK) {</span>
<span class="p_del">-				retval = -EAGAIN;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (signal_pending(current)) {</span>
<span class="p_del">-				retval = -ERESTARTSYS;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
 			up_read(&amp;tty-&gt;termios_rwsem);
<span class="p_add">+			tty_buffer_flush_work(tty-&gt;port);</span>
<span class="p_add">+			down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+			if (!input_available_p(tty, 0)) {</span>
<span class="p_add">+				if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+					retval = -EIO;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (tty_hung_up_p(file))</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				if (!timeout)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				if (file-&gt;f_flags &amp; O_NONBLOCK) {</span>
<span class="p_add">+					retval = -EAGAIN;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (signal_pending(current)) {</span>
<span class="p_add">+					retval = -ERESTARTSYS;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				up_read(&amp;tty-&gt;termios_rwsem);</span>
 
<span class="p_del">-			timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_del">-					     timeout);</span>
<span class="p_add">+				timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_add">+						timeout);</span>
 
<span class="p_del">-			down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+				down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
 		}
 
 		if (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) {
<span class="p_chunk">@@ -2463,12 +2454,17 @@</span> <span class="p_context"> static unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,</span>
 
 	poll_wait(file, &amp;tty-&gt;read_wait, wait);
 	poll_wait(file, &amp;tty-&gt;write_wait, wait);
<span class="p_del">-	if (check_other_done(tty))</span>
<span class="p_del">-		mask |= POLLHUP;</span>
 	if (input_available_p(tty, 1))
 		mask |= POLLIN | POLLRDNORM;
<span class="p_add">+	else {</span>
<span class="p_add">+		tty_buffer_flush_work(tty-&gt;port);</span>
<span class="p_add">+		if (input_available_p(tty, 1))</span>
<span class="p_add">+			mask |= POLLIN | POLLRDNORM;</span>
<span class="p_add">+	}</span>
 	if (tty-&gt;packet &amp;&amp; tty-&gt;link-&gt;ctrl_status)
 		mask |= POLLPRI | POLLIN | POLLRDNORM;
<span class="p_add">+	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_add">+		mask |= POLLHUP;</span>
 	if (tty_hung_up_p(file))
 		mask |= POLLHUP;
 	if (!(mask &amp; (POLLHUP | POLLIN | POLLRDNORM))) {
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index 254c183..b1f78aa 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static void pty_close(struct tty_struct *tty, struct file *filp)</span>
 	if (!tty-&gt;link)
 		return;
 	set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	tty_flip_buffer_push(tty-&gt;link-&gt;port);</span>
<span class="p_add">+	wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait);</span>
 	wake_up_interruptible(&amp;tty-&gt;link-&gt;write_wait);
 	if (tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags);
<span class="p_chunk">@@ -242,9 +242,7 @@</span> <span class="p_context"> static int pty_open(struct tty_struct *tty, struct file *filp)</span>
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);
<span class="p_del">-	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */</span>
 	clear_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	clear_bit(TTY_OTHER_DONE, &amp;tty-&gt;link-&gt;flags);</span>
 	set_bit(TTY_THROTTLED, &amp;tty-&gt;flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 78aeb11..9850bbf 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -1402,6 +1402,9 @@</span> <span class="p_context"> byt_set_termios(struct uart_port *p, struct ktermios *termios,</span>
 	unsigned long m, n;
 	u32 reg;
 
<span class="p_add">+	/* Gracefully handle the B0 case: fall back to B9600 */</span>
<span class="p_add">+	fuart = fuart ? fuart : 9600 * 16;</span>
<span class="p_add">+</span>
 	/* Get Fuart closer to Fref */
 	fuart *= rounddown_pow_of_two(fref / fuart);
 
<span class="p_header">diff --git a/drivers/tty/serial/ucc_uart.c b/drivers/tty/serial/ucc_uart.c</span>
<span class="p_header">index 7d2532b..100c241 100644</span>
<span class="p_header">--- a/drivers/tty/serial/ucc_uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/ucc_uart.c</span>
<span class="p_chunk">@@ -1478,6 +1478,9 @@</span> <span class="p_context"> static const struct of_device_id ucc_uart_match[] = {</span>
 		.type = &quot;serial&quot;,
 		.compatible = &quot;ucc_uart&quot;,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;fsl,t1040-ucc-uart&quot;,</span>
<span class="p_add">+	},</span>
 	{},
 };
 MODULE_DEVICE_TABLE(of, ucc_uart_match);
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 6059177..d7b9a52 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -37,29 +37,6 @@</span> <span class="p_context"></span>
 
 #define TTY_BUFFER_PAGE	(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) &amp; ~0xFF)
 
<span class="p_del">-/*</span>
<span class="p_del">- * If all tty flip buffers have been processed by flush_to_ldisc() or</span>
<span class="p_del">- * dropped by tty_buffer_flush(), check if the linked pty has been closed.</span>
<span class="p_del">- * If so, wake the reader/poll to process</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void check_other_closed(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags, old;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* transition from TTY_OTHER_CLOSED =&gt; TTY_OTHER_DONE must be atomic */</span>
<span class="p_del">-	for (flags = ACCESS_ONCE(tty-&gt;flags);</span>
<span class="p_del">-	     test_bit(TTY_OTHER_CLOSED, &amp;flags);</span>
<span class="p_del">-	     ) {</span>
<span class="p_del">-		old = flags;</span>
<span class="p_del">-		__set_bit(TTY_OTHER_DONE, &amp;flags);</span>
<span class="p_del">-		flags = cmpxchg(&amp;tty-&gt;flags, old, flags);</span>
<span class="p_del">-		if (old == flags) {</span>
<span class="p_del">-			wake_up_interruptible(&amp;tty-&gt;read_wait);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  *	tty_buffer_lock_exclusive	-	gain exclusive access to buffer
  *	tty_buffer_unlock_exclusive	-	release exclusive access
<span class="p_chunk">@@ -251,8 +228,6 @@</span> <span class="p_context"> void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)</span>
 	if (ld &amp;&amp; ld-&gt;ops-&gt;flush_buffer)
 		ld-&gt;ops-&gt;flush_buffer(tty);
 
<span class="p_del">-	check_other_closed(tty);</span>
<span class="p_del">-</span>
 	atomic_dec(&amp;buf-&gt;priority);
 	mutex_unlock(&amp;buf-&gt;lock);
 }
<span class="p_chunk">@@ -496,10 +471,8 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 		smp_rmb();
 		count = head-&gt;commit - head-&gt;read;
 		if (!count) {
<span class="p_del">-			if (next == NULL) {</span>
<span class="p_del">-				check_other_closed(tty);</span>
<span class="p_add">+			if (next == NULL)</span>
 				break;
<span class="p_del">-			}</span>
 			buf-&gt;head = next;
 			tty_buffer_free(port, head);
 			continue;
<span class="p_chunk">@@ -577,3 +550,18 @@</span> <span class="p_context"> void tty_buffer_set_lock_subclass(struct tty_port *port)</span>
 {
 	lockdep_set_subclass(&amp;port-&gt;buf.lock, TTY_LOCK_SLAVE);
 }
<span class="p_add">+</span>
<span class="p_add">+bool tty_buffer_restart_work(struct tty_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return queue_work(system_unbound_wq, &amp;port-&gt;buf.work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool tty_buffer_cancel_work(struct tty_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cancel_work_sync(&amp;port-&gt;buf.work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void tty_buffer_flush_work(struct tty_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_work(&amp;port-&gt;buf.work);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index d5f54a1..876def68 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -1690,7 +1690,7 @@</span> <span class="p_context"> static void release_tty(struct tty_struct *tty, int idx)</span>
 	tty-&gt;port-&gt;itty = NULL;
 	if (tty-&gt;link)
 		tty-&gt;link-&gt;port-&gt;itty = NULL;
<span class="p_del">-	cancel_work_sync(&amp;tty-&gt;port-&gt;buf.work);</span>
<span class="p_add">+	tty_buffer_cancel_work(tty-&gt;port);</span>
 
 	tty_kref_put(tty-&gt;link);
 	tty_kref_put(tty);
<span class="p_header">diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c</span>
<span class="p_header">index 40b3183..892affc 100644</span>
<span class="p_header">--- a/drivers/tty/tty_port.c</span>
<span class="p_header">+++ b/drivers/tty/tty_port.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(tty_port_free_xmit_buf);</span>
  */
 void tty_port_destroy(struct tty_port *port)
 {
<span class="p_del">-	cancel_work_sync(&amp;port-&gt;buf.work);</span>
<span class="p_add">+	tty_buffer_cancel_work(port);</span>
 	tty_buffer_free_all(port);
 }
 EXPORT_SYMBOL(tty_port_destroy);
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 4462d16..cf20282 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -3583,9 +3583,10 @@</span> <span class="p_context"> static int do_register_con_driver(const struct consw *csw, int first, int last)</span>
 		goto err;
 
 	desc = csw-&gt;con_startup();
<span class="p_del">-</span>
<span class="p_del">-	if (!desc)</span>
<span class="p_add">+	if (!desc) {</span>
<span class="p_add">+		retval = -ENODEV;</span>
 		goto err;
<span class="p_add">+	}</span>
 
 	retval = -EINVAL;
 
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index 7792c0e..68323c2 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -283,7 +283,7 @@</span> <span class="p_context"> static int usb_probe_interface(struct device *dev)</span>
 	struct usb_device *udev = interface_to_usbdev(intf);
 	const struct usb_device_id *id;
 	int error = -ENODEV;
<span class="p_del">-	int lpm_disable_error;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	dev_dbg(dev, &quot;%s\n&quot;, __func__);
 
<span class="p_chunk">@@ -331,12 +331,14 @@</span> <span class="p_context"> static int usb_probe_interface(struct device *dev)</span>
 	 * setting during probe, that should also be fine.  usb_set_interface()
 	 * will attempt to disable LPM, and fail if it can&#39;t disable it.
 	 */
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_del">-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_del">-		dev_err(&amp;intf-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_del">-				__func__, driver-&gt;name);</span>
<span class="p_del">-		error = lpm_disable_error;</span>
<span class="p_del">-		goto err;</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+		if (lpm_disable_error) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_add">+					__func__, driver-&gt;name);</span>
<span class="p_add">+			error = lpm_disable_error;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Carry out a deferred switch to altsetting 0 */
<span class="p_chunk">@@ -386,7 +388,8 @@</span> <span class="p_context"> static int usb_unbind_interface(struct device *dev)</span>
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct usb_host_endpoint *ep, **eps = NULL;
 	struct usb_device *udev;
<span class="p_del">-	int i, j, error, r, lpm_disable_error;</span>
<span class="p_add">+	int i, j, error, r;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
<span class="p_chunk">@@ -394,12 +397,13 @@</span> <span class="p_context"> static int usb_unbind_interface(struct device *dev)</span>
 	udev = interface_to_usbdev(intf);
 	error = usb_autoresume_device(udev);
 
<span class="p_del">-	/* Hub-initiated LPM policy may change, so attempt to disable LPM until</span>
<span class="p_add">+	/* If hub-initiated LPM policy may change, attempt to disable LPM until</span>
 	 * the driver is unbound.  If LPM isn&#39;t disabled, that&#39;s fine because it
 	 * wouldn&#39;t be enabled unless all the bound interfaces supported
 	 * hub-initiated LPM.
 	 */
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm)</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
 
 	/*
 	 * Terminate all URBs for this interface unless the driver
<span class="p_chunk">@@ -502,7 +506,7 @@</span> <span class="p_context"> int usb_driver_claim_interface(struct usb_driver *driver,</span>
 	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
<span class="p_del">-	int lpm_disable_error;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	if (!iface)
 		return -ENODEV;
<span class="p_chunk">@@ -519,12 +523,14 @@</span> <span class="p_context"> int usb_driver_claim_interface(struct usb_driver *driver,</span>
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
<span class="p_del">-	/* Disable LPM until this driver is bound. */</span>
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_del">-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_del">-		dev_err(&amp;iface-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_del">-				__func__, driver-&gt;name);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	/* See the comment about disabling LPM in usb_probe_interface(). */</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+		if (lpm_disable_error) {</span>
<span class="p_add">+			dev_err(&amp;iface-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_add">+					__func__, driver-&gt;name);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Claimed interfaces are initially inactive (suspended) and
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index cbcd092..935175d 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -915,7 +915,7 @@</span> <span class="p_context"> static void usb_bus_init (struct usb_bus *bus)</span>
 	bus-&gt;bandwidth_allocated = 0;
 	bus-&gt;bandwidth_int_reqs  = 0;
 	bus-&gt;bandwidth_isoc_reqs = 0;
<span class="p_del">-	mutex_init(&amp;bus-&gt;usb_address0_mutex);</span>
<span class="p_add">+	mutex_init(&amp;bus-&gt;devnum_next_mutex);</span>
 
 	INIT_LIST_HEAD (&amp;bus-&gt;bus_list);
 }
<span class="p_chunk">@@ -2446,6 +2446,14 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		return NULL;
 	}
 	if (primary_hcd == NULL) {
<span class="p_add">+		hcd-&gt;address0_mutex = kmalloc(sizeof(*hcd-&gt;address0_mutex),</span>
<span class="p_add">+				GFP_KERNEL);</span>
<span class="p_add">+		if (!hcd-&gt;address0_mutex) {</span>
<span class="p_add">+			kfree(hcd);</span>
<span class="p_add">+			dev_dbg(dev, &quot;hcd address0 mutex alloc failed\n&quot;);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mutex_init(hcd-&gt;address0_mutex);</span>
 		hcd-&gt;bandwidth_mutex = kmalloc(sizeof(*hcd-&gt;bandwidth_mutex),
 				GFP_KERNEL);
 		if (!hcd-&gt;bandwidth_mutex) {
<span class="p_chunk">@@ -2457,6 +2465,7 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		dev_set_drvdata(dev, hcd);
 	} else {
 		mutex_lock(&amp;usb_port_peer_mutex);
<span class="p_add">+		hcd-&gt;address0_mutex = primary_hcd-&gt;address0_mutex;</span>
 		hcd-&gt;bandwidth_mutex = primary_hcd-&gt;bandwidth_mutex;
 		hcd-&gt;primary_hcd = primary_hcd;
 		primary_hcd-&gt;primary_hcd = primary_hcd;
<span class="p_chunk">@@ -2523,8 +2532,10 @@</span> <span class="p_context"> static void hcd_release(struct kref *kref)</span>
 	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
 
 	mutex_lock(&amp;usb_port_peer_mutex);
<span class="p_del">-	if (usb_hcd_is_primary_hcd(hcd))</span>
<span class="p_add">+	if (usb_hcd_is_primary_hcd(hcd)) {</span>
<span class="p_add">+		kfree(hcd-&gt;address0_mutex);</span>
 		kfree(hcd-&gt;bandwidth_mutex);
<span class="p_add">+	}</span>
 	if (hcd-&gt;shared_hcd) {
 		struct usb_hcd *peer = hcd-&gt;shared_hcd;
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 6c4fe67..be65a94 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2067,7 +2067,7 @@</span> <span class="p_context"> static void choose_devnum(struct usb_device *udev)</span>
 	struct usb_bus	*bus = udev-&gt;bus;
 
 	/* be safe when more hub events are proceed in parallel */
<span class="p_del">-	mutex_lock(&amp;bus-&gt;usb_address0_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;bus-&gt;devnum_next_mutex);</span>
 	if (udev-&gt;wusb) {
 		devnum = udev-&gt;portnum + 1;
 		BUG_ON(test_bit(devnum, bus-&gt;devmap.devicemap));
<span class="p_chunk">@@ -2085,7 +2085,7 @@</span> <span class="p_context"> static void choose_devnum(struct usb_device *udev)</span>
 		set_bit(devnum, bus-&gt;devmap.devicemap);
 		udev-&gt;devnum = devnum;
 	}
<span class="p_del">-	mutex_unlock(&amp;bus-&gt;usb_address0_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;bus-&gt;devnum_next_mutex);</span>
 }
 
 static void release_devnum(struct usb_device *udev)
<span class="p_chunk">@@ -4263,7 +4263,7 @@</span> <span class="p_context"> hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	if (oldspeed == USB_SPEED_LOW)
 		delay = HUB_LONG_RESET_TIME;
 
<span class="p_del">-	mutex_lock(&amp;hdev-&gt;bus-&gt;usb_address0_mutex);</span>
<span class="p_add">+	mutex_lock(hcd-&gt;address0_mutex);</span>
 
 	/* Reset the device; full speed may morph to high speed */
 	/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */
<span class="p_chunk">@@ -4545,7 +4545,7 @@</span> <span class="p_context"> fail:</span>
 		hub_port_disable(hub, port1, 0);
 		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
<span class="p_del">-	mutex_unlock(&amp;hdev-&gt;bus-&gt;usb_address0_mutex);</span>
<span class="p_add">+	mutex_unlock(hcd-&gt;address0_mutex);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 82240db..db9433e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -651,7 +651,7 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 	if (io_data-&gt;read &amp;&amp; ret &gt; 0) {
 		use_mm(io_data-&gt;mm);
 		ret = copy_to_iter(io_data-&gt;buf, ret, &amp;io_data-&gt;data);
<span class="p_del">-		if (iov_iter_count(&amp;io_data-&gt;data))</span>
<span class="p_add">+		if (ret != io_data-&gt;req-&gt;actual &amp;&amp; iov_iter_count(&amp;io_data-&gt;data))</span>
 			ret = -EFAULT;
 		unuse_mm(io_data-&gt;mm);
 	}
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">index f936268..99ae086 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_chunk">@@ -2998,25 +2998,6 @@</span> <span class="p_context"> void fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,</span>
 }
 EXPORT_SYMBOL_GPL(fsg_common_set_inquiry_string);
 
<span class="p_del">-int fsg_common_run_thread(struct fsg_common *common)</span>
<span class="p_del">-{</span>
<span class="p_del">-	common-&gt;state = FSG_STATE_IDLE;</span>
<span class="p_del">-	/* Tell the thread to start working */</span>
<span class="p_del">-	common-&gt;thread_task =</span>
<span class="p_del">-		kthread_create(fsg_main_thread, common, &quot;file-storage&quot;);</span>
<span class="p_del">-	if (IS_ERR(common-&gt;thread_task)) {</span>
<span class="p_del">-		common-&gt;state = FSG_STATE_TERMINATED;</span>
<span class="p_del">-		return PTR_ERR(common-&gt;thread_task);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	DBG(common, &quot;I/O thread pid: %d\n&quot;, task_pid_nr(common-&gt;thread_task));</span>
<span class="p_del">-</span>
<span class="p_del">-	wake_up_process(common-&gt;thread_task);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(fsg_common_run_thread);</span>
<span class="p_del">-</span>
 static void fsg_common_release(struct kref *ref)
 {
 	struct fsg_common *common = container_of(ref, struct fsg_common, ref);
<span class="p_chunk">@@ -3025,6 +3006,7 @@</span> <span class="p_context"> static void fsg_common_release(struct kref *ref)</span>
 	if (common-&gt;state != FSG_STATE_TERMINATED) {
 		raise_exception(common, FSG_STATE_EXIT);
 		wait_for_completion(&amp;common-&gt;thread_notifier);
<span class="p_add">+		common-&gt;thread_task = NULL;</span>
 	}
 
 	if (likely(common-&gt;luns)) {
<span class="p_chunk">@@ -3056,6 +3038,7 @@</span> <span class="p_context"> static void fsg_common_release(struct kref *ref)</span>
 static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 {
 	struct fsg_dev		*fsg = fsg_from_func(f);
<span class="p_add">+	struct fsg_common       *common = fsg-&gt;common;</span>
 	struct usb_gadget	*gadget = c-&gt;cdev-&gt;gadget;
 	int			i;
 	struct usb_ep		*ep;
<span class="p_chunk">@@ -3070,9 +3053,21 @@</span> <span class="p_context"> static int fsg_bind(struct usb_configuration *c, struct usb_function *f)</span>
 		if (ret)
 			return ret;
 		fsg_common_set_inquiry_string(fsg-&gt;common, NULL, NULL);
<span class="p_del">-		ret = fsg_common_run_thread(fsg-&gt;common);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!common-&gt;thread_task) {</span>
<span class="p_add">+		common-&gt;state = FSG_STATE_IDLE;</span>
<span class="p_add">+		common-&gt;thread_task =</span>
<span class="p_add">+			kthread_create(fsg_main_thread, common, &quot;file-storage&quot;);</span>
<span class="p_add">+		if (IS_ERR(common-&gt;thread_task)) {</span>
<span class="p_add">+			int ret = PTR_ERR(common-&gt;thread_task);</span>
<span class="p_add">+			common-&gt;thread_task = NULL;</span>
<span class="p_add">+			common-&gt;state = FSG_STATE_TERMINATED;</span>
 			return ret;
<span class="p_add">+		}</span>
<span class="p_add">+		DBG(common, &quot;I/O thread pid: %d\n&quot;,</span>
<span class="p_add">+		    task_pid_nr(common-&gt;thread_task));</span>
<span class="p_add">+		wake_up_process(common-&gt;thread_task);</span>
 	}
 
 	fsg-&gt;gadget = gadget;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.h b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">index b4866fc..44f2337 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_chunk">@@ -157,8 +157,6 @@</span> <span class="p_context"> int fsg_common_create_luns(struct fsg_common *common, struct fsg_config *cfg);</span>
 void fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,
 				   const char *pn);
 
<span class="p_del">-int fsg_common_run_thread(struct fsg_common *common);</span>
<span class="p_del">-</span>
 void fsg_config_from_params(struct fsg_config *cfg,
 			    const struct fsg_module_parameters *params,
 			    unsigned int fsg_num_buffers);
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/acm_ms.c b/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_header">index 1194b09..5c72379 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_chunk">@@ -147,10 +147,6 @@</span> <span class="p_context"> static int acm_ms_do_config(struct usb_configuration *c)</span>
 	if (status &lt; 0)
 		goto put_msg;
 
<span class="p_del">-	status = fsg_common_run_thread(opts-&gt;common);</span>
<span class="p_del">-	if (status)</span>
<span class="p_del">-		goto remove_acm;</span>
<span class="p_del">-</span>
 	status = usb_add_function(c, f_msg);
 	if (status)
 		goto remove_acm;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/mass_storage.c b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">index e7bfb08..5038475 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_chunk">@@ -146,10 +146,6 @@</span> <span class="p_context"> static int msg_do_config(struct usb_configuration *c)</span>
 	if (IS_ERR(f_msg))
 		return PTR_ERR(f_msg);
 
<span class="p_del">-	ret = fsg_common_run_thread(opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto put_func;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg);
 	if (ret)
 		goto put_func;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/multi.c b/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_header">index b21b51f..163a700 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_chunk">@@ -151,7 +151,6 @@</span> <span class="p_context"> static struct usb_function *f_msg_rndis;</span>
 
 static int rndis_do_config(struct usb_configuration *c)
 {
<span class="p_del">-	struct fsg_opts *fsg_opts;</span>
 	int ret;
 
 	if (gadget_is_otg(c-&gt;cdev-&gt;gadget)) {
<span class="p_chunk">@@ -183,11 +182,6 @@</span> <span class="p_context"> static int rndis_do_config(struct usb_configuration *c)</span>
 		goto err_fsg;
 	}
 
<span class="p_del">-	fsg_opts = fsg_opts_from_func_inst(fi_msg);</span>
<span class="p_del">-	ret = fsg_common_run_thread(fsg_opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto err_run;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg_rndis);
 	if (ret)
 		goto err_run;
<span class="p_chunk">@@ -239,7 +233,6 @@</span> <span class="p_context"> static struct usb_function *f_msg_multi;</span>
 
 static int cdc_do_config(struct usb_configuration *c)
 {
<span class="p_del">-	struct fsg_opts *fsg_opts;</span>
 	int ret;
 
 	if (gadget_is_otg(c-&gt;cdev-&gt;gadget)) {
<span class="p_chunk">@@ -272,11 +265,6 @@</span> <span class="p_context"> static int cdc_do_config(struct usb_configuration *c)</span>
 		goto err_fsg;
 	}
 
<span class="p_del">-	fsg_opts = fsg_opts_from_func_inst(fi_msg);</span>
<span class="p_del">-	ret = fsg_common_run_thread(fsg_opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto err_run;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg_multi);
 	if (ret)
 		goto err_run;
<span class="p_header">diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig</span>
<span class="p_header">index 8afc3c1..a69b405 100644</span>
<span class="p_header">--- a/drivers/usb/host/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/host/Kconfig</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"> config USB_XHCI_PCI</span>
 
 config USB_XHCI_PLATFORM
 	tristate
<span class="p_add">+	select USB_XHCI_RCAR if ARCH_SHMOBILE</span>
 
 config USB_XHCI_MVEBU
 	tristate &quot;xHCI support for Marvell Armada 375/38x&quot;
<span class="p_chunk">@@ -44,7 +45,7 @@</span> <span class="p_context"> config USB_XHCI_MVEBU</span>
 
 config USB_XHCI_RCAR
 	tristate &quot;xHCI support for Renesas R-Car SoCs&quot;
<span class="p_del">-	select USB_XHCI_PLATFORM</span>
<span class="p_add">+	depends on USB_XHCI_PLATFORM</span>
 	depends on ARCH_SHMOBILE || COMPILE_TEST
 	---help---
 	  Say &#39;Y&#39; to enable the support for the xHCI host controller
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 0bbafe7..bbddc44 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -303,11 +303,20 @@</span> <span class="p_context"> static unsigned mod_pattern;</span>
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(mod_pattern, &quot;i/o pattern (0 == zeroes)&quot;);
 
<span class="p_del">-static inline void simple_fill_buf(struct urb *urb)</span>
<span class="p_add">+static unsigned get_maxpacket(struct usb_device *udev, int pipe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_host_endpoint	*ep;</span>
<span class="p_add">+</span>
<span class="p_add">+	ep = usb_pipe_endpoint(udev, pipe);</span>
<span class="p_add">+	return le16_to_cpup(&amp;ep-&gt;desc.wMaxPacketSize);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void simple_fill_buf(struct urb *urb)</span>
 {
 	unsigned	i;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;transfer_buffer_length;
<span class="p_add">+	unsigned	maxpacket;</span>
 
 	switch (pattern) {
 	default:
<span class="p_chunk">@@ -316,8 +325,9 @@</span> <span class="p_context"> static inline void simple_fill_buf(struct urb *urb)</span>
 		memset(buf, 0, len);
 		break;
 	case 1:			/* mod63 */
<span class="p_add">+		maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);</span>
 		for (i = 0; i &lt; len; i++)
<span class="p_del">-			*buf++ = (u8) (i % 63);</span>
<span class="p_add">+			*buf++ = (u8) ((i % maxpacket) % 63);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -349,6 +359,7 @@</span> <span class="p_context"> static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)</span>
 	u8		expected;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;actual_length;
<span class="p_add">+	unsigned	maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);</span>
 
 	int ret = check_guard_bytes(tdev, urb);
 	if (ret)
<span class="p_chunk">@@ -366,7 +377,7 @@</span> <span class="p_context"> static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)</span>
 		 * with set_interface or set_config.
 		 */
 		case 1:			/* mod63 */
<span class="p_del">-			expected = i % 63;</span>
<span class="p_add">+			expected = (i % maxpacket) % 63;</span>
 			break;
 		/* always fail unsupported patterns */
 		default:
<span class="p_chunk">@@ -478,11 +489,14 @@</span> <span class="p_context"> static void free_sglist(struct scatterlist *sg, int nents)</span>
 }
 
 static struct scatterlist *
<span class="p_del">-alloc_sglist(int nents, int max, int vary)</span>
<span class="p_add">+alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)</span>
 {
 	struct scatterlist	*sg;
<span class="p_add">+	unsigned int		n_size = 0;</span>
 	unsigned		i;
 	unsigned		size = max;
<span class="p_add">+	unsigned		maxpacket =</span>
<span class="p_add">+		get_maxpacket(interface_to_usbdev(dev-&gt;intf), pipe);</span>
 
 	if (max == 0)
 		return NULL;
<span class="p_chunk">@@ -511,7 +525,8 @@</span> <span class="p_context"> alloc_sglist(int nents, int max, int vary)</span>
 			break;
 		case 1:
 			for (j = 0; j &lt; size; j++)
<span class="p_del">-				*buf++ = (u8) (j % 63);</span>
<span class="p_add">+				*buf++ = (u8) (((j + n_size) % maxpacket) % 63);</span>
<span class="p_add">+			n_size += size;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -2175,7 +2190,8 @@</span> <span class="p_context"> usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)</span>
 			&quot;TEST 5:  write %d sglists %d entries of %d bytes\n&quot;,
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
<span class="p_del">-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);</span>
<span class="p_add">+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,</span>
<span class="p_add">+				0, dev, dev-&gt;out_pipe);</span>
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
<span class="p_chunk">@@ -2193,7 +2209,8 @@</span> <span class="p_context"> usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)</span>
 			&quot;TEST 6:  read %d sglists %d entries of %d bytes\n&quot;,
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
<span class="p_del">-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);</span>
<span class="p_add">+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,</span>
<span class="p_add">+				0, dev, dev-&gt;in_pipe);</span>
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
<span class="p_chunk">@@ -2210,7 +2227,8 @@</span> <span class="p_context"> usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)</span>
 			&quot;TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n&quot;,
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
<span class="p_del">-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);</span>
<span class="p_add">+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,</span>
<span class="p_add">+				param-&gt;vary, dev, dev-&gt;out_pipe);</span>
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
<span class="p_chunk">@@ -2227,7 +2245,8 @@</span> <span class="p_context"> usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)</span>
 			&quot;TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n&quot;,
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
<span class="p_del">-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);</span>
<span class="p_add">+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,</span>
<span class="p_add">+				param-&gt;vary, dev, dev-&gt;in_pipe);</span>
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index a2b43a6..c33dfff 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -784,7 +784,7 @@</span> <span class="p_context"> static void cp210x_set_termios(struct tty_struct *tty,</span>
 		} else {
 			modem_ctl[0] &amp;= ~0x7B;
 			modem_ctl[0] |= 0x01;
<span class="p_del">-			modem_ctl[1] |= 0x40;</span>
<span class="p_add">+			modem_ctl[1] = 0x40;</span>
 			dev_dbg(dev, &quot;%s - flow control = NONE\n&quot;, __func__);
 		}
 
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index c086697..1947ea0 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2856,14 +2856,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;interrupt_read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;interrupt_read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;interrupt_read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;interrupt_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;interrupt_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;interrupt_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2891,14 +2893,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;bulk_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;bulk_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;bulk_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2924,9 +2928,22 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 			}
 		}
 
<span class="p_del">-		if (!interrupt_in_found || !bulk_in_found || !bulk_out_found) {</span>
<span class="p_del">-			dev_err(ddev, &quot;Error - the proper endpoints were not found!\n&quot;);</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (response || !interrupt_in_found || !bulk_in_found ||</span>
<span class="p_add">+							!bulk_out_found) {</span>
<span class="p_add">+			if (!response) {</span>
<span class="p_add">+				dev_err(ddev, &quot;expected endpoints not found\n&quot;);</span>
<span class="p_add">+				response = -ENODEV;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			kfree(edge_serial);</span>
<span class="p_add">+</span>
<span class="p_add">+			return response;</span>
 		}
 
 		/* start interrupt read for this edgeport this interrupt will
<span class="p_chunk">@@ -2949,16 +2966,9 @@</span> <span class="p_context"> static void edge_disconnect(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_del">-	/* stop reads and writes on all ports */</span>
<span class="p_del">-	/* free up our endpoint stuff */</span>
 	if (edge_serial-&gt;is_epic) {
 		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_del">-</span>
 		usb_kill_urb(edge_serial-&gt;read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;bulk_in_buffer);</span>
 	}
 }
 
<span class="p_chunk">@@ -2971,6 +2981,16 @@</span> <span class="p_context"> static void edge_release(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_add">+	if (edge_serial-&gt;is_epic) {</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(edge_serial);
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c</span>
<span class="p_header">index e07b15e..7faa901 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan.c</span>
<span class="p_chunk">@@ -2376,6 +2376,10 @@</span> <span class="p_context"> static void keyspan_release(struct usb_serial *serial)</span>
 
 	s_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	/* Make sure to unlink the URBs submitted in attach. */</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;instat_urb);</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;indat_urb);</span>
<span class="p_add">+</span>
 	usb_free_urb(s_priv-&gt;instat_urb);
 	usb_free_urb(s_priv-&gt;indat_urb);
 	usb_free_urb(s_priv-&gt;glocont_urb);
<span class="p_header">diff --git a/drivers/usb/serial/mxuport.c b/drivers/usb/serial/mxuport.c</span>
<span class="p_header">index 460a406..d029b2f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mxuport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mxuport.c</span>
<span class="p_chunk">@@ -1263,6 +1263,15 @@</span> <span class="p_context"> static int mxuport_attach(struct usb_serial *serial)</span>
 	return 0;
 }
 
<span class="p_add">+static void mxuport_release(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_serial_port *port0 = serial-&gt;port[0];</span>
<span class="p_add">+	struct usb_serial_port *port1 = serial-&gt;port[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_serial_generic_close(port1);</span>
<span class="p_add">+	usb_serial_generic_close(port0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct mxuport_port *mxport = usb_get_serial_port_data(port);
<span class="p_chunk">@@ -1365,6 +1374,7 @@</span> <span class="p_context"> static struct usb_serial_driver mxuport_device = {</span>
 	.probe			= mxuport_probe,
 	.port_probe		= mxuport_port_probe,
 	.attach			= mxuport_attach,
<span class="p_add">+	.release		= mxuport_release,</span>
 	.calc_num_ports		= mxuport_calc_num_ports,
 	.open			= mxuport_open,
 	.close			= mxuport_close,
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 94e520d..f00919d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -378,18 +378,22 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define HAIER_PRODUCT_CE81B			0x10f8
 #define HAIER_PRODUCT_CE100			0x2009
 
<span class="p_del">-/* Cinterion (formerly Siemens) products */</span>
<span class="p_del">-#define SIEMENS_VENDOR_ID				0x0681</span>
<span class="p_del">-#define CINTERION_VENDOR_ID				0x1e2d</span>
<span class="p_add">+/* Gemalto&#39;s Cinterion products (formerly Siemens) */</span>
<span class="p_add">+#define SIEMENS_VENDOR_ID			0x0681</span>
<span class="p_add">+#define CINTERION_VENDOR_ID			0x1e2d</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC25_MDMNET		0x0040</span>
 #define CINTERION_PRODUCT_HC25_MDM		0x0047
<span class="p_del">-#define CINTERION_PRODUCT_HC25_MDMNET	0x0040</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC28_MDMNET		0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_HC28_MDM		0x004C
<span class="p_del">-#define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_EU3_E			0x0051
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 #define CINTERION_PRODUCT_AHXX			0x0055
 #define CINTERION_PRODUCT_PLXX			0x0060
<span class="p_add">+#define CINTERION_PRODUCT_PH8_2RMNET		0x0082</span>
<span class="p_add">+#define CINTERION_PRODUCT_PH8_AUDIO		0x0083</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_2RMNET		0x0084</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_AUDIO		0x0085</span>
 
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
<span class="p_chunk">@@ -641,6 +645,10 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
 	.reserved = BIT(1) | BIT(2) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1614,7 +1622,79 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
<span class="p_del">-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff42, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff43, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff44, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff45, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff46, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff47, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff48, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff49, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff50, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff51, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff52, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff53, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff54, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff55, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff56, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff57, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff58, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff59, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff60, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff61, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff62, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff63, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff64, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff65, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff66, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff67, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff68, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff69, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff70, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff71, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff72, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff73, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff74, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff75, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff76, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff77, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff78, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff79, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff80, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff81, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff82, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff83, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff84, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff85, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff86, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff87, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff88, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff89, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8a, 0xff, 0xff, 0xff) },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8b, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8c, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8d, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1625,6 +1705,61 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff92, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff93, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff94, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff9f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaa, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffab, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffac, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffae, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffba, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbe, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffca, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffce, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffec, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffee, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xfff6, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1724,7 +1859,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, </span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_2RMNET, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;cinterion_rmnet2_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_AUDIO, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_2RMNET, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_AUDIO, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDMNET) },
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index 504f5bf..b18974c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static void qt2_release(struct usb_serial *serial)</span>
 
 	serial_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	usb_kill_urb(serial_priv-&gt;read_urb);</span>
 	usb_free_urb(serial_priv-&gt;read_urb);
 	kfree(serial_priv-&gt;read_buffer);
 	kfree(serial_priv);
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index d90302e..89e801f 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -487,7 +487,8 @@</span> <span class="p_context"> static void eoi_pirq(struct irq_data *data)</span>
 	if (!VALID_EVTCHN(evtchn))
 		return;
 
<span class="p_del">-	if (unlikely(irqd_is_setaffinity_pending(data))) {</span>
<span class="p_add">+	if (unlikely(irqd_is_setaffinity_pending(data)) &amp;&amp;</span>
<span class="p_add">+	    likely(!irqd_irq_disabled(data))) {</span>
 		int masked = test_and_set_mask(evtchn);
 
 		clear_evtchn(evtchn);
<span class="p_chunk">@@ -1374,7 +1375,8 @@</span> <span class="p_context"> static void ack_dynirq(struct irq_data *data)</span>
 	if (!VALID_EVTCHN(evtchn))
 		return;
 
<span class="p_del">-	if (unlikely(irqd_is_setaffinity_pending(data))) {</span>
<span class="p_add">+	if (unlikely(irqd_is_setaffinity_pending(data)) &amp;&amp;</span>
<span class="p_add">+	    likely(!irqd_irq_disabled(data))) {</span>
 		int masked = test_and_set_mask(evtchn);
 
 		clear_evtchn(evtchn);
<span class="p_header">diff --git a/fs/affs/super.c b/fs/affs/super.c</span>
<span class="p_header">index 3f89c9e..cc75712 100644</span>
<span class="p_header">--- a/fs/affs/super.c</span>
<span class="p_header">+++ b/fs/affs/super.c</span>
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> affs_remount(struct super_block *sb, int *flags, char *data)</span>
 	char			*prefix = NULL;
 
 	new_opts = kstrdup(data, GFP_KERNEL);
<span class="p_del">-	if (!new_opts)</span>
<span class="p_add">+	if (data &amp;&amp; !new_opts)</span>
 		return -ENOMEM;
 
 	pr_debug(&quot;%s(flags=0x%x,opts=\&quot;%s\&quot;)\n&quot;, __func__, *flags, data);
<span class="p_chunk">@@ -544,7 +544,8 @@</span> <span class="p_context"> affs_remount(struct super_block *sb, int *flags, char *data)</span>
 	}
 
 	flush_delayed_work(&amp;sbi-&gt;sb_work);
<span class="p_del">-	replace_mount_options(sb, new_opts);</span>
<span class="p_add">+	if (new_opts)</span>
<span class="p_add">+		replace_mount_options(sb, new_opts);</span>
 
 	sbi-&gt;s_flags = mount_flags;
 	sbi-&gt;s_mode  = mode;
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index 6bd8ea5..293d340 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -3959,6 +3959,7 @@</span> <span class="p_context"> void btrfs_test_inode_set_ops(struct inode *inode);</span>
 
 /* ioctl.c */
 long btrfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
<span class="p_add">+long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg);</span>
 void btrfs_update_iflags(struct inode *inode);
 void btrfs_inherit_iflags(struct inode *inode, struct inode *dir);
 int btrfs_is_empty_uuid(u8 *uuid);
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index dfb6609..f95fe3d 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -2826,7 +2826,7 @@</span> <span class="p_context"> const struct file_operations btrfs_file_operations = {</span>
 	.fallocate	= btrfs_fallocate,
 	.unlocked_ioctl	= btrfs_ioctl,
 #ifdef CONFIG_COMPAT
<span class="p_del">-	.compat_ioctl	= btrfs_ioctl,</span>
<span class="p_add">+	.compat_ioctl	= btrfs_compat_ioctl,</span>
 #endif
 };
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 504eddf..c8b6b3f 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -9933,7 +9933,7 @@</span> <span class="p_context"> static const struct file_operations btrfs_dir_file_operations = {</span>
 	.iterate	= btrfs_real_readdir,
 	.unlocked_ioctl	= btrfs_ioctl,
 #ifdef CONFIG_COMPAT
<span class="p_del">-	.compat_ioctl	= btrfs_ioctl,</span>
<span class="p_add">+	.compat_ioctl	= btrfs_compat_ioctl,</span>
 #endif
 	.release        = btrfs_release_file,
 	.fsync		= btrfs_sync_file,
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index fc784e9..51e896f 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -5640,3 +5640,24 @@</span> <span class="p_context"> long btrfs_ioctl(struct file *file, unsigned int</span>
 
 	return -ENOTTY;
 }
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+long btrfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FS_IOC32_GETFLAGS:</span>
<span class="p_add">+		cmd = FS_IOC_GETFLAGS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case FS_IOC32_SETFLAGS:</span>
<span class="p_add">+		cmd = FS_IOC_SETFLAGS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case FS_IOC32_GETVERSION:</span>
<span class="p_add">+		cmd = FS_IOC_GETVERSION;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -ENOIOCTLCMD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return btrfs_ioctl(file, cmd, (unsigned long) compat_ptr(arg));</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/fs/cifs/cifs_spnego.c b/fs/cifs/cifs_spnego.c</span>
<span class="p_header">index f4cf200..79450fa 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_spnego.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_spnego.c</span>
<span class="p_chunk">@@ -24,10 +24,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;keys/user-type.h&gt;
 #include &lt;linux/key-type.h&gt;
<span class="p_add">+#include &lt;linux/keyctl.h&gt;</span>
 #include &lt;linux/inet.h&gt;
 #include &quot;cifsglob.h&quot;
 #include &quot;cifs_spnego.h&quot;
 #include &quot;cifs_debug.h&quot;
<span class="p_add">+#include &quot;cifsproto.h&quot;</span>
<span class="p_add">+static const struct cred *spnego_cred;</span>
 
 /* create a new cifs key */
 static int
<span class="p_chunk">@@ -102,6 +105,7 @@</span> <span class="p_context"> cifs_get_spnego_key(struct cifs_ses *sesInfo)</span>
 	size_t desc_len;
 	struct key *spnego_key;
 	const char *hostname = server-&gt;hostname;
<span class="p_add">+	const struct cred *saved_cred;</span>
 
 	/* length of fields (with semicolons): ver=0xyz ip4=ipaddress
 	   host=hostname sec=mechanism uid=0xFF user=username */
<span class="p_chunk">@@ -163,7 +167,9 @@</span> <span class="p_context"> cifs_get_spnego_key(struct cifs_ses *sesInfo)</span>
 	sprintf(dp, &quot;;pid=0x%x&quot;, current-&gt;pid);
 
 	cifs_dbg(FYI, &quot;key description = %s\n&quot;, description);
<span class="p_add">+	saved_cred = override_creds(spnego_cred);</span>
 	spnego_key = request_key(&amp;cifs_spnego_key_type, description, &quot;&quot;);
<span class="p_add">+	revert_creds(saved_cred);</span>
 
 #ifdef CONFIG_CIFS_DEBUG2
 	if (cifsFYI &amp;&amp; !IS_ERR(spnego_key)) {
<span class="p_chunk">@@ -177,3 +183,64 @@</span> <span class="p_context"> out:</span>
 	kfree(description);
 	return spnego_key;
 }
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+init_cifs_spnego(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cred *cred;</span>
<span class="p_add">+	struct key *keyring;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Registering the %s key type\n&quot;,</span>
<span class="p_add">+		 cifs_spnego_key_type.name);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Create an override credential set with special thread keyring for</span>
<span class="p_add">+	 * spnego upcalls.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	cred = prepare_kernel_cred(NULL);</span>
<span class="p_add">+	if (!cred)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	keyring = keyring_alloc(&quot;.cifs_spnego&quot;,</span>
<span class="p_add">+				GLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,</span>
<span class="p_add">+				(KEY_POS_ALL &amp; ~KEY_POS_SETATTR) |</span>
<span class="p_add">+				KEY_USR_VIEW | KEY_USR_READ,</span>
<span class="p_add">+				KEY_ALLOC_NOT_IN_QUOTA, NULL);</span>
<span class="p_add">+	if (IS_ERR(keyring)) {</span>
<span class="p_add">+		ret = PTR_ERR(keyring);</span>
<span class="p_add">+		goto failed_put_cred;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto failed_put_key;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * instruct request_key() to use this special keyring as a cache for</span>
<span class="p_add">+	 * the results it looks up</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_bit(KEY_FLAG_ROOT_CAN_CLEAR, &amp;keyring-&gt;flags);</span>
<span class="p_add">+	cred-&gt;thread_keyring = keyring;</span>
<span class="p_add">+	cred-&gt;jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;</span>
<span class="p_add">+	spnego_cred = cred;</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;cifs spnego keyring: %d\n&quot;, key_serial(keyring));</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+failed_put_key:</span>
<span class="p_add">+	key_put(keyring);</span>
<span class="p_add">+failed_put_cred:</span>
<span class="p_add">+	put_cred(cred);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+exit_cifs_spnego(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	key_revoke(spnego_cred-&gt;thread_keyring);</span>
<span class="p_add">+	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	put_cred(spnego_cred);</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Unregistered %s key type\n&quot;, cifs_spnego_key_type.name);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 6a1119e..fe24e22 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -1238,7 +1238,7 @@</span> <span class="p_context"> init_cifs(void)</span>
 		goto out_destroy_mids;
 
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	rc = register_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	rc = init_cifs_spnego();</span>
 	if (rc)
 		goto out_destroy_request_bufs;
 #endif /* CONFIG_CIFS_UPCALL */
<span class="p_chunk">@@ -1261,7 +1261,7 @@</span> <span class="p_context"> out_init_cifs_idmap:</span>
 out_register_key_type:
 #endif
 #ifdef CONFIG_CIFS_UPCALL
<span class="p_del">-	unregister_key_type(&amp;cifs_spnego_key_type);</span>
<span class="p_add">+	exit_cifs_spnego();</span>
 out_destroy_request_bufs:
 #endif
 	cifs_destroy_request_bufs();
<span class="p_header">diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h</span>
<span class="p_header">index c63fd1d..f730c06 100644</span>
<span class="p_header">--- a/fs/cifs/cifsproto.h</span>
<span class="p_header">+++ b/fs/cifs/cifsproto.h</span>
<span class="p_chunk">@@ -60,6 +60,8 @@</span> <span class="p_context"> do {								\</span>
 } while (0)
 extern int init_cifs_idmap(void);
 extern void exit_cifs_idmap(void);
<span class="p_add">+extern int init_cifs_spnego(void);</span>
<span class="p_add">+extern void exit_cifs_spnego(void);</span>
 extern char *build_path_from_dentry(struct dentry *);
 extern char *cifs_build_path_to_root(struct smb_vol *vol,
 				     struct cifs_sb_info *cifs_sb,
<span class="p_header">diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c</span>
<span class="p_header">index bce6fdc..8ffda50 100644</span>
<span class="p_header">--- a/fs/cifs/sess.c</span>
<span class="p_header">+++ b/fs/cifs/sess.c</span>
<span class="p_chunk">@@ -400,19 +400,27 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 	sec_blob-&gt;LmChallengeResponse.MaximumLength = 0;
 
 	sec_blob-&gt;NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_del">-		goto setup_ntlmv2_ret;</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_add">+			goto setup_ntlmv2_ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * don&#39;t send an NT Response for anonymous access</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length = 0;</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength = 0;</span>
 	}
<span class="p_del">-	memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
 
 	if (ses-&gt;domainName == NULL) {
 		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_chunk">@@ -670,20 +678,24 @@</span> <span class="p_context"> sess_auth_lanman(struct sess_data *sess_data)</span>
 
 	pSMB-&gt;req.hdr.Flags2 &amp;= ~SMBFLG2_UNICODE;
 
<span class="p_del">-	/* no capabilities flags in old lanman negotiation */</span>
<span class="p_del">-	pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_del">-	 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_del">-	 * security mode bit in Negottiate Protocol response states</span>
<span class="p_del">-	 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_del">-			      ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_del">-			      true : false, lnm_session_key);</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		/* no capabilities flags in old lanman negotiation */</span>
<span class="p_add">+		pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_add">+		 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_add">+		 * security mode bit in Negottiate Protocol response states</span>
<span class="p_add">+		 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_add">+				      ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_add">+				      true : false, lnm_session_key);</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;old_req.PasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * can not sign if LANMAN negotiated so no need
<span class="p_chunk">@@ -769,26 +781,31 @@</span> <span class="p_context"> sess_auth_ntlm(struct sess_data *sess_data)</span>
 	capabilities = cifs_ssetup_hdr(ses, pSMB);
 
 	pSMB-&gt;req_no_secext.Capabilities = cpu_to_le32(capabilities);
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* calculate ntlm response and session key */</span>
<span class="p_del">-	rc = setup_ntlm_response(ses, sess_data-&gt;nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_del">-				 rc);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_add">+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* calculate ntlm response and session key */</span>
<span class="p_add">+		rc = setup_ntlm_response(ses, sess_data-&gt;nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_add">+					 rc);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* copy ntlm response */</span>
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		/* copy ntlm response */</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 		/* unicode strings must be word aligned */
<span class="p_chunk">@@ -878,22 +895,26 @@</span> <span class="p_context"> sess_auth_ntlmv2(struct sess_data *sess_data)</span>
 	/* LM2 password would be here if we supported it */
 	pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;
 
<span class="p_del">-	/* calculate nlmv2 response and session key */</span>
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, sess_data-&gt;nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;, rc);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		/* calculate nlmv2 response and session key */</span>
<span class="p_add">+		rc = setup_ntlmv2_rsp(ses, sess_data-&gt;nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;, rc);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
 
<span class="p_del">-	/* set case sensitive password length after tilen may get</span>
<span class="p_del">-	 * assigned, tilen is 0 otherwise.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-		cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		/* set case sensitive password length after tilen may get</span>
<span class="p_add">+		 * assigned, tilen is 0 otherwise.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 		if (sess_data-&gt;iov[0].iov_len % 2) {
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index bc0bb9c..0ffa180 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #define SMB2_OP_DELETE 7
 #define SMB2_OP_HARDLINK 8
 #define SMB2_OP_SET_EOF 9
<span class="p_add">+#define SMB2_OP_RMDIR 10</span>
 
 /* Used when constructing chained read requests. */
 #define CHAINED_REQUEST 1
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 899bbc8..4f0231e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -80,6 +80,10 @@</span> <span class="p_context"> smb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		 * SMB2_open() call.
 		 */
 		break;
<span class="p_add">+	case SMB2_OP_RMDIR:</span>
<span class="p_add">+		tmprc = SMB2_rmdir(xid, tcon, fid.persistent_fid,</span>
<span class="p_add">+				   fid.volatile_fid);</span>
<span class="p_add">+		break;</span>
 	case SMB2_OP_RENAME:
 		tmprc = SMB2_rename(xid, tcon, fid.persistent_fid,
 				    fid.volatile_fid, (__le16 *)data);
<span class="p_chunk">@@ -191,8 +195,8 @@</span> <span class="p_context"> smb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,</span>
 	   struct cifs_sb_info *cifs_sb)
 {
 	return smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,
<span class="p_del">-				  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,</span>
<span class="p_del">-				  NULL, SMB2_OP_DELETE);</span>
<span class="p_add">+				  CREATE_NOT_FILE,</span>
<span class="p_add">+				  NULL, SMB2_OP_RMDIR);</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index e543e6a..27ad3dd 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -2443,6 +2443,22 @@</span> <span class="p_context"> SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,</span>
 }
 
 int
<span class="p_add">+SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		  u64 persistent_fid, u64 volatile_fid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__u8 delete_pending = 1;</span>
<span class="p_add">+	void *data;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = &amp;delete_pending;</span>
<span class="p_add">+	size = 1; /* sizeof __u8 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return send_set_info(xid, tcon, persistent_fid, volatile_fid,</span>
<span class="p_add">+			current-&gt;tgid, FILE_DISPOSITION_INFORMATION, 1, &amp;data,</span>
<span class="p_add">+			&amp;size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
 SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 		  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)
 {
<span class="p_header">diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h</span>
<span class="p_header">index 79dc650..9bc59f9 100644</span>
<span class="p_header">--- a/fs/cifs/smb2proto.h</span>
<span class="p_header">+++ b/fs/cifs/smb2proto.h</span>
<span class="p_chunk">@@ -140,6 +140,8 @@</span> <span class="p_context"> extern int SMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,</span>
 extern int SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,
 		       u64 persistent_fid, u64 volatile_fid,
 		       __le16 *target_file);
<span class="p_add">+extern int SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		      u64 persistent_fid, u64 volatile_fid);</span>
 extern int SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 			     u64 persistent_fid, u64 volatile_fid,
 			     __le16 *target_file);
<span class="p_header">diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c</span>
<span class="p_header">index 173c1ae..556ea2a 100644</span>
<span class="p_header">--- a/fs/ext4/ialloc.c</span>
<span class="p_header">+++ b/fs/ext4/ialloc.c</span>
<span class="p_chunk">@@ -1137,11 +1137,13 @@</span> <span class="p_context"> struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)</span>
 		goto iget_failed;
 
 	/*
<span class="p_del">-	 * If the orphans has i_nlinks &gt; 0 then it should be able to be</span>
<span class="p_del">-	 * truncated, otherwise it won&#39;t be removed from the orphan list</span>
<span class="p_del">-	 * during processing and an infinite loop will result.</span>
<span class="p_add">+	 * If the orphans has i_nlinks &gt; 0 then it should be able to</span>
<span class="p_add">+	 * be truncated, otherwise it won&#39;t be removed from the orphan</span>
<span class="p_add">+	 * list during processing and an infinite loop will result.</span>
<span class="p_add">+	 * Similarly, it must not be a bad inode.</span>
 	 */
<span class="p_del">-	if (inode-&gt;i_nlink &amp;&amp; !ext4_can_truncate(inode))</span>
<span class="p_add">+	if ((inode-&gt;i_nlink &amp;&amp; !ext4_can_truncate(inode)) ||</span>
<span class="p_add">+	    is_bad_inode(inode))</span>
 		goto bad_orphan;
 
 	if (NEXT_ORPHAN(inode) &gt; max_ino)
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 34b610e..5162921 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -1252,6 +1252,7 @@</span> <span class="p_context"> static void ext4_mb_unload_buddy(struct ext4_buddy *e4b)</span>
 static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)
 {
 	int order = 1;
<span class="p_add">+	int bb_incr = 1 &lt;&lt; (e4b-&gt;bd_blkbits - 1);</span>
 	void *bb;
 
 	BUG_ON(e4b-&gt;bd_bitmap == e4b-&gt;bd_buddy);
<span class="p_chunk">@@ -1264,7 +1265,8 @@</span> <span class="p_context"> static int mb_find_order_for_block(struct ext4_buddy *e4b, int block)</span>
 			/* this block is part of buddy of order &#39;order&#39; */
 			return order;
 		}
<span class="p_del">-		bb += 1 &lt;&lt; (e4b-&gt;bd_blkbits - order);</span>
<span class="p_add">+		bb += bb_incr;</span>
<span class="p_add">+		bb_incr &gt;&gt;= 1;</span>
 		order++;
 	}
 	return 0;
<span class="p_chunk">@@ -2569,7 +2571,7 @@</span> <span class="p_context"> int ext4_mb_init(struct super_block *sb)</span>
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	unsigned i, j;
<span class="p_del">-	unsigned offset;</span>
<span class="p_add">+	unsigned offset, offset_incr;</span>
 	unsigned max;
 	int ret;
 
<span class="p_chunk">@@ -2598,11 +2600,13 @@</span> <span class="p_context"> int ext4_mb_init(struct super_block *sb)</span>
 
 	i = 1;
 	offset = 0;
<span class="p_add">+	offset_incr = 1 &lt;&lt; (sb-&gt;s_blocksize_bits - 1);</span>
 	max = sb-&gt;s_blocksize &lt;&lt; 2;
 	do {
 		sbi-&gt;s_mb_offsets[i] = offset;
 		sbi-&gt;s_mb_maxs[i] = max;
<span class="p_del">-		offset += 1 &lt;&lt; (sb-&gt;s_blocksize_bits - i);</span>
<span class="p_add">+		offset += offset_incr;</span>
<span class="p_add">+		offset_incr = offset_incr &gt;&gt; 1;</span>
 		max = max &gt;&gt; 1;
 		i++;
 	} while (i &lt;= sb-&gt;s_blocksize_bits + 1);
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 011dcfb..81fc2c6 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -2805,7 +2805,7 @@</span> <span class="p_context"> int ext4_orphan_add(handle_t *handle, struct inode *inode)</span>
 			 * list entries can cause panics at unmount time.
 			 */
 			mutex_lock(&amp;sbi-&gt;s_orphan_lock);
<span class="p_del">-			list_del(&amp;EXT4_I(inode)-&gt;i_orphan);</span>
<span class="p_add">+			list_del_init(&amp;EXT4_I(inode)-&gt;i_orphan);</span>
 			mutex_unlock(&amp;sbi-&gt;s_orphan_lock);
 		}
 	}
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 68a9bed..0b49ffe 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/bitmap.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
 
 /* Mark the filesystem dirty, so that chkdsk checks it when os/2 booted */
 
<span class="p_chunk">@@ -453,10 +454,6 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 	int lowercase, eas, chk, errs, chkdsk, timeshift;
 	int o;
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
<span class="p_del">-	char *new_opts = kstrdup(data, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!new_opts)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
 	sync_filesystem(s);
 
<span class="p_chunk">@@ -493,17 +490,44 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 
 	if (!(*flags &amp; MS_RDONLY)) mark_dirty(s, 1);
 
<span class="p_del">-	replace_mount_options(s, new_opts);</span>
<span class="p_del">-</span>
 	hpfs_unlock(s);
 	return 0;
 
 out_err:
 	hpfs_unlock(s);
<span class="p_del">-	kfree(new_opts);</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static int hpfs_show_options(struct seq_file *seq, struct dentry *root)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hpfs_sb_info *sbi = hpfs_sb(root-&gt;d_sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(seq, &quot;,uid=%u&quot;, from_kuid_munged(&amp;init_user_ns, sbi-&gt;sb_uid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,gid=%u&quot;, from_kgid_munged(&amp;init_user_ns, sbi-&gt;sb_gid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,umask=%03o&quot;, (~sbi-&gt;sb_mode &amp; 0777));</span>
<span class="p_add">+	if (sbi-&gt;sb_lowercase)</span>
<span class="p_add">+		seq_printf(seq, &quot;,case=lower&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=none&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=strict&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_err)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=continue&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_err == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=panic&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chkdsk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chkdsk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=always&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_eas)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_eas == 1)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=ro&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_timeshift)</span>
<span class="p_add">+		seq_printf(seq, &quot;,timeshift=%d&quot;, sbi-&gt;sb_timeshift);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Super operations */
 
 static const struct super_operations hpfs_sops =
<span class="p_chunk">@@ -514,7 +538,7 @@</span> <span class="p_context"> static const struct super_operations hpfs_sops =</span>
 	.put_super	= hpfs_put_super,
 	.statfs		= hpfs_statfs,
 	.remount_fs	= hpfs_remount_fs,
<span class="p_del">-	.show_options	= generic_show_options,</span>
<span class="p_add">+	.show_options	= hpfs_show_options,</span>
 };
 
 static int hpfs_fill_super(struct super_block *s, void *options, int silent)
<span class="p_chunk">@@ -537,8 +561,6 @@</span> <span class="p_context"> static int hpfs_fill_super(struct super_block *s, void *options, int silent)</span>
 
 	int o;
 
<span class="p_del">-	save_mount_options(s, options);</span>
<span class="p_del">-</span>
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi) {
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 731641a..c00bf26 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -6020,6 +6020,7 @@</span> <span class="p_context"> static int nfs41_lock_expired(struct nfs4_state *state, struct file_lock *reques</span>
 static int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)
 {
 	struct nfs_inode *nfsi = NFS_I(state-&gt;inode);
<span class="p_add">+	struct nfs4_state_owner *sp = state-&gt;owner;</span>
 	unsigned char fl_flags = request-&gt;fl_flags;
 	int status = -ENOLCK;
 
<span class="p_chunk">@@ -6034,6 +6035,7 @@</span> <span class="p_context"> static int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock</span>
 	status = do_vfs_lock(state-&gt;inode, request);
 	if (status &lt; 0)
 		goto out;
<span class="p_add">+	mutex_lock(&amp;sp-&gt;so_delegreturn_mutex);</span>
 	down_read(&amp;nfsi-&gt;rwsem);
 	if (test_bit(NFS_DELEGATED_STATE, &amp;state-&gt;flags)) {
 		/* Yes: cache locks! */
<span class="p_chunk">@@ -6041,9 +6043,11 @@</span> <span class="p_context"> static int _nfs4_proc_setlk(struct nfs4_state *state, int cmd, struct file_lock</span>
 		request-&gt;fl_flags = fl_flags &amp; ~FL_SLEEP;
 		status = do_vfs_lock(state-&gt;inode, request);
 		up_read(&amp;nfsi-&gt;rwsem);
<span class="p_add">+		mutex_unlock(&amp;sp-&gt;so_delegreturn_mutex);</span>
 		goto out;
 	}
 	up_read(&amp;nfsi-&gt;rwsem);
<span class="p_add">+	mutex_unlock(&amp;sp-&gt;so_delegreturn_mutex);</span>
 	status = _nfs4_do_setlk(state, cmd, request, NFS_LOCK_NEW);
 out:
 	request-&gt;fl_flags = fl_flags;
<span class="p_header">diff --git a/fs/xfs/xfs_fsops.c b/fs/xfs/xfs_fsops.c</span>
<span class="p_header">index 9b3438a..df4bc93 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_fsops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_fsops.c</span>
<span class="p_chunk">@@ -243,8 +243,8 @@</span> <span class="p_context"> xfs_growfs_data_private(</span>
 		agf-&gt;agf_roots[XFS_BTNUM_CNTi] = cpu_to_be32(XFS_CNT_BLOCK(mp));
 		agf-&gt;agf_levels[XFS_BTNUM_BNOi] = cpu_to_be32(1);
 		agf-&gt;agf_levels[XFS_BTNUM_CNTi] = cpu_to_be32(1);
<span class="p_del">-		agf-&gt;agf_flfirst = 0;</span>
<span class="p_del">-		agf-&gt;agf_fllast = cpu_to_be32(XFS_AGFL_SIZE(mp) - 1);</span>
<span class="p_add">+		agf-&gt;agf_flfirst = cpu_to_be32(1);</span>
<span class="p_add">+		agf-&gt;agf_fllast = 0;</span>
 		agf-&gt;agf_flcount = 0;
 		tmpsize = agsize - XFS_PREALLOC_BLOCKS(mp);
 		agf-&gt;agf_freeblks = cpu_to_be32(tmpsize);
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 3da9f4d..01f3e07 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -3164,13 +3164,14 @@</span> <span class="p_context"> xfs_iflush_cluster(</span>
 		 * We need to check under the i_flags_lock for a valid inode
 		 * here. Skip it if it is not valid or the wrong inode.
 		 */
<span class="p_del">-		spin_lock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_del">-		if (!ip-&gt;i_ino ||</span>
<span class="p_add">+		spin_lock(&amp;iq-&gt;i_flags_lock);</span>
<span class="p_add">+		if (!iq-&gt;i_ino ||</span>
<span class="p_add">+		    __xfs_iflags_test(iq, XFS_ISTALE) ||</span>
 		    (XFS_INO_TO_AGINO(mp, iq-&gt;i_ino) &amp; mask) != first_index) {
<span class="p_del">-			spin_unlock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_add">+			spin_unlock(&amp;iq-&gt;i_flags_lock);</span>
 			continue;
 		}
<span class="p_del">-		spin_unlock(&amp;ip-&gt;i_flags_lock);</span>
<span class="p_add">+		spin_unlock(&amp;iq-&gt;i_flags_lock);</span>
 
 		/*
 		 * Do an un-protected check to see if the inode is dirty and
<span class="p_chunk">@@ -3286,7 +3287,7 @@</span> <span class="p_context"> xfs_iflush(</span>
 	struct xfs_buf		**bpp)
 {
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_del">-	struct xfs_buf		*bp;</span>
<span class="p_add">+	struct xfs_buf		*bp = NULL;</span>
 	struct xfs_dinode	*dip;
 	int			error;
 
<span class="p_chunk">@@ -3328,14 +3329,22 @@</span> <span class="p_context"> xfs_iflush(</span>
 	}
 
 	/*
<span class="p_del">-	 * Get the buffer containing the on-disk inode.</span>
<span class="p_add">+	 * Get the buffer containing the on-disk inode. We are doing a try-lock</span>
<span class="p_add">+	 * operation here, so we may get  an EAGAIN error. In that case, we</span>
<span class="p_add">+	 * simply want to return with the inode still dirty.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we get any other error, we effectively have a corruption situation</span>
<span class="p_add">+	 * and we cannot flush the inode, so we treat it the same as failing</span>
<span class="p_add">+	 * xfs_iflush_int().</span>
 	 */
 	error = xfs_imap_to_bp(mp, NULL, &amp;ip-&gt;i_imap, &amp;dip, &amp;bp, XBF_TRYLOCK,
 			       0);
<span class="p_del">-	if (error || !bp) {</span>
<span class="p_add">+	if (error == -EAGAIN) {</span>
 		xfs_ifunlock(ip);
 		return error;
 	}
<span class="p_add">+	if (error)</span>
<span class="p_add">+		goto corrupt_out;</span>
 
 	/*
 	 * First flush out the inode that xfs_iflush was called with.
<span class="p_chunk">@@ -3363,7 +3372,8 @@</span> <span class="p_context"> xfs_iflush(</span>
 	return 0;
 
 corrupt_out:
<span class="p_del">-	xfs_buf_relse(bp);</span>
<span class="p_add">+	if (bp)</span>
<span class="p_add">+		xfs_buf_relse(bp);</span>
 	xfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);
 cluster_corrupt_out:
 	error = -EFSCORRUPTED;
<span class="p_header">diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c</span>
<span class="p_header">index bbd9b1f..a214629 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_super.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_super.c</span>
<span class="p_chunk">@@ -1240,6 +1240,16 @@</span> <span class="p_context"> xfs_fs_remount(</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		if (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 &amp;&amp;</span>
<span class="p_add">+		    xfs_sb_has_ro_compat_feature(sbp,</span>
<span class="p_add">+					XFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {</span>
<span class="p_add">+			xfs_warn(mp,</span>
<span class="p_add">+&quot;ro-&gt;rw transition prohibited on unknown (0x%x) ro-compat filesystem&quot;,</span>
<span class="p_add">+				(sbp-&gt;sb_features_ro_compat &amp;</span>
<span class="p_add">+					XFS_SB_FEAT_RO_COMPAT_UNKNOWN));</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		mp-&gt;m_flags &amp;= ~XFS_MOUNT_RDONLY;
 
 		/*
<span class="p_header">diff --git a/include/asm-generic/preempt.h b/include/asm-generic/preempt.h</span>
<span class="p_header">index 0bec580..af36c87 100644</span>
<span class="p_header">--- a/include/asm-generic/preempt.h</span>
<span class="p_header">+++ b/include/asm-generic/preempt.h</span>
<span class="p_chunk">@@ -7,10 +7,10 @@</span> <span class="p_context"></span>
 
 static __always_inline int preempt_count(void)
 {
<span class="p_del">-	return current_thread_info()-&gt;preempt_count;</span>
<span class="p_add">+	return READ_ONCE(current_thread_info()-&gt;preempt_count);</span>
 }
 
<span class="p_del">-static __always_inline int *preempt_count_ptr(void)</span>
<span class="p_add">+static __always_inline volatile int *preempt_count_ptr(void)</span>
 {
 	return &amp;current_thread_info()-&gt;preempt_count;
 }
<span class="p_header">diff --git a/include/asm-generic/qspinlock.h b/include/asm-generic/qspinlock.h</span>
<span class="p_header">index e2aadbc..7d633f1 100644</span>
<span class="p_header">--- a/include/asm-generic/qspinlock.h</span>
<span class="p_header">+++ b/include/asm-generic/qspinlock.h</span>
<span class="p_chunk">@@ -27,7 +27,30 @@</span> <span class="p_context"></span>
  */
 static __always_inline int queued_spin_is_locked(struct qspinlock *lock)
 {
<span class="p_del">-	return atomic_read(&amp;lock-&gt;val);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * queued_spin_lock_slowpath() can ACQUIRE the lock before</span>
<span class="p_add">+	 * issuing the unordered store that sets _Q_LOCKED_VAL.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * See both smp_cond_acquire() sites for more detail.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This however means that in code like:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   spin_lock(A)		spin_lock(B)</span>
<span class="p_add">+	 *   spin_unlock_wait(B)	spin_is_locked(A)</span>
<span class="p_add">+	 *   do_something()		do_something()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Both CPUs can end up running do_something() because the store</span>
<span class="p_add">+	 * setting _Q_LOCKED_VAL will pass through the loads in</span>
<span class="p_add">+	 * spin_unlock_wait() and/or spin_is_locked().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Avoid this by issuing a full memory barrier between the spin_lock()</span>
<span class="p_add">+	 * and the loads in spin_unlock_wait() and spin_is_locked().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that regular mutual exclusion doesn&#39;t care about this</span>
<span class="p_add">+	 * delayed store.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+	return atomic_read(&amp;lock-&gt;val) &amp; _Q_LOCKED_MASK;</span>
 }
 
 /**
<span class="p_chunk">@@ -107,6 +130,8 @@</span> <span class="p_context"> static __always_inline void queued_spin_unlock(struct qspinlock *lock)</span>
  */
 static inline void queued_spin_unlock_wait(struct qspinlock *lock)
 {
<span class="p_add">+	/* See queued_spin_is_locked() */</span>
<span class="p_add">+	smp_mb();</span>
 	while (atomic_read(&amp;lock-&gt;val) &amp; _Q_LOCKED_MASK)
 		cpu_relax();
 }
<span class="p_header">diff --git a/include/asm-generic/siginfo.h b/include/asm-generic/siginfo.h</span>
<span class="p_header">index 3d1a3af..a2508a8 100644</span>
<span class="p_header">--- a/include/asm-generic/siginfo.h</span>
<span class="p_header">+++ b/include/asm-generic/siginfo.h</span>
<span class="p_chunk">@@ -17,21 +17,6 @@</span> <span class="p_context"></span>
 struct siginfo;
 void do_schedule_next_timer(struct siginfo *info);
 
<span class="p_del">-#ifndef HAVE_ARCH_COPY_SIGINFO</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/string.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (from-&gt;si_code &lt; 0)</span>
<span class="p_del">-		memcpy(to, from, sizeof(*to));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* _sigchld is currently the largest know union member */</span>
<span class="p_del">-		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from-&gt;_sifields._sigchld));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
 
 #endif
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index c3a9c8f..5e13b98 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -39,8 +39,11 @@</span> <span class="p_context"> struct can_priv {</span>
 	struct can_clock clock;
 
 	enum can_state state;
<span class="p_del">-	u32 ctrlmode;</span>
<span class="p_del">-	u32 ctrlmode_supported;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* CAN controller features - see include/uapi/linux/can/netlink.h */</span>
<span class="p_add">+	u32 ctrlmode;		/* current options setting */</span>
<span class="p_add">+	u32 ctrlmode_supported;	/* options that can be modified by netlink */</span>
<span class="p_add">+	u32 ctrlmode_static;	/* static enabled options for driver/hardware */</span>
 
 	int restart_ms;
 	struct timer_list restart_timer;
<span class="p_chunk">@@ -107,6 +110,21 @@</span> <span class="p_context"> static inline bool can_is_canfd_skb(const struct sk_buff *skb)</span>
 	return skb-&gt;len == CANFD_MTU;
 }
 
<span class="p_add">+/* helper to define static CAN controller features at device creation time */</span>
<span class="p_add">+static inline void can_set_static_ctrlmode(struct net_device *dev,</span>
<span class="p_add">+					   u32 static_mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct can_priv *priv = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* alloc_candev() succeeded =&gt; netdev_priv() is valid at this point */</span>
<span class="p_add">+	priv-&gt;ctrlmode = static_mode;</span>
<span class="p_add">+	priv-&gt;ctrlmode_static = static_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* override MTU which was set by default in can_setup()? */</span>
<span class="p_add">+	if (static_mode &amp; CAN_CTRLMODE_FD)</span>
<span class="p_add">+		dev-&gt;mtu = CANFD_MTU;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* get data length from can_dlc with sanitized can_dlc */
 u8 can_dlc2len(u8 can_dlc);
 
<span class="p_header">diff --git a/include/linux/device.h b/include/linux/device.h</span>
<span class="p_header">index a2b4ea7..b9f58f8 100644</span>
<span class="p_header">--- a/include/linux/device.h</span>
<span class="p_header">+++ b/include/linux/device.h</span>
<span class="p_chunk">@@ -1236,8 +1236,11 @@</span> <span class="p_context"> do {									\</span>
 		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\
 } while (0)
 #else
<span class="p_del">-#define dev_dbg_ratelimited(dev, fmt, ...)			\</span>
<span class="p_del">-	no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define dev_dbg_ratelimited(dev, fmt, ...)				\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	if (0)								\</span>
<span class="p_add">+		dev_printk(KERN_DEBUG, dev, fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+} while (0)</span>
 #endif
 
 #ifdef VERBOSE_DEBUG
<span class="p_header">diff --git a/include/linux/iio/buffer.h b/include/linux/iio/buffer.h</span>
<span class="p_header">index 1600c55..e776fe4 100644</span>
<span class="p_header">--- a/include/linux/iio/buffer.h</span>
<span class="p_header">+++ b/include/linux/iio/buffer.h</span>
<span class="p_chunk">@@ -67,10 +67,12 @@</span> <span class="p_context"> struct iio_buffer_access_funcs {</span>
  * @access:		[DRIVER] buffer access functions associated with the
  *			implementation.
  * @scan_el_dev_attr_list:[INTERN] list of scan element related attributes.
<span class="p_add">+ * @buffer_group:	[INTERN] attributes of the buffer group</span>
  * @scan_el_group:	[DRIVER] attribute group for those attributes not
  *			created from the iio_chan_info array.
  * @pollq:		[INTERN] wait queue to allow for polling on the buffer.
  * @stufftoread:	[INTERN] flag to indicate new data.
<span class="p_add">+ * @attrs:		[INTERN] standard attributes of the buffer</span>
  * @demux_list:		[INTERN] list of operations required to demux the scan.
  * @demux_bounce:	[INTERN] buffer for doing gather from incoming scan.
  * @buffer_list:	[INTERN] entry in the devices list of current buffers.
<span class="p_header">diff --git a/include/linux/lsm_hooks.h b/include/linux/lsm_hooks.h</span>
<span class="p_header">index 9429f05..0045c2c 100644</span>
<span class="p_header">--- a/include/linux/lsm_hooks.h</span>
<span class="p_header">+++ b/include/linux/lsm_hooks.h</span>
<span class="p_chunk">@@ -1797,7 +1797,6 @@</span> <span class="p_context"> struct security_hook_heads {</span>
 	struct list_head tun_dev_attach_queue;
 	struct list_head tun_dev_attach;
 	struct list_head tun_dev_open;
<span class="p_del">-	struct list_head skb_owned_by;</span>
 #endif	/* CONFIG_SECURITY_NETWORK */
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 	struct list_head xfrm_policy_alloc_security;
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 2b05068..63bb576 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1684,7 +1684,7 @@</span> <span class="p_context"> extern void free_highmem_page(struct page *page);</span>
 extern void adjust_managed_page_count(struct page *page, long count);
 extern void mem_init_print_info(const char *str);
 
<span class="p_del">-extern void reserve_bootmem_region(unsigned long start, unsigned long end);</span>
<span class="p_add">+extern void reserve_bootmem_region(phys_addr_t start, phys_addr_t end);</span>
 
 /* Free the reserved page into the buddy system, so it gets managed. */
 static inline void __free_reserved_page(struct page *page)
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index 92557bb..d80259a 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -28,6 +28,21 @@</span> <span class="p_context"> struct sigpending {</span>
 	sigset_t signal;
 };
 
<span class="p_add">+#ifndef HAVE_ARCH_COPY_SIGINFO</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (from-&gt;si_code &lt; 0)</span>
<span class="p_add">+		memcpy(to, from, sizeof(*to));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* _sigchld is currently the largest know union member */</span>
<span class="p_add">+		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from-&gt;_sifields._sigchld));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * Define some primitives to manipulate sigset_t.
  */
<span class="p_header">diff --git a/include/linux/sunrpc/msg_prot.h b/include/linux/sunrpc/msg_prot.h</span>
<span class="p_header">index 8073713..59cbf16 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/msg_prot.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/msg_prot.h</span>
<span class="p_chunk">@@ -158,9 +158,9 @@</span> <span class="p_context"> typedef __be32	rpc_fraghdr;</span>
 
 /*
  * Note that RFC 1833 does not put any size restrictions on the
<span class="p_del">- * netid string, but all currently defined netid&#39;s fit in 4 bytes.</span>
<span class="p_add">+ * netid string, but all currently defined netid&#39;s fit in 5 bytes.</span>
  */
<span class="p_del">-#define RPCBIND_MAXNETIDLEN	(4u)</span>
<span class="p_add">+#define RPCBIND_MAXNETIDLEN	(5u)</span>
 
 /*
  * Universal addresses are introduced in RFC 1833 and further spelled
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 245524a2..d28c904 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -339,7 +339,6 @@</span> <span class="p_context"> struct tty_file_private {</span>
 #define TTY_EXCLUSIVE 		3	/* Exclusive open mode */
 #define TTY_DEBUG 		4	/* Debugging */
 #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
<span class="p_del">-#define TTY_OTHER_DONE		6	/* Closed pty has completed input processing */</span>
 #define TTY_LDISC_OPEN	 	11	/* Line discipline is open */
 #define TTY_PTY_LOCK 		16	/* pty private */
 #define TTY_NO_WRITE_SPLIT 	17	/* Preserve write boundaries to driver */
<span class="p_chunk">@@ -467,6 +466,9 @@</span> <span class="p_context"> extern void tty_buffer_free_all(struct tty_port *port);</span>
 extern void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld);
 extern void tty_buffer_init(struct tty_port *port);
 extern void tty_buffer_set_lock_subclass(struct tty_port *port);
<span class="p_add">+extern bool tty_buffer_restart_work(struct tty_port *port);</span>
<span class="p_add">+extern bool tty_buffer_cancel_work(struct tty_port *port);</span>
<span class="p_add">+extern void tty_buffer_flush_work(struct tty_port *port);</span>
 extern speed_t tty_termios_baud_rate(struct ktermios *termios);
 extern speed_t tty_termios_input_baud_rate(struct ktermios *termios);
 extern void tty_termios_encode_baud_rate(struct ktermios *termios,
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index 447fe29..cb79359 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -367,14 +367,13 @@</span> <span class="p_context"> struct usb_bus {</span>
 
 	int devnum_next;		/* Next open device number in
 					 * round-robin allocation */
<span class="p_add">+	struct mutex devnum_next_mutex; /* devnum_next mutex */</span>
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
 	struct list_head bus_list;	/* list of busses */
 
<span class="p_del">-	struct mutex usb_address0_mutex; /* unaddressed device mutex */</span>
<span class="p_del">-</span>
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
 					 * requests is used, on average?
<span class="p_chunk">@@ -1060,7 +1059,7 @@</span> <span class="p_context"> struct usbdrv_wrap {</span>
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver&#39;s disconnect method.
<span class="p_del">- * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs</span>
<span class="p_add">+ * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs</span>
  *	to initiate lower power link state transitions when an idle timeout
  *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *
<span class="p_header">diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h</span>
<span class="p_header">index c9aa779..0579a7a 100644</span>
<span class="p_header">--- a/include/linux/usb/hcd.h</span>
<span class="p_header">+++ b/include/linux/usb/hcd.h</span>
<span class="p_chunk">@@ -169,6 +169,7 @@</span> <span class="p_context"> struct usb_hcd {</span>
 	 * bandwidth_mutex should be dropped after a successful control message
 	 * to the device, or resetting the bandwidth after a failed attempt.
 	 */
<span class="p_add">+	struct mutex		*address0_mutex;</span>
 	struct mutex		*bandwidth_mutex;
 	struct usb_hcd		*shared_hcd;
 	struct usb_hcd		*primary_hcd;
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index ae84b22..0403c1b 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -259,6 +259,7 @@</span> <span class="p_context"> scmd_printk(const char *, const struct scsi_cmnd *, const char *, ...);</span>
 enum scsi_target_state {
 	STARGET_CREATED = 1,
 	STARGET_RUNNING,
<span class="p_add">+	STARGET_REMOVE,</span>
 	STARGET_DEL,
 };
 
<span class="p_header">diff --git a/include/uapi/linux/libc-compat.h b/include/uapi/linux/libc-compat.h</span>
<span class="p_header">index d5e38c7..e4f048e 100644</span>
<span class="p_header">--- a/include/uapi/linux/libc-compat.h</span>
<span class="p_header">+++ b/include/uapi/linux/libc-compat.h</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"></span>
 #if defined(__GLIBC__)
 
 /* Coordinate with glibc net/if.h header. */
<span class="p_del">-#if defined(_NET_IF_H)</span>
<span class="p_add">+#if defined(_NET_IF_H) &amp;&amp; defined(__USE_MISC)</span>
 
 /* GLIBC headers included first so don&#39;t define anything
  * that would already be defined. */
<span class="p_header">diff --git a/kernel/exit.c b/kernel/exit.c</span>
<span class="p_header">index 031325e..269831c 100644</span>
<span class="p_header">--- a/kernel/exit.c</span>
<span class="p_header">+++ b/kernel/exit.c</span>
<span class="p_chunk">@@ -914,17 +914,28 @@</span> <span class="p_context"> static int eligible_pid(struct wait_opts *wo, struct task_struct *p)</span>
 		task_pid_type(p, wo-&gt;wo_type) == wo-&gt;wo_pid;
 }
 
<span class="p_del">-static int eligible_child(struct wait_opts *wo, struct task_struct *p)</span>
<span class="p_add">+static int</span>
<span class="p_add">+eligible_child(struct wait_opts *wo, bool ptrace, struct task_struct *p)</span>
 {
 	if (!eligible_pid(wo, p))
 		return 0;
<span class="p_del">-	/* Wait for all children (clone and not) if __WALL is set;</span>
<span class="p_del">-	 * otherwise, wait for clone children *only* if __WCLONE is</span>
<span class="p_del">-	 * set; otherwise, wait for non-clone children *only*.  (Note:</span>
<span class="p_del">-	 * A &quot;clone&quot; child here is one that reports to its parent</span>
<span class="p_del">-	 * using a signal other than SIGCHLD.) */</span>
<span class="p_del">-	if (((p-&gt;exit_signal != SIGCHLD) ^ !!(wo-&gt;wo_flags &amp; __WCLONE))</span>
<span class="p_del">-	    &amp;&amp; !(wo-&gt;wo_flags &amp; __WALL))</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for all children (clone and not) if __WALL is set or</span>
<span class="p_add">+	 * if it is traced by us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ptrace || (wo-&gt;wo_flags &amp; __WALL))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Otherwise, wait for clone children *only* if __WCLONE is set;</span>
<span class="p_add">+	 * otherwise, wait for non-clone children *only*.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: a &quot;clone&quot; child here is one that reports to its parent</span>
<span class="p_add">+	 * using a signal other than SIGCHLD, or a non-leader thread which</span>
<span class="p_add">+	 * we can only see if it is traced by us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((p-&gt;exit_signal != SIGCHLD) ^ !!(wo-&gt;wo_flags &amp; __WCLONE))</span>
 		return 0;
 
 	return 1;
<span class="p_chunk">@@ -1297,7 +1308,7 @@</span> <span class="p_context"> static int wait_consider_task(struct wait_opts *wo, int ptrace,</span>
 	if (unlikely(exit_state == EXIT_DEAD))
 		return 0;
 
<span class="p_del">-	ret = eligible_child(wo, p);</span>
<span class="p_add">+	ret = eligible_child(wo, ptrace, p);</span>
 	if (!ret)
 		return ret;
 
<span class="p_header">diff --git a/kernel/sched/loadavg.c b/kernel/sched/loadavg.c</span>
<span class="p_header">index ef71590..b0b93fd 100644</span>
<span class="p_header">--- a/kernel/sched/loadavg.c</span>
<span class="p_header">+++ b/kernel/sched/loadavg.c</span>
<span class="p_chunk">@@ -99,10 +99,13 @@</span> <span class="p_context"> long calc_load_fold_active(struct rq *this_rq)</span>
 static unsigned long
 calc_load(unsigned long load, unsigned long exp, unsigned long active)
 {
<span class="p_del">-	load *= exp;</span>
<span class="p_del">-	load += active * (FIXED_1 - exp);</span>
<span class="p_del">-	load += 1UL &lt;&lt; (FSHIFT - 1);</span>
<span class="p_del">-	return load &gt;&gt; FSHIFT;</span>
<span class="p_add">+	unsigned long newload;</span>
<span class="p_add">+</span>
<span class="p_add">+	newload = load * exp + active * (FIXED_1 - exp);</span>
<span class="p_add">+	if (active &gt;= load)</span>
<span class="p_add">+		newload += FIXED_1-1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return newload / FIXED_1;</span>
 }
 
 #ifdef CONFIG_NO_HZ_COMMON
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 40718df..f683029 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -426,7 +426,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	raw_spinlock_t			reader_lock;	/* serialize readers */
 	arch_spinlock_t			lock;
 	struct lock_class_key		lock_key;
<span class="p_del">-	unsigned int			nr_pages;</span>
<span class="p_add">+	unsigned long			nr_pages;</span>
 	unsigned int			current_context;
 	struct list_head		*pages;
 	struct buffer_page		*head_page;	/* read from head */
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	u64				write_stamp;
 	u64				read_stamp;
 	/* ring buffer pages to update, &gt; 0 to add, &lt; 0 to remove */
<span class="p_del">-	int				nr_pages_to_update;</span>
<span class="p_add">+	long				nr_pages_to_update;</span>
 	struct list_head		new_pages; /* new pages to add */
 	struct work_struct		update_pages_work;
 	struct completion		update_done;
<span class="p_chunk">@@ -1126,10 +1126,10 @@</span> <span class="p_context"> static int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	return 0;
 }
 
<span class="p_del">-static int __rb_allocate_pages(int nr_pages, struct list_head *pages, int cpu)</span>
<span class="p_add">+static int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)</span>
 {
<span class="p_del">-	int i;</span>
 	struct buffer_page *bpage, *tmp;
<span class="p_add">+	long i;</span>
 
 	for (i = 0; i &lt; nr_pages; i++) {
 		struct page *page;
<span class="p_chunk">@@ -1166,7 +1166,7 @@</span> <span class="p_context"> free_pages:</span>
 }
 
 static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
<span class="p_del">-			     unsigned nr_pages)</span>
<span class="p_add">+			     unsigned long nr_pages)</span>
 {
 	LIST_HEAD(pages);
 
<span class="p_chunk">@@ -1191,7 +1191,7 @@</span> <span class="p_context"> static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,</span>
 }
 
 static struct ring_buffer_per_cpu *
<span class="p_del">-rb_allocate_cpu_buffer(struct ring_buffer *buffer, int nr_pages, int cpu)</span>
<span class="p_add">+rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)</span>
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	struct buffer_page *bpage;
<span class="p_chunk">@@ -1291,8 +1291,9 @@</span> <span class="p_context"> struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span>
 					struct lock_class_key *key)
 {
 	struct ring_buffer *buffer;
<span class="p_add">+	long nr_pages;</span>
 	int bsize;
<span class="p_del">-	int cpu, nr_pages;</span>
<span class="p_add">+	int cpu;</span>
 
 	/* keep it in its own cache line */
 	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),
<span class="p_chunk">@@ -1418,12 +1419,12 @@</span> <span class="p_context"> static inline unsigned long rb_page_write(struct buffer_page *bpage)</span>
 }
 
 static int
<span class="p_del">-rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned int nr_pages)</span>
<span class="p_add">+rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)</span>
 {
 	struct list_head *tail_page, *to_remove, *next_page;
 	struct buffer_page *to_remove_page, *tmp_iter_page;
 	struct buffer_page *last_page, *first_page;
<span class="p_del">-	unsigned int nr_removed;</span>
<span class="p_add">+	unsigned long nr_removed;</span>
 	unsigned long head_bit;
 	int page_entries;
 
<span class="p_chunk">@@ -1640,7 +1641,7 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
<span class="p_del">-	unsigned nr_pages;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 	int cpu, err = 0;
 
 	/*
<span class="p_chunk">@@ -1654,14 +1655,13 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 	    !cpumask_test_cpu(cpu_id, buffer-&gt;cpumask))
 		return size;
 
<span class="p_del">-	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_del">-	size *= BUF_PAGE_SIZE;</span>
<span class="p_add">+	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
 
 	/* we need a minimum of two pages */
<span class="p_del">-	if (size &lt; BUF_PAGE_SIZE * 2)</span>
<span class="p_del">-		size = BUF_PAGE_SIZE * 2;</span>
<span class="p_add">+	if (nr_pages &lt; 2)</span>
<span class="p_add">+		nr_pages = 2;</span>
 
<span class="p_del">-	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_add">+	size = nr_pages * BUF_PAGE_SIZE;</span>
 
 	/*
 	 * Don&#39;t succeed if resizing is disabled, as a reader might be
<span class="p_chunk">@@ -4602,8 +4602,9 @@</span> <span class="p_context"> static int rb_cpu_notify(struct notifier_block *self,</span>
 	struct ring_buffer *buffer =
 		container_of(self, struct ring_buffer, cpu_notify);
 	long cpu = (long)hcpu;
<span class="p_del">-	int cpu_i, nr_pages_same;</span>
<span class="p_del">-	unsigned int nr_pages;</span>
<span class="p_add">+	long nr_pages_same;</span>
<span class="p_add">+	int cpu_i;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 
 	switch (action) {
 	case CPU_UP_PREPARE:
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index d8b4df8..0c66f76 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -657,9 +657,9 @@</span> <span class="p_context"> static struct dma_debug_entry *dma_entry_alloc(void)</span>
 	spin_lock_irqsave(&amp;free_entries_lock, flags);
 
 	if (list_empty(&amp;free_entries)) {
<span class="p_del">-		pr_err(&quot;DMA-API: debugging out of memory - disabling\n&quot;);</span>
 		global_disable = true;
 		spin_unlock_irqrestore(&amp;free_entries_lock, flags);
<span class="p_add">+		pr_err(&quot;DMA-API: debugging out of memory - disabling\n&quot;);</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 6d95dea..51fd491 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -908,7 +908,7 @@</span> <span class="p_context"> static inline void init_reserved_page(unsigned long pfn)</span>
  * marks the pages PageReserved. The remaining valid pages are later
  * sent to the buddy page allocator.
  */
<span class="p_del">-void __meminit reserve_bootmem_region(unsigned long start, unsigned long end)</span>
<span class="p_add">+void __meminit reserve_bootmem_region(phys_addr_t start, phys_addr_t end)</span>
 {
 	unsigned long start_pfn = PFN_DOWN(start);
 	unsigned long end_pfn = PFN_UP(end);
<span class="p_header">diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c</span>
<span class="p_header">index cf57b20..fe25db2 100644</span>
<span class="p_header">--- a/net/batman-adv/routing.c</span>
<span class="p_header">+++ b/net/batman-adv/routing.c</span>
<span class="p_chunk">@@ -585,6 +585,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 	struct batadv_unicast_packet *unicast_packet;
 	struct ethhdr *ethhdr = eth_hdr(skb);
 	int res, hdr_len, ret = NET_RX_DROP;
<span class="p_add">+	unsigned int len;</span>
 
 	unicast_packet = (struct batadv_unicast_packet *)skb-&gt;data;
 
<span class="p_chunk">@@ -625,6 +626,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 	if (hdr_len &gt; 0)
 		batadv_skb_set_priority(skb, hdr_len);
 
<span class="p_add">+	len = skb-&gt;len;</span>
 	res = batadv_send_skb_to_orig(skb, orig_node, recv_if);
 
 	/* translate transmit result into receive result */
<span class="p_chunk">@@ -632,7 +634,7 @@</span> <span class="p_context"> static int batadv_route_unicast_packet(struct sk_buff *skb,</span>
 		/* skb was transmitted and consumed */
 		batadv_inc_counter(bat_priv, BATADV_CNT_FORWARD);
 		batadv_add_counter(bat_priv, BATADV_CNT_FORWARD_BYTES,
<span class="p_del">-				   skb-&gt;len + ETH_HLEN);</span>
<span class="p_add">+				   len + ETH_HLEN);</span>
 
 		ret = NET_RX_SUCCESS;
 	} else if (res == NET_XMIT_POLICED) {
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 335f495..135f1b8 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4737,15 +4737,13 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 {
 	struct inet6_ifaddr *ifp;
 	struct net_device *dev = idev-&gt;dev;
<span class="p_del">-	bool update_rs = false;</span>
<span class="p_add">+	bool clear_token, update_rs = false;</span>
 	struct in6_addr ll_addr;
 
 	ASSERT_RTNL();
 
 	if (!token)
 		return -EINVAL;
<span class="p_del">-	if (ipv6_addr_any(token))</span>
<span class="p_del">-		return -EINVAL;</span>
 	if (dev-&gt;flags &amp; (IFF_LOOPBACK | IFF_NOARP))
 		return -EINVAL;
 	if (!ipv6_accept_ra(idev))
<span class="p_chunk">@@ -4760,10 +4758,13 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 
 	write_unlock_bh(&amp;idev-&gt;lock);
 
<span class="p_add">+	clear_token = ipv6_addr_any(token);</span>
<span class="p_add">+	if (clear_token)</span>
<span class="p_add">+		goto update_lft;</span>
<span class="p_add">+</span>
 	if (!idev-&gt;dead &amp;&amp; (idev-&gt;if_flags &amp; IF_READY) &amp;&amp;
 	    !ipv6_get_lladdr(dev, &amp;ll_addr, IFA_F_TENTATIVE |
 			     IFA_F_OPTIMISTIC)) {
<span class="p_del">-</span>
 		/* If we&#39;re not ready, then normal ifup will take care
 		 * of this. Otherwise, we need to request our rs here.
 		 */
<span class="p_chunk">@@ -4771,6 +4772,7 @@</span> <span class="p_context"> static int inet6_set_iftoken(struct inet6_dev *idev, struct in6_addr *token)</span>
 		update_rs = true;
 	}
 
<span class="p_add">+update_lft:</span>
 	write_lock_bh(&amp;idev-&gt;lock);
 
 	if (update_rs) {
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 08bd219..c216bff 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2755,6 +2755,7 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
<span class="p_add">+	struct module *module;</span>
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;
<span class="p_chunk">@@ -2835,9 +2836,11 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 		cb-&gt;done(cb);
 
 	nlk-&gt;cb_running = false;
<span class="p_add">+	module = cb-&gt;module;</span>
<span class="p_add">+	skb = cb-&gt;skb;</span>
 	mutex_unlock(nlk-&gt;cb_mutex);
<span class="p_del">-	module_put(cb-&gt;module);</span>
<span class="p_del">-	consume_skb(cb-&gt;skb);</span>
<span class="p_add">+	module_put(module);</span>
<span class="p_add">+	consume_skb(skb);</span>
 	return 0;
 
 errout_skb:
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 1095be9..4605dc7 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -857,8 +857,8 @@</span> <span class="p_context"> unwrap_integ_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct g</span>
 		goto out;
 	if (svc_getnl(&amp;buf-&gt;head[0]) != seq)
 		goto out;
<span class="p_del">-	/* trim off the mic at the end before returning */</span>
<span class="p_del">-	xdr_buf_trim(buf, mic.len + 4);</span>
<span class="p_add">+	/* trim off the mic and padding at the end before returning */</span>
<span class="p_add">+	xdr_buf_trim(buf, round_up_to_quad(mic.len) + 4);</span>
 	stat = 0;
 out:
 	kfree(mic.data);
<span class="p_header">diff --git a/net/tipc/netlink_compat.c b/net/tipc/netlink_compat.c</span>
<span class="p_header">index 53e0fee..cd6346b 100644</span>
<span class="p_header">--- a/net/tipc/netlink_compat.c</span>
<span class="p_header">+++ b/net/tipc/netlink_compat.c</span>
<span class="p_chunk">@@ -802,7 +802,7 @@</span> <span class="p_context"> static int tipc_nl_compat_name_table_dump(struct tipc_nl_compat_msg *msg,</span>
 		goto out;
 
 	tipc_tlv_sprintf(msg-&gt;rep, &quot;%-10u %s&quot;,
<span class="p_del">-			 nla_get_u32(publ[TIPC_NLA_PUBL_REF]),</span>
<span class="p_add">+			 nla_get_u32(publ[TIPC_NLA_PUBL_KEY]),</span>
 			 scope_str[nla_get_u32(publ[TIPC_NLA_PUBL_SCOPE])]);
 out:
 	tipc_tlv_sprintf(msg-&gt;rep, &quot;\n&quot;);
<span class="p_header">diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn</span>
<span class="p_header">index 0f8ba77..7339c39 100644</span>
<span class="p_header">--- a/scripts/Makefile.extrawarn</span>
<span class="p_header">+++ b/scripts/Makefile.extrawarn</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> warning-1 += $(call cc-option, -Wmissing-prototypes)</span>
 warning-1 += -Wold-style-definition
 warning-1 += $(call cc-option, -Wmissing-include-dirs)
 warning-1 += $(call cc-option, -Wunused-but-set-variable)
<span class="p_add">+warning-1 += $(call cc-option, -Wunused-const-variable)</span>
 warning-1 += $(call cc-disable-warning, missing-field-initializers)
 warning-1 += $(call cc-disable-warning, sign-compare)
 
<span class="p_header">diff --git a/security/security.c b/security/security.c</span>
<span class="p_header">index 9942836..1fbe2c1 100644</span>
<span class="p_header">--- a/security/security.c</span>
<span class="p_header">+++ b/security/security.c</span>
<span class="p_chunk">@@ -1843,7 +1843,6 @@</span> <span class="p_context"> struct security_hook_heads security_hook_heads = {</span>
 	.tun_dev_attach =
 		LIST_HEAD_INIT(security_hook_heads.tun_dev_attach),
 	.tun_dev_open =	LIST_HEAD_INIT(security_hook_heads.tun_dev_open),
<span class="p_del">-	.skb_owned_by =	LIST_HEAD_INIT(security_hook_heads.skb_owned_by),</span>
 #endif	/* CONFIG_SECURITY_NETWORK */
 #ifdef CONFIG_SECURITY_NETWORK_XFRM
 	.xfrm_policy_alloc_security =
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index f3f73f8..ac56e0c 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5408,8 +5408,9 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
 	SND_PCI_QUIRK(0x1028, 0x06df, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
 	SND_PCI_QUIRK(0x1028, 0x06e0, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13 9350&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x0725, &quot;Dell Inspiron 3162&quot;, ALC255_FIXUP_DELL_SPK_NOISE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x075b, &quot;Dell XPS 13 9360&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_header">diff --git a/sound/soc/codecs/ak4642.c b/sound/soc/codecs/ak4642.c</span>
<span class="p_header">index 7c0f6552..d41708f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ak4642.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ak4642.c</span>
<span class="p_chunk">@@ -538,6 +538,7 @@</span> <span class="p_context"> static const struct regmap_config ak4642_regmap = {</span>
 	.max_register		= ARRAY_SIZE(ak4642_reg) + 1,
 	.reg_defaults		= ak4642_reg,
 	.num_reg_defaults	= ARRAY_SIZE(ak4642_reg),
<span class="p_add">+	.cache_type		= REGCACHE_RBTREE,</span>
 };
 
 static const struct regmap_config ak4648_regmap = {
<span class="p_chunk">@@ -546,6 +547,7 @@</span> <span class="p_context"> static const struct regmap_config ak4648_regmap = {</span>
 	.max_register		= ARRAY_SIZE(ak4648_reg) + 1,
 	.reg_defaults		= ak4648_reg,
 	.num_reg_defaults	= ARRAY_SIZE(ak4648_reg),
<span class="p_add">+	.cache_type		= REGCACHE_RBTREE,</span>
 };
 
 static const struct ak4642_drvdata ak4642_drvdata = {
<span class="p_header">diff --git a/tools/perf/tests/vmlinux-kallsyms.c b/tools/perf/tests/vmlinux-kallsyms.c</span>
<span class="p_header">index b34c5fc..8de34ea 100644</span>
<span class="p_header">--- a/tools/perf/tests/vmlinux-kallsyms.c</span>
<span class="p_header">+++ b/tools/perf/tests/vmlinux-kallsyms.c</span>
<span class="p_chunk">@@ -54,8 +54,14 @@</span> <span class="p_context"> int test__vmlinux_matches_kallsyms(void)</span>
 	 * Step 3:
 	 *
 	 * Load and split /proc/kallsyms into multiple maps, one per module.
<span class="p_add">+	 * Do not use kcore, as this test was designed before kcore support</span>
<span class="p_add">+	 * and has parts that only make sense if using the non-kcore code.</span>
<span class="p_add">+	 * XXX: extend it to stress the kcorre code as well, hint: the list</span>
<span class="p_add">+	 * of modules extracted from /proc/kcore, in its current form, can&#39;t</span>
<span class="p_add">+	 * be compacted against the list of modules found in the &quot;vmlinux&quot;</span>
<span class="p_add">+	 * code and with the one got from /proc/modules from the &quot;kallsyms&quot; code.</span>
 	 */
<span class="p_del">-	if (machine__load_kallsyms(&amp;kallsyms, &quot;/proc/kallsyms&quot;, type, NULL) &lt;= 0) {</span>
<span class="p_add">+	if (__machine__load_kallsyms(&amp;kallsyms, &quot;/proc/kallsyms&quot;, type, true, NULL) &lt;= 0) {</span>
 		pr_debug(&quot;dso__load_kallsyms &quot;);
 		goto out;
 	}
<span class="p_header">diff --git a/tools/perf/util/perf_regs.c b/tools/perf/util/perf_regs.c</span>
<span class="p_header">index 43168fb..2fb6f2a 100644</span>
<span class="p_header">--- a/tools/perf/util/perf_regs.c</span>
<span class="p_header">+++ b/tools/perf/util/perf_regs.c</span>
<span class="p_chunk">@@ -7,18 +7,18 @@</span> <span class="p_context"> int perf_reg_value(u64 *valp, struct regs_dump *regs, int id)</span>
 	int i, idx = 0;
 	u64 mask = regs-&gt;mask;
 
<span class="p_del">-	if (regs-&gt;cache_mask &amp; (1 &lt;&lt; id))</span>
<span class="p_add">+	if (regs-&gt;cache_mask &amp; (1ULL &lt;&lt; id))</span>
 		goto out;
 
<span class="p_del">-	if (!(mask &amp; (1 &lt;&lt; id)))</span>
<span class="p_add">+	if (!(mask &amp; (1ULL &lt;&lt; id)))</span>
 		return -EINVAL;
 
 	for (i = 0; i &lt; id; i++) {
<span class="p_del">-		if (mask &amp; (1 &lt;&lt; i))</span>
<span class="p_add">+		if (mask &amp; (1ULL &lt;&lt; i))</span>
 			idx++;
 	}
 
<span class="p_del">-	regs-&gt;cache_mask |= (1 &lt;&lt; id);</span>
<span class="p_add">+	regs-&gt;cache_mask |= (1ULL &lt;&lt; id);</span>
 	regs-&gt;cache_regs[id] = regs-&gt;regs[idx];
 
 out:

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



