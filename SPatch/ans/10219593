
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.54 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.54</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 14, 2018, 6:09 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180214180903.GD8564@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10219593/mbox/"
   >mbox</a>
|
   <a href="/patch/10219593/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10219593/">/patch/10219593/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	83FB560467 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 14 Feb 2018 18:09:50 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1F62D29003
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 14 Feb 2018 18:09:50 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0FA5E2900E; Wed, 14 Feb 2018 18:09:50 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4909C29003
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 14 Feb 2018 18:09:40 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1161689AbeBNSJd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 14 Feb 2018 13:09:33 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:38726 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1161672AbeBNSJS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 14 Feb 2018 13:09:18 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1em1UN-0007Ja-Fl; Wed, 14 Feb 2018 18:09:13 +0000
Date: Wed, 14 Feb 2018 18:09:03 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20180214180903.GD8564@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;+jhVVhN62yS6hEJ8&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.54
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Feb. 14, 2018, 6:09 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.54 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.53 is attached to this message.

Ben.

------------

 .../devicetree/bindings/sound/cs42l56.txt          |   2 +-
 Makefile                                           |   2 +-
 arch/arm/mm/dump.c                                 |   4 +-
 arch/arm64/kernel/vdso/gettimeofday.S              |   3 +-
 arch/mips/kernel/ptrace.c                          |  17 ++
 arch/parisc/kernel/syscall.S                       |   6 +-
 arch/powerpc/kernel/vio.c                          |   2 +
 arch/powerpc/platforms/powernv/opal-async.c        |   6 +-
 arch/powerpc/platforms/powernv/setup.c             |   2 +-
 arch/s390/include/asm/switch_to.h                  |   2 +-
 arch/s390/kernel/dis.c                             |   4 +-
 arch/s390/kernel/early.c                           |   4 +-
 arch/s390/kernel/process.c                         |   1 +
 arch/s390/kernel/runtime_instr.c                   |   4 +-
 arch/x86/include/asm/fixmap.h                      |  11 +-
 arch/x86/include/asm/pvclock.h                     |  15 +-
 arch/x86/include/asm/vdso.h                        |  19 +-
 arch/x86/kernel/alternative.c                      |  26 +-
 arch/x86/kernel/kvmclock.c                         |  16 +-
 arch/x86/kernel/pvclock.c                          |  68 -----
 arch/x86/kvm/svm.c                                 |   7 +
 arch/x86/kvm/vmx.c                                 |   4 +
 arch/x86/kvm/x86.c                                 |   5 +-
 arch/x86/kvm/x86.h                                 |   2 +
 arch/x86/lib/x86-opcode-map.txt                    |   2 +-
 arch/x86/mm/kaiser.c                               |   7 +-
 arch/x86/platform/uv/uv_nmi.c                      |   1 +
 arch/x86/vdso/vclock_gettime.c                     | 103 ++++---
 arch/x86/vdso/vdso-layout.lds.S                    |  45 ++-
 arch/x86/vdso/vdso2c.c                             |  15 +-
 arch/x86/vdso/vdso2c.h                             |  25 +-
 arch/x86/vdso/vma.c                                |  34 ++-
 block/blk-core.c                                   |   3 +
 drivers/acpi/apei/ghes.c                           |  85 +-----
 drivers/char/ipmi/ipmi_msghandler.c                |  10 +-
 drivers/char/tpm/tpm-dev.c                         |   6 +
 drivers/clk/tegra/clk-tegra30.c                    |   2 +-
 drivers/clk/ti/clk-dra7-atl.c                      |   3 +-
 drivers/crypto/caam/desc.h                         |   2 +-
 drivers/gpu/drm/gma500/mdfld_intel_display.c       |   2 +-
 drivers/gpu/drm/i915/intel_bios.c                  |   2 +-
 drivers/gpu/drm/i915/intel_display.c               |  14 +-
 drivers/gpu/drm/i915/intel_dp.c                    |   2 +-
 drivers/gpu/drm/radeon/atombios_dp.c               |  38 ++-
 drivers/gpu/drm/ttm/ttm_bo_util.c                  |   1 +
 drivers/infiniband/hw/mlx4/qp.c                    |   2 +-
 drivers/infiniband/hw/mlx5/main.c                  |   2 +
 drivers/infiniband/ulp/srp/ib_srp.c                |  23 +-
 drivers/infiniband/ulp/srpt/ib_srpt.c              |   9 +-
 drivers/input/misc/adxl34x.c                       |   2 +-
 drivers/iommu/dmar.c                               |   7 +-
 drivers/iommu/intel-iommu.c                        |  10 +
 drivers/md/bcache/alloc.c                          |   3 +-
 drivers/md/bcache/request.c                        |  10 +-
 drivers/md/dm-bufio.c                              |  15 +-
 drivers/md/dm-table.c                              |  32 +-
 drivers/md/dm.c                                    |  12 +-
 drivers/media/platform/omap/omap_vout.c            |   3 +-
 drivers/media/rc/ir-lirc-codec.c                   |   9 +-
 drivers/media/usb/cx231xx/cx231xx-cards.c          |   3 +-
 drivers/mtd/nand/nand_base.c                       |   9 +-
 drivers/mtd/nand/omap2.c                           | 340 ++++++++++++++-------
 drivers/net/ethernet/broadcom/genet/bcmgenet.c     |  56 +---
 drivers/net/ethernet/intel/i40e/i40e_main.c        |   2 +-
 drivers/net/ethernet/intel/i40e/i40e_txrx.c        |   2 +-
 drivers/net/ethernet/intel/i40evf/i40e_txrx.c      |   2 +-
 drivers/net/ethernet/intel/igb/igb_main.c          |   2 +-
 drivers/net/ethernet/intel/igbvf/netdev.c          |   2 +-
 drivers/net/ethernet/intel/ixgbe/ixgbe_main.c      |   2 +-
 drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c  |   2 +-
 drivers/net/wireless/p54/main.c                    |   7 +-
 drivers/net/wireless/rt2x00/rt2x00usb.c            |   6 +-
 drivers/pci/pcie/aer/aerdrv_core.c                 |   9 +-
 drivers/platform/x86/sony-laptop.c                 |  14 +-
 drivers/rtc/interface.c                            |  16 +-
 drivers/scsi/bfa/bfad_debugfs.c                    |   5 +-
 drivers/staging/android/ashmem.c                   |   2 +
 drivers/staging/lustre/lustre/ptlrpc/sec.c         |   2 +-
 drivers/staging/rtl8188eu/core/rtw_mlme.c          |   3 +-
 drivers/staging/usbip/stub.h                       |   1 -
 drivers/staging/usbip/stub_dev.c                   |   4 +-
 drivers/staging/usbip/stub_rx.c                    |  66 ++--
 drivers/staging/usbip/stub_tx.c                    |  13 +-
 drivers/staging/usbip/usbip_common.h               |   1 +
 drivers/staging/usbip/userspace/Makefile.am        |   3 +-
 .../staging/usbip/userspace/libsrc/vhci_driver.c   |   8 +-
 drivers/staging/usbip/vhci_sysfs.c                 |  20 +-
 drivers/target/iscsi/iscsi_target.c                |  49 ++-
 drivers/target/target_core_tmr.c                   |  10 +
 drivers/target/target_core_transport.c             |   2 +
 drivers/usb/core/devio.c                           |  14 +
 drivers/usb/core/quirks.c                          |   3 +
 drivers/usb/serial/garmin_gps.c                    |  22 +-
 drivers/usb/serial/metro-usb.c                     |  11 +-
 drivers/usb/serial/qcserial.c                      |   1 +
 drivers/video/fbdev/udlfb.c                        |  10 +-
 fs/9p/vfs_inode.c                                  |   3 +
 fs/9p/vfs_inode_dotl.c                             |   3 +
 fs/autofs4/waitq.c                                 |  16 +-
 fs/binfmt_elf_fdpic.c                              |   2 +
 fs/btrfs/super.c                                   |   4 +-
 fs/coda/upcall.c                                   |   3 +-
 fs/ecryptfs/messaging.c                            |   7 +-
 fs/ext4/extents.c                                  |   6 +-
 fs/f2fs/file.c                                     |   5 +
 fs/f2fs/segment.c                                  |  20 +-
 fs/isofs/isofs.h                                   |   2 +-
 fs/isofs/rock.h                                    |   2 +-
 fs/isofs/util.c                                    |   2 +-
 fs/nfs/nfs4proc.c                                  |  18 +-
 fs/nfs/nfs4trace.h                                 |   8 +-
 fs/nfs/super.c                                     |   2 +-
 fs/nilfs2/segment.c                                |   6 +-
 include/linux/blkdev.h                             |   1 +
 include/linux/dmar.h                               |   1 +
 include/linux/sched.h                              |   8 -
 include/net/sctp/sctp.h                            |   2 +
 include/net/sctp/structs.h                         |   8 +-
 include/target/target_core_base.h                  |   2 +
 kernel/extable.c                                   |   2 +
 kernel/sched/core.c                                |  15 -
 kernel/trace/blktrace.c                            |  76 ++++-
 lib/int_sqrt.c                                     |   3 +
 net/9p/client.c                                    |   3 +-
 net/9p/trans_virtio.c                              |  13 +-
 net/bluetooth/l2cap_core.c                         |  20 +-
 net/ipv4/route.c                                   |  14 +-
 net/l2tp/l2tp_core.c                               |  21 +-
 net/l2tp/l2tp_core.h                               |   3 +
 net/l2tp/l2tp_eth.c                                | 101 ++++--
 net/l2tp/l2tp_ppp.c                                | 236 ++++++++------
 net/netfilter/xt_TCPMSS.c                          |   6 +-
 net/nfc/core.c                                     |   2 +-
 net/rds/rdma.c                                     |   4 +
 net/sctp/ipv6.c                                    | 160 +++++-----
 net/sctp/protocol.c                                |  12 +-
 net/sctp/socket.c                                  |  33 +-
 net/sctp/transport.c                               |   4 +-
 net/sctp/ulpevent.c                                |   2 +-
 net/wireless/nl80211.c                             |  26 +-
 security/apparmor/domain.c                         |  53 +++-
 security/integrity/ima/ima_main.c                  |   4 +
 sound/core/seq/seq_clientmgr.c                     |  10 +-
 sound/core/seq/seq_clientmgr.h                     |   1 +
 sound/core/timer_compat.c                          |  12 +-
 sound/pci/hda/hda_intel.c                          |   3 +
 sound/usb/clock.c                                  |   9 +-
 sound/usb/mixer.c                                  |  15 +-
 148 files changed, 1470 insertions(+), 1021 deletions(-)

Alan Stern (1):
      USB: usbfs: compute urb-&gt;actual_length for isochronous

Alexander Popov (1):
      usbip: fix NULL pointer dereference on errors

Alexander Potapenko (1):
      sctp: fully initialize the IPv6 address in sctp_v6_to_addr()

Alexander Steffen (1):
      tpm-dev-common: Reject too short writes

Alexandre Belloni (1):
      rtc: set the alarm to the next expiring timer

Andreas Rohner (1):
      nilfs2: fix race condition that causes file system corruption

Andrew F. Davis (1):
      ASoC: cs42l56: Fix reset GPIO name in example DT binding

Andrey Konovalov (1):
      p54: don&#39;t unregister leds when they are not initialized

Andy Lutomirski (4):
      x86, vdso: Move the vvar area before the vdso text
      x86, vdso, pvclock: Simplify and speed up the vdso pvclock reader
      x86/vdso: Get pvclock data from the vvar VMA instead of the fixmap
      x86/vdso: Remove pvclock fixmap machinery

Anna Schumaker (1):
      NFS: Avoid RCU usage in tracepoints

Arnd Bergmann (4):
      drm: gma500: fix logic error
      Input: adxl34x - do not treat FIFO_MODE() as boolean
      elf_fdpic: fix unused variable warning
      isofs: fix timestamps beyond 2027

Bart Van Assche (3):
      IB/srpt: Do not accept invalid initiator port names
      IB/srp: Avoid that a cable pull can trigger a kernel crash
      target/iscsi: Fix iSCSI task reassignment handling

Ben Hutchings (2):
      usbip: tools: Install all headers needed for libusbip development
      Linux 3.16.54

Ben Seri (1):
      Bluetooth: Prevent stack info leak from the EFS element.

Bernhard Rosenkraenzer (1):
      USB: Add delay-init quirk for Corsair K70 LUX keyboards

Boshi Wang (1):
      ima: fix hash algorithm initialization

Brent Taylor (1):
      mtd: nand: Fix writing mtdoops to nand flash.

Brian King (6):
      ixgbe: Fix skb list corruption on Power systems
      i40e: Use smp_rmb rather than read_barrier_depends
      ixgbevf: Use smp_rmb rather than read_barrier_depends
      igbvf: Use smp_rmb rather than read_barrier_depends
      igb: Use smp_rmb rather than read_barrier_depends
      i40evf: Use smp_rmb rather than read_barrier_depends

Christian König (1):
      drm/ttm: once more fix ttm_buffer_object_transfer

Chuck Lever (1):
      nfs: Fix ugly referral attributes

Colin Ian King (3):
      rtc: interface: ignore expired timers when enqueuing new timers
      btrfs: avoid null pointer dereference on fs_info when calling btrfs_crit
      staging: rtl8188eu: avoid a null dereference on pmlmepriv

Coly Li (2):
      bcache: check ca-&gt;alloc_thread initialized before wake up it
      bcache: only permit to recovery read error when cache device is clean

Corey Minyard (1):
      ipmi: fix unsigned long underflow

Dan Carpenter (2):
      scsi: bfa: integer overflow in debugfs
      eCryptfs: use after free in ecryptfs_release_messaging()

Dongho Sim (1):
      f2fs: remove redundant lines in allocate_data_block

Doug Berger (1):
      net: bcmgenet: enable loopback during UniMAC sw_reset

Douglas Fischer (1):
      USB: serial: qcserial: add pid/vid for Sierra Wireless EM7355 fw update

Eric Biggers (1):
      dm bufio: fix integer overflow when limiting maximum cache size

Eric Dumazet (1):
      netfilter: xt_TCPMSS: add more sanity tests on tcph-&gt;doff

Eric W. Biederman (1):
      net/sctp: Always set scope_id in sctp_inet6_skb_msgname

Gabriele Paoloni (1):
      PCI/AER: Report non-fatal errors only to the affected endpoint

Guenter Roeck (1):
      kaiser: Set _PAGE_NX only if supported

Guillaume Nault (5):
      l2tp: ensure sessions are freed after their PPPOL2TP socket
      l2tp: don&#39;t register sessions in l2tp_session_create()
      l2tp: initialise l2tp_eth sessions before registering them
      l2tp: protect sock pointer of struct pppol2tp_session with RCU
      l2tp: initialise PPP sessions before registering them

Heiko Carstens (2):
      s390/runtime instrumention: fix possible memory corruption
      s390: fix transactional execution control register handling

Hou Tao (1):
      dm: fix race between dm_get_from_kobject() and __dm_destroy()

Ingo Molnar (1):
      x86/platform/uv: Include clocksource.h for clocksource_touch_watchdog()

Jaegeuk Kim (1):
      f2fs: expose some sectors to user in inline data or dentry case

James Morse (2):
      ACPI / APEI: Replace ioremap_page_range() with fixmap
      ACPI / APEI: Remove ghes_ioremap_area

Jan Harkes (1):
      coda: fix &#39;kernel memory exposure attempt&#39; in fsync

Jani Nikula (1):
      drm/i915/bios: parse DDI ports also for CHV for HDMI DDC pin and DP AUX channel

Jason Gunthorpe (1):
      sctp: Fixup v4mapped behaviour to comply with Sock API

Jens Axboe (1):
      blktrace: fix unlocked access to init/start-stop/teardown

Joerg Roedel (1):
      iommu/vt-d: Don&#39;t register bus-notifier under dmar_global_lock

Johan Hovold (5):
      USB: serial: garmin_gps: fix I/O after failed probe and remove
      USB: serial: garmin_gps: fix memory leak on probe errors
      USB: serial: metro-usb: stop I/O after failed open
      NFC: fix device-allocation error return
      clk: ti: dra7-atl-clock: fix child-node lookups

Johannes Berg (1):
      nl80211: don&#39;t expose wdev-&gt;ssid for most interfaces

John David Anglin (1):
      parisc: Fix validity check of pointer size argument in new CAS implementation

John Johansen (1):
      apparmor: ensure that undecidable profile attachments fail

Joshua Watt (1):
      NFS: Fix typo in nomigration mount option

Juerg Haefliger (1):
      Revert &quot;x86: kvmclock: Disable use from vDSO if KPTI is enabled&quot;

Ladi Prosek (1):
      KVM: nVMX: set IDTR and GDTR limits when loading L1 host state

Ladislav Michl (1):
      video: udlfb: Fix read EDID timeout

Lepton Wu (1):
      kaiser: Set _PAGE_NX only if supported

Maciej W. Rozycki (1):
      MIPS: Fix an n32 core file generation regset support regression

Majd Dibbiny (1):
      IB/mlx5: Assign send CQ and recv CQ of UMR QP

Manasi Navare (1):
      drm/i915/edp: Get the Panel Power Off timestamp after panel is off

Mark Bloch (1):
      IB/mlx4: Increase maximal message size under UD QP

Mark Rutland (1):
      arm64: vdso: fix clock_getres for 4GiB-aligned res

Markus Elfring (2):
      media: omap_vout: Fix a possible null pointer dereference in omap_vout_open()
      platform/x86: sony-laptop: Fix error handling in sony_nc_setup_rfkill()

Masami Hiramatsu (1):
      x86/decoder: Add new TEST instruction pattern

Mauro Carvalho Chehab (1):
      cx231xx: Fix the max number of interfaces

Michał Mirosław (1):
      clk: tegra: Fix cclk_lp divisor register

Mike Snitzer (1):
      dm: discard support requires all targets in a table support discards

Mohamed Ghannam (2):
      RDS: Heap OOB write in rds_message_alloc_sgs()
      RDS: null pointer dereference in rds_atomic_free_op

Nadav Amit (2):
      staging: lustre: ptlrpc: kfree used instead of kvfree
      KVM: vmx: Inject #GP on invalid PAT CR

Nathan Lynch (1):
      arm64: vdso: minor ABI fix for clock_getres

NeilBrown (2):
      autofs: don&#39;t fail mount for transient error
      autofs: fix careless error in recent commit

Nicholas Bellinger (3):
      target: Avoid early CMD_T_PRE_EXECUTE failures during ABORT_TASK
      iscsi-target: Make TASK_REASSIGN use proper se_cmd-&gt;cmd_kref
      iscsi-target: Fix non-immediate TMR reference leak

Paolo Bonzini (2):
      KVM: SVM: obey guest PAT
      x86: pvclock: Really remove the sched notifier for cross-cpu migrations

Peter Ujfalusi (1):
      clk: ti: dra7-atl-clock: Fix of_node reference counting

Peter Zijlstra (1):
      lib/int_sqrt: optimize small argument

Philip Derrin (1):
      ARM: 8721/1: mm: dump: check hardware RO bit for LPAE

Radu Alexe (1):
      crypto: caam - fix incorrect define

Roger Quadros (1):
      mtd: nand: omap2: Fix subpage write

Roman Kapl (1):
      drm/radeon: fix atombios on big endian

Sean Young (1):
      media: rc: check for integer overflow

Shriya (1):
      powerpc/powernv/cpufreq: Fix the frequency read by /proc/cpuinfo

Shuah Khan (4):
      usbip: fix stub_rx: get_pipe() to validate endpoint number
      usbip: fix stub_rx: harden CMD_SUBMIT path to handle malicious input
      usbip: prevent vhci_hcd driver from leaking a socket pointer address
      usbip: fix stub_send_ret_submit() vulnerability to null transfer_buffer

Stanislaw Gruszka (1):
      rt2x00usb: mark device removed when get ENOENT usb error

Takashi Iwai (5):
      ALSA: timer: Remove kernel warning at compat ioctl error paths
      ALSA: usb-audio: Add sanity checks to FE parser
      ALSA: usb-audio: Fix potential out-of-bound access at parsing SU
      ALSA: usb-audio: Add sanity checks in v2 clock parsers
      ALSA: seq: Make ioctls race-free

Theodore Ts&#39;o (1):
      ext4: fix interaction between i_size, fallocate, and delalloc after a crash

Tuomas Tynkkynen (2):
      fs/9p: Compare qid.path in v9fs_test_inode
      net/9p: Switch to wait_event_killable()

Tyrel Datwyler (1):
      powerpc/pseries/vio: Dispose of virq mapping on vdevice unregister

Vasily Gorbik (1):
      s390/disassembler: increase show_code buffer size

Vijendar Mukunda (1):
      ALSA: hda: Add Raven PCI ID

Viktor Slavkovic (1):
      staging: android: ashmem: fix a race condition in ASHMEM_SET_SIZE ioctl

Ville Syrjälä (1):
      drm/i915: Read timings from the correct transcoder in intel_crtc_mode_get()

Waiman Long (1):
      blktrace: Fix potential deadlock between delete &amp; sysfs ops

William A. Kennington III (1):
      powerpc/opal: Fix EBUSY bug in acquiring tokens

Xin Long (2):
      route: update fnhe_expires for redirect when the fnhe exists
      route: also update fnhe_genid when updating a route cache

Yunlong Song (1):
      Revert &quot;f2fs: handle dirty segments inside refresh_sit_entry&quot;

Zhou Chengming (1):
      kprobes, x86/alternatives: Use text_mutex to protect smp_alt_modules
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/sound/cs42l56.txt b/Documentation/devicetree/bindings/sound/cs42l56.txt</span>
<span class="p_header">index 4feb0eb27ea4..4ba520a28ae8 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/sound/cs42l56.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/sound/cs42l56.txt</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> CS42L52 audio CODEC</span>
 codec: codec@4b {
 	compatible = &quot;cirrus,cs42l56&quot;;
 	reg = &lt;0x4b&gt;;
<span class="p_del">-	gpio-reset = &lt;&amp;gpio 10 0&gt;;</span>
<span class="p_add">+	cirrus,gpio-nreset = &lt;&amp;gpio 10 0&gt;;</span>
 	cirrus,chgfreq-divisor = &lt;0x05&gt;;
 	cirrus.ain1_ref_cfg;
 	cirrus,micbias-lvl = &lt;5&gt;;
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 4386eb2679ae..cafa8cf0dfc1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 53</span>
<span class="p_add">+SUBLEVEL = 54</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/arm/mm/dump.c b/arch/arm/mm/dump.c</span>
<span class="p_header">index 59424937e52b..e223322fc71b 100644</span>
<span class="p_header">--- a/arch/arm/mm/dump.c</span>
<span class="p_header">+++ b/arch/arm/mm/dump.c</span>
<span class="p_chunk">@@ -126,8 +126,8 @@</span> <span class="p_context"> static const struct prot_bits section_bits[] = {</span>
 		.val	= PMD_SECT_USER,
 		.set	= &quot;USR&quot;,
 	}, {
<span class="p_del">-		.mask	= L_PMD_SECT_RDONLY,</span>
<span class="p_del">-		.val	= L_PMD_SECT_RDONLY,</span>
<span class="p_add">+		.mask	= L_PMD_SECT_RDONLY | PMD_SECT_AP2,</span>
<span class="p_add">+		.val	= L_PMD_SECT_RDONLY | PMD_SECT_AP2,</span>
 		.set	= &quot;ro&quot;,
 		.clear	= &quot;RW&quot;,
 #elif __LINUX_ARM_ARCH__ &gt;= 6
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_header">index fe652ffd34c2..0419069a6c97 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_chunk">@@ -174,8 +174,6 @@</span> <span class="p_context"> ENDPROC(__kernel_clock_gettime)</span>
 /* int __kernel_clock_getres(clockid_t clock_id, struct timespec *res); */
 ENTRY(__kernel_clock_getres)
 	.cfi_startproc
<span class="p_del">-	cbz	w1, 3f</span>
<span class="p_del">-</span>
 	cmp	w0, #CLOCK_REALTIME
 	ccmp	w0, #CLOCK_MONOTONIC, #0x4, ne
 	b.ne	1f
<span class="p_chunk">@@ -188,6 +186,7 @@</span> <span class="p_context"> ENTRY(__kernel_clock_getres)</span>
 	b.ne	4f
 	ldr	x2, 6f
 2:
<span class="p_add">+	cbz	x1, 3f</span>
 	stp	xzr, x2, [x1]
 
 3:	/* res == NULL. */
<span class="p_header">diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c</span>
<span class="p_header">index cdb8cc7800a2..b094c4a8ce71 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace.c</span>
<span class="p_chunk">@@ -522,6 +522,19 @@</span> <span class="p_context"> static const struct user_regset_view user_mips64_view = {</span>
 	.n		= ARRAY_SIZE(mips64_regsets),
 };
 
<span class="p_add">+#ifdef CONFIG_MIPS32_N32</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset_view user_mipsn32_view = {</span>
<span class="p_add">+	.name		= &quot;mipsn32&quot;,</span>
<span class="p_add">+	.e_flags	= EF_MIPS_ABI2,</span>
<span class="p_add">+	.e_machine	= ELF_ARCH,</span>
<span class="p_add">+	.ei_osabi	= ELF_OSABI,</span>
<span class="p_add">+	.regsets	= mips64_regsets,</span>
<span class="p_add">+	.n		= ARRAY_SIZE(mips64_regsets),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_MIPS32_N32 */</span>
<span class="p_add">+</span>
 #endif /* CONFIG_64BIT */
 
 const struct user_regset_view *task_user_regset_view(struct task_struct *task)
<span class="p_chunk">@@ -532,6 +545,10 @@</span> <span class="p_context"> const struct user_regset_view *task_user_regset_view(struct task_struct *task)</span>
 #ifdef CONFIG_MIPS32_O32
 	if (test_tsk_thread_flag(task, TIF_32BIT_REGS))
 		return &amp;user_mips_view;
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_MIPS32_N32</span>
<span class="p_add">+	if (test_tsk_thread_flag(task, TIF_32BIT_ADDR))</span>
<span class="p_add">+		return &amp;user_mipsn32_view;</span>
 #endif
 	return &amp;user_mips64_view;
 #endif
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index df6ff75c03ce..3284a3bbd9fb 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -690,15 +690,15 @@</span> <span class="p_context"> ENTRY(linux_gateway_page)</span>
 	/* ELF32 Process entry path */
 lws_compare_and_swap_2:
 #ifdef CONFIG_64BIT
<span class="p_del">-	/* Clip the input registers */</span>
<span class="p_add">+	/* Clip the input registers. We don&#39;t need to clip %r23 as we</span>
<span class="p_add">+	   only use it for word operations */</span>
 	depdi	0, 31, 32, %r26
 	depdi	0, 31, 32, %r25
 	depdi	0, 31, 32, %r24
<span class="p_del">-	depdi	0, 31, 32, %r23</span>
 #endif
 
 	/* Check the validity of the size pointer */
<span class="p_del">-	subi,&gt;&gt;= 4, %r23, %r0</span>
<span class="p_add">+	subi,&gt;&gt;= 3, %r23, %r0</span>
 	b,n	lws_exit_nosys
 
 	/* Jump to the functions which will load the old and new values into
<span class="p_header">diff --git a/arch/powerpc/kernel/vio.c b/arch/powerpc/kernel/vio.c</span>
<span class="p_header">index 904c66128fae..f30807e7697b 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vio.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vio.c</span>
<span class="p_chunk">@@ -1572,6 +1572,8 @@</span> <span class="p_context"> static struct device_attribute vio_dev_attrs[] = {</span>
 void vio_unregister_device(struct vio_dev *viodev)
 {
 	device_unregister(&amp;viodev-&gt;dev);
<span class="p_add">+	if (viodev-&gt;family == VDEVICE)</span>
<span class="p_add">+		irq_dispose_mapping(viodev-&gt;irq);</span>
 }
 EXPORT_SYMBOL(vio_unregister_device);
 
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-async.c b/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_header">index 32e2adfa5320..d867e51cb709 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_chunk">@@ -38,18 +38,18 @@</span> <span class="p_context"> int __opal_async_get_token(void)</span>
 	int token;
 
 	spin_lock_irqsave(&amp;opal_async_comp_lock, flags);
<span class="p_del">-	token = find_first_bit(opal_async_complete_map, opal_max_async_tokens);</span>
<span class="p_add">+	token = find_first_zero_bit(opal_async_token_map, opal_max_async_tokens);</span>
 	if (token &gt;= opal_max_async_tokens) {
 		token = -EBUSY;
 		goto out;
 	}
 
<span class="p_del">-	if (__test_and_set_bit(token, opal_async_token_map)) {</span>
<span class="p_add">+	if (!__test_and_clear_bit(token, opal_async_complete_map)) {</span>
 		token = -EBUSY;
 		goto out;
 	}
 
<span class="p_del">-	__clear_bit(token, opal_async_complete_map);</span>
<span class="p_add">+	__set_bit(token, opal_async_token_map);</span>
 
 out:
 	spin_unlock_irqrestore(&amp;opal_async_comp_lock, flags);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/setup.c b/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_header">index d9b88fa7c5a3..51b2c6aae0ec 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/setup.c</span>
<span class="p_chunk">@@ -309,7 +309,7 @@</span> <span class="p_context"> unsigned long pnv_get_proc_freq(unsigned int cpu)</span>
 {
 	unsigned long ret_freq;
 
<span class="p_del">-	ret_freq = cpufreq_quick_get(cpu) * 1000ul;</span>
<span class="p_add">+	ret_freq = cpufreq_get(cpu) * 1000ul;</span>
 
 	/*
 	 * If the backend cpufreq driver does not exist,
<span class="p_header">diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">index 716df3a992d0..7d8ed6de0858 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -124,12 +124,12 @@</span> <span class="p_context"> static inline void restore_access_regs(unsigned int *acrs)</span>
 		save_access_regs(&amp;prev-&gt;thread.acrs[0]);		\
 		save_ri_cb(prev-&gt;thread.ri_cb);				\
 	}								\
<span class="p_add">+	update_cr_regs(next);						\</span>
 	if (next-&gt;mm) {							\
 		restore_fp_ctl(&amp;next-&gt;thread.fp_regs.fpc);		\
 		restore_fp_regs(next-&gt;thread.fp_regs.fprs);		\
 		restore_access_regs(&amp;next-&gt;thread.acrs[0]);		\
 		restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);	\
<span class="p_del">-		update_cr_regs(next);					\</span>
 	}								\
 	prev = __switch_to(prev,next);					\
 } while (0)
<span class="p_header">diff --git a/arch/s390/kernel/dis.c b/arch/s390/kernel/dis.c</span>
<span class="p_header">index 3d942314818b..a0c29638a707 100644</span>
<span class="p_header">--- a/arch/s390/kernel/dis.c</span>
<span class="p_header">+++ b/arch/s390/kernel/dis.c</span>
<span class="p_chunk">@@ -1765,7 +1765,7 @@</span> <span class="p_context"> void show_code(struct pt_regs *regs)</span>
 {
 	char *mode = user_mode(regs) ? &quot;User&quot; : &quot;Krnl&quot;;
 	unsigned char code[64];
<span class="p_del">-	char buffer[64], *ptr;</span>
<span class="p_add">+	char buffer[128], *ptr;</span>
 	mm_segment_t old_fs;
 	unsigned long addr;
 	int start, end, opsize, hops, i;
<span class="p_chunk">@@ -1828,7 +1828,7 @@</span> <span class="p_context"> void show_code(struct pt_regs *regs)</span>
 		start += opsize;
 		printk(buffer);
 		ptr = buffer;
<span class="p_del">-		ptr += sprintf(ptr, &quot;\n          &quot;);</span>
<span class="p_add">+		ptr += sprintf(ptr, &quot;\n\t  &quot;);</span>
 		hops++;
 	}
 	printk(&quot;\n&quot;);
<span class="p_header">diff --git a/arch/s390/kernel/early.c b/arch/s390/kernel/early.c</span>
<span class="p_header">index 0dff972a169c..ec372dd54c7f 100644</span>
<span class="p_header">--- a/arch/s390/kernel/early.c</span>
<span class="p_header">+++ b/arch/s390/kernel/early.c</span>
<span class="p_chunk">@@ -388,8 +388,10 @@</span> <span class="p_context"> static __init void detect_machine_facilities(void)</span>
 		S390_lowcore.machine_flags |= MACHINE_FLAG_IDTE;
 	if (test_facility(40))
 		S390_lowcore.machine_flags |= MACHINE_FLAG_LPP;
<span class="p_del">-	if (test_facility(50) &amp;&amp; test_facility(73))</span>
<span class="p_add">+	if (test_facility(50) &amp;&amp; test_facility(73)) {</span>
 		S390_lowcore.machine_flags |= MACHINE_FLAG_TE;
<span class="p_add">+		__ctl_set_bit(0, 55);</span>
<span class="p_add">+	}</span>
 	if (test_facility(66))
 		S390_lowcore.machine_flags |= MACHINE_FLAG_RRBM;
 	if (test_facility(51))
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index 8a7f7732db1f..604b3e7577db 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long new_stackp,</span>
 	memset(&amp;p-&gt;thread.per_user, 0, sizeof(p-&gt;thread.per_user));
 	memset(&amp;p-&gt;thread.per_event, 0, sizeof(p-&gt;thread.per_event));
 	clear_tsk_thread_flag(p, TIF_SINGLE_STEP);
<span class="p_add">+	p-&gt;thread.per_flags = 0;</span>
 	/* Initialize per thread user and system timer values */
 	ti = task_thread_info(p);
 	ti-&gt;user_timer = 0;
<span class="p_header">diff --git a/arch/s390/kernel/runtime_instr.c b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">index 26b4ae96fdd7..ddbec1054f75 100644</span>
<span class="p_header">--- a/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">+++ b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_chunk">@@ -53,12 +53,14 @@</span> <span class="p_context"> void exit_thread_runtime_instr(void)</span>
 {
 	struct task_struct *task = current;
 
<span class="p_add">+	preempt_disable();</span>
 	if (!task-&gt;thread.ri_cb)
 		return;
 	disable_runtime_instr();
 	kfree(task-&gt;thread.ri_cb);
 	task-&gt;thread.ri_signum = 0;
 	task-&gt;thread.ri_cb = NULL;
<span class="p_add">+	preempt_enable();</span>
 }
 
 static void runtime_instr_int_handler(struct ext_code ext_code,
<span class="p_chunk">@@ -100,9 +102,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(s390_runtime_instr, int, command, int, signum)</span>
 		return -EOPNOTSUPP;
 
 	if (command == S390_RUNTIME_INSTR_STOP) {
<span class="p_del">-		preempt_disable();</span>
 		exit_thread_runtime_instr();
<span class="p_del">-		preempt_enable();</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/arch/x86/include/asm/fixmap.h b/arch/x86/include/asm/fixmap.h</span>
<span class="p_header">index ffb1733ac91f..ce8cbba4dd34 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/fixmap.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/fixmap.h</span>
<span class="p_chunk">@@ -19,7 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/acpi.h&gt;
 #include &lt;asm/apicdef.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_del">-#include &lt;asm/pvclock.h&gt;</span>
 #ifdef CONFIG_X86_32
 #include &lt;linux/threads.h&gt;
 #include &lt;asm/kmap_types.h&gt;
<span class="p_chunk">@@ -70,10 +69,6 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 	FIX_HOLE,
 #else
 	VSYSCALL_PAGE = (FIXADDR_TOP - VSYSCALL_ADDR) &gt;&gt; PAGE_SHIFT,
<span class="p_del">-#ifdef CONFIG_PARAVIRT_CLOCK</span>
<span class="p_del">-	PVCLOCK_FIXMAP_BEGIN,</span>
<span class="p_del">-	PVCLOCK_FIXMAP_END = PVCLOCK_FIXMAP_BEGIN+PVCLOCK_VSYSCALL_NR_PAGES-1,</span>
<span class="p_del">-#endif</span>
 #endif
 	FIX_DBGP_BASE,
 	FIX_EARLYCON_MEM_BASE,
<span class="p_chunk">@@ -103,6 +98,12 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 #ifdef	CONFIG_X86_INTEL_MID
 	FIX_LNW_VRTC,
 #endif
<span class="p_add">+#ifdef CONFIG_ACPI_APEI_GHES</span>
<span class="p_add">+	/* Used for GHES mapping from assorted contexts */</span>
<span class="p_add">+	FIX_APEI_GHES_IRQ,</span>
<span class="p_add">+	FIX_APEI_GHES_NMI,</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	__end_of_permanent_fixed_addresses,
 
 	/*
<span class="p_header">diff --git a/arch/x86/include/asm/pvclock.h b/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">index 25b1cc07d496..b80536e62fae 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pvclock.h</span>
<span class="p_chunk">@@ -4,6 +4,15 @@</span> <span class="p_context"></span>
 #include &lt;linux/clocksource.h&gt;
 #include &lt;asm/pvclock-abi.h&gt;
 
<span class="p_add">+#ifdef CONFIG_PARAVIRT_CLOCK</span>
<span class="p_add">+extern struct pvclock_vsyscall_time_info *pvclock_pvti_cpu0_va(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline struct pvclock_vsyscall_time_info *pvclock_pvti_cpu0_va(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* some helper functions for xen and kvm pv clock sources */
 cycle_t pvclock_clocksource_read(struct pvclock_vcpu_time_info *src);
 u8 pvclock_read_flags(struct pvclock_vcpu_time_info *src);
<span class="p_chunk">@@ -95,14 +104,8 @@</span> <span class="p_context"> unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,</span>
 
 struct pvclock_vsyscall_time_info {
 	struct pvclock_vcpu_time_info pvti;
<span class="p_del">-	u32 migrate_count;</span>
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
 #define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)
<span class="p_del">-#define PVCLOCK_VSYSCALL_NR_PAGES (((NR_CPUS-1)/(PAGE_SIZE/PVTI_SIZE))+1)</span>
<span class="p_del">-</span>
<span class="p_del">-int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,</span>
<span class="p_del">-				 int size);</span>
<span class="p_del">-struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu);</span>
 
 #endif /* _ASM_X86_PVCLOCK_H */
<span class="p_header">diff --git a/arch/x86/include/asm/vdso.h b/arch/x86/include/asm/vdso.h</span>
<span class="p_header">index 30be253dd283..f97d32664779 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/vdso.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/vdso.h</span>
<span class="p_chunk">@@ -18,15 +18,16 @@</span> <span class="p_context"> struct vdso_image {</span>
 
 	unsigned long alt, alt_len;
 
<span class="p_del">-	unsigned long sym_end_mapping;  /* Total size of the mapping */</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long sym_vvar_page;</span>
<span class="p_del">-	unsigned long sym_hpet_page;</span>
<span class="p_del">-	unsigned long sym_VDSO32_NOTE_MASK;</span>
<span class="p_del">-	unsigned long sym___kernel_sigreturn;</span>
<span class="p_del">-	unsigned long sym___kernel_rt_sigreturn;</span>
<span class="p_del">-	unsigned long sym___kernel_vsyscall;</span>
<span class="p_del">-	unsigned long sym_VDSO32_SYSENTER_RETURN;</span>
<span class="p_add">+	long sym_vvar_start;  /* Negative offset to the vvar area */</span>
<span class="p_add">+</span>
<span class="p_add">+	long sym_vvar_page;</span>
<span class="p_add">+	long sym_hpet_page;</span>
<span class="p_add">+	long sym_pvclock_page;</span>
<span class="p_add">+	long sym_VDSO32_NOTE_MASK;</span>
<span class="p_add">+	long sym___kernel_sigreturn;</span>
<span class="p_add">+	long sym___kernel_rt_sigreturn;</span>
<span class="p_add">+	long sym___kernel_vsyscall;</span>
<span class="p_add">+	long sym_VDSO32_SYSENTER_RETURN;</span>
 };
 
 #ifdef CONFIG_X86_64
<span class="p_header">diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c</span>
<span class="p_header">index af397cc98d05..fa030d032eb7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/alternative.c</span>
<span class="p_header">+++ b/arch/x86/kernel/alternative.c</span>
<span class="p_chunk">@@ -409,7 +409,6 @@</span> <span class="p_context"> static void alternatives_smp_lock(const s32 *start, const s32 *end,</span>
 {
 	const s32 *poff;
 
<span class="p_del">-	mutex_lock(&amp;text_mutex);</span>
 	for (poff = start; poff &lt; end; poff++) {
 		u8 *ptr = (u8 *)poff + *poff;
 
<span class="p_chunk">@@ -419,7 +418,6 @@</span> <span class="p_context"> static void alternatives_smp_lock(const s32 *start, const s32 *end,</span>
 		if (*ptr == 0x3e)
 			text_poke(ptr, ((unsigned char []){0xf0}), 1);
 	}
<span class="p_del">-	mutex_unlock(&amp;text_mutex);</span>
 }
 
 static void alternatives_smp_unlock(const s32 *start, const s32 *end,
<span class="p_chunk">@@ -427,7 +425,6 @@</span> <span class="p_context"> static void alternatives_smp_unlock(const s32 *start, const s32 *end,</span>
 {
 	const s32 *poff;
 
<span class="p_del">-	mutex_lock(&amp;text_mutex);</span>
 	for (poff = start; poff &lt; end; poff++) {
 		u8 *ptr = (u8 *)poff + *poff;
 
<span class="p_chunk">@@ -437,7 +434,6 @@</span> <span class="p_context"> static void alternatives_smp_unlock(const s32 *start, const s32 *end,</span>
 		if (*ptr == 0xf0)
 			text_poke(ptr, ((unsigned char []){0x3E}), 1);
 	}
<span class="p_del">-	mutex_unlock(&amp;text_mutex);</span>
 }
 
 struct smp_alt_module {
<span class="p_chunk">@@ -456,8 +452,7 @@</span> <span class="p_context"> struct smp_alt_module {</span>
 	struct list_head next;
 };
 static LIST_HEAD(smp_alt_modules);
<span class="p_del">-static DEFINE_MUTEX(smp_alt);</span>
<span class="p_del">-static bool uniproc_patched = false;	/* protected by smp_alt */</span>
<span class="p_add">+static bool uniproc_patched = false;	/* protected by text_mutex */</span>
 
 void __init_or_module alternatives_smp_module_add(struct module *mod,
 						  char *name,
<span class="p_chunk">@@ -466,7 +461,7 @@</span> <span class="p_context"> void __init_or_module alternatives_smp_module_add(struct module *mod,</span>
 {
 	struct smp_alt_module *smp;
 
<span class="p_del">-	mutex_lock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_lock(&amp;text_mutex);</span>
 	if (!uniproc_patched)
 		goto unlock;
 
<span class="p_chunk">@@ -493,14 +488,14 @@</span> <span class="p_context"> void __init_or_module alternatives_smp_module_add(struct module *mod,</span>
 smp_unlock:
 	alternatives_smp_unlock(locks, locks_end, text, text_end);
 unlock:
<span class="p_del">-	mutex_unlock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_unlock(&amp;text_mutex);</span>
 }
 
 void __init_or_module alternatives_smp_module_del(struct module *mod)
 {
 	struct smp_alt_module *item;
 
<span class="p_del">-	mutex_lock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_lock(&amp;text_mutex);</span>
 	list_for_each_entry(item, &amp;smp_alt_modules, next) {
 		if (mod != item-&gt;mod)
 			continue;
<span class="p_chunk">@@ -508,7 +503,7 @@</span> <span class="p_context"> void __init_or_module alternatives_smp_module_del(struct module *mod)</span>
 		kfree(item);
 		break;
 	}
<span class="p_del">-	mutex_unlock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_unlock(&amp;text_mutex);</span>
 }
 
 void alternatives_enable_smp(void)
<span class="p_chunk">@@ -518,7 +513,7 @@</span> <span class="p_context"> void alternatives_enable_smp(void)</span>
 	/* Why bother if there are no other CPUs? */
 	BUG_ON(num_possible_cpus() == 1);
 
<span class="p_del">-	mutex_lock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_lock(&amp;text_mutex);</span>
 
 	if (uniproc_patched) {
 		pr_info(&quot;switching to SMP code\n&quot;);
<span class="p_chunk">@@ -530,10 +525,13 @@</span> <span class="p_context"> void alternatives_enable_smp(void)</span>
 					      mod-&gt;text, mod-&gt;text_end);
 		uniproc_patched = false;
 	}
<span class="p_del">-	mutex_unlock(&amp;smp_alt);</span>
<span class="p_add">+	mutex_unlock(&amp;text_mutex);</span>
 }
 
<span class="p_del">-/* Return 1 if the address range is reserved for smp-alternatives */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Return 1 if the address range is reserved for SMP-alternatives.</span>
<span class="p_add">+ * Must hold text_mutex.</span>
<span class="p_add">+ */</span>
 int alternatives_text_reserved(void *start, void *end)
 {
 	struct smp_alt_module *mod;
<span class="p_chunk">@@ -541,6 +539,8 @@</span> <span class="p_context"> int alternatives_text_reserved(void *start, void *end)</span>
 	u8 *text_start = start;
 	u8 *text_end = end;
 
<span class="p_add">+	lockdep_assert_held(&amp;text_mutex);</span>
<span class="p_add">+</span>
 	list_for_each_entry(mod, &amp;smp_alt_modules, next) {
 		if (mod-&gt;text &gt; text_end || mod-&gt;text_end &lt; text_start)
 			continue;
<span class="p_header">diff --git a/arch/x86/kernel/kvmclock.c b/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">index 206aa5a2afe0..218035f29166 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvmclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvmclock.c</span>
<span class="p_chunk">@@ -24,7 +24,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/percpu.h&gt;
 #include &lt;linux/hardirq.h&gt;
 #include &lt;linux/memblock.h&gt;
<span class="p_del">-#include &lt;linux/kaiser.h&gt;</span>
 
 #include &lt;asm/x86_init.h&gt;
 #include &lt;asm/reboot.h&gt;
<span class="p_chunk">@@ -44,6 +43,11 @@</span> <span class="p_context"> early_param(&quot;no-kvmclock&quot;, parse_no_kvmclock);</span>
 static struct pvclock_vsyscall_time_info *hv_clock;
 static struct pvclock_wall_clock wall_clock;
 
<span class="p_add">+struct pvclock_vsyscall_time_info *pvclock_pvti_cpu0_va(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return hv_clock;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * The wallclock is the time of day when we booted. Since then, some time may
  * have elapsed since the hypervisor wrote the data. So we try to account for
<span class="p_chunk">@@ -274,7 +278,6 @@</span> <span class="p_context"> int __init kvm_setup_vsyscall_timeinfo(void)</span>
 {
 #ifdef CONFIG_X86_64
 	int cpu;
<span class="p_del">-	int ret;</span>
 	u8 flags;
 	struct pvclock_vcpu_time_info *vcpu_time;
 	unsigned int size;
<span class="p_chunk">@@ -282,10 +285,6 @@</span> <span class="p_context"> int __init kvm_setup_vsyscall_timeinfo(void)</span>
 	if (!hv_clock)
 		return 0;
 
<span class="p_del">-	/* FIXME: Need to add pvclock pages to user-space page tables */</span>
<span class="p_del">-	if (kaiser_enabled)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	size = PAGE_ALIGN(sizeof(struct pvclock_vsyscall_time_info)*NR_CPUS);
 
 	preempt_disable();
<span class="p_chunk">@@ -299,11 +298,6 @@</span> <span class="p_context"> int __init kvm_setup_vsyscall_timeinfo(void)</span>
 		return 1;
 	}
 
<span class="p_del">-	if ((ret = pvclock_init_vsyscall(hv_clock, size))) {</span>
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	preempt_enable();
 
 	kvm_clock.archdata.vclock_mode = VCLOCK_PVCLOCK;
<span class="p_header">diff --git a/arch/x86/kernel/pvclock.c b/arch/x86/kernel/pvclock.c</span>
<span class="p_header">index e5ecd20e72dd..99bfc025111d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pvclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pvclock.c</span>
<span class="p_chunk">@@ -140,71 +140,3 @@</span> <span class="p_context"> void pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,</span>
 
 	set_normalized_timespec(ts, now.tv_sec, now.tv_nsec);
 }
<span class="p_del">-</span>
<span class="p_del">-static struct pvclock_vsyscall_time_info *pvclock_vdso_info;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pvclock_vsyscall_time_info *</span>
<span class="p_del">-pvclock_get_vsyscall_user_time_info(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!pvclock_vdso_info) {</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;pvclock_vdso_info[cpu];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return &amp;pvclock_get_vsyscall_user_time_info(cpu)-&gt;pvti;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static int pvclock_task_migrate(struct notifier_block *nb, unsigned long l,</span>
<span class="p_del">-			        void *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct task_migration_notifier *mn = v;</span>
<span class="p_del">-	struct pvclock_vsyscall_time_info *pvti;</span>
<span class="p_del">-</span>
<span class="p_del">-	pvti = pvclock_get_vsyscall_user_time_info(mn-&gt;from_cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* this is NULL when pvclock vsyscall is not initialized */</span>
<span class="p_del">-	if (unlikely(pvti == NULL))</span>
<span class="p_del">-		return NOTIFY_DONE;</span>
<span class="p_del">-</span>
<span class="p_del">-	pvti-&gt;migrate_count++;</span>
<span class="p_del">-</span>
<span class="p_del">-	return NOTIFY_DONE;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct notifier_block pvclock_migrate = {</span>
<span class="p_del">-	.notifier_call = pvclock_task_migrate,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Initialize the generic pvclock vsyscall state.  This will allocate</span>
<span class="p_del">- * a/some page(s) for the per-vcpu pvclock information, set up a</span>
<span class="p_del">- * fixmap mapping for the page(s)</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,</span>
<span class="p_del">-				 int size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int idx;</span>
<span class="p_del">-</span>
<span class="p_del">-	WARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	pvclock_vdso_info = i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (idx = 0; idx &lt;= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {</span>
<span class="p_del">-		__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,</span>
<span class="p_del">-			     __pa(i) + (idx*PAGE_SIZE),</span>
<span class="p_del">-			     PAGE_KERNEL_VVAR);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	register_task_migration_notifier(&amp;pvclock_migrate);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 2003a07de9ad..5ac22e7c3bf7 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -3157,6 +3157,13 @@</span> <span class="p_context"> static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)</span>
 	u32 ecx = msr-&gt;index;
 	u64 data = msr-&gt;data;
 	switch (ecx) {
<span class="p_add">+	case MSR_IA32_CR_PAT:</span>
<span class="p_add">+		if (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		vcpu-&gt;arch.pat = data;</span>
<span class="p_add">+		svm-&gt;vmcb-&gt;save.g_pat = data;</span>
<span class="p_add">+		mark_dirty(svm-&gt;vmcb, VMCB_NPT);</span>
<span class="p_add">+		break;</span>
 	case MSR_IA32_TSC:
 		kvm_write_tsc(vcpu, msr);
 		break;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 6f6f77a5145c..329eb2260ade 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2599,6 +2599,8 @@</span> <span class="p_context"> static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)</span>
 		break;
 	case MSR_IA32_CR_PAT:
 		if (vmcs_config.vmentry_ctrl &amp; VM_ENTRY_LOAD_IA32_PAT) {
<span class="p_add">+			if (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))</span>
<span class="p_add">+				return 1;</span>
 			vmcs_write64(GUEST_IA32_PAT, data);
 			vcpu-&gt;arch.pat = data;
 			break;
<span class="p_chunk">@@ -8695,6 +8697,8 @@</span> <span class="p_context"> static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,</span>
 	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12-&gt;host_ia32_sysenter_eip);
 	vmcs_writel(GUEST_IDTR_BASE, vmcs12-&gt;host_idtr_base);
 	vmcs_writel(GUEST_GDTR_BASE, vmcs12-&gt;host_gdtr_base);
<span class="p_add">+	vmcs_write32(GUEST_IDTR_LIMIT, 0xFFFF);</span>
<span class="p_add">+	vmcs_write32(GUEST_GDTR_LIMIT, 0xFFFF);</span>
 
 	/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */
 	if (vmcs12-&gt;vm_exit_controls &amp; VM_EXIT_CLEAR_BNDCFGS)
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index d0847b33282f..64052c92ba5c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -1742,7 +1742,7 @@</span> <span class="p_context"> static bool valid_mtrr_type(unsigned t)</span>
 	return t &lt; 8 &amp;&amp; (1 &lt;&lt; t) &amp; 0x73; /* 0, 1, 4, 5, 6 */
 }
 
<span class="p_del">-static bool mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)</span>
<span class="p_add">+bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)</span>
 {
 	int i;
 
<span class="p_chunk">@@ -1768,12 +1768,13 @@</span> <span class="p_context"> static bool mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)</span>
 	/* variable MTRRs */
 	return valid_mtrr_type(data &amp; 0xff);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(kvm_mtrr_valid);</span>
 
 static int set_msr_mtrr(struct kvm_vcpu *vcpu, u32 msr, u64 data)
 {
 	u64 *p = (u64 *)&amp;vcpu-&gt;arch.mtrr_state.fixed_ranges;
 
<span class="p_del">-	if (!mtrr_valid(vcpu, msr, data))</span>
<span class="p_add">+	if (!kvm_mtrr_valid(vcpu, msr, data))</span>
 		return 1;
 
 	if (msr == MSR_MTRRdefType) {
<span class="p_header">diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h</span>
<span class="p_header">index b0b17e6f0431..8bc086f5c5a6 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.h</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.h</span>
<span class="p_chunk">@@ -132,6 +132,8 @@</span> <span class="p_context"> int kvm_write_guest_virt_system(struct x86_emulate_ctxt *ctxt,</span>
 	gva_t addr, void *val, unsigned int bytes,
 	struct x86_exception *exception);
 
<span class="p_add">+bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data);</span>
<span class="p_add">+</span>
 #define KVM_SUPPORTED_XCR0     (XSTATE_FP | XSTATE_SSE | XSTATE_YMM \
 				| XSTATE_BNDREGS | XSTATE_BNDCSR)
 extern u64 host_xcr0;
<span class="p_header">diff --git a/arch/x86/lib/x86-opcode-map.txt b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">index 1a2be7c6895d..3ce0dcc56ce5 100644</span>
<span class="p_header">--- a/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">+++ b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -814,7 +814,7 @@</span> <span class="p_context"> EndTable</span>
 
 GrpTable: Grp3_1
 0: TEST Eb,Ib
<span class="p_del">-1:</span>
<span class="p_add">+1: TEST Eb,Ib</span>
 2: NOT Eb
 3: NEG Eb
 4: MUL AL,Eb
<span class="p_header">diff --git a/arch/x86/mm/kaiser.c b/arch/x86/mm/kaiser.c</span>
<span class="p_header">index 8d1019d176e2..8a07537dae08 100644</span>
<span class="p_header">--- a/arch/x86/mm/kaiser.c</span>
<span class="p_header">+++ b/arch/x86/mm/kaiser.c</span>
<span class="p_chunk">@@ -195,6 +195,8 @@</span> <span class="p_context"> static int kaiser_add_user_map(const void *__start_addr, unsigned long size,</span>
 	 * requires that not to be #defined to 0): so mask it off here.
 	 */
 	flags &amp;= ~_PAGE_GLOBAL;
<span class="p_add">+	if (!(__supported_pte_mask &amp; _PAGE_NX))</span>
<span class="p_add">+		flags &amp;= ~_PAGE_NX;</span>
 
 	for (; address &lt; end_addr; address += PAGE_SIZE) {
 		target_address = get_pa_from_mapping(address);
<span class="p_chunk">@@ -322,7 +324,7 @@</span> <span class="p_context"> void __init kaiser_check_boottime_disable(void)</span>
  */
 void __init kaiser_init(void)
 {
<span class="p_del">-	int cpu, idx;</span>
<span class="p_add">+	int cpu;</span>
 
 	if (!kaiser_enabled)
 		return;
<span class="p_chunk">@@ -428,7 +430,8 @@</span> <span class="p_context"> pgd_t kaiser_set_shadow_pgd(pgd_t *pgdp, pgd_t pgd)</span>
 			 * get out to userspace running on the kernel CR3,
 			 * userspace will crash instead of running.
 			 */
<span class="p_del">-			pgd.pgd |= _PAGE_NX;</span>
<span class="p_add">+			if (__supported_pte_mask &amp; _PAGE_NX)</span>
<span class="p_add">+				pgd.pgd |= _PAGE_NX;</span>
 		}
 	} else if (!pgd.pgd) {
 		/*
<span class="p_header">diff --git a/arch/x86/platform/uv/uv_nmi.c b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">index c89c93320c12..30777beb345a 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/nmi.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/clocksource.h&gt;</span>
 
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/current.h&gt;
<span class="p_header">diff --git a/arch/x86/vdso/vclock_gettime.c b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">index 40d2473836c9..c3c3cf14680f 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_chunk">@@ -36,11 +36,15 @@</span> <span class="p_context"> static notrace cycle_t vread_hpet(void)</span>
 }
 #endif
 
<span class="p_add">+#ifdef CONFIG_PARAVIRT_CLOCK</span>
<span class="p_add">+extern u8 pvclock_page</span>
<span class="p_add">+	__attribute__((visibility(&quot;hidden&quot;)));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #ifndef BUILD_VDSO32
 
 #include &lt;linux/kernel.h&gt;
 #include &lt;asm/vsyscall.h&gt;
<span class="p_del">-#include &lt;asm/fixmap.h&gt;</span>
 #include &lt;asm/pvclock.h&gt;
 
 notrace static long vdso_fallback_gettime(long clock, struct timespec *ts)
<span class="p_chunk">@@ -62,67 +66,66 @@</span> <span class="p_context"> notrace static long vdso_fallback_gtod(struct timeval *tv, struct timezone *tz)</span>
 
 #ifdef CONFIG_PARAVIRT_CLOCK
 
<span class="p_del">-static notrace const struct pvclock_vsyscall_time_info *get_pvti(int cpu)</span>
<span class="p_add">+static notrace const struct pvclock_vsyscall_time_info *get_pvti0(void)</span>
 {
<span class="p_del">-	const struct pvclock_vsyscall_time_info *pvti_base;</span>
<span class="p_del">-	int idx = cpu / (PAGE_SIZE/PVTI_SIZE);</span>
<span class="p_del">-	int offset = cpu % (PAGE_SIZE/PVTI_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(PVCLOCK_FIXMAP_BEGIN + idx &gt; PVCLOCK_FIXMAP_END);</span>
<span class="p_del">-</span>
<span class="p_del">-	pvti_base = (struct pvclock_vsyscall_time_info *)</span>
<span class="p_del">-		    __fix_to_virt(PVCLOCK_FIXMAP_BEGIN+idx);</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;pvti_base[offset];</span>
<span class="p_add">+	return (const struct pvclock_vsyscall_time_info *)&amp;pvclock_page;</span>
 }
 
 static notrace cycle_t vread_pvclock(int *mode)
 {
<span class="p_del">-	const struct pvclock_vsyscall_time_info *pvti;</span>
<span class="p_add">+	const struct pvclock_vcpu_time_info *pvti = &amp;get_pvti0()-&gt;pvti;</span>
 	cycle_t ret;
<span class="p_del">-	u64 last;</span>
<span class="p_del">-	u32 version;</span>
<span class="p_del">-	u32 migrate_count;</span>
<span class="p_del">-	u8 flags;</span>
<span class="p_del">-	unsigned cpu, cpu1;</span>
<span class="p_del">-</span>
<span class="p_add">+	u64 tsc, pvti_tsc;</span>
<span class="p_add">+	u64 last, delta, pvti_system_time;</span>
<span class="p_add">+	u32 version, pvti_tsc_to_system_mul, pvti_tsc_shift;</span>
 
 	/*
<span class="p_del">-	 * When looping to get a consistent (time-info, tsc) pair, we</span>
<span class="p_del">-	 * also need to deal with the possibility we can switch vcpus,</span>
<span class="p_del">-	 * so make sure we always re-fetch time-info for the current vcpu.</span>
<span class="p_add">+	 * Note: The kernel and hypervisor must guarantee that cpu ID</span>
<span class="p_add">+	 * number maps 1:1 to per-CPU pvclock time info.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Because the hypervisor is entirely unaware of guest userspace</span>
<span class="p_add">+	 * preemption, it cannot guarantee that per-CPU pvclock time</span>
<span class="p_add">+	 * info is updated if the underlying CPU changes or that that</span>
<span class="p_add">+	 * version is increased whenever underlying CPU changes.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * On KVM, we are guaranteed that pvti updates for any vCPU are</span>
<span class="p_add">+	 * atomic as seen by *all* vCPUs.  This is an even stronger</span>
<span class="p_add">+	 * guarantee than we get with a normal seqlock.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * On Xen, we don&#39;t appear to have that guarantee, but Xen still</span>
<span class="p_add">+	 * supplies a valid seqlock using the version field.</span>
<span class="p_add">+</span>
<span class="p_add">+	 * We only do pvclock vdso timing at all if</span>
<span class="p_add">+	 * PVCLOCK_TSC_STABLE_BIT is set, and we interpret that bit to</span>
<span class="p_add">+	 * mean that all vCPUs have matching pvti and that the TSC is</span>
<span class="p_add">+	 * synced, so we can just look at vCPU 0&#39;s pvti.</span>
 	 */
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!(pvti-&gt;flags &amp; PVCLOCK_TSC_STABLE_BIT))) {</span>
<span class="p_add">+		*mode = VCLOCK_NONE;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	do {
<span class="p_del">-		cpu = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_del">-		/* TODO: We can put vcpu id into higher bits of pvti.version.</span>
<span class="p_del">-		 * This will save a couple of cycles by getting rid of</span>
<span class="p_del">-		 * __getcpu() calls (Gleb).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Make sure migrate_count will change if we leave the VCPU. */</span>
<span class="p_del">-		do {</span>
<span class="p_del">-			pvti = get_pvti(cpu);</span>
<span class="p_del">-			migrate_count = pvti-&gt;migrate_count;</span>
<span class="p_del">-</span>
<span class="p_del">-			cpu1 = cpu;</span>
<span class="p_del">-			cpu = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_del">-		} while (unlikely(cpu != cpu1));</span>
<span class="p_del">-</span>
<span class="p_del">-		version = __pvclock_read_cycles(&amp;pvti-&gt;pvti, &amp;ret, &amp;flags);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Test we&#39;re still on the cpu as well as the version.</span>
<span class="p_del">-		 * - We must read TSC of pvti&#39;s VCPU.</span>
<span class="p_del">-		 * - KVM doesn&#39;t follow the versioning protocol, so data could</span>
<span class="p_del">-		 *   change before version if we left the VCPU.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+		version = pvti-&gt;version;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* This is also a read barrier, so we&#39;ll read version first. */</span>
<span class="p_add">+		rdtsc_barrier();</span>
<span class="p_add">+		tsc = __native_read_tsc();</span>
<span class="p_add">+</span>
<span class="p_add">+		pvti_tsc_to_system_mul = pvti-&gt;tsc_to_system_mul;</span>
<span class="p_add">+		pvti_tsc_shift = pvti-&gt;tsc_shift;</span>
<span class="p_add">+		pvti_system_time = pvti-&gt;system_time;</span>
<span class="p_add">+		pvti_tsc = pvti-&gt;tsc_timestamp;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Make sure that the version double-check is last. */</span>
 		smp_rmb();
<span class="p_del">-	} while (unlikely((pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_del">-			  pvti-&gt;pvti.version != version ||</span>
<span class="p_del">-			  pvti-&gt;migrate_count != migrate_count));</span>
<span class="p_add">+	} while (unlikely((version &amp; 1) || version != pvti-&gt;version));</span>
 
<span class="p_del">-	if (unlikely(!(flags &amp; PVCLOCK_TSC_STABLE_BIT)))</span>
<span class="p_del">-		*mode = VCLOCK_NONE;</span>
<span class="p_add">+	delta = tsc - pvti_tsc;</span>
<span class="p_add">+	ret = pvti_system_time +</span>
<span class="p_add">+		pvclock_scale_delta(delta, pvti_tsc_to_system_mul,</span>
<span class="p_add">+				    pvti_tsc_shift);</span>
 
 	/* refer to tsc.c read_tsc() comment for rationale */
 	last = gtod-&gt;cycle_last;
<span class="p_header">diff --git a/arch/x86/vdso/vdso-layout.lds.S b/arch/x86/vdso/vdso-layout.lds.S</span>
<span class="p_header">index 9197544eea9a..4158acc17df0 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso-layout.lds.S</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso-layout.lds.S</span>
<span class="p_chunk">@@ -18,6 +18,26 @@</span> <span class="p_context"></span>
 
 SECTIONS
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * User/kernel shared data is before the vDSO.  This may be a little</span>
<span class="p_add">+	 * uglier than putting it after the vDSO, but it avoids issues with</span>
<span class="p_add">+	 * non-allocatable things that dangle past the end of the PT_LOAD</span>
<span class="p_add">+	 * segment.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	vvar_start = . - 3 * PAGE_SIZE;</span>
<span class="p_add">+	vvar_page = vvar_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Place all vvars at the offsets in asm/vvar.h. */</span>
<span class="p_add">+#define EMIT_VVAR(name, offset) vvar_ ## name = vvar_page + offset;</span>
<span class="p_add">+#define __VVAR_KERNEL_LDS</span>
<span class="p_add">+#include &lt;asm/vvar.h&gt;</span>
<span class="p_add">+#undef __VVAR_KERNEL_LDS</span>
<span class="p_add">+#undef EMIT_VVAR</span>
<span class="p_add">+</span>
<span class="p_add">+	hpet_page = vvar_start + PAGE_SIZE;</span>
<span class="p_add">+	pvclock_page = vvar_start + 2 * PAGE_SIZE;</span>
<span class="p_add">+</span>
 	. = SIZEOF_HEADERS;
 
 	.hash		: { *(.hash) }			:text
<span class="p_chunk">@@ -74,31 +94,6 @@</span> <span class="p_context"> SECTIONS</span>
 	.altinstructions	: { *(.altinstructions) }	:text
 	.altinstr_replacement	: { *(.altinstr_replacement) }	:text
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The remainder of the vDSO consists of special pages that are</span>
<span class="p_del">-	 * shared between the kernel and userspace.  It needs to be at the</span>
<span class="p_del">-	 * end so that it doesn&#39;t overlap the mapping of the actual</span>
<span class="p_del">-	 * vDSO image.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	. = ALIGN(PAGE_SIZE);</span>
<span class="p_del">-	vvar_page = .;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Place all vvars at the offsets in asm/vvar.h. */</span>
<span class="p_del">-#define EMIT_VVAR(name, offset) vvar_ ## name = vvar_page + offset;</span>
<span class="p_del">-#define __VVAR_KERNEL_LDS</span>
<span class="p_del">-#include &lt;asm/vvar.h&gt;</span>
<span class="p_del">-#undef __VVAR_KERNEL_LDS</span>
<span class="p_del">-#undef EMIT_VVAR</span>
<span class="p_del">-</span>
<span class="p_del">-	. = vvar_page + PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	hpet_page = .;</span>
<span class="p_del">-	. = . + PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	. = ALIGN(PAGE_SIZE);</span>
<span class="p_del">-	end_mapping = .;</span>
<span class="p_del">-</span>
 	/DISCARD/ : {
 		*(.discard)
 		*(.discard.*)
<span class="p_header">diff --git a/arch/x86/vdso/vdso2c.c b/arch/x86/vdso/vdso2c.c</span>
<span class="p_header">index 238dbe82776e..b68127538571 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso2c.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso2c.c</span>
<span class="p_chunk">@@ -20,9 +20,10 @@</span> <span class="p_context"> const char *outfilename;</span>
 
 /* Symbols that we need in vdso2c. */
 enum {
<span class="p_add">+	sym_vvar_start,</span>
 	sym_vvar_page,
 	sym_hpet_page,
<span class="p_del">-	sym_end_mapping,</span>
<span class="p_add">+	sym_pvclock_page,</span>
 	sym_VDSO_FAKE_SECTION_TABLE_START,
 	sym_VDSO_FAKE_SECTION_TABLE_END,
 };
<span class="p_chunk">@@ -30,6 +31,7 @@</span> <span class="p_context"> enum {</span>
 const int special_pages[] = {
 	sym_vvar_page,
 	sym_hpet_page,
<span class="p_add">+	sym_pvclock_page,</span>
 };
 
 struct vdso_sym {
<span class="p_chunk">@@ -38,9 +40,10 @@</span> <span class="p_context"> struct vdso_sym {</span>
 };
 
 struct vdso_sym required_syms[] = {
<span class="p_add">+	[sym_vvar_start] = {&quot;vvar_start&quot;, true},</span>
 	[sym_vvar_page] = {&quot;vvar_page&quot;, true},
 	[sym_hpet_page] = {&quot;hpet_page&quot;, true},
<span class="p_del">-	[sym_end_mapping] = {&quot;end_mapping&quot;, true},</span>
<span class="p_add">+	[sym_pvclock_page] = {&quot;pvclock_page&quot;, true},</span>
 	[sym_VDSO_FAKE_SECTION_TABLE_START] = {
 		&quot;VDSO_FAKE_SECTION_TABLE_START&quot;, false
 	},
<span class="p_chunk">@@ -96,9 +99,11 @@</span> <span class="p_context"> extern void bad_put_le(void);</span>
 
 #define NSYMS (sizeof(required_syms) / sizeof(required_syms[0]))
 
<span class="p_del">-#define BITSFUNC3(name, bits) name##bits</span>
<span class="p_del">-#define BITSFUNC2(name, bits) BITSFUNC3(name, bits)</span>
<span class="p_del">-#define BITSFUNC(name) BITSFUNC2(name, ELF_BITS)</span>
<span class="p_add">+#define BITSFUNC3(name, bits, suffix) name##bits##suffix</span>
<span class="p_add">+#define BITSFUNC2(name, bits, suffix) BITSFUNC3(name, bits, suffix)</span>
<span class="p_add">+#define BITSFUNC(name) BITSFUNC2(name, ELF_BITS, )</span>
<span class="p_add">+</span>
<span class="p_add">+#define INT_BITS BITSFUNC2(int, ELF_BITS, _t)</span>
 
 #define ELF_BITS_XFORM2(bits, x) Elf##bits##_##x
 #define ELF_BITS_XFORM(bits, x) ELF_BITS_XFORM2(bits, x)
<span class="p_header">diff --git a/arch/x86/vdso/vdso2c.h b/arch/x86/vdso/vdso2c.h</span>
<span class="p_header">index 11b65d4f9414..2da32fbc46da 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso2c.h</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso2c.h</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> static void BITSFUNC(go)(void *addr, size_t len,</span>
 		*alt_sec = NULL;
 	ELF(Dyn) *dyn = 0, *dyn_end = 0;
 	const char *secstrings;
<span class="p_del">-	uint64_t syms[NSYMS] = {};</span>
<span class="p_add">+	INT_BITS syms[NSYMS] = {};</span>
 
 	struct BITSFUNC(fake_sections) fake_sections = {};
 
<span class="p_chunk">@@ -209,6 +209,13 @@</span> <span class="p_context"> static void BITSFUNC(go)(void *addr, size_t len,</span>
 					fail(&quot;duplicate symbol %s\n&quot;,
 					     required_syms[k].name);
 				}
<span class="p_add">+</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Careful: we use negative addresses, but</span>
<span class="p_add">+				 * st_value is unsigned, so we rely</span>
<span class="p_add">+				 * on syms[k] being a signed type of the</span>
<span class="p_add">+				 * correct width.</span>
<span class="p_add">+				 */</span>
 				syms[k] = GET_LE(&amp;sym-&gt;st_value);
 			}
 		}
<span class="p_chunk">@@ -263,15 +270,15 @@</span> <span class="p_context"> static void BITSFUNC(go)(void *addr, size_t len,</span>
 		if (syms[i] % 4096)
 			fail(&quot;%s must be a multiple of 4096\n&quot;,
 			     required_syms[i].name);
<span class="p_del">-		if (syms[i] &lt; data_size)</span>
<span class="p_del">-			fail(&quot;%s must be after the text mapping\n&quot;,</span>
<span class="p_add">+		if (syms[sym_vvar_start] &gt; syms[i] + 4096)</span>
<span class="p_add">+			fail(&quot;%s underruns begin_vvar\n&quot;,</span>
 			     required_syms[i].name);
<span class="p_del">-		if (syms[sym_end_mapping] &lt; syms[i] + 4096)</span>
<span class="p_del">-			fail(&quot;%s overruns end_mapping\n&quot;,</span>
<span class="p_add">+		if (syms[i] + 4096 &gt; 0)</span>
<span class="p_add">+			fail(&quot;%s is on the wrong side of the vdso text\n&quot;,</span>
 			     required_syms[i].name);
 	}
<span class="p_del">-	if (syms[sym_end_mapping] % 4096)</span>
<span class="p_del">-		fail(&quot;end_mapping must be a multiple of 4096\n&quot;);</span>
<span class="p_add">+	if (syms[sym_vvar_start] % 4096)</span>
<span class="p_add">+		fail(&quot;vvar_begin must be a multiple of 4096\n&quot;);</span>
 
 	if (!name) {
 		fwrite(addr, load_size, 1, outfile);
<span class="p_chunk">@@ -311,8 +318,8 @@</span> <span class="p_context"> static void BITSFUNC(go)(void *addr, size_t len,</span>
 	}
 	for (i = 0; i &lt; NSYMS; i++) {
 		if (required_syms[i].export &amp;&amp; syms[i])
<span class="p_del">-			fprintf(outfile, &quot;\t.sym_%s = 0x%&quot; PRIx64 &quot;,\n&quot;,</span>
<span class="p_del">-				required_syms[i].name, syms[i]);</span>
<span class="p_add">+			fprintf(outfile, &quot;\t.sym_%s = %&quot; PRIi64 &quot;,\n&quot;,</span>
<span class="p_add">+				required_syms[i].name, (int64_t)syms[i]);</span>
 	}
 	fprintf(outfile, &quot;};\n&quot;);
 }
<span class="p_header">diff --git a/arch/x86/vdso/vma.c b/arch/x86/vdso/vma.c</span>
<span class="p_header">index 3ae68edd8c52..91b2677213cf 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vma.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vma.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/random.h&gt;
 #include &lt;linux/elf.h&gt;
 #include &lt;asm/vsyscall.h&gt;
<span class="p_add">+#include &lt;asm/pvclock.h&gt;</span>
 #include &lt;asm/vgtod.h&gt;
 #include &lt;asm/proto.h&gt;
 #include &lt;asm/vdso.h&gt;
<span class="p_chunk">@@ -106,36 +107,39 @@</span> <span class="p_context"> static int map_vdso(const struct vdso_image *image, bool calculate_addr)</span>
 {
 	struct mm_struct *mm = current-&gt;mm;
 	struct vm_area_struct *vma;
<span class="p_del">-	unsigned long addr;</span>
<span class="p_add">+	unsigned long addr, text_start;</span>
 	int ret = 0;
 	static struct page *no_pages[] = {NULL};
 	static struct vm_special_mapping vvar_mapping = {
 		.name = &quot;[vvar]&quot;,
 		.pages = no_pages,
 	};
<span class="p_add">+	struct pvclock_vsyscall_time_info *pvti;</span>
 
 	if (calculate_addr) {
 		addr = vdso_addr(current-&gt;mm-&gt;start_stack,
<span class="p_del">-				 image-&gt;sym_end_mapping);</span>
<span class="p_add">+				 image-&gt;size - image-&gt;sym_vvar_start);</span>
 	} else {
 		addr = 0;
 	}
 
 	down_write(&amp;mm-&gt;mmap_sem);
 
<span class="p_del">-	addr = get_unmapped_area(NULL, addr, image-&gt;sym_end_mapping, 0, 0);</span>
<span class="p_add">+	addr = get_unmapped_area(NULL, addr,</span>
<span class="p_add">+				 image-&gt;size - image-&gt;sym_vvar_start, 0, 0);</span>
 	if (IS_ERR_VALUE(addr)) {
 		ret = addr;
 		goto up_fail;
 	}
 
<span class="p_del">-	current-&gt;mm-&gt;context.vdso = (void __user *)addr;</span>
<span class="p_add">+	text_start = addr - image-&gt;sym_vvar_start;</span>
<span class="p_add">+	current-&gt;mm-&gt;context.vdso = (void __user *)text_start;</span>
 
 	/*
 	 * MAYWRITE to allow gdb to COW and set breakpoints
 	 */
 	vma = _install_special_mapping(mm,
<span class="p_del">-				       addr,</span>
<span class="p_add">+				       text_start,</span>
 				       image-&gt;size,
 				       VM_READ|VM_EXEC|
 				       VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC,
<span class="p_chunk">@@ -147,8 +151,8 @@</span> <span class="p_context"> static int map_vdso(const struct vdso_image *image, bool calculate_addr)</span>
 	}
 
 	vma = _install_special_mapping(mm,
<span class="p_del">-				       addr + image-&gt;size,</span>
<span class="p_del">-				       image-&gt;sym_end_mapping - image-&gt;size,</span>
<span class="p_add">+				       addr,</span>
<span class="p_add">+				       -image-&gt;sym_vvar_start,</span>
 				       VM_READ,
 				       &amp;vvar_mapping);
 
<span class="p_chunk">@@ -159,7 +163,7 @@</span> <span class="p_context"> static int map_vdso(const struct vdso_image *image, bool calculate_addr)</span>
 
 	if (image-&gt;sym_vvar_page)
 		ret = remap_pfn_range(vma,
<span class="p_del">-				      addr + image-&gt;sym_vvar_page,</span>
<span class="p_add">+				      text_start + image-&gt;sym_vvar_page,</span>
 				      __pa_symbol(&amp;__vvar_page) &gt;&gt; PAGE_SHIFT,
 				      PAGE_SIZE,
 				      PAGE_READONLY);
<span class="p_chunk">@@ -170,7 +174,7 @@</span> <span class="p_context"> static int map_vdso(const struct vdso_image *image, bool calculate_addr)</span>
 #ifdef CONFIG_HPET_TIMER
 	if (hpet_address &amp;&amp; image-&gt;sym_hpet_page) {
 		ret = io_remap_pfn_range(vma,
<span class="p_del">-			addr + image-&gt;sym_hpet_page,</span>
<span class="p_add">+			text_start + image-&gt;sym_hpet_page,</span>
 			hpet_address &gt;&gt; PAGE_SHIFT,
 			PAGE_SIZE,
 			pgprot_noncached(PAGE_READONLY));
<span class="p_chunk">@@ -180,6 +184,18 @@</span> <span class="p_context"> static int map_vdso(const struct vdso_image *image, bool calculate_addr)</span>
 	}
 #endif
 
<span class="p_add">+	pvti = pvclock_pvti_cpu0_va();</span>
<span class="p_add">+	if (pvti &amp;&amp; image-&gt;sym_pvclock_page) {</span>
<span class="p_add">+		ret = remap_pfn_range(vma,</span>
<span class="p_add">+				      text_start + image-&gt;sym_pvclock_page,</span>
<span class="p_add">+				      __pa(pvti) &gt;&gt; PAGE_SHIFT,</span>
<span class="p_add">+				      PAGE_SIZE,</span>
<span class="p_add">+				      PAGE_READONLY);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto up_fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 up_fail:
 	if (ret)
 		current-&gt;mm-&gt;context.vdso = NULL;
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 972e08de8ef8..be6fd704d2a4 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -611,6 +611,9 @@</span> <span class="p_context"> struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)</span>
 
 	kobject_init(&amp;q-&gt;kobj, &amp;blk_queue_ktype);
 
<span class="p_add">+#ifdef CONFIG_BLK_DEV_IO_TRACE</span>
<span class="p_add">+	mutex_init(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+#endif</span>
 	mutex_init(&amp;q-&gt;sysfs_lock);
 	spin_lock_init(&amp;q-&gt;__queue_lock);
 
<span class="p_header">diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c</span>
<span class="p_header">index ccb6876d9d86..019db73c01fa 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/ghes.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/ghes.c</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/aer.h&gt;
 
 #include &lt;acpi/ghes.h&gt;
<span class="p_add">+#include &lt;asm/fixmap.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/nmi.h&gt;
<span class="p_chunk">@@ -110,22 +111,10 @@</span> <span class="p_context"> static DEFINE_RAW_SPINLOCK(ghes_nmi_lock);</span>
  * Because the memory area used to transfer hardware error information
  * from BIOS to Linux can be determined only in NMI, IRQ or timer
  * handler, but general ioremap can not be used in atomic context, so
<span class="p_del">- * a special version of atomic ioremap is implemented for that.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Two virtual pages are used, one for NMI context, the other for</span>
<span class="p_del">- * IRQ/PROCESS context</span>
<span class="p_del">- */</span>
<span class="p_del">-#define GHES_IOREMAP_PAGES		2</span>
<span class="p_del">-#define GHES_IOREMAP_NMI_PAGE(base)	(base)</span>
<span class="p_del">-#define GHES_IOREMAP_IRQ_PAGE(base)	((base) + PAGE_SIZE)</span>
<span class="p_del">-</span>
<span class="p_del">-/* virtual memory area for atomic ioremap */</span>
<span class="p_del">-static struct vm_struct *ghes_ioremap_area;</span>
<span class="p_del">-/*</span>
<span class="p_del">- * These 2 spinlock is used to prevent atomic ioremap virtual memory</span>
<span class="p_del">- * area from being mapped simultaneously.</span>
<span class="p_add">+ * the fixmap is used instead.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * These 2 spinlocks are used to prevent the fixmap entries from being used</span>
<span class="p_add">+ * simultaneously.</span>
  */
 static DEFINE_RAW_SPINLOCK(ghes_ioremap_lock_nmi);
 static DEFINE_SPINLOCK(ghes_ioremap_lock_irq);
<span class="p_chunk">@@ -146,63 +135,28 @@</span> <span class="p_context"> static struct irq_work ghes_proc_irq_work;</span>
 struct ghes_estatus_cache *ghes_estatus_caches[GHES_ESTATUS_CACHES_SIZE];
 static atomic_t ghes_estatus_cache_alloced;
 
<span class="p_del">-static int ghes_ioremap_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ghes_ioremap_area = __get_vm_area(PAGE_SIZE * GHES_IOREMAP_PAGES,</span>
<span class="p_del">-		VM_IOREMAP, VMALLOC_START, VMALLOC_END);</span>
<span class="p_del">-	if (!ghes_ioremap_area) {</span>
<span class="p_del">-		pr_err(GHES_PFX &quot;Failed to allocate virtual memory area for atomic ioremap.\n&quot;);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void ghes_ioremap_exit(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	free_vm_area(ghes_ioremap_area);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void __iomem *ghes_ioremap_pfn_nmi(u64 pfn)
 {
<span class="p_del">-	unsigned long vaddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	vaddr = (unsigned long)GHES_IOREMAP_NMI_PAGE(ghes_ioremap_area-&gt;addr);</span>
<span class="p_del">-	ioremap_page_range(vaddr, vaddr + PAGE_SIZE,</span>
<span class="p_del">-			   pfn &lt;&lt; PAGE_SHIFT, PAGE_KERNEL);</span>
<span class="p_add">+	__set_fixmap(FIX_APEI_GHES_NMI, pfn &lt;&lt; PAGE_SHIFT, PAGE_KERNEL);</span>
 
<span class="p_del">-	return (void __iomem *)vaddr;</span>
<span class="p_add">+	return (void __iomem *) fix_to_virt(FIX_APEI_GHES_NMI);</span>
 }
 
 static void __iomem *ghes_ioremap_pfn_irq(u64 pfn)
 {
<span class="p_del">-	unsigned long vaddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	vaddr = (unsigned long)GHES_IOREMAP_IRQ_PAGE(ghes_ioremap_area-&gt;addr);</span>
<span class="p_del">-	ioremap_page_range(vaddr, vaddr + PAGE_SIZE,</span>
<span class="p_del">-			   pfn &lt;&lt; PAGE_SHIFT, PAGE_KERNEL);</span>
<span class="p_add">+	__set_fixmap(FIX_APEI_GHES_IRQ, pfn &lt;&lt; PAGE_SHIFT, PAGE_KERNEL);</span>
 
<span class="p_del">-	return (void __iomem *)vaddr;</span>
<span class="p_add">+	return (void __iomem *) fix_to_virt(FIX_APEI_GHES_IRQ);</span>
 }
 
<span class="p_del">-static void ghes_iounmap_nmi(void __iomem *vaddr_ptr)</span>
<span class="p_add">+static void ghes_iounmap_nmi(void)</span>
 {
<span class="p_del">-	unsigned long vaddr = (unsigned long __force)vaddr_ptr;</span>
<span class="p_del">-	void *base = ghes_ioremap_area-&gt;addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(vaddr != (unsigned long)GHES_IOREMAP_NMI_PAGE(base));</span>
<span class="p_del">-	unmap_kernel_range_noflush(vaddr, PAGE_SIZE);</span>
<span class="p_del">-	__flush_tlb_one(vaddr);</span>
<span class="p_add">+	clear_fixmap(FIX_APEI_GHES_NMI);</span>
 }
 
<span class="p_del">-static void ghes_iounmap_irq(void __iomem *vaddr_ptr)</span>
<span class="p_add">+static void ghes_iounmap_irq(void)</span>
 {
<span class="p_del">-	unsigned long vaddr = (unsigned long __force)vaddr_ptr;</span>
<span class="p_del">-	void *base = ghes_ioremap_area-&gt;addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(vaddr != (unsigned long)GHES_IOREMAP_IRQ_PAGE(base));</span>
<span class="p_del">-	unmap_kernel_range_noflush(vaddr, PAGE_SIZE);</span>
<span class="p_del">-	__flush_tlb_one(vaddr);</span>
<span class="p_add">+	clear_fixmap(FIX_APEI_GHES_IRQ);</span>
 }
 
 static int ghes_estatus_pool_init(void)
<span class="p_chunk">@@ -341,10 +295,10 @@</span> <span class="p_context"> static void ghes_copy_tofrom_phys(void *buffer, u64 paddr, u32 len,</span>
 		paddr += trunk;
 		buffer += trunk;
 		if (in_nmi) {
<span class="p_del">-			ghes_iounmap_nmi(vaddr);</span>
<span class="p_add">+			ghes_iounmap_nmi();</span>
 			raw_spin_unlock(&amp;ghes_ioremap_lock_nmi);
 		} else {
<span class="p_del">-			ghes_iounmap_irq(vaddr);</span>
<span class="p_add">+			ghes_iounmap_irq();</span>
 			spin_unlock_irqrestore(&amp;ghes_ioremap_lock_irq, flags);
 		}
 	}
<span class="p_chunk">@@ -1080,13 +1034,9 @@</span> <span class="p_context"> static int __init ghes_init(void)</span>
 
 	init_irq_work(&amp;ghes_proc_irq_work, ghes_proc_in_irq);
 
<span class="p_del">-	rc = ghes_ioremap_init();</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-</span>
 	rc = ghes_estatus_pool_init();
 	if (rc)
<span class="p_del">-		goto err_ioremap_exit;</span>
<span class="p_add">+		goto err;</span>
 
 	rc = ghes_estatus_pool_expand(GHES_ESTATUS_CACHE_AVG_SIZE *
 				      GHES_ESTATUS_CACHE_ALLOCED_MAX);
<span class="p_chunk">@@ -1110,8 +1060,6 @@</span> <span class="p_context"> static int __init ghes_init(void)</span>
 	return 0;
 err_pool_exit:
 	ghes_estatus_pool_exit();
<span class="p_del">-err_ioremap_exit:</span>
<span class="p_del">-	ghes_ioremap_exit();</span>
 err:
 	return rc;
 }
<span class="p_chunk">@@ -1120,7 +1068,6 @@</span> <span class="p_context"> static void __exit ghes_exit(void)</span>
 {
 	platform_driver_unregister(&amp;ghes_platform_driver);
 	ghes_estatus_pool_exit();
<span class="p_del">-	ghes_ioremap_exit();</span>
 }
 
 module_init(ghes_init);
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_header">index e6db9381b2c7..edeadbf962d7 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_chunk">@@ -4007,7 +4007,8 @@</span> <span class="p_context"> smi_from_recv_msg(ipmi_smi_t intf, struct ipmi_recv_msg *recv_msg,</span>
 }
 
 static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,
<span class="p_del">-			      struct list_head *timeouts, long timeout_period,</span>
<span class="p_add">+			      struct list_head *timeouts,</span>
<span class="p_add">+			      unsigned long timeout_period,</span>
 			      int slot, unsigned long *flags,
 			      unsigned int *waiting_msgs)
 {
<span class="p_chunk">@@ -4020,8 +4021,8 @@</span> <span class="p_context"> static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,</span>
 	if (!ent-&gt;inuse)
 		return;
 
<span class="p_del">-	ent-&gt;timeout -= timeout_period;</span>
<span class="p_del">-	if (ent-&gt;timeout &gt; 0) {</span>
<span class="p_add">+	if (timeout_period &lt; ent-&gt;timeout) {</span>
<span class="p_add">+		ent-&gt;timeout -= timeout_period;</span>
 		(*waiting_msgs)++;
 		return;
 	}
<span class="p_chunk">@@ -4088,7 +4089,8 @@</span> <span class="p_context"> static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,</span>
 	}
 }
 
<span class="p_del">-static unsigned int ipmi_timeout_handler(ipmi_smi_t intf, long timeout_period)</span>
<span class="p_add">+static unsigned int ipmi_timeout_handler(ipmi_smi_t intf,</span>
<span class="p_add">+					 unsigned long timeout_period)</span>
 {
 	struct list_head     timeouts;
 	struct ipmi_recv_msg *msg, *msg2;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">index d9b774e02a1f..2a86a75a5e28 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_chunk">@@ -139,6 +139,12 @@</span> <span class="p_context"> static ssize_t tpm_write(struct file *file, const char __user *buf,</span>
 		return -EFAULT;
 	}
 
<span class="p_add">+	if (in_size &lt; 6 ||</span>
<span class="p_add">+	    in_size &lt; be32_to_cpu(*((__be32 *) (priv-&gt;data_buffer + 2)))) {</span>
<span class="p_add">+		mutex_unlock(&amp;priv-&gt;buffer_mutex);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* atomic tpm command send and result receive */
 	out_size = tpm_transmit(priv-&gt;chip, priv-&gt;data_buffer,
 				sizeof(priv-&gt;data_buffer));
<span class="p_header">diff --git a/drivers/clk/tegra/clk-tegra30.c b/drivers/clk/tegra/clk-tegra30.c</span>
<span class="p_header">index 8b10c38b6e3c..7609f5a4cebf 100644</span>
<span class="p_header">--- a/drivers/clk/tegra/clk-tegra30.c</span>
<span class="p_header">+++ b/drivers/clk/tegra/clk-tegra30.c</span>
<span class="p_chunk">@@ -1060,7 +1060,7 @@</span> <span class="p_context"> static void __init tegra30_super_clk_init(void)</span>
 	 * U71 divider of cclk_lp.
 	 */
 	clk = tegra_clk_register_divider(&quot;pll_p_out3_cclklp&quot;, &quot;pll_p_out3&quot;,
<span class="p_del">-				clk_base + SUPER_CCLKG_DIVIDER, 0,</span>
<span class="p_add">+				clk_base + SUPER_CCLKLP_DIVIDER, 0,</span>
 				TEGRA_DIVIDER_INT, 16, 8, 1, NULL);
 	clk_register_clkdev(clk, &quot;pll_p_out3_cclklp&quot;, NULL);
 
<span class="p_header">diff --git a/drivers/clk/ti/clk-dra7-atl.c b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">index d1db76887b8b..e4405d19e669 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 
 		/* Get configuration for the ATL instances */
 		snprintf(prop, sizeof(prop), &quot;atl%u&quot;, i);
<span class="p_del">-		cfg_node = of_find_node_by_name(node, prop);</span>
<span class="p_add">+		cfg_node = of_get_child_by_name(node, prop);</span>
 		if (cfg_node) {
 			ret = of_property_read_u32(cfg_node, &quot;bws&quot;,
 						   &amp;cdesc-&gt;bws);
<span class="p_chunk">@@ -275,6 +275,7 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 				atl_write(cinfo, DRA7_ATL_AWSMUX_REG(i),
 					  cdesc-&gt;aws);
 			}
<span class="p_add">+			of_node_put(cfg_node);</span>
 		}
 
 		cdesc-&gt;probed = true;
<span class="p_header">diff --git a/drivers/crypto/caam/desc.h b/drivers/crypto/caam/desc.h</span>
<span class="p_header">index 7e4500f18df6..9c3f9e183b67 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/desc.h</span>
<span class="p_header">+++ b/drivers/crypto/caam/desc.h</span>
<span class="p_chunk">@@ -1434,7 +1434,7 @@</span> <span class="p_context"> struct sec4_sg_entry {</span>
 #define MATH_SRC1_REG2		(0x02 &lt;&lt; MATH_SRC1_SHIFT)
 #define MATH_SRC1_REG3		(0x03 &lt;&lt; MATH_SRC1_SHIFT)
 #define MATH_SRC1_IMM		(0x04 &lt;&lt; MATH_SRC1_SHIFT)
<span class="p_del">-#define MATH_SRC1_DPOVRD	(0x07 &lt;&lt; MATH_SRC0_SHIFT)</span>
<span class="p_add">+#define MATH_SRC1_DPOVRD	(0x07 &lt;&lt; MATH_SRC1_SHIFT)</span>
 #define MATH_SRC1_INFIFO	(0x0a &lt;&lt; MATH_SRC1_SHIFT)
 #define MATH_SRC1_OUTFIFO	(0x0b &lt;&lt; MATH_SRC1_SHIFT)
 #define MATH_SRC1_ONE		(0x0c &lt;&lt; MATH_SRC1_SHIFT)
<span class="p_header">diff --git a/drivers/gpu/drm/gma500/mdfld_intel_display.c b/drivers/gpu/drm/gma500/mdfld_intel_display.c</span>
<span class="p_header">index 8cc8a5abbc7b..95a05c5976d7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/gma500/mdfld_intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/gma500/mdfld_intel_display.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> void mdfldWaitForPipeEnable(struct drm_device *dev, int pipe)</span>
 	/* Wait for for the pipe enable to take effect. */
 	for (count = 0; count &lt; COUNT_MAX; count++) {
 		temp = REG_READ(map-&gt;conf);
<span class="p_del">-		if ((temp &amp; PIPEACONF_PIPE_STATE) == 1)</span>
<span class="p_add">+		if (temp &amp; PIPEACONF_PIPE_STATE)</span>
 			break;
 	}
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">index e03526a10340..367a1ab8e7ca 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_chunk">@@ -1007,7 +1007,7 @@</span> <span class="p_context"> static void parse_ddi_ports(struct drm_i915_private *dev_priv,</span>
 	struct drm_device *dev = dev_priv-&gt;dev;
 	enum port port;
 
<span class="p_del">-	if (!HAS_DDI(dev))</span>
<span class="p_add">+	if (!HAS_DDI(dev) &amp;&amp; !IS_CHERRYVIEW(dev))</span>
 		return;
 
 	if (!dev_priv-&gt;vbt.child_dev_num)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 3a3afe1b15bd..7bcca10ae746 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -8662,13 +8662,10 @@</span> <span class="p_context"> struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,</span>
 {
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
<span class="p_del">-	enum transcoder cpu_transcoder = intel_crtc-&gt;config.cpu_transcoder;</span>
<span class="p_add">+	enum transcoder cpu_transcoder;</span>
 	struct drm_display_mode *mode;
 	struct intel_crtc_config pipe_config;
<span class="p_del">-	int htot = I915_READ(HTOTAL(cpu_transcoder));</span>
<span class="p_del">-	int hsync = I915_READ(HSYNC(cpu_transcoder));</span>
<span class="p_del">-	int vtot = I915_READ(VTOTAL(cpu_transcoder));</span>
<span class="p_del">-	int vsync = I915_READ(VSYNC(cpu_transcoder));</span>
<span class="p_add">+	u32 htot, hsync, vtot, vsync;</span>
 	enum pipe pipe = intel_crtc-&gt;pipe;
 
 	mode = kzalloc(sizeof(*mode), GFP_KERNEL);
<span class="p_chunk">@@ -8690,6 +8687,13 @@</span> <span class="p_context"> struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,</span>
 	i9xx_crtc_clock_get(intel_crtc, &amp;pipe_config);
 
 	mode-&gt;clock = pipe_config.port_clock / pipe_config.pixel_multiplier;
<span class="p_add">+</span>
<span class="p_add">+	cpu_transcoder = pipe_config.cpu_transcoder;</span>
<span class="p_add">+	htot = I915_READ(HTOTAL(cpu_transcoder));</span>
<span class="p_add">+	hsync = I915_READ(HSYNC(cpu_transcoder));</span>
<span class="p_add">+	vtot = I915_READ(VTOTAL(cpu_transcoder));</span>
<span class="p_add">+	vsync = I915_READ(VSYNC(cpu_transcoder));</span>
<span class="p_add">+</span>
 	mode-&gt;hdisplay = (htot &amp; 0xffff) + 1;
 	mode-&gt;htotal = ((htot &amp; 0xffff0000) &gt;&gt; 16) + 1;
 	mode-&gt;hsync_start = (hsync &amp; 0xffff) + 1;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index b5660eb078f6..16b14c02236b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -1365,8 +1365,8 @@</span> <span class="p_context"> void intel_edp_panel_off(struct intel_dp *intel_dp)</span>
 	I915_WRITE(pp_ctrl_reg, pp);
 	POSTING_READ(pp_ctrl_reg);
 
<span class="p_del">-	intel_dp-&gt;last_power_cycle = jiffies;</span>
 	wait_panel_off(intel_dp);
<span class="p_add">+	intel_dp-&gt;last_power_cycle = jiffies;</span>
 
 	/* We got a reference when we enabled the VDD. */
 	power_domain = intel_display_port_power_domain(intel_encoder);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index f9db2aabc2ac..7a475cbd1aa9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -45,34 +45,32 @@</span> <span class="p_context"> static char *pre_emph_names[] = {</span>
 
 /***** radeon AUX functions *****/
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void radeon_atom_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">index 1df856f78568..2248cd68657f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_chunk">@@ -463,6 +463,7 @@</span> <span class="p_context"> static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,</span>
 	INIT_LIST_HEAD(&amp;fbo-&gt;lru);
 	INIT_LIST_HEAD(&amp;fbo-&gt;swap);
 	INIT_LIST_HEAD(&amp;fbo-&gt;io_reserve_lru);
<span class="p_add">+	mutex_init(&amp;fbo-&gt;wu_mutex);</span>
 	drm_vma_node_reset(&amp;fbo-&gt;vma_node);
 	atomic_set(&amp;fbo-&gt;cpu_writers, 0);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 3e1ea0323983..5a2aab8c75ea 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1468,7 +1468,7 @@</span> <span class="p_context"> static int __mlx4_ib_modify_qp(struct ib_qp *ibqp,</span>
 			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) |
 					      ilog2(dev-&gt;dev-&gt;caps.max_gso_sz);
 		else
<span class="p_del">-			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 12;</span>
<span class="p_add">+			context-&gt;mtu_msgmax = (IB_MTU_4096 &lt;&lt; 5) | 13;</span>
 	} else if (attr_mask &amp; IB_QP_PATH_MTU) {
 		if (attr-&gt;path_mtu &lt; IB_MTU_256 || attr-&gt;path_mtu &gt; IB_MTU_4096) {
 			pr_err(&quot;path MTU (%u) is invalid\n&quot;,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index b7e8515dfaf1..1936cbfc3c5e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -1164,6 +1164,8 @@</span> <span class="p_context"> static int create_umr_res(struct mlx5_ib_dev *dev)</span>
 	qp-&gt;real_qp    = qp;
 	qp-&gt;uobject    = NULL;
 	qp-&gt;qp_type    = MLX5_IB_QPT_REG_UMR;
<span class="p_add">+	qp-&gt;send_cq    = init_attr-&gt;send_cq;</span>
<span class="p_add">+	qp-&gt;recv_cq    = init_attr-&gt;recv_cq;</span>
 
 	attr-&gt;qp_state = IB_QPS_INIT;
 	attr-&gt;port_num = 1;
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 6311fd448c36..4591cc7b8240 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -600,12 +600,19 @@</span> <span class="p_context"> static void srp_path_rec_completion(int status,</span>
 
 static int srp_lookup_path(struct srp_target_port *target)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENODEV;</span>
 
 	target-&gt;path.numb_path = 1;
 
 	init_completion(&amp;target-&gt;done);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid that the SCSI host can be removed by srp_remove_target()</span>
<span class="p_add">+	 * before srp_path_rec_completion() is called.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!scsi_host_get(target-&gt;scsi_host))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	target-&gt;path_query_id = ib_sa_path_rec_get(&amp;srp_sa_client,
 						   target-&gt;srp_host-&gt;srp_dev-&gt;dev,
 						   target-&gt;srp_host-&gt;port,
<span class="p_chunk">@@ -619,18 +626,24 @@</span> <span class="p_context"> static int srp_lookup_path(struct srp_target_port *target)</span>
 						   GFP_KERNEL,
 						   srp_path_rec_completion,
 						   target, &amp;target-&gt;path_query);
<span class="p_del">-	if (target-&gt;path_query_id &lt; 0)</span>
<span class="p_del">-		return target-&gt;path_query_id;</span>
<span class="p_add">+	ret = target-&gt;path_query_id;</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto put;</span>
 
 	ret = wait_for_completion_interruptible(&amp;target-&gt;done);
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	if (target-&gt;status &lt; 0)</span>
<span class="p_add">+	ret = target-&gt;status;</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		shost_printk(KERN_WARNING, target-&gt;scsi_host,
 			     PFX &quot;Path record query failed\n&quot;);
 
<span class="p_del">-	return target-&gt;status;</span>
<span class="p_add">+put:</span>
<span class="p_add">+	scsi_host_put(target-&gt;scsi_host);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int srp_send_req(struct srp_target_port *target)
<span class="p_header">diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.c b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">index 1f15b4d0fd10..0ee17bb7f7b2 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_chunk">@@ -3521,7 +3521,7 @@</span> <span class="p_context"> static int srpt_parse_i_port_id(u8 i_port_id[16], const char *name)</span>
 {
 	const char *p;
 	unsigned len, count, leading_zero_bytes;
<span class="p_del">-	int ret, rc;</span>
<span class="p_add">+	int ret;</span>
 
 	p = name;
 	if (strnicmp(p, &quot;0x&quot;, 2) == 0)
<span class="p_chunk">@@ -3533,10 +3533,9 @@</span> <span class="p_context"> static int srpt_parse_i_port_id(u8 i_port_id[16], const char *name)</span>
 	count = min(len / 2, 16U);
 	leading_zero_bytes = 16 - count;
 	memset(i_port_id, 0, leading_zero_bytes);
<span class="p_del">-	rc = hex2bin(i_port_id + leading_zero_bytes, p, count);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		pr_debug(&quot;hex2bin failed for srpt_parse_i_port_id: %d\n&quot;, rc);</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+	ret = hex2bin(i_port_id + leading_zero_bytes, p, count);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		pr_debug(&quot;hex2bin failed for srpt_parse_i_port_id: %d\n&quot;, ret);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/drivers/input/misc/adxl34x.c b/drivers/input/misc/adxl34x.c</span>
<span class="p_header">index 2b2d02f408bb..a3e79bf5a04b 100644</span>
<span class="p_header">--- a/drivers/input/misc/adxl34x.c</span>
<span class="p_header">+++ b/drivers/input/misc/adxl34x.c</span>
<span class="p_chunk">@@ -796,7 +796,7 @@</span> <span class="p_context"> struct adxl34x *adxl34x_probe(struct device *dev, int irq,</span>
 
 	if (pdata-&gt;watermark) {
 		ac-&gt;int_mask |= WATERMARK;
<span class="p_del">-		if (!FIFO_MODE(pdata-&gt;fifo_mode))</span>
<span class="p_add">+		if (FIFO_MODE(pdata-&gt;fifo_mode) == FIFO_BYPASS)</span>
 			ac-&gt;pdata.fifo_mode |= FIFO_STREAM;
 	} else {
 		ac-&gt;int_mask |= DATA_READY;
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index bccfacabbae7..3793d6695ed3 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -718,13 +718,16 @@</span> <span class="p_context"> int __init dmar_dev_scope_init(void)</span>
 				dmar_free_pci_notify_info(info);
 			}
 		}
<span class="p_del">-</span>
<span class="p_del">-		bus_register_notifier(&amp;pci_bus_type, &amp;dmar_pci_bus_nb);</span>
 	}
 
 	return dmar_dev_scope_status;
 }
 
<span class="p_add">+void dmar_register_bus_notifier(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bus_register_notifier(&amp;pci_bus_type, &amp;dmar_pci_bus_nb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 int __init dmar_table_init(void)
 {
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 5b331109b4c4..a2a8a45c3217 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -4044,6 +4044,16 @@</span> <span class="p_context"> int __init intel_iommu_init(void)</span>
 		goto out_free_dmar;
 	}
 
<span class="p_add">+	up_write(&amp;dmar_global_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The bus notifier takes the dmar_global_lock, so lockdep will</span>
<span class="p_add">+	 * complain later when we register it under the lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dmar_register_bus_notifier();</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;dmar_global_lock);</span>
<span class="p_add">+</span>
 	if (no_iommu || dmar_disabled)
 		goto out_free_dmar;
 
<span class="p_header">diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c</span>
<span class="p_header">index 443d03fbac47..7bf9fdb62751 100644</span>
<span class="p_header">--- a/drivers/md/bcache/alloc.c</span>
<span class="p_header">+++ b/drivers/md/bcache/alloc.c</span>
<span class="p_chunk">@@ -406,7 +406,8 @@</span> <span class="p_context"> long bch_bucket_alloc(struct cache *ca, unsigned reserve, bool wait)</span>
 
 	finish_wait(&amp;ca-&gt;set-&gt;bucket_wait, &amp;w);
 out:
<span class="p_del">-	wake_up_process(ca-&gt;alloc_thread);</span>
<span class="p_add">+	if (ca-&gt;alloc_thread)</span>
<span class="p_add">+		wake_up_process(ca-&gt;alloc_thread);</span>
 
 	trace_bcache_alloc(ca, reserve);
 
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index cd41f03b91c2..04d2fc7282f9 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -698,8 +698,16 @@</span> <span class="p_context"> static void cached_dev_read_error(struct closure *cl)</span>
 {
 	struct search *s = container_of(cl, struct search, cl);
 	struct bio *bio = &amp;s-&gt;bio.bio;
<span class="p_add">+	struct cached_dev *dc = container_of(s-&gt;d, struct cached_dev, disk);</span>
 
<span class="p_del">-	if (s-&gt;recoverable) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If cache device is dirty (dc-&gt;has_dirty is non-zero), then</span>
<span class="p_add">+	 * recovery a failed read request from cached device may get a</span>
<span class="p_add">+	 * stale data back. So read failure recovery is only permitted</span>
<span class="p_add">+	 * when cache device is clean.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (s-&gt;recoverable &amp;&amp;</span>
<span class="p_add">+	    (dc &amp;&amp; !atomic_read(&amp;dc-&gt;has_dirty))) {</span>
 		/* Retry from the backing device: */
 		trace_bcache_read_retry(s-&gt;orig_bio);
 
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index c0e44d210326..1c9e542e3161 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -888,7 +888,8 @@</span> <span class="p_context"> static void __get_memory_limit(struct dm_bufio_client *c,</span>
 		buffers = c-&gt;minimum_buffers;
 
 	*limit_buffers = buffers;
<span class="p_del">-	*threshold_buffers = buffers * DM_BUFIO_WRITEBACK_PERCENT / 100;</span>
<span class="p_add">+	*threshold_buffers = mult_frac(buffers,</span>
<span class="p_add">+				       DM_BUFIO_WRITEBACK_PERCENT, 100);</span>
 }
 
 /*
<span class="p_chunk">@@ -1778,19 +1779,15 @@</span> <span class="p_context"> static int __init dm_bufio_init(void)</span>
 	memset(&amp;dm_bufio_caches, 0, sizeof dm_bufio_caches);
 	memset(&amp;dm_bufio_cache_names, 0, sizeof dm_bufio_cache_names);
 
<span class="p_del">-	mem = (__u64)((totalram_pages - totalhigh_pages) *</span>
<span class="p_del">-		      DM_BUFIO_MEMORY_PERCENT / 100) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	mem = (__u64)mult_frac(totalram_pages - totalhigh_pages,</span>
<span class="p_add">+			       DM_BUFIO_MEMORY_PERCENT, 100) &lt;&lt; PAGE_SHIFT;</span>
 
 	if (mem &gt; ULONG_MAX)
 		mem = ULONG_MAX;
 
 #ifdef CONFIG_MMU
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get the size of vmalloc space the same way as VMALLOC_TOTAL</span>
<span class="p_del">-	 * in fs/proc/internal.h</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mem &gt; (VMALLOC_END - VMALLOC_START) * DM_BUFIO_VMALLOC_PERCENT / 100)</span>
<span class="p_del">-		mem = (VMALLOC_END - VMALLOC_START) * DM_BUFIO_VMALLOC_PERCENT / 100;</span>
<span class="p_add">+	if (mem &gt; mult_frac(VMALLOC_TOTAL, DM_BUFIO_VMALLOC_PERCENT, 100))</span>
<span class="p_add">+		mem = mult_frac(VMALLOC_TOTAL, DM_BUFIO_VMALLOC_PERCENT, 100);</span>
 #endif
 
 	dm_bufio_default_cache_size = mem;
<span class="p_header">diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c</span>
<span class="p_header">index c932b6b0d54c..f5f1837dfa5b 100644</span>
<span class="p_header">--- a/drivers/md/dm-table.c</span>
<span class="p_header">+++ b/drivers/md/dm-table.c</span>
<span class="p_chunk">@@ -1643,12 +1643,12 @@</span> <span class="p_context"> void dm_table_run_md_queue_async(struct dm_table *t)</span>
 }
 EXPORT_SYMBOL(dm_table_run_md_queue_async);
 
<span class="p_del">-static int device_discard_capable(struct dm_target *ti, struct dm_dev *dev,</span>
<span class="p_del">-				  sector_t start, sector_t len, void *data)</span>
<span class="p_add">+static int device_not_discard_capable(struct dm_target *ti, struct dm_dev *dev,</span>
<span class="p_add">+				      sector_t start, sector_t len, void *data)</span>
 {
 	struct request_queue *q = bdev_get_queue(dev-&gt;bdev);
 
<span class="p_del">-	return q &amp;&amp; blk_queue_discard(q);</span>
<span class="p_add">+	return q &amp;&amp; !blk_queue_discard(q);</span>
 }
 
 bool dm_table_supports_discards(struct dm_table *t)
<span class="p_chunk">@@ -1656,26 +1656,22 @@</span> <span class="p_context"> bool dm_table_supports_discards(struct dm_table *t)</span>
 	struct dm_target *ti;
 	unsigned i = 0;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Unless any target used by the table set discards_supported,</span>
<span class="p_del">-	 * require at least one underlying device to support discards.</span>
<span class="p_del">-	 * t-&gt;devices includes internal dm devices such as mirror logs</span>
<span class="p_del">-	 * so we need to use iterate_devices here, which targets</span>
<span class="p_del">-	 * supporting discard selectively must provide.</span>
<span class="p_del">-	 */</span>
 	while (i &lt; dm_table_get_num_targets(t)) {
 		ti = dm_table_get_target(t, i++);
 
 		if (!ti-&gt;num_discard_bios)
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (ti-&gt;discards_supported)</span>
<span class="p_del">-			return 1;</span>
<span class="p_add">+			return false;</span>
 
<span class="p_del">-		if (ti-&gt;type-&gt;iterate_devices &amp;&amp;</span>
<span class="p_del">-		    ti-&gt;type-&gt;iterate_devices(ti, device_discard_capable, NULL))</span>
<span class="p_del">-			return 1;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Either the target provides discard support (as implied by setting</span>
<span class="p_add">+		 * &#39;discards_supported&#39;) or it relies on _all_ data devices having</span>
<span class="p_add">+		 * discard support.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!ti-&gt;discards_supported &amp;&amp;</span>
<span class="p_add">+		    (!ti-&gt;type-&gt;iterate_devices ||</span>
<span class="p_add">+		     ti-&gt;type-&gt;iterate_devices(ti, device_not_discard_capable, NULL)))</span>
<span class="p_add">+			return false;</span>
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return true;</span>
 }
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 98a47dbf48c2..043ad8d8d700 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2912,11 +2912,15 @@</span> <span class="p_context"> struct mapped_device *dm_get_from_kobject(struct kobject *kobj)</span>
 
 	md = container_of(kobj, struct mapped_device, kobj_holder.kobj);
 
<span class="p_del">-	if (test_bit(DMF_FREEING, &amp;md-&gt;flags) ||</span>
<span class="p_del">-	    dm_deleting_md(md))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock(&amp;_minor_lock);</span>
<span class="p_add">+	if (test_bit(DMF_FREEING, &amp;md-&gt;flags) || dm_deleting_md(md)) {</span>
<span class="p_add">+		md = NULL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	dm_get(md);
<span class="p_add">+out:</span>
<span class="p_add">+	spin_unlock(&amp;_minor_lock);</span>
<span class="p_add">+</span>
 	return md;
 }
 
<span class="p_header">diff --git a/drivers/media/platform/omap/omap_vout.c b/drivers/media/platform/omap/omap_vout.c</span>
<span class="p_header">index 9a726eacb29b..af9bb7425b34 100644</span>
<span class="p_header">--- a/drivers/media/platform/omap/omap_vout.c</span>
<span class="p_header">+++ b/drivers/media/platform/omap/omap_vout.c</span>
<span class="p_chunk">@@ -1017,11 +1017,12 @@</span> <span class="p_context"> static int omap_vout_open(struct file *file)</span>
 	struct omap_vout_device *vout = NULL;
 
 	vout = video_drvdata(file);
<span class="p_del">-	v4l2_dbg(1, debug, &amp;vout-&gt;vid_dev-&gt;v4l2_dev, &quot;Entering %s\n&quot;, __func__);</span>
 
 	if (vout == NULL)
 		return -ENODEV;
 
<span class="p_add">+	v4l2_dbg(1, debug, &amp;vout-&gt;vid_dev-&gt;v4l2_dev, &quot;Entering %s\n&quot;, __func__);</span>
<span class="p_add">+</span>
 	/* for now, we only support single open */
 	if (vout-&gt;opened)
 		return -EBUSY;
<span class="p_header">diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">index 33d6c05352a2..a9c1c2eac2b1 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_chunk">@@ -289,11 +289,14 @@</span> <span class="p_context"> static long ir_lirc_ioctl(struct file *filep, unsigned int cmd,</span>
 		if (!dev-&gt;max_timeout)
 			return -ENOSYS;
 
<span class="p_add">+		/* Check for multiply overflow */</span>
<span class="p_add">+		if (val &gt; U32_MAX / 1000)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		tmp = val * 1000;
 
<span class="p_del">-		if (tmp &lt; dev-&gt;min_timeout ||</span>
<span class="p_del">-		    tmp &gt; dev-&gt;max_timeout)</span>
<span class="p_del">-				return -EINVAL;</span>
<span class="p_add">+		if (tmp &lt; dev-&gt;min_timeout || tmp &gt; dev-&gt;max_timeout)</span>
<span class="p_add">+			return -EINVAL;</span>
 
 		dev-&gt;timeout = tmp;
 		break;
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index 5cc7f9220d51..84b129e109ca 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -1185,8 +1185,7 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	dev-&gt;vbi_or_sliced_cc_mode = 0;
 
 	/* get maximum no.of IAD interfaces */
<span class="p_del">-	assoc_desc = udev-&gt;actconfig-&gt;intf_assoc[0];</span>
<span class="p_del">-	dev-&gt;max_iad_interface_count = assoc_desc-&gt;bInterfaceCount;</span>
<span class="p_add">+	dev-&gt;max_iad_interface_count = udev-&gt;config-&gt;desc.bNumInterfaces;</span>
 
 	/* init CIR module TBD */
 
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 529f42a8d7f8..857e6cc4a91e 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2466,15 +2466,18 @@</span> <span class="p_context"> static int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,</span>
 			    size_t *retlen, const uint8_t *buf)
 {
 	struct nand_chip *chip = mtd-&gt;priv;
<span class="p_add">+	int chipnr = (int)(to &gt;&gt; chip-&gt;chip_shift);</span>
 	struct mtd_oob_ops ops;
 	int ret;
 
<span class="p_del">-	/* Wait for the device to get ready */</span>
<span class="p_del">-	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_del">-</span>
 	/* Grab the device */
 	panic_nand_get_device(chip, mtd, FL_WRITING);
 
<span class="p_add">+	chip-&gt;select_chip(mtd, chipnr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the device to get ready */</span>
<span class="p_add">+	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_add">+</span>
 	ops.len = len;
 	ops.datbuf = (uint8_t *)buf;
 	ops.oobbuf = NULL;
<span class="p_header">diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c</span>
<span class="p_header">index 575a015c8394..6ffb1eab4344 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/omap2.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/omap2.c</span>
<span class="p_chunk">@@ -1163,130 +1163,174 @@</span> <span class="p_context"> static u8  bch8_polynomial[] = {0xef, 0x51, 0x2e, 0x09, 0xed, 0x93, 0x9a, 0xc2,</span>
 				0x97, 0x79, 0xe5, 0x24, 0xb5};
 
 /**
<span class="p_del">- * omap_calculate_ecc_bch - Generate bytes of ECC bytes</span>
<span class="p_add">+ * _omap_calculate_ecc_bch - Generate ECC bytes for one sector</span>
  * @mtd:	MTD device structure
  * @dat:	The pointer to data on which ecc is computed
  * @ecc_code:	The ecc_code buffer
<span class="p_add">+ * @i:		The sector number (for a multi sector page)</span>
  *
<span class="p_del">- * Support calculating of BCH4/8 ecc vectors for the page</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ECC vectors for one sector</span>
<span class="p_add">+ * within a page. Sector number is in @i.</span>
  */
<span class="p_del">-static int __maybe_unused omap_calculate_ecc_bch(struct mtd_info *mtd,</span>
<span class="p_del">-					const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+static int _omap_calculate_ecc_bch(struct mtd_info *mtd,</span>
<span class="p_add">+				   const u_char *dat, u_char *ecc_calc, int i)</span>
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 						   mtd);
 	int eccbytes	= info-&gt;nand.ecc.bytes;
 	struct gpmc_nand_regs	*gpmc_regs = &amp;info-&gt;reg;
 	u8 *ecc_code;
<span class="p_del">-	unsigned long nsectors, bch_val1, bch_val2, bch_val3, bch_val4;</span>
<span class="p_add">+	unsigned long bch_val1, bch_val2, bch_val3, bch_val4;</span>
 	u32 val;
<span class="p_del">-	int i, j;</span>
<span class="p_add">+	int j;</span>
<span class="p_add">+</span>
<span class="p_add">+	ecc_code = ecc_calc;</span>
<span class="p_add">+	switch (info-&gt;ecc_opt) {</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_add">+		bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		bch_val3 = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_add">+		bch_val4 = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_add">+		*ecc_code++ = (bch_val4 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val3 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val2 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val1 &amp; 0xFF);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_add">+		bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &amp; 0xF) &lt;&lt; 4) |</span>
<span class="p_add">+			((bch_val1 &gt;&gt; 28) &amp; 0xF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 20) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &amp; 0xF) &lt;&lt; 4);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result6[i]);</span>
<span class="p_add">+		ecc_code[0]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[1]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result5[i]);</span>
<span class="p_add">+		ecc_code[2]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[3]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[4]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[5]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result4[i]);</span>
<span class="p_add">+		ecc_code[6]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[7]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[8]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[9]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_add">+		ecc_code[10] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[11] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[12] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[13] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_add">+		ecc_code[14] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[15] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[16] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[17] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		ecc_code[18] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[19] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[20] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[21] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		ecc_code[22] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[23] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[24] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[25] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ECC scheme specific syndrome customizations */</span>
<span class="p_add">+	switch (info-&gt;ecc_opt) {</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+		/* Add constant polynomial to remainder, so that</span>
<span class="p_add">+		 * ECC of blank pages results in 0x0 on reading back</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_add">+			ecc_calc[j] ^= bch4_polynomial[j];</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_add">+		/* Set  8th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_add">+		ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+		/* Add constant polynomial to remainder, so that</span>
<span class="p_add">+		 * ECC of blank pages results in 0x0 on reading back</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_add">+			ecc_calc[j] ^= bch8_polynomial[j];</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_add">+		/* Set 14th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_add">+		ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_calculate_ecc_bch_sw - ECC generator for sector for SW based correction</span>
<span class="p_add">+ * @mtd:	MTD device structure</span>
<span class="p_add">+ * @dat:	The pointer to data on which ecc is computed</span>
<span class="p_add">+ * @ecc_code:	The ecc_code buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ECC vectors for one sector. This is used</span>
<span class="p_add">+ * when SW based correction is required as ECC is required for one sector</span>
<span class="p_add">+ * at a time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_calculate_ecc_bch_sw(struct mtd_info *mtd,</span>
<span class="p_add">+				     const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return _omap_calculate_ecc_bch(mtd, dat, ecc_calc, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_calculate_ecc_bch_multi - Generate ECC for multiple sectors</span>
<span class="p_add">+ * @mtd:	MTD device structure</span>
<span class="p_add">+ * @dat:	The pointer to data on which ecc is computed</span>
<span class="p_add">+ * @ecc_code:	The ecc_code buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ecc vectors for the entire page in one go.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_calculate_ecc_bch_multi(struct mtd_info *mtd,</span>
<span class="p_add">+					const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,</span>
<span class="p_add">+						   mtd);</span>
<span class="p_add">+	int eccbytes = info-&gt;nand.ecc.bytes;</span>
<span class="p_add">+	unsigned long nsectors;</span>
<span class="p_add">+	int i, ret;</span>
 
 	nsectors = ((readl(info-&gt;reg.gpmc_ecc_config) &gt;&gt; 4) &amp; 0x7) + 1;
 	for (i = 0; i &lt; nsectors; i++) {
<span class="p_del">-		ecc_code = ecc_calc;</span>
<span class="p_del">-		switch (info-&gt;ecc_opt) {</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_del">-			bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			bch_val3 = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_del">-			bch_val4 = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_del">-			*ecc_code++ = (bch_val4 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val3 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val2 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val1 &amp; 0xFF);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_del">-			bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &amp; 0xF) &lt;&lt; 4) |</span>
<span class="p_del">-				((bch_val1 &gt;&gt; 28) &amp; 0xF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 20) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &amp; 0xF) &lt;&lt; 4);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result6[i]);</span>
<span class="p_del">-			ecc_code[0]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[1]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result5[i]);</span>
<span class="p_del">-			ecc_code[2]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[3]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[4]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[5]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result4[i]);</span>
<span class="p_del">-			ecc_code[6]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[7]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[8]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[9]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_del">-			ecc_code[10] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[11] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[12] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[13] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_del">-			ecc_code[14] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[15] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[16] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[17] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			ecc_code[18] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[19] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[20] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[21] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			ecc_code[22] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[23] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[24] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[25] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ret = _omap_calculate_ecc_bch(mtd, dat, ecc_calc, i);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
 
<span class="p_del">-		/* ECC scheme specific syndrome customizations */</span>
<span class="p_del">-		switch (info-&gt;ecc_opt) {</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-			/* Add constant polynomial to remainder, so that</span>
<span class="p_del">-			 * ECC of blank pages results in 0x0 on reading back */</span>
<span class="p_del">-			for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_del">-				ecc_calc[j] ^= bch4_polynomial[j];</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_del">-			/* Set  8th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_del">-			ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-			/* Add constant polynomial to remainder, so that</span>
<span class="p_del">-			 * ECC of blank pages results in 0x0 on reading back */</span>
<span class="p_del">-			for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_del">-				ecc_calc[j] ^= bch8_polynomial[j];</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_del">-			/* Set 14th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_del">-			ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	ecc_calc += eccbytes;</span>
<span class="p_add">+		ecc_calc += eccbytes;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1527,7 +1571,7 @@</span> <span class="p_context"> static int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 	chip-&gt;write_buf(mtd, buf, mtd-&gt;writesize);
 
 	/* Update ecc vector from GPMC result registers */
<span class="p_del">-	chip-&gt;ecc.calculate(mtd, buf, &amp;ecc_calc[0]);</span>
<span class="p_add">+	omap_calculate_ecc_bch_multi(mtd, buf, &amp;ecc_calc[0]);</span>
 
 	for (i = 0; i &lt; chip-&gt;ecc.total; i++)
 		chip-&gt;oob_poi[eccpos[i]] = ecc_calc[i];
<span class="p_chunk">@@ -1537,6 +1581,72 @@</span> <span class="p_context"> static int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 	return 0;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_write_subpage_bch - BCH hardware ECC based subpage write</span>
<span class="p_add">+ * @mtd:	mtd info structure</span>
<span class="p_add">+ * @chip:	nand chip info structure</span>
<span class="p_add">+ * @offset:	column address of subpage within the page</span>
<span class="p_add">+ * @data_len:	data length</span>
<span class="p_add">+ * @buf:	data buffer</span>
<span class="p_add">+ * @oob_required: must write chip-&gt;oob_poi to OOB</span>
<span class="p_add">+ * @page: page number to write</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * OMAP optimized subpage write method.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_write_subpage_bch(struct mtd_info *mtd,</span>
<span class="p_add">+				  struct nand_chip *chip, u32 offset,</span>
<span class="p_add">+				  u32 data_len, const u8 *buf,</span>
<span class="p_add">+				  int oob_required, int page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *ecc_calc = chip-&gt;buffers-&gt;ecccalc;</span>
<span class="p_add">+	int ecc_size      = chip-&gt;ecc.size;</span>
<span class="p_add">+	int ecc_bytes     = chip-&gt;ecc.bytes;</span>
<span class="p_add">+	int ecc_steps     = chip-&gt;ecc.steps;</span>
<span class="p_add">+	u32 start_step = offset / ecc_size;</span>
<span class="p_add">+	u32 end_step   = (offset + data_len - 1) / ecc_size;</span>
<span class="p_add">+	int step, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write entire page at one go as it would be optimal</span>
<span class="p_add">+	 * as ECC is calculated by hardware.</span>
<span class="p_add">+	 * ECC is calculated for all subpages but we choose</span>
<span class="p_add">+	 * only what we want.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable GPMC ECC engine */</span>
<span class="p_add">+	chip-&gt;ecc.hwctl(mtd, NAND_ECC_WRITE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Write data */</span>
<span class="p_add">+	chip-&gt;write_buf(mtd, buf, mtd-&gt;writesize);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (step = 0; step &lt; ecc_steps; step++) {</span>
<span class="p_add">+		/* mask ECC of un-touched subpages by padding 0xFF */</span>
<span class="p_add">+		if (step &lt; start_step || step &gt; end_step)</span>
<span class="p_add">+			memset(ecc_calc, 0xff, ecc_bytes);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = _omap_calculate_ecc_bch(mtd, buf, ecc_calc, step);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += ecc_size;</span>
<span class="p_add">+		ecc_calc += ecc_bytes;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* copy calculated ECC for whole page to chip-&gt;buffer-&gt;oob */</span>
<span class="p_add">+	/* this include masked-value(0xFF) for unwritten subpages */</span>
<span class="p_add">+	ecc_calc = chip-&gt;buffers-&gt;ecccalc;</span>
<span class="p_add">+	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip-&gt;oob_poi, 0,</span>
<span class="p_add">+					 chip-&gt;ecc.total);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* write OOB buffer to NAND device */</span>
<span class="p_add">+	chip-&gt;write_buf(mtd, chip-&gt;oob_poi, mtd-&gt;oobsize);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * omap_read_page_bch - BCH ecc based page read function for entire page
  * @mtd:		mtd info structure
<span class="p_chunk">@@ -1574,7 +1684,7 @@</span> <span class="p_context"> static int omap_read_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 	chip-&gt;read_buf(mtd, oob, chip-&gt;ecc.total);
 
 	/* Calculate ecc bytes */
<span class="p_del">-	chip-&gt;ecc.calculate(mtd, buf, ecc_calc);</span>
<span class="p_add">+	omap_calculate_ecc_bch_multi(mtd, buf, ecc_calc);</span>
 
 	memcpy(ecc_code, &amp;chip-&gt;oob_poi[eccpos[0]], chip-&gt;ecc.total);
 
<span class="p_chunk">@@ -1823,7 +1933,7 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 4;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= nand_bch_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
<span class="p_add">+		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch_sw;</span>
 		/* define ECC layout */
 		ecclayout-&gt;eccbytes		= nand_chip-&gt;ecc.bytes *
 							(mtd-&gt;writesize /
<span class="p_chunk">@@ -1863,9 +1973,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 4;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		/* define ECC layout */
 		ecclayout-&gt;eccbytes		= nand_chip-&gt;ecc.bytes *
 							(mtd-&gt;writesize /
<span class="p_chunk">@@ -1898,7 +2008,7 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 8;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= nand_bch_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
<span class="p_add">+		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch_sw;</span>
 		/* define ECC layout */
 		ecclayout-&gt;eccbytes		= nand_chip-&gt;ecc.bytes *
 							(mtd-&gt;writesize /
<span class="p_chunk">@@ -1939,9 +2049,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 8;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		/* This ECC scheme requires ELM H/W block */
 		err = is_elm_present(info, pdata-&gt;elm_of_node, BCH8_ECC);
 		if (err &lt; 0) {
<span class="p_chunk">@@ -1974,9 +2084,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 16;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		/* This ECC scheme requires ELM H/W block */
 		err = is_elm_present(info, pdata-&gt;elm_of_node, BCH16_ECC);
 		if (err &lt; 0) {
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">index f22654e2060d..eb99d65f87f3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_chunk">@@ -1509,12 +1509,8 @@</span> <span class="p_context"> static void bcmgenet_free_rx_buffers(struct bcmgenet_priv *priv)</span>
 	}
 }
 
<span class="p_del">-static int reset_umac(struct bcmgenet_priv *priv)</span>
<span class="p_add">+static void reset_umac(struct bcmgenet_priv *priv)</span>
 {
<span class="p_del">-	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
<span class="p_del">-	unsigned int timeout = 0;</span>
<span class="p_del">-	u32 reg;</span>
<span class="p_del">-</span>
 	/* 7358a0/7552a0: bad default in RBUF_FLUSH_CTRL.umac_sw_rst */
 	bcmgenet_rbuf_ctrl_set(priv, 0);
 	udelay(10);
<span class="p_chunk">@@ -1522,38 +1518,21 @@</span> <span class="p_context"> static int reset_umac(struct bcmgenet_priv *priv)</span>
 	/* disable MAC while updating its registers */
 	bcmgenet_umac_writel(priv, 0, UMAC_CMD);
 
<span class="p_del">-	/* issue soft reset, wait for it to complete */</span>
<span class="p_del">-	bcmgenet_umac_writel(priv, CMD_SW_RESET, UMAC_CMD);</span>
<span class="p_del">-	while (timeout++ &lt; 1000) {</span>
<span class="p_del">-		reg = bcmgenet_umac_readl(priv, UMAC_CMD);</span>
<span class="p_del">-		if (!(reg &amp; CMD_SW_RESET))</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		udelay(1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (timeout == 1000) {</span>
<span class="p_del">-		dev_err(kdev,</span>
<span class="p_del">-			&quot;timeout waiting for MAC to come out of resetn\n&quot;);</span>
<span class="p_del">-		return -ETIMEDOUT;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	/* issue soft reset with (rg)mii loopback to ensure a stable rxclk */</span>
<span class="p_add">+	bcmgenet_umac_writel(priv, CMD_SW_RESET | CMD_LCL_LOOP_EN, UMAC_CMD);</span>
<span class="p_add">+	udelay(2);</span>
<span class="p_add">+	bcmgenet_umac_writel(priv, 0, UMAC_CMD);</span>
 }
 
<span class="p_del">-static int init_umac(struct bcmgenet_priv *priv)</span>
<span class="p_add">+static void init_umac(struct bcmgenet_priv *priv)</span>
 {
 	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;
<span class="p_del">-	int ret;</span>
 	u32 reg, cpu_mask_clear;
 
 	dev_dbg(&amp;priv-&gt;pdev-&gt;dev, &quot;bcmgenet: init_umac\n&quot;);
 
<span class="p_del">-	ret = reset_umac(priv);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	reset_umac(priv);</span>
 
<span class="p_del">-	bcmgenet_umac_writel(priv, 0, UMAC_CMD);</span>
 	/* clear tx/rx counter */
 	bcmgenet_umac_writel(priv,
 		MIB_RESET_RX | MIB_RESET_TX | MIB_RESET_RUNT, UMAC_MIB_CTRL);
<span class="p_chunk">@@ -1604,8 +1583,6 @@</span> <span class="p_context"> static int init_umac(struct bcmgenet_priv *priv)</span>
 
 	/* Enable rx/tx engine.*/
 	dev_dbg(kdev, &quot;done init umac\n&quot;);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 /* Initialize all house-keeping variables for a TX ring, along
<span class="p_chunk">@@ -1994,14 +1971,10 @@</span> <span class="p_context"> static void bcmgenet_set_hw_addr(struct bcmgenet_priv *priv,</span>
 
 static int bcmgenet_wol_resume(struct bcmgenet_priv *priv)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
 	/* From WOL-enabled suspend, switch to regular clock */
 	clk_disable(priv-&gt;clk_wol);
 	/* init umac registers to synchronize s/w with h/w */
<span class="p_del">-	ret = init_umac(priv);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	init_umac(priv);</span>
 
 	phy_init_hw(priv-&gt;phydev);
 	/* Speed settings must be restored */
<span class="p_chunk">@@ -2062,14 +2035,7 @@</span> <span class="p_context"> static int bcmgenet_open(struct net_device *dev)</span>
 	/* take MAC out of reset */
 	bcmgenet_umac_reset(priv);
 
<span class="p_del">-	ret = init_umac(priv);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto err_clk_disable;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* disable ethernet MAC while updating its registers */</span>
<span class="p_del">-	reg = bcmgenet_umac_readl(priv, UMAC_CMD);</span>
<span class="p_del">-	reg &amp;= ~(CMD_TX_EN | CMD_RX_EN);</span>
<span class="p_del">-	bcmgenet_umac_writel(priv, reg, UMAC_CMD);</span>
<span class="p_add">+	init_umac(priv);</span>
 
 	bcmgenet_set_hw_addr(priv, dev-&gt;dev_addr);
 
<span class="p_chunk">@@ -2603,9 +2569,7 @@</span> <span class="p_context"> static int bcmgenet_probe(struct platform_device *pdev)</span>
 	    !strcasecmp(phy_mode_str, &quot;internal&quot;))
 		bcmgenet_power_up(priv, GENET_POWER_PASSIVE);
 
<span class="p_del">-	err = reset_umac(priv);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto err_clk_disable;</span>
<span class="p_add">+	reset_umac(priv);</span>
 
 	err = bcmgenet_mii_init(dev);
 	if (err)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index fd388cc8c22e..01254f25f9fc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -3047,7 +3047,7 @@</span> <span class="p_context"> static bool i40e_clean_fdir_tx_irq(struct i40e_ring *tx_ring, int budget)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if the descriptor isn&#39;t done, no work yet to do */
 		if (!(eop_desc-&gt;cmd_type_offset_bsz &amp;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">index 7b1be746dd30..63090f461b7a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_chunk">@@ -657,7 +657,7 @@</span> <span class="p_context"> static bool i40e_clean_tx_irq(struct i40e_ring *tx_ring, int budget)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* we have caught up to head, no work left to do */
 		if (tx_head == tx_desc)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_header">index 48ebb6cd69f2..7e9a54fe5ab5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static bool i40e_clean_tx_irq(struct i40e_ring *tx_ring, int budget)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* we have caught up to head, no work left to do */
 		if (tx_head == tx_desc)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index b844902d12a0..905328f3db86 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -6360,7 +6360,7 @@</span> <span class="p_context"> static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(E1000_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igbvf/netdev.c b/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_header">index d608599e123a..296559052d45 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_chunk">@@ -808,7 +808,7 @@</span> <span class="p_context"> static bool igbvf_clean_tx_irq(struct igbvf_ring *tx_ring)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(E1000_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index a125d3c35856..1d1af2e62811 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -1086,7 +1086,7 @@</span> <span class="p_context"> static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">index e626b73ca00e..c932436c6a47 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> static bool ixgbevf_clean_tx_irq(struct ixgbevf_q_vector *q_vector,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/wireless/p54/main.c b/drivers/net/wireless/p54/main.c</span>
<span class="p_header">index 7be3a4839640..1084e1d04279 100644</span>
<span class="p_header">--- a/drivers/net/wireless/p54/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/p54/main.c</span>
<span class="p_chunk">@@ -851,12 +851,11 @@</span> <span class="p_context"> void p54_unregister_common(struct ieee80211_hw *dev)</span>
 {
 	struct p54_common *priv = dev-&gt;priv;
 
<span class="p_del">-#ifdef CONFIG_P54_LEDS</span>
<span class="p_del">-	p54_unregister_leds(priv);</span>
<span class="p_del">-#endif /* CONFIG_P54_LEDS */</span>
<span class="p_del">-</span>
 	if (priv-&gt;registered) {
 		priv-&gt;registered = false;
<span class="p_add">+#ifdef CONFIG_P54_LEDS</span>
<span class="p_add">+		p54_unregister_leds(priv);</span>
<span class="p_add">+#endif /* CONFIG_P54_LEDS */</span>
 		ieee80211_unregister_hw(dev);
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/rt2x00/rt2x00usb.c b/drivers/net/wireless/rt2x00/rt2x00usb.c</span>
<span class="p_header">index 86c43d112a4b..b949116a472e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rt2x00/rt2x00usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rt2x00/rt2x00usb.c</span>
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> int rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,</span>
 		 * -ENODEV: Device has disappeared, no point continuing.
 		 * All other errors: Try again.
 		 */
<span class="p_del">-		else if (status == -ENODEV) {</span>
<span class="p_add">+		else if (status == -ENODEV || status == -ENOENT) {</span>
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 			break;
 		}
<span class="p_chunk">@@ -325,7 +325,7 @@</span> <span class="p_context"> static bool rt2x00usb_kick_tx_entry(struct queue_entry *entry, void *data)</span>
 
 	status = usb_submit_urb(entry_priv-&gt;urb, GFP_ATOMIC);
 	if (status) {
<span class="p_del">-		if (status == -ENODEV)</span>
<span class="p_add">+		if (status == -ENODEV || status == -ENOENT)</span>
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 		set_bit(ENTRY_DATA_IO_FAILED, &amp;entry-&gt;flags);
 		rt2x00lib_dmadone(entry);
<span class="p_chunk">@@ -414,7 +414,7 @@</span> <span class="p_context"> static bool rt2x00usb_kick_rx_entry(struct queue_entry *entry, void *data)</span>
 
 	status = usb_submit_urb(entry_priv-&gt;urb, GFP_ATOMIC);
 	if (status) {
<span class="p_del">-		if (status == -ENODEV)</span>
<span class="p_add">+		if (status == -ENODEV || status == -ENOENT)</span>
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 		set_bit(ENTRY_DATA_IO_FAILED, &amp;entry-&gt;flags);
 		rt2x00lib_dmadone(entry);
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">index b60a325234c5..cca4b4789ac4 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_chunk">@@ -360,7 +360,14 @@</span> <span class="p_context"> static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,</span>
 		 * If the error is reported by an end point, we think this
 		 * error is related to the upstream link of the end point.
 		 */
<span class="p_del">-		pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
<span class="p_add">+		if (state == pci_channel_io_normal)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * the error is non fatal so the bus is ok, just invoke</span>
<span class="p_add">+			 * the callback for the function that logged the error.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cb(dev, &amp;result_data);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
 	}
 
 	return result_data.result;
<span class="p_header">diff --git a/drivers/platform/x86/sony-laptop.c b/drivers/platform/x86/sony-laptop.c</span>
<span class="p_header">index 9c5a07417b2b..e7ff8152ef2b 100644</span>
<span class="p_header">--- a/drivers/platform/x86/sony-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/sony-laptop.c</span>
<span class="p_chunk">@@ -1654,17 +1654,19 @@</span> <span class="p_context"> static int sony_nc_setup_rfkill(struct acpi_device *device,</span>
 	if (!rfk)
 		return -ENOMEM;
 
<span class="p_del">-	if (sony_call_snc_handle(sony_rfkill_handle, 0x200, &amp;result) &lt; 0) {</span>
<span class="p_add">+	err = sony_call_snc_handle(sony_rfkill_handle, 0x200, &amp;result);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		rfkill_destroy(rfk);
<span class="p_del">-		return -1;</span>
<span class="p_add">+		return err;</span>
 	}
 	hwblock = !(result &amp; 0x1);
 
<span class="p_del">-	if (sony_call_snc_handle(sony_rfkill_handle,</span>
<span class="p_del">-				sony_rfkill_address[nc_type],</span>
<span class="p_del">-				&amp;result) &lt; 0) {</span>
<span class="p_add">+	err = sony_call_snc_handle(sony_rfkill_handle,</span>
<span class="p_add">+				   sony_rfkill_address[nc_type],</span>
<span class="p_add">+				   &amp;result);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		rfkill_destroy(rfk);
<span class="p_del">-		return -1;</span>
<span class="p_add">+		return err;</span>
 	}
 	swblock = !(result &amp; 0x2);
 
<span class="p_header">diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c</span>
<span class="p_header">index 5813fa52c3d4..05eeeb537ff8 100644</span>
<span class="p_header">--- a/drivers/rtc/interface.c</span>
<span class="p_header">+++ b/drivers/rtc/interface.c</span>
<span class="p_chunk">@@ -778,9 +778,23 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(rtc_irq_set_freq);</span>
  */
 static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)
 {
<span class="p_add">+	struct timerqueue_node *next = timerqueue_getnext(&amp;rtc-&gt;timerqueue);</span>
<span class="p_add">+	struct rtc_time tm;</span>
<span class="p_add">+	ktime_t now;</span>
<span class="p_add">+</span>
 	timer-&gt;enabled = 1;
<span class="p_add">+	__rtc_read_time(rtc, &amp;tm);</span>
<span class="p_add">+	now = rtc_tm_to_ktime(tm);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Skip over expired timers */</span>
<span class="p_add">+	while (next) {</span>
<span class="p_add">+		if (next-&gt;expires.tv64 &gt;= now.tv64)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		next = timerqueue_iterate_next(next);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	timerqueue_add(&amp;rtc-&gt;timerqueue, &amp;timer-&gt;node);
<span class="p_del">-	if (&amp;timer-&gt;node == timerqueue_getnext(&amp;rtc-&gt;timerqueue)) {</span>
<span class="p_add">+	if (!next || ktime_before(timer-&gt;node.expires, next-&gt;expires)) {</span>
 		struct rtc_wkalrm alarm;
 		int err;
 		alarm.time = rtc_ktime_to_tm(timer-&gt;node.expires);
<span class="p_header">diff --git a/drivers/scsi/bfa/bfad_debugfs.c b/drivers/scsi/bfa/bfad_debugfs.c</span>
<span class="p_header">index 8e83d0474fe7..996f3170a7ab 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfad_debugfs.c</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfad_debugfs.c</span>
<span class="p_chunk">@@ -254,7 +254,8 @@</span> <span class="p_context"> bfad_debugfs_write_regrd(struct file *file, const char __user *buf,</span>
 	struct bfad_s *bfad = port-&gt;bfad;
 	struct bfa_s *bfa = &amp;bfad-&gt;bfa;
 	struct bfa_ioc_s *ioc = &amp;bfa-&gt;ioc;
<span class="p_del">-	int addr, len, rc, i;</span>
<span class="p_add">+	int addr, rc, i;</span>
<span class="p_add">+	u32 len;</span>
 	u32 *regbuf;
 	void __iomem *rb, *reg_addr;
 	unsigned long flags;
<span class="p_chunk">@@ -274,7 +275,7 @@</span> <span class="p_context"> bfad_debugfs_write_regrd(struct file *file, const char __user *buf,</span>
 	}
 
 	rc = sscanf(kern_buf, &quot;%x:%x&quot;, &amp;addr, &amp;len);
<span class="p_del">-	if (rc &lt; 2) {</span>
<span class="p_add">+	if (rc &lt; 2 || len &gt; (UINT_MAX &gt;&gt; 2)) {</span>
 		printk(KERN_INFO
 			&quot;bfad[%d]: %s failed to read user buf\n&quot;,
 			bfad-&gt;inst_no, __func__);
<span class="p_header">diff --git a/drivers/staging/android/ashmem.c b/drivers/staging/android/ashmem.c</span>
<span class="p_header">index 713a97226787..be2958f0ce28 100644</span>
<span class="p_header">--- a/drivers/staging/android/ashmem.c</span>
<span class="p_header">+++ b/drivers/staging/android/ashmem.c</span>
<span class="p_chunk">@@ -758,10 +758,12 @@</span> <span class="p_context"> static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 		break;
 	case ASHMEM_SET_SIZE:
 		ret = -EINVAL;
<span class="p_add">+		mutex_lock(&amp;ashmem_mutex);</span>
 		if (!asma-&gt;file) {
 			ret = 0;
 			asma-&gt;size = (size_t) arg;
 		}
<span class="p_add">+		mutex_unlock(&amp;ashmem_mutex);</span>
 		break;
 	case ASHMEM_GET_SIZE:
 		ret = asma-&gt;size;
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/ptlrpc/sec.c b/drivers/staging/lustre/lustre/ptlrpc/sec.c</span>
<span class="p_header">index 28ac824a73fb..1961de7934e2 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/ptlrpc/sec.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/ptlrpc/sec.c</span>
<span class="p_chunk">@@ -867,7 +867,7 @@</span> <span class="p_context"> void sptlrpc_request_out_callback(struct ptlrpc_request *req)</span>
 	if (req-&gt;rq_pool || !req-&gt;rq_reqbuf)
 		return;
 
<span class="p_del">-	OBD_FREE(req-&gt;rq_reqbuf, req-&gt;rq_reqbuf_len);</span>
<span class="p_add">+	OBD_FREE_LARGE(req-&gt;rq_reqbuf, req-&gt;rq_reqbuf_len);</span>
 	req-&gt;rq_reqbuf = NULL;
 	req-&gt;rq_reqbuf_len = 0;
 }
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_mlme.c b/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_header">index 155282ef78fb..6412e2e759a8 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_mlme.c</span>
<span class="p_chunk">@@ -120,9 +120,8 @@</span> <span class="p_context"> void rtw_free_mlme_priv_ie_data(struct mlme_priv *pmlmepriv)</span>
 
 void _rtw_free_mlme_priv(struct mlme_priv *pmlmepriv)
 {
<span class="p_del">-	rtw_free_mlme_priv_ie_data(pmlmepriv);</span>
<span class="p_del">-</span>
 	if (pmlmepriv) {
<span class="p_add">+		rtw_free_mlme_priv_ie_data(pmlmepriv);</span>
 		if (pmlmepriv-&gt;free_bss_buf)
 			vfree(pmlmepriv-&gt;free_bss_buf);
 	}
<span class="p_header">diff --git a/drivers/staging/usbip/stub.h b/drivers/staging/usbip/stub.h</span>
<span class="p_header">index 266e2b0ce9a8..910f027773aa 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub.h</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub.h</span>
<span class="p_chunk">@@ -33,7 +33,6 @@</span> <span class="p_context"></span>
 #define STUB_BUSID_ALLOC 3
 
 struct stub_device {
<span class="p_del">-	struct usb_interface *interface;</span>
 	struct usb_device *udev;
 
 	struct usbip_device ud;
<span class="p_header">diff --git a/drivers/staging/usbip/stub_dev.c b/drivers/staging/usbip/stub_dev.c</span>
<span class="p_header">index 51d0c7188738..2107aed62ebd 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub_dev.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub_dev.c</span>
<span class="p_chunk">@@ -246,7 +246,7 @@</span> <span class="p_context"> static void stub_device_reset(struct usbip_device *ud)</span>
 
 	dev_dbg(&amp;udev-&gt;dev, &quot;device reset&quot;);
 
<span class="p_del">-	ret = usb_lock_device_for_reset(udev, sdev-&gt;interface);</span>
<span class="p_add">+	ret = usb_lock_device_for_reset(udev, NULL);</span>
 	if (ret &lt; 0) {
 		dev_err(&amp;udev-&gt;dev, &quot;lock for reset\n&quot;);
 		spin_lock_irq(&amp;ud-&gt;lock);
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static void stub_device_unusable(struct usbip_device *ud)</span>
 
 /**
  * stub_device_alloc - allocate a new stub_device struct
<span class="p_del">- * @interface: usb_interface of a new device</span>
<span class="p_add">+ * @udev: usb_device of a new device</span>
  *
  * Allocates and initializes a new stub_device struct.
  */
<span class="p_header">diff --git a/drivers/staging/usbip/stub_rx.c b/drivers/staging/usbip/stub_rx.c</span>
<span class="p_header">index e0b6d6b42728..35f59747122a 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub_rx.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub_rx.c</span>
<span class="p_chunk">@@ -165,12 +165,7 @@</span> <span class="p_context"> static int tweak_reset_device_cmd(struct urb *urb)</span>
 
 	dev_info(&amp;urb-&gt;dev-&gt;dev, &quot;usb_queue_reset_device\n&quot;);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * With the implementation of pre_reset and post_reset the driver no</span>
<span class="p_del">-	 * longer unbinds. This allows the use of synchronous reset.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	if (usb_lock_device_for_reset(sdev-&gt;udev, sdev-&gt;interface) &lt; 0) {</span>
<span class="p_add">+	if (usb_lock_device_for_reset(sdev-&gt;udev, NULL) &lt; 0) {</span>
 		dev_err(&amp;urb-&gt;dev-&gt;dev, &quot;could not obtain lock to reset device\n&quot;);
 		return 0;
 	}
<span class="p_chunk">@@ -321,7 +316,7 @@</span> <span class="p_context"> static struct stub_priv *stub_priv_alloc(struct stub_device *sdev,</span>
 
 	priv = kmem_cache_zalloc(stub_priv_cache, GFP_ATOMIC);
 	if (!priv) {
<span class="p_del">-		dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;alloc stub_priv\n&quot;);</span>
<span class="p_add">+		dev_err(&amp;sdev-&gt;udev-&gt;dev, &quot;alloc stub_priv\n&quot;);</span>
 		spin_unlock_irqrestore(&amp;sdev-&gt;priv_lock, flags);
 		usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
 		return NULL;
<span class="p_chunk">@@ -341,23 +336,34 @@</span> <span class="p_context"> static struct stub_priv *stub_priv_alloc(struct stub_device *sdev,</span>
 	return priv;
 }
 
<span class="p_del">-static int get_pipe(struct stub_device *sdev, int epnum, int dir)</span>
<span class="p_add">+static int get_pipe(struct stub_device *sdev, struct usbip_header *pdu)</span>
 {
 	struct usb_device *udev = sdev-&gt;udev;
 	struct usb_host_endpoint *ep;
 	struct usb_endpoint_descriptor *epd = NULL;
<span class="p_add">+	int epnum = pdu-&gt;base.ep;</span>
<span class="p_add">+	int dir = pdu-&gt;base.direction;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (epnum &lt; 0 || epnum &gt; 15)</span>
<span class="p_add">+		goto err_ret;</span>
 
 	if (dir == USBIP_DIR_IN)
 		ep = udev-&gt;ep_in[epnum &amp; 0x7f];
 	else
 		ep = udev-&gt;ep_out[epnum &amp; 0x7f];
<span class="p_del">-	if (!ep) {</span>
<span class="p_del">-		dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;no such endpoint?, %d\n&quot;,</span>
<span class="p_del">-			epnum);</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!ep)</span>
<span class="p_add">+		goto err_ret;</span>
 
 	epd = &amp;ep-&gt;desc;
<span class="p_add">+</span>
<span class="p_add">+	/* validate transfer_buffer_length */</span>
<span class="p_add">+	if (pdu-&gt;u.cmd_submit.transfer_buffer_length &gt; INT_MAX) {</span>
<span class="p_add">+		dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
<span class="p_add">+			&quot;CMD_SUBMIT: -EMSGSIZE transfer_buffer_length %d\n&quot;,</span>
<span class="p_add">+			pdu-&gt;u.cmd_submit.transfer_buffer_length);</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (usb_endpoint_xfer_control(epd)) {
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndctrlpipe(udev, epnum);
<span class="p_chunk">@@ -380,15 +386,31 @@</span> <span class="p_context"> static int get_pipe(struct stub_device *sdev, int epnum, int dir)</span>
 	}
 
 	if (usb_endpoint_xfer_isoc(epd)) {
<span class="p_add">+		/* validate packet size and number of packets */</span>
<span class="p_add">+		unsigned int maxp, packets, bytes;</span>
<span class="p_add">+</span>
<span class="p_add">+		maxp = usb_endpoint_maxp(epd);</span>
<span class="p_add">+		maxp *= usb_endpoint_maxp_mult(epd);</span>
<span class="p_add">+		bytes = pdu-&gt;u.cmd_submit.transfer_buffer_length;</span>
<span class="p_add">+		packets = DIV_ROUND_UP(bytes, maxp);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pdu-&gt;u.cmd_submit.number_of_packets &lt; 0 ||</span>
<span class="p_add">+		    pdu-&gt;u.cmd_submit.number_of_packets &gt; packets) {</span>
<span class="p_add">+			dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
<span class="p_add">+				&quot;CMD_SUBMIT: isoc invalid num packets %d\n&quot;,</span>
<span class="p_add">+				pdu-&gt;u.cmd_submit.number_of_packets);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
 		if (dir == USBIP_DIR_OUT)
 			return usb_sndisocpipe(udev, epnum);
 		else
 			return usb_rcvisocpipe(udev, epnum);
 	}
 
<span class="p_add">+err_ret:</span>
 	/* NOT REACHED */
<span class="p_del">-	dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;get pipe, epnum %d\n&quot;, epnum);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	dev_err(&amp;sdev-&gt;udev-&gt;dev, &quot;CMD_SUBMIT: invalid epnum %d\n&quot;, epnum);</span>
<span class="p_add">+	return -1;</span>
 }
 
 static void masking_bogus_flags(struct urb *urb)
<span class="p_chunk">@@ -452,7 +474,10 @@</span> <span class="p_context"> static void stub_recv_cmd_submit(struct stub_device *sdev,</span>
 	struct stub_priv *priv;
 	struct usbip_device *ud = &amp;sdev-&gt;ud;
 	struct usb_device *udev = sdev-&gt;udev;
<span class="p_del">-	int pipe = get_pipe(sdev, pdu-&gt;base.ep, pdu-&gt;base.direction);</span>
<span class="p_add">+	int pipe = get_pipe(sdev, pdu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pipe == -1)</span>
<span class="p_add">+		return;</span>
 
 	priv = stub_priv_alloc(sdev, pdu);
 	if (!priv)
<span class="p_chunk">@@ -466,13 +491,14 @@</span> <span class="p_context"> static void stub_recv_cmd_submit(struct stub_device *sdev,</span>
 		priv-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);
 
 	if (!priv-&gt;urb) {
<span class="p_del">-		dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;malloc urb\n&quot;);</span>
<span class="p_add">+		dev_err(&amp;udev-&gt;dev, &quot;malloc urb\n&quot;);</span>
 		usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
 		return;
 	}
 
 	/* allocate urb transfer buffer, if needed */
<span class="p_del">-	if (pdu-&gt;u.cmd_submit.transfer_buffer_length &gt; 0) {</span>
<span class="p_add">+	if (pdu-&gt;u.cmd_submit.transfer_buffer_length &gt; 0 &amp;&amp;</span>
<span class="p_add">+	    pdu-&gt;u.cmd_submit.transfer_buffer_length &lt;= INT_MAX) {</span>
 		priv-&gt;urb-&gt;transfer_buffer =
 			kzalloc(pdu-&gt;u.cmd_submit.transfer_buffer_length,
 				GFP_KERNEL);
<span class="p_chunk">@@ -486,7 +512,7 @@</span> <span class="p_context"> static void stub_recv_cmd_submit(struct stub_device *sdev,</span>
 	priv-&gt;urb-&gt;setup_packet = kmemdup(&amp;pdu-&gt;u.cmd_submit.setup, 8,
 					  GFP_KERNEL);
 	if (!priv-&gt;urb-&gt;setup_packet) {
<span class="p_del">-		dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;allocate setup_packet\n&quot;);</span>
<span class="p_add">+		dev_err(&amp;udev-&gt;dev, &quot;allocate setup_packet\n&quot;);</span>
 		usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);
 		return;
 	}
<span class="p_chunk">@@ -517,7 +543,7 @@</span> <span class="p_context"> static void stub_recv_cmd_submit(struct stub_device *sdev,</span>
 		usbip_dbg_stub_rx(&quot;submit urb ok, seqnum %u\n&quot;,
 				  pdu-&gt;base.seqnum);
 	else {
<span class="p_del">-		dev_err(&amp;sdev-&gt;interface-&gt;dev, &quot;submit_urb error, %d\n&quot;, ret);</span>
<span class="p_add">+		dev_err(&amp;udev-&gt;dev, &quot;submit_urb error, %d\n&quot;, ret);</span>
 		usbip_dump_header(pdu);
 		usbip_dump_urb(priv-&gt;urb);
 
<span class="p_header">diff --git a/drivers/staging/usbip/stub_tx.c b/drivers/staging/usbip/stub_tx.c</span>
<span class="p_header">index 021003c4de53..28760119629f 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/stub_tx.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/stub_tx.c</span>
<span class="p_chunk">@@ -178,6 +178,13 @@</span> <span class="p_context"> static int stub_send_ret_submit(struct stub_device *sdev)</span>
 		memset(&amp;pdu_header, 0, sizeof(pdu_header));
 		memset(&amp;msg, 0, sizeof(msg));
 
<span class="p_add">+		if (urb-&gt;actual_length &gt; 0 &amp;&amp; !urb-&gt;transfer_buffer) {</span>
<span class="p_add">+			dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
<span class="p_add">+				&quot;urb: actual_length %d transfer_buffer null\n&quot;,</span>
<span class="p_add">+				urb-&gt;actual_length);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
 			iovnum = 2 + urb-&gt;number_of_packets;
 		else
<span class="p_chunk">@@ -233,7 +240,7 @@</span> <span class="p_context"> static int stub_send_ret_submit(struct stub_device *sdev)</span>
 			}
 
 			if (txsize != sizeof(pdu_header) + urb-&gt;actual_length) {
<span class="p_del">-				dev_err(&amp;sdev-&gt;interface-&gt;dev,</span>
<span class="p_add">+				dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
 					&quot;actual length of urb %d does not match iso packet sizes %zu\n&quot;,
 					urb-&gt;actual_length,
 					txsize-sizeof(pdu_header));
<span class="p_chunk">@@ -265,7 +272,7 @@</span> <span class="p_context"> static int stub_send_ret_submit(struct stub_device *sdev)</span>
 		ret = kernel_sendmsg(sdev-&gt;ud.tcp_socket, &amp;msg,
 						iov,  iovnum, txsize);
 		if (ret != txsize) {
<span class="p_del">-			dev_err(&amp;sdev-&gt;interface-&gt;dev,</span>
<span class="p_add">+			dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
 				&quot;sendmsg failed!, retval %d for %zd\n&quot;,
 				ret, txsize);
 			kfree(iov);
<span class="p_chunk">@@ -340,7 +347,7 @@</span> <span class="p_context"> static int stub_send_ret_unlink(struct stub_device *sdev)</span>
 		ret = kernel_sendmsg(sdev-&gt;ud.tcp_socket, &amp;msg, iov,
 				     1, txsize);
 		if (ret != txsize) {
<span class="p_del">-			dev_err(&amp;sdev-&gt;interface-&gt;dev,</span>
<span class="p_add">+			dev_err(&amp;sdev-&gt;udev-&gt;dev,</span>
 				&quot;sendmsg failed!, retval %d for %zd\n&quot;,
 				ret, txsize);
 			usbip_event_add(&amp;sdev-&gt;ud, SDEV_EVENT_ERROR_TCP);
<span class="p_header">diff --git a/drivers/staging/usbip/usbip_common.h b/drivers/staging/usbip/usbip_common.h</span>
<span class="p_header">index 4da3866a037d..01be15a2066e 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/usbip_common.h</span>
<span class="p_header">+++ b/drivers/staging/usbip/usbip_common.h</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> struct usbip_device {</span>
 	/* lock for status */
 	spinlock_t lock;
 
<span class="p_add">+	int sockfd;</span>
 	struct socket *tcp_socket;
 
 	struct task_struct *tcp_rx;
<span class="p_header">diff --git a/drivers/staging/usbip/userspace/Makefile.am b/drivers/staging/usbip/userspace/Makefile.am</span>
<span class="p_header">index 66f8bf038c9f..a2f302cb679f 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/userspace/Makefile.am</span>
<span class="p_header">+++ b/drivers/staging/usbip/userspace/Makefile.am</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 SUBDIRS := libsrc src
 includedir = @includedir@/usbip
 include_HEADERS := $(addprefix libsrc/, \
<span class="p_del">-		     usbip_common.h vhci_driver.h usbip_host_driver.h)</span>
<span class="p_add">+		     usbip_common.h vhci_driver.h usbip_host_driver.h \</span>
<span class="p_add">+		     list.h sysfs_utils.h)</span>
 
 dist_man_MANS := $(addprefix doc/, usbip.8 usbipd.8)
<span class="p_header">diff --git a/drivers/staging/usbip/userspace/libsrc/vhci_driver.c b/drivers/staging/usbip/userspace/libsrc/vhci_driver.c</span>
<span class="p_header">index ad9204773533..1274f326242c 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/userspace/libsrc/vhci_driver.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/userspace/libsrc/vhci_driver.c</span>
<span class="p_chunk">@@ -55,12 +55,12 @@</span> <span class="p_context"> static int parse_status(const char *value)</span>
 
 	while (*c != &#39;\0&#39;) {
 		int port, status, speed, devid;
<span class="p_del">-		unsigned long socket;</span>
<span class="p_add">+		int sockfd;</span>
 		char lbusid[SYSFS_BUS_ID_SIZE];
 
<span class="p_del">-		ret = sscanf(c, &quot;%d %d %d %x %lx %31s\n&quot;,</span>
<span class="p_add">+		ret = sscanf(c, &quot;%d %d %d %x %u %31s\n&quot;,</span>
 				&amp;port, &amp;status, &amp;speed,
<span class="p_del">-				&amp;devid, &amp;socket, lbusid);</span>
<span class="p_add">+				&amp;devid, &amp;sockfd, lbusid);</span>
 
 		if (ret &lt; 5) {
 			dbg(&quot;sscanf failed: %d&quot;, ret);
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static int parse_status(const char *value)</span>
 
 		dbg(&quot;port %d status %d speed %d devid %x&quot;,
 				port, status, speed, devid);
<span class="p_del">-		dbg(&quot;socket %lx lbusid %s&quot;, socket, lbusid);</span>
<span class="p_add">+		dbg(&quot;sockfd %u lbusid %s&quot;, sockfd, lbusid);</span>
 
 
 		/* if a device is connected, look at it */
<span class="p_header">diff --git a/drivers/staging/usbip/vhci_sysfs.c b/drivers/staging/usbip/vhci_sysfs.c</span>
<span class="p_header">index 211f43f67ea2..14267d55bf0d 100644</span>
<span class="p_header">--- a/drivers/staging/usbip/vhci_sysfs.c</span>
<span class="p_header">+++ b/drivers/staging/usbip/vhci_sysfs.c</span>
<span class="p_chunk">@@ -39,13 +39,18 @@</span> <span class="p_context"> static ssize_t status_show(struct device *dev, struct device_attribute *attr,</span>
 
 	/*
 	 * output example:
<span class="p_del">-	 * prt sta spd dev socket           local_busid</span>
<span class="p_del">-	 * 000 004 000 000         c5a7bb80 1-2.3</span>
<span class="p_del">-	 * 001 004 000 000         d8cee980 2-3.4</span>
<span class="p_add">+	 * prt sta spd dev sockfd    local_busid</span>
<span class="p_add">+	 * 000 004 000 000 3         1-2.3</span>
<span class="p_add">+	 * 001 004 000 000 4         2-3.4</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Output includes socket fd instead of socket pointer address to avoid</span>
<span class="p_add">+	 * leaking kernel memory address in:</span>
<span class="p_add">+	 *	/sys/devices/platform/vhci_hcd.0/status and in debug output.</span>
<span class="p_add">+	 * The socket pointer address is not used at the moment and it was made</span>
<span class="p_add">+	 * visible as a convenient way to find IP address from socket pointer</span>
<span class="p_add">+	 * address by looking up /proc/net/{tcp,tcp6}. As this opens a security</span>
<span class="p_add">+	 * hole, the change is made to use sockfd instead.</span>
 	 *
<span class="p_del">-	 * IP address can be retrieved from a socket pointer address by looking</span>
<span class="p_del">-	 * up /proc/net/{tcp,tcp6}. Also, a userland program may remember a</span>
<span class="p_del">-	 * port number and its peer IP address.</span>
 	 */
 	out += sprintf(out,
 		       &quot;prt sta spd bus dev socket           local_busid\n&quot;);
<span class="p_chunk">@@ -59,7 +64,7 @@</span> <span class="p_context"> static ssize_t status_show(struct device *dev, struct device_attribute *attr,</span>
 		if (vdev-&gt;ud.status == VDEV_ST_USED) {
 			out += sprintf(out, &quot;%03u %08x &quot;,
 				       vdev-&gt;speed, vdev-&gt;devid);
<span class="p_del">-			out += sprintf(out, &quot;%16p &quot;, vdev-&gt;ud.tcp_socket);</span>
<span class="p_add">+			out += sprintf(out, &quot;%u&quot;, vdev-&gt;ud.sockfd);</span>
 			out += sprintf(out, &quot;%s&quot;, dev_name(&amp;vdev-&gt;udev-&gt;dev));
 
 		} else {
<span class="p_chunk">@@ -223,6 +228,7 @@</span> <span class="p_context"> static ssize_t store_attach(struct device *dev, struct device_attribute *attr,</span>
 
 	vdev-&gt;devid         = devid;
 	vdev-&gt;speed         = speed;
<span class="p_add">+	vdev-&gt;ud.sockfd     = sockfd;</span>
 	vdev-&gt;ud.tcp_socket = socket;
 	vdev-&gt;ud.status     = VDEV_ST_NOTASSIGNED;
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index e137dc7cfc72..f7eab402cd4f 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -1753,8 +1753,7 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 	struct iscsi_tmr_req *tmr_req;
 	struct iscsi_tm *hdr;
 	int out_of_order_cmdsn = 0, ret;
<span class="p_del">-	bool sess_ref = false;</span>
<span class="p_del">-	u8 function;</span>
<span class="p_add">+	u8 function, tcm_function = TMR_UNKNOWN;</span>
 
 	hdr			= (struct iscsi_tm *) buf;
 	hdr-&gt;flags &amp;= ~ISCSI_FLAG_CMD_FINAL;
<span class="p_chunk">@@ -1795,23 +1794,18 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 					     buf);
 	}
 
<span class="p_add">+	transport_init_se_cmd(&amp;cmd-&gt;se_cmd,</span>
<span class="p_add">+			      &amp;lio_target_fabric_configfs-&gt;tf_ops,</span>
<span class="p_add">+			      conn-&gt;sess-&gt;se_sess, 0, DMA_NONE,</span>
<span class="p_add">+			      MSG_SIMPLE_TAG, cmd-&gt;sense_buffer + 2);</span>
<span class="p_add">+</span>
<span class="p_add">+	target_get_sess_cmd(conn-&gt;sess-&gt;se_sess, &amp;cmd-&gt;se_cmd, true);</span>
<span class="p_add">+</span>
 	/*
 	 * TASK_REASSIGN for ERL=2 / connection stays inside of
 	 * LIO-Target $FABRIC_MOD
 	 */
 	if (function != ISCSI_TM_FUNC_TASK_REASSIGN) {
<span class="p_del">-</span>
<span class="p_del">-		u8 tcm_function;</span>
<span class="p_del">-		int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-		transport_init_se_cmd(&amp;cmd-&gt;se_cmd,</span>
<span class="p_del">-				      &amp;lio_target_fabric_configfs-&gt;tf_ops,</span>
<span class="p_del">-				      conn-&gt;sess-&gt;se_sess, 0, DMA_NONE,</span>
<span class="p_del">-				      MSG_SIMPLE_TAG, cmd-&gt;sense_buffer + 2);</span>
<span class="p_del">-</span>
<span class="p_del">-		target_get_sess_cmd(conn-&gt;sess-&gt;se_sess, &amp;cmd-&gt;se_cmd, true);</span>
<span class="p_del">-		sess_ref = true;</span>
<span class="p_del">-</span>
 		switch (function) {
 		case ISCSI_TM_FUNC_ABORT_TASK:
 			tcm_function = TMR_ABORT_TASK;
<span class="p_chunk">@@ -1840,15 +1834,14 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 			return iscsit_add_reject_cmd(cmd,
 				ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 		}
<span class="p_del">-</span>
<span class="p_del">-		ret = core_tmr_alloc_req(&amp;cmd-&gt;se_cmd, cmd-&gt;tmr_req,</span>
<span class="p_del">-					 tcm_function, GFP_KERNEL);</span>
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_del">-			return iscsit_add_reject_cmd(cmd,</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret = core_tmr_alloc_req(&amp;cmd-&gt;se_cmd, cmd-&gt;tmr_req, tcm_function,</span>
<span class="p_add">+				 GFP_KERNEL);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return iscsit_add_reject_cmd(cmd,</span>
 				ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 
<span class="p_del">-		cmd-&gt;tmr_req-&gt;se_tmr_req = cmd-&gt;se_cmd.se_tmr_req;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cmd-&gt;tmr_req-&gt;se_tmr_req = cmd-&gt;se_cmd.se_tmr_req;</span>
 
 	cmd-&gt;iscsi_opcode	= ISCSI_OP_SCSI_TMFUNC;
 	cmd-&gt;i_state		= ISTATE_SEND_TASKMGTRSP;
<span class="p_chunk">@@ -1924,12 +1917,14 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 
 	if (!(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)) {
 		int cmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr-&gt;cmdsn);
<span class="p_del">-		if (cmdsn_ret == CMDSN_HIGHER_THAN_EXP)</span>
<span class="p_add">+		if (cmdsn_ret == CMDSN_HIGHER_THAN_EXP) {</span>
 			out_of_order_cmdsn = 1;
<span class="p_del">-		else if (cmdsn_ret == CMDSN_LOWER_THAN_EXP)</span>
<span class="p_add">+		} else if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {</span>
<span class="p_add">+			target_put_sess_cmd(conn-&gt;sess-&gt;se_sess, &amp;cmd-&gt;se_cmd);</span>
 			return 0;
<span class="p_del">-		else if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)</span>
<span class="p_add">+		} else if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER) {</span>
 			return -1;
<span class="p_add">+		}</span>
 	}
 	iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr-&gt;exp_statsn));
 
<span class="p_chunk">@@ -1949,12 +1944,8 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 	 * For connection recovery, this is also the default action for
 	 * TMR TASK_REASSIGN.
 	 */
<span class="p_del">-	if (sess_ref) {</span>
<span class="p_del">-		pr_debug(&quot;Handle TMR, using sess_ref=true check\n&quot;);</span>
<span class="p_del">-		target_put_sess_cmd(conn-&gt;sess-&gt;se_sess, &amp;cmd-&gt;se_cmd);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	iscsit_add_cmd_to_response_queue(cmd, conn, cmd-&gt;i_state);
<span class="p_add">+	target_put_sess_cmd(conn-&gt;sess-&gt;se_sess, &amp;cmd-&gt;se_cmd);</span>
 	return 0;
 }
 EXPORT_SYMBOL(iscsit_handle_task_mgt_cmd);
<span class="p_header">diff --git a/drivers/target/target_core_tmr.c b/drivers/target/target_core_tmr.c</span>
<span class="p_header">index e6fe1b3dd76f..43a9b0168972 100644</span>
<span class="p_header">--- a/drivers/target/target_core_tmr.c</span>
<span class="p_header">+++ b/drivers/target/target_core_tmr.c</span>
<span class="p_chunk">@@ -141,6 +141,16 @@</span> <span class="p_context"> static bool __target_check_io_state(struct se_cmd *se_cmd,</span>
 		spin_unlock(&amp;se_cmd-&gt;t_state_lock);
 		return false;
 	}
<span class="p_add">+	if (se_cmd-&gt;transport_state &amp; CMD_T_PRE_EXECUTE) {</span>
<span class="p_add">+		if (se_cmd-&gt;scsi_status) {</span>
<span class="p_add">+			pr_debug(&quot;Attempted to abort io tag: %u early failure&quot;</span>
<span class="p_add">+				 &quot; status: 0x%02x\n&quot;,</span>
<span class="p_add">+				 se_cmd-&gt;se_tfo-&gt;get_task_tag(se_cmd),</span>
<span class="p_add">+				 se_cmd-&gt;scsi_status);</span>
<span class="p_add">+			spin_unlock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	if (sess-&gt;sess_tearing_down || se_cmd-&gt;cmd_wait_set) {
 		pr_debug(&quot;Attempted to abort io tag: %u already shutdown,&quot;
 			&quot; skipping\n&quot;, se_cmd-&gt;se_tfo-&gt;get_task_tag(se_cmd));
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index da00938c6dfa..1f06969c6102 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1797,6 +1797,7 @@</span> <span class="p_context"> void target_execute_cmd(struct se_cmd *cmd)</span>
 	}
 
 	cmd-&gt;t_state = TRANSPORT_PROCESSING;
<span class="p_add">+	cmd-&gt;transport_state &amp;= ~CMD_T_PRE_EXECUTE;</span>
 	cmd-&gt;transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 	/*
<span class="p_chunk">@@ -2441,6 +2442,7 @@</span> <span class="p_context"> int target_get_sess_cmd(struct se_session *se_sess, struct se_cmd *se_cmd,</span>
 		ret = -ESHUTDOWN;
 		goto out;
 	}
<span class="p_add">+	se_cmd-&gt;transport_state |= CMD_T_PRE_EXECUTE;</span>
 	list_add_tail(&amp;se_cmd-&gt;se_cmd_list, &amp;se_sess-&gt;sess_cmd_list);
 out:
 	spin_unlock_irqrestore(&amp;se_sess-&gt;sess_cmd_lock, flags);
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 72cf56086c91..f5a0b850f4aa 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1650,6 +1650,18 @@</span> <span class="p_context"> static int proc_unlinkurb(struct usb_dev_state *ps, void __user *arg)</span>
 	return 0;
 }
 
<span class="p_add">+static void compute_isochronous_actual_length(struct urb *urb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (urb-&gt;number_of_packets &gt; 0) {</span>
<span class="p_add">+		urb-&gt;actual_length = 0;</span>
<span class="p_add">+		for (i = 0; i &lt; urb-&gt;number_of_packets; i++)</span>
<span class="p_add">+			urb-&gt;actual_length +=</span>
<span class="p_add">+					urb-&gt;iso_frame_desc[i].actual_length;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int processcompl(struct async *as, void __user * __user *arg)
 {
 	struct urb *urb = as-&gt;urb;
<span class="p_chunk">@@ -1657,6 +1669,7 @@</span> <span class="p_context"> static int processcompl(struct async *as, void __user * __user *arg)</span>
 	void __user *addr = as-&gt;userurb;
 	unsigned int i;
 
<span class="p_add">+	compute_isochronous_actual_length(urb);</span>
 	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length) {
 		if (copy_urb_data_to_user(as-&gt;userbuffer, urb))
 			goto err_out;
<span class="p_chunk">@@ -1826,6 +1839,7 @@</span> <span class="p_context"> static int processcompl_compat(struct async *as, void __user * __user *arg)</span>
 	void __user *addr = as-&gt;userurb;
 	unsigned int i;
 
<span class="p_add">+	compute_isochronous_actual_length(urb);</span>
 	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length) {
 		if (copy_urb_data_to_user(as-&gt;userbuffer, urb))
 			return -EFAULT;
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 25d0eed708a3..6f5ffed75ca1 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -218,6 +218,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Corsair Strafe RGB */
 	{ USB_DEVICE(0x1b1c, 0x1b20), .driver_info = USB_QUIRK_DELAY_INIT },
 
<span class="p_add">+	/* Corsair K70 LUX */</span>
<span class="p_add">+	{ USB_DEVICE(0x1b1c, 0x1b36), .driver_info = USB_QUIRK_DELAY_INIT },</span>
<span class="p_add">+</span>
 	/* MIDI keyboard WORLDE MINI */
 	{ USB_DEVICE(0x1c75, 0x0204), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
<span class="p_header">diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">index 37d0e8cc7af6..2220c1b9df10 100644</span>
<span class="p_header">--- a/drivers/usb/serial/garmin_gps.c</span>
<span class="p_header">+++ b/drivers/usb/serial/garmin_gps.c</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> struct garmin_data {</span>
 	__u8   privpkt[4*6];
 	spinlock_t lock;
 	struct list_head pktlist;
<span class="p_add">+	struct usb_anchor write_urbs;</span>
 };
 
 
<span class="p_chunk">@@ -906,13 +907,19 @@</span> <span class="p_context"> static int garmin_init_session(struct usb_serial_port *port)</span>
 					sizeof(GARMIN_START_SESSION_REQ), 0);
 
 			if (status &lt; 0)
<span class="p_del">-				break;</span>
<span class="p_add">+				goto err_kill_urbs;</span>
 		}
 
 		if (status &gt; 0)
 			status = 0;
 	}
 
<span class="p_add">+	return status;</span>
<span class="p_add">+</span>
<span class="p_add">+err_kill_urbs:</span>
<span class="p_add">+	usb_kill_anchored_urbs(&amp;garmin_data_p-&gt;write_urbs);</span>
<span class="p_add">+	usb_kill_urb(port-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
 	return status;
 }
 
<span class="p_chunk">@@ -931,7 +938,6 @@</span> <span class="p_context"> static int garmin_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 	spin_unlock_irqrestore(&amp;garmin_data_p-&gt;lock, flags);
 
 	/* shutdown any bulk reads that might be going on */
<span class="p_del">-	usb_kill_urb(port-&gt;write_urb);</span>
 	usb_kill_urb(port-&gt;read_urb);
 
 	if (garmin_data_p-&gt;state == STATE_RESET)
<span class="p_chunk">@@ -954,7 +960,7 @@</span> <span class="p_context"> static void garmin_close(struct usb_serial_port *port)</span>
 
 	/* shutdown our urbs */
 	usb_kill_urb(port-&gt;read_urb);
<span class="p_del">-	usb_kill_urb(port-&gt;write_urb);</span>
<span class="p_add">+	usb_kill_anchored_urbs(&amp;garmin_data_p-&gt;write_urbs);</span>
 
 	/* keep reset state so we know that we must start a new session */
 	if (garmin_data_p-&gt;state != STATE_RESET)
<span class="p_chunk">@@ -1038,12 +1044,14 @@</span> <span class="p_context"> static int garmin_write_bulk(struct usb_serial_port *port,</span>
 	}
 
 	/* send it down the pipe */
<span class="p_add">+	usb_anchor_urb(urb, &amp;garmin_data_p-&gt;write_urbs);</span>
 	status = usb_submit_urb(urb, GFP_ATOMIC);
 	if (status) {
 		dev_err(&amp;port-&gt;dev,
 		   &quot;%s - usb_submit_urb(write bulk) failed with status = %d\n&quot;,
 				__func__, status);
 		count = status;
<span class="p_add">+		usb_unanchor_urb(urb);</span>
 		kfree(buffer);
 	}
 
<span class="p_chunk">@@ -1402,9 +1410,16 @@</span> <span class="p_context"> static int garmin_port_probe(struct usb_serial_port *port)</span>
 	garmin_data_p-&gt;state = 0;
 	garmin_data_p-&gt;flags = 0;
 	garmin_data_p-&gt;count = 0;
<span class="p_add">+	init_usb_anchor(&amp;garmin_data_p-&gt;write_urbs);</span>
 	usb_set_serial_port_data(port, garmin_data_p);
 
 	status = garmin_init_session(port);
<span class="p_add">+	if (status)</span>
<span class="p_add">+		goto err_free;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+err_free:</span>
<span class="p_add">+	kfree(garmin_data_p);</span>
 
 	return status;
 }
<span class="p_chunk">@@ -1414,6 +1429,7 @@</span> <span class="p_context"> static int garmin_port_remove(struct usb_serial_port *port)</span>
 {
 	struct garmin_data *garmin_data_p = usb_get_serial_port_data(port);
 
<span class="p_add">+	usb_kill_anchored_urbs(&amp;garmin_data_p-&gt;write_urbs);</span>
 	usb_kill_urb(port-&gt;interrupt_in_urb);
 	del_timer_sync(&amp;garmin_data_p-&gt;timer);
 	kfree(garmin_data_p);
<span class="p_header">diff --git a/drivers/usb/serial/metro-usb.c b/drivers/usb/serial/metro-usb.c</span>
<span class="p_header">index 45182c65fa1f..72f7b23b1495 100644</span>
<span class="p_header">--- a/drivers/usb/serial/metro-usb.c</span>
<span class="p_header">+++ b/drivers/usb/serial/metro-usb.c</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> static int metrousb_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 		dev_err(&amp;port-&gt;dev,
 			&quot;%s - failed submitting interrupt in urb, error code=%d\n&quot;,
 			__func__, result);
<span class="p_del">-		goto exit;</span>
<span class="p_add">+		return result;</span>
 	}
 
 	/* Send activate cmd to device */
<span class="p_chunk">@@ -226,11 +226,16 @@</span> <span class="p_context"> static int metrousb_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 		dev_err(&amp;port-&gt;dev,
 			&quot;%s - failed to configure device, error code=%d\n&quot;,
 			__func__, result);
<span class="p_del">-		goto exit;</span>
<span class="p_add">+		goto err_kill_urb;</span>
 	}
 
 	dev_dbg(&amp;port-&gt;dev, &quot;%s - port open\n&quot;, __func__);
<span class="p_del">-exit:</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_kill_urb:</span>
<span class="p_add">+	usb_kill_urb(port-&gt;interrupt_in_urb);</span>
<span class="p_add">+</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 996dc09b00b8..7b3ce6e42fc6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -147,6 +147,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x114f, 0x68a2)},	/* Sierra Wireless MC7750 */
 	{DEVICE_SWI(0x1199, 0x68a2)},	/* Sierra Wireless MC7710 */
 	{DEVICE_SWI(0x1199, 0x901c)},	/* Sierra Wireless EM7700 */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x901e)},	/* Sierra Wireless EM7355 QDL */</span>
 	{DEVICE_SWI(0x1199, 0x901f)},	/* Sierra Wireless EM7355 */
 	{DEVICE_SWI(0x1199, 0x9040)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9051)},	/* Netgear AirCard 340U */
<span class="p_header">diff --git a/drivers/video/fbdev/udlfb.c b/drivers/video/fbdev/udlfb.c</span>
<span class="p_header">index 77b890e4d296..4c244c696aa6 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/udlfb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/udlfb.c</span>
<span class="p_chunk">@@ -769,11 +769,11 @@</span> <span class="p_context"> static int dlfb_get_edid(struct dlfb_data *dev, char *edid, int len)</span>
 
 	for (i = 0; i &lt; len; i++) {
 		ret = usb_control_msg(dev-&gt;udev,
<span class="p_del">-				    usb_rcvctrlpipe(dev-&gt;udev, 0), (0x02),</span>
<span class="p_del">-				    (0x80 | (0x02 &lt;&lt; 5)), i &lt;&lt; 8, 0xA1, rbuf, 2,</span>
<span class="p_del">-				    HZ);</span>
<span class="p_del">-		if (ret &lt; 1) {</span>
<span class="p_del">-			pr_err(&quot;Read EDID byte %d failed err %x\n&quot;, i, ret);</span>
<span class="p_add">+				      usb_rcvctrlpipe(dev-&gt;udev, 0), 0x02,</span>
<span class="p_add">+				      (0x80 | (0x02 &lt;&lt; 5)), i &lt;&lt; 8, 0xA1,</span>
<span class="p_add">+				      rbuf, 2, USB_CTRL_GET_TIMEOUT);</span>
<span class="p_add">+		if (ret &lt; 2) {</span>
<span class="p_add">+			pr_err(&quot;Read EDID byte %d failed: %d\n&quot;, i, ret);</span>
 			i--;
 			break;
 		}
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index d0b7320b17c4..e1f366fa59a2 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -483,6 +483,9 @@</span> <span class="p_context"> static int v9fs_test_inode(struct inode *inode, void *data)</span>
 
 	if (v9inode-&gt;qid.type != st-&gt;qid.type)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (v9inode-&gt;qid.path != st-&gt;qid.path)</span>
<span class="p_add">+		return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index f03024e5bcbe..84b611ff4b65 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -87,6 +87,9 @@</span> <span class="p_context"> static int v9fs_test_inode_dotl(struct inode *inode, void *data)</span>
 
 	if (v9inode-&gt;qid.type != st-&gt;qid.type)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (v9inode-&gt;qid.path != st-&gt;qid.path)</span>
<span class="p_add">+		return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c</span>
<span class="p_header">index 116fd38ee472..d5d0f819b64a 100644</span>
<span class="p_header">--- a/fs/autofs4/waitq.c</span>
<span class="p_header">+++ b/fs/autofs4/waitq.c</span>
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int autofs4_write(struct autofs_sb_info *sbi,</span>
 		spin_unlock_irqrestore(&amp;current-&gt;sighand-&gt;siglock, flags);
 	}
 
<span class="p_del">-	return (bytes &gt; 0);</span>
<span class="p_add">+	/* if &#39;wr&#39; returned 0 (impossible) we assume -EIO (safe) */</span>
<span class="p_add">+	return bytes == 0 ? 0 : wr &lt; 0 ? wr : -EIO;</span>
 }
 	
 static void autofs4_notify_daemon(struct autofs_sb_info *sbi,
<span class="p_chunk">@@ -101,6 +102,7 @@</span> <span class="p_context"> static void autofs4_notify_daemon(struct autofs_sb_info *sbi,</span>
 	} pkt;
 	struct file *pipe = NULL;
 	size_t pktsz;
<span class="p_add">+	int ret;</span>
 
 	DPRINTK(&quot;wait id = 0x%08lx, name = %.*s, type=%d&quot;,
 		(unsigned long) wq-&gt;wait_queue_token, wq-&gt;name.len, wq-&gt;name.name, type);
<span class="p_chunk">@@ -172,8 +174,18 @@</span> <span class="p_context"> static void autofs4_notify_daemon(struct autofs_sb_info *sbi,</span>
 
 	mutex_unlock(&amp;sbi-&gt;wq_mutex);
 
<span class="p_del">-	if (autofs4_write(sbi, pipe, &amp;pkt, pktsz))</span>
<span class="p_add">+	switch (ret = autofs4_write(sbi, pipe, &amp;pkt, pktsz)) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case -ENOMEM:</span>
<span class="p_add">+	case -ERESTARTSYS:</span>
<span class="p_add">+		/* Just fail this one */</span>
<span class="p_add">+		autofs4_wait_release(sbi, wq-&gt;wait_queue_token, ret);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		autofs4_catatonic_mode(sbi);
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 	fput(pipe);
 }
 
<span class="p_header">diff --git a/fs/binfmt_elf_fdpic.c b/fs/binfmt_elf_fdpic.c</span>
<span class="p_header">index fe2a643ee005..f1c68f8df674 100644</span>
<span class="p_header">--- a/fs/binfmt_elf_fdpic.c</span>
<span class="p_header">+++ b/fs/binfmt_elf_fdpic.c</span>
<span class="p_chunk">@@ -1487,7 +1487,9 @@</span> <span class="p_context"> static bool elf_fdpic_dump_segments(struct coredump_params *cprm)</span>
 	struct vm_area_struct *vma;
 
 	for (vma = current-&gt;mm-&gt;mmap; vma; vma = vma-&gt;vm_next) {
<span class="p_add">+#ifdef CONFIG_MMU</span>
 		unsigned long addr;
<span class="p_add">+#endif</span>
 
 		if (!maydump(vma, cprm-&gt;mm_flags))
 			continue;
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 3cec2fb4fdc1..72068ce50d76 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -185,7 +185,6 @@</span> <span class="p_context"> static const char * const logtypes[] = {</span>
 
 void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)
 {
<span class="p_del">-	struct super_block *sb = fs_info-&gt;sb;</span>
 	char lvl[4];
 	struct va_format vaf;
 	va_list args;
<span class="p_chunk">@@ -207,7 +206,8 @@</span> <span class="p_context"> void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)</span>
 	vaf.fmt = fmt;
 	vaf.va = &amp;args;
 
<span class="p_del">-	printk(&quot;%sBTRFS %s (device %s): %pV\n&quot;, lvl, type, sb-&gt;s_id, &amp;vaf);</span>
<span class="p_add">+	printk(&quot;%sBTRFS %s (device %s): %pV\n&quot;, lvl, type,</span>
<span class="p_add">+		fs_info ? fs_info-&gt;sb-&gt;s_id : &quot;&lt;unknown&gt;&quot;, &amp;vaf);</span>
 
 	va_end(args);
 }
<span class="p_header">diff --git a/fs/coda/upcall.c b/fs/coda/upcall.c</span>
<span class="p_header">index 21fcf8dcb9cd..19233dd073aa 100644</span>
<span class="p_header">--- a/fs/coda/upcall.c</span>
<span class="p_header">+++ b/fs/coda/upcall.c</span>
<span class="p_chunk">@@ -446,8 +446,7 @@</span> <span class="p_context"> int venus_fsync(struct super_block *sb, struct CodaFid *fid)</span>
 	UPARG(CODA_FSYNC);
 
 	inp-&gt;coda_fsync.VFid = *fid;
<span class="p_del">-	error = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),</span>
<span class="p_del">-			    &amp;outsize, inp);</span>
<span class="p_add">+	error = coda_upcall(coda_vcp(sb), insize, &amp;outsize, inp);</span>
 
 	CODA_FREE(inp, insize);
 	return error;
<span class="p_header">diff --git a/fs/ecryptfs/messaging.c b/fs/ecryptfs/messaging.c</span>
<span class="p_header">index e57380e5f6bd..3ca7f48bd540 100644</span>
<span class="p_header">--- a/fs/ecryptfs/messaging.c</span>
<span class="p_header">+++ b/fs/ecryptfs/messaging.c</span>
<span class="p_chunk">@@ -443,15 +443,16 @@</span> <span class="p_context"> void ecryptfs_release_messaging(void)</span>
 	}
 	if (ecryptfs_daemon_hash) {
 		struct ecryptfs_daemon *daemon;
<span class="p_add">+		struct hlist_node *n;</span>
 		int i;
 
 		mutex_lock(&amp;ecryptfs_daemon_hash_mux);
 		for (i = 0; i &lt; (1 &lt;&lt; ecryptfs_hash_bits); i++) {
 			int rc;
 
<span class="p_del">-			hlist_for_each_entry(daemon,</span>
<span class="p_del">-					     &amp;ecryptfs_daemon_hash[i],</span>
<span class="p_del">-					     euid_chain) {</span>
<span class="p_add">+			hlist_for_each_entry_safe(daemon, n,</span>
<span class="p_add">+						  &amp;ecryptfs_daemon_hash[i],</span>
<span class="p_add">+						  euid_chain) {</span>
 				rc = ecryptfs_exorcise_daemon(daemon);
 				if (rc)
 					printk(KERN_ERR &quot;%s: Error whilst &quot;
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index d4b31664a75b..ea90ab336d76 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4810,7 +4810,8 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	}
 
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
<span class="p_del">-	     offset + len &gt; i_size_read(inode)) {</span>
<span class="p_add">+	    (offset + len &gt; i_size_read(inode) ||</span>
<span class="p_add">+	     offset + len &gt; EXT4_I(inode)-&gt;i_disksize)) {</span>
 		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
<span class="p_chunk">@@ -4956,7 +4957,8 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	}
 
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
<span class="p_del">-	     offset + len &gt; i_size_read(inode)) {</span>
<span class="p_add">+	    (offset + len &gt; i_size_read(inode) ||</span>
<span class="p_add">+	     offset + len &gt; EXT4_I(inode)-&gt;i_disksize)) {</span>
 		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
<span class="p_header">diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="p_header">index 010c2af33858..89c3f2ca3c9b 100644</span>
<span class="p_header">--- a/fs/f2fs/file.c</span>
<span class="p_header">+++ b/fs/f2fs/file.c</span>
<span class="p_chunk">@@ -460,6 +460,11 @@</span> <span class="p_context"> int f2fs_getattr(struct vfsmount *mnt,</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	generic_fillattr(inode, stat);
 	stat-&gt;blocks &lt;&lt;= 3;
<span class="p_add">+</span>
<span class="p_add">+	/* we need to show initial sectors used for inline_data/dentries */</span>
<span class="p_add">+	if (S_ISREG(inode-&gt;i_mode) &amp;&amp; f2fs_has_inline_data(inode))</span>
<span class="p_add">+		stat-&gt;blocks += (stat-&gt;size + 511) &gt;&gt; 9;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c</span>
<span class="p_header">index 00dec8840068..cd4d5dccc9fd 100644</span>
<span class="p_header">--- a/fs/f2fs/segment.c</span>
<span class="p_header">+++ b/fs/f2fs/segment.c</span>
<span class="p_chunk">@@ -969,14 +969,12 @@</span> <span class="p_context"> void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,</span>
 {
 	struct sit_info *sit_i = SIT_I(sbi);
 	struct curseg_info *curseg;
<span class="p_del">-	unsigned int old_cursegno;</span>
 
 	curseg = CURSEG_I(sbi, type);
 
 	mutex_lock(&amp;curseg-&gt;curseg_mutex);
 
 	*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg);
<span class="p_del">-	old_cursegno = curseg-&gt;segno;</span>
 
 	/*
 	 * __add_sum_entry should be resided under the curseg_mutex
<span class="p_chunk">@@ -990,14 +988,24 @@</span> <span class="p_context"> void allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,</span>
 
 	stat_inc_block_count(sbi, curseg);
 
<span class="p_del">-	if (!__has_curseg_space(sbi, type))</span>
<span class="p_del">-		sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, false);</span>
 	/*
 	 * SIT information should be updated before segment allocation,
 	 * since SSR needs latest valid block information.
 	 */
<span class="p_del">-	refresh_sit_entry(sbi, old_blkaddr, *new_blkaddr);</span>
<span class="p_del">-	locate_dirty_segment(sbi, old_cursegno);</span>
<span class="p_add">+	update_sit_entry(sbi, *new_blkaddr, 1);</span>
<span class="p_add">+	if (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)</span>
<span class="p_add">+		update_sit_entry(sbi, old_blkaddr, -1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__has_curseg_space(sbi, type))</span>
<span class="p_add">+		sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * segment dirty status should be updated after segment allocation,</span>
<span class="p_add">+	 * so we just need to update status only one time after previous</span>
<span class="p_add">+	 * segment being closed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));</span>
<span class="p_add">+	locate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr));</span>
 
 	mutex_unlock(&amp;sit_i-&gt;sentry_lock);
 
<span class="p_header">diff --git a/fs/isofs/isofs.h b/fs/isofs/isofs.h</span>
<span class="p_header">index 0ac4c1f73fbd..25177e6bd603 100644</span>
<span class="p_header">--- a/fs/isofs/isofs.h</span>
<span class="p_header">+++ b/fs/isofs/isofs.h</span>
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static inline unsigned int isonum_733(char *p)</span>
 	/* Ignore bigendian datum due to broken mastering programs */
 	return get_unaligned_le32(p);
 }
<span class="p_del">-extern int iso_date(char *, int);</span>
<span class="p_add">+extern int iso_date(u8 *, int);</span>
 
 struct inode;		/* To make gcc happy */
 
<span class="p_header">diff --git a/fs/isofs/rock.h b/fs/isofs/rock.h</span>
<span class="p_header">index ed09e2b08637..f835976ce033 100644</span>
<span class="p_header">--- a/fs/isofs/rock.h</span>
<span class="p_header">+++ b/fs/isofs/rock.h</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> struct RR_PL_s {</span>
 };
 
 struct stamp {
<span class="p_del">-	char time[7];</span>
<span class="p_add">+	__u8 time[7];		/* actually 6 unsigned, 1 signed */</span>
 } __attribute__ ((packed));
 
 struct RR_TF_s {
<span class="p_header">diff --git a/fs/isofs/util.c b/fs/isofs/util.c</span>
<span class="p_header">index 01e1ee7a998b..5cdf5359b0e9 100644</span>
<span class="p_header">--- a/fs/isofs/util.c</span>
<span class="p_header">+++ b/fs/isofs/util.c</span>
<span class="p_chunk">@@ -14,7 +14,7 @@</span> <span class="p_context"></span>
  * to GMT.  Thus  we should always be correct.
  */
 
<span class="p_del">-int iso_date(char * p, int flag)</span>
<span class="p_add">+int iso_date(u8 *p, int flag)</span>
 {
 	int year, month, day, hour, minute, second, tz;
 	int crtime, days, i;
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 18d314b3f80f..7f9b6f799aa2 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -243,15 +243,12 @@</span> <span class="p_context"> const u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE</span>
 };
 
 const u32 nfs4_fs_locations_bitmap[3] = {
<span class="p_del">-	FATTR4_WORD0_TYPE</span>
<span class="p_del">-	| FATTR4_WORD0_CHANGE</span>
<span class="p_add">+	FATTR4_WORD0_CHANGE</span>
 	| FATTR4_WORD0_SIZE
 	| FATTR4_WORD0_FSID
 	| FATTR4_WORD0_FILEID
 	| FATTR4_WORD0_FS_LOCATIONS,
<span class="p_del">-	FATTR4_WORD1_MODE</span>
<span class="p_del">-	| FATTR4_WORD1_NUMLINKS</span>
<span class="p_del">-	| FATTR4_WORD1_OWNER</span>
<span class="p_add">+	FATTR4_WORD1_OWNER</span>
 	| FATTR4_WORD1_OWNER_GROUP
 	| FATTR4_WORD1_RAWDEV
 	| FATTR4_WORD1_SPACE_USED
<span class="p_chunk">@@ -6015,9 +6012,7 @@</span> <span class="p_context"> static int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,</span>
 				   struct page *page)
 {
 	struct nfs_server *server = NFS_SERVER(dir);
<span class="p_del">-	u32 bitmask[3] = {</span>
<span class="p_del">-		[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,</span>
<span class="p_del">-	};</span>
<span class="p_add">+	u32 bitmask[3];</span>
 	struct nfs4_fs_locations_arg args = {
 		.dir_fh = NFS_FH(dir),
 		.name = name,
<span class="p_chunk">@@ -6036,12 +6031,15 @@</span> <span class="p_context"> static int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,</span>
 
 	dprintk(&quot;%s: start\n&quot;, __func__);
 
<span class="p_add">+	bitmask[0] = nfs4_fattr_bitmap[0] | FATTR4_WORD0_FS_LOCATIONS;</span>
<span class="p_add">+	bitmask[1] = nfs4_fattr_bitmap[1];</span>
<span class="p_add">+</span>
 	/* Ask for the fileid of the absent filesystem if mounted_on_fileid
 	 * is not supported */
 	if (NFS_SERVER(dir)-&gt;attr_bitmask[1] &amp; FATTR4_WORD1_MOUNTED_ON_FILEID)
<span class="p_del">-		bitmask[1] |= FATTR4_WORD1_MOUNTED_ON_FILEID;</span>
<span class="p_add">+		bitmask[0] &amp;= ~FATTR4_WORD0_FILEID;</span>
 	else
<span class="p_del">-		bitmask[0] |= FATTR4_WORD0_FILEID;</span>
<span class="p_add">+		bitmask[1] &amp;= ~FATTR4_WORD1_MOUNTED_ON_FILEID;</span>
 
 	nfs_fattr_init(&amp;fs_locations-&gt;fattr);
 	fs_locations-&gt;server = server;
<span class="p_header">diff --git a/fs/nfs/nfs4trace.h b/fs/nfs/nfs4trace.h</span>
<span class="p_header">index 1c32adbe728d..14e589195cae 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4trace.h</span>
<span class="p_header">+++ b/fs/nfs/nfs4trace.h</span>
<span class="p_chunk">@@ -201,17 +201,13 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_clientid_event,</span>
 		TP_ARGS(clp, error),
 
 		TP_STRUCT__entry(
<span class="p_del">-			__string(dstaddr,</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR))</span>
<span class="p_add">+			__string(dstaddr, clp-&gt;cl_hostname)</span>
 			__field(int, error)
 		),
 
 		TP_fast_assign(
 			__entry-&gt;error = error;
<span class="p_del">-			__assign_str(dstaddr,</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-						RPC_DISPLAY_ADDR));</span>
<span class="p_add">+			__assign_str(dstaddr, clp-&gt;cl_hostname);</span>
 		),
 
 		TP_printk(
<span class="p_header">diff --git a/fs/nfs/super.c b/fs/nfs/super.c</span>
<span class="p_header">index 3fd83327bbad..b04563f7be69 100644</span>
<span class="p_header">--- a/fs/nfs/super.c</span>
<span class="p_header">+++ b/fs/nfs/super.c</span>
<span class="p_chunk">@@ -1319,7 +1319,7 @@</span> <span class="p_context"> static int nfs_parse_mount_options(char *raw,</span>
 			mnt-&gt;options |= NFS_OPTION_MIGRATION;
 			break;
 		case Opt_nomigration:
<span class="p_del">-			mnt-&gt;options &amp;= NFS_OPTION_MIGRATION;</span>
<span class="p_add">+			mnt-&gt;options &amp;= ~NFS_OPTION_MIGRATION;</span>
 			break;
 
 		/*
<span class="p_header">diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c</span>
<span class="p_header">index 14538a865102..2ef7f51d7950 100644</span>
<span class="p_header">--- a/fs/nilfs2/segment.c</span>
<span class="p_header">+++ b/fs/nilfs2/segment.c</span>
<span class="p_chunk">@@ -1883,8 +1883,6 @@</span> <span class="p_context"> static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,</span>
 					      &quot;failed to get inode block.\n&quot;);
 				return err;
 			}
<span class="p_del">-			mark_buffer_dirty(ibh);</span>
<span class="p_del">-			nilfs_mdt_mark_dirty(ifile);</span>
 			spin_lock(&amp;nilfs-&gt;ns_inode_lock);
 			if (likely(!ii-&gt;i_bh))
 				ii-&gt;i_bh = ibh;
<span class="p_chunk">@@ -1893,6 +1891,10 @@</span> <span class="p_context"> static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,</span>
 			goto retry;
 		}
 
<span class="p_add">+		// Always redirty the buffer to avoid race condition</span>
<span class="p_add">+		mark_buffer_dirty(ii-&gt;i_bh);</span>
<span class="p_add">+		nilfs_mdt_mark_dirty(ifile);</span>
<span class="p_add">+</span>
 		clear_bit(NILFS_I_QUEUED, &amp;ii-&gt;i_state);
 		set_bit(NILFS_I_BUSY, &amp;ii-&gt;i_state);
 		list_move_tail(&amp;ii-&gt;i_dirty, &amp;sci-&gt;sc_dirty_files);
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index 2ec13bc4deb3..af700530622f 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -448,6 +448,7 @@</span> <span class="p_context"> struct request_queue {</span>
 	int			node;
 #ifdef CONFIG_BLK_DEV_IO_TRACE
 	struct blk_trace	*blk_trace;
<span class="p_add">+	struct mutex		blk_trace_mutex;</span>
 #endif
 	/*
 	 * for flush operations
<span class="p_header">diff --git a/include/linux/dmar.h b/include/linux/dmar.h</span>
<span class="p_header">index 23c8db129560..7052a36f5c80 100644</span>
<span class="p_header">--- a/include/linux/dmar.h</span>
<span class="p_header">+++ b/include/linux/dmar.h</span>
<span class="p_chunk">@@ -100,6 +100,7 @@</span> <span class="p_context"> static inline bool dmar_rcu_check(void)</span>
 
 extern int dmar_table_init(void);
 extern int dmar_dev_scope_init(void);
<span class="p_add">+extern void dmar_register_bus_notifier(void);</span>
 extern int dmar_parse_dev_scope(void *start, void *end, int *cnt,
 				struct dmar_dev_scope **devices, u16 segment);
 extern void *dmar_alloc_dev_scope(void *start, void *end, int *cnt);
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index ca9589027893..34af72b8b296 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -174,14 +174,6 @@</span> <span class="p_context"> extern unsigned long this_cpu_load(void);</span>
 extern void calc_global_load(unsigned long ticks);
 extern void update_cpu_load_nohz(void);
 
<span class="p_del">-/* Notifier for when a task gets migrated to a new CPU */</span>
<span class="p_del">-struct task_migration_notifier {</span>
<span class="p_del">-	struct task_struct *task;</span>
<span class="p_del">-	int from_cpu;</span>
<span class="p_del">-	int to_cpu;</span>
<span class="p_del">-};</span>
<span class="p_del">-extern void register_task_migration_notifier(struct notifier_block *n);</span>
<span class="p_del">-</span>
 extern unsigned long get_parent_ip(unsigned long addr);
 
 extern void dump_cpu_task(int cpu);
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index 6c9979b24eba..775724d054cd 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -583,6 +583,8 @@</span> <span class="p_context"> static inline void sctp_v6_map_v4(union sctp_addr *addr)</span>
 static inline void sctp_v4_map_v6(union sctp_addr *addr)
 {
 	addr-&gt;v6.sin6_family = AF_INET6;
<span class="p_add">+	addr-&gt;v6.sin6_flowinfo = 0;</span>
<span class="p_add">+	addr-&gt;v6.sin6_scope_id = 0;</span>
 	addr-&gt;v6.sin6_port = addr-&gt;v4.sin_port;
 	addr-&gt;v6.sin6_addr.s6_addr32[3] = addr-&gt;v4.sin_addr.s_addr;
 	addr-&gt;v6.sin6_addr.s6_addr32[0] = 0;
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index 2f256a202e97..9e4f596f2175 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -465,10 +465,6 @@</span> <span class="p_context"> struct sctp_af {</span>
 					 int saddr);
 	void		(*from_sk)	(union sctp_addr *,
 					 struct sock *sk);
<span class="p_del">-	void		(*to_sk_saddr)	(union sctp_addr *,</span>
<span class="p_del">-					 struct sock *sk);</span>
<span class="p_del">-	void		(*to_sk_daddr)	(union sctp_addr *,</span>
<span class="p_del">-					 struct sock *sk);</span>
 	void		(*from_addr_param) (union sctp_addr *,
 					    union sctp_addr_param *,
 					    __be16 port, int iif);
<span class="p_chunk">@@ -509,7 +505,9 @@</span> <span class="p_context"> struct sctp_pf {</span>
 	int  (*supported_addrs)(const struct sctp_sock *, __be16 *);
 	struct sock *(*create_accept_sk) (struct sock *sk,
 					  struct sctp_association *asoc);
<span class="p_del">-	void (*addr_v4map) (struct sctp_sock *, union sctp_addr *);</span>
<span class="p_add">+	int (*addr_to_user)(struct sctp_sock *sk, union sctp_addr *addr);</span>
<span class="p_add">+	void (*to_sk_saddr)(union sctp_addr *, struct sock *sk);</span>
<span class="p_add">+	void (*to_sk_daddr)(union sctp_addr *, struct sock *sk);</span>
 	struct sctp_af *af;
 };
 
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 5c755a85630b..23af3c8569be 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -230,6 +230,7 @@</span> <span class="p_context"> enum tcm_tmreq_table {</span>
 	TMR_LUN_RESET		= 5,
 	TMR_TARGET_WARM_RESET	= 6,
 	TMR_TARGET_COLD_RESET	= 7,
<span class="p_add">+	TMR_UNKNOWN		= 0xff,</span>
 };
 
 /* fabric independent task management response values */
<span class="p_chunk">@@ -536,6 +537,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 #define CMD_T_BUSY		(1 &lt;&lt; 9)
 #define CMD_T_TAS		(1 &lt;&lt; 10)
 #define CMD_T_FABRIC_STOP	(1 &lt;&lt; 11)
<span class="p_add">+#define CMD_T_PRE_EXECUTE	(1 &lt;&lt; 12)</span>
 	spinlock_t		t_state_lock;
 	struct completion	t_transport_stop_comp;
 
<span class="p_header">diff --git a/kernel/extable.c b/kernel/extable.c</span>
<span class="p_header">index d8a6446adbcb..f7f4771f00c5 100644</span>
<span class="p_header">--- a/kernel/extable.c</span>
<span class="p_header">+++ b/kernel/extable.c</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"></span>
  * mutex protecting text section modification (dynamic code patching).
  * some users need to sleep (allocating memory...) while they hold this lock.
  *
<span class="p_add">+ * Note: Also protects SMP-alternatives modification on x86.</span>
<span class="p_add">+ *</span>
  * NOT exported to modules - patching kernel text is a really delicate matter.
  */
 DEFINE_MUTEX(text_mutex);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index d776fb7d902a..c2e902a52c6d 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1041,13 +1041,6 @@</span> <span class="p_context"> void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)</span>
 		rq-&gt;skip_clock_update = 1;
 }
 
<span class="p_del">-static ATOMIC_NOTIFIER_HEAD(task_migration_notifier);</span>
<span class="p_del">-</span>
<span class="p_del">-void register_task_migration_notifier(struct notifier_block *n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	atomic_notifier_chain_register(&amp;task_migration_notifier, n);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_SMP
 void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 {
<span class="p_chunk">@@ -1078,18 +1071,10 @@</span> <span class="p_context"> void set_task_cpu(struct task_struct *p, unsigned int new_cpu)</span>
 	trace_sched_migrate_task(p, new_cpu);
 
 	if (task_cpu(p) != new_cpu) {
<span class="p_del">-		struct task_migration_notifier tmn;</span>
<span class="p_del">-</span>
 		if (p-&gt;sched_class-&gt;migrate_task_rq)
 			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);
 		p-&gt;se.nr_migrations++;
 		perf_sw_event_sched(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 0);
<span class="p_del">-</span>
<span class="p_del">-		tmn.task = p;</span>
<span class="p_del">-		tmn.from_cpu = task_cpu(p);</span>
<span class="p_del">-		tmn.to_cpu = new_cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-		atomic_notifier_call_chain(&amp;task_migration_notifier, 0, &amp;tmn);</span>
 	}
 
 	__set_task_cpu(p, new_cpu);
<span class="p_header">diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c</span>
<span class="p_header">index c1bd4ada2a04..a2f934e638c7 100644</span>
<span class="p_header">--- a/kernel/trace/blktrace.c</span>
<span class="p_header">+++ b/kernel/trace/blktrace.c</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static void blk_trace_cleanup(struct blk_trace *bt)</span>
 		blk_unregister_tracepoints();
 }
 
<span class="p_del">-int blk_trace_remove(struct request_queue *q)</span>
<span class="p_add">+static int __blk_trace_remove(struct request_queue *q)</span>
 {
 	struct blk_trace *bt;
 
<span class="p_chunk">@@ -320,6 +320,17 @@</span> <span class="p_context"> int blk_trace_remove(struct request_queue *q)</span>
 
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+int blk_trace_remove(struct request_queue *q)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+	ret = __blk_trace_remove(q);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(blk_trace_remove);
 
 static ssize_t blk_dropped_read(struct file *filp, char __user *buffer,
<span class="p_chunk">@@ -536,9 +547,8 @@</span> <span class="p_context"> int do_blk_trace_setup(struct request_queue *q, char *name, dev_t dev,</span>
 	return ret;
 }
 
<span class="p_del">-int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,</span>
<span class="p_del">-		    struct block_device *bdev,</span>
<span class="p_del">-		    char __user *arg)</span>
<span class="p_add">+static int __blk_trace_setup(struct request_queue *q, char *name, dev_t dev,</span>
<span class="p_add">+			     struct block_device *bdev, char __user *arg)</span>
 {
 	struct blk_user_trace_setup buts;
 	int ret;
<span class="p_chunk">@@ -557,6 +567,19 @@</span> <span class="p_context"> int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,</span>
 	}
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+int blk_trace_setup(struct request_queue *q, char *name, dev_t dev,</span>
<span class="p_add">+		    struct block_device *bdev,</span>
<span class="p_add">+		    char __user *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+	ret = __blk_trace_setup(q, name, dev, bdev, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(blk_trace_setup);
 
 #if defined(CONFIG_COMPAT) &amp;&amp; defined(CONFIG_X86_64)
<span class="p_chunk">@@ -593,7 +616,7 @@</span> <span class="p_context"> static int compat_blk_trace_setup(struct request_queue *q, char *name,</span>
 }
 #endif
 
<span class="p_del">-int blk_trace_startstop(struct request_queue *q, int start)</span>
<span class="p_add">+static int __blk_trace_startstop(struct request_queue *q, int start)</span>
 {
 	int ret;
 	struct blk_trace *bt = q-&gt;blk_trace;
<span class="p_chunk">@@ -632,8 +655,25 @@</span> <span class="p_context"> int blk_trace_startstop(struct request_queue *q, int start)</span>
 
 	return ret;
 }
<span class="p_add">+</span>
<span class="p_add">+int blk_trace_startstop(struct request_queue *q, int start)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+	ret = __blk_trace_startstop(q, start);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(blk_trace_startstop);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * When reading or writing the blktrace sysfs files, the references to the</span>
<span class="p_add">+ * opened sysfs or device files should prevent the underlying block device</span>
<span class="p_add">+ * from being removed. So no further delete protection is really needed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 /**
  * blk_trace_ioctl: - handle the ioctls associated with tracing
  * @bdev:	the block device
<span class="p_chunk">@@ -651,12 +691,12 @@</span> <span class="p_context"> int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)</span>
 	if (!q)
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
 
 	switch (cmd) {
 	case BLKTRACESETUP:
 		bdevname(bdev, b);
<span class="p_del">-		ret = blk_trace_setup(q, b, bdev-&gt;bd_dev, bdev, arg);</span>
<span class="p_add">+		ret = __blk_trace_setup(q, b, bdev-&gt;bd_dev, bdev, arg);</span>
 		break;
 #if defined(CONFIG_COMPAT) &amp;&amp; defined(CONFIG_X86_64)
 	case BLKTRACESETUP32:
<span class="p_chunk">@@ -667,17 +707,17 @@</span> <span class="p_context"> int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)</span>
 	case BLKTRACESTART:
 		start = 1;
 	case BLKTRACESTOP:
<span class="p_del">-		ret = blk_trace_startstop(q, start);</span>
<span class="p_add">+		ret = __blk_trace_startstop(q, start);</span>
 		break;
 	case BLKTRACETEARDOWN:
<span class="p_del">-		ret = blk_trace_remove(q);</span>
<span class="p_add">+		ret = __blk_trace_remove(q);</span>
 		break;
 	default:
 		ret = -ENOTTY;
 		break;
 	}
 
<span class="p_del">-	mutex_unlock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -688,10 +728,14 @@</span> <span class="p_context"> int blk_trace_ioctl(struct block_device *bdev, unsigned cmd, char __user *arg)</span>
  **/
 void blk_trace_shutdown(struct request_queue *q)
 {
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
<span class="p_add">+</span>
 	if (q-&gt;blk_trace) {
<span class="p_del">-		blk_trace_startstop(q, 0);</span>
<span class="p_del">-		blk_trace_remove(q);</span>
<span class="p_add">+		__blk_trace_startstop(q, 0);</span>
<span class="p_add">+		__blk_trace_remove(q);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
 }
 
 /*
<span class="p_chunk">@@ -1670,7 +1714,7 @@</span> <span class="p_context"> static ssize_t sysfs_blk_trace_attr_show(struct device *dev,</span>
 	if (q == NULL)
 		goto out_bdput;
 
<span class="p_del">-	mutex_lock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
 
 	if (attr == &amp;dev_attr_enable) {
 		ret = sprintf(buf, &quot;%u\n&quot;, !!q-&gt;blk_trace);
<span class="p_chunk">@@ -1689,7 +1733,7 @@</span> <span class="p_context"> static ssize_t sysfs_blk_trace_attr_show(struct device *dev,</span>
 		ret = sprintf(buf, &quot;%llu\n&quot;, q-&gt;blk_trace-&gt;end_lba);
 
 out_unlock_bdev:
<span class="p_del">-	mutex_unlock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
 out_bdput:
 	bdput(bdev);
 out:
<span class="p_chunk">@@ -1731,7 +1775,7 @@</span> <span class="p_context"> static ssize_t sysfs_blk_trace_attr_store(struct device *dev,</span>
 	if (q == NULL)
 		goto out_bdput;
 
<span class="p_del">-	mutex_lock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;q-&gt;blk_trace_mutex);</span>
 
 	if (attr == &amp;dev_attr_enable) {
 		if (value)
<span class="p_chunk">@@ -1757,7 +1801,7 @@</span> <span class="p_context"> static ssize_t sysfs_blk_trace_attr_store(struct device *dev,</span>
 	}
 
 out_unlock_bdev:
<span class="p_del">-	mutex_unlock(&amp;bdev-&gt;bd_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;q-&gt;blk_trace_mutex);</span>
 out_bdput:
 	bdput(bdev);
 out:
<span class="p_header">diff --git a/lib/int_sqrt.c b/lib/int_sqrt.c</span>
<span class="p_header">index 1ef4cc344977..1afb545a37c5 100644</span>
<span class="p_header">--- a/lib/int_sqrt.c</span>
<span class="p_header">+++ b/lib/int_sqrt.c</span>
<span class="p_chunk">@@ -22,6 +22,9 @@</span> <span class="p_context"> unsigned long int_sqrt(unsigned long x)</span>
 		return x;
 
 	m = 1UL &lt;&lt; (BITS_PER_LONG - 2);
<span class="p_add">+	while (m &gt; x)</span>
<span class="p_add">+		m &gt;&gt;= 2;</span>
<span class="p_add">+</span>
 	while (m != 0) {
 		b = y + m;
 		y &gt;&gt;= 1;
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index 1a39a660dd18..90295cc94b82 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -753,8 +753,7 @@</span> <span class="p_context"> p9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...)</span>
 	}
 again:
 	/* Wait for the response */
<span class="p_del">-	err = wait_event_interruptible(*req-&gt;wq,</span>
<span class="p_del">-				       req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
<span class="p_add">+	err = wait_event_killable(*req-&gt;wq, req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
 
 	/*
 	 * Make sure our req is coherent with regard to updates in other
<span class="p_header">diff --git a/net/9p/trans_virtio.c b/net/9p/trans_virtio.c</span>
<span class="p_header">index 6940d8fe8971..2121d9e5f801 100644</span>
<span class="p_header">--- a/net/9p/trans_virtio.c</span>
<span class="p_header">+++ b/net/9p/trans_virtio.c</span>
<span class="p_chunk">@@ -292,8 +292,8 @@</span> <span class="p_context"> p9_virtio_request(struct p9_client *client, struct p9_req_t *req)</span>
 		if (err == -ENOSPC) {
 			chan-&gt;ring_bufs_avail = 0;
 			spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
<span class="p_del">-			err = wait_event_interruptible(*chan-&gt;vc_wq,</span>
<span class="p_del">-							chan-&gt;ring_bufs_avail);</span>
<span class="p_add">+			err = wait_event_killable(*chan-&gt;vc_wq,</span>
<span class="p_add">+						  chan-&gt;ring_bufs_avail);</span>
 			if (err  == -ERESTARTSYS)
 				return err;
 
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> static int p9_get_mapped_pages(struct virtio_chan *chan,</span>
 		 * Other zc request to finish here
 		 */
 		if (atomic_read(&amp;vp_pinned) &gt;= chan-&gt;p9_max_pages) {
<span class="p_del">-			err = wait_event_interruptible(vp_wq,</span>
<span class="p_add">+			err = wait_event_killable(vp_wq,</span>
 			      (atomic_read(&amp;vp_pinned) &lt; chan-&gt;p9_max_pages));
 			if (err == -ERESTARTSYS)
 				return err;
<span class="p_chunk">@@ -454,8 +454,8 @@</span> <span class="p_context"> p9_virtio_zc_request(struct p9_client *client, struct p9_req_t *req,</span>
 		if (err == -ENOSPC) {
 			chan-&gt;ring_bufs_avail = 0;
 			spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
<span class="p_del">-			err = wait_event_interruptible(*chan-&gt;vc_wq,</span>
<span class="p_del">-						       chan-&gt;ring_bufs_avail);</span>
<span class="p_add">+			err = wait_event_killable(*chan-&gt;vc_wq,</span>
<span class="p_add">+						  chan-&gt;ring_bufs_avail);</span>
 			if (err  == -ERESTARTSYS)
 				goto err_out;
 
<span class="p_chunk">@@ -472,8 +472,7 @@</span> <span class="p_context"> p9_virtio_zc_request(struct p9_client *client, struct p9_req_t *req,</span>
 	virtqueue_kick(chan-&gt;vq);
 	spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
 	p9_debug(P9_DEBUG_TRANS, &quot;virtio request kicked\n&quot;);
<span class="p_del">-	err = wait_event_interruptible(*req-&gt;wq,</span>
<span class="p_del">-				       req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
<span class="p_add">+	err = wait_event_killable(*req-&gt;wq, req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
 	/*
 	 * Non kernel buffers are pinned, unpin them
 	 */
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index 0dbc437958ec..3be30519e741 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -3349,9 +3349,10 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_del">-			remote_efs = 1;</span>
<span class="p_del">-			if (olen == sizeof(efs))</span>
<span class="p_add">+			if (olen == sizeof(efs)) {</span>
<span class="p_add">+				remote_efs = 1;</span>
 				memcpy(&amp;efs, (void *) val, olen);
<span class="p_add">+			}</span>
 			break;
 
 		case L2CAP_CONF_EWS:
<span class="p_chunk">@@ -3570,16 +3571,17 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_del">-			if (olen == sizeof(efs))</span>
<span class="p_add">+			if (olen == sizeof(efs)) {</span>
 				memcpy(&amp;efs, (void *)val, olen);
 
<span class="p_del">-			if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;</span>
<span class="p_del">-			    efs.stype != L2CAP_SERV_NOTRAFIC &amp;&amp;</span>
<span class="p_del">-			    efs.stype != chan-&gt;local_stype)</span>
<span class="p_del">-				return -ECONNREFUSED;</span>
<span class="p_add">+				if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;</span>
<span class="p_add">+				    efs.stype != L2CAP_SERV_NOTRAFIC &amp;&amp;</span>
<span class="p_add">+				    efs.stype != chan-&gt;local_stype)</span>
<span class="p_add">+					return -ECONNREFUSED;</span>
 
<span class="p_del">-			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),</span>
<span class="p_del">-					   (unsigned long) &amp;efs, endptr - ptr);</span>
<span class="p_add">+				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
<span class="p_add">+			}</span>
 			break;
 
 		case L2CAP_CONF_FCS:
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index d0c1d3781b1d..a7c1d6f798ea 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -623,9 +623,12 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	struct fnhe_hash_bucket *hash;
 	struct fib_nh_exception *fnhe;
 	struct rtable *rt;
<span class="p_add">+	u32 genid, hval;</span>
 	unsigned int i;
 	int depth;
<span class="p_del">-	u32 hval = fnhe_hashfun(daddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+	hval = fnhe_hashfun(daddr);</span>
 
 	spin_lock_bh(&amp;fnhe_lock);
 
<span class="p_chunk">@@ -648,12 +651,13 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 	}
 
 	if (fnhe) {
<span class="p_add">+		if (fnhe-&gt;fnhe_genid != genid)</span>
<span class="p_add">+			fnhe-&gt;fnhe_genid = genid;</span>
 		if (gw)
 			fnhe-&gt;fnhe_gw = gw;
<span class="p_del">-		if (pmtu) {</span>
<span class="p_add">+		if (pmtu)</span>
 			fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_del">-			fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		fnhe-&gt;fnhe_expires = max(1UL, expires);</span>
 		/* Update all cached dsts too */
 		rt = rcu_dereference(fnhe-&gt;fnhe_rth_input);
 		if (rt)
<span class="p_chunk">@@ -672,7 +676,7 @@</span> <span class="p_context"> static void update_or_create_fnhe(struct fib_nh *nh, __be32 daddr, __be32 gw,</span>
 			fnhe-&gt;fnhe_next = hash-&gt;chain;
 			rcu_assign_pointer(hash-&gt;chain, fnhe);
 		}
<span class="p_del">-		fnhe-&gt;fnhe_genid = fnhe_genid(dev_net(nh-&gt;nh_dev));</span>
<span class="p_add">+		fnhe-&gt;fnhe_genid = genid;</span>
 		fnhe-&gt;fnhe_daddr = daddr;
 		fnhe-&gt;fnhe_gw = gw;
 		fnhe-&gt;fnhe_pmtu = pmtu;
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 1f3677610ad7..c79d70b77402 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -370,8 +370,8 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_session_get_by_ifname);
 
<span class="p_del">-static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
<span class="p_del">-				      struct l2tp_session *session)</span>
<span class="p_add">+int l2tp_session_register(struct l2tp_session *session,</span>
<span class="p_add">+			  struct l2tp_tunnel *tunnel)</span>
 {
 	struct l2tp_session *session_walk;
 	struct hlist_head *g_head;
<span class="p_chunk">@@ -419,6 +419,10 @@</span> <span class="p_context"> static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
 	hlist_add_head(&amp;session-&gt;hlist, head);
 	write_unlock_bh(&amp;tunnel-&gt;hlist_lock);
 
<span class="p_add">+	/* Ignore management session in session count value */</span>
<span class="p_add">+	if (session-&gt;session_id != 0)</span>
<span class="p_add">+		atomic_inc(&amp;l2tp_session_count);</span>
<span class="p_add">+</span>
 	return 0;
 
 err_tlock_pnlock:
<span class="p_chunk">@@ -428,6 +432,7 @@</span> <span class="p_context"> static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
 
 	return err;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_session_register);</span>
 
 /* Lookup a tunnel by id
  */
<span class="p_chunk">@@ -1868,7 +1873,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_session_set_header_len);</span>
 struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)
 {
 	struct l2tp_session *session;
<span class="p_del">-	int err;</span>
 
 	session = kzalloc(sizeof(struct l2tp_session) + priv_size, GFP_KERNEL);
 	if (session != NULL) {
<span class="p_chunk">@@ -1926,17 +1930,6 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 
 		l2tp_session_inc_refcount(session);
 
<span class="p_del">-		err = l2tp_session_add_to_tunnel(tunnel, session);</span>
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			kfree(session);</span>
<span class="p_del">-</span>
<span class="p_del">-			return ERR_PTR(err);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ignore management session in session count value */</span>
<span class="p_del">-		if (session-&gt;session_id != 0)</span>
<span class="p_del">-			atomic_inc(&amp;l2tp_session_count);</span>
<span class="p_del">-</span>
 		return session;
 	}
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index b56ca9346038..faa2d3e2f9bd 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -274,6 +274,9 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size,</span>
 					 struct l2tp_tunnel *tunnel,
 					 u32 session_id, u32 peer_session_id,
 					 struct l2tp_session_cfg *cfg);
<span class="p_add">+int l2tp_session_register(struct l2tp_session *session,</span>
<span class="p_add">+			  struct l2tp_tunnel *tunnel);</span>
<span class="p_add">+</span>
 void __l2tp_session_unhash(struct l2tp_session *session);
 int l2tp_session_delete(struct l2tp_session *session);
 void l2tp_session_free(struct l2tp_session *session);
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index a719bf9afb04..6355fd449412 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> struct l2tp_eth {</span>
 
 /* via l2tp_session_priv() */
 struct l2tp_eth_sess {
<span class="p_del">-	struct net_device	*dev;</span>
<span class="p_add">+	struct net_device __rcu *dev;</span>
 };
 
 
<span class="p_chunk">@@ -69,7 +69,14 @@</span> <span class="p_context"> static int l2tp_eth_dev_init(struct net_device *dev)</span>
 
 static void l2tp_eth_dev_uninit(struct net_device *dev)
 {
<span class="p_del">-	dev_put(dev);</span>
<span class="p_add">+	struct l2tp_eth *priv = netdev_priv(dev);</span>
<span class="p_add">+	struct l2tp_eth_sess *spriv;</span>
<span class="p_add">+</span>
<span class="p_add">+	spriv = l2tp_session_priv(priv-&gt;session);</span>
<span class="p_add">+	RCU_INIT_POINTER(spriv-&gt;dev, NULL);</span>
<span class="p_add">+	/* No need for synchronize_net() here. We&#39;re called by</span>
<span class="p_add">+	 * unregister_netdev*(), which does the synchronisation for us.</span>
<span class="p_add">+	 */</span>
 }
 
 static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)
<span class="p_chunk">@@ -123,8 +130,8 @@</span> <span class="p_context"> static void l2tp_eth_dev_setup(struct net_device *dev)</span>
 static void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)
 {
 	struct l2tp_eth_sess *spriv = l2tp_session_priv(session);
<span class="p_del">-	struct net_device *dev = spriv-&gt;dev;</span>
<span class="p_del">-	struct l2tp_eth *priv = netdev_priv(dev);</span>
<span class="p_add">+	struct net_device *dev;</span>
<span class="p_add">+	struct l2tp_eth *priv;</span>
 
 	if (session-&gt;debug &amp; L2TP_MSG_DATA) {
 		unsigned int length;
<span class="p_chunk">@@ -148,16 +155,25 @@</span> <span class="p_context"> static void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb,</span>
 	skb_dst_drop(skb);
 	nf_reset(skb);
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	dev = rcu_dereference(spriv-&gt;dev);</span>
<span class="p_add">+	if (!dev)</span>
<span class="p_add">+		goto error_rcu;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = netdev_priv(dev);</span>
 	if (dev_forward_skb(dev, skb) == NET_RX_SUCCESS) {
 		atomic_long_inc(&amp;priv-&gt;rx_packets);
 		atomic_long_add(data_len, &amp;priv-&gt;rx_bytes);
 	} else {
 		atomic_long_inc(&amp;priv-&gt;rx_errors);
 	}
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	return;
 
<span class="p_add">+error_rcu:</span>
<span class="p_add">+	rcu_read_unlock();</span>
 error:
<span class="p_del">-	atomic_long_inc(&amp;priv-&gt;rx_errors);</span>
 	kfree_skb(skb);
 }
 
<span class="p_chunk">@@ -168,11 +184,15 @@</span> <span class="p_context"> static void l2tp_eth_delete(struct l2tp_session *session)</span>
 
 	if (session) {
 		spriv = l2tp_session_priv(session);
<span class="p_del">-		dev = spriv-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+		rtnl_lock();</span>
<span class="p_add">+		dev = rtnl_dereference(spriv-&gt;dev);</span>
 		if (dev) {
<span class="p_del">-			unregister_netdev(dev);</span>
<span class="p_del">-			spriv-&gt;dev = NULL;</span>
<span class="p_add">+			unregister_netdevice(dev);</span>
<span class="p_add">+			rtnl_unlock();</span>
 			module_put(THIS_MODULE);
<span class="p_add">+		} else {</span>
<span class="p_add">+			rtnl_unlock();</span>
 		}
 	}
 }
<span class="p_chunk">@@ -182,9 +202,20 @@</span> <span class="p_context"> static void l2tp_eth_show(struct seq_file *m, void *arg)</span>
 {
 	struct l2tp_session *session = arg;
 	struct l2tp_eth_sess *spriv = l2tp_session_priv(session);
<span class="p_del">-	struct net_device *dev = spriv-&gt;dev;</span>
<span class="p_add">+	struct net_device *dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	dev = rcu_dereference(spriv-&gt;dev);</span>
<span class="p_add">+	if (!dev) {</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dev_hold(dev);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
 	seq_printf(m, &quot;   interface %s\n&quot;, dev-&gt;name);
<span class="p_add">+</span>
<span class="p_add">+	dev_put(dev);</span>
 }
 #endif
 
<span class="p_chunk">@@ -204,7 +235,7 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 		if (dev) {
 			dev_put(dev);
 			rc = -EEXIST;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto err;</span>
 		}
 		strlcpy(name, cfg-&gt;ifname, IFNAMSIZ);
 	} else
<span class="p_chunk">@@ -214,13 +245,13 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 				      peer_session_id, cfg);
 	if (IS_ERR(session)) {
 		rc = PTR_ERR(session);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	dev = alloc_netdev(sizeof(*priv), name, l2tp_eth_dev_setup);
 	if (!dev) {
 		rc = -ENOMEM;
<span class="p_del">-		goto out_del_session;</span>
<span class="p_add">+		goto err_sess;</span>
 	}
 
 	dev_net_set(dev, net);
<span class="p_chunk">@@ -241,26 +272,48 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 #endif
 
 	spriv = l2tp_session_priv(session);
<span class="p_del">-	spriv-&gt;dev = dev;</span>
 
<span class="p_del">-	rc = register_netdev(dev);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		goto out_del_dev;</span>
<span class="p_add">+	l2tp_session_inc_refcount(session);</span>
<span class="p_add">+</span>
<span class="p_add">+	rtnl_lock();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Register both device and session while holding the rtnl lock. This</span>
<span class="p_add">+	 * ensures that l2tp_eth_delete() will see that there&#39;s a device to</span>
<span class="p_add">+	 * unregister, even if it happened to run before we assign spriv-&gt;dev.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = l2tp_session_register(session, tunnel);</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		rtnl_unlock();</span>
<span class="p_add">+		goto err_sess_dev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = register_netdevice(dev);</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		rtnl_unlock();</span>
<span class="p_add">+		l2tp_session_delete(session);</span>
<span class="p_add">+		l2tp_session_dec_refcount(session);</span>
<span class="p_add">+		free_netdev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	__module_get(THIS_MODULE);</span>
<span class="p_del">-	/* Must be done after register_netdev() */</span>
 	strlcpy(session-&gt;ifname, dev-&gt;name, IFNAMSIZ);
<span class="p_add">+	rcu_assign_pointer(spriv-&gt;dev, dev);</span>
 
<span class="p_del">-	dev_hold(dev);</span>
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+</span>
<span class="p_add">+	__module_get(THIS_MODULE);</span>
 
 	return 0;
 
<span class="p_del">-out_del_dev:</span>
<span class="p_add">+err_sess_dev:</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
 	free_netdev(dev);
<span class="p_del">-	spriv-&gt;dev = NULL;</span>
<span class="p_del">-out_del_session:</span>
<span class="p_del">-	l2tp_session_delete(session);</span>
<span class="p_del">-out:</span>
<span class="p_add">+err_sess:</span>
<span class="p_add">+	kfree(session);</span>
<span class="p_add">+err:</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index 22d74e6b6461..8d6e261704df 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -122,8 +122,11 @@</span> <span class="p_context"></span>
 struct pppol2tp_session {
 	int			owner;		/* pid that opened the socket */
 
<span class="p_del">-	struct sock		*sock;		/* Pointer to the session</span>
<span class="p_add">+	struct mutex		sk_lock;	/* Protects .sk */</span>
<span class="p_add">+	struct sock __rcu	*sk;		/* Pointer to the session</span>
 						 * PPPoX socket */
<span class="p_add">+	struct sock		*__sk;		/* Copy of .sk, for cleanup */</span>
<span class="p_add">+	struct rcu_head		rcu;		/* For asynchronous release */</span>
 	struct sock		*tunnel_sock;	/* Pointer to the tunnel UDP
 						 * socket */
 	int			flags;		/* accessed by PPPIOCGFLAGS.
<span class="p_chunk">@@ -138,6 +141,24 @@</span> <span class="p_context"> static const struct ppp_channel_ops pppol2tp_chan_ops = {</span>
 
 static const struct proto_ops pppol2tp_ops;
 
<span class="p_add">+/* Retrieves the pppol2tp socket associated to a session.</span>
<span class="p_add">+ * A reference is held on the returned socket, so this function must be paired</span>
<span class="p_add">+ * with sock_put().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sock *pppol2tp_session_get_sock(struct l2tp_session *session)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	sk = rcu_dereference(ps-&gt;sk);</span>
<span class="p_add">+	if (sk)</span>
<span class="p_add">+		sock_hold(sk);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	return sk;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Helpers to obtain tunnel/session contexts from sockets.
  */
 static inline struct l2tp_session *pppol2tp_sock_to_session(struct sock *sk)
<span class="p_chunk">@@ -225,7 +246,8 @@</span> <span class="p_context"> static void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int</span>
 	/* If the socket is bound, send it in to PPP&#39;s input queue. Otherwise
 	 * queue it on the session socket.
 	 */
<span class="p_del">-	sk = ps-&gt;sock;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	sk = rcu_dereference(ps-&gt;sk);</span>
 	if (sk == NULL)
 		goto no_sock;
 
<span class="p_chunk">@@ -263,30 +285,16 @@</span> <span class="p_context"> static void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int</span>
 			kfree_skb(skb);
 		}
 	}
<span class="p_add">+	rcu_read_unlock();</span>
 
 	return;
 
 no_sock:
<span class="p_add">+	rcu_read_unlock();</span>
 	l2tp_info(session, PPPOL2TP_MSG_DATA, &quot;%s: no socket\n&quot;, session-&gt;name);
 	kfree_skb(skb);
 }
 
<span class="p_del">-static void pppol2tp_session_sock_hold(struct l2tp_session *session)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ps-&gt;sock)</span>
<span class="p_del">-		sock_hold(ps-&gt;sock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pppol2tp_session_sock_put(struct l2tp_session *session)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ps-&gt;sock)</span>
<span class="p_del">-		sock_put(ps-&gt;sock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /************************************************************************
  * Transmit handling
  ***********************************************************************/
<span class="p_chunk">@@ -450,16 +458,15 @@</span> <span class="p_context"> static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)</span>
  */
 static void pppol2tp_session_close(struct l2tp_session *session)
 {
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_del">-	struct sock *sk = ps-&gt;sock;</span>
<span class="p_del">-	struct socket *sock = sk-&gt;sk_socket;</span>
<span class="p_add">+	struct sock *sk;</span>
 
 	BUG_ON(session-&gt;magic != L2TP_SESSION_MAGIC);
 
<span class="p_del">-	if (sock) {</span>
<span class="p_del">-		inet_shutdown(sock, 2);</span>
<span class="p_del">-		/* Don&#39;t let the session go away before our socket does */</span>
<span class="p_del">-		l2tp_session_inc_refcount(session);</span>
<span class="p_add">+	sk = pppol2tp_session_get_sock(session);</span>
<span class="p_add">+	if (sk) {</span>
<span class="p_add">+		if (sk-&gt;sk_socket)</span>
<span class="p_add">+			inet_shutdown(sk-&gt;sk_socket, SEND_SHUTDOWN);</span>
<span class="p_add">+		sock_put(sk);</span>
 	}
 }
 
<span class="p_chunk">@@ -480,6 +487,14 @@</span> <span class="p_context"> static void pppol2tp_session_destruct(struct sock *sk)</span>
 	}
 }
 
<span class="p_add">+static void pppol2tp_put_sk(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pppol2tp_session *ps;</span>
<span class="p_add">+</span>
<span class="p_add">+	ps = container_of(head, typeof(*ps), rcu);</span>
<span class="p_add">+	sock_put(ps-&gt;__sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Called when the PPPoX socket (session) is closed.
  */
 static int pppol2tp_release(struct socket *sock)
<span class="p_chunk">@@ -505,11 +520,23 @@</span> <span class="p_context"> static int pppol2tp_release(struct socket *sock)</span>
 
 	session = pppol2tp_sock_to_session(sk);
 
<span class="p_del">-	/* Purge any queued data */</span>
 	if (session != NULL) {
<span class="p_del">-		__l2tp_session_unhash(session);</span>
<span class="p_del">-		l2tp_session_queue_purge(session);</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_add">+		struct pppol2tp_session *ps;</span>
<span class="p_add">+</span>
<span class="p_add">+		l2tp_session_delete(session);</span>
<span class="p_add">+</span>
<span class="p_add">+		ps = l2tp_session_priv(session);</span>
<span class="p_add">+		mutex_lock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+		ps-&gt;__sk = rcu_dereference_protected(ps-&gt;sk,</span>
<span class="p_add">+						     lockdep_is_held(&amp;ps-&gt;sk_lock));</span>
<span class="p_add">+		RCU_INIT_POINTER(ps-&gt;sk, NULL);</span>
<span class="p_add">+		mutex_unlock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+		call_rcu(&amp;ps-&gt;rcu, pppol2tp_put_sk);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Rely on the sock_put() call at the end of the function for</span>
<span class="p_add">+		 * dropping the reference held by pppol2tp_sock_to_session().</span>
<span class="p_add">+		 * The last reference will be dropped by pppol2tp_put_sk().</span>
<span class="p_add">+		 */</span>
 	}
 	release_sock(sk);
 
<span class="p_chunk">@@ -576,16 +603,47 @@</span> <span class="p_context"> static int pppol2tp_create(struct net *net, struct socket *sock)</span>
 static void pppol2tp_show(struct seq_file *m, void *arg)
 {
 	struct l2tp_session *session = arg;
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk = pppol2tp_session_get_sock(session);</span>
<span class="p_add">+	if (sk) {</span>
<span class="p_add">+		struct pppox_sock *po = pppox_sk(sk);</span>
 
<span class="p_del">-	if (ps) {</span>
<span class="p_del">-		struct pppox_sock *po = pppox_sk(ps-&gt;sock);</span>
<span class="p_del">-		if (po)</span>
<span class="p_del">-			seq_printf(m, &quot;   interface %s\n&quot;, ppp_dev_name(&amp;po-&gt;chan));</span>
<span class="p_add">+		seq_printf(m, &quot;   interface %s\n&quot;, ppp_dev_name(&amp;po-&gt;chan));</span>
<span class="p_add">+		sock_put(sk);</span>
 	}
 }
 #endif
 
<span class="p_add">+static void pppol2tp_session_init(struct l2tp_session *session)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pppol2tp_session *ps;</span>
<span class="p_add">+	struct dst_entry *dst;</span>
<span class="p_add">+</span>
<span class="p_add">+	session-&gt;recv_skb = pppol2tp_recv;</span>
<span class="p_add">+	session-&gt;session_close = pppol2tp_session_close;</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_L2TP_DEBUGFS)</span>
<span class="p_add">+	session-&gt;show = pppol2tp_show;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	ps = l2tp_session_priv(session);</span>
<span class="p_add">+	mutex_init(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+	ps-&gt;tunnel_sock = session-&gt;tunnel-&gt;sock;</span>
<span class="p_add">+	ps-&gt;owner = current-&gt;pid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If PMTU discovery was enabled, use the MTU that was discovered */</span>
<span class="p_add">+	dst = sk_dst_get(session-&gt;tunnel-&gt;sock);</span>
<span class="p_add">+	if (dst) {</span>
<span class="p_add">+		u32 pmtu = dst_mtu(dst);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pmtu) {</span>
<span class="p_add">+			session-&gt;mtu = pmtu - PPPOL2TP_HEADER_OVERHEAD;</span>
<span class="p_add">+			session-&gt;mru = pmtu - PPPOL2TP_HEADER_OVERHEAD;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		dst_release(dst);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* connect() handler. Attach a PPPoX socket to a tunnel UDP socket
  */
 static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,
<span class="p_chunk">@@ -597,7 +655,6 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	struct l2tp_session *session = NULL;
 	struct l2tp_tunnel *tunnel;
 	struct pppol2tp_session *ps;
<span class="p_del">-	struct dst_entry *dst;</span>
 	struct l2tp_session_cfg cfg = { 0, };
 	int error = 0;
 	u32 tunnel_id, peer_tunnel_id;
<span class="p_chunk">@@ -715,13 +772,17 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 		/* Using a pre-existing session is fine as long as it hasn&#39;t
 		 * been connected yet.
 		 */
<span class="p_del">-		if (ps-&gt;sock) {</span>
<span class="p_add">+		mutex_lock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+		if (rcu_dereference_protected(ps-&gt;sk,</span>
<span class="p_add">+					      lockdep_is_held(&amp;ps-&gt;sk_lock))) {</span>
<span class="p_add">+			mutex_unlock(&amp;ps-&gt;sk_lock);</span>
 			error = -EEXIST;
 			goto end;
 		}
 
 		/* consistency checks */
 		if (ps-&gt;tunnel_sock != tunnel-&gt;sock) {
<span class="p_add">+			mutex_unlock(&amp;ps-&gt;sk_lock);</span>
 			error = -EEXIST;
 			goto end;
 		}
<span class="p_chunk">@@ -737,35 +798,19 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 			error = PTR_ERR(session);
 			goto end;
 		}
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Associate session with its PPPoL2TP socket */</span>
<span class="p_del">-	ps = l2tp_session_priv(session);</span>
<span class="p_del">-	ps-&gt;owner	     = current-&gt;pid;</span>
<span class="p_del">-	ps-&gt;sock	     = sk;</span>
<span class="p_del">-	ps-&gt;tunnel_sock = tunnel-&gt;sock;</span>
<span class="p_del">-</span>
<span class="p_del">-	session-&gt;recv_skb	= pppol2tp_recv;</span>
<span class="p_del">-	session-&gt;session_close	= pppol2tp_session_close;</span>
<span class="p_del">-#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)</span>
<span class="p_del">-	session-&gt;show		= pppol2tp_show;</span>
<span class="p_del">-#endif</span>
 
<span class="p_del">-	/* We need to know each time a skb is dropped from the reorder</span>
<span class="p_del">-	 * queue.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	session-&gt;ref = pppol2tp_session_sock_hold;</span>
<span class="p_del">-	session-&gt;deref = pppol2tp_session_sock_put;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If PMTU discovery was enabled, use the MTU that was discovered */</span>
<span class="p_del">-	dst = sk_dst_get(tunnel-&gt;sock);</span>
<span class="p_del">-	if (dst != NULL) {</span>
<span class="p_del">-		u32 pmtu = dst_mtu(dst);</span>
<span class="p_add">+		pppol2tp_session_init(session);</span>
<span class="p_add">+		ps = l2tp_session_priv(session);</span>
<span class="p_add">+		l2tp_session_inc_refcount(session);</span>
 
<span class="p_del">-		if (pmtu != 0)</span>
<span class="p_del">-			session-&gt;mtu = session-&gt;mru = pmtu -</span>
<span class="p_del">-				PPPOL2TP_HEADER_OVERHEAD;</span>
<span class="p_del">-		dst_release(dst);</span>
<span class="p_add">+		mutex_lock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+		error = l2tp_session_register(session, tunnel);</span>
<span class="p_add">+		if (error &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+			kfree(session);</span>
<span class="p_add">+			goto end;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		drop_refcnt = true;</span>
 	}
 
 	/* Special case: if source &amp; dest session_id == 0x0000, this
<span class="p_chunk">@@ -790,12 +835,23 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	po-&gt;chan.mtu	 = session-&gt;mtu;
 
 	error = ppp_register_net_channel(sock_net(sk), &amp;po-&gt;chan);
<span class="p_del">-	if (error)</span>
<span class="p_add">+	if (error) {</span>
<span class="p_add">+		mutex_unlock(&amp;ps-&gt;sk_lock);</span>
 		goto end;
<span class="p_add">+	}</span>
 
 out_no_ppp:
 	/* This is how we get the session context from the socket. */
 	sk-&gt;sk_user_data = session;
<span class="p_add">+	rcu_assign_pointer(ps-&gt;sk, sk);</span>
<span class="p_add">+	mutex_unlock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Keep the reference we&#39;ve grabbed on the session: sk doesn&#39;t expect</span>
<span class="p_add">+	 * the session to disappear. pppol2tp_session_destruct() is responsible</span>
<span class="p_add">+	 * for dropping it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	drop_refcnt = false;</span>
<span class="p_add">+</span>
 	sk-&gt;sk_state = PPPOX_CONNECTED;
 	l2tp_info(session, PPPOL2TP_MSG_CONTROL, &quot;%s: created\n&quot;,
 		  session-&gt;name);
<span class="p_chunk">@@ -819,12 +875,11 @@</span> <span class="p_context"> static int pppol2tp_session_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 {
 	int error;
 	struct l2tp_session *session;
<span class="p_del">-	struct pppol2tp_session *ps;</span>
 
 	/* Error if tunnel socket is not prepped */
 	if (!tunnel-&gt;sock) {
 		error = -ENOENT;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	/* Default MTU values. */
<span class="p_chunk">@@ -839,18 +894,20 @@</span> <span class="p_context"> static int pppol2tp_session_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
 				      peer_session_id, cfg);
 	if (IS_ERR(session)) {
 		error = PTR_ERR(session);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
<span class="p_del">-	ps = l2tp_session_priv(session);</span>
<span class="p_del">-	ps-&gt;tunnel_sock = tunnel-&gt;sock;</span>
<span class="p_add">+	pppol2tp_session_init(session);</span>
 
<span class="p_del">-	l2tp_info(session, PPPOL2TP_MSG_CONTROL, &quot;%s: created\n&quot;,</span>
<span class="p_del">-		  session-&gt;name);</span>
<span class="p_add">+	error = l2tp_session_register(session, tunnel);</span>
<span class="p_add">+	if (error &lt; 0)</span>
<span class="p_add">+		goto err_sess;</span>
 
<span class="p_del">-	error = 0;</span>
<span class="p_add">+	return 0;</span>
 
<span class="p_del">-out:</span>
<span class="p_add">+err_sess:</span>
<span class="p_add">+	kfree(session);</span>
<span class="p_add">+err:</span>
 	return error;
 }
 
<span class="p_chunk">@@ -1011,12 +1068,10 @@</span> <span class="p_context"> static int pppol2tp_session_ioctl(struct l2tp_session *session,</span>
 		 &quot;%s: pppol2tp_session_ioctl(cmd=%#x, arg=%#lx)\n&quot;,
 		 session-&gt;name, cmd, arg);
 
<span class="p_del">-	sk = ps-&gt;sock;</span>
<span class="p_add">+	sk = pppol2tp_session_get_sock(session);</span>
 	if (!sk)
 		return -EBADR;
 
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_del">-</span>
 	switch (cmd) {
 	case SIOCGIFMTU:
 		err = -ENXIO;
<span class="p_chunk">@@ -1292,7 +1347,6 @@</span> <span class="p_context"> static int pppol2tp_session_setsockopt(struct sock *sk,</span>
 				       int optname, int val)
 {
 	int err = 0;
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
 
 	switch (optname) {
 	case PPPOL2TP_SO_RECVSEQ:
<span class="p_chunk">@@ -1313,8 +1367,8 @@</span> <span class="p_context"> static int pppol2tp_session_setsockopt(struct sock *sk,</span>
 		}
 		session-&gt;send_seq = val ? -1 : 0;
 		{
<span class="p_del">-			struct sock *ssk      = ps-&gt;sock;</span>
<span class="p_del">-			struct pppox_sock *po = pppox_sk(ssk);</span>
<span class="p_add">+			struct pppox_sock *po = pppox_sk(sk);</span>
<span class="p_add">+</span>
 			po-&gt;chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :
 				PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;
 		}
<span class="p_chunk">@@ -1653,8 +1707,9 @@</span> <span class="p_context"> static void pppol2tp_seq_session_show(struct seq_file *m, void *v)</span>
 {
 	struct l2tp_session *session = v;
 	struct l2tp_tunnel *tunnel = session-&gt;tunnel;
<span class="p_del">-	struct pppol2tp_session *ps = l2tp_session_priv(session);</span>
<span class="p_del">-	struct pppox_sock *po = pppox_sk(ps-&gt;sock);</span>
<span class="p_add">+	unsigned char state;</span>
<span class="p_add">+	char user_data_ok;</span>
<span class="p_add">+	struct sock *sk;</span>
 	u32 ip = 0;
 	u16 port = 0;
 
<span class="p_chunk">@@ -1664,6 +1719,15 @@</span> <span class="p_context"> static void pppol2tp_seq_session_show(struct seq_file *m, void *v)</span>
 		port = ntohs(inet-&gt;inet_sport);
 	}
 
<span class="p_add">+	sk = pppol2tp_session_get_sock(session);</span>
<span class="p_add">+	if (sk) {</span>
<span class="p_add">+		state = sk-&gt;sk_state;</span>
<span class="p_add">+		user_data_ok = (session == sk-&gt;sk_user_data) ? &#39;Y&#39; : &#39;N&#39;;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		state = 0;</span>
<span class="p_add">+		user_data_ok = &#39;N&#39;;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	seq_printf(m, &quot;  SESSION &#39;%s&#39; %08X/%d %04X/%04X -&gt; &quot;
 		   &quot;%04X/%04X %d %c\n&quot;,
 		   session-&gt;name, ip, port,
<span class="p_chunk">@@ -1671,9 +1735,7 @@</span> <span class="p_context"> static void pppol2tp_seq_session_show(struct seq_file *m, void *v)</span>
 		   session-&gt;session_id,
 		   tunnel-&gt;peer_tunnel_id,
 		   session-&gt;peer_session_id,
<span class="p_del">-		   ps-&gt;sock-&gt;sk_state,</span>
<span class="p_del">-		   (session == ps-&gt;sock-&gt;sk_user_data) ?</span>
<span class="p_del">-		   &#39;Y&#39; : &#39;N&#39;);</span>
<span class="p_add">+		   state, user_data_ok);</span>
 	seq_printf(m, &quot;   %d/%d/%c/%c/%s %08x %u\n&quot;,
 		   session-&gt;mtu, session-&gt;mru,
 		   session-&gt;recv_seq ? &#39;R&#39; : &#39;-&#39;,
<span class="p_chunk">@@ -1690,8 +1752,12 @@</span> <span class="p_context"> static void pppol2tp_seq_session_show(struct seq_file *m, void *v)</span>
 		   atomic_long_read(&amp;session-&gt;stats.rx_bytes),
 		   atomic_long_read(&amp;session-&gt;stats.rx_errors));
 
<span class="p_del">-	if (po)</span>
<span class="p_add">+	if (sk) {</span>
<span class="p_add">+		struct pppox_sock *po = pppox_sk(sk);</span>
<span class="p_add">+</span>
 		seq_printf(m, &quot;   interface %s\n&quot;, ppp_dev_name(&amp;po-&gt;chan));
<span class="p_add">+		sock_put(sk);</span>
<span class="p_add">+	}</span>
 }
 
 static int pppol2tp_seq_show(struct seq_file *m, void *v)
<span class="p_header">diff --git a/net/netfilter/xt_TCPMSS.c b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">index e762de5ee89b..6531d7039b11 100644</span>
<span class="p_header">--- a/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">+++ b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph-&gt;doff * 4;
 
<span class="p_del">-	if (len &lt; tcp_hdrlen)</span>
<span class="p_add">+	if (len &lt; tcp_hdrlen || tcp_hdrlen &lt; sizeof(struct tcphdr))</span>
 		return -1;
 
 	if (info-&gt;mss == XT_TCPMSS_CLAMP_PMTU) {
<span class="p_chunk">@@ -156,6 +156,10 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	if (len &gt; tcp_hdrlen)
 		return 0;
 
<span class="p_add">+	/* tcph-&gt;doff has 4 bits, do not wrap it to 0 */</span>
<span class="p_add">+	if (tcp_hdrlen &gt;= 15 * 4)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/*
 	 * MSS Option not found ?! add it..
 	 */
<span class="p_header">diff --git a/net/nfc/core.c b/net/nfc/core.c</span>
<span class="p_header">index 2ff3c924b64f..a8e8756878de 100644</span>
<span class="p_header">--- a/net/nfc/core.c</span>
<span class="p_header">+++ b/net/nfc/core.c</span>
<span class="p_chunk">@@ -1074,7 +1074,7 @@</span> <span class="p_context"> struct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,</span>
 err_free_dev:
 	kfree(dev);
 
<span class="p_del">-	return ERR_PTR(rc);</span>
<span class="p_add">+	return NULL;</span>
 }
 EXPORT_SYMBOL(nfc_allocate_device);
 
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 4e37c1cbe8b2..6fcd65a923ea 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -516,6 +516,9 @@</span> <span class="p_context"> int rds_rdma_extra_size(struct rds_rdma_args *args)</span>
 
 	local_vec = (struct rds_iovec __user *)(unsigned long) args-&gt;local_vec_addr;
 
<span class="p_add">+	if (args-&gt;nr_local == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* figure out the number of pages in the vector */
 	for (i = 0; i &lt; args-&gt;nr_local; i++) {
 		if (copy_from_user(&amp;vec, &amp;local_vec[i],
<span class="p_chunk">@@ -852,6 +855,7 @@</span> <span class="p_context"> int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm,</span>
 err:
 	if (page)
 		put_page(page);
<span class="p_add">+	rm-&gt;atomic.op_active = 0;</span>
 	kfree(rm-&gt;atomic.op_notifier);
 
 	return ret;
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 7f47fbdeb414..4128c0d7f845 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static void sctp_v6_from_sk(union sctp_addr *addr, struct sock *sk)</span>
 /* Initialize sk-&gt;sk_rcv_saddr from sctp_addr. */
 static void sctp_v6_to_sk_saddr(union sctp_addr *addr, struct sock *sk)
 {
<span class="p_del">-	if (addr-&gt;sa.sa_family == AF_INET &amp;&amp; sctp_sk(sk)-&gt;v4mapped) {</span>
<span class="p_add">+	if (addr-&gt;sa.sa_family == AF_INET) {</span>
 		sk-&gt;sk_v6_rcv_saddr.s6_addr32[0] = 0;
 		sk-&gt;sk_v6_rcv_saddr.s6_addr32[1] = 0;
 		sk-&gt;sk_v6_rcv_saddr.s6_addr32[2] = htonl(0x0000ffff);
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> static void sctp_v6_to_sk_saddr(union sctp_addr *addr, struct sock *sk)</span>
 /* Initialize sk-&gt;sk_daddr from sctp_addr. */
 static void sctp_v6_to_sk_daddr(union sctp_addr *addr, struct sock *sk)
 {
<span class="p_del">-	if (addr-&gt;sa.sa_family == AF_INET &amp;&amp; sctp_sk(sk)-&gt;v4mapped) {</span>
<span class="p_add">+	if (addr-&gt;sa.sa_family == AF_INET) {</span>
 		sk-&gt;sk_v6_daddr.s6_addr32[0] = 0;
 		sk-&gt;sk_v6_daddr.s6_addr32[1] = 0;
 		sk-&gt;sk_v6_daddr.s6_addr32[2] = htonl(0x0000ffff);
<span class="p_chunk">@@ -491,7 +491,9 @@</span> <span class="p_context"> static void sctp_v6_to_addr(union sctp_addr *addr, struct in6_addr *saddr,</span>
 {
 	addr-&gt;sa.sa_family = AF_INET6;
 	addr-&gt;v6.sin6_port = port;
<span class="p_add">+	addr-&gt;v6.sin6_flowinfo = 0;</span>
 	addr-&gt;v6.sin6_addr = *saddr;
<span class="p_add">+	addr-&gt;v6.sin6_scope_id = 0;</span>
 }
 
 /* Compare addresses exactly.
<span class="p_chunk">@@ -558,8 +560,6 @@</span> <span class="p_context"> static int sctp_v6_available(union sctp_addr *addr, struct sctp_sock *sp)</span>
 	if (IPV6_ADDR_ANY == type)
 		return 1;
 	if (type == IPV6_ADDR_MAPPED) {
<span class="p_del">-		if (sp &amp;&amp; !sp-&gt;v4mapped)</span>
<span class="p_del">-			return 0;</span>
 		if (sp &amp;&amp; ipv6_only_sock(sctp_opt2sk(sp)))
 			return 0;
 		sctp_v6_map_v4(addr);
<span class="p_chunk">@@ -589,8 +589,6 @@</span> <span class="p_context"> static int sctp_v6_addr_valid(union sctp_addr *addr,</span>
 		/* Note: This routine is used in input, so v4-mapped-v6
 		 * are disallowed here when there is no sctp_sock.
 		 */
<span class="p_del">-		if (!sp || !sp-&gt;v4mapped)</span>
<span class="p_del">-			return 0;</span>
 		if (sp &amp;&amp; ipv6_only_sock(sctp_opt2sk(sp)))
 			return 0;
 		sctp_v6_map_v4(addr);
<span class="p_chunk">@@ -688,11 +686,23 @@</span> <span class="p_context"> static struct sock *sctp_v6_create_accept_sk(struct sock *sk,</span>
 	return newsk;
 }
 
<span class="p_del">-/* Map v4 address to mapped v6 address */</span>
<span class="p_del">-static void sctp_v6_addr_v4map(struct sctp_sock *sp, union sctp_addr *addr)</span>
<span class="p_add">+/* Format a sockaddr for return to user space. This makes sure the return is</span>
<span class="p_add">+ * AF_INET or AF_INET6 depending on the SCTP_I_WANT_MAPPED_V4_ADDR option.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int sctp_v6_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)</span>
 {
<span class="p_del">-	if (sp-&gt;v4mapped &amp;&amp; AF_INET == addr-&gt;sa.sa_family)</span>
<span class="p_del">-		sctp_v4_map_v6(addr);</span>
<span class="p_add">+	if (sp-&gt;v4mapped) {</span>
<span class="p_add">+		if (addr-&gt;sa.sa_family == AF_INET)</span>
<span class="p_add">+			sctp_v4_map_v6(addr);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (addr-&gt;sa.sa_family == AF_INET6 &amp;&amp;</span>
<span class="p_add">+		    ipv6_addr_v4mapped(&amp;addr-&gt;v6.sin6_addr))</span>
<span class="p_add">+			sctp_v6_map_v4(addr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (addr-&gt;sa.sa_family == AF_INET)</span>
<span class="p_add">+		return sizeof(struct sockaddr_in);</span>
<span class="p_add">+	return sizeof(struct sockaddr_in6);</span>
 }
 
 /* Where did this skb come from?  */
<span class="p_chunk">@@ -719,82 +729,70 @@</span> <span class="p_context"> static void sctp_v6_ecn_capable(struct sock *sk)</span>
 	inet6_sk(sk)-&gt;tclass |= INET_ECN_ECT_0;
 }
 
<span class="p_del">-/* Initialize a PF_INET6 socket msg_name. */</span>
<span class="p_del">-static void sctp_inet6_msgname(char *msgname, int *addr_len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sockaddr_in6 *sin6;</span>
<span class="p_del">-</span>
<span class="p_del">-	sin6 = (struct sockaddr_in6 *)msgname;</span>
<span class="p_del">-	sin6-&gt;sin6_family = AF_INET6;</span>
<span class="p_del">-	sin6-&gt;sin6_flowinfo = 0;</span>
<span class="p_del">-	sin6-&gt;sin6_scope_id = 0; /*FIXME */</span>
<span class="p_del">-	*addr_len = sizeof(struct sockaddr_in6);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Initialize a PF_INET msgname from a ulpevent. */
 static void sctp_inet6_event_msgname(struct sctp_ulpevent *event,
 				     char *msgname, int *addrlen)
 {
<span class="p_del">-	struct sockaddr_in6 *sin6, *sin6from;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (msgname) {</span>
<span class="p_del">-		union sctp_addr *addr;</span>
<span class="p_del">-		struct sctp_association *asoc;</span>
<span class="p_del">-</span>
<span class="p_del">-		asoc = event-&gt;asoc;</span>
<span class="p_del">-		sctp_inet6_msgname(msgname, addrlen);</span>
<span class="p_del">-		sin6 = (struct sockaddr_in6 *)msgname;</span>
<span class="p_del">-		sin6-&gt;sin6_port = htons(asoc-&gt;peer.port);</span>
<span class="p_del">-		addr = &amp;asoc-&gt;peer.primary_addr;</span>
<span class="p_add">+	union sctp_addr *addr;</span>
<span class="p_add">+	struct sctp_association *asoc;</span>
<span class="p_add">+	union sctp_addr *paddr;</span>
 
<span class="p_del">-		/* Note: If we go to a common v6 format, this code</span>
<span class="p_del">-		 * will change.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+	if (!msgname)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-		/* Map ipv4 address into v4-mapped-on-v6 address.  */</span>
<span class="p_del">-		if (sctp_sk(asoc-&gt;base.sk)-&gt;v4mapped &amp;&amp;</span>
<span class="p_del">-		    AF_INET == addr-&gt;sa.sa_family) {</span>
<span class="p_del">-			sctp_v4_map_v6((union sctp_addr *)sin6);</span>
<span class="p_del">-			sin6-&gt;sin6_addr.s6_addr32[3] =</span>
<span class="p_del">-				addr-&gt;v4.sin_addr.s_addr;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	addr = (union sctp_addr *)msgname;</span>
<span class="p_add">+	asoc = event-&gt;asoc;</span>
<span class="p_add">+	paddr = &amp;asoc-&gt;peer.primary_addr;</span>
 
<span class="p_del">-		sin6from = &amp;asoc-&gt;peer.primary_addr.v6;</span>
<span class="p_del">-		sin6-&gt;sin6_addr = sin6from-&gt;sin6_addr;</span>
<span class="p_del">-		if (ipv6_addr_type(&amp;sin6-&gt;sin6_addr) &amp; IPV6_ADDR_LINKLOCAL)</span>
<span class="p_del">-			sin6-&gt;sin6_scope_id = sin6from-&gt;sin6_scope_id;</span>
<span class="p_add">+	if (paddr-&gt;sa.sa_family == AF_INET) {</span>
<span class="p_add">+		addr-&gt;v4.sin_family = AF_INET;</span>
<span class="p_add">+		addr-&gt;v4.sin_port = htons(asoc-&gt;peer.port);</span>
<span class="p_add">+		addr-&gt;v4.sin_addr = paddr-&gt;v4.sin_addr;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		addr-&gt;v6.sin6_family = AF_INET6;</span>
<span class="p_add">+		addr-&gt;v6.sin6_flowinfo = 0;</span>
<span class="p_add">+		if (ipv6_addr_type(&amp;paddr-&gt;v6.sin6_addr) &amp; IPV6_ADDR_LINKLOCAL)</span>
<span class="p_add">+			addr-&gt;v6.sin6_scope_id = paddr-&gt;v6.sin6_scope_id;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			addr-&gt;v6.sin6_scope_id = 0;</span>
<span class="p_add">+		addr-&gt;v6.sin6_port = htons(asoc-&gt;peer.port);</span>
<span class="p_add">+		addr-&gt;v6.sin6_addr = paddr-&gt;v6.sin6_addr;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	*addrlen = sctp_v6_addr_to_user(sctp_sk(asoc-&gt;base.sk), addr);</span>
 }
 
 /* Initialize a msg_name from an inbound skb. */
 static void sctp_inet6_skb_msgname(struct sk_buff *skb, char *msgname,
 				   int *addr_len)
 {
<span class="p_add">+	union sctp_addr *addr;</span>
 	struct sctphdr *sh;
<span class="p_del">-	struct sockaddr_in6 *sin6;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (msgname) {</span>
<span class="p_del">-		sctp_inet6_msgname(msgname, addr_len);</span>
<span class="p_del">-		sin6 = (struct sockaddr_in6 *)msgname;</span>
<span class="p_del">-		sh = sctp_hdr(skb);</span>
<span class="p_del">-		sin6-&gt;sin6_port = sh-&gt;source;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Map ipv4 address into v4-mapped-on-v6 address. */</span>
<span class="p_del">-		if (sctp_sk(skb-&gt;sk)-&gt;v4mapped &amp;&amp;</span>
<span class="p_del">-		    ip_hdr(skb)-&gt;version == 4) {</span>
<span class="p_del">-			sctp_v4_map_v6((union sctp_addr *)sin6);</span>
<span class="p_del">-			sin6-&gt;sin6_addr.s6_addr32[3] = ip_hdr(skb)-&gt;saddr;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
 
<span class="p_del">-		/* Otherwise, just copy the v6 address. */</span>
<span class="p_del">-		sin6-&gt;sin6_addr = ipv6_hdr(skb)-&gt;saddr;</span>
<span class="p_del">-		if (ipv6_addr_type(&amp;sin6-&gt;sin6_addr) &amp; IPV6_ADDR_LINKLOCAL) {</span>
<span class="p_add">+	if (!msgname)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = (union sctp_addr *)msgname;</span>
<span class="p_add">+	sh = sctp_hdr(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ip_hdr(skb)-&gt;version == 4) {</span>
<span class="p_add">+		addr-&gt;v4.sin_family = AF_INET;</span>
<span class="p_add">+		addr-&gt;v4.sin_port = sh-&gt;source;</span>
<span class="p_add">+		addr-&gt;v4.sin_addr.s_addr =  ip_hdr(skb)-&gt;saddr;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		addr-&gt;v6.sin6_family = AF_INET6;</span>
<span class="p_add">+		addr-&gt;v6.sin6_flowinfo = 0;</span>
<span class="p_add">+		addr-&gt;v6.sin6_port = sh-&gt;source;</span>
<span class="p_add">+		addr-&gt;v6.sin6_addr = ipv6_hdr(skb)-&gt;saddr;</span>
<span class="p_add">+		if (ipv6_addr_type(&amp;addr-&gt;v6.sin6_addr) &amp; IPV6_ADDR_LINKLOCAL) {</span>
 			struct sctp_ulpevent *ev = sctp_skb2event(skb);
<span class="p_del">-			sin6-&gt;sin6_scope_id = ev-&gt;iif;</span>
<span class="p_add">+			addr-&gt;v6.sin6_scope_id = ev-&gt;iif;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			addr-&gt;v6.sin6_scope_id = 0;</span>
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	*addr_len = sctp_v6_addr_to_user(sctp_sk(skb-&gt;sk), addr);</span>
 }
 
 /* Do we support this AF? */
<span class="p_chunk">@@ -870,9 +868,6 @@</span> <span class="p_context"> static int sctp_inet6_bind_verify(struct sctp_sock *opt, union sctp_addr *addr)</span>
 				return 0;
 			}
 			rcu_read_unlock();
<span class="p_del">-		} else if (type == IPV6_ADDR_MAPPED) {</span>
<span class="p_del">-			if (!opt-&gt;v4mapped)</span>
<span class="p_del">-				return 0;</span>
 		}
 
 		af = opt-&gt;pf-&gt;af;
<span class="p_chunk">@@ -927,6 +922,23 @@</span> <span class="p_context"> static int sctp_inet6_supported_addrs(const struct sctp_sock *opt,</span>
 	return 1;
 }
 
<span class="p_add">+/* Handle SCTP_I_WANT_MAPPED_V4_ADDR for getpeername() and getsockname() */</span>
<span class="p_add">+static int sctp_getname(struct socket *sock, struct sockaddr *uaddr,</span>
<span class="p_add">+			int *uaddr_len, int peer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = inet6_getname(sock, uaddr, uaddr_len, peer);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rc != 0)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	*uaddr_len = sctp_v6_addr_to_user(sctp_sk(sock-&gt;sk),</span>
<span class="p_add">+					  (union sctp_addr *)uaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct proto_ops inet6_seqpacket_ops = {
 	.family		   = PF_INET6,
 	.owner		   = THIS_MODULE,
<span class="p_chunk">@@ -935,7 +947,7 @@</span> <span class="p_context"> static const struct proto_ops inet6_seqpacket_ops = {</span>
 	.connect	   = inet_dgram_connect,
 	.socketpair	   = sock_no_socketpair,
 	.accept		   = inet_accept,
<span class="p_del">-	.getname	   = inet6_getname,</span>
<span class="p_add">+	.getname	   = sctp_getname,</span>
 	.poll		   = sctp_poll,
 	.ioctl		   = inet6_ioctl,
 	.listen		   = sctp_inet_listen,
<span class="p_chunk">@@ -987,8 +999,6 @@</span> <span class="p_context"> static struct sctp_af sctp_af_inet6 = {</span>
 	.copy_addrlist	   = sctp_v6_copy_addrlist,
 	.from_skb	   = sctp_v6_from_skb,
 	.from_sk	   = sctp_v6_from_sk,
<span class="p_del">-	.to_sk_saddr	   = sctp_v6_to_sk_saddr,</span>
<span class="p_del">-	.to_sk_daddr	   = sctp_v6_to_sk_daddr,</span>
 	.from_addr_param   = sctp_v6_from_addr_param,
 	.to_addr_param	   = sctp_v6_to_addr_param,
 	.cmp_addr	   = sctp_v6_cmp_addr,
<span class="p_chunk">@@ -1018,7 +1028,9 @@</span> <span class="p_context"> static struct sctp_pf sctp_pf_inet6 = {</span>
 	.send_verify   = sctp_inet6_send_verify,
 	.supported_addrs = sctp_inet6_supported_addrs,
 	.create_accept_sk = sctp_v6_create_accept_sk,
<span class="p_del">-	.addr_v4map    = sctp_v6_addr_v4map,</span>
<span class="p_add">+	.addr_to_user  = sctp_v6_addr_to_user,</span>
<span class="p_add">+	.to_sk_saddr   = sctp_v6_to_sk_saddr,</span>
<span class="p_add">+	.to_sk_daddr   = sctp_v6_to_sk_daddr,</span>
 	.af            = &amp;sctp_af_inet6,
 };
 
<span class="p_header">diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c</span>
<span class="p_header">index c143f74a25b9..eccd9ebc5ebd 100644</span>
<span class="p_header">--- a/net/sctp/protocol.c</span>
<span class="p_header">+++ b/net/sctp/protocol.c</span>
<span class="p_chunk">@@ -578,10 +578,10 @@</span> <span class="p_context"> static struct sock *sctp_v4_create_accept_sk(struct sock *sk,</span>
 	return newsk;
 }
 
<span class="p_del">-/* Map address, empty for v4 family */</span>
<span class="p_del">-static void sctp_v4_addr_v4map(struct sctp_sock *sp, union sctp_addr *addr)</span>
<span class="p_add">+static int sctp_v4_addr_to_user(struct sctp_sock *sp, union sctp_addr *addr)</span>
 {
<span class="p_del">-	/* Empty */</span>
<span class="p_add">+	/* No address mapping for V4 sockets */</span>
<span class="p_add">+	return sizeof(struct sockaddr_in);</span>
 }
 
 /* Dump the v4 addr to the seq file. */
<span class="p_chunk">@@ -978,7 +978,9 @@</span> <span class="p_context"> static struct sctp_pf sctp_pf_inet = {</span>
 	.send_verify   = sctp_inet_send_verify,
 	.supported_addrs = sctp_inet_supported_addrs,
 	.create_accept_sk = sctp_v4_create_accept_sk,
<span class="p_del">-	.addr_v4map	= sctp_v4_addr_v4map,</span>
<span class="p_add">+	.addr_to_user  = sctp_v4_addr_to_user,</span>
<span class="p_add">+	.to_sk_saddr   = sctp_v4_to_sk_saddr,</span>
<span class="p_add">+	.to_sk_daddr   = sctp_v4_to_sk_daddr,</span>
 	.af            = &amp;sctp_af_inet
 };
 
<span class="p_chunk">@@ -1049,8 +1051,6 @@</span> <span class="p_context"> static struct sctp_af sctp_af_inet = {</span>
 	.copy_addrlist	   = sctp_v4_copy_addrlist,
 	.from_skb	   = sctp_v4_from_skb,
 	.from_sk	   = sctp_v4_from_sk,
<span class="p_del">-	.to_sk_saddr	   = sctp_v4_to_sk_saddr,</span>
<span class="p_del">-	.to_sk_daddr	   = sctp_v4_to_sk_daddr,</span>
 	.from_addr_param   = sctp_v4_from_addr_param,
 	.to_addr_param	   = sctp_v4_to_addr_param,
 	.cmp_addr	   = sctp_v4_cmp_addr,
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index b0f068937260..6785522788f0 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> static struct sctp_transport *sctp_addr_id2transport(struct sock *sk,</span>
 	if (id_asoc &amp;&amp; (id_asoc != addr_asoc))
 		return NULL;
 
<span class="p_del">-	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sctp_sk(sk),</span>
<span class="p_add">+	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_to_user(sctp_sk(sk),</span>
 						(union sctp_addr *)addr);
 
 	return transport;
<span class="p_chunk">@@ -396,7 +396,7 @@</span> <span class="p_context"> static int sctp_do_bind(struct sock *sk, union sctp_addr *addr, int len)</span>
 	/* Copy back into socket for getsockname() use. */
 	if (!ret) {
 		inet_sk(sk)-&gt;inet_sport = htons(inet_sk(sk)-&gt;inet_num);
<span class="p_del">-		af-&gt;to_sk_saddr(addr, sk);</span>
<span class="p_add">+		sp-&gt;pf-&gt;to_sk_saddr(addr, sk);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -1053,7 +1053,6 @@</span> <span class="p_context"> static int __sctp_connect(struct sock *sk,</span>
 	struct sctp_association *asoc2;
 	struct sctp_transport *transport;
 	union sctp_addr to;
<span class="p_del">-	struct sctp_af *af;</span>
 	sctp_scope_t scope;
 	long timeo;
 	int err = 0;
<span class="p_chunk">@@ -1081,6 +1080,8 @@</span> <span class="p_context"> static int __sctp_connect(struct sock *sk,</span>
 	/* Walk through the addrs buffer and count the number of addresses. */
 	addr_buf = kaddrs;
 	while (walk_size &lt; addrs_size) {
<span class="p_add">+		struct sctp_af *af;</span>
<span class="p_add">+</span>
 		if (walk_size + sizeof(sa_family_t) &gt; addrs_size) {
 			err = -EINVAL;
 			goto out_free;
<span class="p_chunk">@@ -1205,8 +1206,7 @@</span> <span class="p_context"> static int __sctp_connect(struct sock *sk,</span>
 
 	/* Initialize sk&#39;s dport and daddr for getpeername() */
 	inet_sk(sk)-&gt;inet_dport = htons(asoc-&gt;peer.port);
<span class="p_del">-	af = sctp_get_af_specific(sa_addr-&gt;sa.sa_family);</span>
<span class="p_del">-	af-&gt;to_sk_daddr(sa_addr, sk);</span>
<span class="p_add">+	sp-&gt;pf-&gt;to_sk_daddr(sa_addr, sk);</span>
 	sk-&gt;sk_err = 0;
 
 	/* in-kernel sockets don&#39;t generally have a file allocated to them
<span class="p_chunk">@@ -4166,7 +4166,7 @@</span> <span class="p_context"> static int sctp_getsockopt_sctp_status(struct sock *sk, int len,</span>
 	memcpy(&amp;status.sstat_primary.spinfo_address, &amp;transport-&gt;ipaddr,
 			transport-&gt;af_specific-&gt;sockaddr_len);
 	/* Map ipv4 address into v4-mapped-on-v6 address.  */
<span class="p_del">-	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sctp_sk(sk),</span>
<span class="p_add">+	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_to_user(sctp_sk(sk),</span>
 		(union sctp_addr *)&amp;status.sstat_primary.spinfo_address);
 	status.sstat_primary.spinfo_state = transport-&gt;state;
 	status.sstat_primary.spinfo_cwnd = transport-&gt;cwnd;
<span class="p_chunk">@@ -4324,8 +4324,8 @@</span> <span class="p_context"> static int sctp_getsockopt_autoclose(struct sock *sk, int len, char __user *optv</span>
 int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
 {
 	struct sctp_association *asoc = sctp_id2assoc(sk, id);
<span class="p_add">+	struct sctp_sock *sp = sctp_sk(sk);</span>
 	struct socket *sock;
<span class="p_del">-	struct sctp_af *af;</span>
 	int err = 0;
 
 	/* Do not peel off from one netns to another one. */
<span class="p_chunk">@@ -4357,8 +4357,7 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	/* Make peeled-off sockets more like 1-1 accepted sockets.
 	 * Set the daddr and initialize id to something more random
 	 */
<span class="p_del">-	af = sctp_get_af_specific(asoc-&gt;peer.primary_addr.sa.sa_family);</span>
<span class="p_del">-	af-&gt;to_sk_daddr(&amp;asoc-&gt;peer.primary_addr, sk);</span>
<span class="p_add">+	sp-&gt;pf-&gt;to_sk_daddr(&amp;asoc-&gt;peer.primary_addr, sk);</span>
 
 	/* Populate the fields of the newsk from the oldsk and migrate the
 	 * asoc to the newsk.
<span class="p_chunk">@@ -4742,8 +4741,8 @@</span> <span class="p_context"> static int sctp_getsockopt_peer_addrs(struct sock *sk, int len,</span>
 	list_for_each_entry(from, &amp;asoc-&gt;peer.transport_addr_list,
 				transports) {
 		memcpy(&amp;temp, &amp;from-&gt;ipaddr, sizeof(temp));
<span class="p_del">-		sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sp, &amp;temp);</span>
<span class="p_del">-		addrlen = sctp_get_af_specific(temp.sa.sa_family)-&gt;sockaddr_len;</span>
<span class="p_add">+		addrlen = sctp_get_pf_specific(sk-&gt;sk_family)</span>
<span class="p_add">+			      -&gt;addr_to_user(sp, &amp;temp);</span>
 		if (space_left &lt; addrlen)
 			return -ENOMEM;
 		if (copy_to_user(to, &amp;temp, addrlen))
<span class="p_chunk">@@ -4787,9 +4786,9 @@</span> <span class="p_context"> static int sctp_copy_laddrs(struct sock *sk, __u16 port, void *to,</span>
 		if (!temp.v4.sin_port)
 			temp.v4.sin_port = htons(port);
 
<span class="p_del">-		sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sctp_sk(sk),</span>
<span class="p_del">-								&amp;temp);</span>
<span class="p_del">-		addrlen = sctp_get_af_specific(temp.sa.sa_family)-&gt;sockaddr_len;</span>
<span class="p_add">+		addrlen = sctp_get_pf_specific(sk-&gt;sk_family)</span>
<span class="p_add">+			      -&gt;addr_to_user(sctp_sk(sk), &amp;temp);</span>
<span class="p_add">+</span>
 		if (space_left &lt; addrlen) {
 			cnt =  -ENOMEM;
 			break;
<span class="p_chunk">@@ -4877,8 +4876,8 @@</span> <span class="p_context"> static int sctp_getsockopt_local_addrs(struct sock *sk, int len,</span>
 	 */
 	list_for_each_entry(addr, &amp;bp-&gt;address_list, list) {
 		memcpy(&amp;temp, &amp;addr-&gt;a, sizeof(temp));
<span class="p_del">-		sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sp, &amp;temp);</span>
<span class="p_del">-		addrlen = sctp_get_af_specific(temp.sa.sa_family)-&gt;sockaddr_len;</span>
<span class="p_add">+		addrlen = sctp_get_pf_specific(sk-&gt;sk_family)</span>
<span class="p_add">+			      -&gt;addr_to_user(sp, &amp;temp);</span>
 		if (space_left &lt; addrlen) {
 			err =  -ENOMEM; /*fixme: right error?*/
 			goto out;
<span class="p_chunk">@@ -4937,7 +4936,7 @@</span> <span class="p_context"> static int sctp_getsockopt_primary_addr(struct sock *sk, int len,</span>
 	memcpy(&amp;prim.ssp_addr, &amp;asoc-&gt;peer.primary_path-&gt;ipaddr,
 		asoc-&gt;peer.primary_path-&gt;af_specific-&gt;sockaddr_len);
 
<span class="p_del">-	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_v4map(sp,</span>
<span class="p_add">+	sctp_get_pf_specific(sk-&gt;sk_family)-&gt;addr_to_user(sp,</span>
 			(union sctp_addr *)&amp;prim.ssp_addr);
 
 	if (put_user(len, optlen))
<span class="p_header">diff --git a/net/sctp/transport.c b/net/sctp/transport.c</span>
<span class="p_header">index d27f064e2d06..b71fc5880706 100644</span>
<span class="p_header">--- a/net/sctp/transport.c</span>
<span class="p_header">+++ b/net/sctp/transport.c</span>
<span class="p_chunk">@@ -289,8 +289,8 @@</span> <span class="p_context"> void sctp_transport_route(struct sctp_transport *transport,</span>
 		 */
 		if (asoc &amp;&amp; (!asoc-&gt;peer.primary_path ||
 				(transport == asoc-&gt;peer.active_path)))
<span class="p_del">-			opt-&gt;pf-&gt;af-&gt;to_sk_saddr(&amp;transport-&gt;saddr,</span>
<span class="p_del">-						 asoc-&gt;base.sk);</span>
<span class="p_add">+			opt-&gt;pf-&gt;to_sk_saddr(&amp;transport-&gt;saddr,</span>
<span class="p_add">+					     asoc-&gt;base.sk);</span>
 	} else
 		transport-&gt;pathmtu = SCTP_DEFAULT_MAXSEGMENT;
 }
<span class="p_header">diff --git a/net/sctp/ulpevent.c b/net/sctp/ulpevent.c</span>
<span class="p_header">index b6842fdb53d4..dd5787f877e7 100644</span>
<span class="p_header">--- a/net/sctp/ulpevent.c</span>
<span class="p_header">+++ b/net/sctp/ulpevent.c</span>
<span class="p_chunk">@@ -341,7 +341,7 @@</span> <span class="p_context"> struct sctp_ulpevent *sctp_ulpevent_make_peer_addr_change(</span>
 	memcpy(&amp;spc-&gt;spc_aaddr, aaddr, sizeof(struct sockaddr_storage));
 
 	/* Map ipv4 address into v4-mapped-on-v6 address.  */
<span class="p_del">-	sctp_get_pf_specific(asoc-&gt;base.sk-&gt;sk_family)-&gt;addr_v4map(</span>
<span class="p_add">+	sctp_get_pf_specific(asoc-&gt;base.sk-&gt;sk_family)-&gt;addr_to_user(</span>
 					sctp_sk(asoc-&gt;base.sk),
 					(union sctp_addr *)&amp;spc-&gt;spc_aaddr);
 
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index eb71b29eb647..173915a2be1e 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -2341,10 +2341,32 @@</span> <span class="p_context"> static int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flag</span>
 		}
 	}
 
<span class="p_del">-	if (wdev-&gt;ssid_len) {</span>
<span class="p_del">-		if (nla_put(msg, NL80211_ATTR_SSID, wdev-&gt;ssid_len, wdev-&gt;ssid))</span>
<span class="p_add">+	wdev_lock(wdev);</span>
<span class="p_add">+	switch (wdev-&gt;iftype) {</span>
<span class="p_add">+	case NL80211_IFTYPE_AP:</span>
<span class="p_add">+		if (wdev-&gt;ssid_len &amp;&amp;</span>
<span class="p_add">+		    nla_put(msg, NL80211_ATTR_SSID, wdev-&gt;ssid_len, wdev-&gt;ssid))</span>
 			goto nla_put_failure;
<span class="p_add">+		break;</span>
<span class="p_add">+	case NL80211_IFTYPE_STATION:</span>
<span class="p_add">+	case NL80211_IFTYPE_P2P_CLIENT:</span>
<span class="p_add">+	case NL80211_IFTYPE_ADHOC: {</span>
<span class="p_add">+		const u8 *ssid_ie;</span>
<span class="p_add">+		if (!wdev-&gt;current_bss)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		ssid_ie = ieee80211_bss_get_ie(&amp;wdev-&gt;current_bss-&gt;pub,</span>
<span class="p_add">+					       WLAN_EID_SSID);</span>
<span class="p_add">+		if (!ssid_ie)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (nla_put(msg, NL80211_ATTR_SSID, ssid_ie[1], ssid_ie + 2))</span>
<span class="p_add">+			goto nla_put_failure;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/* nothing */</span>
<span class="p_add">+		break;</span>
 	}
<span class="p_add">+	wdev_unlock(wdev);</span>
 
 	return genlmsg_end(msg, hdr);
 
<span class="p_header">diff --git a/security/apparmor/domain.c b/security/apparmor/domain.c</span>
<span class="p_header">index 24a21cd72b4c..4830e8ac3e85 100644</span>
<span class="p_header">--- a/security/apparmor/domain.c</span>
<span class="p_header">+++ b/security/apparmor/domain.c</span>
<span class="p_chunk">@@ -126,6 +126,7 @@</span> <span class="p_context"> static struct file_perms change_profile_perms(struct aa_profile *profile,</span>
  * __attach_match_ - find an attachment match
  * @name - to match against  (NOT NULL)
  * @head - profile list to walk  (NOT NULL)
<span class="p_add">+ * @info - info message if there was an error (NOT NULL)</span>
  *
  * Do a linear search on the profiles in the list.  There is a matching
  * preference where an exact match is preferred over a name which uses
<span class="p_chunk">@@ -137,28 +138,44 @@</span> <span class="p_context"> static struct file_perms change_profile_perms(struct aa_profile *profile,</span>
  * Returns: profile or NULL if no match found
  */
 static struct aa_profile *__attach_match(const char *name,
<span class="p_del">-					 struct list_head *head)</span>
<span class="p_add">+					 struct list_head *head,</span>
<span class="p_add">+					 const char **info)</span>
 {
 	int len = 0;
<span class="p_add">+	bool conflict = false;</span>
 	struct aa_profile *profile, *candidate = NULL;
 
 	list_for_each_entry_rcu(profile, head, base.list) {
 		if (profile-&gt;flags &amp; PFLAG_NULL)
 			continue;
<span class="p_del">-		if (profile-&gt;xmatch &amp;&amp; profile-&gt;xmatch_len &gt; len) {</span>
<span class="p_del">-			unsigned int state = aa_dfa_match(profile-&gt;xmatch,</span>
<span class="p_del">-							  DFA_START, name);</span>
<span class="p_del">-			u32 perm = dfa_user_allow(profile-&gt;xmatch, state);</span>
<span class="p_del">-			/* any accepting state means a valid match. */</span>
<span class="p_del">-			if (perm &amp; MAY_EXEC) {</span>
<span class="p_del">-				candidate = profile;</span>
<span class="p_del">-				len = profile-&gt;xmatch_len;</span>
<span class="p_add">+		if (profile-&gt;xmatch) {</span>
<span class="p_add">+			if (profile-&gt;xmatch_len == len) {</span>
<span class="p_add">+				conflict = true;</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			} else if (profile-&gt;xmatch_len &gt; len) {</span>
<span class="p_add">+				unsigned int state;</span>
<span class="p_add">+				u32 perm;</span>
<span class="p_add">+</span>
<span class="p_add">+				state = aa_dfa_match(profile-&gt;xmatch,</span>
<span class="p_add">+						     DFA_START, name);</span>
<span class="p_add">+				perm = dfa_user_allow(profile-&gt;xmatch, state);</span>
<span class="p_add">+				/* any accepting state means a valid match. */</span>
<span class="p_add">+				if (perm &amp; MAY_EXEC) {</span>
<span class="p_add">+					candidate = profile;</span>
<span class="p_add">+					len = profile-&gt;xmatch_len;</span>
<span class="p_add">+					conflict = false;</span>
<span class="p_add">+				}</span>
 			}
 		} else if (!strcmp(profile-&gt;base.name, name))
 			/* exact non-re match, no more searching required */
 			return profile;
 	}
 
<span class="p_add">+	if (conflict) {</span>
<span class="p_add">+		*info = &quot;conflicting profile attachments&quot;;</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return candidate;
 }
 
<span class="p_chunk">@@ -167,16 +184,18 @@</span> <span class="p_context"> static struct aa_profile *__attach_match(const char *name,</span>
  * @ns: the current namespace  (NOT NULL)
  * @list: list to search  (NOT NULL)
  * @name: the executable name to match against  (NOT NULL)
<span class="p_add">+ * @info: info message if there was an error</span>
  *
  * Returns: profile or NULL if no match found
  */
 static struct aa_profile *find_attach(struct aa_namespace *ns,
<span class="p_del">-				      struct list_head *list, const char *name)</span>
<span class="p_add">+				      struct list_head *list, const char *name,</span>
<span class="p_add">+				      const char **info)</span>
 {
 	struct aa_profile *profile;
 
 	rcu_read_lock();
<span class="p_del">-	profile = aa_get_profile(__attach_match(name, list));</span>
<span class="p_add">+	profile = aa_get_profile(__attach_match(name, list, info));</span>
 	rcu_read_unlock();
 
 	return profile;
<span class="p_chunk">@@ -298,7 +317,8 @@</span> <span class="p_context"> static struct aa_profile *x_table_lookup(struct aa_profile *profile, u32 xindex)</span>
  * Returns: refcounted profile or NULL if not found available
  */
 static struct aa_profile *x_to_profile(struct aa_profile *profile,
<span class="p_del">-				       const char *name, u32 xindex)</span>
<span class="p_add">+				       const char *name, u32 xindex,</span>
<span class="p_add">+				       const char **info)</span>
 {
 	struct aa_profile *new_profile = NULL;
 	struct aa_namespace *ns = profile-&gt;ns;
<span class="p_chunk">@@ -312,11 +332,11 @@</span> <span class="p_context"> static struct aa_profile *x_to_profile(struct aa_profile *profile,</span>
 		if (xindex &amp; AA_X_CHILD)
 			/* released by caller */
 			new_profile = find_attach(ns, &amp;profile-&gt;base.profiles,
<span class="p_del">-						  name);</span>
<span class="p_add">+						  name, info);</span>
 		else
 			/* released by caller */
 			new_profile = find_attach(ns, &amp;ns-&gt;base.profiles,
<span class="p_del">-						  name);</span>
<span class="p_add">+						  name, info);</span>
 		break;
 	case AA_X_TABLE:
 		/* released by caller */
<span class="p_chunk">@@ -385,7 +405,8 @@</span> <span class="p_context"> int apparmor_bprm_set_creds(struct linux_binprm *bprm)</span>
 			/* change_profile on exec already been granted */
 			new_profile = aa_get_profile(cxt-&gt;onexec);
 		else
<span class="p_del">-			new_profile = find_attach(ns, &amp;ns-&gt;base.profiles, name);</span>
<span class="p_add">+			new_profile = find_attach(ns, &amp;ns-&gt;base.profiles, name,</span>
<span class="p_add">+						  &amp;info);</span>
 		if (!new_profile)
 			goto cleanup;
 		/*
<span class="p_chunk">@@ -421,7 +442,7 @@</span> <span class="p_context"> int apparmor_bprm_set_creds(struct linux_binprm *bprm)</span>
 
 	if (perms.allow &amp; MAY_EXEC) {
 		/* exec permission determine how to transition */
<span class="p_del">-		new_profile = x_to_profile(profile, name, perms.xindex);</span>
<span class="p_add">+		new_profile = x_to_profile(profile, name, perms.xindex, &amp;info);</span>
 		if (!new_profile) {
 			if (perms.xindex &amp; AA_X_INHERIT) {
 				/* (p|c|n)ix - don&#39;t change profile but do
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index ac2e2cee7a2a..6d88467a0de1 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -52,6 +52,8 @@</span> <span class="p_context"> static int __init hash_setup(char *str)</span>
 			ima_hash_algo = HASH_ALGO_SHA1;
 		else if (strncmp(str, &quot;md5&quot;, 3) == 0)
 			ima_hash_algo = HASH_ALGO_MD5;
<span class="p_add">+		else</span>
<span class="p_add">+			return 1;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -61,6 +63,8 @@</span> <span class="p_context"> static int __init hash_setup(char *str)</span>
 			break;
 		}
 	}
<span class="p_add">+	if (i == HASH_ALGO__LAST)</span>
<span class="p_add">+		return 1;</span>
 out:
 	hash_setup_done = 1;
 	return 1;
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 0a52e377a617..83bf65ae8251 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -236,6 +236,7 @@</span> <span class="p_context"> static struct snd_seq_client *seq_create_client1(int client_index, int poolsize)</span>
 	rwlock_init(&amp;client-&gt;ports_lock);
 	mutex_init(&amp;client-&gt;ports_mutex);
 	INIT_LIST_HEAD(&amp;client-&gt;ports_list_head);
<span class="p_add">+	mutex_init(&amp;client-&gt;ioctl_mutex);</span>
 
 	/* find free slot in the client table */
 	spin_lock_irqsave(&amp;clients_lock, flags);
<span class="p_chunk">@@ -2200,6 +2201,7 @@</span> <span class="p_context"> static int snd_seq_do_ioctl(struct snd_seq_client *client, unsigned int cmd,</span>
 			    void __user *arg)
 {
 	struct seq_ioctl_table *p;
<span class="p_add">+	int ret;</span>
 
 	switch (cmd) {
 	case SNDRV_SEQ_IOCTL_PVERSION:
<span class="p_chunk">@@ -2213,8 +2215,12 @@</span> <span class="p_context"> static int snd_seq_do_ioctl(struct snd_seq_client *client, unsigned int cmd,</span>
 	if (! arg)
 		return -EFAULT;
 	for (p = ioctl_tables; p-&gt;cmd; p++) {
<span class="p_del">-		if (p-&gt;cmd == cmd)</span>
<span class="p_del">-			return p-&gt;func(client, arg);</span>
<span class="p_add">+		if (p-&gt;cmd == cmd) {</span>
<span class="p_add">+			mutex_lock(&amp;client-&gt;ioctl_mutex);</span>
<span class="p_add">+			ret = p-&gt;func(client, arg);</span>
<span class="p_add">+			mutex_unlock(&amp;client-&gt;ioctl_mutex);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 	}
 	pr_debug(&quot;ALSA: seq unknown ioctl() 0x%x (type=&#39;%c&#39;, number=0x%02x)\n&quot;,
 		   cmd, _IOC_TYPE(cmd), _IOC_NR(cmd));
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.h b/sound/core/seq/seq_clientmgr.h</span>
<span class="p_header">index 20f0a725ec7d..91f8f165bfdc 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.h</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.h</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> struct snd_seq_client {</span>
 	struct list_head ports_list_head;
 	rwlock_t ports_lock;
 	struct mutex ports_mutex;
<span class="p_add">+	struct mutex ioctl_mutex;</span>
 	int convert32;		/* convert 32-&gt;64bit */
 
 	/* output pool */
<span class="p_header">diff --git a/sound/core/timer_compat.c b/sound/core/timer_compat.c</span>
<span class="p_header">index 0b4b028e8e98..de9155eed727 100644</span>
<span class="p_header">--- a/sound/core/timer_compat.c</span>
<span class="p_header">+++ b/sound/core/timer_compat.c</span>
<span class="p_chunk">@@ -40,11 +40,11 @@</span> <span class="p_context"> static int snd_timer_user_info_compat(struct file *file,</span>
 	struct snd_timer *t;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	if (snd_BUG_ON(!tu-&gt;timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!tu-&gt;timeri)</span>
<span class="p_add">+		return -EBADFD;</span>
 	t = tu-&gt;timeri-&gt;timer;
<span class="p_del">-	if (snd_BUG_ON(!t))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!t)</span>
<span class="p_add">+		return -EBADFD;</span>
 	memset(&amp;info, 0, sizeof(info));
 	info.card = t-&gt;card ? t-&gt;card-&gt;number : -1;
 	if (t-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE)
<span class="p_chunk">@@ -73,8 +73,8 @@</span> <span class="p_context"> static int snd_timer_user_status_compat(struct file *file,</span>
 	struct snd_timer_status32 status;
 	
 	tu = file-&gt;private_data;
<span class="p_del">-	if (snd_BUG_ON(!tu-&gt;timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!tu-&gt;timeri)</span>
<span class="p_add">+		return -EBADFD;</span>
 	memset(&amp;status, 0, sizeof(status));
 	status.tstamp.tv_sec = tu-&gt;tstamp.tv_sec;
 	status.tstamp.tv_nsec = tu-&gt;tstamp.tv_nsec;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 7823dc0aabd7..93cfc305f04e 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -1914,6 +1914,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* AMD Hudson */
 	{ PCI_DEVICE(0x1022, 0x780d),
 	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },
<span class="p_add">+	/* AMD Raven */</span>
<span class="p_add">+	{ PCI_DEVICE(0x1022, 0x15e3),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },</span>
 	/* ATI HDMI */
 	{ PCI_DEVICE(0x1002, 0x793b),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
<span class="p_header">diff --git a/sound/usb/clock.c b/sound/usb/clock.c</span>
<span class="p_header">index 56216a23277f..09feedbd80c9 100644</span>
<span class="p_header">--- a/sound/usb/clock.c</span>
<span class="p_header">+++ b/sound/usb/clock.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static struct uac_clock_source_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_SOURCE))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id)</span>
 			return cs;
 	}
 
<span class="p_chunk">@@ -59,8 +59,11 @@</span> <span class="p_context"> static struct uac_clock_selector_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_SELECTOR))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id) {</span>
<span class="p_add">+			if (cs-&gt;bLength &lt; 5 + cs-&gt;bNrInPins)</span>
<span class="p_add">+				return NULL;</span>
 			return cs;
<span class="p_add">+		}</span>
 	}
 
 	return NULL;
<span class="p_chunk">@@ -75,7 +78,7 @@</span> <span class="p_context"> static struct uac_clock_multiplier_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_MULTIPLIER))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id)</span>
 			return cs;
 	}
 
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 6d7605db36d0..2784ed187fee 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -1378,6 +1378,12 @@</span> <span class="p_context"> static int parse_audio_feature_unit(struct mixer_build *state, int unitid,</span>
 	__u8 *bmaControls;
 
 	if (state-&gt;mixer-&gt;protocol == UAC_VERSION_1) {
<span class="p_add">+		if (hdr-&gt;bLength &lt; 7) {</span>
<span class="p_add">+			usb_audio_err(state-&gt;chip,</span>
<span class="p_add">+				      &quot;unit %u: invalid UAC_FEATURE_UNIT descriptor\n&quot;,</span>
<span class="p_add">+				      unitid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 		csize = hdr-&gt;bControlSize;
 		if (!csize) {
 			usb_audio_dbg(state-&gt;chip,
<span class="p_chunk">@@ -1395,6 +1401,12 @@</span> <span class="p_context"> static int parse_audio_feature_unit(struct mixer_build *state, int unitid,</span>
 		}
 	} else {
 		struct uac2_feature_unit_descriptor *ftr = _ftr;
<span class="p_add">+		if (hdr-&gt;bLength &lt; 6) {</span>
<span class="p_add">+			usb_audio_err(state-&gt;chip,</span>
<span class="p_add">+				      &quot;unit %u: invalid UAC_FEATURE_UNIT descriptor\n&quot;,</span>
<span class="p_add">+				      unitid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 		csize = 4;
 		channels = (hdr-&gt;bLength - 6) / 4 - 1;
 		bmaControls = ftr-&gt;bmaControls;
<span class="p_chunk">@@ -2008,7 +2020,8 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	const struct usbmix_name_map *map;
 	char **namelist;
 
<span class="p_del">-	if (!desc-&gt;bNrInPins || desc-&gt;bLength &lt; 5 + desc-&gt;bNrInPins) {</span>
<span class="p_add">+	if (desc-&gt;bLength &lt; 5 || !desc-&gt;bNrInPins ||</span>
<span class="p_add">+	    desc-&gt;bLength &lt; 5 + desc-&gt;bNrInPins) {</span>
 		usb_audio_err(state-&gt;chip,
 			&quot;invalid SELECTOR UNIT descriptor %d\n&quot;, unitid);
 		return -EINVAL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



