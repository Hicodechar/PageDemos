
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.19.y-ckt,stable] Linux 3.19.8-ckt4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.19.y-ckt,stable] Linux 3.19.8-ckt4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 20, 2015, 10:38 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437431934-27665-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6831221/mbox/"
   >mbox</a>
|
   <a href="/patch/6831221/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6831221/">/patch/6831221/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 5F3F2C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 22:40:52 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 39EE3205F9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 22:40:33 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D716E205BE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 22:39:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1757175AbbGTWjb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 20 Jul 2015 18:39:31 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:58168 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756532AbbGTWjB (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 20 Jul 2015 18:39:01 -0400
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1ZHJi5-0005vk-Iq; Mon, 20 Jul 2015 22:38:59 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1ZHJi3-0007Cp-B8; Mon, 20 Jul 2015 15:38:55 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.19.y-ckt stable] Linux 3.19.8-ckt4
Date: Mon, 20 Jul 2015 15:38:54 -0700
Message-Id: &lt;1437431934-27665-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1437431934-27665-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1437431934-27665-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.19
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - July 20, 2015, 10:38 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/ima_policy b/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">index d0d0c57..0a378a8 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">+++ b/Documentation/ABI/testing/ima_policy</span>
<span class="p_chunk">@@ -20,17 +20,19 @@</span> <span class="p_context"> Description:</span>
 		action: measure | dont_measure | appraise | dont_appraise | audit
 		condition:= base | lsm  [option]
 			base:	[[func=] [mask=] [fsmagic=] [fsuuid=] [uid=]
<span class="p_del">-				 [fowner]]</span>
<span class="p_add">+				[euid=] [fowner=]]</span>
 			lsm:	[[subj_user=] [subj_role=] [subj_type=]
 				 [obj_user=] [obj_role=] [obj_type=]]
 			option:	[[appraise_type=]] [permit_directio]
 
 		base: 	func:= [BPRM_CHECK][MMAP_CHECK][FILE_CHECK][MODULE_CHECK]
 				[FIRMWARE_CHECK]
<span class="p_del">-			mask:= [MAY_READ] [MAY_WRITE] [MAY_APPEND] [MAY_EXEC]</span>
<span class="p_add">+			mask:= [[^]MAY_READ] [[^]MAY_WRITE] [[^]MAY_APPEND]</span>
<span class="p_add">+			       [[^]MAY_EXEC]</span>
 			fsmagic:= hex value
 			fsuuid:= file system UUID (e.g 8bcbe394-4f13-4144-be8e-5aa9ea2ce2f6)
 			uid:= decimal value
<span class="p_add">+			euid:= decimal value</span>
 			fowner:=decimal value
 		lsm:  	are LSM specific
 		option:	appraise_type:= [imasig]
<span class="p_chunk">@@ -49,11 +51,25 @@</span> <span class="p_context"> Description:</span>
 			dont_measure fsmagic=0x01021994
 			dont_appraise fsmagic=0x01021994
 			# RAMFS_MAGIC
<span class="p_del">-			dont_measure fsmagic=0x858458f6</span>
 			dont_appraise fsmagic=0x858458f6
<span class="p_add">+			# DEVPTS_SUPER_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x1cd1</span>
<span class="p_add">+			dont_appraise fsmagic=0x1cd1</span>
<span class="p_add">+			# BINFMTFS_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x42494e4d</span>
<span class="p_add">+			dont_appraise fsmagic=0x42494e4d</span>
 			# SECURITYFS_MAGIC
 			dont_measure fsmagic=0x73636673
 			dont_appraise fsmagic=0x73636673
<span class="p_add">+			# SELINUX_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0xf97cff8c</span>
<span class="p_add">+			dont_appraise fsmagic=0xf97cff8c</span>
<span class="p_add">+			# CGROUP_SUPER_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x27e0eb</span>
<span class="p_add">+			dont_appraise fsmagic=0x27e0eb</span>
<span class="p_add">+			# NSFS_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x6e736673</span>
<span class="p_add">+			dont_appraise fsmagic=0x6e736673</span>
 
 			measure func=BPRM_CHECK
 			measure func=FILE_MMAP mask=MAY_EXEC
<span class="p_chunk">@@ -70,10 +86,6 @@</span> <span class="p_context"> Description:</span>
 		Examples of LSM specific definitions:
 
 		SELinux:
<span class="p_del">-			# SELINUX_MAGIC</span>
<span class="p_del">-			dont_measure fsmagic=0xf97cff8c</span>
<span class="p_del">-			dont_appraise fsmagic=0xf97cff8c</span>
<span class="p_del">-</span>
 			dont_measure obj_type=var_log_t
 			dont_appraise obj_type=var_log_t
 			dont_measure obj_type=auditd_log_t
<span class="p_header">diff --git a/Documentation/DMA-API-HOWTO.txt b/Documentation/DMA-API-HOWTO.txt</span>
<span class="p_header">index 0f7afb2..aef8cc5 100644</span>
<span class="p_header">--- a/Documentation/DMA-API-HOWTO.txt</span>
<span class="p_header">+++ b/Documentation/DMA-API-HOWTO.txt</span>
<span class="p_chunk">@@ -25,13 +25,18 @@</span> <span class="p_context"> physical addresses.  These are the addresses in /proc/iomem.  The physical</span>
 address is not directly useful to a driver; it must use ioremap() to map
 the space and produce a virtual address.
 
<span class="p_del">-I/O devices use a third kind of address: a &quot;bus address&quot; or &quot;DMA address&quot;.</span>
<span class="p_del">-If a device has registers at an MMIO address, or if it performs DMA to read</span>
<span class="p_del">-or write system memory, the addresses used by the device are bus addresses.</span>
<span class="p_del">-In some systems, bus addresses are identical to CPU physical addresses, but</span>
<span class="p_del">-in general they are not.  IOMMUs and host bridges can produce arbitrary</span>
<span class="p_add">+I/O devices use a third kind of address: a &quot;bus address&quot;.  If a device has</span>
<span class="p_add">+registers at an MMIO address, or if it performs DMA to read or write system</span>
<span class="p_add">+memory, the addresses used by the device are bus addresses.  In some</span>
<span class="p_add">+systems, bus addresses are identical to CPU physical addresses, but in</span>
<span class="p_add">+general they are not.  IOMMUs and host bridges can produce arbitrary</span>
 mappings between physical and bus addresses.
 
<span class="p_add">+From a device&#39;s point of view, DMA uses the bus address space, but it may</span>
<span class="p_add">+be restricted to a subset of that space.  For example, even if a system</span>
<span class="p_add">+supports 64-bit addresses for main memory and PCI BARs, it may use an IOMMU</span>
<span class="p_add">+so devices only need to use 32-bit DMA addresses.</span>
<span class="p_add">+</span>
 Here&#39;s a picture and some examples:
 
                CPU                  CPU                  Bus
<span class="p_chunk">@@ -72,11 +77,11 @@</span> <span class="p_context"> can use virtual address X to access the buffer, but the device itself</span>
 cannot because DMA doesn&#39;t go through the CPU virtual memory system.
 
 In some simple systems, the device can do DMA directly to physical address
<span class="p_del">-Y.  But in many others, there is IOMMU hardware that translates bus</span>
<span class="p_add">+Y.  But in many others, there is IOMMU hardware that translates DMA</span>
 addresses to physical addresses, e.g., it translates Z to Y.  This is part
 of the reason for the DMA API: the driver can give a virtual address X to
 an interface like dma_map_single(), which sets up any required IOMMU
<span class="p_del">-mapping and returns the bus address Z.  The driver then tells the device to</span>
<span class="p_add">+mapping and returns the DMA address Z.  The driver then tells the device to</span>
 do DMA to Z, and the IOMMU maps it to the buffer at address Y in system
 RAM.
 
<span class="p_chunk">@@ -98,7 +103,7 @@</span> <span class="p_context"> First of all, you should make sure</span>
 #include &lt;linux/dma-mapping.h&gt;
 
 is in your driver, which provides the definition of dma_addr_t.  This type
<span class="p_del">-can hold any valid DMA or bus address for the platform and should be used</span>
<span class="p_add">+can hold any valid DMA address for the platform and should be used</span>
 everywhere you hold a DMA address returned from the DMA mapping functions.
 
 			 What memory is DMA&#39;able?
<span class="p_chunk">@@ -316,7 +321,7 @@</span> <span class="p_context"> There are two types of DMA mappings:</span>
   Think of &quot;consistent&quot; as &quot;synchronous&quot; or &quot;coherent&quot;.
 
   The current default is to return consistent memory in the low 32
<span class="p_del">-  bits of the bus space.  However, for future compatibility you should</span>
<span class="p_add">+  bits of the DMA space.  However, for future compatibility you should</span>
   set the consistent mask even if this default is fine for your
   driver.
 
<span class="p_chunk">@@ -403,7 +408,7 @@</span> <span class="p_context"> dma_alloc_coherent() returns two values: the virtual address which you</span>
 can use to access it from the CPU and dma_handle which you pass to the
 card.
 
<span class="p_del">-The CPU virtual address and the DMA bus address are both</span>
<span class="p_add">+The CPU virtual address and the DMA address are both</span>
 guaranteed to be aligned to the smallest PAGE_SIZE order which
 is greater than or equal to the requested size.  This invariant
 exists (for example) to guarantee that if you allocate a chunk
<span class="p_chunk">@@ -645,8 +650,8 @@</span> <span class="p_context"> PLEASE NOTE:  The &#39;nents&#39; argument to the dma_unmap_sg call must be</span>
               dma_map_sg call.
 
 Every dma_map_{single,sg}() call should have its dma_unmap_{single,sg}()
<span class="p_del">-counterpart, because the bus address space is a shared resource and</span>
<span class="p_del">-you could render the machine unusable by consuming all bus addresses.</span>
<span class="p_add">+counterpart, because the DMA address space is a shared resource and</span>
<span class="p_add">+you could render the machine unusable by consuming all DMA addresses.</span>
 
 If you need to use the same streaming DMA region multiple times and touch
 the data in between the DMA transfers, the buffer needs to be synced
<span class="p_header">diff --git a/Documentation/DMA-API.txt b/Documentation/DMA-API.txt</span>
<span class="p_header">index 5208840..7eba542 100644</span>
<span class="p_header">--- a/Documentation/DMA-API.txt</span>
<span class="p_header">+++ b/Documentation/DMA-API.txt</span>
<span class="p_chunk">@@ -18,10 +18,10 @@</span> <span class="p_context"> Part I - dma_ API</span>
 To get the dma_ API, you must #include &lt;linux/dma-mapping.h&gt;.  This
 provides dma_addr_t and the interfaces described below.
 
<span class="p_del">-A dma_addr_t can hold any valid DMA or bus address for the platform.  It</span>
<span class="p_del">-can be given to a device to use as a DMA source or target.  A CPU cannot</span>
<span class="p_del">-reference a dma_addr_t directly because there may be translation between</span>
<span class="p_del">-its physical address space and the bus address space.</span>
<span class="p_add">+A dma_addr_t can hold any valid DMA address for the platform.  It can be</span>
<span class="p_add">+given to a device to use as a DMA source or target.  A CPU cannot reference</span>
<span class="p_add">+a dma_addr_t directly because there may be translation between its physical</span>
<span class="p_add">+address space and the DMA address space.</span>
 
 Part Ia - Using large DMA-coherent buffers
 ------------------------------------------
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> It returns a pointer to the allocated region (in the processor&#39;s virtual</span>
 address space) or NULL if the allocation failed.
 
 It also returns a &lt;dma_handle&gt; which may be cast to an unsigned integer the
<span class="p_del">-same width as the bus and given to the device as the bus address base of</span>
<span class="p_add">+same width as the bus and given to the device as the DMA address base of</span>
 the region.
 
 Note: consistent memory can be expensive on some platforms, and the
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> dma_map_single(struct device *dev, void *cpu_addr, size_t size,</span>
 		      enum dma_data_direction direction)
 
 Maps a piece of processor virtual memory so it can be accessed by the
<span class="p_del">-device and returns the bus address of the memory.</span>
<span class="p_add">+device and returns the DMA address of the memory.</span>
 
 The direction for both APIs may be converted freely by casting.
 However the dma_ API uses a strongly typed enumerator for its
<span class="p_chunk">@@ -212,20 +212,20 @@</span> <span class="p_context"> contiguous piece of memory.  For this reason, memory to be mapped by</span>
 this API should be obtained from sources which guarantee it to be
 physically contiguous (like kmalloc).
 
<span class="p_del">-Further, the bus address of the memory must be within the</span>
<span class="p_add">+Further, the DMA address of the memory must be within the</span>
 dma_mask of the device (the dma_mask is a bit mask of the
<span class="p_del">-addressable region for the device, i.e., if the bus address of</span>
<span class="p_del">-the memory ANDed with the dma_mask is still equal to the bus</span>
<span class="p_add">+addressable region for the device, i.e., if the DMA address of</span>
<span class="p_add">+the memory ANDed with the dma_mask is still equal to the DMA</span>
 address, then the device can perform DMA to the memory).  To
 ensure that the memory allocated by kmalloc is within the dma_mask,
 the driver may specify various platform-dependent flags to restrict
<span class="p_del">-the bus address range of the allocation (e.g., on x86, GFP_DMA</span>
<span class="p_del">-guarantees to be within the first 16MB of available bus addresses,</span>
<span class="p_add">+the DMA address range of the allocation (e.g., on x86, GFP_DMA</span>
<span class="p_add">+guarantees to be within the first 16MB of available DMA addresses,</span>
 as required by ISA devices).
 
 Note also that the above constraints on physical contiguity and
 dma_mask may not apply if the platform has an IOMMU (a device which
<span class="p_del">-maps an I/O bus address to a physical memory address).  However, to be</span>
<span class="p_add">+maps an I/O DMA address to a physical memory address).  However, to be</span>
 portable, device driver writers may *not* assume that such an IOMMU
 exists.
 
<span class="p_chunk">@@ -296,7 +296,7 @@</span> <span class="p_context"> reduce current DMA mapping usage or delay and try again later).</span>
 	dma_map_sg(struct device *dev, struct scatterlist *sg,
 		int nents, enum dma_data_direction direction)
 
<span class="p_del">-Returns: the number of bus address segments mapped (this may be shorter</span>
<span class="p_add">+Returns: the number of DMA address segments mapped (this may be shorter</span>
 than &lt;nents&gt; passed in if some elements of the scatter/gather list are
 physically or virtually adjacent and an IOMMU maps them with a single
 entry).
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"> must be the same as those and passed in to the scatter/gather mapping</span>
 API.
 
 Note: &lt;nents&gt; must be the number you passed in, *not* the number of
<span class="p_del">-bus address entries returned.</span>
<span class="p_add">+DMA address entries returned.</span>
 
 void
 dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle, size_t size,
<span class="p_chunk">@@ -507,7 +507,7 @@</span> <span class="p_context"> it&#39;s asked for coherent memory for this device.</span>
 phys_addr is the CPU physical address to which the memory is currently
 assigned (this will be ioremapped so the CPU can access the region).
 
<span class="p_del">-device_addr is the bus address the device needs to be programmed</span>
<span class="p_add">+device_addr is the DMA address the device needs to be programmed</span>
 with to actually address this memory (this will be handed out as the
 dma_addr_t in dma_alloc_coherent()).
 
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">index 750d577..f5a8ca2 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 * Marvell Armada 370 / Armada XP Ethernet Controller (NETA)
 
 Required properties:
<span class="p_del">-- compatible: should be &quot;marvell,armada-370-neta&quot;.</span>
<span class="p_add">+- compatible: &quot;marvell,armada-370-neta&quot; or &quot;marvell,armada-xp-neta&quot;.</span>
 - reg: address and length of the register set for the device.
 - interrupts: interrupt for the device
 - phy: See ethernet.txt file in the same directory.
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index adda2a8..e357b02 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -92,5 +92,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">index 7de0cda..bedbe42 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_chunk">@@ -22,8 +22,8 @@</span> <span class="p_context"> mpp5          5        gpio, dev(ad7), spi0(cs2), spi1(cs2)</span>
 mpp6          6        gpio, dev(ad0), led(p1), audio(rclk)
 mpp7          7        gpio, dev(ad1), ptp(clk), led(p2), audio(extclk)
 mpp8          8        gpio, dev (bootcs), spi0(cs0), spi1(cs0)
<span class="p_del">-mpp9          9        gpio, nf(wen), spi0(sck), spi1(sck)</span>
<span class="p_del">-mpp10        10        gpio, nf(ren), dram(vttctrl), led(c1)</span>
<span class="p_add">+mpp9          9        gpio, spi0(sck), spi1(sck), nand(we)</span>
<span class="p_add">+mpp10        10        gpio, dram(vttctrl), led(c1), nand(re)</span>
 mpp11        11        gpio, dev(a0), led(c2), audio(sdo)
 mpp12        12        gpio, dev(a1), audio(bclk)
 mpp13        13        gpio, dev(readyn), pcie0(rstoutn), pcie1(rstoutn)
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">index b17c968..4ac138a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_chunk">@@ -27,15 +27,15 @@</span> <span class="p_context"> mpp8          8        gpio, ge0(txd1), dev(ad10)</span>
 mpp9          9        gpio, ge0(txd2), dev(ad11)
 mpp10         10       gpio, ge0(txd3), dev(ad12)
 mpp11         11       gpio, ge0(txctl), dev(ad13)
<span class="p_del">-mpp12         12       gpio, ge0(rxd0), pcie0(rstout), pcie1(rstout) [1], spi0(cs1), dev(ad14)</span>
<span class="p_del">-mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15)</span>
<span class="p_del">-mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1)</span>
<span class="p_del">-mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi), pcie1(rstout) [1]</span>
<span class="p_del">-mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq)</span>
<span class="p_add">+mpp12         12       gpio, ge0(rxd0), pcie0(rstout), spi0(cs1), dev(ad14), pcie3(clkreq)</span>
<span class="p_add">+mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15), pcie2(clkreq)</span>
<span class="p_add">+mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1), pcie3(clkreq)</span>
<span class="p_add">+mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi)</span>
<span class="p_add">+mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq), pcie1(clkreq) [1]</span>
 mpp17         17       gpio, ge0(rxclk), ptp(clk), ua1(rxd), spi0(sck), sata1(prsnt)
<span class="p_del">-mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0), pcie1(rstout) [1]</span>
<span class="p_del">-mpp19         19       gpio, ge0(col), ptp(event_req), pcie0(clkreq), sata1(prsnt), ua0(cts)</span>
<span class="p_del">-mpp20         20       gpio, ge0(txclk), ptp(clk), pcie1(rstout) [1], sata0(prsnt), ua0(rts)</span>
<span class="p_add">+mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0)</span>
<span class="p_add">+mpp19         19       gpio, ge0(col), ptp(event_req), ge0(txerr), sata1(prsnt), ua0(cts)</span>
<span class="p_add">+mpp20         20       gpio, ge0(txclk), ptp(clk), sata0(prsnt), ua0(rts)</span>
 mpp21         21       gpio, spi0(cs1), ge1(rxd0), sata0(prsnt), sd0(cmd), dev(bootcs)
 mpp22         22       gpio, spi0(mosi), dev(ad0)
 mpp23         23       gpio, spi0(sck), dev(ad2)
<span class="p_chunk">@@ -58,23 +58,23 @@</span> <span class="p_context"> mpp39         39       gpio, i2c1(sck), ge1(rxd2), ua0(cts), sd0(d1), dev(a2)</span>
 mpp40         40       gpio, i2c1(sda), ge1(rxd3), ua0(rts), sd0(d2), dev(ad6)
 mpp41         41       gpio, ua1(rxd), ge1(rxctl), ua0(cts), spi1(cs3), dev(burst/last)
 mpp42         42       gpio, ua1(txd), ua0(rts), dev(ad7)
<span class="p_del">-mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), pcie0(rstout), dev(clkout)</span>
<span class="p_del">-mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3], pcie0(rstout)</span>
<span class="p_del">-mpp45         45       gpio, ref(clk_out0), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp46         46       gpio, ref(clk_out1), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], spi1(cs2), sata3(prsnt) [2]</span>
<span class="p_del">-mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4)</span>
<span class="p_del">-mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5)</span>
<span class="p_del">-mpp50         50       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(drx), audio(extclk), sd0(cmd)</span>
<span class="p_add">+mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), spi1(cs2), dev(clkout)</span>
<span class="p_add">+mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3]</span>
<span class="p_add">+mpp45         45       gpio, ref(clk_out0), pcie0(rstout)</span>
<span class="p_add">+mpp46         46       gpio, ref(clk_out1), pcie0(rstout)</span>
<span class="p_add">+mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [2]</span>
<span class="p_add">+mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4), pcie0(clkreq)</span>
<span class="p_add">+mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5), pcie1(clkreq)</span>
<span class="p_add">+mpp50         50       gpio, pcie0(rstout), tdm2c(drx), audio(extclk), sd0(cmd)</span>
 mpp51         51       gpio, tdm2c(dtx), audio(sdo), m(decc_err)
<span class="p_del">-mpp52         52       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(intn), audio(sdi), sd0(d6)</span>
<span class="p_add">+mpp52         52       gpio, pcie0(rstout), tdm2c(intn), audio(sdi), sd0(d6)</span>
 mpp53         53       gpio, sata1(prsnt), sata0(prsnt), tdm2c(rstn), audio(bclk), sd0(d7)
<span class="p_del">-mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), pcie1(rstout) [1], sd0(d3)</span>
<span class="p_add">+mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), ge0(txerr), sd0(d3)</span>
 mpp55         55       gpio, ua1(cts), ge(mdio), pcie1(clkreq) [1], spi1(cs1), sd0(d0)
 mpp56         56       gpio, ua1(rts), ge(mdc), m(decc_err), spi1(mosi)
 mpp57         57       gpio, spi1(sck), sd0(clk)
 mpp58         58       gpio, pcie1(clkreq) [1], i2c1(sck), pcie2(clkreq), spi1(miso), sd0(d1)
<span class="p_del">-mpp59         59       gpio, pcie0(rstout), i2c1(sda), pcie1(rstout) [1], spi1(cs0), sd0(d2)</span>
<span class="p_add">+mpp59         59       gpio, pcie0(rstout), i2c1(sda), spi1(cs0), sd0(d2)</span>
 
 [1]: only available on 88F6820 and 88F6828
 [2]: only available on 88F6828
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index 373dbccd..96e7744 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -42,15 +42,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -58,21 +58,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -84,9 +81,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -96,6 +93,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Documentation/networking/pktgen.txt b/Documentation/networking/pktgen.txt</span>
<span class="p_header">index 6915c6b..5c606cd 100644</span>
<span class="p_header">--- a/Documentation/networking/pktgen.txt</span>
<span class="p_header">+++ b/Documentation/networking/pktgen.txt</span>
<span class="p_chunk">@@ -145,6 +145,7 @@</span> <span class="p_context"> Examples:</span>
                               UDPCSUM,
                               IPSEC # IPsec encapsulation (needs CONFIG_XFRM)
                               NODE_ALLOC # node specific memory allocation
<span class="p_add">+                              NO_TIMESTAMP # disable timestamping</span>
 
  pgset spi SPI_VALUE     Set specific SA used to transform packet.
 
<span class="p_chunk">@@ -285,6 +286,7 @@</span> <span class="p_context"> flag</span>
   UDPCSUM
   IPSEC
   NODE_ALLOC
<span class="p_add">+  NO_TIMESTAMP</span>
 
 dst_min
 dst_max
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b2f65ac..ab8a985 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt3</span>
<span class="p_add">+EXTRAVERSION = -ckt4</span>
 NAME = Sedated Swine
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/atomic.h b/arch/arc/include/asm/atomic.h</span>
<span class="p_header">index 9917a45..20b7dc1 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -43,6 +43,12 @@</span> <span class="p_context"> static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
 {									\
 	unsigned int temp;						\
 									\
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as		\</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	__asm__ __volatile__(						\
 	&quot;1:	llock   %0, [%1]	\n&quot;				\
 	&quot;	&quot; #asm_op &quot; %0, %0, %2	\n&quot;				\
<span class="p_chunk">@@ -52,6 +58,8 @@</span> <span class="p_context"> static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
 	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)					\
 	: &quot;cc&quot;);							\
 									\
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	return temp;							\
 }
 
<span class="p_chunk">@@ -105,6 +113,9 @@</span> <span class="p_context"> static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
 	unsigned long flags;						\
 	unsigned long temp;						\
 									\
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * spin lock/unlock provides the needed smp_mb() before/after	\</span>
<span class="p_add">+	 */								\</span>
 	atomic_ops_lock(flags);						\
 	temp = v-&gt;counter;						\
 	temp c_op i;							\
<span class="p_chunk">@@ -142,9 +153,19 @@</span> <span class="p_context"> ATOMIC_OP(and, &amp;=, and)</span>
 #define __atomic_add_unless(v, a, u)					\
 ({									\
 	int c, old;							\
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as		\</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	c = atomic_read(v);						\
 	while (c != (u) &amp;&amp; (old = atomic_cmpxchg((v), c, c + (a))) != c)\
 		c = old;						\
<span class="p_add">+									\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	c;								\
 })
 
<span class="p_header">diff --git a/arch/arc/include/asm/bitops.h b/arch/arc/include/asm/bitops.h</span>
<span class="p_header">index 1a5bf07..1af9629 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/bitops.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/bitops.h</span>
<span class="p_chunk">@@ -103,6 +103,12 @@</span> <span class="p_context"> static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as</span>
<span class="p_add">+	 * LLOCK/SCOND themselves don&#39;t provide any such semantics</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bset    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -112,6 +118,8 @@</span> <span class="p_context"> static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -125,6 +133,8 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bclr    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -134,6 +144,8 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -147,6 +159,8 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bxor    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -156,6 +170,8 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -254,6 +270,9 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin lock/unlock provide the needed smp_mb() before/after</span>
<span class="p_add">+	 */</span>
 	bitops_lock(flags);
 
 	old = *m;
<span class="p_header">diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">index 03cd689..44fd531 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -10,6 +10,8 @@</span> <span class="p_context"></span>
 #define __ASM_ARC_CMPXCHG_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/barrier.h&gt;</span>
 #include &lt;asm/smp.h&gt;
 
 #ifdef CONFIG_ARC_HAS_LLSC
<span class="p_chunk">@@ -19,16 +21,25 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 {
 	unsigned long prev;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%1]	\n&quot;
 	&quot;	brne    %0, %2, 2f	\n&quot;
 	&quot;	scond   %3, [%1]	\n&quot;
 	&quot;	bnz     1b		\n&quot;
 	&quot;2:				\n&quot;
<span class="p_del">-	: &quot;=&amp;r&quot;(prev)</span>
<span class="p_del">-	: &quot;r&quot;(ptr), &quot;ir&quot;(expected),</span>
<span class="p_del">-	  &quot;r&quot;(new) /* can&#39;t be &quot;ir&quot;. scond can&#39;t take limm for &quot;b&quot; */</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(prev)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_add">+	: &quot;r&quot;(ptr),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */</span>
<span class="p_add">+	  &quot;ir&quot;(expected),</span>
<span class="p_add">+	  &quot;r&quot;(new)	/* can&#39;t be &quot;ir&quot;. scond can&#39;t take LIMM for &quot;b&quot; */</span>
<span class="p_add">+	: &quot;cc&quot;, &quot;memory&quot;); /* so that gcc knows memory is being written here */</span>
<span class="p_add">+</span>
<span class="p_add">+	smp_mb();</span>
 
 	return prev;
 }
<span class="p_chunk">@@ -42,6 +53,9 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 	int prev;
 	volatile unsigned long *p = ptr;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin lock/unlock provide the needed smp_mb() before/after</span>
<span class="p_add">+	 */</span>
 	atomic_ops_lock(flags);
 	prev = *p;
 	if (prev == expected)
<span class="p_chunk">@@ -77,12 +91,16 @@</span> <span class="p_context"> static inline unsigned long __xchg(unsigned long val, volatile void *ptr,</span>
 
 	switch (size) {
 	case 4:
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		__asm__ __volatile__(
 		&quot;	ex  %0, [%1]	\n&quot;
 		: &quot;+r&quot;(val)
 		: &quot;r&quot;(ptr)
 		: &quot;memory&quot;);
 
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		return val;
 	}
 	return __xchg_bad_pointer();
<span class="p_header">diff --git a/arch/arc/include/asm/spinlock.h b/arch/arc/include/asm/spinlock.h</span>
<span class="p_header">index b6a8c2d..e1651df 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -22,24 +22,46 @@</span> <span class="p_context"> static inline void arch_spin_lock(arch_spinlock_t *lock)</span>
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_LOCKED__;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This smp_mb() is technically superfluous, we only need the one</span>
<span class="p_add">+	 * after the lock for providing the ACQUIRE semantics.</span>
<span class="p_add">+	 * However doing the &quot;right&quot; thing was regressing hackbench</span>
<span class="p_add">+	 * so keeping this, pending further investigation</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	ex  %0, [%1]		\n&quot;
 	&quot;	breq  %0, %2, 1b	\n&quot;
 	: &quot;+&amp;r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock)), &quot;ir&quot;(__ARCH_SPIN_LOCK_LOCKED__)
 	: &quot;memory&quot;);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ACQUIRE barrier to ensure load/store after taking the lock</span>
<span class="p_add">+	 * don&#39;t &quot;bleed-up&quot; out of the critical section (leak-in is allowed)</span>
<span class="p_add">+	 * http://www.spinics.net/lists/kernel/msg2010409.html</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * ARCv2 only has load-load, store-store and all-all barrier</span>
<span class="p_add">+	 * thus need the full all-all barrier</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
 }
 
 static inline int arch_spin_trylock(arch_spinlock_t *lock)
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_LOCKED__;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	ex  %0, [%1]		\n&quot;
 	: &quot;+r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock))
 	: &quot;memory&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (tmp == __ARCH_SPIN_LOCK_UNLOCKED__);
 }
 
<span class="p_chunk">@@ -47,12 +69,22 @@</span> <span class="p_context"> static inline void arch_spin_unlock(arch_spinlock_t *lock)</span>
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_UNLOCKED__;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * RELEASE barrier: given the instructions avail on ARCv2, full barrier</span>
<span class="p_add">+	 * is the only option</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;	ex  %0, [%1]		\n&quot;
 	: &quot;+r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock))
 	: &quot;memory&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * superfluous, but keeping for now - see pairing version in</span>
<span class="p_add">+	 * arch_spin_lock above</span>
<span class="p_add">+	 */</span>
 	smp_mb();
 }
 
<span class="p_header">diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig</span>
<span class="p_header">index 97d07ed..2da8610 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/Kconfig</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"> config ARM</span>
 	select HANDLE_DOMAIN_IRQ
 	select HARDIRQS_SW_RESEND
 	select HAVE_ARCH_AUDITSYSCALL if (AEABI &amp;&amp; !OABI_COMPAT)
<span class="p_del">-	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL</span>
<span class="p_del">-	select HAVE_ARCH_KGDB</span>
<span class="p_add">+	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL &amp;&amp; !CPU_ENDIAN_BE32</span>
<span class="p_add">+	select HAVE_ARCH_KGDB if !CPU_ENDIAN_BE32</span>
 	select HAVE_ARCH_SECCOMP_FILTER if (AEABI &amp;&amp; !OABI_COMPAT)
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_BPF_JIT
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> config ARM</span>
 	select HAVE_DMA_API_DEBUG
 	select HAVE_DMA_ATTRS
 	select HAVE_DMA_CONTIGUOUS if MMU
<span class="p_del">-	select HAVE_DYNAMIC_FTRACE if (!XIP_KERNEL)</span>
<span class="p_add">+	select HAVE_DYNAMIC_FTRACE if (!XIP_KERNEL) &amp;&amp; !CPU_ENDIAN_BE32</span>
 	select HAVE_EFFICIENT_UNALIGNED_ACCESS if (CPU_V6 || CPU_V6K || CPU_V7) &amp;&amp; MMU
 	select HAVE_FTRACE_MCOUNT_RECORD if (!XIP_KERNEL)
 	select HAVE_FUNCTION_GRAPH_TRACER if (!THUMB2_KERNEL)
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> config ARM</span>
 	select HAVE_KERNEL_LZMA
 	select HAVE_KERNEL_LZO
 	select HAVE_KERNEL_XZ
<span class="p_del">-	select HAVE_KPROBES if !XIP_KERNEL</span>
<span class="p_add">+	select HAVE_KPROBES if !XIP_KERNEL &amp;&amp; !CPU_ENDIAN_BE32</span>
 	select HAVE_KRETPROBES if (HAVE_KPROBES)
 	select HAVE_MEMBLOCK
 	select HAVE_MOD_ARCH_SPECIFIC if ARM_UNWIND
<span class="p_chunk">@@ -1318,6 +1318,7 @@</span> <span class="p_context"> config SMP</span>
 	depends on GENERIC_CLOCKEVENTS
 	depends on HAVE_SMP
 	depends on MMU || ARM_MPU
<span class="p_add">+	select IRQ_WORK</span>
 	help
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, say N. If you have a system with more
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-370-xp.dtsi b/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_header">index 1af4286..0c0e6b7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_chunk">@@ -231,7 +231,6 @@</span> <span class="p_context"></span>
 			};
 
 			eth0: ethernet@70000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
 				reg = &lt;0x70000 0x4000&gt;;
 				interrupts = &lt;8&gt;;
 				clocks = &lt;&amp;gateclk 4&gt;;
<span class="p_chunk">@@ -247,7 +246,6 @@</span> <span class="p_context"></span>
 			};
 
 			eth1: ethernet@74000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
 				reg = &lt;0x74000 0x4000&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;gateclk 3&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-370.dtsi b/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_header">index fdb3c12..7124a5b 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_chunk">@@ -272,6 +272,14 @@</span> <span class="p_context"></span>
 					dmacap,memset;
 				};
 			};
<span class="p_add">+</span>
<span class="p_add">+			ethernet@70000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
<span class="p_add">+			ethernet@74000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+			};</span>
 		};
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-mv78260.dtsi b/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_header">index d7a8d0b..b8af89f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth3: ethernet@34000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x34000 0x4000&gt;;
 				interrupts = &lt;14&gt;;
 				clocks = &lt;&amp;gateclk 1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-mv78460.dtsi b/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_header">index 9c40c13..4b55434 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth3: ethernet@34000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x34000 0x4000&gt;;
 				interrupts = &lt;14&gt;;
 				clocks = &lt;&amp;gateclk 1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp.dtsi b/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_header">index 62c3ba9..fa955dd 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth2: ethernet@30000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x30000 0x4000&gt;;
 				interrupts = &lt;12&gt;;
 				clocks = &lt;&amp;gateclk 2&gt;;
<span class="p_chunk">@@ -184,6 +184,14 @@</span> <span class="p_context"></span>
 				};
 			};
 
<span class="p_add">+			ethernet@70000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
<span class="p_add">+			ethernet@74000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
 			xor@f0900 {
 				compatible = &quot;marvell,orion-xor&quot;;
 				reg = &lt;0xF0900 0x100
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4ek.dts b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">index 9198b71..004c08a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_chunk">@@ -108,8 +108,8 @@</span> <span class="p_context"></span>
 			mmc0: mmc@f8000000 {
 				pinctrl-names = &quot;default&quot;;
 				pinctrl-0 = &lt;&amp;pinctrl_mmc0_clk_cmd_dat0 &amp;pinctrl_mmc0_dat1_3 &amp;pinctrl_mmc0_cd&gt;;
<span class="p_del">-				slot@1 {</span>
<span class="p_del">-					reg = &lt;1&gt;;</span>
<span class="p_add">+				slot@0 {</span>
<span class="p_add">+					reg = &lt;0&gt;;</span>
 					bus-width = &lt;4&gt;;
 					cd-gpios = &lt;&amp;pioE 5 0&gt;;
 				};
<span class="p_header">diff --git a/arch/arm/kvm/interrupts.S b/arch/arm/kvm/interrupts.S</span>
<span class="p_header">index 01dcb0e..d66d608 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts.S</span>
<span class="p_chunk">@@ -159,13 +159,9 @@</span> <span class="p_context"> __kvm_vcpu_return:</span>
 	@ Don&#39;t trap coprocessor accesses for host kernel
 	set_hstr vmexit
 	set_hdcr vmexit
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11)), after_vfp_restore</span>
 
 #ifdef CONFIG_VFPv3
<span class="p_del">-	@ Save floating point registers we if let guest use them.</span>
<span class="p_del">-	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_del">-	bne	after_vfp_restore</span>
<span class="p_del">-</span>
 	@ Switch VFP/NEON hardware state to the host&#39;s
 	add	r7, vcpu, #VCPU_VFP_GUEST
 	store_vfp_state r7
<span class="p_chunk">@@ -177,6 +173,8 @@</span> <span class="p_context"> after_vfp_restore:</span>
 	@ Restore FPEXC_EN which we clobbered on entry
 	pop	{r2}
 	VFPFMXR FPEXC, r2
<span class="p_add">+#else</span>
<span class="p_add">+after_vfp_restore:</span>
 #endif
 
 	@ Reset Hyp-role
<span class="p_chunk">@@ -472,7 +470,7 @@</span> <span class="p_context"> switch_to_guest_vfp:</span>
 	push	{r3-r7}
 
 	@ NEON/VFP used.  Turn on VFP access.
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmtrap, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
 
 	@ Switch VFP/NEON hardware state to the guest&#39;s
 	add	r7, r0, #VCPU_VFP_HOST
<span class="p_header">diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">index 14d4883..f6f1481 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_chunk">@@ -599,8 +599,13 @@</span> <span class="p_context"> ARM_BE8(rev	r6, r6  )</span>
 .endm
 
 /* Configures the HCPTR (Hyp Coprocessor Trap Register) on entry/return
<span class="p_del">- * (hardware reset value is 0). Keep previous value in r2. */</span>
<span class="p_del">-.macro set_hcptr operation, mask</span>
<span class="p_add">+ * (hardware reset value is 0). Keep previous value in r2.</span>
<span class="p_add">+ * An ISB is emited on vmexit/vmtrap, but executed on vmexit only if</span>
<span class="p_add">+ * VFP wasn&#39;t already enabled (always executed on vmtrap).</span>
<span class="p_add">+ * If a label is specified with vmexit, it is branched to if VFP wasn&#39;t</span>
<span class="p_add">+ * enabled.</span>
<span class="p_add">+ */</span>
<span class="p_add">+.macro set_hcptr operation, mask, label = none</span>
 	mrc	p15, 4, r2, c1, c1, 2
 	ldr	r3, =\mask
 	.if \operation == vmentry
<span class="p_chunk">@@ -609,6 +614,17 @@</span> <span class="p_context"> ARM_BE8(rev	r6, r6  )</span>
 	bic	r3, r2, r3		@ Don&#39;t trap defined coproc-accesses
 	.endif
 	mcr	p15, 4, r3, c1, c1, 2
<span class="p_add">+	.if \operation != vmentry</span>
<span class="p_add">+	.if \operation == vmexit</span>
<span class="p_add">+	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.if \label != none</span>
<span class="p_add">+	b	\label</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+1:</span>
<span class="p_add">+	.endif</span>
 .endm
 
 /* Configures the HDCR (Hyp Debug Configuration Register) on entry/return
<span class="p_header">diff --git a/arch/arm/kvm/psci.c b/arch/arm/kvm/psci.c</span>
<span class="p_header">index 58cb324..4d0d89e 100644</span>
<span class="p_header">--- a/arch/arm/kvm/psci.c</span>
<span class="p_header">+++ b/arch/arm/kvm/psci.c</span>
<span class="p_chunk">@@ -237,10 +237,6 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 	case PSCI_0_2_FN64_AFFINITY_INFO:
 		val = kvm_psci_vcpu_affinity_info(vcpu);
 		break;
<span class="p_del">-	case PSCI_0_2_FN_MIGRATE:</span>
<span class="p_del">-	case PSCI_0_2_FN64_MIGRATE:</span>
<span class="p_del">-		val = PSCI_RET_NOT_SUPPORTED;</span>
<span class="p_del">-		break;</span>
 	case PSCI_0_2_FN_MIGRATE_INFO_TYPE:
 		/*
 		 * Trusted OS is MP hence does not require migration
<span class="p_chunk">@@ -249,10 +245,6 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 		 */
 		val = PSCI_0_2_TOS_MP;
 		break;
<span class="p_del">-	case PSCI_0_2_FN_MIGRATE_INFO_UP_CPU:</span>
<span class="p_del">-	case PSCI_0_2_FN64_MIGRATE_INFO_UP_CPU:</span>
<span class="p_del">-		val = PSCI_RET_NOT_SUPPORTED;</span>
<span class="p_del">-		break;</span>
 	case PSCI_0_2_FN_SYSTEM_OFF:
 		kvm_psci_system_off(vcpu);
 		/*
<span class="p_chunk">@@ -278,7 +270,8 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 		ret = 0;
 		break;
 	default:
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		val = PSCI_RET_NOT_SUPPORTED;</span>
<span class="p_add">+		break;</span>
 	}
 
 	*vcpu_reg(vcpu, 0) = val;
<span class="p_chunk">@@ -298,12 +291,9 @@</span> <span class="p_context"> static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)</span>
 	case KVM_PSCI_FN_CPU_ON:
 		val = kvm_psci_vcpu_on(vcpu);
 		break;
<span class="p_del">-	case KVM_PSCI_FN_CPU_SUSPEND:</span>
<span class="p_del">-	case KVM_PSCI_FN_MIGRATE:</span>
<span class="p_add">+	default:</span>
 		val = PSCI_RET_NOT_SUPPORTED;
 		break;
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
 	}
 
 	*vcpu_reg(vcpu, 0) = val;
<span class="p_header">diff --git a/arch/arm/mach-dove/include/mach/irqs.h b/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_header">index 03d401d..3f29e6bc 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_header">+++ b/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_chunk">@@ -14,73 +14,73 @@</span> <span class="p_context"></span>
 /*
  * Dove Low Interrupt Controller
  */
<span class="p_del">-#define IRQ_DOVE_BRIDGE		0</span>
<span class="p_del">-#define IRQ_DOVE_H2C		1</span>
<span class="p_del">-#define IRQ_DOVE_C2H		2</span>
<span class="p_del">-#define IRQ_DOVE_NAND		3</span>
<span class="p_del">-#define IRQ_DOVE_PDMA		4</span>
<span class="p_del">-#define IRQ_DOVE_SPI1		5</span>
<span class="p_del">-#define IRQ_DOVE_SPI0		6</span>
<span class="p_del">-#define IRQ_DOVE_UART_0		7</span>
<span class="p_del">-#define IRQ_DOVE_UART_1		8</span>
<span class="p_del">-#define IRQ_DOVE_UART_2		9</span>
<span class="p_del">-#define IRQ_DOVE_UART_3		10</span>
<span class="p_del">-#define IRQ_DOVE_I2C		11</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_0_7	12</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_8_15	13</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_16_23	14</span>
<span class="p_del">-#define IRQ_DOVE_PCIE0_ERR	15</span>
<span class="p_del">-#define IRQ_DOVE_PCIE0		16</span>
<span class="p_del">-#define IRQ_DOVE_PCIE1_ERR	17</span>
<span class="p_del">-#define IRQ_DOVE_PCIE1		18</span>
<span class="p_del">-#define IRQ_DOVE_I2S0		19</span>
<span class="p_del">-#define IRQ_DOVE_I2S0_ERR	20</span>
<span class="p_del">-#define IRQ_DOVE_I2S1		21</span>
<span class="p_del">-#define IRQ_DOVE_I2S1_ERR	22</span>
<span class="p_del">-#define IRQ_DOVE_USB_ERR	23</span>
<span class="p_del">-#define IRQ_DOVE_USB0		24</span>
<span class="p_del">-#define IRQ_DOVE_USB1		25</span>
<span class="p_del">-#define IRQ_DOVE_GE00_RX	26</span>
<span class="p_del">-#define IRQ_DOVE_GE00_TX	27</span>
<span class="p_del">-#define IRQ_DOVE_GE00_MISC	28</span>
<span class="p_del">-#define IRQ_DOVE_GE00_SUM	29</span>
<span class="p_del">-#define IRQ_DOVE_GE00_ERR	30</span>
<span class="p_del">-#define IRQ_DOVE_CRYPTO		31</span>
<span class="p_add">+#define IRQ_DOVE_BRIDGE		(1 + 0)</span>
<span class="p_add">+#define IRQ_DOVE_H2C		(1 + 1)</span>
<span class="p_add">+#define IRQ_DOVE_C2H		(1 + 2)</span>
<span class="p_add">+#define IRQ_DOVE_NAND		(1 + 3)</span>
<span class="p_add">+#define IRQ_DOVE_PDMA		(1 + 4)</span>
<span class="p_add">+#define IRQ_DOVE_SPI1		(1 + 5)</span>
<span class="p_add">+#define IRQ_DOVE_SPI0		(1 + 6)</span>
<span class="p_add">+#define IRQ_DOVE_UART_0		(1 + 7)</span>
<span class="p_add">+#define IRQ_DOVE_UART_1		(1 + 8)</span>
<span class="p_add">+#define IRQ_DOVE_UART_2		(1 + 9)</span>
<span class="p_add">+#define IRQ_DOVE_UART_3		(1 + 10)</span>
<span class="p_add">+#define IRQ_DOVE_I2C		(1 + 11)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_0_7	(1 + 12)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_8_15	(1 + 13)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_16_23	(1 + 14)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE0_ERR	(1 + 15)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE0		(1 + 16)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE1_ERR	(1 + 17)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE1		(1 + 18)</span>
<span class="p_add">+#define IRQ_DOVE_I2S0		(1 + 19)</span>
<span class="p_add">+#define IRQ_DOVE_I2S0_ERR	(1 + 20)</span>
<span class="p_add">+#define IRQ_DOVE_I2S1		(1 + 21)</span>
<span class="p_add">+#define IRQ_DOVE_I2S1_ERR	(1 + 22)</span>
<span class="p_add">+#define IRQ_DOVE_USB_ERR	(1 + 23)</span>
<span class="p_add">+#define IRQ_DOVE_USB0		(1 + 24)</span>
<span class="p_add">+#define IRQ_DOVE_USB1		(1 + 25)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_RX	(1 + 26)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_TX	(1 + 27)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_MISC	(1 + 28)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_SUM	(1 + 29)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_ERR	(1 + 30)</span>
<span class="p_add">+#define IRQ_DOVE_CRYPTO		(1 + 31)</span>
 
 /*
  * Dove High Interrupt Controller
  */
<span class="p_del">-#define IRQ_DOVE_AC97		32</span>
<span class="p_del">-#define IRQ_DOVE_PMU		33</span>
<span class="p_del">-#define IRQ_DOVE_CAM		34</span>
<span class="p_del">-#define IRQ_DOVE_SDIO0		35</span>
<span class="p_del">-#define IRQ_DOVE_SDIO1		36</span>
<span class="p_del">-#define IRQ_DOVE_SDIO0_WAKEUP	37</span>
<span class="p_del">-#define IRQ_DOVE_SDIO1_WAKEUP	38</span>
<span class="p_del">-#define IRQ_DOVE_XOR_00		39</span>
<span class="p_del">-#define IRQ_DOVE_XOR_01		40</span>
<span class="p_del">-#define IRQ_DOVE_XOR0_ERR	41</span>
<span class="p_del">-#define IRQ_DOVE_XOR_10		42</span>
<span class="p_del">-#define IRQ_DOVE_XOR_11		43</span>
<span class="p_del">-#define IRQ_DOVE_XOR1_ERR	44</span>
<span class="p_del">-#define IRQ_DOVE_LCD_DCON	45</span>
<span class="p_del">-#define IRQ_DOVE_LCD1		46</span>
<span class="p_del">-#define IRQ_DOVE_LCD0		47</span>
<span class="p_del">-#define IRQ_DOVE_GPU		48</span>
<span class="p_del">-#define IRQ_DOVE_PERFORM_MNTR	49</span>
<span class="p_del">-#define IRQ_DOVE_VPRO_DMA1	51</span>
<span class="p_del">-#define IRQ_DOVE_SSP_TIMER	54</span>
<span class="p_del">-#define IRQ_DOVE_SSP		55</span>
<span class="p_del">-#define IRQ_DOVE_MC_L2_ERR	56</span>
<span class="p_del">-#define IRQ_DOVE_CRYPTO_ERR	59</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_24_31	60</span>
<span class="p_del">-#define IRQ_DOVE_HIGH_GPIO	61</span>
<span class="p_del">-#define IRQ_DOVE_SATA		62</span>
<span class="p_add">+#define IRQ_DOVE_AC97		(1 + 32)</span>
<span class="p_add">+#define IRQ_DOVE_PMU		(1 + 33)</span>
<span class="p_add">+#define IRQ_DOVE_CAM		(1 + 34)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO0		(1 + 35)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO1		(1 + 36)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO0_WAKEUP	(1 + 37)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO1_WAKEUP	(1 + 38)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_00		(1 + 39)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_01		(1 + 40)</span>
<span class="p_add">+#define IRQ_DOVE_XOR0_ERR	(1 + 41)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_10		(1 + 42)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_11		(1 + 43)</span>
<span class="p_add">+#define IRQ_DOVE_XOR1_ERR	(1 + 44)</span>
<span class="p_add">+#define IRQ_DOVE_LCD_DCON	(1 + 45)</span>
<span class="p_add">+#define IRQ_DOVE_LCD1		(1 + 46)</span>
<span class="p_add">+#define IRQ_DOVE_LCD0		(1 + 47)</span>
<span class="p_add">+#define IRQ_DOVE_GPU		(1 + 48)</span>
<span class="p_add">+#define IRQ_DOVE_PERFORM_MNTR	(1 + 49)</span>
<span class="p_add">+#define IRQ_DOVE_VPRO_DMA1	(1 + 51)</span>
<span class="p_add">+#define IRQ_DOVE_SSP_TIMER	(1 + 54)</span>
<span class="p_add">+#define IRQ_DOVE_SSP		(1 + 55)</span>
<span class="p_add">+#define IRQ_DOVE_MC_L2_ERR	(1 + 56)</span>
<span class="p_add">+#define IRQ_DOVE_CRYPTO_ERR	(1 + 59)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_24_31	(1 + 60)</span>
<span class="p_add">+#define IRQ_DOVE_HIGH_GPIO	(1 + 61)</span>
<span class="p_add">+#define IRQ_DOVE_SATA		(1 + 62)</span>
 
 /*
  * DOVE General Purpose Pins
  */
<span class="p_del">-#define IRQ_DOVE_GPIO_START	64</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_START	65</span>
 #define NR_GPIO_IRQS		64
 
 /*
<span class="p_header">diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c</span>
<span class="p_header">index 4a5a7ae..df0223f 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/irq.c</span>
<span class="p_header">+++ b/arch/arm/mach-dove/irq.c</span>
<span class="p_chunk">@@ -126,14 +126,14 @@</span> <span class="p_context"> __exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)</span>
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_LOW_OFF);
 	stat &amp;= readl_relaxed(dove_irq_base + IRQ_MASK_LOW_OFF);
 	if (stat) {
<span class="p_del">-		unsigned int hwirq = __fls(stat);</span>
<span class="p_add">+		unsigned int hwirq = 1 + __fls(stat);</span>
 		handle_IRQ(hwirq, regs);
 		return;
 	}
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_HIGH_OFF);
 	stat &amp;= readl_relaxed(dove_irq_base + IRQ_MASK_HIGH_OFF);
 	if (stat) {
<span class="p_del">-		unsigned int hwirq = 32 + __fls(stat);</span>
<span class="p_add">+		unsigned int hwirq = 33 + __fls(stat);</span>
 		handle_IRQ(hwirq, regs);
 		return;
 	}
<span class="p_chunk">@@ -144,8 +144,8 @@</span> <span class="p_context"> void __init dove_init_irq(void)</span>
 {
 	int i;
 
<span class="p_del">-	orion_irq_init(0, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);</span>
<span class="p_del">-	orion_irq_init(32, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);</span>
<span class="p_add">+	orion_irq_init(1, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);</span>
<span class="p_add">+	orion_irq_init(33, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);</span>
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(dove_legacy_handle_irq);
<span class="p_header">diff --git a/arch/arm/mach-mvebu/pm-board.c b/arch/arm/mach-mvebu/pm-board.c</span>
<span class="p_header">index 6dfd4ab..301ab38 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/pm-board.c</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/pm-board.c</span>
<span class="p_chunk">@@ -43,6 +43,9 @@</span> <span class="p_context"> static void mvebu_armada_xp_gp_pm_enter(void __iomem *sdram_reg, u32 srcmd)</span>
 	for (i = 0; i &lt; ARMADA_XP_GP_PIC_NR_GPIOS; i++)
 		ackcmd |= BIT(pic_raw_gpios[i]);
 
<span class="p_add">+	srcmd = cpu_to_le32(srcmd);</span>
<span class="p_add">+	ackcmd = cpu_to_le32(ackcmd);</span>
<span class="p_add">+</span>
 	/*
 	 * Wait a while, the PIC needs quite a bit of time between the
 	 * two GPIO commands.
<span class="p_header">diff --git a/arch/arm/mach-tegra/cpuidle-tegra20.c b/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_header">index 4f25a7c..a351eff 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/cpuidle-tegra20.c</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #include &quot;iomap.h&quot;
 #include &quot;irq.h&quot;
 #include &quot;pm.h&quot;
<span class="p_add">+#include &quot;reset.h&quot;</span>
 #include &quot;sleep.h&quot;
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -71,15 +72,13 @@</span> <span class="p_context"> static struct cpuidle_driver tegra_idle_driver = {</span>
 
 #ifdef CONFIG_PM_SLEEP
 #ifdef CONFIG_SMP
<span class="p_del">-static void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);</span>
<span class="p_del">-</span>
 static int tegra20_reset_sleeping_cpu_1(void)
 {
 	int ret = 0;
 
 	tegra_pen_lock();
 
<span class="p_del">-	if (readl(pmc + PMC_SCRATCH41) == CPU_RESETTABLE)</span>
<span class="p_add">+	if (readb(tegra20_cpu1_resettable_status) == CPU_RESETTABLE)</span>
 		tegra20_cpu_shutdown(1);
 	else
 		ret = -EINVAL;
<span class="p_header">diff --git a/arch/arm/mach-tegra/reset-handler.S b/arch/arm/mach-tegra/reset-handler.S</span>
<span class="p_header">index 71be4af..e3070fd 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/reset-handler.S</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/reset-handler.S</span>
<span class="p_chunk">@@ -169,10 +169,10 @@</span> <span class="p_context"> after_errata:</span>
 	cmp	r6, #TEGRA20
 	bne	1f
 	/* If not CPU0, don&#39;t let CPU0 reset CPU1 now that CPU1 is coming up. */
<span class="p_del">-	mov32	r5, TEGRA_PMC_BASE</span>
<span class="p_del">-	mov	r0, #0</span>
<span class="p_add">+	mov32	r5, TEGRA_IRAM_BASE + TEGRA_IRAM_RESET_HANDLER_OFFSET</span>
<span class="p_add">+	mov	r0, #CPU_NOT_RESETTABLE</span>
 	cmp	r10, #0
<span class="p_del">-	strne	r0, [r5, #PMC_SCRATCH41]</span>
<span class="p_add">+	strneb	r0, [r5, #__tegra20_cpu1_resettable_status_offset]</span>
 1:
 #endif
 
<span class="p_chunk">@@ -281,6 +281,10 @@</span> <span class="p_context"> __tegra_cpu_reset_handler_data:</span>
 	.rept	TEGRA_RESET_DATA_SIZE
 	.long	0
 	.endr
<span class="p_add">+	.globl	__tegra20_cpu1_resettable_status_offset</span>
<span class="p_add">+	.equ	__tegra20_cpu1_resettable_status_offset, \</span>
<span class="p_add">+					. - __tegra_cpu_reset_handler_start</span>
<span class="p_add">+	.byte	0</span>
 	.align L1_CACHE_SHIFT
 
 ENTRY(__tegra_cpu_reset_handler_end)
<span class="p_header">diff --git a/arch/arm/mach-tegra/reset.h b/arch/arm/mach-tegra/reset.h</span>
<span class="p_header">index 76a9343..29c3dec 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/reset.h</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/reset.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"> extern unsigned long __tegra_cpu_reset_handler_data[TEGRA_RESET_DATA_SIZE];</span>
 
 void __tegra_cpu_reset_handler_start(void);
 void __tegra_cpu_reset_handler(void);
<span class="p_add">+void __tegra20_cpu1_resettable_status_offset(void);</span>
 void __tegra_cpu_reset_handler_end(void);
 void tegra_secondary_startup(void);
 
<span class="p_chunk">@@ -47,6 +48,9 @@</span> <span class="p_context"> void tegra_secondary_startup(void);</span>
 	(IO_ADDRESS(TEGRA_IRAM_BASE + TEGRA_IRAM_RESET_HANDLER_OFFSET + \
 	((u32)&amp;__tegra_cpu_reset_handler_data[TEGRA_RESET_MASK_LP2] - \
 	 (u32)__tegra_cpu_reset_handler_start)))
<span class="p_add">+#define tegra20_cpu1_resettable_status \</span>
<span class="p_add">+	(IO_ADDRESS(TEGRA_IRAM_BASE + TEGRA_IRAM_RESET_HANDLER_OFFSET + \</span>
<span class="p_add">+	 (u32)__tegra20_cpu1_resettable_status_offset))</span>
 #endif
 
 #define tegra_cpu_reset_handler_offset \
<span class="p_header">diff --git a/arch/arm/mach-tegra/sleep-tegra20.S b/arch/arm/mach-tegra/sleep-tegra20.S</span>
<span class="p_header">index be4bc5f..e6b684e 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/sleep-tegra20.S</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/sleep-tegra20.S</span>
<span class="p_chunk">@@ -97,9 +97,10 @@</span> <span class="p_context"> ENDPROC(tegra20_hotplug_shutdown)</span>
 ENTRY(tegra20_cpu_shutdown)
 	cmp	r0, #0
 	reteq	lr			@ must not be called for CPU 0
<span class="p_del">-	mov32	r1, TEGRA_PMC_VIRT + PMC_SCRATCH41</span>
<span class="p_add">+	mov32	r1, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r2, =__tegra20_cpu1_resettable_status_offset</span>
 	mov	r12, #CPU_RESETTABLE
<span class="p_del">-	str	r12, [r1]</span>
<span class="p_add">+	strb	r12, [r1, r2]</span>
 
 	cpu_to_halt_reg r1, r0
 	ldr	r3, =TEGRA_FLOW_CTRL_VIRT
<span class="p_chunk">@@ -182,38 +183,41 @@</span> <span class="p_context"> ENDPROC(tegra_pen_unlock)</span>
 /*
  * tegra20_cpu_clear_resettable(void)
  *
<span class="p_del">- * Called to clear the &quot;resettable soon&quot; flag in PMC_SCRATCH41 when</span>
<span class="p_add">+ * Called to clear the &quot;resettable soon&quot; flag in IRAM variable when</span>
  * it is expected that the secondary CPU will be idle soon.
  */
 ENTRY(tegra20_cpu_clear_resettable)
<span class="p_del">-	mov32	r1, TEGRA_PMC_VIRT + PMC_SCRATCH41</span>
<span class="p_add">+	mov32	r1, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r2, =__tegra20_cpu1_resettable_status_offset</span>
 	mov	r12, #CPU_NOT_RESETTABLE
<span class="p_del">-	str	r12, [r1]</span>
<span class="p_add">+	strb	r12, [r1, r2]</span>
 	ret	lr
 ENDPROC(tegra20_cpu_clear_resettable)
 
 /*
  * tegra20_cpu_set_resettable_soon(void)
  *
<span class="p_del">- * Called to set the &quot;resettable soon&quot; flag in PMC_SCRATCH41 when</span>
<span class="p_add">+ * Called to set the &quot;resettable soon&quot; flag in IRAM variable when</span>
  * it is expected that the secondary CPU will be idle soon.
  */
 ENTRY(tegra20_cpu_set_resettable_soon)
<span class="p_del">-	mov32	r1, TEGRA_PMC_VIRT + PMC_SCRATCH41</span>
<span class="p_add">+	mov32	r1, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r2, =__tegra20_cpu1_resettable_status_offset</span>
 	mov	r12, #CPU_RESETTABLE_SOON
<span class="p_del">-	str	r12, [r1]</span>
<span class="p_add">+	strb	r12, [r1, r2]</span>
 	ret	lr
 ENDPROC(tegra20_cpu_set_resettable_soon)
 
 /*
  * tegra20_cpu_is_resettable_soon(void)
  *
<span class="p_del">- * Returns true if the &quot;resettable soon&quot; flag in PMC_SCRATCH41 has been</span>
<span class="p_add">+ * Returns true if the &quot;resettable soon&quot; flag in IRAM variable has been</span>
  * set because it is expected that the secondary CPU will be idle soon.
  */
 ENTRY(tegra20_cpu_is_resettable_soon)
<span class="p_del">-	mov32	r1, TEGRA_PMC_VIRT + PMC_SCRATCH41</span>
<span class="p_del">-	ldr	r12, [r1]</span>
<span class="p_add">+	mov32	r1, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r2, =__tegra20_cpu1_resettable_status_offset</span>
<span class="p_add">+	ldrb	r12, [r1, r2]</span>
 	cmp	r12, #CPU_RESETTABLE_SOON
 	moveq	r0, #1
 	movne	r0, #0
<span class="p_chunk">@@ -256,9 +260,10 @@</span> <span class="p_context"> ENTRY(tegra20_sleep_cpu_secondary_finish)</span>
 	mov	r0, #TEGRA_FLUSH_CACHE_LOUIS
 	bl	tegra_disable_clean_inv_dcache
 
<span class="p_del">-	mov32	r0, TEGRA_PMC_VIRT + PMC_SCRATCH41</span>
<span class="p_add">+	mov32	r0, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r4, =__tegra20_cpu1_resettable_status_offset</span>
 	mov	r3, #CPU_RESETTABLE
<span class="p_del">-	str	r3, [r0]</span>
<span class="p_add">+	strb	r3, [r0, r4]</span>
 
 	bl	tegra_cpu_do_idle
 
<span class="p_chunk">@@ -274,10 +279,10 @@</span> <span class="p_context"> ENTRY(tegra20_sleep_cpu_secondary_finish)</span>
 
 	bl	tegra_pen_lock
 
<span class="p_del">-	mov32	r3, TEGRA_PMC_VIRT</span>
<span class="p_del">-	add	r0, r3, #PMC_SCRATCH41</span>
<span class="p_add">+	mov32	r0, TEGRA_IRAM_RESET_BASE_VIRT</span>
<span class="p_add">+	ldr	r4, =__tegra20_cpu1_resettable_status_offset</span>
 	mov	r3, #CPU_NOT_RESETTABLE
<span class="p_del">-	str	r3, [r0]</span>
<span class="p_add">+	strb	r3, [r0, r4]</span>
 
 	bl	tegra_pen_unlock
 
<span class="p_header">diff --git a/arch/arm/mach-tegra/sleep.h b/arch/arm/mach-tegra/sleep.h</span>
<span class="p_header">index 92d46ec..0d59360 100644</span>
<span class="p_header">--- a/arch/arm/mach-tegra/sleep.h</span>
<span class="p_header">+++ b/arch/arm/mach-tegra/sleep.h</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #define __MACH_TEGRA_SLEEP_H
 
 #include &quot;iomap.h&quot;
<span class="p_add">+#include &quot;irammap.h&quot;</span>
 
 #define TEGRA_ARM_PERIF_VIRT (TEGRA_ARM_PERIF_BASE - IO_CPU_PHYS \
 					+ IO_CPU_VIRT)
<span class="p_chunk">@@ -29,6 +30,9 @@</span> <span class="p_context"></span>
 					+ IO_APB_VIRT)
 #define TEGRA_PMC_VIRT	(TEGRA_PMC_BASE - IO_APB_PHYS + IO_APB_VIRT)
 
<span class="p_add">+#define TEGRA_IRAM_RESET_BASE_VIRT (IO_IRAM_VIRT + \</span>
<span class="p_add">+				TEGRA_IRAM_RESET_HANDLER_OFFSET)</span>
<span class="p_add">+</span>
 /* PMC_SCRATCH37-39 and 41 are used for tegra_pen_lock and idle */
 #define PMC_SCRATCH37	0x130
 #define PMC_SCRATCH38	0x134
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index 9b870a2..158b076 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -517,6 +517,7 @@</span> <span class="p_context"> el0_sp_pc:</span>
 	mrs	x26, far_el1
 	// enable interrupts before calling the main handler
 	enable_dbg_and_irq
<span class="p_add">+	ct_user_exit</span>
 	mov	x0, x26
 	mov	x1, x25
 	mov	x2, sp
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index e1b857f..c132df4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -570,7 +570,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	if ((unsigned)ipinr &lt; NR_IPI) {
<span class="p_del">-		trace_ipi_entry(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_entry_rcuidle(ipi_types[ipinr]);</span>
 		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
 	}
 
<span class="p_chunk">@@ -619,7 +619,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	}
 
 	if ((unsigned)ipinr &lt; NR_IPI)
<span class="p_del">-		trace_ipi_exit(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_exit_rcuidle(ipi_types[ipinr]);</span>
 	set_irq_regs(old_regs);
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index ff3bdde..f6fe17d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"> ccflags-y := -shared -fno-common -fno-builtin</span>
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
<span class="p_add">+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared</span>
<span class="p_add">+# down to collect2, resulting in silent corruption of the vDSO image.</span>
<span class="p_add">+ccflags-y += -Wl,-shared</span>
<span class="p_add">+</span>
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index baa758d..76c1e6c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -92,6 +92,14 @@</span> <span class="p_context"> static void reset_context(void *info)</span>
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current-&gt;active_mm;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * current-&gt;active_mm could be init_mm for the idle thread immediately</span>
<span class="p_add">+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to</span>
<span class="p_add">+	 * the reserved value, so no need to reset any context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 2de9d2e..0eeb4f09 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -40,13 +40,13 @@</span> <span class="p_context"> int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)</span>
 
 int pmd_huge(pmd_t pmd)
 {
<span class="p_del">-	return !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
<span class="p_add">+	return pmd_val(pmd) &amp;&amp; !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
 }
 
 int pud_huge(pud_t pud)
 {
 #ifndef __PAGETABLE_PMD_FOLDED
<span class="p_del">-	return !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
<span class="p_add">+	return pud_val(pud) &amp;&amp; !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
 #else
 	return 0;
 #endif
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index c95464a..f752943 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
<span class="p_del">-		prev_end = ALIGN(start + __phys_to_pfn(reg-&gt;size),</span>
<span class="p_add">+		prev_end = ALIGN(__phys_to_pfn(reg-&gt;base + reg-&gt;size),</span>
 				 MAX_ORDER_NR_PAGES);
 	}
 
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit.h b/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">index de0a81a..98a26ce 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit.h</span>
<span class="p_chunk">@@ -110,6 +110,10 @@</span> <span class="p_context"></span>
 /* Rd = Rn &gt;&gt; shift; signed */
 #define A64_ASR(sf, Rd, Rn, shift) A64_SBFM(sf, Rd, Rn, shift, (sf) ? 63 : 31)
 
<span class="p_add">+/* Zero extend */</span>
<span class="p_add">+#define A64_UXTH(sf, Rd, Rn) A64_UBFM(sf, Rd, Rn, 0, 15)</span>
<span class="p_add">+#define A64_UXTW(sf, Rd, Rn) A64_UBFM(sf, Rd, Rn, 0, 31)</span>
<span class="p_add">+</span>
 /* Move wide (immediate) */
 #define A64_MOVEW(sf, Rd, imm16, shift, type) \
 	aarch64_insn_gen_movewide(Rd, imm16, shift, \
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index dc6a484..c047598 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -113,9 +113,9 @@</span> <span class="p_context"> static inline void emit_a64_mov_i(const int is64, const int reg,</span>
 static inline int bpf2a64_offset(int bpf_to, int bpf_from,
 				 const struct jit_ctx *ctx)
 {
<span class="p_del">-	int to = ctx-&gt;offset[bpf_to + 1];</span>
<span class="p_add">+	int to = ctx-&gt;offset[bpf_to];</span>
 	/* -1 to account for the Branch instruction */
<span class="p_del">-	int from = ctx-&gt;offset[bpf_from + 1] - 1;</span>
<span class="p_add">+	int from = ctx-&gt;offset[bpf_from] - 1;</span>
 
 	return to - from;
 }
<span class="p_chunk">@@ -289,23 +289,41 @@</span> <span class="p_context"> static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)</span>
 	case BPF_ALU | BPF_END | BPF_FROM_BE:
 #ifdef CONFIG_CPU_BIG_ENDIAN
 		if (BPF_SRC(code) == BPF_FROM_BE)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto emit_bswap_uxt;</span>
 #else /* !CONFIG_CPU_BIG_ENDIAN */
 		if (BPF_SRC(code) == BPF_FROM_LE)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto emit_bswap_uxt;</span>
 #endif
 		switch (imm) {
 		case 16:
 			emit(A64_REV16(is64, dst, dst), ctx);
<span class="p_add">+			/* zero-extend 16 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTH(is64, dst, dst), ctx);</span>
 			break;
 		case 32:
 			emit(A64_REV32(is64, dst, dst), ctx);
<span class="p_add">+			/* upper 32 bits already cleared */</span>
 			break;
 		case 64:
 			emit(A64_REV64(dst, dst), ctx);
 			break;
 		}
 		break;
<span class="p_add">+emit_bswap_uxt:</span>
<span class="p_add">+		switch (imm) {</span>
<span class="p_add">+		case 16:</span>
<span class="p_add">+			/* zero-extend 16 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTH(is64, dst, dst), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 32:</span>
<span class="p_add">+			/* zero-extend 32 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTW(is64, dst, dst), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 64:</span>
<span class="p_add">+			/* nop */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
 	/* dst = imm */
 	case BPF_ALU | BPF_MOV | BPF_K:
 	case BPF_ALU64 | BPF_MOV | BPF_K:
<span class="p_chunk">@@ -640,10 +658,11 @@</span> <span class="p_context"> static int build_body(struct jit_ctx *ctx)</span>
 		const struct bpf_insn *insn = &amp;prog-&gt;insnsi[i];
 		int ret;
 
<span class="p_add">+		ret = build_insn(insn, ctx);</span>
<span class="p_add">+</span>
 		if (ctx-&gt;image == NULL)
 			ctx-&gt;offset[i] = ctx-&gt;idx;
 
<span class="p_del">-		ret = build_insn(insn, ctx);</span>
 		if (ret &gt; 0) {
 			i++;
 			continue;
<span class="p_header">diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig</span>
<span class="p_header">index 843713c..2a50476 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig</span>
<span class="p_header">+++ b/arch/mips/Kconfig</span>
<span class="p_chunk">@@ -1484,7 +1484,8 @@</span> <span class="p_context"> config CPU_CAVIUM_OCTEON</span>
 	select WEAK_ORDERING
 	select CPU_SUPPORTS_HIGHMEM
 	select CPU_SUPPORTS_HUGEPAGES
<span class="p_del">-	select USB_EHCI_BIG_ENDIAN_MMIO</span>
<span class="p_add">+	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN</span>
<span class="p_add">+	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN</span>
 	select MIPS_L1_CACHE_SHIFT_7
 	help
 	  The Cavium Octeon processor is a highly integrated chip containing
<span class="p_header">diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">index 9488fa5..afc96ec 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_chunk">@@ -94,7 +94,11 @@</span> <span class="p_context"></span>
 #endif
 
 #ifndef FIXADDR_TOP
<span class="p_add">+#ifdef CONFIG_KVM_GUEST</span>
<span class="p_add">+#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)</span>
<span class="p_add">+#else</span>
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
<span class="p_add">+#endif</span>
 
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
<span class="p_header">diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c</span>
<span class="p_header">index 39074fb..a53eaf5 100644</span>
<span class="p_header">--- a/arch/mips/kvm/mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/mips.c</span>
<span class="p_chunk">@@ -784,7 +784,7 @@</span> <span class="p_context"> int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)</span>
 
 	/* If nothing is dirty, don&#39;t bother messing with page tables. */
 	if (is_dirty) {
<span class="p_del">-		memslot = &amp;kvm-&gt;memslots-&gt;memslots[log-&gt;slot];</span>
<span class="p_add">+		memslot = id_to_memslot(kvm-&gt;memslots, log-&gt;slot);</span>
 
 		ga = memslot-&gt;base_gfn &lt;&lt; PAGE_SHIFT;
 		ga_end = ga + (memslot-&gt;npages &lt;&lt; PAGE_SHIFT);
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index 7c4f669..3cb25fd 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -131,7 +131,16 @@</span> <span class="p_context"> static void pmao_restore_workaround(bool ebb) { }</span>
 
 static bool regs_use_siar(struct pt_regs *regs)
 {
<span class="p_del">-	return !!regs-&gt;result;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we take a performance monitor exception the regs are setup</span>
<span class="p_add">+	 * using perf_read_regs() which overloads some fields, in particular</span>
<span class="p_add">+	 * regs-&gt;result to tell us whether to use SIAR.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However if the regs are from another exception, eg. a syscall, then</span>
<span class="p_add">+	 * they have not been setup using perf_read_regs() and so regs-&gt;result</span>
<span class="p_add">+	 * is something random.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return ((TRAP(regs) == 0xf00) &amp;&amp; regs-&gt;result);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 0991578..d852bef 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -419,11 +419,10 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 		return -ENODEV;
 
 	dn = dlpar_configure_connector(cpu_to_be32(drc_index), parent);
<span class="p_add">+	of_node_put(parent);</span>
 	if (!dn)
 		return -EINVAL;
 
<span class="p_del">-	of_node_put(parent);</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/s390/hypfs/inode.c b/arch/s390/hypfs/inode.c</span>
<span class="p_header">index c952b98..e86bbf1 100644</span>
<span class="p_header">--- a/arch/s390/hypfs/inode.c</span>
<span class="p_header">+++ b/arch/s390/hypfs/inode.c</span>
<span class="p_chunk">@@ -461,8 +461,6 @@</span> <span class="p_context"> static const struct super_operations hypfs_s_ops = {</span>
 	.show_options	= hypfs_show_options,
 };
 
<span class="p_del">-static struct kobject *s390_kobj;</span>
<span class="p_del">-</span>
 static int __init hypfs_init(void)
 {
 	int rc;
<span class="p_chunk">@@ -482,18 +480,16 @@</span> <span class="p_context"> static int __init hypfs_init(void)</span>
 		rc = -ENODATA;
 		goto fail_hypfs_vm_exit;
 	}
<span class="p_del">-	s390_kobj = kobject_create_and_add(&quot;s390&quot;, hypervisor_kobj);</span>
<span class="p_del">-	if (!s390_kobj) {</span>
<span class="p_del">-		rc = -ENOMEM;</span>
<span class="p_add">+	rc = sysfs_create_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
<span class="p_add">+	if (rc)</span>
 		goto fail_hypfs_sprp_exit;
<span class="p_del">-	}</span>
 	rc = register_filesystem(&amp;hypfs_type);
 	if (rc)
 		goto fail_filesystem;
 	return 0;
 
 fail_filesystem:
<span class="p_del">-	kobject_put(s390_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
 fail_hypfs_sprp_exit:
 	hypfs_sprp_exit();
 fail_hypfs_vm_exit:
<span class="p_chunk">@@ -509,7 +505,7 @@</span> <span class="p_context"> fail_dbfs_exit:</span>
 static void __exit hypfs_exit(void)
 {
 	unregister_filesystem(&amp;hypfs_type);
<span class="p_del">-	kobject_put(s390_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(hypervisor_kobj, &quot;s390&quot;);</span>
 	hypfs_sprp_exit();
 	hypfs_vm_exit();
 	hypfs_diag_exit();
<span class="p_header">diff --git a/arch/s390/kernel/crash_dump.c b/arch/s390/kernel/crash_dump.c</span>
<span class="p_header">index 9f73c80..49b7445 100644</span>
<span class="p_header">--- a/arch/s390/kernel/crash_dump.c</span>
<span class="p_header">+++ b/arch/s390/kernel/crash_dump.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> static void *nt_s390_vx_low(void *ptr, __vector128 *vx_regs)</span>
 	ptr += len;
 	/* Copy lower halves of SIMD registers 0-15 */
 	for (i = 0; i &lt; 16; i++) {
<span class="p_del">-		memcpy(ptr, &amp;vx_regs[i], 8);</span>
<span class="p_add">+		memcpy(ptr, &amp;vx_regs[i].u[2], 8);</span>
 		ptr += 8;
 	}
 	return ptr;
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 274a9f5..591f119f 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -2313,7 +2313,7 @@</span> <span class="p_context"> void *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,</span>
 	if (len &amp; (8UL - 1))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	buf = kzalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	buf = kzalloc(len, GFP_ATOMIC);</span>
 	if (!buf)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 3a67d76..3121585 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -573,7 +573,7 @@</span> <span class="p_context"> struct kvm_arch {</span>
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
<span class="p_del">-	int vapics_in_nmi_mode;</span>
<span class="p_add">+	atomic_t vapics_in_nmi_mode;</span>
 	struct mutex apic_map_lock;
 	struct kvm_apic_map *apic_map;
 
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index 298781d..1406ffd 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static void pit_do_work(struct kthread_work *work)</span>
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
<span class="p_del">-		if (kvm-&gt;arch.vapics_in_nmi_mode &gt; 0)</span>
<span class="p_add">+		if (atomic_read(&amp;kvm-&gt;arch.vapics_in_nmi_mode) &gt; 0)</span>
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 5ee4e1f..a959f3b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1182,10 +1182,10 @@</span> <span class="p_context"> static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)</span>
 		if (!nmi_wd_enabled) {
 			apic_debug(&quot;Receive NMI setting on APIC_LVT0 &quot;
 				   &quot;for cpu %d\n&quot;, apic-&gt;vcpu-&gt;vcpu_id);
<span class="p_del">-			apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode++;</span>
<span class="p_add">+			atomic_inc(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 		}
 	} else if (nmi_wd_enabled)
<span class="p_del">-		apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode--;</span>
<span class="p_add">+		atomic_dec(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
<span class="p_chunk">@@ -1742,6 +1742,7 @@</span> <span class="p_context"> void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,</span>
 	apic_update_ppr(apic);
 	hrtimer_cancel(&amp;apic-&gt;lapic_timer.timer);
 	apic_update_lvtt(apic);
<span class="p_add">+	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));</span>
 	update_divide_count(apic);
 	start_apic_timer(apic);
 	apic-&gt;irr_pending = true;
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index cfd1b13..a3e94b4 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -84,6 +84,17 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */</span>
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_use_crs,</span>
<span class="p_add">+		.ident = &quot;Foxconn K8M890-8237A&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Foxconn&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;K8M890-8237A&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* Now for the blacklist.. */
 
<span class="p_chunk">@@ -124,8 +135,10 @@</span> <span class="p_context"> void __init pci_acpi_crs_quirks(void)</span>
 {
 	int year;
 
<span class="p_del">-	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008)</span>
<span class="p_del">-		pci_use_crs = false;</span>
<span class="p_add">+	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008) {</span>
<span class="p_add">+		if (iomem_resource.end &lt;= 0xffffffff)</span>
<span class="p_add">+			pci_use_crs = false;</span>
<span class="p_add">+	}</span>
 
 	dmi_check_system(pci_crs_quirks);
 
<span class="p_header">diff --git a/crypto/asymmetric_keys/asymmetric_keys.h b/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_header">index f973308..3f5b537 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_chunk">@@ -11,6 +11,9 @@</span> <span class="p_context"></span>
 
 extern struct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id);
 
<span class="p_add">+extern int __asymmetric_key_hex_to_key_id(const char *id,</span>
<span class="p_add">+					  struct asymmetric_key_id *match_id,</span>
<span class="p_add">+					  size_t hexlen);</span>
 static inline
 const struct asymmetric_key_ids *asymmetric_key_ids(const struct key *key)
 {
<span class="p_header">diff --git a/crypto/asymmetric_keys/asymmetric_type.c b/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_header">index bcbbbd7..b0e4ed2 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_chunk">@@ -104,6 +104,15 @@</span> <span class="p_context"> static bool asymmetric_match_key_ids(</span>
 	return false;
 }
 
<span class="p_add">+/* helper function can be called directly with pre-allocated memory */</span>
<span class="p_add">+inline int __asymmetric_key_hex_to_key_id(const char *id,</span>
<span class="p_add">+				   struct asymmetric_key_id *match_id,</span>
<span class="p_add">+				   size_t hexlen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	match_id-&gt;len = hexlen;</span>
<span class="p_add">+	return hex2bin(match_id-&gt;data, id, hexlen);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * asymmetric_key_hex_to_key_id - Convert a hex string into a key ID.
  * @id: The ID as a hex string.
<span class="p_chunk">@@ -111,21 +120,20 @@</span> <span class="p_context"> static bool asymmetric_match_key_ids(</span>
 struct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id)
 {
 	struct asymmetric_key_id *match_id;
<span class="p_del">-	size_t hexlen;</span>
<span class="p_add">+	size_t asciihexlen;</span>
 	int ret;
 
 	if (!*id)
 		return ERR_PTR(-EINVAL);
<span class="p_del">-	hexlen = strlen(id);</span>
<span class="p_del">-	if (hexlen &amp; 1)</span>
<span class="p_add">+	asciihexlen = strlen(id);</span>
<span class="p_add">+	if (asciihexlen &amp; 1)</span>
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	match_id = kmalloc(sizeof(struct asymmetric_key_id) + hexlen / 2,</span>
<span class="p_add">+	match_id = kmalloc(sizeof(struct asymmetric_key_id) + asciihexlen / 2,</span>
 			   GFP_KERNEL);
 	if (!match_id)
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	match_id-&gt;len = hexlen / 2;</span>
<span class="p_del">-	ret = hex2bin(match_id-&gt;data, id, hexlen / 2);</span>
<span class="p_add">+	ret = __asymmetric_key_hex_to_key_id(id, match_id, asciihexlen / 2);</span>
 	if (ret &lt; 0) {
 		kfree(match_id);
 		return ERR_PTR(-EINVAL);
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_public_key.c b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">index a6c4203..24f17e6 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_chunk">@@ -28,17 +28,30 @@</span> <span class="p_context"> static bool use_builtin_keys;</span>
 static struct asymmetric_key_id *ca_keyid;
 
 #ifndef MODULE
<span class="p_add">+static struct {</span>
<span class="p_add">+	struct asymmetric_key_id id;</span>
<span class="p_add">+	unsigned char data[10];</span>
<span class="p_add">+} cakey;</span>
<span class="p_add">+</span>
 static int __init ca_keys_setup(char *str)
 {
 	if (!str)		/* default system keyring */
 		return 1;
 
 	if (strncmp(str, &quot;id:&quot;, 3) == 0) {
<span class="p_del">-		struct asymmetric_key_id *p;</span>
<span class="p_del">-		p = asymmetric_key_hex_to_key_id(str + 3);</span>
<span class="p_del">-		if (p == ERR_PTR(-EINVAL))</span>
<span class="p_del">-			pr_err(&quot;Unparsable hex string in ca_keys\n&quot;);</span>
<span class="p_del">-		else if (!IS_ERR(p))</span>
<span class="p_add">+		struct asymmetric_key_id *p = &amp;cakey.id;</span>
<span class="p_add">+		size_t hexlen = (strlen(str) - 3) / 2;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hexlen == 0 || hexlen &gt; sizeof(cakey.data)) {</span>
<span class="p_add">+			pr_err(&quot;Missing or invalid ca_keys id\n&quot;);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = __asymmetric_key_hex_to_key_id(str + 3, p, hexlen);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			pr_err(&quot;Unparsable ca_keys id hex string\n&quot;);</span>
<span class="p_add">+		else</span>
 			ca_keyid = p;	/* owner key &#39;id:xxxxxx&#39; */
 	} else if (strcmp(str, &quot;builtin&quot;) == 0) {
 		use_builtin_keys = true;
<span class="p_header">diff --git a/drivers/acpi/acpica/aclocal.h b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">index 680d23b..f982aa6 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> struct acpi_table_list {</span>
 
 #define ACPI_TABLE_INDEX_DSDT           (0)
 #define ACPI_TABLE_INDEX_FACS           (1)
<span class="p_add">+#define ACPI_TABLE_INDEX_X_FACS         (2)</span>
 
 struct acpi_find_context {
 	char *search_for;
<span class="p_header">diff --git a/drivers/acpi/acpica/tbfadt.c b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">index 41519a9..dfa3f36 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_chunk">@@ -350,9 +350,18 @@</span> <span class="p_context"> void acpi_tb_parse_fadt(u32 table_index)</span>
 	/* If Hardware Reduced flag is set, there is no FACS */
 
 	if (!acpi_gbl_reduced_hardware) {
<span class="p_del">-		acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_del">-					    acpi_gbl_FADT.Xfacs, ACPI_SIG_FACS,</span>
<span class="p_del">-					    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		if (acpi_gbl_FADT.facs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.facs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (acpi_gbl_FADT.Xfacs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.Xfacs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_X_FACS);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -491,13 +500,9 @@</span> <span class="p_context"> static void acpi_tb_convert_fadt(void)</span>
 	acpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);
 
 	/*
<span class="p_del">-	 * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.</span>
<span class="p_add">+	 * Expand the 32-bit DSDT addresses to 64-bit as necessary.</span>
 	 * Later ACPICA code will always use the X 64-bit field.
 	 */
<span class="p_del">-	acpi_gbl_FADT.Xfacs = acpi_tb_select_address(&quot;FACS&quot;,</span>
<span class="p_del">-						     acpi_gbl_FADT.facs,</span>
<span class="p_del">-						     acpi_gbl_FADT.Xfacs);</span>
<span class="p_del">-</span>
 	acpi_gbl_FADT.Xdsdt = acpi_tb_select_address(&quot;DSDT&quot;,
 						     acpi_gbl_FADT.dsdt,
 						     acpi_gbl_FADT.Xdsdt);
<span class="p_header">diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">index 6b1ca99..0912b16 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> acpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size);</span>
 
 acpi_status acpi_tb_initialize_facs(void)
 {
<span class="p_del">-	acpi_status status;</span>
<span class="p_add">+	struct acpi_table_facs *facs32;</span>
<span class="p_add">+	struct acpi_table_facs *facs64;</span>
 
 	/* If Hardware Reduced flag is set, there is no FACS */
 
<span class="p_chunk">@@ -77,11 +78,22 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 		return (AE_OK);
 	}
 
<span class="p_del">-	status = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_del">-					 ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_del">-								acpi_table_header,</span>
<span class="p_del">-								&amp;acpi_gbl_FACS));</span>
<span class="p_del">-	return (status);</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs32));</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_X_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs64));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_gbl_use32_bit_facs_addresses) {</span>
<span class="p_add">+		acpi_gbl_FACS = facs32 ? facs32 : facs64;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		acpi_gbl_FACS = facs64 ? facs64 : facs32;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return (AE_OK);</span>
 }
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_chunk">@@ -101,7 +113,7 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 u8 acpi_tb_tables_loaded(void)
 {
 
<span class="p_del">-	if (acpi_gbl_root_table_list.current_table_count &gt;= 3) {</span>
<span class="p_add">+	if (acpi_gbl_root_table_list.current_table_count &gt;= 4) {</span>
 		return (TRUE);
 	}
 
<span class="p_chunk">@@ -357,11 +369,11 @@</span> <span class="p_context"> acpi_status __init acpi_tb_parse_root_table(acpi_physical_address rsdp_address)</span>
 	table_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));
 
 	/*
<span class="p_del">-	 * First two entries in the table array are reserved for the DSDT</span>
<span class="p_del">-	 * and FACS, which are not actually present in the RSDT/XSDT - they</span>
<span class="p_del">-	 * come from the FADT</span>
<span class="p_add">+	 * First three entries in the table array are reserved for the DSDT</span>
<span class="p_add">+	 * and 32bit/64bit FACS, which are not actually present in the</span>
<span class="p_add">+	 * RSDT/XSDT - they come from the FADT</span>
 	 */
<span class="p_del">-	acpi_gbl_root_table_list.current_table_count = 2;</span>
<span class="p_add">+	acpi_gbl_root_table_list.current_table_count = 3;</span>
 
 	/* Initialize the root table array from the RSDT/XSDT */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">index ab5308b..435f716 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_chunk">@@ -166,7 +166,8 @@</span> <span class="p_context"> static acpi_status acpi_tb_load_namespace(void)</span>
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 	for (i = 0; i &lt; acpi_gbl_root_table_list.current_table_count; ++i) {
<span class="p_del">-		if ((!ACPI_COMPARE_NAME</span>
<span class="p_add">+		if (!acpi_gbl_root_table_list.tables[i].address ||</span>
<span class="p_add">+		    (!ACPI_COMPARE_NAME</span>
 		     (&amp;(acpi_gbl_root_table_list.tables[i].signature),
 		      ACPI_SIG_SSDT)
 		     &amp;&amp;
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index b1fd688..eec9fc3 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -179,10 +179,12 @@</span> <span class="p_context"> acpi_status __init acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c</span>
<span class="p_header">index 8b67bd0..cd4598b 100644</span>
<span class="p_header">--- a/drivers/acpi/bus.c</span>
<span class="p_header">+++ b/drivers/acpi/bus.c</span>
<span class="p_chunk">@@ -467,6 +467,16 @@</span> <span class="p_context"> static int __init acpi_bus_init_irq(void)</span>
 	return 0;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_early_init - Initialize ACPICA and populate the ACPI namespace.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The ACPI tables are accessible after this, but the handling of events has not</span>
<span class="p_add">+ * been initialized and the global lock is not available yet, so AML should not</span>
<span class="p_add">+ * be executed at this point.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this before switching the EFI runtime services to virtual mode allows</span>
<span class="p_add">+ * the EfiBootServices memory to be freed slightly earlier on boot.</span>
<span class="p_add">+ */</span>
 void __init acpi_early_init(void)
 {
 	acpi_status status;
<span class="p_chunk">@@ -530,26 +540,42 @@</span> <span class="p_context"> void __init acpi_early_init(void)</span>
 		acpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;
 	}
 #endif
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+ error0:</span>
<span class="p_add">+	disable_acpi();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_subsystem_init - Finalize the early initialization of ACPI.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Switch over the platform to the ACPI mode (if possible), initialize the</span>
<span class="p_add">+ * handling of ACPI events, install the interrupt and global lock handlers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this too early is generally unsafe, but at the same time it needs to be</span>
<span class="p_add">+ * done before all things that really depend on ACPI.  The right spot appears to</span>
<span class="p_add">+ * be before finalizing the EFI initialization.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init acpi_subsystem_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_disabled)</span>
<span class="p_add">+		return;</span>
 
 	status = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX &quot;Unable to enable ACPI\n&quot;);
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		disable_acpi();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the system is using ACPI then we can be reasonably</span>
<span class="p_add">+		 * confident that any regulators are managed by the firmware</span>
<span class="p_add">+		 * so tell the regulator core it has everything it needs to</span>
<span class="p_add">+		 * know.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regulator_has_full_constraints();</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the system is using ACPI then we can be reasonably</span>
<span class="p_del">-	 * confident that any regulators are managed by the firmware</span>
<span class="p_del">-	 * so tell the regulator core it has everything it needs to</span>
<span class="p_del">-	 * know.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regulator_has_full_constraints();</span>
<span class="p_del">-</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-      error0:</span>
<span class="p_del">-	disable_acpi();</span>
<span class="p_del">-	return;</span>
 }
 
 static int __init acpi_bus_init(void)
<span class="p_header">diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c</span>
<span class="p_header">index c0d44d3..f340b3f9 100644</span>
<span class="p_header">--- a/drivers/acpi/device_pm.c</span>
<span class="p_header">+++ b/drivers/acpi/device_pm.c</span>
<span class="p_chunk">@@ -953,6 +953,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(acpi_subsys_prepare);</span>
  */
 void acpi_subsys_complete(struct device *dev)
 {
<span class="p_add">+	pm_generic_complete(dev);</span>
 	/*
 	 * If the device had been runtime-suspended before the system went into
 	 * the sleep state it is going out of and it has never been resumed till
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 5aa1f6e..330bccb 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -175,11 +175,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 	if (!addr || !length)
 		return;
 
<span class="p_del">-	/* Resources are never freed */</span>
<span class="p_del">-	if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_del">-		request_region(addr, length, desc);</span>
<span class="p_del">-	else if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_del">-		request_mem_region(addr, length, desc);</span>
<span class="p_add">+	acpi_reserve_region(addr, length, gas-&gt;space_id, 0, desc);</span>
 }
 
 static void __init acpi_reserve_resources(void)
<span class="p_header">diff --git a/drivers/acpi/resource.c b/drivers/acpi/resource.c</span>
<span class="p_header">index 782a0d1..b73e09d 100644</span>
<span class="p_header">--- a/drivers/acpi/resource.c</span>
<span class="p_header">+++ b/drivers/acpi/resource.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;linux/ioport.h&gt;
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 
 #ifdef CONFIG_X86
<span class="p_chunk">@@ -538,3 +539,164 @@</span> <span class="p_context"> int acpi_dev_get_resources(struct acpi_device *adev, struct list_head *list,</span>
 	return c.count;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_get_resources);
<span class="p_add">+</span>
<span class="p_add">+struct reserved_region {</span>
<span class="p_add">+	struct list_head node;</span>
<span class="p_add">+	u64 start;</span>
<span class="p_add">+	u64 end;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static LIST_HEAD(reserved_io_regions);</span>
<span class="p_add">+static LIST_HEAD(reserved_mem_regions);</span>
<span class="p_add">+</span>
<span class="p_add">+static int request_range(u64 start, u64 end, u8 space_id, unsigned long flags,</span>
<span class="p_add">+			 char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int length = end - start + 1;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = space_id == ACPI_ADR_SPACE_SYSTEM_IO ?</span>
<span class="p_add">+		request_region(start, length, desc) :</span>
<span class="p_add">+		request_mem_region(start, length, desc);</span>
<span class="p_add">+	if (!res)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	res-&gt;flags &amp;= ~flags;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int add_region_before(u64 start, u64 end, u8 space_id,</span>
<span class="p_add">+			     unsigned long flags, char *desc,</span>
<span class="p_add">+			     struct list_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct reserved_region *reg;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = kmalloc(sizeof(*reg), GFP_KERNEL);</span>
<span class="p_add">+	if (!reg)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = request_range(start, end, space_id, flags, desc);</span>
<span class="p_add">+	if (error) {</span>
<span class="p_add">+		kfree(reg);</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;start = start;</span>
<span class="p_add">+	reg-&gt;end = end;</span>
<span class="p_add">+	list_add_tail(&amp;reg-&gt;node, head);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_reserve_region - Reserve an I/O or memory region as a system resource.</span>
<span class="p_add">+ * @start: Starting address of the region.</span>
<span class="p_add">+ * @length: Length of the region.</span>
<span class="p_add">+ * @space_id: Identifier of address space to reserve the region from.</span>
<span class="p_add">+ * @flags: Resource flags to clear for the region after requesting it.</span>
<span class="p_add">+ * @desc: Region description (for messages).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Reserve an I/O or memory region as a system resource to prevent others from</span>
<span class="p_add">+ * using it.  If the new region overlaps with one of the regions (in the given</span>
<span class="p_add">+ * address space) already reserved by this routine, only the non-overlapping</span>
<span class="p_add">+ * parts of it will be reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returned is either 0 (success) or a negative error code indicating a resource</span>
<span class="p_add">+ * reservation problem.  It is the code of the first encountered error, but the</span>
<span class="p_add">+ * routine doesn&#39;t abort until it has attempted to request all of the parts of</span>
<span class="p_add">+ * the new region that don&#39;t overlap with other regions reserved previously.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The resources requested by this routine are never released.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_add">+			unsigned long flags, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct list_head *regions;</span>
<span class="p_add">+	struct reserved_region *reg;</span>
<span class="p_add">+	u64 end = start + length - 1;</span>
<span class="p_add">+	int ret = 0, error = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_add">+		regions = &amp;reserved_io_regions;</span>
<span class="p_add">+	else if (space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_add">+		regions = &amp;reserved_mem_regions;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (list_empty(regions))</span>
<span class="p_add">+		return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(reg, regions, node)</span>
<span class="p_add">+		if (reg-&gt;start == end + 1) {</span>
<span class="p_add">+			/* The new region can be prepended to this one. */</span>
<span class="p_add">+			ret = request_range(start, end, space_id, flags, desc);</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				reg-&gt;start = start;</span>
<span class="p_add">+</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		} else if (reg-&gt;start &gt; end) {</span>
<span class="p_add">+			/* No overlap.  Add the new region here and get out. */</span>
<span class="p_add">+			return add_region_before(start, end, space_id, flags,</span>
<span class="p_add">+						 desc, &amp;reg-&gt;node);</span>
<span class="p_add">+		} else if (reg-&gt;end == start - 1) {</span>
<span class="p_add">+			goto combine;</span>
<span class="p_add">+		} else if (reg-&gt;end &gt;= start) {</span>
<span class="p_add">+			goto overlap;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The new region goes after the last existing one. */</span>
<span class="p_add">+	return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_add">+</span>
<span class="p_add">+ overlap:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new region overlaps an existing one.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The head part of the new region immediately preceding the existing</span>
<span class="p_add">+	 * overlapping one can be combined with it right away.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (reg-&gt;start &gt; start) {</span>
<span class="p_add">+		error = request_range(start, reg-&gt;start - 1, space_id, flags, desc);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			ret = error;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			reg-&gt;start = start;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+ combine:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new region is adjacent to an existing one.  If it extends beyond</span>
<span class="p_add">+	 * that region all the way to the next one, it is possible to combine</span>
<span class="p_add">+	 * all three of them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (reg-&gt;end &lt; end) {</span>
<span class="p_add">+		struct reserved_region *next = NULL;</span>
<span class="p_add">+		u64 a = reg-&gt;end + 1, b = end;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!list_is_last(&amp;reg-&gt;node, regions)) {</span>
<span class="p_add">+			next = list_next_entry(reg, node);</span>
<span class="p_add">+			if (next-&gt;start &lt;= end)</span>
<span class="p_add">+				b = next-&gt;start - 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		error = request_range(a, b, space_id, flags, desc);</span>
<span class="p_add">+		if (!error) {</span>
<span class="p_add">+			if (next &amp;&amp; next-&gt;start == b + 1) {</span>
<span class="p_add">+				reg-&gt;end = next-&gt;end;</span>
<span class="p_add">+				list_del(&amp;next-&gt;node);</span>
<span class="p_add">+				kfree(next);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				reg-&gt;end = end;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else if (next) {</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				ret = error;</span>
<span class="p_add">+</span>
<span class="p_add">+			reg = next;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret ? ret : error;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(acpi_reserve_region);</span>
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 0b8d57c..0f762ab 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4233,7 +4233,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
 	/* devices that don&#39;t properly handle queued TRIM commands */
<span class="p_del">-	{ &quot;Micron_M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Micron_M500_*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_header">diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c</span>
<span class="p_header">index ee731bb..b389c1d 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap.c</span>
<span class="p_chunk">@@ -944,11 +944,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devm_regmap_init);</span>
 static void regmap_field_init(struct regmap_field *rm_field,
 	struct regmap *regmap, struct reg_field reg_field)
 {
<span class="p_del">-	int field_bits = reg_field.msb - reg_field.lsb + 1;</span>
 	rm_field-&gt;regmap = regmap;
 	rm_field-&gt;reg = reg_field.reg;
 	rm_field-&gt;shift = reg_field.lsb;
<span class="p_del">-	rm_field-&gt;mask = ((BIT(field_bits) - 1) &lt;&lt; reg_field.lsb);</span>
<span class="p_add">+	rm_field-&gt;mask = GENMASK(reg_field.msb, reg_field.lsb);</span>
 	rm_field-&gt;id_size = reg_field.id_size;
 	rm_field-&gt;id_offset = reg_field.id_offset;
 }
<span class="p_chunk">@@ -2317,7 +2316,7 @@</span> <span class="p_context"> int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,</span>
 					  &amp;ival);
 			if (ret != 0)
 				return ret;
<span class="p_del">-			memcpy(val + (i * val_bytes), &amp;ival, val_bytes);</span>
<span class="p_add">+			map-&gt;format.format_val(val + (i * val_bytes), ival, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 733e621..0c4ede9 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -1998,11 +1998,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 288547a..8dc319d 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe057) },
 	{ USB_DEVICE(0x0489, 0xe056) },
 	{ USB_DEVICE(0x0489, 0xe05f) },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076) },</span>
 	{ USB_DEVICE(0x0489, 0xe078) },
 	{ USB_DEVICE(0x04c5, 0x1330) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
<span class="p_chunk">@@ -88,6 +89,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x04CA, 0x3007) },
 	{ USB_DEVICE(0x04CA, 0x3008) },
 	{ USB_DEVICE(0x04CA, 0x300b) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300d) },</span>
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300f) },</span>
 	{ USB_DEVICE(0x04CA, 0x3010) },
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -111,6 +114,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408) },
 	{ USB_DEVICE(0x13d3, 0x3423) },
 	{ USB_DEVICE(0x13d3, 0x3432) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -135,6 +139,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -143,6 +148,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -166,6 +173,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index b0449bb..ec5c3ae 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -168,6 +168,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -176,6 +177,8 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -199,6 +202,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_chunk">@@ -1591,6 +1595,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_header">diff --git a/drivers/bus/arm-ccn.c b/drivers/bus/arm-ccn.c</span>
<span class="p_header">index aaa0f2a..60397ec 100644</span>
<span class="p_header">--- a/drivers/bus/arm-ccn.c</span>
<span class="p_header">+++ b/drivers/bus/arm-ccn.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static int arm_ccn_node_to_xp_port(int node)</span>
 
 static void arm_ccn_pmu_config_set(u64 *config, u32 node_xp, u32 type, u32 port)
 {
<span class="p_del">-	*config &amp;= ~((0xff &lt;&lt; 0) | (0xff &lt;&lt; 8) | (0xff &lt;&lt; 24));</span>
<span class="p_add">+	*config &amp;= ~((0xff &lt;&lt; 0) | (0xff &lt;&lt; 8) | (0x3 &lt;&lt; 24));</span>
 	*config |= (node_xp &lt;&lt; 0) | (type &lt;&lt; 8) | (port &lt;&lt; 24);
 }
 
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index 92aa43f..ab379f3 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 102463ba..643bba7 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -579,6 +579,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -623,8 +626,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c</span>
<span class="p_header">index 2f14f57..9a50629 100644</span>
<span class="p_header">--- a/drivers/clk/clk.c</span>
<span class="p_header">+++ b/drivers/clk/clk.c</span>
<span class="p_chunk">@@ -177,11 +177,12 @@</span> <span class="p_context"> static void clk_dump_one(struct seq_file *s, struct clk *c, int level)</span>
 	if (!c)
 		return;
 
<span class="p_add">+	/* This should be JSON format, i.e. elements separated with a comma */</span>
 	seq_printf(s, &quot;\&quot;%s\&quot;: { &quot;, c-&gt;name);
 	seq_printf(s, &quot;\&quot;enable_count\&quot;: %d,&quot;, c-&gt;enable_count);
 	seq_printf(s, &quot;\&quot;prepare_count\&quot;: %d,&quot;, c-&gt;prepare_count);
<span class="p_del">-	seq_printf(s, &quot;\&quot;rate\&quot;: %lu&quot;, clk_get_rate(c));</span>
<span class="p_del">-	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu&quot;, clk_get_accuracy(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;rate\&quot;: %lu,&quot;, clk_get_rate(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu,&quot;, clk_get_accuracy(c));</span>
 	seq_printf(s, &quot;\&quot;phase\&quot;: %d&quot;, clk_get_phase(c));
 }
 
<span class="p_header">diff --git a/drivers/clk/ti/clk-dra7-atl.c b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">index 59bb4b3..e14b847 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_chunk">@@ -252,6 +252,11 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 		}
 
 		clk = of_clk_get_from_provider(&amp;clkspec);
<span class="p_add">+		if (IS_ERR(clk)) {</span>
<span class="p_add">+			pr_err(&quot;%s: failed to get atl clock %d from provider\n&quot;,</span>
<span class="p_add">+			       __func__, i);</span>
<span class="p_add">+			return PTR_ERR(clk);</span>
<span class="p_add">+		}</span>
 
 		cdesc = to_atl_desc(__clk_get_hw(clk));
 		cdesc-&gt;cinfo = cinfo;
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 83564c9..c844616 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -466,15 +466,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
<span class="p_del">-		evt-&gt;irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_del">-		if (request_irq(evt-&gt;irq, exynos4_mct_tick_isr,</span>
<span class="p_del">-				IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_del">-				evt-&gt;name, mevt)) {</span>
<span class="p_del">-			pr_err(&quot;exynos-mct: cannot register IRQ %d\n&quot;,</span>
<span class="p_del">-				evt-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (evt-&gt;irq == -1)</span>
 			return -EIO;
<span class="p_del">-		}</span>
<span class="p_del">-		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span>
<span class="p_add">+		enable_irq(evt-&gt;irq);</span>
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
<span class="p_chunk">@@ -487,10 +484,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
<span class="p_del">-	if (mct_int_type == MCT_INT_SPI)</span>
<span class="p_del">-		free_irq(evt-&gt;irq, this_cpu_ptr(&amp;percpu_mct_tick));</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (mct_int_type == MCT_INT_SPI) {</span>
<span class="p_add">+		if (evt-&gt;irq != -1)</span>
<span class="p_add">+			disable_irq_nosync(evt-&gt;irq);</span>
<span class="p_add">+	} else {</span>
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
<span class="p_add">+	}</span>
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
<span class="p_chunk">@@ -522,7 +521,7 @@</span> <span class="p_context"> static struct notifier_block exynos4_mct_cpu_nb = {</span>
 
 static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, cpu;</span>
 	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);
 	struct clk *mct_clk, *tick_clk;
 
<span class="p_chunk">@@ -549,7 +548,25 @@</span> <span class="p_context"> static void __init exynos4_timer_resources(struct device_node *np, void __iomem</span>
 		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,
 		     mct_irqs[MCT_L0_IRQ], err);
 	} else {
<span class="p_del">-		irq_set_affinity(mct_irqs[MCT_L0_IRQ], cpumask_of(0));</span>
<span class="p_add">+		for_each_possible_cpu(cpu) {</span>
<span class="p_add">+			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_add">+			struct mct_clock_event_device *pcpu_mevt =</span>
<span class="p_add">+				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span>
<span class="p_add">+			if (request_irq(mct_irq,</span>
<span class="p_add">+					exynos4_mct_tick_isr,</span>
<span class="p_add">+					IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_add">+					pcpu_mevt-&gt;name, pcpu_mevt)) {</span>
<span class="p_add">+				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span>
<span class="p_add">+									cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = mct_irq;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 742eefb..c37c895 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -497,7 +497,7 @@</span> <span class="p_context"> static void byt_set_pstate(struct cpudata *cpudata, int pstate)</span>
 
 	val |= vid;
 
<span class="p_del">-	wrmsrl(MSR_IA32_PERF_CTL, val);</span>
<span class="p_add">+	wrmsrl_on_cpu(cpudata-&gt;cpu, MSR_IA32_PERF_CTL, val);</span>
 }
 
 #define BYT_BCLK_FREQS 5
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 067ec21..0584c4e 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -927,7 +927,8 @@</span> <span class="p_context"> static int sg_to_link_tbl(struct scatterlist *sg, int sg_count,</span>
 		sg_count--;
 		link_tbl_ptr--;
 	}
<span class="p_del">-	be16_add_cpu(&amp;link_tbl_ptr-&gt;len, cryptlen);</span>
<span class="p_add">+	link_tbl_ptr-&gt;len = cpu_to_be16(be16_to_cpu(link_tbl_ptr-&gt;len)</span>
<span class="p_add">+					+ cryptlen);</span>
 
 	/* tag end of link table */
 	link_tbl_ptr-&gt;j_extent = DESC_PTR_LNKTBL_RETURN;
<span class="p_chunk">@@ -2563,6 +2564,7 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		break;
 	default:
 		dev_err(dev, &quot;unknown algorithm type %d\n&quot;, t_alg-&gt;algt.type);
<span class="p_add">+		kfree(t_alg);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index d7ac558..794cfcb 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -277,7 +277,8 @@</span> <span class="p_context"> static void mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -289,38 +290,57 @@</span> <span class="p_context"> static void mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index 78edc7e..4fa0fe2 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_DESCRIPTOR_SWAP		BIT(14)
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_DESC_DMA_OWNED		BIT(31)
 #define XOR_DESC_EOD_INT_EN		BIT(31)
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 9035c1b..b1d7051 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -65,7 +65,6 @@</span> <span class="p_context"> static int __init parse_efi_cmdline(char *str)</span>
 early_param(&quot;efi&quot;, parse_efi_cmdline);
 
 static struct kobject *efi_kobj;
<span class="p_del">-static struct kobject *efivars_kobj;</span>
 
 /*
  * Let&#39;s not leave out systab information that snuck into
<span class="p_chunk">@@ -203,10 +202,9 @@</span> <span class="p_context"> static int __init efisubsys_init(void)</span>
 		goto err_remove_group;
 
 	/* and the standard mountpoint for efivarfs */
<span class="p_del">-	efivars_kobj = kobject_create_and_add(&quot;efivars&quot;, efi_kobj);</span>
<span class="p_del">-	if (!efivars_kobj) {</span>
<span class="p_add">+	error = sysfs_create_mount_point(efi_kobj, &quot;efivars&quot;);</span>
<span class="p_add">+	if (error) {</span>
 		pr_err(&quot;efivars: Subsystem registration failed.\n&quot;);
<span class="p_del">-		error = -ENOMEM;</span>
 		goto err_remove_group;
 	}
 
<span class="p_header">diff --git a/drivers/gpio/gpio-crystalcove.c b/drivers/gpio/gpio-crystalcove.c</span>
<span class="p_header">index 3d9e08f..57cd089 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-crystalcove.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-crystalcove.c</span>
<span class="p_chunk">@@ -250,6 +250,7 @@</span> <span class="p_context"> static struct irq_chip crystalcove_irqchip = {</span>
 	.irq_set_type		= crystalcove_irq_type,
 	.irq_bus_lock		= crystalcove_bus_lock,
 	.irq_bus_sync_unlock	= crystalcove_bus_sync_unlock,
<span class="p_add">+	.flags			= IRQCHIP_SKIP_SET_WAKE,</span>
 };
 
 static irqreturn_t crystalcove_gpio_irq_handler(int irq, void *data)
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 9a5b687..30308ab 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -863,8 +863,16 @@</span> <span class="p_context"> static void drm_dp_destroy_port(struct kref *kref)</span>
 		port-&gt;vcpi.num_slots = 0;
 
 		kfree(port-&gt;cached_edid);
<span class="p_del">-		if (port-&gt;connector)</span>
<span class="p_del">-			(*port-&gt;mgr-&gt;cbs-&gt;destroy_connector)(mgr, port-&gt;connector);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* we can&#39;t destroy the connector here, as</span>
<span class="p_add">+		   we might be holding the mode_config.mutex</span>
<span class="p_add">+		   from an EDID retrieval */</span>
<span class="p_add">+		if (port-&gt;connector) {</span>
<span class="p_add">+			mutex_lock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			list_add(&amp;port-&gt;connector-&gt;destroy_list, &amp;mgr-&gt;destroy_connector_list);</span>
<span class="p_add">+			mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			schedule_work(&amp;mgr-&gt;destroy_connector_work);</span>
<span class="p_add">+		}</span>
 		drm_dp_port_teardown_pdt(port, port-&gt;pdt);
 
 		if (!port-&gt;input &amp;&amp; port-&gt;vcpi.vcpi &gt; 0)
<span class="p_chunk">@@ -1159,6 +1167,8 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 	struct drm_dp_mst_port *port;
 	int i;
 	/* find the port by iterating down */
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;mgr-&gt;lock);</span>
 	mstb = mgr-&gt;mst_primary;
 
 	for (i = 0; i &lt; lct - 1; i++) {
<span class="p_chunk">@@ -1178,6 +1188,7 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 		}
 	}
 	kref_get(&amp;mstb-&gt;kref);
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
 	return mstb;
 }
 
<span class="p_chunk">@@ -1185,7 +1196,7 @@</span> <span class="p_context"> static void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *m</span>
 					       struct drm_dp_mst_branch *mstb)
 {
 	struct drm_dp_mst_port *port;
<span class="p_del">-</span>
<span class="p_add">+	struct drm_dp_mst_branch *mstb_child;</span>
 	if (!mstb-&gt;link_address_sent) {
 		drm_dp_send_link_address(mgr, mstb);
 		mstb-&gt;link_address_sent = true;
<span class="p_chunk">@@ -1200,17 +1211,31 @@</span> <span class="p_context"> static void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *m</span>
 		if (!port-&gt;available_pbn)
 			drm_dp_send_enum_path_resources(mgr, mstb, port);
 
<span class="p_del">-		if (port-&gt;mstb)</span>
<span class="p_del">-			drm_dp_check_and_send_link_address(mgr, port-&gt;mstb);</span>
<span class="p_add">+		if (port-&gt;mstb) {</span>
<span class="p_add">+			mstb_child = drm_dp_get_validated_mstb_ref(mgr, port-&gt;mstb);</span>
<span class="p_add">+			if (mstb_child) {</span>
<span class="p_add">+				drm_dp_check_and_send_link_address(mgr, mstb_child);</span>
<span class="p_add">+				drm_dp_put_mst_branch_device(mstb_child);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 }
 
 static void drm_dp_mst_link_probe_work(struct work_struct *work)
 {
 	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, work);
<span class="p_add">+	struct drm_dp_mst_branch *mstb;</span>
 
<span class="p_del">-	drm_dp_check_and_send_link_address(mgr, mgr-&gt;mst_primary);</span>
<span class="p_del">-</span>
<span class="p_add">+	mutex_lock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+	mstb = mgr-&gt;mst_primary;</span>
<span class="p_add">+	if (mstb) {</span>
<span class="p_add">+		kref_get(&amp;mstb-&gt;kref);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+	if (mstb) {</span>
<span class="p_add">+		drm_dp_check_and_send_link_address(mgr, mstb);</span>
<span class="p_add">+		drm_dp_put_mst_branch_device(mstb);</span>
<span class="p_add">+	}</span>
 }
 
 static bool drm_dp_validate_guid(struct drm_dp_mst_topology_mgr *mgr,
<span class="p_chunk">@@ -2614,6 +2639,30 @@</span> <span class="p_context"> static void drm_dp_tx_work(struct work_struct *work)</span>
 	mutex_unlock(&amp;mgr-&gt;qlock);
 }
 
<span class="p_add">+static void drm_dp_destroy_connector_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, destroy_connector_work);</span>
<span class="p_add">+	struct drm_connector *connector;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Not a regular list traverse as we have to drop the destroy</span>
<span class="p_add">+	 * connector lock before destroying the connector, to avoid AB-&gt;BA</span>
<span class="p_add">+	 * ordering between this lock and the config mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		mutex_lock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+		connector = list_first_entry_or_null(&amp;mgr-&gt;destroy_connector_list, struct drm_connector, destroy_list);</span>
<span class="p_add">+		if (!connector) {</span>
<span class="p_add">+			mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		list_del(&amp;connector-&gt;destroy_list);</span>
<span class="p_add">+		mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		mgr-&gt;cbs-&gt;destroy_connector(mgr, connector);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * drm_dp_mst_topology_mgr_init - initialise a topology manager
  * @mgr: manager struct to initialise
<span class="p_chunk">@@ -2633,10 +2682,13 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr,</span>
 	mutex_init(&amp;mgr-&gt;lock);
 	mutex_init(&amp;mgr-&gt;qlock);
 	mutex_init(&amp;mgr-&gt;payload_lock);
<span class="p_add">+	mutex_init(&amp;mgr-&gt;destroy_connector_lock);</span>
 	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_upq);
 	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_downq);
<span class="p_add">+	INIT_LIST_HEAD(&amp;mgr-&gt;destroy_connector_list);</span>
 	INIT_WORK(&amp;mgr-&gt;work, drm_dp_mst_link_probe_work);
 	INIT_WORK(&amp;mgr-&gt;tx_work, drm_dp_tx_work);
<span class="p_add">+	INIT_WORK(&amp;mgr-&gt;destroy_connector_work, drm_dp_destroy_connector_work);</span>
 	init_waitqueue_head(&amp;mgr-&gt;tx_waitq);
 	mgr-&gt;dev = dev;
 	mgr-&gt;aux = aux;
<span class="p_chunk">@@ -2661,6 +2713,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_dp_mst_topology_mgr_init);</span>
  */
 void drm_dp_mst_topology_mgr_destroy(struct drm_dp_mst_topology_mgr *mgr)
 {
<span class="p_add">+	flush_work(&amp;mgr-&gt;destroy_connector_work);</span>
 	mutex_lock(&amp;mgr-&gt;payload_lock);
 	kfree(mgr-&gt;payloads);
 	mgr-&gt;payloads = NULL;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 6e7a6f0..4487368 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -3064,6 +3064,7 @@</span> <span class="p_context"> enum punit_power_well {</span>
 #define   BLM_POLARITY_PNV			(1 &lt;&lt; 0) /* pnv only */
 
 #define BLC_HIST_CTL	(dev_priv-&gt;info.display_mmio_offset + 0x61260)
<span class="p_add">+#define  BLM_HISTOGRAM_ENABLE			(1 &lt;&lt; 31)</span>
 
 /* New registers for PCH-split platforms. Safe where new bits show up, the
  * register layout machtes with gen4 BLC_PWM_CTL[12]. */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_panel.c b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">index dfb783a..e6d0f82 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_chunk">@@ -878,6 +878,14 @@</span> <span class="p_context"> static void i9xx_enable_backlight(struct intel_connector *connector)</span>
 
 	/* XXX: combine this into above write? */
 	intel_panel_actually_set_backlight(connector, panel-&gt;backlight.level);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Needed to enable backlight on some 855gm models. BLC_HIST_CTL is</span>
<span class="p_add">+	 * 855gm only, but checking for gen2 is safe, as 855gm is the only gen2</span>
<span class="p_add">+	 * that has backlight.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_GEN2(dev))</span>
<span class="p_add">+		I915_WRITE(BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);</span>
 }
 
 static void i965_enable_backlight(struct intel_connector *connector)
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index 9782364..f33251d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index b110883..7354a4c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -122,8 +122,10 @@</span> <span class="p_context"> static struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,</span>
 	qobj = gem_to_qxl_bo(gobj);
 
 	ret = qxl_release_list_add(release, qobj);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(gobj);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	return qobj;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index c94e68d..3011c7a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4543,6 +4543,31 @@</span> <span class="p_context"> void cik_compute_set_wptr(struct radeon_device *rdev,</span>
 	WDOORBELL32(ring-&gt;doorbell_index, ring-&gt;wptr);
 }
 
<span class="p_add">+static void cik_compute_stop(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 j, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cik_srbm_select(rdev, ring-&gt;me, ring-&gt;pipe, ring-&gt;queue, 0);</span>
<span class="p_add">+	/* Disable wptr polling. */</span>
<span class="p_add">+	tmp = RREG32(CP_PQ_WPTR_POLL_CNTL);</span>
<span class="p_add">+	tmp &amp;= ~WPTR_POLL_EN;</span>
<span class="p_add">+	WREG32(CP_PQ_WPTR_POLL_CNTL, tmp);</span>
<span class="p_add">+	/* Disable HQD. */</span>
<span class="p_add">+	if (RREG32(CP_HQD_ACTIVE) &amp; 1) {</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 1);</span>
<span class="p_add">+		for (j = 0; j &lt; rdev-&gt;usec_timeout; j++) {</span>
<span class="p_add">+			if (!(RREG32(CP_HQD_ACTIVE) &amp; 1))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			udelay(1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_RPTR, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_WPTR, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cik_srbm_select(rdev, 0, 0, 0, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cik_cp_compute_enable - enable/disable the compute CP MEs
  *
<span class="p_chunk">@@ -4556,6 +4581,15 @@</span> <span class="p_context"> static void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)</span>
 	if (enable)
 		WREG32(CP_MEC_CNTL, 0);
 	else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * To make hibernation reliable we need to clear compute ring</span>
<span class="p_add">+		 * configuration before halting the compute ring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX]);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX]);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+</span>
 		WREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">index 42cd0cf..ddd39fe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_chunk">@@ -268,6 +268,17 @@</span> <span class="p_context"> static void cik_sdma_gfx_stop(struct radeon_device *rdev)</span>
 	}
 	rdev-&gt;ring[R600_RING_TYPE_DMA_INDEX].ready = false;
 	rdev-&gt;ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME use something else than big hammer but after few days can not</span>
<span class="p_add">+	 * seem to find good combination so reset SDMA blocks as it seems we</span>
<span class="p_add">+	 * do not shut them down properly. This fix hibernation and does not</span>
<span class="p_add">+	 * affect suspend to ram.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, SOFT_RESET_SDMA | SOFT_RESET_SDMA1);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, 0);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index 00fc597..bbcd754 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,10 +79,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/tegra/dpaux.c b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">index d6b55e3..a43a836 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_chunk">@@ -72,34 +72,32 @@</span> <span class="p_context"> static inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,</span>
 static void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,
 				   size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_WRITE(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value = 0;
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			value |= buffer[i + j] &lt;&lt; (j * 8);</span>
<span class="p_add">+			value |= buffer[i * 4 + j] &lt;&lt; (j * 8);</span>
 
<span class="p_del">-		tegra_dpaux_writel(dpaux, value, offset++);</span>
<span class="p_add">+		tegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXDATA_WRITE(i));</span>
 	}
 }
 
 static void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,
 				  size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_READ(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value;
 
<span class="p_del">-		value = tegra_dpaux_readl(dpaux, offset++);</span>
<span class="p_add">+		value = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXDATA_READ(i));</span>
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			buffer[i + j] = value &gt;&gt; (j * 8);</span>
<span class="p_add">+			buffer[i * 4 + j] = value &gt;&gt; (j * 8);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/hid/hid-rmi.c b/drivers/hid/hid-rmi.c</span>
<span class="p_header">index b51200f..e746fef 100644</span>
<span class="p_header">--- a/drivers/hid/hid-rmi.c</span>
<span class="p_header">+++ b/drivers/hid/hid-rmi.c</span>
<span class="p_chunk">@@ -29,9 +29,9 @@</span> <span class="p_context"></span>
 #define RMI_SET_RMI_MODE_REPORT_ID	0x0f /* Feature Report */
 
 /* flags */
<span class="p_del">-#define RMI_READ_REQUEST_PENDING	BIT(0)</span>
<span class="p_del">-#define RMI_READ_DATA_PENDING		BIT(1)</span>
<span class="p_del">-#define RMI_STARTED			BIT(2)</span>
<span class="p_add">+#define RMI_READ_REQUEST_PENDING	0</span>
<span class="p_add">+#define RMI_READ_DATA_PENDING		1</span>
<span class="p_add">+#define RMI_STARTED			2</span>
 
 enum rmi_mode_type {
 	RMI_MODE_OFF			= 0,
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 5e72fc2..829a62c 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -41,9 +41,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/i2c/i2c-hid.h&gt;
 
 /* flags */
<span class="p_del">-#define I2C_HID_STARTED		(1 &lt;&lt; 0)</span>
<span class="p_del">-#define I2C_HID_RESET_PENDING	(1 &lt;&lt; 1)</span>
<span class="p_del">-#define I2C_HID_READ_PENDING	(1 &lt;&lt; 2)</span>
<span class="p_add">+#define I2C_HID_STARTED		0</span>
<span class="p_add">+#define I2C_HID_RESET_PENDING	1</span>
<span class="p_add">+#define I2C_HID_READ_PENDING	2</span>
 
 #define I2C_HID_PWR_ON		0x00
 #define I2C_HID_PWR_SLEEP	0x01
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index d219c06..972444a 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/hwmon/nct7802.c b/drivers/hwmon/nct7802.c</span>
<span class="p_header">index ec56782..60cf5d1 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7802.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7802.c</span>
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static umode_t nct7802_temp_is_visible(struct kobject *kobj,</span>
 	if (index &gt;= 9 &amp;&amp; index &lt; 18 &amp;&amp;
 	    (reg &amp; 0x0c) != 0x04 &amp;&amp; (reg &amp; 0x0c) != 0x08)	/* RD2 */
 		return 0;
<span class="p_del">-	if (index &gt;= 18 &amp;&amp; index &lt; 27 &amp;&amp; (reg &amp; 0x30) != 0x10)	/* RD3 */</span>
<span class="p_add">+	if (index &gt;= 18 &amp;&amp; index &lt; 27 &amp;&amp; (reg &amp; 0x30) != 0x20)	/* RD3 */</span>
 		return 0;
 	if (index &gt;= 27 &amp;&amp; index &lt; 35)				/* local */
 		return attr-&gt;mode;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 636fd2e..2d7fe45 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -65,6 +65,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -119,13 +122,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -215,6 +217,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -309,7 +319,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -370,7 +380,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -383,6 +393,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	int ret;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -413,26 +451,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/i2c/i2c-mux.c b/drivers/i2c/i2c-mux.c</span>
<span class="p_header">index 06cc1ff..98dd5d4 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-mux.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-mux.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> static int i2c_mux_master_xfer(struct i2c_adapter *adap,</span>
 
 	ret = priv-&gt;select(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 	if (ret &gt;= 0)
<span class="p_del">-		ret = parent-&gt;algo-&gt;master_xfer(parent, msgs, num);</span>
<span class="p_add">+		ret = __i2c_transfer(parent, msgs, num);</span>
 	if (priv-&gt;deselect)
 		priv-&gt;deselect(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">index cb77277..0c8d4d2 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static int pca9541_reg_write(struct i2c_client *client, u8 command, u8 val)</span>
 		buf[0] = command;
 		buf[1] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int pca9541_reg_read(struct i2c_client *client, u8 command)</span>
 				.buf = &amp;val
 			}
 		};
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, msg, 2);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, msg, 2);</span>
 		if (ret == 2)
 			ret = val;
 		else if (ret &gt;= 0)
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index ec11b40..15db589 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> static int pca954x_reg_write(struct i2c_adapter *adap,</span>
 		msg.len = 1;
 		buf[0] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 		ret = adap-&gt;algo-&gt;smbus_xfer(adap, client-&gt;addr,
<span class="p_header">diff --git a/drivers/iio/accel/kxcjk-1013.c b/drivers/iio/accel/kxcjk-1013.c</span>
<span class="p_header">index da2fe93..ce536f6 100644</span>
<span class="p_header">--- a/drivers/iio/accel/kxcjk-1013.c</span>
<span class="p_header">+++ b/drivers/iio/accel/kxcjk-1013.c</span>
<span class="p_chunk">@@ -1398,6 +1398,7 @@</span> <span class="p_context"> static const struct dev_pm_ops kxcjk1013_pm_ops = {</span>
 static const struct acpi_device_id kx_acpi_match[] = {
 	{&quot;KXCJ1013&quot;, KXCJK1013},
 	{&quot;KXCJ1008&quot;, KXCJ91008},
<span class="p_add">+	{&quot;KXCJ9000&quot;, KXCJ91008},</span>
 	{&quot;KXTJ1009&quot;, KXTJ21009},
 	{ },
 };
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 729382c..b5d7b1a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -1365,14 +1365,17 @@</span> <span class="p_context"> static void mlx4_ib_multiplex_mad(struct mlx4_ib_demux_pv_ctx *ctx, struct ib_wc</span>
 	 * stadard address handle by decoding the tunnelled mlx4_ah fields */
 	memcpy(&amp;ah.av, &amp;tunnel-&gt;hdr.av, sizeof (struct mlx4_av));
 	ah.ibah.device = ctx-&gt;ib_dev;
<span class="p_add">+</span>
<span class="p_add">+	port = be32_to_cpu(ah.av.ib.port_pd) &gt;&gt; 24;</span>
<span class="p_add">+	port = mlx4_slave_convert_port(dev-&gt;dev, slave, port);</span>
<span class="p_add">+	if (port &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	ah.av.ib.port_pd = cpu_to_be32(port &lt;&lt; 24 | (be32_to_cpu(ah.av.ib.port_pd) &amp; 0xffffff));</span>
<span class="p_add">+</span>
 	mlx4_ib_query_ah(&amp;ah.ibah, &amp;ah_attr);
 	if (ah_attr.ah_flags &amp; IB_AH_GRH)
 		fill_in_real_sgid_index(dev, slave, ctx-&gt;port, &amp;ah_attr);
 
<span class="p_del">-	port = mlx4_slave_convert_port(dev-&gt;dev, slave, ah_attr.port_num);</span>
<span class="p_del">-	if (port &lt; 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	ah_attr.port_num = port;</span>
 	memcpy(ah_attr.dmac, tunnel-&gt;hdr.mac, 6);
 	ah_attr.vlan_id = be16_to_cpu(tunnel-&gt;hdr.vlan);
 	/* if slave have default vlan use it */
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 0747c05..313dfad 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -464,14 +464,13 @@</span> <span class="p_context"> static struct srp_fr_pool *srp_alloc_fr_pool(struct srp_target_port *target)</span>
  */
 static void srp_destroy_qp(struct srp_rdma_ch *ch)
 {
<span class="p_del">-	struct srp_target_port *target = ch-&gt;target;</span>
 	static struct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };
 	static struct ib_recv_wr wr = { .wr_id = SRP_LAST_WR_ID };
 	struct ib_recv_wr *bad_wr;
 	int ret;
 
 	/* Destroying a QP and reusing ch-&gt;done is only safe if not connected */
<span class="p_del">-	WARN_ON_ONCE(target-&gt;connected);</span>
<span class="p_add">+	WARN_ON_ONCE(ch-&gt;connected);</span>
 
 	ret = ib_modify_qp(ch-&gt;qp, &amp;attr, IB_QP_STATE);
 	WARN_ONCE(ret, &quot;ib_cm_init_qp_attr() returned %d\n&quot;, ret);
<span class="p_chunk">@@ -810,35 +809,19 @@</span> <span class="p_context"> static bool srp_queue_remove_work(struct srp_target_port *target)</span>
 	return changed;
 }
 
<span class="p_del">-static bool srp_change_conn_state(struct srp_target_port *target,</span>
<span class="p_del">-				  bool connected)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool changed = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irq(&amp;target-&gt;lock);</span>
<span class="p_del">-	if (target-&gt;connected != connected) {</span>
<span class="p_del">-		target-&gt;connected = connected;</span>
<span class="p_del">-		changed = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	spin_unlock_irq(&amp;target-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return changed;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void srp_disconnect_target(struct srp_target_port *target)
 {
 	struct srp_rdma_ch *ch;
 	int i;
 
<span class="p_del">-	if (srp_change_conn_state(target, false)) {</span>
<span class="p_del">-		/* XXX should send SRP_I_LOGOUT request */</span>
<span class="p_add">+	/* XXX should send SRP_I_LOGOUT request */</span>
 
<span class="p_del">-		for (i = 0; i &lt; target-&gt;ch_count; i++) {</span>
<span class="p_del">-			ch = &amp;target-&gt;ch[i];</span>
<span class="p_del">-			if (ch-&gt;cm_id &amp;&amp; ib_send_cm_dreq(ch-&gt;cm_id, NULL, 0)) {</span>
<span class="p_del">-				shost_printk(KERN_DEBUG, target-&gt;scsi_host,</span>
<span class="p_del">-					     PFX &quot;Sending CM DREQ failed\n&quot;);</span>
<span class="p_del">-			}</span>
<span class="p_add">+	for (i = 0; i &lt; target-&gt;ch_count; i++) {</span>
<span class="p_add">+		ch = &amp;target-&gt;ch[i];</span>
<span class="p_add">+		ch-&gt;connected = false;</span>
<span class="p_add">+		if (ch-&gt;cm_id &amp;&amp; ib_send_cm_dreq(ch-&gt;cm_id, NULL, 0)) {</span>
<span class="p_add">+			shost_printk(KERN_DEBUG, target-&gt;scsi_host,</span>
<span class="p_add">+				     PFX &quot;Sending CM DREQ failed\n&quot;);</span>
 		}
 	}
 }
<span class="p_chunk">@@ -985,14 +968,26 @@</span> <span class="p_context"> static void srp_rport_delete(struct srp_rport *rport)</span>
 	srp_queue_remove_work(target);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * srp_connected_ch() - number of connected channels</span>
<span class="p_add">+ * @target: SRP target port.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int srp_connected_ch(struct srp_target_port *target)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, c = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; target-&gt;ch_count; i++)</span>
<span class="p_add">+		c += target-&gt;ch[i].connected;</span>
<span class="p_add">+</span>
<span class="p_add">+	return c;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int srp_connect_ch(struct srp_rdma_ch *ch, bool multich)
 {
 	struct srp_target_port *target = ch-&gt;target;
 	int ret;
 
<span class="p_del">-	WARN_ON_ONCE(!multich &amp;&amp; target-&gt;connected);</span>
<span class="p_del">-</span>
<span class="p_del">-	target-&gt;qp_in_error = false;</span>
<span class="p_add">+	WARN_ON_ONCE(!multich &amp;&amp; srp_connected_ch(target) &gt; 0);</span>
 
 	ret = srp_lookup_path(ch);
 	if (ret)
<span class="p_chunk">@@ -1015,7 +1010,7 @@</span> <span class="p_context"> static int srp_connect_ch(struct srp_rdma_ch *ch, bool multich)</span>
 		 */
 		switch (ch-&gt;status) {
 		case 0:
<span class="p_del">-			srp_change_conn_state(target, true);</span>
<span class="p_add">+			ch-&gt;connected = true;</span>
 			return 0;
 
 		case SRP_PORT_REDIRECT:
<span class="p_chunk">@@ -1242,13 +1237,13 @@</span> <span class="p_context"> static int srp_rport_reconnect(struct srp_rport *rport)</span>
 		for (j = 0; j &lt; target-&gt;queue_size; ++j)
 			list_add(&amp;ch-&gt;tx_ring[j]-&gt;list, &amp;ch-&gt;free_tx);
 	}
<span class="p_add">+</span>
<span class="p_add">+	target-&gt;qp_in_error = false;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; target-&gt;ch_count; i++) {
 		ch = &amp;target-&gt;ch[i];
<span class="p_del">-		if (ret || !ch-&gt;target) {</span>
<span class="p_del">-			if (i &gt; 1)</span>
<span class="p_del">-				ret = 0;</span>
<span class="p_add">+		if (ret || !ch-&gt;target)</span>
 			break;
<span class="p_del">-		}</span>
 		ret = srp_connect_ch(ch, multich);
 		multich = true;
 	}
<span class="p_chunk">@@ -1928,7 +1923,7 @@</span> <span class="p_context"> static void srp_handle_qp_err(u64 wr_id, enum ib_wc_status wc_status,</span>
 		return;
 	}
 
<span class="p_del">-	if (target-&gt;connected &amp;&amp; !target-&gt;qp_in_error) {</span>
<span class="p_add">+	if (ch-&gt;connected &amp;&amp; !target-&gt;qp_in_error) {</span>
 		if (wr_id &amp; LOCAL_INV_WR_ID_MASK) {
 			shost_printk(KERN_ERR, target-&gt;scsi_host, PFX
 				     &quot;LOCAL_INV failed with status %d\n&quot;,
<span class="p_chunk">@@ -2366,7 +2361,7 @@</span> <span class="p_context"> static int srp_cm_handler(struct ib_cm_id *cm_id, struct ib_cm_event *event)</span>
 	case IB_CM_DREQ_RECEIVED:
 		shost_printk(KERN_WARNING, target-&gt;scsi_host,
 			     PFX &quot;DREQ received - connection closed\n&quot;);
<span class="p_del">-		srp_change_conn_state(target, false);</span>
<span class="p_add">+		ch-&gt;connected = false;</span>
 		if (ib_send_cm_drep(cm_id, NULL, 0))
 			shost_printk(KERN_ERR, target-&gt;scsi_host,
 				     PFX &quot;Sending CM DREP failed\n&quot;);
<span class="p_chunk">@@ -2422,7 +2417,7 @@</span> <span class="p_context"> static int srp_send_tsk_mgmt(struct srp_rdma_ch *ch, u64 req_tag,</span>
 	struct srp_iu *iu;
 	struct srp_tsk_mgmt *tsk_mgmt;
 
<span class="p_del">-	if (!target-&gt;connected || target-&gt;qp_in_error)</span>
<span class="p_add">+	if (!ch-&gt;connected || target-&gt;qp_in_error)</span>
 		return -1;
 
 	init_completion(&amp;ch-&gt;tsk_mgmt_done);
<span class="p_chunk">@@ -2796,7 +2791,8 @@</span> <span class="p_context"> static int srp_add_target(struct srp_host *host, struct srp_target_port *target)</span>
 	scsi_scan_target(&amp;target-&gt;scsi_host-&gt;shost_gendev,
 			 0, target-&gt;scsi_id, SCAN_WILD_CARD, 0);
 
<span class="p_del">-	if (!target-&gt;connected || target-&gt;qp_in_error) {</span>
<span class="p_add">+	if (srp_connected_ch(target) &lt; target-&gt;ch_count ||</span>
<span class="p_add">+	    target-&gt;qp_in_error) {</span>
 		shost_printk(KERN_INFO, target-&gt;scsi_host,
 			     PFX &quot;SCSI scan failed - removing SCSI host\n&quot;);
 		srp_queue_remove_work(target);
<span class="p_chunk">@@ -3171,11 +3167,11 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 
 	ret = srp_parse_options(buf, target);
 	if (ret)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto out;</span>
 
 	ret = scsi_init_shared_tag_map(target_host, target_host-&gt;can_queue);
 	if (ret)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto out;</span>
 
 	target-&gt;req_ring_size = target-&gt;queue_size - SRP_TSK_MGMT_SQ_SIZE;
 
<span class="p_chunk">@@ -3186,7 +3182,7 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 			     be64_to_cpu(target-&gt;ioc_guid),
 			     be64_to_cpu(target-&gt;initiator_ext));
 		ret = -EEXIST;
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (!srp_dev-&gt;has_fmr &amp;&amp; !srp_dev-&gt;has_fr &amp;&amp; !target-&gt;allow_ext_sg &amp;&amp;
<span class="p_chunk">@@ -3207,7 +3203,7 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 	spin_lock_init(&amp;target-&gt;lock);
 	ret = ib_query_gid(ibdev, host-&gt;port, 0, &amp;target-&gt;sgid);
 	if (ret)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto out;</span>
 
 	ret = -ENOMEM;
 	target-&gt;ch_count = max_t(unsigned, num_online_nodes(),
<span class="p_chunk">@@ -3218,7 +3214,7 @@</span> <span class="p_context"> static ssize_t srp_create_target(struct device *dev,</span>
 	target-&gt;ch = kcalloc(target-&gt;ch_count, sizeof(*target-&gt;ch),
 			     GFP_KERNEL);
 	if (!target-&gt;ch)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto out;</span>
 
 	node_idx = 0;
 	for_each_online_node(node) {
<span class="p_chunk">@@ -3314,9 +3310,6 @@</span> <span class="p_context"> err_disconnect:</span>
 	}
 
 	kfree(target-&gt;ch);
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	scsi_host_put(target_host);</span>
 	goto out;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.h b/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_header">index a611556..e690847 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.h</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> struct srp_rdma_ch {</span>
 
 	struct completion	tsk_mgmt_done;
 	u8			tsk_mgmt_status;
<span class="p_add">+	bool			connected;</span>
 };
 
 /**
<span class="p_chunk">@@ -214,7 +215,6 @@</span> <span class="p_context"> struct srp_target_port {</span>
 	__be16			pkey;
 
 	u32			rq_tmo_jiffies;
<span class="p_del">-	bool			connected;</span>
 
 	int			zero_req_lim;
 
<span class="p_header">diff --git a/drivers/input/touchscreen/pixcir_i2c_ts.c b/drivers/input/touchscreen/pixcir_i2c_ts.c</span>
<span class="p_header">index 4fb5537..30b59b5 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/pixcir_i2c_ts.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/pixcir_i2c_ts.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> static void pixcir_ts_parse(struct pixcir_i2c_ts_data *tsdata,</span>
 	}
 
 	ret = i2c_master_recv(tsdata-&gt;client, rdbuf, readsize);
<span class="p_del">-	if (ret != sizeof(rdbuf)) {</span>
<span class="p_add">+	if (ret != readsize) {</span>
 		dev_err(&amp;tsdata-&gt;client-&gt;dev,
 			&quot;%s: i2c_master_recv failed(), ret=%d\n&quot;,
 			__func__, ret);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 9802485..0ecfa72 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1870,9 +1870,15 @@</span> <span class="p_context"> static void free_pt_##LVL (unsigned long __pt)			\</span>
 	pt = (u64 *)__pt;					\
 								\
 	for (i = 0; i &lt; 512; ++i) {				\
<span class="p_add">+		/* PTE present? */				\</span>
 		if (!IOMMU_PTE_PRESENT(pt[i]))			\
 			continue;				\
 								\
<span class="p_add">+		/* Large PTE? */				\</span>
<span class="p_add">+		if (PM_PTE_LEVEL(pt[i]) == 0 ||			\</span>
<span class="p_add">+		    PM_PTE_LEVEL(pt[i]) == 7)			\</span>
<span class="p_add">+			continue;				\</span>
<span class="p_add">+								\</span>
 		p = (unsigned long)IOMMU_PTE_PAGE(pt[i]);	\
 		FN(p);						\
 	}							\
<span class="p_header">diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c</span>
<span class="p_header">index dbeebac..5033e0d 100644</span>
<span class="p_header">--- a/drivers/leds/led-class.c</span>
<span class="p_header">+++ b/drivers/leds/led-class.c</span>
<span class="p_chunk">@@ -183,6 +183,7 @@</span> <span class="p_context"> void led_classdev_resume(struct led_classdev *led_cdev)</span>
 }
 EXPORT_SYMBOL_GPL(led_classdev_resume);
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
 static int led_suspend(struct device *dev)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
<span class="p_chunk">@@ -202,11 +203,9 @@</span> <span class="p_context"> static int led_resume(struct device *dev)</span>
 
 	return 0;
 }
<span class="p_add">+#endif</span>
 
<span class="p_del">-static const struct dev_pm_ops leds_class_dev_pm_ops = {</span>
<span class="p_del">-	.suspend        = led_suspend,</span>
<span class="p_del">-	.resume         = led_resume,</span>
<span class="p_del">-};</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(leds_class_dev_pm_ops, led_suspend, led_resume);</span>
 
 /**
  * led_classdev_register - register a new object of led_classdev class.
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-cleaner.c b/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_header">index b04d1f9..004e463 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_chunk">@@ -171,7 +171,8 @@</span> <span class="p_context"> static void remove_cache_hash_entry(struct wb_cache_entry *e)</span>
 /* Public interface (see dm-cache-policy.h */
 static int wb_map(struct dm_cache_policy *pe, dm_oblock_t oblock,
 		  bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		  struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+		  struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		  struct policy_result *result)</span>
 {
 	struct policy *p = to_policy(pe);
 	struct wb_cache_entry *e;
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-internal.h b/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_header">index 2256a1f..c198e6d 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_chunk">@@ -16,9 +16,10 @@</span> <span class="p_context"></span>
  */
 static inline int policy_map(struct dm_cache_policy *p, dm_oblock_t oblock,
 			     bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-			     struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+			     struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+			     struct policy_result *result)</span>
 {
<span class="p_del">-	return p-&gt;map(p, oblock, can_block, can_migrate, discarded_oblock, bio, result);</span>
<span class="p_add">+	return p-&gt;map(p, oblock, can_block, can_migrate, discarded_oblock, bio, locker, result);</span>
 }
 
 static inline int policy_lookup(struct dm_cache_policy *p, dm_oblock_t oblock, dm_cblock_t *cblock)
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-mq.c b/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_header">index 13f547a..af4936d 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_chunk">@@ -616,9 +616,10 @@</span> <span class="p_context"> static void requeue_and_update_tick(struct mq_policy *mq, struct entry *e)</span>
  * - set the hit count to a hard coded value other than 1, eg, is it better
  *   if it goes in at level 2?
  */
<span class="p_del">-static int demote_cblock(struct mq_policy *mq, dm_oblock_t *oblock)</span>
<span class="p_add">+static int demote_cblock(struct mq_policy *mq,</span>
<span class="p_add">+			 struct policy_locker *locker, dm_oblock_t *oblock)</span>
 {
<span class="p_del">-	struct entry *demoted = pop(mq, &amp;mq-&gt;cache_clean);</span>
<span class="p_add">+	struct entry *demoted = peek(&amp;mq-&gt;cache_clean);</span>
 
 	if (!demoted)
 		/*
<span class="p_chunk">@@ -630,6 +631,13 @@</span> <span class="p_context"> static int demote_cblock(struct mq_policy *mq, dm_oblock_t *oblock)</span>
 		 */
 		return -ENOSPC;
 
<span class="p_add">+	if (locker-&gt;fn(locker, demoted-&gt;oblock))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We couldn&#39;t lock the demoted block.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	del(mq, demoted);</span>
 	*oblock = demoted-&gt;oblock;
 	free_entry(&amp;mq-&gt;cache_pool, demoted);
 
<span class="p_chunk">@@ -718,6 +726,7 @@</span> <span class="p_context"> static int cache_entry_found(struct mq_policy *mq,</span>
  * finding which cache block to use.
  */
 static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,
<span class="p_add">+			      struct policy_locker *locker,</span>
 			      struct policy_result *result)
 {
 	int r;
<span class="p_chunk">@@ -726,11 +735,12 @@</span> <span class="p_context"> static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,</span>
 	/* Ensure there&#39;s a free cblock in the cache */
 	if (epool_empty(&amp;mq-&gt;cache_pool)) {
 		result-&gt;op = POLICY_REPLACE;
<span class="p_del">-		r = demote_cblock(mq, &amp;result-&gt;old_oblock);</span>
<span class="p_add">+		r = demote_cblock(mq, locker, &amp;result-&gt;old_oblock);</span>
 		if (r) {
 			result-&gt;op = POLICY_MISS;
 			return 0;
 		}
<span class="p_add">+</span>
 	} else
 		result-&gt;op = POLICY_NEW;
 
<span class="p_chunk">@@ -754,7 +764,8 @@</span> <span class="p_context"> static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,</span>
 
 static int pre_cache_entry_found(struct mq_policy *mq, struct entry *e,
 				 bool can_migrate, bool discarded_oblock,
<span class="p_del">-				 int data_dir, struct policy_result *result)</span>
<span class="p_add">+				 int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+				 struct policy_result *result)</span>
 {
 	int r = 0;
 	bool updated = updated_this_tick(mq, e);
<span class="p_chunk">@@ -769,7 +780,7 @@</span> <span class="p_context"> static int pre_cache_entry_found(struct mq_policy *mq, struct entry *e,</span>
 
 	else {
 		requeue_and_update_tick(mq, e);
<span class="p_del">-		r = pre_cache_to_cache(mq, e, result);</span>
<span class="p_add">+		r = pre_cache_to_cache(mq, e, locker, result);</span>
 	}
 
 	return r;
<span class="p_chunk">@@ -800,6 +811,7 @@</span> <span class="p_context"> static void insert_in_pre_cache(struct mq_policy *mq,</span>
 }
 
 static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,
<span class="p_add">+			    struct policy_locker *locker,</span>
 			    struct policy_result *result)
 {
 	int r;
<span class="p_chunk">@@ -807,7 +819,7 @@</span> <span class="p_context"> static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 	if (epool_empty(&amp;mq-&gt;cache_pool)) {
 		result-&gt;op = POLICY_REPLACE;
<span class="p_del">-		r = demote_cblock(mq, &amp;result-&gt;old_oblock);</span>
<span class="p_add">+		r = demote_cblock(mq, locker, &amp;result-&gt;old_oblock);</span>
 		if (unlikely(r)) {
 			result-&gt;op = POLICY_MISS;
 			insert_in_pre_cache(mq, oblock);
<span class="p_chunk">@@ -836,11 +848,12 @@</span> <span class="p_context"> static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 static int no_entry_found(struct mq_policy *mq, dm_oblock_t oblock,
 			  bool can_migrate, bool discarded_oblock,
<span class="p_del">-			  int data_dir, struct policy_result *result)</span>
<span class="p_add">+			  int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+			  struct policy_result *result)</span>
 {
 	if (adjusted_promote_threshold(mq, discarded_oblock, data_dir) &lt;= 1) {
 		if (can_migrate)
<span class="p_del">-			insert_in_cache(mq, oblock, result);</span>
<span class="p_add">+			insert_in_cache(mq, oblock, locker, result);</span>
 		else
 			return -EWOULDBLOCK;
 	} else {
<span class="p_chunk">@@ -857,7 +870,8 @@</span> <span class="p_context"> static int no_entry_found(struct mq_policy *mq, dm_oblock_t oblock,</span>
  */
 static int map(struct mq_policy *mq, dm_oblock_t oblock,
 	       bool can_migrate, bool discarded_oblock,
<span class="p_del">-	       int data_dir, struct policy_result *result)</span>
<span class="p_add">+	       int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+	       struct policy_result *result)</span>
 {
 	int r = 0;
 	struct entry *e = hash_lookup(mq, oblock);
<span class="p_chunk">@@ -871,11 +885,11 @@</span> <span class="p_context"> static int map(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 	else if (e)
 		r = pre_cache_entry_found(mq, e, can_migrate, discarded_oblock,
<span class="p_del">-					  data_dir, result);</span>
<span class="p_add">+					  data_dir, locker, result);</span>
 
 	else
 		r = no_entry_found(mq, oblock, can_migrate, discarded_oblock,
<span class="p_del">-				   data_dir, result);</span>
<span class="p_add">+				   data_dir, locker, result);</span>
 
 	if (r == -EWOULDBLOCK)
 		result-&gt;op = POLICY_MISS;
<span class="p_chunk">@@ -916,7 +930,8 @@</span> <span class="p_context"> static void copy_tick(struct mq_policy *mq)</span>
 
 static int mq_map(struct dm_cache_policy *p, dm_oblock_t oblock,
 		  bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		  struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+		  struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		  struct policy_result *result)</span>
 {
 	int r;
 	struct mq_policy *mq = to_mq_policy(p);
<span class="p_chunk">@@ -932,7 +947,7 @@</span> <span class="p_context"> static int mq_map(struct dm_cache_policy *p, dm_oblock_t oblock,</span>
 
 	iot_examine_bio(&amp;mq-&gt;tracker, bio);
 	r = map(mq, oblock, can_migrate, discarded_oblock,
<span class="p_del">-		bio_data_dir(bio), result);</span>
<span class="p_add">+		bio_data_dir(bio), locker, result);</span>
 
 	mutex_unlock(&amp;mq-&gt;lock);
 
<span class="p_header">diff --git a/drivers/md/dm-cache-policy.h b/drivers/md/dm-cache-policy.h</span>
<span class="p_header">index f50fe36..5524e21 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy.h</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy.h</span>
<span class="p_chunk">@@ -70,6 +70,18 @@</span> <span class="p_context"> enum policy_operation {</span>
 };
 
 /*
<span class="p_add">+ * When issuing a POLICY_REPLACE the policy needs to make a callback to</span>
<span class="p_add">+ * lock the block being demoted.  This doesn&#39;t need to occur during a</span>
<span class="p_add">+ * writeback operation since the block remains in the cache.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct policy_locker;</span>
<span class="p_add">+typedef int (*policy_lock_fn)(struct policy_locker *l, dm_oblock_t oblock);</span>
<span class="p_add">+</span>
<span class="p_add">+struct policy_locker {</span>
<span class="p_add">+	policy_lock_fn fn;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * This is the instruction passed back to the core target.
  */
 struct policy_result {
<span class="p_chunk">@@ -122,7 +134,8 @@</span> <span class="p_context"> struct dm_cache_policy {</span>
 	 */
 	int (*map)(struct dm_cache_policy *p, dm_oblock_t oblock,
 		   bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		   struct bio *bio, struct policy_result *result);</span>
<span class="p_add">+		   struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		   struct policy_result *result);</span>
 
 	/*
 	 * Sometimes we want to see if a block is in the cache, without
<span class="p_header">diff --git a/drivers/md/dm-cache-target.c b/drivers/md/dm-cache-target.c</span>
<span class="p_header">index e165053..b283f51 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-target.c</span>
<span class="p_chunk">@@ -1444,16 +1444,43 @@</span> <span class="p_context"> static void inc_miss_counter(struct cache *cache, struct bio *bio)</span>
 		   &amp;cache-&gt;stats.read_miss : &amp;cache-&gt;stats.write_miss);
 }
 
<span class="p_add">+/*----------------------------------------------------------------*/</span>
<span class="p_add">+</span>
<span class="p_add">+struct old_oblock_lock {</span>
<span class="p_add">+	struct policy_locker locker;</span>
<span class="p_add">+	struct cache *cache;</span>
<span class="p_add">+	struct prealloc *structs;</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int null_locker(struct policy_locker *locker, dm_oblock_t b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* This should never be called */</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int cell_locker(struct policy_locker *locker, dm_oblock_t b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct old_oblock_lock *l = container_of(locker, struct old_oblock_lock, locker);</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell_prealloc = prealloc_get_cell(l-&gt;structs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return bio_detain(l-&gt;cache, b, NULL, cell_prealloc,</span>
<span class="p_add">+			  (cell_free_fn) prealloc_put_cell,</span>
<span class="p_add">+			  l-&gt;structs, &amp;l-&gt;cell);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void process_bio(struct cache *cache, struct prealloc *structs,
 			struct bio *bio)
 {
 	int r;
 	bool release_cell = true;
 	dm_oblock_t block = get_bio_block(cache, bio);
<span class="p_del">-	struct dm_bio_prison_cell *cell_prealloc, *old_ocell, *new_ocell;</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell_prealloc, *new_ocell;</span>
 	struct policy_result lookup_result;
 	bool passthrough = passthrough_mode(&amp;cache-&gt;features);
 	bool discarded_block, can_migrate;
<span class="p_add">+	struct old_oblock_lock ool;</span>
 
 	/*
 	 * Check to see if that block is currently migrating.
<span class="p_chunk">@@ -1468,8 +1495,12 @@</span> <span class="p_context"> static void process_bio(struct cache *cache, struct prealloc *structs,</span>
 	discarded_block = is_discarded_oblock(cache, block);
 	can_migrate = !passthrough &amp;&amp; (discarded_block || spare_migration_bandwidth(cache));
 
<span class="p_add">+	ool.locker.fn = cell_locker;</span>
<span class="p_add">+	ool.cache = cache;</span>
<span class="p_add">+	ool.structs = structs;</span>
<span class="p_add">+	ool.cell = NULL;</span>
 	r = policy_map(cache-&gt;policy, block, true, can_migrate, discarded_block,
<span class="p_del">-		       bio, &amp;lookup_result);</span>
<span class="p_add">+		       bio, &amp;ool.locker, &amp;lookup_result);</span>
 
 	if (r == -EWOULDBLOCK)
 		/* migration has been denied */
<span class="p_chunk">@@ -1526,27 +1557,11 @@</span> <span class="p_context"> static void process_bio(struct cache *cache, struct prealloc *structs,</span>
 		break;
 
 	case POLICY_REPLACE:
<span class="p_del">-		cell_prealloc = prealloc_get_cell(structs);</span>
<span class="p_del">-		r = bio_detain(cache, lookup_result.old_oblock, bio, cell_prealloc,</span>
<span class="p_del">-			       (cell_free_fn) prealloc_put_cell,</span>
<span class="p_del">-			       structs, &amp;old_ocell);</span>
<span class="p_del">-		if (r &gt; 0) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We have to be careful to avoid lock inversion of</span>
<span class="p_del">-			 * the cells.  So we back off, and wait for the</span>
<span class="p_del">-			 * old_ocell to become free.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			policy_force_mapping(cache-&gt;policy, block,</span>
<span class="p_del">-					     lookup_result.old_oblock);</span>
<span class="p_del">-			atomic_inc(&amp;cache-&gt;stats.cache_cell_clash);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		atomic_inc(&amp;cache-&gt;stats.demotion);
 		atomic_inc(&amp;cache-&gt;stats.promotion);
<span class="p_del">-</span>
 		demote_then_promote(cache, structs, lookup_result.old_oblock,
 				    block, lookup_result.cblock,
<span class="p_del">-				    old_ocell, new_ocell);</span>
<span class="p_add">+				    ool.cell, new_ocell);</span>
 		release_cell = false;
 		break;
 
<span class="p_chunk">@@ -2594,6 +2609,9 @@</span> <span class="p_context"> static int __cache_map(struct cache *cache, struct bio *bio, struct dm_bio_priso</span>
 	bool discarded_block;
 	struct policy_result lookup_result;
 	struct per_bio_data *pb = init_per_bio_data(bio, pb_data_size);
<span class="p_add">+	struct old_oblock_lock ool;</span>
<span class="p_add">+</span>
<span class="p_add">+	ool.locker.fn = null_locker;</span>
 
 	if (unlikely(from_oblock(block) &gt;= from_oblock(cache-&gt;origin_blocks))) {
 		/*
<span class="p_chunk">@@ -2632,7 +2650,7 @@</span> <span class="p_context"> static int __cache_map(struct cache *cache, struct bio *bio, struct dm_bio_priso</span>
 	discarded_block = is_discarded_oblock(cache, block);
 
 	r = policy_map(cache-&gt;policy, block, false, can_migrate, discarded_block,
<span class="p_del">-		       bio, &amp;lookup_result);</span>
<span class="p_add">+		       bio, &amp;ool.locker, &amp;lookup_result);</span>
 	if (r == -EWOULDBLOCK) {
 		cell_defer(cache, *cell, true);
 		return DM_MAPIO_SUBMITTED;
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index f478a4c..419bdd4 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -795,6 +795,8 @@</span> <span class="p_context"> static int message_stats_create(struct mapped_device *md,</span>
 		return -EINVAL;
 
 	if (sscanf(argv[2], &quot;/%u%c&quot;, &amp;divisor, &amp;dummy) == 1) {
<span class="p_add">+		if (!divisor)</span>
<span class="p_add">+			return -EINVAL;</span>
 		step = end - start;
 		if (do_div(step, divisor))
 			step++;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index e8a9042..5309129 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -204,6 +204,27 @@</span> <span class="p_context"> static void in(struct sm_metadata *smm)</span>
 	smm-&gt;recursion_count++;
 }
 
<span class="p_add">+static int apply_bops(struct sm_metadata *smm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_add">+		struct block_op bop;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = commit_bop(smm, &amp;bop);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int out(struct sm_metadata *smm)
 {
 	int r = 0;
<span class="p_chunk">@@ -216,21 +237,8 @@</span> <span class="p_context"> static int out(struct sm_metadata *smm)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	if (smm-&gt;recursion_count == 1) {</span>
<span class="p_del">-		while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_del">-			struct block_op bop;</span>
<span class="p_del">-</span>
<span class="p_del">-			r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_del">-			if (r) {</span>
<span class="p_del">-				DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			r = commit_bop(smm, &amp;bop);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (smm-&gt;recursion_count == 1)</span>
<span class="p_add">+		apply_bops(smm);</span>
 
 	smm-&gt;recursion_count--;
 
<span class="p_chunk">@@ -704,6 +712,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 		}
 		old_len = smm-&gt;begin;
 
<span class="p_add">+		r = apply_bops(smm);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		r = sm_ll_commit(&amp;smm-&gt;ll);
 		if (r)
 			goto out;
<span class="p_chunk">@@ -773,6 +787,12 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	if (r)
 		return r;
 
<span class="p_add">+	r = apply_bops(smm);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return sm_metadata_commit(sm);
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index 8001690..ba6c8f6 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -605,6 +605,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c..7bc68b3 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24117.c b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">index acb965c..af63635 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_chunk">@@ -1043,7 +1043,7 @@</span> <span class="p_context"> static int cx24117_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	dev_dbg(&amp;state-&gt;priv-&gt;i2c-&gt;dev, &quot;)\n&quot;);
 
 	/* Validate length */
<span class="p_del">-	if (d-&gt;msg_len &gt; 15)</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
 		return -EINVAL;
 
 	/* DiSEqC message */
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7..0b4f8fe 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/media/pci/cx18/cx18-streams.c b/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_header">index 369445f..ec68028 100644</span>
<span class="p_header">--- a/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_header">+++ b/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> static struct {</span>
 		&quot;encoder PCM audio&quot;,
 		VFL_TYPE_GRABBER, CX18_V4L2_ENC_PCM_OFFSET,
 		PCI_DMA_FROMDEVICE,
<span class="p_add">+		V4L2_CAP_TUNER | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,</span>
 	},
 	{	/* CX18_ENC_STREAM_TYPE_IDX */
 		&quot;encoder IDX&quot;,
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-encoder.c b/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_header">index 9266965..7a0a651 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_chunk">@@ -721,13 +721,14 @@</span> <span class="p_context"> static int vidioc_querycap(struct file *file, void  *priv,</span>
 		sizeof(cap-&gt;card));
 	sprintf(cap-&gt;bus_info, &quot;PCI:%s&quot;, pci_name(dev-&gt;pci));
 
<span class="p_del">-	cap-&gt;capabilities =</span>
<span class="p_add">+	cap-&gt;device_caps =</span>
 		V4L2_CAP_VIDEO_CAPTURE |
<span class="p_del">-		V4L2_CAP_READWRITE     |</span>
<span class="p_del">-		0;</span>
<span class="p_add">+		V4L2_CAP_READWRITE |</span>
<span class="p_add">+		V4L2_CAP_TUNER;</span>
 
<span class="p_del">-	cap-&gt;capabilities |= V4L2_CAP_TUNER;</span>
<span class="p_del">-	cap-&gt;version = 0;</span>
<span class="p_add">+	cap-&gt;capabilities = cap-&gt;device_caps |</span>
<span class="p_add">+		V4L2_CAP_VBI_CAPTURE |</span>
<span class="p_add">+		V4L2_CAP_DEVICE_CAPS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-vbi.c b/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_header">index 6e025fe..06117e6 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_chunk">@@ -660,13 +660,14 @@</span> <span class="p_context"> static int vidioc_querycap(struct file *file, void  *priv,</span>
 		sizeof(cap-&gt;card));
 	sprintf(cap-&gt;bus_info, &quot;PCI:%s&quot;, pci_name(dev-&gt;pci));
 
<span class="p_del">-	cap-&gt;capabilities =</span>
<span class="p_add">+	cap-&gt;device_caps =</span>
 		V4L2_CAP_VBI_CAPTURE |
<span class="p_del">-		V4L2_CAP_READWRITE     |</span>
<span class="p_del">-		0;</span>
<span class="p_add">+		V4L2_CAP_READWRITE |</span>
<span class="p_add">+		V4L2_CAP_TUNER;</span>
 
<span class="p_del">-	cap-&gt;capabilities |= V4L2_CAP_TUNER;</span>
<span class="p_del">-	cap-&gt;version = 0;</span>
<span class="p_add">+	cap-&gt;capabilities = cap-&gt;device_caps |</span>
<span class="p_add">+		V4L2_CAP_VIDEO_CAPTURE |</span>
<span class="p_add">+		V4L2_CAP_DEVICE_CAPS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_core.c b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">index 50856db..605b090 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_chunk">@@ -658,10 +658,20 @@</span> <span class="p_context"> out:</span>
 struct dib0700_rc_response {
 	u8 report_id;
 	u8 data_state;
<span class="p_del">-	u8 system;</span>
<span class="p_del">-	u8 not_system;</span>
<span class="p_del">-	u8 data;</span>
<span class="p_del">-	u8 not_data;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u8 system;</span>
<span class="p_add">+			u8 not_system;</span>
<span class="p_add">+			u8 data;</span>
<span class="p_add">+			u8 not_data;</span>
<span class="p_add">+		} nec;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u8 not_used;</span>
<span class="p_add">+			u8 system;</span>
<span class="p_add">+			u8 data;</span>
<span class="p_add">+			u8 not_data;</span>
<span class="p_add">+		} rc5;</span>
<span class="p_add">+	};</span>
 };
 #define RC_MSG_SIZE_V1_20 6
 
<span class="p_chunk">@@ -697,8 +707,8 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 
 	deb_data(&quot;IR ID = %02X state = %02X System = %02X %02X Cmd = %02X %02X (len %d)\n&quot;,
 		 poll_reply-&gt;report_id, poll_reply-&gt;data_state,
<span class="p_del">-		 poll_reply-&gt;system, poll_reply-&gt;not_system,</span>
<span class="p_del">-		 poll_reply-&gt;data, poll_reply-&gt;not_data,</span>
<span class="p_add">+		 poll_reply-&gt;nec.system, poll_reply-&gt;nec.not_system,</span>
<span class="p_add">+		 poll_reply-&gt;nec.data, poll_reply-&gt;nec.not_data,</span>
 		 purb-&gt;actual_length);
 
 	switch (d-&gt;props.rc.core.protocol) {
<span class="p_chunk">@@ -707,30 +717,30 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 		toggle = 0;
 
 		/* NEC protocol sends repeat code as 0 0 0 FF */
<span class="p_del">-		if (poll_reply-&gt;system     == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;not_system == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;data       == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;not_data   == 0xff) {</span>
<span class="p_add">+		if (poll_reply-&gt;nec.system     == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.not_system == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.data       == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.not_data   == 0xff) {</span>
 			poll_reply-&gt;data_state = 2;
 			break;
 		}
 
<span class="p_del">-		if ((poll_reply-&gt;data ^ poll_reply-&gt;not_data) != 0xff) {</span>
<span class="p_add">+		if ((poll_reply-&gt;nec.data ^ poll_reply-&gt;nec.not_data) != 0xff) {</span>
 			deb_data(&quot;NEC32 protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NEC32(poll_reply-&gt;system     &lt;&lt; 24 |</span>
<span class="p_del">-						     poll_reply-&gt;not_system &lt;&lt; 16 |</span>
<span class="p_del">-						     poll_reply-&gt;data       &lt;&lt; 8  |</span>
<span class="p_del">-						     poll_reply-&gt;not_data);</span>
<span class="p_del">-		} else if ((poll_reply-&gt;system ^ poll_reply-&gt;not_system) != 0xff) {</span>
<span class="p_add">+			keycode = RC_SCANCODE_NEC32(poll_reply-&gt;nec.system     &lt;&lt; 24 |</span>
<span class="p_add">+						     poll_reply-&gt;nec.not_system &lt;&lt; 16 |</span>
<span class="p_add">+						     poll_reply-&gt;nec.data       &lt;&lt; 8  |</span>
<span class="p_add">+						     poll_reply-&gt;nec.not_data);</span>
<span class="p_add">+		} else if ((poll_reply-&gt;nec.system ^ poll_reply-&gt;nec.not_system) != 0xff) {</span>
 			deb_data(&quot;NEC extended protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NECX(poll_reply-&gt;system &lt;&lt; 8 |</span>
<span class="p_del">-						    poll_reply-&gt;not_system,</span>
<span class="p_del">-						    poll_reply-&gt;data);</span>
<span class="p_add">+			keycode = RC_SCANCODE_NECX(poll_reply-&gt;nec.system &lt;&lt; 8 |</span>
<span class="p_add">+						    poll_reply-&gt;nec.not_system,</span>
<span class="p_add">+						    poll_reply-&gt;nec.data);</span>
 
 		} else {
 			deb_data(&quot;NEC normal protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NEC(poll_reply-&gt;system,</span>
<span class="p_del">-						   poll_reply-&gt;data);</span>
<span class="p_add">+			keycode = RC_SCANCODE_NEC(poll_reply-&gt;nec.system,</span>
<span class="p_add">+						   poll_reply-&gt;nec.data);</span>
 		}
 
 		break;
<span class="p_chunk">@@ -738,19 +748,19 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 		deb_data(&quot;RC5 protocol\n&quot;);
 		protocol = RC_TYPE_RC5;
 		toggle = poll_reply-&gt;report_id;
<span class="p_del">-		keycode = RC_SCANCODE_RC5(poll_reply-&gt;system, poll_reply-&gt;data);</span>
<span class="p_add">+		keycode = RC_SCANCODE_RC5(poll_reply-&gt;rc5.system, poll_reply-&gt;rc5.data);</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((poll_reply-&gt;rc5.data ^ poll_reply-&gt;rc5.not_data) != 0xff) {</span>
<span class="p_add">+			/* Key failed integrity check */</span>
<span class="p_add">+			err(&quot;key failed integrity check: %02x %02x %02x %02x&quot;,</span>
<span class="p_add">+			    poll_reply-&gt;rc5.not_used, poll_reply-&gt;rc5.system,</span>
<span class="p_add">+			    poll_reply-&gt;rc5.data, poll_reply-&gt;rc5.not_data);</span>
<span class="p_add">+			goto resubmit;</span>
<span class="p_add">+		}</span>
 
 		break;
 	}
 
<span class="p_del">-	if ((poll_reply-&gt;data + poll_reply-&gt;not_data) != 0xff) {</span>
<span class="p_del">-		/* Key failed integrity check */</span>
<span class="p_del">-		err(&quot;key failed integrity check: %02x %02x %02x %02x&quot;,</span>
<span class="p_del">-		    poll_reply-&gt;system,  poll_reply-&gt;not_system,</span>
<span class="p_del">-		    poll_reply-&gt;data, poll_reply-&gt;not_data);</span>
<span class="p_del">-		goto resubmit;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc_keydown(d-&gt;rc_dev, protocol, keycode, toggle);
 
 resubmit:
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_devices.c b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">index e1757b8..6aa4e9f 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_chunk">@@ -3947,6 +3947,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			}, {
 			.num_frontends = 1,
 			.fe = {{
<span class="p_chunk">@@ -3959,6 +3961,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x03),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			}
 		},
 
<span class="p_chunk">@@ -4012,6 +4016,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			},
 		},
 
<span class="p_header">diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c</span>
<span class="p_header">index 1382d55..d5b9028 100644</span>
<span class="p_header">--- a/drivers/misc/mei/client.c</span>
<span class="p_header">+++ b/drivers/misc/mei/client.c</span>
<span class="p_chunk">@@ -478,7 +478,7 @@</span> <span class="p_context"> void mei_host_client_init(struct work_struct *work)</span>
 bool mei_hbuf_acquire(struct mei_device *dev)
 {
 	if (mei_pg_state(dev) == MEI_PG_ON ||
<span class="p_del">-	    dev-&gt;pg_event == MEI_PG_EVENT_WAIT) {</span>
<span class="p_add">+	    mei_pg_in_transition(dev)) {</span>
 		dev_dbg(dev-&gt;dev, &quot;device is in pg\n&quot;);
 		return false;
 	}
<span class="p_header">diff --git a/drivers/misc/mei/hw-me.c b/drivers/misc/mei/hw-me.c</span>
<span class="p_header">index f8fd503..19e0cdb 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-me.c</span>
<span class="p_chunk">@@ -629,11 +629,27 @@</span> <span class="p_context"> int mei_me_pg_unset_sync(struct mei_device *dev)</span>
 	mutex_lock(&amp;dev-&gt;device_lock);
 
 reply:
<span class="p_del">-	if (dev-&gt;pg_event == MEI_PG_EVENT_RECEIVED)</span>
<span class="p_del">-		ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_EXIT_RES_CMD);</span>
<span class="p_add">+	if (dev-&gt;pg_event != MEI_PG_EVENT_RECEIVED) {</span>
<span class="p_add">+		ret = -ETIME;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;pg_event = MEI_PG_EVENT_INTR_WAIT;</span>
<span class="p_add">+	ret = mei_hbm_pg(dev, MEI_PG_ISOLATION_EXIT_RES_CMD);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;dev-&gt;device_lock);</span>
<span class="p_add">+	wait_event_timeout(dev-&gt;wait_pg,</span>
<span class="p_add">+		dev-&gt;pg_event == MEI_PG_EVENT_INTR_RECEIVED, timeout);</span>
<span class="p_add">+	mutex_lock(&amp;dev-&gt;device_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;pg_event == MEI_PG_EVENT_INTR_RECEIVED)</span>
<span class="p_add">+		ret = 0;</span>
 	else
 		ret = -ETIME;
 
<span class="p_add">+out:</span>
 	dev-&gt;pg_event = MEI_PG_EVENT_IDLE;
 	hw-&gt;pg_state = MEI_PG_OFF;
 
<span class="p_chunk">@@ -641,6 +657,19 @@</span> <span class="p_context"> reply:</span>
 }
 
 /**
<span class="p_add">+ * mei_me_pg_in_transition - is device now in pg transition</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: the device structure</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: true if in pg transition, false otherwise</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool mei_me_pg_in_transition(struct mei_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;pg_event &gt;= MEI_PG_EVENT_WAIT &amp;&amp;</span>
<span class="p_add">+	       dev-&gt;pg_event &lt;= MEI_PG_EVENT_INTR_WAIT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * mei_me_pg_is_enabled - detect if PG is supported by HW
  *
  * @dev: the device structure
<span class="p_chunk">@@ -672,6 +701,24 @@</span> <span class="p_context"> notsupported:</span>
 }
 
 /**
<span class="p_add">+ * mei_me_pg_intr - perform pg processing in interrupt thread handler</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: the device structure</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void mei_me_pg_intr(struct mei_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mei_me_hw *hw = to_me_hw(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;pg_event != MEI_PG_EVENT_INTR_WAIT)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;pg_event = MEI_PG_EVENT_INTR_RECEIVED;</span>
<span class="p_add">+	hw-&gt;pg_state = MEI_PG_OFF;</span>
<span class="p_add">+	if (waitqueue_active(&amp;dev-&gt;wait_pg))</span>
<span class="p_add">+		wake_up(&amp;dev-&gt;wait_pg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * mei_me_irq_quick_handler - The ISR of the MEI device
  *
  * @irq: The irq number
<span class="p_chunk">@@ -729,6 +776,8 @@</span> <span class="p_context"> irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)</span>
 		goto end;
 	}
 
<span class="p_add">+	mei_me_pg_intr(dev);</span>
<span class="p_add">+</span>
 	/*  check if we need to start the dev */
 	if (!mei_host_is_ready(dev)) {
 		if (mei_hw_is_ready(dev)) {
<span class="p_chunk">@@ -765,9 +814,10 @@</span> <span class="p_context"> irqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)</span>
 	/*
 	 * During PG handshake only allowed write is the replay to the
 	 * PG exit message, so block calling write function
<span class="p_del">-	 * if the pg state is not idle</span>
<span class="p_add">+	 * if the pg event is in PG handshake</span>
 	 */
<span class="p_del">-	if (dev-&gt;pg_event == MEI_PG_EVENT_IDLE) {</span>
<span class="p_add">+	if (dev-&gt;pg_event != MEI_PG_EVENT_WAIT &amp;&amp;</span>
<span class="p_add">+	    dev-&gt;pg_event != MEI_PG_EVENT_RECEIVED) {</span>
 		rets = mei_irq_write_handler(dev, &amp;complete_list);
 		dev-&gt;hbuf_is_ready = mei_hbuf_is_ready(dev);
 	}
<span class="p_chunk">@@ -792,6 +842,7 @@</span> <span class="p_context"> static const struct mei_hw_ops mei_me_hw_ops = {</span>
 	.hw_config = mei_me_hw_config,
 	.hw_start = mei_me_hw_start,
 
<span class="p_add">+	.pg_in_transition = mei_me_pg_in_transition,</span>
 	.pg_is_enabled = mei_me_pg_is_enabled,
 
 	.intr_clear = mei_me_intr_clear,
<span class="p_header">diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">index 618ea72..50bd6e9 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-txe.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/jiffies.h&gt;
<span class="p_add">+#include &lt;linux/ktime.h&gt;</span>
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/irqreturn.h&gt;
<span class="p_chunk">@@ -218,26 +219,25 @@</span> <span class="p_context"> static u32 mei_txe_aliveness_get(struct mei_device *dev)</span>
  *
  * Polls for HICR_HOST_ALIVENESS_RESP.ALIVENESS_RESP to be set
  *
<span class="p_del">- * Return: &gt; 0 if the expected value was received, -ETIME otherwise</span>
<span class="p_add">+ * Return: 0 if the expected value was received, -ETIME otherwise</span>
  */
 static int mei_txe_aliveness_poll(struct mei_device *dev, u32 expected)
 {
 	struct mei_txe_hw *hw = to_txe_hw(dev);
<span class="p_del">-	int t = 0;</span>
<span class="p_add">+	ktime_t stop, start;</span>
 
<span class="p_add">+	start = ktime_get();</span>
<span class="p_add">+	stop = ktime_add(start, ms_to_ktime(SEC_ALIVENESS_WAIT_TIMEOUT));</span>
 	do {
 		hw-&gt;aliveness = mei_txe_aliveness_get(dev);
 		if (hw-&gt;aliveness == expected) {
 			dev-&gt;pg_event = MEI_PG_EVENT_IDLE;
<span class="p_del">-			dev_dbg(dev-&gt;dev,</span>
<span class="p_del">-				&quot;aliveness settled after %d msecs\n&quot;, t);</span>
<span class="p_del">-			return t;</span>
<span class="p_add">+			dev_dbg(dev-&gt;dev, &quot;aliveness settled after %lld usecs\n&quot;,</span>
<span class="p_add">+				ktime_to_us(ktime_sub(ktime_get(), start)));</span>
<span class="p_add">+			return 0;</span>
 		}
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;device_lock);</span>
<span class="p_del">-		msleep(MSEC_PER_SEC / 5);</span>
<span class="p_del">-		mutex_lock(&amp;dev-&gt;device_lock);</span>
<span class="p_del">-		t += MSEC_PER_SEC / 5;</span>
<span class="p_del">-	} while (t &lt; SEC_ALIVENESS_WAIT_TIMEOUT);</span>
<span class="p_add">+		usleep_range(20, 50);</span>
<span class="p_add">+	} while (ktime_before(ktime_get(), stop));</span>
 
 	dev-&gt;pg_event = MEI_PG_EVENT_IDLE;
 	dev_err(dev-&gt;dev, &quot;aliveness timed out\n&quot;);
<span class="p_chunk">@@ -302,6 +302,18 @@</span> <span class="p_context"> int mei_txe_aliveness_set_sync(struct mei_device *dev, u32 req)</span>
 }
 
 /**
<span class="p_add">+ * mei_txe_pg_in_transition - is device now in pg transition</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: the device structure</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: true if in pg transition, false otherwise</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool mei_txe_pg_in_transition(struct mei_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;pg_event == MEI_PG_EVENT_WAIT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * mei_txe_pg_is_enabled - detect if PG is supported by HW
  *
  * @dev: the device structure
<span class="p_chunk">@@ -1138,6 +1150,7 @@</span> <span class="p_context"> static const struct mei_hw_ops mei_txe_hw_ops = {</span>
 	.hw_config = mei_txe_hw_config,
 	.hw_start = mei_txe_hw_start,
 
<span class="p_add">+	.pg_in_transition = mei_txe_pg_in_transition,</span>
 	.pg_is_enabled = mei_txe_pg_is_enabled,
 
 	.intr_clear = mei_txe_intr_clear,
<span class="p_header">diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">index 3dad74a..7d2f644 100644</span>
<span class="p_header">--- a/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">+++ b/drivers/misc/mei/mei_dev.h</span>
<span class="p_chunk">@@ -267,6 +267,7 @@</span> <span class="p_context"> struct mei_cl {</span>
 
  * @fw_status        : get fw status registers
  * @pg_state         : power gating state of the device
<span class="p_add">+ * @pg_in_transition : is device now in pg transition</span>
  * @pg_is_enabled    : is power gating enabled
 
  * @intr_clear       : clear pending interrupts
<span class="p_chunk">@@ -296,6 +297,7 @@</span> <span class="p_context"> struct mei_hw_ops {</span>
 
 	int (*fw_status)(struct mei_device *dev, struct mei_fw_status *fw_sts);
 	enum mei_pg_state (*pg_state)(struct mei_device *dev);
<span class="p_add">+	bool (*pg_in_transition)(struct mei_device *dev);</span>
 	bool (*pg_is_enabled)(struct mei_device *dev);
 
 	void (*intr_clear)(struct mei_device *dev);
<span class="p_chunk">@@ -394,11 +396,15 @@</span> <span class="p_context"> struct mei_cl_device {</span>
  * @MEI_PG_EVENT_IDLE: the driver is not in power gating transition
  * @MEI_PG_EVENT_WAIT: the driver is waiting for a pg event to complete
  * @MEI_PG_EVENT_RECEIVED: the driver received pg event
<span class="p_add">+ * @MEI_PG_EVENT_INTR_WAIT: the driver is waiting for a pg event interrupt</span>
<span class="p_add">+ * @MEI_PG_EVENT_INTR_RECEIVED: the driver received pg event interrupt</span>
  */
 enum mei_pg_event {
 	MEI_PG_EVENT_IDLE,
 	MEI_PG_EVENT_WAIT,
 	MEI_PG_EVENT_RECEIVED,
<span class="p_add">+	MEI_PG_EVENT_INTR_WAIT,</span>
<span class="p_add">+	MEI_PG_EVENT_INTR_RECEIVED,</span>
 };
 
 /**
<span class="p_chunk">@@ -725,6 +731,11 @@</span> <span class="p_context"> static inline enum mei_pg_state mei_pg_state(struct mei_device *dev)</span>
 	return dev-&gt;ops-&gt;pg_state(dev);
 }
 
<span class="p_add">+static inline bool mei_pg_in_transition(struct mei_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;ops-&gt;pg_in_transition(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool mei_pg_is_enabled(struct mei_device *dev)
 {
 	return dev-&gt;ops-&gt;pg_is_enabled(dev);
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 4e5d36a..c972b97 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1910,9 +1910,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index f1a488e..5c8b463 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -3247,13 +3247,14 @@</span> <span class="p_context"> int sdhci_add_host(struct sdhci_host *host)</span>
 				   SDHCI_MAX_CURRENT_MULTIPLIER;
 	}
 
<span class="p_del">-	/* If OCR set by external regulators, use it instead */</span>
<span class="p_add">+	/* If OCR set by host, use it instead. */</span>
<span class="p_add">+	if (host-&gt;ocr_mask)</span>
<span class="p_add">+		ocr_avail = host-&gt;ocr_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If OCR set by external regulators, give it highest prio. */</span>
 	if (mmc-&gt;ocr_avail)
 		ocr_avail = mmc-&gt;ocr_avail;
 
<span class="p_del">-	if (host-&gt;ocr_mask)</span>
<span class="p_del">-		ocr_avail &amp;= host-&gt;ocr_mask;</span>
<span class="p_del">-</span>
 	mmc-&gt;ocr_avail = ocr_avail;
 	mmc-&gt;ocr_avail_sdio = ocr_avail;
 	if (host-&gt;ocr_avail_sdio)
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f8a7dd1..70a3db3 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index d08229e..3a69b1e 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -200,6 +200,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -223,6 +224,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -233,6 +235,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -246,6 +249,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -259,6 +263,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 }
<span class="p_header">diff --git a/drivers/net/dsa/bcm_sf2.c b/drivers/net/dsa/bcm_sf2.c</span>
<span class="p_header">index feb29c4..784b5aa 100644</span>
<span class="p_header">--- a/drivers/net/dsa/bcm_sf2.c</span>
<span class="p_header">+++ b/drivers/net/dsa/bcm_sf2.c</span>
<span class="p_chunk">@@ -706,6 +706,13 @@</span> <span class="p_context"> static void bcm_sf2_sw_fixed_link_update(struct dsa_switch *ds, int port,</span>
 	 */
 	if (port == 7) {
 		status-&gt;link = priv-&gt;port_sts[port].link;
<span class="p_add">+		/* For MoCA interfaces, also force a link down notification</span>
<span class="p_add">+		 * since some version of the user-space daemon (mocad) use</span>
<span class="p_add">+		 * cmd-&gt;autoneg to force the link, which messes up the PHY</span>
<span class="p_add">+		 * state machine and make it go in PHY_FORCING state instead.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!status-&gt;link)</span>
<span class="p_add">+			netif_carrier_off(ds-&gt;ports[port]);</span>
 		status-&gt;duplex = 1;
 	} else {
 		status-&gt;link = 1;
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-desc.c b/drivers/net/ethernet/amd/xgbe/xgbe-desc.c</span>
<span class="p_header">index a50891f..b873734 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-desc.c</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> static int xgbe_alloc_pages(struct xgbe_prv_data *pdata,</span>
 	int ret;
 
 	/* Try to obtain pages, decreasing order if necessary */
<span class="p_del">-	gfp |= __GFP_COLD | __GFP_COMP;</span>
<span class="p_add">+	gfp |= __GFP_COLD | __GFP_COMP | __GFP_NOWARN;</span>
 	while (order &gt;= 0) {
 		pages = alloc_pages(gfp, order);
 		if (pages)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index ac6a0ef..39a1d3c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -9310,7 +9310,8 @@</span> <span class="p_context"> unload_error:</span>
 	 * function stop ramrod is sent, since as part of this ramrod FW access
 	 * PTP registers.
 	 */
<span class="p_del">-	bnx2x_stop_ptp(bp);</span>
<span class="p_add">+	if (bp-&gt;flags &amp; PTP_SUPPORTED)</span>
<span class="p_add">+		bnx2x_stop_ptp(bp);</span>
 
 	/* Disable HW interrupts, NAPI */
 	bnx2x_netif_stop(bp, 1);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/82571.c b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">index dc79ed8..32e7775 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_chunk">@@ -2010,7 +2010,7 @@</span> <span class="p_context"> const struct e1000_info e1000_82573_info = {</span>
 	.flags2			= FLAG2_DISABLE_ASPM_L1
 				  | FLAG2_DISABLE_ASPM_L0S,
 	.pba			= 20,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_82571,
 	.mac_ops		= &amp;e82571_mac_ops,
 	.phy_ops		= &amp;e82_phy_ops_m88,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/ich8lan.c b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">index 48b74a5..c067c84 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_chunk">@@ -1494,7 +1494,7 @@</span> <span class="p_context"> static s32 e1000_get_variants_ich8lan(struct e1000_adapter *adapter)</span>
 	    ((adapter-&gt;hw.mac.type &gt;= e1000_pch2lan) &amp;&amp;
 	     (!(er32(CTRL_EXT) &amp; E1000_CTRL_EXT_LSECCK)))) {
 		adapter-&gt;flags &amp;= ~FLAG_HAS_JUMBO_FRAMES;
<span class="p_del">-		adapter-&gt;max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;</span>
<span class="p_add">+		adapter-&gt;max_hw_frame_size = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 		hw-&gt;mac.ops.blink_led = NULL;
 	}
<span class="p_chunk">@@ -5067,7 +5067,7 @@</span> <span class="p_context"> const struct e1000_info e1000_ich8_info = {</span>
 				  | FLAG_HAS_FLASH
 				  | FLAG_APME_IN_WUC,
 	.pba			= 8,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5140,7 +5140,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch2_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5160,7 +5160,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch_lpt_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index e14fd85..b5d98be 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -3784,7 +3784,7 @@</span> <span class="p_context"> void e1000e_reset(struct e1000_adapter *adapter)</span>
 	/* reset Packet Buffer Allocation to default */
 	ew32(PBA, pba);
 
<span class="p_del">-	if (adapter-&gt;max_frame_size &gt; ETH_FRAME_LEN + ETH_FCS_LEN) {</span>
<span class="p_add">+	if (adapter-&gt;max_frame_size &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) {</span>
 		/* To maintain wire speed transmits, the Tx FIFO should be
 		 * large enough to accommodate two full transmit packets,
 		 * rounded up to the next 1KB and expressed in KB.  Likewise,
<span class="p_chunk">@@ -4172,9 +4172,9 @@</span> <span class="p_context"> static int e1000_sw_init(struct e1000_adapter *adapter)</span>
 {
 	struct net_device *netdev = adapter-&gt;netdev;
 
<span class="p_del">-	adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 	adapter-&gt;rx_ps_bsize0 = 128;
<span class="p_del">-	adapter-&gt;max_frame_size = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;max_frame_size = netdev-&gt;mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 	adapter-&gt;min_frame_size = ETH_ZLEN + ETH_FCS_LEN;
 	adapter-&gt;tx_ring_count = E1000_DEFAULT_TXD;
 	adapter-&gt;rx_ring_count = E1000_DEFAULT_RXD;
<span class="p_chunk">@@ -5749,17 +5749,17 @@</span> <span class="p_context"> struct rtnl_link_stats64 *e1000e_get_stats64(struct net_device *netdev,</span>
 static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
<span class="p_del">-	int max_frame = new_mtu + VLAN_HLEN + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	int max_frame = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 
 	/* Jumbo frame support */
<span class="p_del">-	if ((max_frame &gt; ETH_FRAME_LEN + ETH_FCS_LEN) &amp;&amp;</span>
<span class="p_add">+	if ((max_frame &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) &amp;&amp;</span>
 	    !(adapter-&gt;flags &amp; FLAG_HAS_JUMBO_FRAMES)) {
 		e_err(&quot;Jumbo Frames not supported.\n&quot;);
 		return -EINVAL;
 	}
 
 	/* Supported frame sizes */
<span class="p_del">-	if ((new_mtu &lt; ETH_ZLEN + ETH_FCS_LEN + VLAN_HLEN) ||</span>
<span class="p_add">+	if ((new_mtu &lt; (VLAN_ETH_ZLEN + ETH_FCS_LEN)) ||</span>
 	    (max_frame &gt; adapter-&gt;max_hw_frame_size)) {
 		e_err(&quot;Unsupported MTU setting\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -5799,10 +5799,8 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		adapter-&gt;rx_buffer_len = 4096;
 
 	/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */
<span class="p_del">-	if ((max_frame == ETH_FRAME_LEN + ETH_FCS_LEN) ||</span>
<span class="p_del">-	    (max_frame == ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN))</span>
<span class="p_del">-		adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN</span>
<span class="p_del">-		    + ETH_FCS_LEN;</span>
<span class="p_add">+	if (max_frame &lt;= (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))</span>
<span class="p_add">+		adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 	if (netif_running(netdev))
 		e1000e_up(adapter);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 96208f1..2562249 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -304,6 +304,7 @@</span> <span class="p_context"> struct mvneta_port {</span>
 	unsigned int link;
 	unsigned int duplex;
 	unsigned int speed;
<span class="p_add">+	unsigned int tx_csum_limit;</span>
 };
 
 /* The mvneta_tx_desc and mvneta_rx_desc structures describe the
<span class="p_chunk">@@ -2441,8 +2442,10 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 
 	dev-&gt;mtu = mtu;
 
<span class="p_del">-	if (!netif_running(dev))</span>
<span class="p_add">+	if (!netif_running(dev)) {</span>
<span class="p_add">+		netdev_update_features(dev);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/* The interface is running, so we have to force a
 	 * reallocation of the queues
<span class="p_chunk">@@ -2471,9 +2474,26 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 	mvneta_start_dev(pp);
 	mvneta_port_up(pp);
 
<span class="p_add">+	netdev_update_features(dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+static netdev_features_t mvneta_fix_features(struct net_device *dev,</span>
<span class="p_add">+					     netdev_features_t features)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mvneta_port *pp = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pp-&gt;tx_csum_limit &amp;&amp; dev-&gt;mtu &gt; pp-&gt;tx_csum_limit) {</span>
<span class="p_add">+		features &amp;= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);</span>
<span class="p_add">+		netdev_info(dev,</span>
<span class="p_add">+			    &quot;Disable IP checksum for MTU greater than %dB\n&quot;,</span>
<span class="p_add">+			    pp-&gt;tx_csum_limit);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return features;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Get mac address */
 static void mvneta_get_mac_addr(struct mvneta_port *pp, unsigned char *addr)
 {
<span class="p_chunk">@@ -2790,6 +2810,7 @@</span> <span class="p_context"> static const struct net_device_ops mvneta_netdev_ops = {</span>
 	.ndo_set_rx_mode     = mvneta_set_rx_mode,
 	.ndo_set_mac_address = mvneta_set_mac_addr,
 	.ndo_change_mtu      = mvneta_change_mtu,
<span class="p_add">+	.ndo_fix_features    = mvneta_fix_features,</span>
 	.ndo_get_stats64     = mvneta_get_stats64,
 	.ndo_do_ioctl        = mvneta_ioctl,
 };
<span class="p_chunk">@@ -3028,6 +3049,9 @@</span> <span class="p_context"> static int mvneta_probe(struct platform_device *pdev)</span>
 		}
 	}
 
<span class="p_add">+	if (of_device_is_compatible(dn, &quot;marvell,armada-370-neta&quot;))</span>
<span class="p_add">+		pp-&gt;tx_csum_limit = 1600;</span>
<span class="p_add">+</span>
 	pp-&gt;tx_ring_size = MVNETA_MAX_TXD;
 	pp-&gt;rx_ring_size = MVNETA_MAX_RXD;
 
<span class="p_chunk">@@ -3100,6 +3124,7 @@</span> <span class="p_context"> static int mvneta_remove(struct platform_device *pdev)</span>
 
 static const struct of_device_id mvneta_match[] = {
 	{ .compatible = &quot;marvell,armada-370-neta&quot; },
<span class="p_add">+	{ .compatible = &quot;marvell,armada-xp-neta&quot; },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(of, mvneta_match);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">index 9842bf9..782bd10 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_chunk">@@ -725,7 +725,7 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 {
 	struct ib_smp *smp = inbox-&gt;buf;
 	u32 index;
<span class="p_del">-	u8 port;</span>
<span class="p_add">+	u8 port, slave_port;</span>
 	u8 opcode_modifier;
 	u16 *table;
 	int err;
<span class="p_chunk">@@ -737,7 +737,8 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 	__be32 slave_cap_mask;
 	__be64 slave_node_guid;
 
<span class="p_del">-	port = vhcr-&gt;in_modifier;</span>
<span class="p_add">+	slave_port = vhcr-&gt;in_modifier;</span>
<span class="p_add">+	port = mlx4_slave_convert_port(dev, slave, slave_port);</span>
 
 	/* network-view bit is for driver use only, and should not be passed to FW */
 	opcode_modifier = vhcr-&gt;op_modifier &amp; ~0x8; /* clear netw view bit */
<span class="p_chunk">@@ -771,8 +772,9 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 			if (smp-&gt;attr_id == IB_SMP_ATTR_PORT_INFO) {
 				/*get the slave specific caps:*/
 				/*do the command */
<span class="p_add">+				smp-&gt;attr_mod = cpu_to_be32(port);</span>
 				err = mlx4_cmd_box(dev, inbox-&gt;dma, outbox-&gt;dma,
<span class="p_del">-					    vhcr-&gt;in_modifier, opcode_modifier,</span>
<span class="p_add">+					    port, opcode_modifier,</span>
 					    vhcr-&gt;op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);
 				/* modify the response for slaves */
 				if (!err &amp;&amp; slave != mlx4_master_func_num(dev)) {
<span class="p_chunk">@@ -803,7 +805,7 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 			}
 			if (smp-&gt;attr_id == IB_SMP_ATTR_NODE_INFO) {
 				err = mlx4_cmd_box(dev, inbox-&gt;dma, outbox-&gt;dma,
<span class="p_del">-					     vhcr-&gt;in_modifier, opcode_modifier,</span>
<span class="p_add">+					     port, opcode_modifier,</span>
 					     vhcr-&gt;op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);
 				if (!err) {
 					slave_node_guid =  mlx4_get_slave_node_guid(dev, slave);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index c998c4d..99b99eb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -1973,10 +1973,6 @@</span> <span class="p_context"> void mlx4_en_free_resources(struct mlx4_en_priv *priv)</span>
 			mlx4_en_destroy_cq(priv, &amp;priv-&gt;rx_cq[i]);
 	}
 
<span class="p_del">-	if (priv-&gt;base_tx_qpn) {</span>
<span class="p_del">-		mlx4_qp_release_range(priv-&gt;mdev-&gt;dev, priv-&gt;base_tx_qpn, priv-&gt;tx_ring_num);</span>
<span class="p_del">-		priv-&gt;base_tx_qpn = 0;</span>
<span class="p_del">-	}</span>
 }
 
 int mlx4_en_alloc_resources(struct mlx4_en_priv *priv)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index 10d3533..7f16627 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -719,7 +719,7 @@</span> <span class="p_context"> static int get_fixed_ipv6_csum(__wsum hw_checksum, struct sk_buff *skb,</span>
 }
 #endif
 static int check_csum(struct mlx4_cqe *cqe, struct sk_buff *skb, void *va,
<span class="p_del">-		      int hwtstamp_rx_filter)</span>
<span class="p_add">+		      netdev_features_t dev_features)</span>
 {
 	__wsum hw_checksum = 0;
 
<span class="p_chunk">@@ -727,14 +727,8 @@</span> <span class="p_context"> static int check_csum(struct mlx4_cqe *cqe, struct sk_buff *skb, void *va,</span>
 
 	hw_checksum = csum_unfold((__force __sum16)cqe-&gt;checksum);
 
<span class="p_del">-	if (((struct ethhdr *)va)-&gt;h_proto == htons(ETH_P_8021Q) &amp;&amp;</span>
<span class="p_del">-	    hwtstamp_rx_filter != HWTSTAMP_FILTER_NONE) {</span>
<span class="p_del">-		/* next protocol non IPv4 or IPv6 */</span>
<span class="p_del">-		if (((struct vlan_hdr *)hdr)-&gt;h_vlan_encapsulated_proto</span>
<span class="p_del">-		    != htons(ETH_P_IP) &amp;&amp;</span>
<span class="p_del">-		    ((struct vlan_hdr *)hdr)-&gt;h_vlan_encapsulated_proto</span>
<span class="p_del">-		    != htons(ETH_P_IPV6))</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+	if (cqe-&gt;vlan_my_qpn &amp; cpu_to_be32(MLX4_CQE_VLAN_PRESENT_MASK) &amp;&amp;</span>
<span class="p_add">+	    !(dev_features &amp; NETIF_F_HW_VLAN_CTAG_RX)) {</span>
 		hw_checksum = get_fixed_vlan_csum(hw_checksum, hdr);
 		hdr += sizeof(struct vlan_hdr);
 	}
<span class="p_chunk">@@ -897,7 +891,8 @@</span> <span class="p_context"> int mlx4_en_process_rx_cq(struct net_device *dev, struct mlx4_en_cq *cq, int bud</span>
 
 			if (ip_summed == CHECKSUM_COMPLETE) {
 				void *va = skb_frag_address(skb_shinfo(gro_skb)-&gt;frags);
<span class="p_del">-				if (check_csum(cqe, gro_skb, va, ring-&gt;hwtstamp_rx_filter)) {</span>
<span class="p_add">+				if (check_csum(cqe, gro_skb, va,</span>
<span class="p_add">+					       dev-&gt;features)) {</span>
 					ip_summed = CHECKSUM_NONE;
 					ring-&gt;csum_none++;
 					ring-&gt;csum_complete--;
<span class="p_chunk">@@ -952,7 +947,7 @@</span> <span class="p_context"> int mlx4_en_process_rx_cq(struct net_device *dev, struct mlx4_en_cq *cq, int bud</span>
 		}
 
 		if (ip_summed == CHECKSUM_COMPLETE) {
<span class="p_del">-			if (check_csum(cqe, skb, skb-&gt;data, ring-&gt;hwtstamp_rx_filter)) {</span>
<span class="p_add">+			if (check_csum(cqe, skb, skb-&gt;data, dev-&gt;features)) {</span>
 				ip_summed = CHECKSUM_NONE;
 				ring-&gt;csum_complete--;
 				ring-&gt;csum_none++;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index 18db895..b54e621 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,</span>
 	ring-&gt;size = size;
 	ring-&gt;size_mask = size - 1;
 	ring-&gt;stride = stride;
<span class="p_add">+	ring-&gt;full_size = ring-&gt;size - HEADROOM - MAX_DESC_TXBBS;</span>
 
 	tmp = size * sizeof(struct mlx4_en_tx_info);
 	ring-&gt;tx_info = kmalloc_node(tmp, GFP_KERNEL | __GFP_NOWARN, node);
<span class="p_chunk">@@ -180,6 +181,7 @@</span> <span class="p_context"> void mlx4_en_destroy_tx_ring(struct mlx4_en_priv *priv,</span>
 		mlx4_bf_free(mdev-&gt;dev, &amp;ring-&gt;bf);
 	mlx4_qp_remove(mdev-&gt;dev, &amp;ring-&gt;qp);
 	mlx4_qp_free(mdev-&gt;dev, &amp;ring-&gt;qp);
<span class="p_add">+	mlx4_qp_release_range(priv-&gt;mdev-&gt;dev, ring-&gt;qpn, 1);</span>
 	mlx4_en_unmap_buffer(&amp;ring-&gt;wqres.buf);
 	mlx4_free_hwq_res(mdev-&gt;dev, &amp;ring-&gt;wqres, ring-&gt;buf_size);
 	kfree(ring-&gt;bounce_buf);
<span class="p_chunk">@@ -231,6 +233,11 @@</span> <span class="p_context"> void mlx4_en_deactivate_tx_ring(struct mlx4_en_priv *priv,</span>
 		       MLX4_QP_STATE_RST, NULL, 0, 0, &amp;ring-&gt;qp);
 }
 
<span class="p_add">+static inline bool mlx4_en_is_tx_ring_full(struct mlx4_en_tx_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ring-&gt;prod - ring-&gt;cons &gt; ring-&gt;full_size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mlx4_en_stamp_wqe(struct mlx4_en_priv *priv,
 			      struct mlx4_en_tx_ring *ring, int index,
 			      u8 owner)
<span class="p_chunk">@@ -473,11 +480,10 @@</span> <span class="p_context"> static bool mlx4_en_process_tx_cq(struct net_device *dev,</span>
 
 	netdev_tx_completed_queue(ring-&gt;tx_queue, packets, bytes);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Wakeup Tx queue if this stopped, and at least 1 packet</span>
<span class="p_del">-	 * was completed</span>
<span class="p_add">+	/* Wakeup Tx queue if this stopped, and ring is not full.</span>
 	 */
<span class="p_del">-	if (netif_tx_queue_stopped(ring-&gt;tx_queue) &amp;&amp; txbbs_skipped &gt; 0) {</span>
<span class="p_add">+	if (netif_tx_queue_stopped(ring-&gt;tx_queue) &amp;&amp;</span>
<span class="p_add">+	    !mlx4_en_is_tx_ring_full(ring)) {</span>
 		netif_tx_wake_queue(ring-&gt;tx_queue);
 		ring-&gt;wake_queue++;
 	}
<span class="p_chunk">@@ -921,8 +927,7 @@</span> <span class="p_context"> netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	skb_tx_timestamp(skb);
 
 	/* Check available TXBBs And 2K spare for prefetch */
<span class="p_del">-	stop_queue = (int)(ring-&gt;prod - ring_cons) &gt;</span>
<span class="p_del">-		      ring-&gt;size - HEADROOM - MAX_DESC_TXBBS;</span>
<span class="p_add">+	stop_queue = mlx4_en_is_tx_ring_full(ring);</span>
 	if (unlikely(stop_queue)) {
 		netif_tx_stop_queue(ring-&gt;tx_queue);
 		ring-&gt;queue_stopped++;
<span class="p_chunk">@@ -991,8 +996,7 @@</span> <span class="p_context"> netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		smp_rmb();
 
 		ring_cons = ACCESS_ONCE(ring-&gt;cons);
<span class="p_del">-		if (unlikely(((int)(ring-&gt;prod - ring_cons)) &lt;=</span>
<span class="p_del">-			     ring-&gt;size - HEADROOM - MAX_DESC_TXBBS)) {</span>
<span class="p_add">+		if (unlikely(!mlx4_en_is_tx_ring_full(ring))) {</span>
 			netif_tx_wake_queue(ring-&gt;tx_queue);
 			ring-&gt;wake_queue++;
 		}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">index 6cc49c1..18f8578 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_chunk">@@ -280,6 +280,7 @@</span> <span class="p_context"> struct mlx4_en_tx_ring {</span>
 	u32			size; /* number of TXBBs */
 	u32			size_mask;
 	u16			stride;
<span class="p_add">+	u32			full_size;</span>
 	u16			cqn;	/* index of port CQ associated with this ring */
 	u32			buf_size;
 	__be32			doorbell_qpn;
<span class="p_chunk">@@ -599,7 +600,6 @@</span> <span class="p_context"> struct mlx4_en_priv {</span>
 	int vids[128];
 	bool wol;
 	struct device *ddev;
<span class="p_del">-	int base_tx_qpn;</span>
 	struct hlist_head mac_hash[MLX4_EN_MAC_HASH_SIZE];
 	struct hwtstamp_config hwtstamp_config;
 
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">index ad39960..799c292 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_chunk">@@ -158,6 +158,8 @@</span> <span class="p_context"> struct dma_desc {</span>
 			u32 buffer2_size:13;
 			u32 reserved4:3;
 		} etx;		/* -- enhanced -- */
<span class="p_add">+</span>
<span class="p_add">+		u64 all_flags;</span>
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">index 1e2bcf5..7d94444 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_chunk">@@ -240,6 +240,7 @@</span> <span class="p_context"> static int enh_desc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
 				  int mode, int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.erx.own = 1;
 	p-&gt;des01.erx.buffer1_size = BUF_SIZE_8KiB - 1;
 
<span class="p_chunk">@@ -254,7 +255,7 @@</span> <span class="p_context"> static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,</span>
 
 static void enh_desc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.etx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ehn_desc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">index 35ad4f4..48c3456 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static int ndesc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
 			       int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.rx.own = 1;
 	p-&gt;des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
 
<span class="p_chunk">@@ -137,7 +138,7 @@</span> <span class="p_context"> static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,</span>
 
 static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.tx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ndesc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index cf62ff4..8834b82 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -1188,41 +1188,41 @@</span> <span class="p_context"> static int alloc_dma_desc_resources(struct stmmac_priv *priv)</span>
 		goto err_tx_skbuff;
 
 	if (priv-&gt;extend_desc) {
<span class="p_del">-		priv-&gt;dma_erx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_erx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_erx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_etx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_etx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_etx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_extended_desc),</span>
<span class="p_del">-					priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_extended_desc),</span>
<span class="p_add">+					  priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	} else {
<span class="p_del">-		priv-&gt;dma_rx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_rx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_rx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_tx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_tx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_tx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_desc),</span>
<span class="p_del">-					priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_desc),</span>
<span class="p_add">+					  priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	}
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 3fc91e8..70a0d88 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -782,10 +782,11 @@</span> <span class="p_context"> static int genphy_config_advert(struct phy_device *phydev)</span>
 	if (phydev-&gt;supported &amp; (SUPPORTED_1000baseT_Half |
 				 SUPPORTED_1000baseT_Full)) {
 		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
<span class="p_del">-		if (adv != oldadv)</span>
<span class="p_del">-			changed = 1;</span>
 	}
 
<span class="p_add">+	if (adv != oldadv)</span>
<span class="p_add">+		changed = 1;</span>
<span class="p_add">+</span>
 	err = phy_write(phydev, MII_CTRL1000, adv);
 	if (err &lt; 0)
 		return err;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index c400567..05597cb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -2367,6 +2367,7 @@</span> <span class="p_context"> static void ath10k_tx(struct ieee80211_hw *hw,</span>
 		ath10k_dbg(ar, ATH10K_DBG_MAC, &quot;IEEE80211_TX_CTL_NO_CCK_RATE\n&quot;);
 
 	ATH10K_SKB_CB(skb)-&gt;htt.is_offchan = false;
<span class="p_add">+	ATH10K_SKB_CB(skb)-&gt;htt.freq = 0;</span>
 	ATH10K_SKB_CB(skb)-&gt;htt.tid = ath10k_tx_h_get_tid(hdr);
 	ATH10K_SKB_CB(skb)-&gt;vdev_id = ath10k_tx_h_get_vdev_id(ar, vif);
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/trace.h b/drivers/net/wireless/ath/ath10k/trace.h</span>
<span class="p_header">index b289378..fa4bb625 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/trace.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/trace.h</span>
<span class="p_chunk">@@ -21,11 +21,16 @@</span> <span class="p_context"></span>
 #include &quot;core.h&quot;
 
 #if !defined(_TRACE_H_)
<span class="p_del">-static inline u32 ath10k_frm_hdr_len(const void *buf)</span>
<span class="p_add">+static inline u32 ath10k_frm_hdr_len(const void *buf, size_t len)</span>
 {
 	const struct ieee80211_hdr *hdr = buf;
 
<span class="p_del">-	return ieee80211_hdrlen(hdr-&gt;frame_control);</span>
<span class="p_add">+	/* In some rare cases (e.g. fcs error) device reports frame buffer</span>
<span class="p_add">+	 * shorter than what frame header implies (e.g. len = 0). The buffer</span>
<span class="p_add">+	 * can still be accessed so do a simple min() to guarantee caller</span>
<span class="p_add">+	 * doesn&#39;t get value greater than len.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return min_t(u32, len, ieee80211_hdrlen(hdr-&gt;frame_control));</span>
 }
 #endif
 
<span class="p_chunk">@@ -46,7 +51,7 @@</span> <span class="p_context"> static inline void trace_ ## name(proto) {}</span>
 #undef TRACE_SYSTEM
 #define TRACE_SYSTEM ath10k
 
<span class="p_del">-#define ATH10K_MSG_MAX 200</span>
<span class="p_add">+#define ATH10K_MSG_MAX 400</span>
 
 DECLARE_EVENT_CLASS(ath10k_log_event,
 	TP_PROTO(struct ath10k *ar, struct va_format *vaf),
<span class="p_chunk">@@ -360,13 +365,13 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(ath10k_hdr_event,</span>
 		__string(device, dev_name(ar-&gt;dev))
 		__string(driver, dev_driver_string(ar-&gt;dev))
 		__field(size_t, len)
<span class="p_del">-		__dynamic_array(u8, data, ath10k_frm_hdr_len(data))</span>
<span class="p_add">+		__dynamic_array(u8, data, ath10k_frm_hdr_len(data, len))</span>
 	),
 
 	TP_fast_assign(
 		__assign_str(device, dev_name(ar-&gt;dev));
 		__assign_str(driver, dev_driver_string(ar-&gt;dev));
<span class="p_del">-		__entry-&gt;len = ath10k_frm_hdr_len(data);</span>
<span class="p_add">+		__entry-&gt;len = ath10k_frm_hdr_len(data, len);</span>
 		memcpy(__get_dynamic_array(data), data, __entry-&gt;len);
 	),
 
<span class="p_chunk">@@ -387,15 +392,16 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(ath10k_payload_event,</span>
 		__string(device, dev_name(ar-&gt;dev))
 		__string(driver, dev_driver_string(ar-&gt;dev))
 		__field(size_t, len)
<span class="p_del">-		__dynamic_array(u8, payload, (len - ath10k_frm_hdr_len(data)))</span>
<span class="p_add">+		__dynamic_array(u8, payload, (len -</span>
<span class="p_add">+					      ath10k_frm_hdr_len(data, len)))</span>
 	),
 
 	TP_fast_assign(
 		__assign_str(device, dev_name(ar-&gt;dev));
 		__assign_str(driver, dev_driver_string(ar-&gt;dev));
<span class="p_del">-		__entry-&gt;len = len - ath10k_frm_hdr_len(data);</span>
<span class="p_add">+		__entry-&gt;len = len - ath10k_frm_hdr_len(data, len);</span>
 		memcpy(__get_dynamic_array(payload),
<span class="p_del">-		       data + ath10k_frm_hdr_len(data), __entry-&gt;len);</span>
<span class="p_add">+		       data + ath10k_frm_hdr_len(data, len), __entry-&gt;len);</span>
 	),
 
 	TP_printk(
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/htc.h b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">index 9dde265..7493e3d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_chunk">@@ -437,9 +437,9 @@</span> <span class="p_context"> static inline void ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)</span>
 }
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
<span class="p_del">-#define OP_BT_PRIORITY_DETECTED    BIT(3)</span>
<span class="p_del">-#define OP_BT_SCAN                 BIT(4)</span>
<span class="p_del">-#define OP_TSF_RESET               BIT(6)</span>
<span class="p_add">+#define OP_BT_PRIORITY_DETECTED    3</span>
<span class="p_add">+#define OP_BT_SCAN                 4</span>
<span class="p_add">+#define OP_TSF_RESET               6</span>
 
 struct ath9k_htc_priv {
 	struct device *dev;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index 62b0bf4..cea94dbf 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -216,11 +216,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 	ath_stop_ani(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c</span>
<span class="p_header">index 2fa0dbb..7ada9b9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43/main.c</span>
<span class="p_chunk">@@ -5317,6 +5317,10 @@</span> <span class="p_context"> static void b43_supported_bands(struct b43_wldev *dev, bool *have_2ghz_phy,</span>
 		*have_5ghz_phy = true;
 		return;
 	case 0x4321: /* BCM4306 */
<span class="p_add">+		/* There are 14e4:4321 PCI devs with 2.4 GHz BCM4321 (N-PHY) */</span>
<span class="p_add">+		if (dev-&gt;phy.type != B43_PHYTYPE_G)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* fall through */</span>
 	case 0x4313: /* BCM4311 */
 	case 0x431a: /* BCM4318 */
 	case 0x432a: /* BCM4321 */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/debugfs.c b/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_header">index 33bf915..40468d1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"></span>
  * GPL LICENSE SUMMARY
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
  * BSD LICENSE
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -1323,6 +1323,7 @@</span> <span class="p_context"> static ssize_t iwl_dbgfs_d0i3_refs_read(struct file *file,</span>
 	PRINT_MVM_REF(IWL_MVM_REF_UCODE_DOWN);
 	PRINT_MVM_REF(IWL_MVM_REF_SCAN);
 	PRINT_MVM_REF(IWL_MVM_REF_ROC);
<span class="p_add">+	PRINT_MVM_REF(IWL_MVM_REF_ROC_AUX);</span>
 	PRINT_MVM_REF(IWL_MVM_REF_P2P_CLIENT);
 	PRINT_MVM_REF(IWL_MVM_REF_AP_IBSS);
 	PRINT_MVM_REF(IWL_MVM_REF_USER);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index a704be0..7b0d757 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1015,7 +1015,7 @@</span> <span class="p_context"> void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)</span>
 	 * The work item could be running or queued if the
 	 * ROC time event stops just as we get here.
 	 */
<span class="p_del">-	cancel_work_sync(&amp;mvm-&gt;roc_done_wk);</span>
<span class="p_add">+	flush_work(&amp;mvm-&gt;roc_done_wk);</span>
 
 	iwl_trans_stop_device(mvm-&gt;trans);
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index d24660f..a5db114 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -259,6 +259,7 @@</span> <span class="p_context"> enum iwl_mvm_ref_type {</span>
 	IWL_MVM_REF_UCODE_DOWN,
 	IWL_MVM_REF_SCAN,
 	IWL_MVM_REF_ROC,
<span class="p_add">+	IWL_MVM_REF_ROC_AUX,</span>
 	IWL_MVM_REF_P2P_CLIENT,
 	IWL_MVM_REF_AP_IBSS,
 	IWL_MVM_REF_USER,
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/time-event.c b/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_header">index f8d6f30..761d9d3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"></span>
  * GPL LICENSE SUMMARY
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
  * BSD LICENSE
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -108,12 +108,14 @@</span> <span class="p_context"> void iwl_mvm_roc_done_wk(struct work_struct *wk)</span>
 	 * in the case that the time event actually completed in the firmware
 	 * (which is handled in iwl_mvm_te_handle_notif).
 	 */
<span class="p_del">-	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &amp;mvm-&gt;status))</span>
<span class="p_add">+	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &amp;mvm-&gt;status)) {</span>
 		queues |= BIT(IWL_MVM_OFFCHANNEL_QUEUE);
<span class="p_del">-	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status))</span>
<span class="p_add">+		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status)) {</span>
 		queues |= BIT(mvm-&gt;aux_queue);
<span class="p_del">-</span>
<span class="p_del">-	iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);</span>
<span class="p_add">+		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC_AUX);</span>
<span class="p_add">+	}</span>
 
 	synchronize_net();
 
<span class="p_chunk">@@ -332,6 +334,7 @@</span> <span class="p_context"> static int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,</span>
 	} else if (le32_to_cpu(notif-&gt;action) == TE_V2_NOTIF_HOST_EVENT_START) {
 		set_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status);
 		te_data-&gt;running = true;
<span class="p_add">+		iwl_mvm_ref(mvm, IWL_MVM_REF_ROC_AUX);</span>
 		ieee80211_ready_on_channel(mvm-&gt;hw); /* Start TE */
 	} else {
 		IWL_DEBUG_TE(mvm,
<span class="p_header">diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">index 1a4facd..363cab1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_chunk">@@ -356,9 +356,9 @@</span> <span class="p_context"> struct ndis_80211_pmkid {</span>
 #define CAP_MODE_80211G		4
 #define CAP_MODE_MASK		7
 
<span class="p_del">-#define WORK_LINK_UP		(1&lt;&lt;0)</span>
<span class="p_del">-#define WORK_LINK_DOWN		(1&lt;&lt;1)</span>
<span class="p_del">-#define WORK_SET_MULTICAST_LIST	(1&lt;&lt;2)</span>
<span class="p_add">+#define WORK_LINK_UP		0</span>
<span class="p_add">+#define WORK_LINK_DOWN		1</span>
<span class="p_add">+#define WORK_SET_MULTICAST_LIST	2</span>
 
 #define RNDIS_WLAN_ALG_NONE	0
 #define RNDIS_WLAN_ALG_WEP	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c b/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_header">index f2b9713..425ccb3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_chunk">@@ -1353,27 +1353,11 @@</span> <span class="p_context"> void rtl88ee_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl88ee_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl88ee_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl88ee_clear_interrupt(hw);/*clear it here first*/</span>
 	rtl_write_dword(rtlpriv, REG_HIMR,
 			rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c b/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">index b461b31..9362454 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_chunk">@@ -1584,28 +1584,11 @@</span> <span class="p_context"> void rtl92ee_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl92ee_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl92ee_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl92ee_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_header">index aa08546..5e13340 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_chunk">@@ -1258,18 +1258,6 @@</span> <span class="p_context"> void rtl8723e_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8723e_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8723e_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
<span class="p_chunk">@@ -1284,7 +1272,6 @@</span> <span class="p_context"> void rtl8723e_disable_interrupt(struct ieee80211_hw *hw)</span>
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
<span class="p_del">-	rtl8723e_clear_interrupt(hw);/*clear it here first*/</span>
 	rtl_write_dword(rtlpriv, 0x3a8, IMR8190_DISABLED);
 	rtl_write_dword(rtlpriv, 0x3ac, IMR8190_DISABLED);
 	rtlpci-&gt;irq_enabled = false;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">index 6dad28e..cfe6799 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_chunk">@@ -1634,28 +1634,11 @@</span> <span class="p_context"> void rtl8723be_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8723be_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8723be_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl8723be_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 8ec8200..43c14d4 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2253,31 +2253,11 @@</span> <span class="p_context"> void rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	/*printk(&quot;clear interrupt first:\n&quot;);</span>
<span class="p_del">-	printk(&quot;0x%x = 0x%08x\n&quot;,REG_HISR, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	/*printk(&quot;0x%x = 0x%08x\n&quot;,REG_HISRE, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	/*printk(&quot;0x%x = 0x%08x\n&quot;,REG_HSISR, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl8821ae_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/nfc/st21nfcb/i2c.c b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">index b5eb375..45b1f39 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_chunk">@@ -87,11 +87,6 @@</span> <span class="p_context"> static void st21nfcb_nci_i2c_disable(void *phy_id)</span>
 	gpio_set_value(phy-&gt;gpio_reset, 1);
 }
 
<span class="p_del">-static void st21nfcb_nci_remove_header(struct sk_buff *skb)</span>
<span class="p_del">-{</span>
<span class="p_del">-	skb_pull(skb, ST21NFCB_FRAME_HEADROOM);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Writing a frame must not return the number of written bytes.
  * It must return either zero for success, or &lt;0 for error.
<span class="p_chunk">@@ -121,8 +116,6 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_write(void *phy_id, struct sk_buff *skb)</span>
 			r = 0;
 	}
 
<span class="p_del">-	st21nfcb_nci_remove_header(skb);</span>
<span class="p_del">-</span>
 	return r;
 }
 
<span class="p_chunk">@@ -365,9 +358,6 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_remove(struct i2c_client *client)</span>
 
 	ndlc_remove(phy-&gt;ndlc);
 
<span class="p_del">-	if (phy-&gt;powered)</span>
<span class="p_del">-		st21nfcb_nci_i2c_disable(phy);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/nfc/st21nfcb/st21nfcb.c b/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_header">index ea63d58..28b3914 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_chunk">@@ -122,11 +122,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(st21nfcb_nci_probe);</span>
 
 void st21nfcb_nci_remove(struct nci_dev *ndev)
 {
<span class="p_del">-	struct st21nfcb_nci_info *info = nci_get_drvdata(ndev);</span>
<span class="p_del">-</span>
 	nci_unregister_device(ndev);
 	nci_free_device(ndev);
<span class="p_del">-	kfree(info);</span>
 }
 EXPORT_SYMBOL_GPL(st21nfcb_nci_remove);
 
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 78a7dcb..8bfda6a 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -712,7 +712,7 @@</span> <span class="p_context"> int __weak pci_register_io_range(phys_addr_t addr, resource_size_t size)</span>
 	}
 
 	/* add the range to the list */
<span class="p_del">-	range = kzalloc(sizeof(*range), GFP_KERNEL);</span>
<span class="p_add">+	range = kzalloc(sizeof(*range), GFP_ATOMIC);</span>
 	if (!range) {
 		err = -ENOMEM;
 		goto end_register;
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> unsigned long __weak pci_address_to_pio(phys_addr_t address)</span>
 	spin_lock(&amp;io_range_lock);
 	list_for_each_entry(res, &amp;io_range_list, list) {
 		if (address &gt;= res-&gt;start &amp;&amp; address &lt; res-&gt;start + res-&gt;size) {
<span class="p_del">-			addr = res-&gt;start - address + offset;</span>
<span class="p_add">+			addr = address - res-&gt;start + offset;</span>
 			break;
 		}
 		offset += res-&gt;size;
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 65a47f4..250a6a1 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(of_n_size_cells);</span>
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
<span class="p_del">-	return numa_node_id();</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig</span>
<span class="p_header">index 7a8f1c5..73de4ef 100644</span>
<span class="p_header">--- a/drivers/pci/Kconfig</span>
<span class="p_header">+++ b/drivers/pci/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,10 @@</span> <span class="p_context"></span>
 #
 # PCI configuration
 #
<span class="p_add">+config PCI_BUS_ADDR_T_64BIT</span>
<span class="p_add">+	def_bool y if (ARCH_DMA_ADDR_T_64BIT || 64BIT)</span>
<span class="p_add">+	depends on PCI</span>
<span class="p_add">+</span>
 config PCI_MSI
 	bool &quot;Message Signaled Interrupts (MSI and MSI-X)&quot;
 	depends on PCI
<span class="p_header">diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c</span>
<span class="p_header">index 8fb1618..f4367a7 100644</span>
<span class="p_header">--- a/drivers/pci/bus.c</span>
<span class="p_header">+++ b/drivers/pci/bus.c</span>
<span class="p_chunk">@@ -98,11 +98,11 @@</span> <span class="p_context"> void pci_bus_remove_resources(struct pci_bus *bus)</span>
 }
 
 static struct pci_bus_region pci_32_bit = {0, 0xffffffffULL};
<span class="p_del">-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT</span>
<span class="p_add">+#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT</span>
 static struct pci_bus_region pci_64_bit = {0,
<span class="p_del">-				(dma_addr_t) 0xffffffffffffffffULL};</span>
<span class="p_del">-static struct pci_bus_region pci_high = {(dma_addr_t) 0x100000000ULL,</span>
<span class="p_del">-				(dma_addr_t) 0xffffffffffffffffULL};</span>
<span class="p_add">+				(pci_bus_addr_t) 0xffffffffffffffffULL};</span>
<span class="p_add">+static struct pci_bus_region pci_high = {(pci_bus_addr_t) 0x100000000ULL,</span>
<span class="p_add">+				(pci_bus_addr_t) 0xffffffffffffffffULL};</span>
 #endif
 
 /*
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> int pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,</span>
 					  resource_size_t),
 		void *alignf_data)
 {
<span class="p_del">-#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT</span>
<span class="p_add">+#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT</span>
 	int rc;
 
 	if (res-&gt;flags &amp; IORESOURCE_MEM_64) {
<span class="p_header">diff --git a/drivers/pci/hotplug/pciehp_hpc.c b/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_header">index 0ebf754..6d68688 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/pciehp_hpc.c</span>
<span class="p_chunk">@@ -176,20 +176,17 @@</span> <span class="p_context"> static void pcie_wait_cmd(struct controller *ctrl)</span>
 			  jiffies_to_msecs(jiffies - ctrl-&gt;cmd_started));
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * pcie_write_cmd - Issue controller command</span>
<span class="p_del">- * @ctrl: controller to which the command is issued</span>
<span class="p_del">- * @cmd:  command value written to slot control register</span>
<span class="p_del">- * @mask: bitmask of slot control register to be modified</span>
<span class="p_del">- */</span>
<span class="p_del">-static void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)</span>
<span class="p_add">+static void pcie_do_write_cmd(struct controller *ctrl, u16 cmd,</span>
<span class="p_add">+			      u16 mask, bool wait)</span>
 {
 	struct pci_dev *pdev = ctrl_dev(ctrl);
 	u16 slot_ctrl;
 
 	mutex_lock(&amp;ctrl-&gt;ctrl_lock);
 
<span class="p_del">-	/* Wait for any previous command that might still be in progress */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Always wait for any previous command that might still be in progress</span>
<span class="p_add">+	 */</span>
 	pcie_wait_cmd(ctrl);
 
 	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &amp;slot_ctrl);
<span class="p_chunk">@@ -201,9 +198,33 @@</span> <span class="p_context"> static void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)</span>
 	ctrl-&gt;cmd_started = jiffies;
 	ctrl-&gt;slot_ctrl = slot_ctrl;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Optionally wait for the hardware to be ready for a new command,</span>
<span class="p_add">+	 * indicating completion of the above issued command.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (wait)</span>
<span class="p_add">+		pcie_wait_cmd(ctrl);</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;ctrl-&gt;ctrl_lock);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * pcie_write_cmd - Issue controller command</span>
<span class="p_add">+ * @ctrl: controller to which the command is issued</span>
<span class="p_add">+ * @cmd:  command value written to slot control register</span>
<span class="p_add">+ * @mask: bitmask of slot control register to be modified</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pcie_do_write_cmd(ctrl, cmd, mask, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Same as above without waiting for the hardware to latch */</span>
<span class="p_add">+static void pcie_write_cmd_nowait(struct controller *ctrl, u16 cmd, u16 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pcie_do_write_cmd(ctrl, cmd, mask, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 bool pciehp_check_link_active(struct controller *ctrl)
 {
 	struct pci_dev *pdev = ctrl_dev(ctrl);
<span class="p_chunk">@@ -422,7 +443,7 @@</span> <span class="p_context"> void pciehp_set_attention_status(struct slot *slot, u8 value)</span>
 	default:
 		return;
 	}
<span class="p_del">-	pcie_write_cmd(ctrl, slot_cmd, PCI_EXP_SLTCTL_AIC);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, slot_cmd, PCI_EXP_SLTCTL_AIC);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL, slot_cmd);
 }
<span class="p_chunk">@@ -434,7 +455,8 @@</span> <span class="p_context"> void pciehp_green_led_on(struct slot *slot)</span>
 	if (!PWR_LED(ctrl))
 		return;
 
<span class="p_del">-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON, PCI_EXP_SLTCTL_PIC);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON,</span>
<span class="p_add">+			      PCI_EXP_SLTCTL_PIC);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL,
 		 PCI_EXP_SLTCTL_PWR_IND_ON);
<span class="p_chunk">@@ -447,7 +469,8 @@</span> <span class="p_context"> void pciehp_green_led_off(struct slot *slot)</span>
 	if (!PWR_LED(ctrl))
 		return;
 
<span class="p_del">-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF, PCI_EXP_SLTCTL_PIC);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,</span>
<span class="p_add">+			      PCI_EXP_SLTCTL_PIC);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL,
 		 PCI_EXP_SLTCTL_PWR_IND_OFF);
<span class="p_chunk">@@ -460,7 +483,8 @@</span> <span class="p_context"> void pciehp_green_led_blink(struct slot *slot)</span>
 	if (!PWR_LED(ctrl))
 		return;
 
<span class="p_del">-	pcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK, PCI_EXP_SLTCTL_PIC);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK,</span>
<span class="p_add">+			      PCI_EXP_SLTCTL_PIC);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL,
 		 PCI_EXP_SLTCTL_PWR_IND_BLINK);
<span class="p_chunk">@@ -613,7 +637,7 @@</span> <span class="p_context"> void pcie_enable_notification(struct controller *ctrl)</span>
 		PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |
 		PCI_EXP_SLTCTL_DLLSCE);
 
<span class="p_del">-	pcie_write_cmd(ctrl, cmd, mask);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, cmd, mask);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL, cmd);
 }
<span class="p_chunk">@@ -664,7 +688,7 @@</span> <span class="p_context"> int pciehp_reset_slot(struct slot *slot, int probe)</span>
 	pci_reset_bridge_secondary_bus(ctrl-&gt;pcie-&gt;port);
 
 	pcie_capability_write_word(pdev, PCI_EXP_SLTSTA, stat_mask);
<span class="p_del">-	pcie_write_cmd(ctrl, ctrl_mask, ctrl_mask);</span>
<span class="p_add">+	pcie_write_cmd_nowait(ctrl, ctrl_mask, ctrl_mask);</span>
 	ctrl_dbg(ctrl, &quot;%s: SLOTCTRL %x write cmd %x\n&quot;, __func__,
 		 pci_pcie_cap(ctrl-&gt;pcie-&gt;port) + PCI_EXP_SLTCTL, ctrl_mask);
 	if (pciehp_poll_mode)
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index e9d4fd8..b8d2084 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -4291,6 +4291,17 @@</span> <span class="p_context"> bool pci_device_is_present(struct pci_dev *pdev)</span>
 }
 EXPORT_SYMBOL_GPL(pci_device_is_present);
 
<span class="p_add">+void pci_ignore_hotplug(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *bridge = dev-&gt;bus-&gt;self;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;ignore_hotplug = 1;</span>
<span class="p_add">+	/* Propagate the &quot;ignore hotplug&quot; setting to the parent bridge. */</span>
<span class="p_add">+	if (bridge)</span>
<span class="p_add">+		bridge-&gt;ignore_hotplug = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(pci_ignore_hotplug);</span>
<span class="p_add">+</span>
 #define RESOURCE_ALIGNMENT_PARAM_SIZE COMMAND_LINE_SIZE
 static char resource_alignment_param[RESOURCE_ALIGNMENT_PARAM_SIZE] = {0};
 static DEFINE_SPINLOCK(resource_alignment_lock);
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index 23212f8..b7167ad 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -253,8 +253,8 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 	}
 
 	if (res-&gt;flags &amp; IORESOURCE_MEM_64) {
<span class="p_del">-		if ((sizeof(dma_addr_t) &lt; 8 || sizeof(resource_size_t) &lt; 8) &amp;&amp;</span>
<span class="p_del">-		    sz64 &gt; 0x100000000ULL) {</span>
<span class="p_add">+		if ((sizeof(pci_bus_addr_t) &lt; 8 || sizeof(resource_size_t) &lt; 8)</span>
<span class="p_add">+		    &amp;&amp; sz64 &gt; 0x100000000ULL) {</span>
 			res-&gt;flags |= IORESOURCE_UNSET | IORESOURCE_DISABLED;
 			res-&gt;start = 0;
 			res-&gt;end = 0;
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 			goto out;
 		}
 
<span class="p_del">-		if ((sizeof(dma_addr_t) &lt; 8) &amp;&amp; l) {</span>
<span class="p_add">+		if ((sizeof(pci_bus_addr_t) &lt; 8) &amp;&amp; l) {</span>
 			/* Above 32-bit boundary; try to reallocate */
 			res-&gt;flags |= IORESOURCE_UNSET;
 			res-&gt;start = 0;
<span class="p_chunk">@@ -398,7 +398,7 @@</span> <span class="p_context"> static void pci_read_bridge_mmio_pref(struct pci_bus *child)</span>
 	struct pci_dev *dev = child-&gt;self;
 	u16 mem_base_lo, mem_limit_lo;
 	u64 base64, limit64;
<span class="p_del">-	dma_addr_t base, limit;</span>
<span class="p_add">+	pci_bus_addr_t base, limit;</span>
 	struct pci_bus_region region;
 	struct resource *res;
 
<span class="p_chunk">@@ -425,8 +425,8 @@</span> <span class="p_context"> static void pci_read_bridge_mmio_pref(struct pci_bus *child)</span>
 		}
 	}
 
<span class="p_del">-	base = (dma_addr_t) base64;</span>
<span class="p_del">-	limit = (dma_addr_t) limit64;</span>
<span class="p_add">+	base = (pci_bus_addr_t) base64;</span>
<span class="p_add">+	limit = (pci_bus_addr_t) limit64;</span>
 
 	if (base != base64) {
 		dev_err(&amp;dev-&gt;dev, &quot;can&#39;t handle bridge window above 4GB (bus address %#010llx)\n&quot;,
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a..582688fe 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/phy/phy-twl4030-usb.c b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">index 8e87f54..37eb93c 100644</span>
<span class="p_header">--- a/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_chunk">@@ -712,7 +712,6 @@</span> <span class="p_context"> static int twl4030_usb_probe(struct platform_device *pdev)</span>
 	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
 	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 2000);
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
 
 	/* Our job is to use irqs and status from the power module
 	 * to keep the transceiver disabled when nothing&#39;s connected.
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index c4f51d0..a974598 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -370,11 +370,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-375.c b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">index cd7c8f5..4e0f6e8 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_chunk">@@ -92,19 +92,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6720_mpp_modes[] = {</span>
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;io1&quot;)),
 	MPP_MODE(8,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;dev &quot;, &quot;bootcs&quot;),</span>
<span class="p_add">+		 MPP_FUNCTION(0x1, &quot;dev&quot;, &quot;bootcs&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;ce&quot;)),
 	MPP_MODE(9,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;wen&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;we&quot;)),
 	MPP_MODE(10,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;ren&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;dram&quot;, &quot;vttctrl&quot;),
 		 MPP_FUNCTION(0x3, &quot;led&quot;, &quot;c1&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;re&quot;),
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">index 224c6cf..d6ae915 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_chunk">@@ -94,37 +94,39 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd0&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs1&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(13,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd1&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie2&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(14,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd2&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs3&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(15,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd3&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdc slave&quot;,  V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS)),</span>
 	MPP_MODE(16,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxctl&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdio slave&quot;, V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;miso&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(17,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxclk&quot;,      V_88F6810_PLUS),
<span class="p_chunk">@@ -137,20 +139,18 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxerr&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;trig_gen&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;ua1&quot;,   &quot;txd&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS)),</span>
 	MPP_MODE(19,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;col&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;event_req&quot;,  V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(3, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;cts&quot;,        V_88F6810_PLUS)),
 	MPP_MODE(20,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;txclk&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;rts&quot;,        V_88F6810_PLUS)),
 	MPP_MODE(21,
<span class="p_chunk">@@ -275,35 +275,27 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;clkout&quot;,     V_88F6810_PLUS)),
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),</span>
 	MPP_MODE(45,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out0&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(46,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out1&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(47,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -311,18 +303,19 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;pclk&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;mclk&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(2, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;fsync&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;lrclk&quot;,      V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(50,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;drx&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;extclk&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;cmd&quot;,        V_88F6810_PLUS)),
<span class="p_chunk">@@ -334,7 +327,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 	MPP_MODE(52,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;intn&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;sdi&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d6&quot;,         V_88F6810_PLUS)),
<span class="p_chunk">@@ -350,7 +342,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d3&quot;,         V_88F6810_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -380,7 +372,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;i2c1&quot;,  &quot;sda&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d2&quot;,         V_88F6810_PLUS)),
 };
<span class="p_chunk">@@ -409,7 +400,7 @@</span> <span class="p_context"> static struct mvebu_mpp_ctrl armada_38x_mpp_controls[] = {</span>
 
 static struct pinctrl_gpio_range armada_38x_mpp_gpio_ranges[] = {
 	MPP_GPIO_RANGE(0,   0,  0, 32),
<span class="p_del">-	MPP_GPIO_RANGE(1,  32, 32, 27),</span>
<span class="p_add">+	MPP_GPIO_RANGE(1,  32, 32, 28),</span>
 };
 
 static int armada_38x_pinctrl_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index fc33761..7b014f6 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -171,20 +168,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -199,8 +193,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -208,13 +201,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -246,7 +237,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -261,15 +251,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -298,7 +286,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -320,16 +308,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index 3d21efe..7da7e4c 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -271,7 +271,6 @@</span> <span class="p_context"> static const struct dmi_system_id dell_quirks[] __initconst = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -824,12 +823,11 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_del">-	if (!bufferpage) {</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	if (!buffer) {</span>
 		ret = -ENOMEM;
 		goto fail_buffer;
 	}
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -891,7 +889,7 @@</span> <span class="p_context"> fail_backlight:</span>
 	cancel_delayed_work_sync(&amp;dell_rfkill_work);
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index b3d419a..1bd34db 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -464,8 +464,9 @@</span> <span class="p_context"> static const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 static int ideapad_rfk_set(void *data, bool blocked)
 {
 	struct ideapad_rfk_priv *priv = data;
<span class="p_add">+	int opcode = ideapad_rfk_data[priv-&gt;dev].opcode;</span>
 
<span class="p_del">-	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, priv-&gt;dev, !blocked);</span>
<span class="p_add">+	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, opcode, !blocked);</span>
 }
 
 static struct rfkill_ops ideapad_rfk_ops = {
<span class="p_chunk">@@ -830,6 +831,13 @@</span> <span class="p_context"> static void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)</span>
  */
 static const struct dmi_system_id no_hw_rfkill_list[] = {
 	{
<span class="p_add">+		.ident = &quot;Lenovo G50-30&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo G50-30&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 2 11 / 13 / Pro&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/pnp/system.c b/drivers/pnp/system.c</span>
<span class="p_header">index 49c1720..515f338 100644</span>
<span class="p_header">--- a/drivers/pnp/system.c</span>
<span class="p_header">+++ b/drivers/pnp/system.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
  *	Bjorn Helgaas &lt;bjorn.helgaas@hp.com&gt;
  */
 
<span class="p_add">+#include &lt;linux/acpi.h&gt;</span>
 #include &lt;linux/pnp.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/init.h&gt;
<span class="p_chunk">@@ -22,25 +23,41 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	{&quot;&quot;, 0}
 };
 
<span class="p_add">+#ifdef CONFIG_ACPI</span>
<span class="p_add">+static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 space_id = io ? ACPI_ADR_SPACE_SYSTEM_IO : ACPI_ADR_SPACE_SYSTEM_MEMORY;</span>
<span class="p_add">+	return !acpi_reserve_region(start, length, space_id, IORESOURCE_BUSY, desc);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = io ? request_region(start, length, desc) :</span>
<span class="p_add">+		request_mem_region(start, length, desc);</span>
<span class="p_add">+	if (res) {</span>
<span class="p_add">+		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)
 {
 	char *regionid;
 	const char *pnpid = dev_name(&amp;dev-&gt;dev);
 	resource_size_t start = r-&gt;start, end = r-&gt;end;
<span class="p_del">-	struct resource *res;</span>
<span class="p_add">+	bool reserved;</span>
 
 	regionid = kmalloc(16, GFP_KERNEL);
 	if (!regionid)
 		return;
 
 	snprintf(regionid, 16, &quot;pnp %s&quot;, pnpid);
<span class="p_del">-	if (port)</span>
<span class="p_del">-		res = request_region(start, end - start + 1, regionid);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		res = request_mem_region(start, end - start + 1, regionid);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	reserved = __reserve_range(start, end - start + 1, !!port, regionid);</span>
<span class="p_add">+	if (!reserved)</span>
 		kfree(regionid);
 
 	/*
<span class="p_chunk">@@ -49,7 +66,7 @@</span> <span class="p_context"> static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)</span>
 	 * have double reservations.
 	 */
 	dev_info(&amp;dev-&gt;dev, &quot;%pR %s reserved\n&quot;, r,
<span class="p_del">-		 res ? &quot;has been&quot; : &quot;could not be&quot;);</span>
<span class="p_add">+		 reserved ? &quot;has been&quot; : &quot;could not be&quot;);</span>
 }
 
 static void reserve_resources_of_dev(struct pnp_dev *dev)
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index a5761d0..7d508ef 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -774,7 +774,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/rtc/rtc-snvs.c b/drivers/rtc/rtc-snvs.c</span>
<span class="p_header">index 0479e80..d87a85c 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-snvs.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-snvs.c</span>
<span class="p_chunk">@@ -322,6 +322,13 @@</span> <span class="p_context"> static int snvs_rtc_suspend(struct device *dev)</span>
 	if (device_may_wakeup(dev))
 		enable_irq_wake(data-&gt;irq);
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int snvs_rtc_suspend_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snvs_rtc_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+</span>
 	if (data-&gt;clk)
 		clk_disable_unprepare(data-&gt;clk);
 
<span class="p_chunk">@@ -331,23 +338,28 @@</span> <span class="p_context"> static int snvs_rtc_suspend(struct device *dev)</span>
 static int snvs_rtc_resume(struct device *dev)
 {
 	struct snvs_rtc_data *data = dev_get_drvdata(dev);
<span class="p_del">-	int ret;</span>
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		disable_irq_wake(data-&gt;irq);</span>
<span class="p_add">+		return disable_irq_wake(data-&gt;irq);</span>
 
<span class="p_del">-	if (data-&gt;clk) {</span>
<span class="p_del">-		ret = clk_prepare_enable(data-&gt;clk);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int snvs_rtc_resume_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snvs_rtc_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data-&gt;clk)</span>
<span class="p_add">+		return clk_prepare_enable(data-&gt;clk);</span>
 
 	return 0;
 }
 
 static const struct dev_pm_ops snvs_rtc_pm_ops = {
<span class="p_del">-	.suspend_noirq = snvs_rtc_suspend,</span>
<span class="p_del">-	.resume_noirq = snvs_rtc_resume,</span>
<span class="p_add">+	.suspend = snvs_rtc_suspend,</span>
<span class="p_add">+	.suspend_noirq = snvs_rtc_suspend_noirq,</span>
<span class="p_add">+	.resume = snvs_rtc_resume,</span>
<span class="p_add">+	.resume_noirq = snvs_rtc_resume_noirq,</span>
 };
 
 #define SNVS_RTC_PM_OPS	(&amp;snvs_rtc_pm_ops)
<span class="p_header">diff --git a/drivers/s390/kvm/virtio_ccw.c b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">index 71d7802..5717117 100644</span>
<span class="p_header">--- a/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">+++ b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> struct virtio_ccw_device {</span>
 	bool is_thinint;
 	bool going_away;
 	bool device_lost;
<span class="p_add">+	unsigned int config_ready;</span>
 	void *airq_info;
 };
 
<span class="p_chunk">@@ -833,8 +834,11 @@</span> <span class="p_context"> static void virtio_ccw_get_config(struct virtio_device *vdev,</span>
 	if (ret)
 		goto out_free;
 
<span class="p_del">-	memcpy(vcdev-&gt;config, config_area, sizeof(vcdev-&gt;config));</span>
<span class="p_del">-	memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	memcpy(vcdev-&gt;config, config_area, offset + len);</span>
<span class="p_add">+	if (buf)</span>
<span class="p_add">+		memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset + len)</span>
<span class="p_add">+		vcdev-&gt;config_ready = offset + len;</span>
 
 out_free:
 	kfree(config_area);
<span class="p_chunk">@@ -857,6 +861,9 @@</span> <span class="p_context"> static void virtio_ccw_set_config(struct virtio_device *vdev,</span>
 	if (!config_area)
 		goto out_free;
 
<span class="p_add">+	/* Make sure we don&#39;t overwrite fields. */</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset)</span>
<span class="p_add">+		virtio_ccw_get_config(vdev, 0, NULL, offset);</span>
 	memcpy(&amp;vcdev-&gt;config[offset], buf, len);
 	/* Write the config area to the host. */
 	memcpy(config_area, vcdev-&gt;config, sizeof(vcdev-&gt;config));
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index ec03b42..70b0647 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">index 0d44d91..e94f9bd 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_chunk">@@ -1838,7 +1838,7 @@</span> <span class="p_context"> struct megasas_cmd {</span>
 
 	u32 index;
 	u8 sync_cmd;
<span class="p_del">-	u8 cmd_status;</span>
<span class="p_add">+	u8 cmd_status_drv;</span>
 	u8 abort_aen;
 	u8 retry_for_fw_reset;
 
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index d63f041..e541c6c 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -910,7 +910,7 @@</span> <span class="p_context"> extern struct megasas_instance_template megasas_instance_template_fusion;</span>
  * @instance:			Adapter soft state
  * @cmd:			Command packet to be issued
  *
<span class="p_del">- * For polling, MFI requires the cmd_status to be set to 0xFF before posting.</span>
<span class="p_add">+ * For polling, MFI requires the cmd_status to be set to MFI_STAT_INVALID_STATUS before posting.</span>
  */
 int
 megasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)
<span class="p_chunk">@@ -952,20 +952,21 @@</span> <span class="p_context"> megasas_issue_blocked_cmd(struct megasas_instance *instance,</span>
 			  struct megasas_cmd *cmd, int timeout)
 {
 	int ret = 0;
<span class="p_del">-	cmd-&gt;cmd_status = ENODATA;</span>
<span class="p_add">+	cmd-&gt;cmd_status_drv = MFI_STAT_INVALID_STATUS;</span>
 
 	cmd-&gt;is_wait_event = 1;
 	instance-&gt;instancet-&gt;issue_dcmd(instance, cmd);
 	if (timeout) {
 		ret = wait_event_timeout(instance-&gt;int_cmd_wait_q,
<span class="p_del">-				cmd-&gt;cmd_status != ENODATA, timeout * HZ);</span>
<span class="p_add">+				cmd-&gt;cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);</span>
 		if (!ret)
 			return 1;
 	} else
 		wait_event(instance-&gt;int_cmd_wait_q,
<span class="p_del">-				cmd-&gt;cmd_status != ENODATA);</span>
<span class="p_add">+				cmd-&gt;cmd_status_drv != MFI_STAT_INVALID_STATUS);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return (cmd-&gt;cmd_status_drv == MFI_STAT_OK) ?</span>
<span class="p_add">+		0 : 1;</span>
 }
 
 /**
<span class="p_chunk">@@ -998,7 +999,7 @@</span> <span class="p_context"> megasas_issue_blocked_abort_cmd(struct megasas_instance *instance,</span>
 	 * Prepare and issue the abort frame
 	 */
 	abort_fr-&gt;cmd = MFI_CMD_ABORT;
<span class="p_del">-	abort_fr-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	abort_fr-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	abort_fr-&gt;flags = cpu_to_le16(0);
 	abort_fr-&gt;abort_context = cpu_to_le32(cmd_to_abort-&gt;index);
 	abort_fr-&gt;abort_mfi_phys_addr_lo =
<span class="p_chunk">@@ -1007,13 +1008,13 @@</span> <span class="p_context"> megasas_issue_blocked_abort_cmd(struct megasas_instance *instance,</span>
 		cpu_to_le32(upper_32_bits(cmd_to_abort-&gt;frame_phys_addr));
 
 	cmd-&gt;sync_cmd = 1;
<span class="p_del">-	cmd-&gt;cmd_status = ENODATA;</span>
<span class="p_add">+	cmd-&gt;cmd_status_drv = MFI_STAT_INVALID_STATUS;</span>
 
 	instance-&gt;instancet-&gt;issue_dcmd(instance, cmd);
 
 	if (timeout) {
 		ret = wait_event_timeout(instance-&gt;abort_cmd_wait_q,
<span class="p_del">-				cmd-&gt;cmd_status != ENODATA, timeout * HZ);</span>
<span class="p_add">+				cmd-&gt;cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);</span>
 		if (!ret) {
 			dev_err(&amp;instance-&gt;pdev-&gt;dev, &quot;Command timedout&quot;
 				&quot;from %s\n&quot;, __func__);
<span class="p_chunk">@@ -1021,7 +1022,7 @@</span> <span class="p_context"> megasas_issue_blocked_abort_cmd(struct megasas_instance *instance,</span>
 		}
 	} else
 		wait_event(instance-&gt;abort_cmd_wait_q,
<span class="p_del">-				cmd-&gt;cmd_status != ENODATA);</span>
<span class="p_add">+				cmd-&gt;cmd_status_drv != MFI_STAT_INVALID_STATUS);</span>
 
 	cmd-&gt;sync_cmd = 0;
 
<span class="p_chunk">@@ -1923,7 +1924,7 @@</span> <span class="p_context"> static int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,</span>
 	memset(dcmd-&gt;mbox.b, 0, MFI_MBOX_SIZE);
 
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = MFI_FRAME_DIR_BOTH;
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -2038,7 +2039,7 @@</span> <span class="p_context"> static int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,</span>
 	memset(dcmd-&gt;mbox.b, 0, MFI_MBOX_SIZE);
 
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = MFI_FRAME_DIR_BOTH;
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -2207,7 +2208,7 @@</span> <span class="p_context"> int megasas_sriov_start_heartbeat(struct megasas_instance *instance,</span>
 
 	dcmd-&gt;mbox.s[0] = sizeof(struct MR_CTRL_HB_HOST_MEM);
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = MFI_FRAME_DIR_BOTH;
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -2223,21 +2224,11 @@</span> <span class="p_context"> int megasas_sriov_start_heartbeat(struct megasas_instance *instance,</span>
 	if (!megasas_issue_polled(instance, cmd)) {
 		retval = 0;
 	} else {
<span class="p_del">-		printk(KERN_WARNING &quot;megasas: SR-IOV: MR_DCMD_CTRL_SHARED_HOST&quot;</span>
<span class="p_del">-		       &quot;_MEM_ALLOC DCMD timed out for scsi%d\n&quot;,</span>
<span class="p_del">-		       instance-&gt;host-&gt;host_no);</span>
<span class="p_del">-		retval = 1;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	if (dcmd-&gt;cmd_status) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;megasas: SR-IOV: MR_DCMD_CTRL_SHARED_HOST&quot;</span>
<span class="p_del">-		       &quot;_MEM_ALLOC DCMD failed with status 0x%x for scsi%d\n&quot;,</span>
<span class="p_del">-		       dcmd-&gt;cmd_status,</span>
<span class="p_del">-		       instance-&gt;host-&gt;host_no);</span>
<span class="p_add">+		dev_warn(&amp;instance-&gt;pdev-&gt;dev, &quot;SR-IOV: MR_DCMD_CTRL_SHARED_HOST&quot;</span>
<span class="p_add">+			&quot;_MEM_ALLOC DCMD %s for scsi%d\n&quot;,</span>
<span class="p_add">+			(dcmd-&gt;cmd_status == MFI_STAT_INVALID_STATUS) ?</span>
<span class="p_add">+			&quot;timed out&quot; : &quot;failed&quot;, instance-&gt;host-&gt;host_no);</span>
 		retval = 1;
<span class="p_del">-		goto out;</span>
 	}
 
 out:
<span class="p_chunk">@@ -2333,7 +2324,7 @@</span> <span class="p_context"> static int megasas_wait_for_outstanding(struct megasas_instance *instance)</span>
 						&quot;reset queue\n&quot;,
 						reset_cmd);
 
<span class="p_del">-				reset_cmd-&gt;cmd_status = ENODATA;</span>
<span class="p_add">+				reset_cmd-&gt;cmd_status_drv = MFI_STAT_INVALID_STATUS;</span>
 				instance-&gt;instancet-&gt;fire_cmd(instance,
 						reset_cmd-&gt;frame_phys_addr,
 						0, instance-&gt;reg_set);
<span class="p_chunk">@@ -2816,11 +2807,7 @@</span> <span class="p_context"> static void</span>
 megasas_complete_int_cmd(struct megasas_instance *instance,
 			 struct megasas_cmd *cmd)
 {
<span class="p_del">-	cmd-&gt;cmd_status = cmd-&gt;frame-&gt;io.cmd_status;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;cmd_status == ENODATA) {</span>
<span class="p_del">-		cmd-&gt;cmd_status = 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cmd-&gt;cmd_status_drv = cmd-&gt;frame-&gt;io.cmd_status;</span>
 	wake_up(&amp;instance-&gt;int_cmd_wait_q);
 }
 
<span class="p_chunk">@@ -2839,7 +2826,7 @@</span> <span class="p_context"> megasas_complete_abort(struct megasas_instance *instance,</span>
 {
 	if (cmd-&gt;sync_cmd) {
 		cmd-&gt;sync_cmd = 0;
<span class="p_del">-		cmd-&gt;cmd_status = 0;</span>
<span class="p_add">+		cmd-&gt;cmd_status_drv = 0;</span>
 		wake_up(&amp;instance-&gt;abort_cmd_wait_q);
 	}
 
<span class="p_chunk">@@ -3087,7 +3074,7 @@</span> <span class="p_context"> megasas_issue_pending_cmds_again(struct megasas_instance *instance)</span>
 			printk(KERN_NOTICE &quot;megasas: %p synchronous cmd&quot;
 						&quot;on the internal reset queue,&quot;
 						&quot;issue it again.\n&quot;, cmd);
<span class="p_del">-			cmd-&gt;cmd_status = ENODATA;</span>
<span class="p_add">+			cmd-&gt;cmd_status_drv = MFI_STAT_INVALID_STATUS;</span>
 			instance-&gt;instancet-&gt;fire_cmd(instance,
 							cmd-&gt;frame_phys_addr ,
 							0, instance-&gt;reg_set);
<span class="p_chunk">@@ -3828,7 +3815,7 @@</span> <span class="p_context"> megasas_get_pd_list(struct megasas_instance *instance)</span>
 	dcmd-&gt;mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;
 	dcmd-&gt;mbox.b[1] = 0;
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = cpu_to_le16(MFI_FRAME_DIR_READ);
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -3928,7 +3915,7 @@</span> <span class="p_context"> megasas_get_ld_list(struct megasas_instance *instance)</span>
 	if (instance-&gt;supportmax256vd)
 		dcmd-&gt;mbox.b[0] = 1;
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = cpu_to_le16(MFI_FRAME_DIR_READ);
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -4021,7 +4008,7 @@</span> <span class="p_context"> megasas_ld_list_query(struct megasas_instance *instance, u8 query_type)</span>
 		dcmd-&gt;mbox.b[2] = 1;
 
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = cpu_to_le16(MFI_FRAME_DIR_READ);
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -4159,7 +4146,7 @@</span> <span class="p_context"> megasas_get_ctrl_info(struct megasas_instance *instance)</span>
 	memset(dcmd-&gt;mbox.b, 0, MFI_MBOX_SIZE);
 
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = cpu_to_le16(MFI_FRAME_DIR_READ);
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -4230,7 +4217,7 @@</span> <span class="p_context"> int megasas_set_crash_dump_params(struct megasas_instance *instance,</span>
 	memset(dcmd-&gt;mbox.b, 0, MFI_MBOX_SIZE);
 	dcmd-&gt;mbox.b[0] = crash_buf_state;
 	dcmd-&gt;cmd = MFI_CMD_DCMD;
<span class="p_del">-	dcmd-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	dcmd-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	dcmd-&gt;sge_count = 1;
 	dcmd-&gt;flags = cpu_to_le16(MFI_FRAME_DIR_NONE);
 	dcmd-&gt;timeout = 0;
<span class="p_chunk">@@ -4301,7 +4288,7 @@</span> <span class="p_context"> megasas_issue_init_mfi(struct megasas_instance *instance)</span>
 	initq_info-&gt;consumer_index_phys_addr_lo = cpu_to_le32(instance-&gt;consumer_h);
 
 	init_frame-&gt;cmd = MFI_CMD_INIT;
<span class="p_del">-	init_frame-&gt;cmd_status = 0xFF;</span>
<span class="p_add">+	init_frame-&gt;cmd_status = MFI_STAT_INVALID_STATUS;</span>
 	init_frame-&gt;queue_info_new_phys_addr_lo =
 		cpu_to_le32(lower_32_bits(initq_info_h));
 	init_frame-&gt;queue_info_new_phys_addr_hi =
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 0764d20..8b1b47e 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -612,7 +612,8 @@</span> <span class="p_context"> wait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,</span>
 		return -ETIME;
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return (frame_hdr-&gt;cmd_status == MFI_STAT_OK) ?</span>
<span class="p_add">+		0 : 1;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_srp.c b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">index ae45bd9..f115f67 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_chunk">@@ -396,6 +396,36 @@</span> <span class="p_context"> static void srp_reconnect_work(struct work_struct *work)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_add">+ * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To do: add support for scsi-mq in this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_device *sdev;</span>
<span class="p_add">+	struct request_queue *q;</span>
<span class="p_add">+	int request_fn_active = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	shost_for_each_device(sdev, shost) {</span>
<span class="p_add">+		q = sdev-&gt;request_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_add">+		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return request_fn_active;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Wait until ongoing shost-&gt;hostt-&gt;queuecommand() calls have finished. */</span>
<span class="p_add">+static void srp_wait_for_queuecommand(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (scsi_request_fn_active(shost))</span>
<span class="p_add">+		msleep(20);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __rport_fail_io_fast(struct srp_rport *rport)
 {
 	struct Scsi_Host *shost = rport_to_shost(rport);
<span class="p_chunk">@@ -409,8 +439,10 @@</span> <span class="p_context"> static void __rport_fail_io_fast(struct srp_rport *rport)</span>
 
 	/* Involve the LLD if possible to terminate all I/O on the rport. */
 	i = to_srp_internal(shost-&gt;transportt);
<span class="p_del">-	if (i-&gt;f-&gt;terminate_rport_io)</span>
<span class="p_add">+	if (i-&gt;f-&gt;terminate_rport_io) {</span>
<span class="p_add">+		srp_wait_for_queuecommand(shost);</span>
 		i-&gt;f-&gt;terminate_rport_io(rport);
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -504,27 +536,6 @@</span> <span class="p_context"> void srp_start_tl_fail_timers(struct srp_rport *rport)</span>
 EXPORT_SYMBOL(srp_start_tl_fail_timers);
 
 /**
<span class="p_del">- * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_del">- * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_device *sdev;</span>
<span class="p_del">-	struct request_queue *q;</span>
<span class="p_del">-	int request_fn_active = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	shost_for_each_device(sdev, shost) {</span>
<span class="p_del">-		q = sdev-&gt;request_queue;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_del">-		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return request_fn_active;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * srp_reconnect_rport() - reconnect to an SRP target port
  * @rport: SRP target port.
  *
<span class="p_chunk">@@ -559,8 +570,7 @@</span> <span class="p_context"> int srp_reconnect_rport(struct srp_rport *rport)</span>
 	if (res)
 		goto out;
 	scsi_target_block(&amp;shost-&gt;shost_gendev);
<span class="p_del">-	while (scsi_request_fn_active(shost))</span>
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+	srp_wait_for_queuecommand(shost);</span>
 	res = rport-&gt;state != SRP_RPORT_LOST ? i-&gt;f-&gt;reconnect(rport) : -ENODEV;
 	pr_debug(&quot;%s (state %d): transport.reconnect() returned %d\n&quot;,
 		 dev_name(&amp;shost-&gt;shost_gendev), rport-&gt;state, res);
<span class="p_header">diff --git a/drivers/spi/spi-orion.c b/drivers/spi/spi-orion.c</span>
<span class="p_header">index 3dec9e0..386522b 100644</span>
<span class="p_header">--- a/drivers/spi/spi-orion.c</span>
<span class="p_header">+++ b/drivers/spi/spi-orion.c</span>
<span class="p_chunk">@@ -52,6 +52,12 @@</span> <span class="p_context"> enum orion_spi_type {</span>
 
 struct orion_spi_dev {
 	enum orion_spi_type	typ;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * min_divisor and max_hz should be exclusive, the only we can</span>
<span class="p_add">+	 * have both is for managing the armada-370-spi case with old</span>
<span class="p_add">+	 * device tree</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned long		max_hz;</span>
 	unsigned int		min_divisor;
 	unsigned int		max_divisor;
 	u32			prescale_mask;
<span class="p_chunk">@@ -402,8 +408,9 @@</span> <span class="p_context"> static const struct orion_spi_dev orion_spi_dev_data = {</span>
 
 static const struct orion_spi_dev armada_spi_dev_data = {
 	.typ = ARMADA_SPI,
<span class="p_del">-	.min_divisor = 1,</span>
<span class="p_add">+	.min_divisor = 4,</span>
 	.max_divisor = 1920,
<span class="p_add">+	.max_hz = 50000000,</span>
 	.prescale_mask = ARMADA_SPI_CLK_PRESCALE_MASK,
 };
 
<span class="p_chunk">@@ -468,7 +475,21 @@</span> <span class="p_context"> static int orion_spi_probe(struct platform_device *pdev)</span>
 		goto out;
 
 	tclk_hz = clk_get_rate(spi-&gt;clk);
<span class="p_del">-	master-&gt;max_speed_hz = DIV_ROUND_UP(tclk_hz, devdata-&gt;min_divisor);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * With old device tree, armada-370-spi could be used with</span>
<span class="p_add">+	 * Armada XP, however for this SoC the maximum frequency is</span>
<span class="p_add">+	 * 50MHz instead of tclk/4. On Armada 370, tclk cannot be</span>
<span class="p_add">+	 * higher than 200MHz. So, in order to be able to handle both</span>
<span class="p_add">+	 * SoCs, we can take the minimum of 50MHz and tclk/4.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (of_device_is_compatible(pdev-&gt;dev.of_node,</span>
<span class="p_add">+					&quot;marvell,armada-370-spi&quot;))</span>
<span class="p_add">+		master-&gt;max_speed_hz = min(devdata-&gt;max_hz,</span>
<span class="p_add">+				DIV_ROUND_UP(tclk_hz, devdata-&gt;min_divisor));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		master-&gt;max_speed_hz =</span>
<span class="p_add">+			DIV_ROUND_UP(tclk_hz, devdata-&gt;min_divisor);</span>
 	master-&gt;min_speed_hz = DIV_ROUND_UP(tclk_hz, devdata-&gt;max_divisor);
 
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index a17f533..bfa47d5 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1059,9 +1059,6 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 
 	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);
 	mesg = master-&gt;cur_msg;
<span class="p_del">-	master-&gt;cur_msg = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
 	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);
 
 	spi_unmap_msg(master, mesg);
<span class="p_chunk">@@ -1074,9 +1071,13 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 		}
 	}
 
<span class="p_del">-	trace_spi_message_done(mesg);</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+	master-&gt;cur_msg = NULL;</span>
 	master-&gt;cur_msg_prepared = false;
<span class="p_add">+	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_spi_message_done(mesg);</span>
 
 	mesg-&gt;state = NULL;
 	if (mesg-&gt;complete)
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index cd8b444..5542243 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1056,7 +1056,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index b95e915..fea0214 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -851,6 +851,10 @@</span> <span class="p_context"> static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 	     pRD = pRD-&gt;next) {
 		if (works++ &gt; 15)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		if (!pRD-&gt;pRDInfo-&gt;skb)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		if (vnt_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				dev_err(&amp;pDevice-&gt;pcid-&gt;dev,
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 95f8f64..1ce085a 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -308,8 +308,7 @@</span> <span class="p_context"> static int atmel_config_rs485(struct uart_port *port,</span>
 	if (rs485conf-&gt;flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
 		atmel_port-&gt;tx_done_mask = ATMEL_US_TXEMPTY;
<span class="p_del">-		if ((rs485conf-&gt;delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_chunk">@@ -370,8 +369,7 @@</span> <span class="p_context"> static void atmel_set_mctrl(struct uart_port *port, u_int mctrl)</span>
 
 	if (port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
<span class="p_del">-		if ((port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_chunk">@@ -2026,8 +2024,7 @@</span> <span class="p_context"> static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 	mode &amp;= ~ATMEL_US_USMODE;
 
 	if (port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
<span class="p_del">-		if ((port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	}
 
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 42bad18..647d3df 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -55,9 +55,6 @@</span> <span class="p_context"></span>
 static int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;
 static bool __read_mostly sysrq_always_enabled;
 
<span class="p_del">-unsigned short platform_sysrq_reset_seq[] __weak = { KEY_RESERVED };</span>
<span class="p_del">-int sysrq_reset_downtime_ms __weak;</span>
<span class="p_del">-</span>
 static bool sysrq_on(void)
 {
 	return sysrq_enabled || sysrq_always_enabled;
<span class="p_chunk">@@ -567,6 +564,7 @@</span> <span class="p_context"> void handle_sysrq(int key)</span>
 EXPORT_SYMBOL(handle_sysrq);
 
 #ifdef CONFIG_INPUT
<span class="p_add">+static int sysrq_reset_downtime_ms;</span>
 
 /* Simple translation table for the SysRq keys */
 static const unsigned char sysrq_xlate[KEY_CNT] =
<span class="p_chunk">@@ -947,23 +945,8 @@</span> <span class="p_context"> static bool sysrq_handler_registered;</span>
 
 static inline void sysrq_register_handler(void)
 {
<span class="p_del">-	unsigned short key;</span>
 	int error;
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First check if a __weak interface was instantiated. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sysrq_reset_seq); i++) {</span>
<span class="p_del">-		key = platform_sysrq_reset_seq[i];</span>
<span class="p_del">-		if (key == KEY_RESERVED || key &gt; KEY_MAX)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		sysrq_reset_seq[sysrq_reset_seq_len++] = key;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * DT configuration takes precedence over anything that would</span>
<span class="p_del">-	 * have been defined via the __weak interface.</span>
<span class="p_del">-	 */</span>
 	sysrq_of_get_keyreset_config();
 
 	error = input_register_handler(&amp;sysrq_handler);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 054fc28..9a294a8 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1483,6 +1483,11 @@</span> <span class="p_context"> skip_countries:</span>
 		goto alloc_fail8;
 	}
 
<span class="p_add">+	if (quirks &amp; CLEAR_HALT_CONDITIONS) {</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress));</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 alloc_fail8:
 	if (acm-&gt;country_codes) {
<span class="p_chunk">@@ -1760,6 +1765,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
 
<span class="p_add">+	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */</span>
<span class="p_add">+	.driver_info = CLEAR_HALT_CONDITIONS,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Nokia S60 phones expose two ACM channels. The first is
 	 * a modem and is picked up by the standard AT-command
 	 * information below. The second is &#39;vendor-specific&#39; but
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index ffeb3c8..b3b6c9d 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -133,3 +133,4 @@</span> <span class="p_context"> struct acm {</span>
 #define NO_DATA_INTERFACE		BIT(4)
 #define IGNORE_DEVICE			BIT(5)
 #define QUIRK_CONTROL_LINE_STATE	BIT(6)
<span class="p_add">+#define CLEAR_HALT_CONDITIONS		BIT(7)</span>
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index e500243..fae81924 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 95409aacc..79d50b9 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2616,9 +2616,6 @@</span> <span class="p_context"> static bool use_new_scheme(struct usb_device *udev, int retry)</span>
 	return USE_NEW_SCHEME(retry);
 }
 
<span class="p_del">-static int hub_port_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, unsigned int delay, bool warm);</span>
<span class="p_del">-</span>
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
  * Port worm reset is required to recover
  */
<span class="p_chunk">@@ -2706,44 +2703,6 @@</span> <span class="p_context"> static int hub_port_wait_reset(struct usb_hub *hub, int port1,</span>
 	return 0;
 }
 
<span class="p_del">-static void hub_port_finish_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, int *status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (*status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_del">-		msleep(10 + 40);</span>
<span class="p_del">-		if (udev) {</span>
<span class="p_del">-			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_del">-</span>
<span class="p_del">-			update_devnum(udev, 0);</span>
<span class="p_del">-			/* The xHC may think the device is already reset,</span>
<span class="p_del">-			 * so ignore the status.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_del">-				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* FALL THROUGH */</span>
<span class="p_del">-	case -ENOTCONN:</span>
<span class="p_del">-	case -ENODEV:</span>
<span class="p_del">-		usb_clear_port_feature(hub-&gt;hdev,</span>
<span class="p_del">-				port1, USB_PORT_FEAT_C_RESET);</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (udev)</span>
<span class="p_del">-			usb_set_device_state(udev, *status</span>
<span class="p_del">-					? USB_STATE_NOTATTACHED</span>
<span class="p_del">-					: USB_STATE_DEFAULT);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
<span class="p_chunk">@@ -2767,13 +2726,10 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		 * If the caller hasn&#39;t explicitly requested a warm reset,
 		 * double check and see if one is needed.
 		 */
<span class="p_del">-		status = hub_port_status(hub, port1,</span>
<span class="p_del">-					&amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (status &lt; 0)</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (hub_port_warm_reset_required(hub, port1, portstatus))</span>
<span class="p_del">-			warm = true;</span>
<span class="p_add">+		if (hub_port_status(hub, port1, &amp;portstatus, &amp;portchange) == 0)</span>
<span class="p_add">+			if (hub_port_warm_reset_required(hub, port1,</span>
<span class="p_add">+							portstatus))</span>
<span class="p_add">+				warm = true;</span>
 	}
 	clear_bit(port1, hub-&gt;warm_reset_bits);
 
<span class="p_chunk">@@ -2799,11 +2755,19 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 
 		/* Check for disconnect or reset */
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
<span class="p_del">-			hub_port_finish_reset(hub, port1, udev, &amp;status);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_RESET);</span>
 
 			if (!hub_is_superspeed(hub-&gt;hdev))
 				goto done;
 
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+</span>
 			/*
 			 * If a USB 3.0 device migrates from reset to an error
 			 * state, re-issue the warm reset.
<span class="p_chunk">@@ -2836,6 +2800,26 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 	dev_err(&amp;port_dev-&gt;dev, &quot;Cannot enable. Maybe the USB cable is bad?\n&quot;);
 
 done:
<span class="p_add">+	if (status == 0) {</span>
<span class="p_add">+		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_add">+		msleep(10 + 40);</span>
<span class="p_add">+		if (udev) {</span>
<span class="p_add">+			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_add">+</span>
<span class="p_add">+			update_devnum(udev, 0);</span>
<span class="p_add">+			/* The xHC may think the device is already reset,</span>
<span class="p_add">+			 * so ignore the status.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_add">+				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_DEFAULT);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (udev)</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!hub_is_superspeed(hub-&gt;hdev))
 		up_read(&amp;ehci_cf_port_reset_rwsem);
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 4efd3bd..5496218 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1906,12 +1906,16 @@</span> <span class="p_context"> static void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,</span>
 {
 	unsigned		status = 0;
 	int			clean_busy;
<span class="p_add">+	u32			is_xfer_complete;</span>
<span class="p_add">+</span>
<span class="p_add">+	is_xfer_complete = (event-&gt;endpoint_event == DWC3_DEPEVT_XFERCOMPLETE);</span>
 
 	if (event-&gt;status &amp; DEPEVT_STATUS_BUSERR)
 		status = -ECONNRESET;
 
 	clean_busy = dwc3_cleanup_done_reqs(dwc, dep, event, status);
<span class="p_del">-	if (clean_busy)</span>
<span class="p_add">+	if (clean_busy &amp;&amp; (is_xfer_complete ||</span>
<span class="p_add">+				usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc)))</span>
 		dep-&gt;flags &amp;= ~DWC3_EP_BUSY;
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig</span>
<span class="p_header">index fafc628..c87e6e7 100644</span>
<span class="p_header">--- a/drivers/usb/host/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/host/Kconfig</span>
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> config USB_OCTEON_EHCI</span>
 	bool &quot;Octeon on-chip EHCI support (DEPRECATED)&quot;
 	depends on CAVIUM_OCTEON_SOC
 	default n
<span class="p_del">-	select USB_EHCI_BIG_ENDIAN_MMIO</span>
<span class="p_add">+	select USB_EHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN</span>
 	select USB_EHCI_HCD_PLATFORM
 	help
 	  This option is deprecated now and the driver was removed, use
<span class="p_chunk">@@ -582,7 +582,7 @@</span> <span class="p_context"> config USB_OCTEON_OHCI</span>
 	bool &quot;Octeon on-chip OHCI support (DEPRECATED)&quot;
 	depends on CAVIUM_OCTEON_SOC
 	default USB_OCTEON_EHCI
<span class="p_del">-	select USB_OHCI_BIG_ENDIAN_MMIO</span>
<span class="p_add">+	select USB_OHCI_BIG_ENDIAN_MMIO if CPU_BIG_ENDIAN</span>
 	select USB_OHCI_LITTLE_ENDIAN
 	select USB_OHCI_HCD_PLATFORM
 	help
<span class="p_header">diff --git a/drivers/video/fbdev/mxsfb.c b/drivers/video/fbdev/mxsfb.c</span>
<span class="p_header">index f8ac4a4..0f64165 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/mxsfb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/mxsfb.c</span>
<span class="p_chunk">@@ -316,6 +316,18 @@</span> <span class="p_context"> static int mxsfb_check_var(struct fb_var_screeninfo *var,</span>
 	return 0;
 }
 
<span class="p_add">+static inline void mxsfb_enable_axi_clk(struct mxsfb_info *host)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (host-&gt;clk_axi)</span>
<span class="p_add">+		clk_prepare_enable(host-&gt;clk_axi);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void mxsfb_disable_axi_clk(struct mxsfb_info *host)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (host-&gt;clk_axi)</span>
<span class="p_add">+		clk_disable_unprepare(host-&gt;clk_axi);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mxsfb_enable_controller(struct fb_info *fb_info)
 {
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
<span class="p_chunk">@@ -333,14 +345,13 @@</span> <span class="p_context"> static void mxsfb_enable_controller(struct fb_info *fb_info)</span>
 		}
 	}
 
<span class="p_del">-	if (host-&gt;clk_axi)</span>
<span class="p_del">-		clk_prepare_enable(host-&gt;clk_axi);</span>
<span class="p_del">-</span>
 	if (host-&gt;clk_disp_axi)
 		clk_prepare_enable(host-&gt;clk_disp_axi);
 	clk_prepare_enable(host-&gt;clk);
 	clk_set_rate(host-&gt;clk, PICOS2KHZ(fb_info-&gt;var.pixclock) * 1000U);
 
<span class="p_add">+	mxsfb_enable_axi_clk(host);</span>
<span class="p_add">+</span>
 	/* if it was disabled, re-enable the mode again */
 	writel(CTRL_DOTCLK_MODE, host-&gt;base + LCDC_CTRL + REG_SET);
 
<span class="p_chunk">@@ -380,11 +391,11 @@</span> <span class="p_context"> static void mxsfb_disable_controller(struct fb_info *fb_info)</span>
 	reg = readl(host-&gt;base + LCDC_VDCTRL4);
 	writel(reg &amp; ~VDCTRL4_SYNC_SIGNALS_ON, host-&gt;base + LCDC_VDCTRL4);
 
<span class="p_add">+	mxsfb_disable_axi_clk(host);</span>
<span class="p_add">+</span>
 	clk_disable_unprepare(host-&gt;clk);
 	if (host-&gt;clk_disp_axi)
 		clk_disable_unprepare(host-&gt;clk_disp_axi);
<span class="p_del">-	if (host-&gt;clk_axi)</span>
<span class="p_del">-		clk_disable_unprepare(host-&gt;clk_axi);</span>
 
 	host-&gt;enabled = 0;
 
<span class="p_chunk">@@ -421,6 +432,8 @@</span> <span class="p_context"> static int mxsfb_set_par(struct fb_info *fb_info)</span>
 		mxsfb_disable_controller(fb_info);
 	}
 
<span class="p_add">+	mxsfb_enable_axi_clk(host);</span>
<span class="p_add">+</span>
 	/* clear the FIFOs */
 	writel(CTRL1_FIFO_CLEAR, host-&gt;base + LCDC_CTRL1 + REG_SET);
 
<span class="p_chunk">@@ -438,6 +451,7 @@</span> <span class="p_context"> static int mxsfb_set_par(struct fb_info *fb_info)</span>
 		ctrl |= CTRL_SET_WORD_LENGTH(3);
 		switch (host-&gt;ld_intf_width) {
 		case STMLCDIF_8BIT:
<span class="p_add">+			mxsfb_disable_axi_clk(host);</span>
 			dev_err(&amp;host-&gt;pdev-&gt;dev,
 					&quot;Unsupported LCD bus width mapping\n&quot;);
 			return -EINVAL;
<span class="p_chunk">@@ -451,6 +465,7 @@</span> <span class="p_context"> static int mxsfb_set_par(struct fb_info *fb_info)</span>
 		writel(CTRL1_SET_BYTE_PACKAGING(0x7), host-&gt;base + LCDC_CTRL1);
 		break;
 	default:
<span class="p_add">+		mxsfb_disable_axi_clk(host);</span>
 		dev_err(&amp;host-&gt;pdev-&gt;dev, &quot;Unhandled color depth of %u\n&quot;,
 				fb_info-&gt;var.bits_per_pixel);
 		return -EINVAL;
<span class="p_chunk">@@ -504,6 +519,8 @@</span> <span class="p_context"> static int mxsfb_set_par(struct fb_info *fb_info)</span>
 			fb_info-&gt;fix.line_length * fb_info-&gt;var.yoffset,
 			host-&gt;base + host-&gt;devdata-&gt;next_buf);
 
<span class="p_add">+	mxsfb_disable_axi_clk(host);</span>
<span class="p_add">+</span>
 	if (reenable)
 		mxsfb_enable_controller(fb_info);
 
<span class="p_chunk">@@ -582,10 +599,14 @@</span> <span class="p_context"> static int mxsfb_pan_display(struct fb_var_screeninfo *var,</span>
 
 	offset = fb_info-&gt;fix.line_length * var-&gt;yoffset;
 
<span class="p_add">+	mxsfb_enable_axi_clk(host);</span>
<span class="p_add">+</span>
 	/* update on next VSYNC */
 	writel(fb_info-&gt;fix.smem_start + offset,
 			host-&gt;base + host-&gt;devdata-&gt;next_buf);
 
<span class="p_add">+	mxsfb_disable_axi_clk(host);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -608,13 +629,17 @@</span> <span class="p_context"> static int mxsfb_restore_mode(struct mxsfb_info *host,</span>
 	unsigned line_count;
 	unsigned period;
 	unsigned long pa, fbsize;
<span class="p_del">-	int bits_per_pixel, ofs;</span>
<span class="p_add">+	int bits_per_pixel, ofs, ret = 0;</span>
 	u32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;
 
<span class="p_add">+	mxsfb_enable_axi_clk(host);</span>
<span class="p_add">+</span>
 	/* Only restore the mode when the controller is running */
 	ctrl = readl(host-&gt;base + LCDC_CTRL);
<span class="p_del">-	if (!(ctrl &amp; CTRL_RUN))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!(ctrl &amp; CTRL_RUN)) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
 
 	vdctrl0 = readl(host-&gt;base + LCDC_VDCTRL0);
 	vdctrl2 = readl(host-&gt;base + LCDC_VDCTRL2);
<span class="p_chunk">@@ -635,7 +660,8 @@</span> <span class="p_context"> static int mxsfb_restore_mode(struct mxsfb_info *host,</span>
 		break;
 	case 1:
 	default:
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	fb_info-&gt;var.bits_per_pixel = bits_per_pixel;
<span class="p_chunk">@@ -673,10 +699,14 @@</span> <span class="p_context"> static int mxsfb_restore_mode(struct mxsfb_info *host,</span>
 
 	pa = readl(host-&gt;base + host-&gt;devdata-&gt;cur_buf);
 	fbsize = fb_info-&gt;fix.line_length * vmode-&gt;yres;
<span class="p_del">-	if (pa &lt; fb_info-&gt;fix.smem_start)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	if (pa + fbsize &gt; fb_info-&gt;fix.smem_start + fb_info-&gt;fix.smem_len)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (pa &lt; fb_info-&gt;fix.smem_start) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (pa + fbsize &gt; fb_info-&gt;fix.smem_start + fb_info-&gt;fix.smem_len) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
 	ofs = pa - fb_info-&gt;fix.smem_start;
 	if (ofs) {
 		memmove(fb_info-&gt;screen_base, fb_info-&gt;screen_base + ofs, fbsize);
<span class="p_chunk">@@ -689,7 +719,11 @@</span> <span class="p_context"> static int mxsfb_restore_mode(struct mxsfb_info *host,</span>
 	clk_prepare_enable(host-&gt;clk);
 	host-&gt;enabled = 1;
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		mxsfb_disable_axi_clk(host);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,
<span class="p_chunk">@@ -915,7 +949,9 @@</span> <span class="p_context"> static int mxsfb_probe(struct platform_device *pdev)</span>
 	}
 
 	if (!host-&gt;enabled) {
<span class="p_add">+		mxsfb_enable_axi_clk(host);</span>
 		writel(0, host-&gt;base + LCDC_CTRL);
<span class="p_add">+		mxsfb_disable_axi_clk(host);</span>
 		mxsfb_set_par(fb_info);
 		mxsfb_enable_controller(fb_info);
 	}
<span class="p_chunk">@@ -954,11 +990,15 @@</span> <span class="p_context"> static void mxsfb_shutdown(struct platform_device *pdev)</span>
 	struct fb_info *fb_info = platform_get_drvdata(pdev);
 	struct mxsfb_info *host = to_imxfb_host(fb_info);
 
<span class="p_add">+	mxsfb_enable_axi_clk(host);</span>
<span class="p_add">+</span>
 	/*
 	 * Force stop the LCD controller as keeping it running during reboot
 	 * might interfere with the BootROM&#39;s boot mode pads sampling.
 	 */
 	writel(CTRL_RUN, host-&gt;base + LCDC_CTRL + REG_CLR);
<span class="p_add">+</span>
<span class="p_add">+	mxsfb_disable_axi_clk(host);</span>
 }
 
 static struct platform_driver mxsfb_driver = {
<span class="p_header">diff --git a/drivers/w1/slaves/w1_therm.c b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">index 1f11a20..55eb86c 100644</span>
<span class="p_header">--- a/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">+++ b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_chunk">@@ -59,16 +59,32 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;w1-family-&quot; __stringify(W1_THERM_DS28EA00));</span>
 static int w1_strong_pullup = 1;
 module_param_named(strong_pullup, w1_strong_pullup, int, 0);
 
<span class="p_add">+struct w1_therm_family_data {</span>
<span class="p_add">+	uint8_t rom[9];</span>
<span class="p_add">+	atomic_t refcnt;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* return the address of the refcnt in the family data */</span>
<span class="p_add">+#define THERM_REFCNT(family_data) \</span>
<span class="p_add">+	(&amp;((struct w1_therm_family_data*)family_data)-&gt;refcnt)</span>
<span class="p_add">+</span>
 static int w1_therm_add_slave(struct w1_slave *sl)
 {
<span class="p_del">-	sl-&gt;family_data = kzalloc(9, GFP_KERNEL);</span>
<span class="p_add">+	sl-&gt;family_data = kzalloc(sizeof(struct w1_therm_family_data),</span>
<span class="p_add">+		GFP_KERNEL);</span>
 	if (!sl-&gt;family_data)
 		return -ENOMEM;
<span class="p_add">+	atomic_set(THERM_REFCNT(sl-&gt;family_data), 1);</span>
 	return 0;
 }
 
 static void w1_therm_remove_slave(struct w1_slave *sl)
 {
<span class="p_add">+	int refcnt = atomic_sub_return(1, THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	while(refcnt) {</span>
<span class="p_add">+		msleep(1000);</span>
<span class="p_add">+		refcnt = atomic_read(THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	}</span>
 	kfree(sl-&gt;family_data);
 	sl-&gt;family_data = NULL;
 }
<span class="p_chunk">@@ -194,13 +210,22 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	struct w1_slave *sl = dev_to_w1_slave(device);
 	struct w1_master *dev = sl-&gt;master;
 	u8 rom[9], crc, verdict, external_power;
<span class="p_del">-	int i, max_trying = 10;</span>
<span class="p_add">+	int i, ret, max_trying = 10;</span>
 	ssize_t c = PAGE_SIZE;
<span class="p_add">+	u8 *family_data = sl-&gt;family_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+	if (ret != 0)</span>
<span class="p_add">+		goto post_unlock;</span>
 
<span class="p_del">-	i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-	if (i != 0)</span>
<span class="p_del">-		return i;</span>
<span class="p_add">+	if(!sl-&gt;family_data)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto pre_unlock;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	/* prevent the slave from going away in sleep */</span>
<span class="p_add">+	atomic_inc(THERM_REFCNT(family_data));</span>
 	memset(rom, 0, sizeof(rom));
 
 	while (max_trying--) {
<span class="p_chunk">@@ -230,17 +255,19 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 				mutex_unlock(&amp;dev-&gt;bus_mutex);
 
 				sleep_rem = msleep_interruptible(tm);
<span class="p_del">-				if (sleep_rem != 0)</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+				if (sleep_rem != 0) {</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto post_unlock;</span>
<span class="p_add">+				}</span>
 
<span class="p_del">-				i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-				if (i != 0)</span>
<span class="p_del">-					return i;</span>
<span class="p_add">+				ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+				if (ret != 0)</span>
<span class="p_add">+					goto post_unlock;</span>
 			} else if (!w1_strong_pullup) {
 				sleep_rem = msleep_interruptible(tm);
 				if (sleep_rem != 0) {
<span class="p_del">-					mutex_unlock(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto pre_unlock;</span>
 				}
 			}
 
<span class="p_chunk">@@ -269,19 +296,24 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;: crc=%02x %s\n&quot;,
 			   crc, (verdict) ? &quot;YES&quot; : &quot;NO&quot;);
 	if (verdict)
<span class="p_del">-		memcpy(sl-&gt;family_data, rom, sizeof(rom));</span>
<span class="p_add">+		memcpy(family_data, rom, sizeof(rom));</span>
 	else
 		dev_warn(device, &quot;Read failed CRC check\n&quot;);
 
 	for (i = 0; i &lt; 9; ++i)
 		c -= snprintf(buf + PAGE_SIZE - c, c, &quot;%02x &quot;,
<span class="p_del">-			      ((u8 *)sl-&gt;family_data)[i]);</span>
<span class="p_add">+			      ((u8 *)family_data)[i]);</span>
 
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;t=%d\n&quot;,
 		w1_convert_temp(rom, sl-&gt;family-&gt;fid));
<span class="p_add">+	ret = PAGE_SIZE - c;</span>
<span class="p_add">+</span>
<span class="p_add">+pre_unlock:</span>
 	mutex_unlock(&amp;dev-&gt;bus_mutex);
 
<span class="p_del">-	return PAGE_SIZE - c;</span>
<span class="p_add">+post_unlock:</span>
<span class="p_add">+	atomic_dec(THERM_REFCNT(family_data));</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init w1_therm_init(void)
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 9f2709d..7df4644 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -132,6 +132,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (readl_relaxed(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 334b0a9..0dc23cd 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2406,8 +2406,6 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 		goto out_unlock_inode;
 	}
 
<span class="p_del">-	d_invalidate(dentry);</span>
<span class="p_del">-</span>
 	down_write(&amp;root-&gt;fs_info-&gt;subvol_sem);
 
 	err = may_destroy_subvol(dest);
<span class="p_chunk">@@ -2501,7 +2499,7 @@</span> <span class="p_context"> out_up_write:</span>
 out_unlock_inode:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	if (!err) {
<span class="p_del">-		shrink_dcache_sb(root-&gt;fs_info-&gt;sb);</span>
<span class="p_add">+		d_invalidate(dentry);</span>
 		btrfs_invalidate_inodes(dest);
 		d_delete(dentry);
 		ASSERT(dest-&gt;send_in_progress == 0);
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 6f49b28..a25cb5b 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -1205,7 +1205,9 @@</span> <span class="p_context"> static struct dentry *mount_subvol(const char *subvol_name, int flags,</span>
 				return ERR_CAST(mnt);
 			}
 
<span class="p_add">+			down_write(&amp;mnt-&gt;mnt_sb-&gt;s_umount);</span>
 			r = btrfs_remount(mnt-&gt;mnt_sb, &amp;flags, NULL);
<span class="p_add">+			up_write(&amp;mnt-&gt;mnt_sb-&gt;s_umount);</span>
 			if (r &lt; 0) {
 				/* FIXME: release vfsmount mnt ??*/
 				kfree(newargs);
<span class="p_header">diff --git a/fs/configfs/mount.c b/fs/configfs/mount.c</span>
<span class="p_header">index f6c2858..e9aa820 100644</span>
<span class="p_header">--- a/fs/configfs/mount.c</span>
<span class="p_header">+++ b/fs/configfs/mount.c</span>
<span class="p_chunk">@@ -129,8 +129,6 @@</span> <span class="p_context"> void configfs_release_fs(void)</span>
 }
 
 
<span class="p_del">-static struct kobject *config_kobj;</span>
<span class="p_del">-</span>
 static int __init configfs_init(void)
 {
 	int err = -ENOMEM;
<span class="p_chunk">@@ -141,8 +139,8 @@</span> <span class="p_context"> static int __init configfs_init(void)</span>
 	if (!configfs_dir_cachep)
 		goto out;
 
<span class="p_del">-	config_kobj = kobject_create_and_add(&quot;config&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!config_kobj)</span>
<span class="p_add">+	err = sysfs_create_mount_point(kernel_kobj, &quot;config&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out2;
 
 	err = configfs_inode_init();
<span class="p_chunk">@@ -158,7 +156,7 @@</span> <span class="p_context"> out4:</span>
 	pr_err(&quot;Unable to register filesystem!\n&quot;);
 	configfs_inode_exit();
 out3:
<span class="p_del">-	kobject_put(config_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(kernel_kobj, &quot;config&quot;);</span>
 out2:
 	kmem_cache_destroy(configfs_dir_cachep);
 	configfs_dir_cachep = NULL;
<span class="p_chunk">@@ -169,7 +167,7 @@</span> <span class="p_context"> out:</span>
 static void __exit configfs_exit(void)
 {
 	unregister_filesystem(&amp;configfs_fs_type);
<span class="p_del">-	kobject_put(config_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(kernel_kobj, &quot;config&quot;);</span>
 	kmem_cache_destroy(configfs_dir_cachep);
 	configfs_dir_cachep = NULL;
 	configfs_inode_exit();
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index aa8ff8d..647bb88 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -2788,17 +2788,6 @@</span> <span class="p_context"> restart:</span>
 				vfsmnt = &amp;mnt-&gt;mnt;
 				continue;
 			}
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Filesystems needing to implement special &quot;root names&quot;</span>
<span class="p_del">-			 * should do so with -&gt;d_dname()</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (IS_ROOT(dentry) &amp;&amp;</span>
<span class="p_del">-			   (dentry-&gt;d_name.len != 1 ||</span>
<span class="p_del">-			    dentry-&gt;d_name.name[0] != &#39;/&#39;)) {</span>
<span class="p_del">-				WARN(1, &quot;Root dentry has weird name &lt;%.*s&gt;\n&quot;,</span>
<span class="p_del">-				     (int) dentry-&gt;d_name.len,</span>
<span class="p_del">-				     dentry-&gt;d_name.name);</span>
<span class="p_del">-			}</span>
 			if (!error)
 				error = is_mounted(vfsmnt) ? 1 : 2;
 			break;
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 6f0ce53..efa764c 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -668,20 +668,17 @@</span> <span class="p_context"> bool debugfs_initialized(void)</span>
 }
 EXPORT_SYMBOL_GPL(debugfs_initialized);
 
<span class="p_del">-</span>
<span class="p_del">-static struct kobject *debug_kobj;</span>
<span class="p_del">-</span>
 static int __init debugfs_init(void)
 {
 	int retval;
 
<span class="p_del">-	debug_kobj = kobject_create_and_add(&quot;debug&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!debug_kobj)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	retval = sysfs_create_mount_point(kernel_kobj, &quot;debug&quot;);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		return retval;</span>
 
 	retval = register_filesystem(&amp;debug_fs_type);
 	if (retval)
<span class="p_del">-		kobject_put(debug_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(kernel_kobj, &quot;debug&quot;);</span>
 	else
 		debugfs_registered = true;
 
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 5e7af1c..1136888 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -565,7 +565,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	/* Set up for the direct block allocation */
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 9743a38..bd9967f 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1583,19 +1583,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		BUFFER_TRACE(inode_bh, &quot;get write access&quot;);
 		ret = ext4_journal_get_write_access(handle, inode_bh);
<span class="p_chunk">@@ -1621,6 +1634,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index fc29b2c..e820414 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -822,6 +822,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index f38256e..3602bbd 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1027,6 +1027,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1041,7 +1042,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_chunk">@@ -1239,7 +1239,6 @@</span> <span class="p_context"> static void fuse_fs_cleanup(void)</span>
 }
 
 static struct kobject *fuse_kobj;
<span class="p_del">-static struct kobject *connections_kobj;</span>
 
 static int fuse_sysfs_init(void)
 {
<span class="p_chunk">@@ -1251,11 +1250,9 @@</span> <span class="p_context"> static int fuse_sysfs_init(void)</span>
 		goto out_err;
 	}
 
<span class="p_del">-	connections_kobj = kobject_create_and_add(&quot;connections&quot;, fuse_kobj);</span>
<span class="p_del">-	if (!connections_kobj) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fuse_kobj, &quot;connections&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out_fuse_unregister;
<span class="p_del">-	}</span>
 
 	return 0;
 
<span class="p_chunk">@@ -1267,7 +1264,7 @@</span> <span class="p_context"> static int fuse_sysfs_init(void)</span>
 
 static void fuse_sysfs_cleanup(void)
 {
<span class="p_del">-	kobject_put(connections_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(fuse_kobj, &quot;connections&quot;);</span>
 	kobject_put(fuse_kobj);
 }
 
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index aa149e7..0a733f0 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -1633,8 +1633,8 @@</span> <span class="p_context"> int file_remove_suid(struct file *file)</span>
 		error = security_inode_killpriv(dentry);
 	if (!error &amp;&amp; killsuid)
 		error = __remove_suid(dentry, killsuid);
<span class="p_del">-	if (!error &amp;&amp; (inode-&gt;i_sb-&gt;s_flags &amp; MS_NOSEC))</span>
<span class="p_del">-		inode-&gt;i_flags |= S_NOSEC;</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		inode_has_no_xattr(inode);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 988b32e..4227dc4 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -405,10 +405,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index b96bd80..112fad9 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -885,9 +885,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -897,7 +898,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -913,6 +917,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1331,7 +1338,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1370,7 +1377,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1383,10 +1393,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1395,13 +1406,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1950,7 +1966,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1966,7 +1989,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c</span>
<span class="p_header">index 2d881b3..48ed22d 100644</span>
<span class="p_header">--- a/fs/kernfs/dir.c</span>
<span class="p_header">+++ b/fs/kernfs/dir.c</span>
<span class="p_chunk">@@ -587,6 +587,9 @@</span> <span class="p_context"> int kernfs_add_one(struct kernfs_node *kn)</span>
 		goto out_unlock;
 
 	ret = -ENOENT;
<span class="p_add">+	if (parent-&gt;flags &amp; KERNFS_EMPTY_DIR)</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+</span>
 	if ((parent-&gt;flags &amp; KERNFS_ACTIVATED) &amp;&amp; !kernfs_active(parent))
 		goto out_unlock;
 
<span class="p_chunk">@@ -778,6 +781,38 @@</span> <span class="p_context"> struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,</span>
 	return ERR_PTR(rc);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kernfs_create_empty_dir - create an always empty directory</span>
<span class="p_add">+ * @parent: parent in which to create a new directory</span>
<span class="p_add">+ * @name: name of the new directory</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the created node on success, ERR_PTR() value on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,</span>
<span class="p_add">+					    const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *kn;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* allocate */</span>
<span class="p_add">+	kn = kernfs_new_node(parent, name, S_IRUGO|S_IXUGO|S_IFDIR, KERNFS_DIR);</span>
<span class="p_add">+	if (!kn)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	kn-&gt;flags |= KERNFS_EMPTY_DIR;</span>
<span class="p_add">+	kn-&gt;dir.root = parent-&gt;dir.root;</span>
<span class="p_add">+	kn-&gt;ns = NULL;</span>
<span class="p_add">+	kn-&gt;priv = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* link in */</span>
<span class="p_add">+	rc = kernfs_add_one(kn);</span>
<span class="p_add">+	if (!rc)</span>
<span class="p_add">+		return kn;</span>
<span class="p_add">+</span>
<span class="p_add">+	kernfs_put(kn);</span>
<span class="p_add">+	return ERR_PTR(rc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dentry *kernfs_iop_lookup(struct inode *dir,
 					struct dentry *dentry,
 					unsigned int flags)
<span class="p_chunk">@@ -1249,7 +1284,8 @@</span> <span class="p_context"> int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,</span>
 	mutex_lock(&amp;kernfs_mutex);
 
 	error = -ENOENT;
<span class="p_del">-	if (!kernfs_active(kn) || !kernfs_active(new_parent))</span>
<span class="p_add">+	if (!kernfs_active(kn) || !kernfs_active(new_parent) ||</span>
<span class="p_add">+	    (new_parent-&gt;flags &amp; KERNFS_EMPTY_DIR))</span>
 		goto out;
 
 	error = 0;
<span class="p_header">diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c</span>
<span class="p_header">index 9852176..5b8ab29 100644</span>
<span class="p_header">--- a/fs/kernfs/inode.c</span>
<span class="p_header">+++ b/fs/kernfs/inode.c</span>
<span class="p_chunk">@@ -309,6 +309,8 @@</span> <span class="p_context"> static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)</span>
 	case KERNFS_DIR:
 		inode-&gt;i_op = &amp;kernfs_dir_iops;
 		inode-&gt;i_fop = &amp;kernfs_dir_fops;
<span class="p_add">+		if (kn-&gt;flags &amp; KERNFS_EMPTY_DIR)</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
 		break;
 	case KERNFS_FILE:
 		inode-&gt;i_size = kn-&gt;attr.size;
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index 005843c..e5dc742 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -1093,3 +1093,99 @@</span> <span class="p_context"> simple_nosetlease(struct file *filp, long arg, struct file_lock **flp,</span>
 	return -EINVAL;
 }
 EXPORT_SYMBOL(simple_nosetlease);
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Operations for a permanently empty directory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOENT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,</span>
<span class="p_add">+				 struct kstat *stat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = d_inode(dentry);</span>
<span class="p_add">+	generic_fillattr(inode, stat);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_setattr(struct dentry *dentry, struct iattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EPERM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_setxattr(struct dentry *dentry, const char *name,</span>
<span class="p_add">+			      const void *value, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t empty_dir_getxattr(struct dentry *dentry, const char *name,</span>
<span class="p_add">+				  void *value, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_removexattr(struct dentry *dentry, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct inode_operations empty_dir_inode_operations = {</span>
<span class="p_add">+	.lookup		= empty_dir_lookup,</span>
<span class="p_add">+	.permission	= generic_permission,</span>
<span class="p_add">+	.setattr	= empty_dir_setattr,</span>
<span class="p_add">+	.getattr	= empty_dir_getattr,</span>
<span class="p_add">+	.setxattr	= empty_dir_setxattr,</span>
<span class="p_add">+	.getxattr	= empty_dir_getxattr,</span>
<span class="p_add">+	.removexattr	= empty_dir_removexattr,</span>
<span class="p_add">+	.listxattr	= empty_dir_listxattr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* An empty directory has two entries . and .. at offsets 0 and 1 */</span>
<span class="p_add">+	return generic_file_llseek_size(file, offset, whence, 2, 2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_readdir(struct file *file, struct dir_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir_emit_dots(file, ctx);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct file_operations empty_dir_operations = {</span>
<span class="p_add">+	.llseek		= empty_dir_llseek,</span>
<span class="p_add">+	.read		= generic_read_dir,</span>
<span class="p_add">+	.iterate	= empty_dir_readdir,</span>
<span class="p_add">+	.fsync		= noop_fsync,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void make_empty_dir_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_nlink(inode, 2);</span>
<span class="p_add">+	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	inode-&gt;i_uid = GLOBAL_ROOT_UID;</span>
<span class="p_add">+	inode-&gt;i_gid = GLOBAL_ROOT_GID;</span>
<span class="p_add">+	inode-&gt;i_rdev = 0;</span>
<span class="p_add">+	inode-&gt;i_size = 2;</span>
<span class="p_add">+	inode-&gt;i_blkbits = PAGE_SHIFT;</span>
<span class="p_add">+	inode-&gt;i_blocks = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode-&gt;i_op = &amp;empty_dir_inode_operations;</span>
<span class="p_add">+	inode-&gt;i_fop = &amp;empty_dir_operations;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_empty_dir_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (inode-&gt;i_fop == &amp;empty_dir_operations) &amp;&amp;</span>
<span class="p_add">+		(inode-&gt;i_op == &amp;empty_dir_inode_operations);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 8129c51..e9b5687 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -2293,6 +2293,8 @@</span> <span class="p_context"> unlock:</span>
 	return err;
 }
 
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *fs_type, int *new_mnt_flags);</span>
<span class="p_add">+</span>
 /*
  * create a new mount for userspace and request it to be added into the
  * namespace&#39;s tree
<span class="p_chunk">@@ -2324,6 +2326,10 @@</span> <span class="p_context"> static int do_new_mount(struct path *path, const char *fstype, int flags,</span>
 			flags |= MS_NODEV;
 			mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;
 		}
<span class="p_add">+		if (type-&gt;fs_flags &amp; FS_USERNS_VISIBLE) {</span>
<span class="p_add">+			if (!fs_fully_visible(type, &amp;mnt_flags))</span>
<span class="p_add">+				return -EPERM;</span>
<span class="p_add">+		}</span>
 	}
 
 	mnt = vfs_kern_mount(type, flags, name, data);
<span class="p_chunk">@@ -3125,9 +3131,10 @@</span> <span class="p_context"> bool current_chrooted(void)</span>
 	return chrooted;
 }
 
<span class="p_del">-bool fs_fully_visible(struct file_system_type *type)</span>
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *type, int *new_mnt_flags)</span>
 {
 	struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns;
<span class="p_add">+	int new_flags = *new_mnt_flags;</span>
 	struct mount *mnt;
 	bool visible = false;
 
<span class="p_chunk">@@ -3146,16 +3153,36 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)
 			continue;
 
<span class="p_del">-		/* This mount is not fully visible if there are any child mounts</span>
<span class="p_del">-		 * that cover anything except for empty directories.</span>
<span class="p_add">+		/* Verify the mount flags are equal to or more permissive</span>
<span class="p_add">+		 * than the proposed new mount.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_READONLY))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_NODEV) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_NODEV))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp;</span>
<span class="p_add">+		    ((mnt-&gt;mnt.mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* This mount is not fully visible if there are any</span>
<span class="p_add">+		 * locked child mounts that cover anything except for</span>
<span class="p_add">+		 * empty directories.</span>
 		 */
 		list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) {
 			struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode;
<span class="p_del">-			if (!S_ISDIR(inode-&gt;i_mode))</span>
<span class="p_del">-				goto next;</span>
<span class="p_del">-			if (inode-&gt;i_nlink &gt; 2)</span>
<span class="p_add">+			/* Only worry about locked mounts */</span>
<span class="p_add">+			if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			/* Is the directory permanetly empty? */</span>
<span class="p_add">+			if (!is_empty_dir_inode(inode))</span>
 				goto next;
 		}
<span class="p_add">+		/* Preserve the locked attributes */</span>
<span class="p_add">+		*new_mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; (MNT_LOCK_READONLY | \</span>
<span class="p_add">+							MNT_LOCK_NODEV    | \</span>
<span class="p_add">+							MNT_LOCK_ATIME);</span>
 		visible = true;
 		goto found;
 	next:	;
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index 8f4cbe7..53853ca 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 5194933..1f9d57a 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1455,6 +1455,8 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 883ee88..354f666 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1535,6 +1535,7 @@</span> <span class="p_context"> int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)</span>
 	/* Resend all requests through the MDS */
 	nfs_pageio_init_write(&amp;pgio, hdr-&gt;inode, FLUSH_STABLE, true,
 			      hdr-&gt;completion_ops);
<span class="p_add">+	set_bit(NFS_CONTEXT_RESEND_WRITES, &amp;hdr-&gt;args.context-&gt;flags);</span>
 	return nfs_pageio_resend(&amp;pgio, hdr);
 }
 EXPORT_SYMBOL_GPL(pnfs_write_done_resend_to_mds);
<span class="p_chunk">@@ -1576,6 +1577,7 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		desc-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 static enum pnfs_try_status
<span class="p_chunk">@@ -1692,6 +1694,7 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		desc-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index d489ff3..64b0b54 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1259,6 +1259,7 @@</span> <span class="p_context"> static void nfs_initiate_write(struct nfs_pgio_header *hdr,</span>
 static void nfs_redirty_request(struct nfs_page *req)
 {
 	nfs_mark_request_dirty(req);
<span class="p_add">+	set_bit(NFS_CONTEXT_RESEND_WRITES, &amp;req-&gt;wb_context-&gt;flags);</span>
 	nfs_unlock_request(req);
 	nfs_end_page_writeback(req);
 	nfs_release_request(req);
<span class="p_header">diff --git a/fs/proc/generic.c b/fs/proc/generic.c</span>
<span class="p_header">index b502bba..e0d13cb 100644</span>
<span class="p_header">--- a/fs/proc/generic.c</span>
<span class="p_header">+++ b/fs/proc/generic.c</span>
<span class="p_chunk">@@ -390,6 +390,10 @@</span> <span class="p_context"> static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,</span>
 		WARN(1, &quot;create &#39;/proc/%s&#39; by hand\n&quot;, qstr.name);
 		return NULL;
 	}
<span class="p_add">+	if (is_empty_pde(*parent)) {</span>
<span class="p_add">+		WARN(1, &quot;attempt to add to permanently empty directory&quot;);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 
 	ent = kzalloc(sizeof(struct proc_dir_entry) + qstr.len + 1, GFP_KERNEL);
 	if (!ent)
<span class="p_chunk">@@ -467,6 +471,25 @@</span> <span class="p_context"> struct proc_dir_entry *proc_mkdir(const char *name,</span>
 }
 EXPORT_SYMBOL(proc_mkdir);
 
<span class="p_add">+struct proc_dir_entry *proc_create_mount_point(const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	struct proc_dir_entry *ent, *parent = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ent = __proc_create(&amp;parent, name, mode, 2);</span>
<span class="p_add">+	if (ent) {</span>
<span class="p_add">+		ent-&gt;data = NULL;</span>
<span class="p_add">+		ent-&gt;proc_fops = NULL;</span>
<span class="p_add">+		ent-&gt;proc_iops = NULL;</span>
<span class="p_add">+		if (proc_register(parent, ent) &lt; 0) {</span>
<span class="p_add">+			kfree(ent);</span>
<span class="p_add">+			parent-&gt;nlink--;</span>
<span class="p_add">+			ent = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ent;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
 					struct proc_dir_entry *parent,
 					const struct file_operations *proc_fops,
<span class="p_header">diff --git a/fs/proc/inode.c b/fs/proc/inode.c</span>
<span class="p_header">index 3b0f838..0612570 100644</span>
<span class="p_header">--- a/fs/proc/inode.c</span>
<span class="p_header">+++ b/fs/proc/inode.c</span>
<span class="p_chunk">@@ -423,6 +423,10 @@</span> <span class="p_context"> struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)</span>
 		inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
 		PROC_I(inode)-&gt;pde = de;
 
<span class="p_add">+		if (is_empty_pde(de)) {</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
<span class="p_add">+			return inode;</span>
<span class="p_add">+		}</span>
 		if (de-&gt;mode) {
 			inode-&gt;i_mode = de-&gt;mode;
 			inode-&gt;i_uid = de-&gt;uid;
<span class="p_header">diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="p_header">index c835b94..aa27810 100644</span>
<span class="p_header">--- a/fs/proc/internal.h</span>
<span class="p_header">+++ b/fs/proc/internal.h</span>
<span class="p_chunk">@@ -191,6 +191,12 @@</span> <span class="p_context"> static inline struct proc_dir_entry *pde_get(struct proc_dir_entry *pde)</span>
 }
 extern void pde_put(struct proc_dir_entry *);
 
<span class="p_add">+static inline bool is_empty_pde(const struct proc_dir_entry *pde)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return S_ISDIR(pde-&gt;mode) &amp;&amp; !pde-&gt;proc_iops;</span>
<span class="p_add">+}</span>
<span class="p_add">+struct proc_dir_entry *proc_create_mount_point(const char *name);</span>
<span class="p_add">+</span>
 /*
  * inode.c
  */
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index f92d5dd..3f7dc3e 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -19,6 +19,28 @@</span> <span class="p_context"> static const struct inode_operations proc_sys_inode_operations;</span>
 static const struct file_operations proc_sys_dir_file_operations;
 static const struct inode_operations proc_sys_dir_operations;
 
<span class="p_add">+/* Support for permanently empty directories */</span>
<span class="p_add">+</span>
<span class="p_add">+struct ctl_table sysctl_mount_point[] = {</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static bool is_empty_dir(struct ctl_table_header *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return head-&gt;ctl_table[0].child == sysctl_mount_point;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void set_empty_dir(struct ctl_dir *dir)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir-&gt;header.ctl_table[0].child = sysctl_mount_point;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void clear_empty_dir(struct ctl_dir *dir)</span>
<span class="p_add">+</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir-&gt;header.ctl_table[0].child = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void proc_sys_poll_notify(struct ctl_table_poll *poll)
 {
 	if (!poll)
<span class="p_chunk">@@ -187,6 +209,17 @@</span> <span class="p_context"> static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)</span>
 	struct ctl_table *entry;
 	int err;
 
<span class="p_add">+	/* Is this a permanently empty directory? */</span>
<span class="p_add">+	if (is_empty_dir(&amp;dir-&gt;header))</span>
<span class="p_add">+		return -EROFS;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Am I creating a permanently empty directory? */</span>
<span class="p_add">+	if (header-&gt;ctl_table == sysctl_mount_point) {</span>
<span class="p_add">+		if (!RB_EMPTY_ROOT(&amp;dir-&gt;root))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		set_empty_dir(dir);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dir-&gt;header.nreg++;
 	header-&gt;parent = dir;
 	err = insert_links(header);
<span class="p_chunk">@@ -202,6 +235,8 @@</span> <span class="p_context"> fail:</span>
 	erase_header(header);
 	put_links(header);
 fail_links:
<span class="p_add">+	if (header-&gt;ctl_table == sysctl_mount_point)</span>
<span class="p_add">+		clear_empty_dir(dir);</span>
 	header-&gt;parent = NULL;
 	drop_sysctl_table(&amp;dir-&gt;header);
 	return err;
<span class="p_chunk">@@ -419,6 +454,8 @@</span> <span class="p_context"> static struct inode *proc_sys_make_inode(struct super_block *sb,</span>
 		inode-&gt;i_mode |= S_IFDIR;
 		inode-&gt;i_op = &amp;proc_sys_dir_operations;
 		inode-&gt;i_fop = &amp;proc_sys_dir_file_operations;
<span class="p_add">+		if (is_empty_dir(head))</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
 	}
 out:
 	return inode;
<span class="p_header">diff --git a/fs/proc/root.c b/fs/proc/root.c</span>
<span class="p_header">index e74ac9f..6934ce8 100644</span>
<span class="p_header">--- a/fs/proc/root.c</span>
<span class="p_header">+++ b/fs/proc/root.c</span>
<span class="p_chunk">@@ -112,9 +112,6 @@</span> <span class="p_context"> static struct dentry *proc_mount(struct file_system_type *fs_type,</span>
 		ns = task_active_pid_ns(current);
 		options = data;
 
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		/* Does the mounter have privilege over the pid namespace? */
 		if (!ns_capable(ns-&gt;user_ns, CAP_SYS_ADMIN))
 			return ERR_PTR(-EPERM);
<span class="p_chunk">@@ -159,7 +156,7 @@</span> <span class="p_context"> static struct file_system_type proc_fs_type = {</span>
 	.name		= &quot;proc&quot;,
 	.mount		= proc_mount,
 	.kill_sb	= proc_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 void __init proc_root_init(void)
<span class="p_chunk">@@ -182,10 +179,10 @@</span> <span class="p_context"> void __init proc_root_init(void)</span>
 #endif
 	proc_mkdir(&quot;fs&quot;, NULL);
 	proc_mkdir(&quot;driver&quot;, NULL);
<span class="p_del">-	proc_mkdir(&quot;fs/nfsd&quot;, NULL); /* somewhere for the nfsd filesystem to be mounted */</span>
<span class="p_add">+	proc_create_mount_point(&quot;fs/nfsd&quot;); /* somewhere for the nfsd filesystem to be mounted */</span>
 #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)
 	/* just give it a mountpoint */
<span class="p_del">-	proc_mkdir(&quot;openprom&quot;, NULL);</span>
<span class="p_add">+	proc_create_mount_point(&quot;openprom&quot;);</span>
 #endif
 	proc_tty_init();
 	proc_mkdir(&quot;bus&quot;, NULL);
<span class="p_header">diff --git a/fs/pstore/inode.c b/fs/pstore/inode.c</span>
<span class="p_header">index 5041660..b356efc 100644</span>
<span class="p_header">--- a/fs/pstore/inode.c</span>
<span class="p_header">+++ b/fs/pstore/inode.c</span>
<span class="p_chunk">@@ -452,22 +452,18 @@</span> <span class="p_context"> static struct file_system_type pstore_fs_type = {</span>
 	.kill_sb	= pstore_kill_sb,
 };
 
<span class="p_del">-static struct kobject *pstore_kobj;</span>
<span class="p_del">-</span>
 static int __init init_pstore_fs(void)
 {
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int err;</span>
 
 	/* Create a convenient mount point for people to access pstore */
<span class="p_del">-	pstore_kobj = kobject_create_and_add(&quot;pstore&quot;, fs_kobj);</span>
<span class="p_del">-	if (!pstore_kobj) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;pstore&quot;);</span>
<span class="p_add">+	if (err)</span>
 		goto out;
<span class="p_del">-	}</span>
 
 	err = register_filesystem(&amp;pstore_fs_type);
 	if (err &lt; 0)
<span class="p_del">-		kobject_put(pstore_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;pstore&quot;);</span>
 
 out:
 	return err;
<span class="p_header">diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c</span>
<span class="p_header">index 0b45ff4..94374e4 100644</span>
<span class="p_header">--- a/fs/sysfs/dir.c</span>
<span class="p_header">+++ b/fs/sysfs/dir.c</span>
<span class="p_chunk">@@ -121,3 +121,37 @@</span> <span class="p_context"> int sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,</span>
 
 	return kernfs_rename_ns(kn, new_parent, kn-&gt;name, new_ns);
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * sysfs_create_mount_point - create an always empty directory</span>
<span class="p_add">+ * @parent_kobj:  kobject that will contain this always empty directory</span>
<span class="p_add">+ * @name: The name of the always empty directory to add</span>
<span class="p_add">+ */</span>
<span class="p_add">+int sysfs_create_mount_point(struct kobject *parent_kobj, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *kn, *parent = parent_kobj-&gt;sd;</span>
<span class="p_add">+</span>
<span class="p_add">+	kn = kernfs_create_empty_dir(parent, name);</span>
<span class="p_add">+	if (IS_ERR(kn)) {</span>
<span class="p_add">+		if (PTR_ERR(kn) == -EEXIST)</span>
<span class="p_add">+			sysfs_warn_dup(parent, name);</span>
<span class="p_add">+		return PTR_ERR(kn);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sysfs_create_mount_point);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ *	sysfs_remove_mount_point - remove an always empty directory.</span>
<span class="p_add">+ *	@parent_kobj: kobject that will contain this always empty directory</span>
<span class="p_add">+ *	@name: The name of the always empty directory to remove</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+void sysfs_remove_mount_point(struct kobject *parent_kobj, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *parent = parent_kobj-&gt;sd;</span>
<span class="p_add">+</span>
<span class="p_add">+	kernfs_remove_by_name_ns(parent, name, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sysfs_remove_mount_point);</span>
<span class="p_header">diff --git a/fs/sysfs/mount.c b/fs/sysfs/mount.c</span>
<span class="p_header">index 8a49486..1c6ac6f 100644</span>
<span class="p_header">--- a/fs/sysfs/mount.c</span>
<span class="p_header">+++ b/fs/sysfs/mount.c</span>
<span class="p_chunk">@@ -31,9 +31,6 @@</span> <span class="p_context"> static struct dentry *sysfs_mount(struct file_system_type *fs_type,</span>
 	bool new_sb;
 
 	if (!(flags &amp; MS_KERNMOUNT)) {
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		if (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))
 			return ERR_PTR(-EPERM);
 	}
<span class="p_chunk">@@ -58,7 +55,7 @@</span> <span class="p_context"> static struct file_system_type sysfs_fs_type = {</span>
 	.name		= &quot;sysfs&quot;,
 	.mount		= sysfs_mount,
 	.kill_sb	= sysfs_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 int __init sysfs_init(void)
<span class="p_header">diff --git a/fs/ufs/balloc.c b/fs/ufs/balloc.c</span>
<span class="p_header">index 2c10360..a7106ed 100644</span>
<span class="p_header">--- a/fs/ufs/balloc.c</span>
<span class="p_header">+++ b/fs/ufs/balloc.c</span>
<span class="p_chunk">@@ -51,8 +51,8 @@</span> <span class="p_context"> void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)</span>
 	
 	if (ufs_fragnum(fragment) + count &gt; uspi-&gt;s_fpg)
 		ufs_error (sb, &quot;ufs_free_fragments&quot;, &quot;internal error&quot;);
<span class="p_del">-	</span>
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	
 	cgno = ufs_dtog(uspi, fragment);
 	bit = ufs_dtogd(uspi, fragment);
<span class="p_chunk">@@ -115,13 +115,13 @@</span> <span class="p_context"> void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)</span>
 	if (sb-&gt;s_flags &amp; MS_SYNCHRONOUS)
 		ubh_sync_block(UCPI_UBH(ucpi));
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	</span>
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 	return;
 
 failed:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return;
 }
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)</span>
 		goto failed;
 	}
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	
 do_more:
 	overflow = 0;
<span class="p_chunk">@@ -211,12 +211,12 @@</span> <span class="p_context"> do_more:</span>
 	}
 
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 	return;
 
 failed_unlock:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 failed:
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return;
<span class="p_chunk">@@ -357,7 +357,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 	usb1 = ubh_get_usb_first(uspi);
 	*err = -ENOSPC;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 
 	if (count + ufs_fragnum(fragment) &gt; uspi-&gt;s_fpb) {
<span class="p_chunk">@@ -378,19 +378,19 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 				  &quot;fragment %llu, tmp %llu\n&quot;,
 				  (unsigned long long)fragment,
 				  (unsigned long long)tmp);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return INVBLOCK;
 		}
 		if (fragment &lt; UFS_I(inode)-&gt;i_lastfrag) {
 			UFSD(&quot;EXIT (ALREADY ALLOCATED)\n&quot;);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return 0;
 		}
 	}
 	else {
 		if (tmp) {
 			UFSD(&quot;EXIT (ALREADY ALLOCATED)\n&quot;);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return 0;
 		}
 	}
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 	 * There is not enough space for user on the device
 	 */
 	if (!capable(CAP_SYS_RESOURCE) &amp;&amp; ufs_freespace(uspi, UFS_MINFREE) &lt;= 0) {
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT (FAILED)\n&quot;);
 		return 0;
 	}
<span class="p_chunk">@@ -424,7 +424,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 			ufs_clear_frags(inode, result + oldcount,
 					newcount - oldcount, locked_page != NULL);
 		}
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT, result %llu\n&quot;, (unsigned long long)result);
 		return result;
 	}
<span class="p_chunk">@@ -439,7 +439,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 						fragment + count);
 		ufs_clear_frags(inode, result + oldcount, newcount - oldcount,
 				locked_page != NULL);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT, result %llu\n&quot;, (unsigned long long)result);
 		return result;
 	}
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 		*err = 0;
 		UFS_I(inode)-&gt;i_lastfrag = max(UFS_I(inode)-&gt;i_lastfrag,
 						fragment + count);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		if (newcount &lt; request)
 			ufs_free_fragments (inode, result + newcount, request - newcount);
 		ufs_free_fragments (inode, tmp, oldcount);
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 		return result;
 	}
 
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return 0;
 }		
<span class="p_header">diff --git a/fs/ufs/ialloc.c b/fs/ufs/ialloc.c</span>
<span class="p_header">index 7caa016..fd0203c 100644</span>
<span class="p_header">--- a/fs/ufs/ialloc.c</span>
<span class="p_header">+++ b/fs/ufs/ialloc.c</span>
<span class="p_chunk">@@ -69,11 +69,11 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 	
 	ino = inode-&gt;i_ino;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 
 	if (!((ino &gt; 1) &amp;&amp; (ino &lt; (uspi-&gt;s_ncg * uspi-&gt;s_ipg )))) {
 		ufs_warning(sb, &quot;ufs_free_inode&quot;, &quot;reserved inode or nonexistent inode %u\n&quot;, ino);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		return;
 	}
 	
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 	bit = ufs_inotocgoff (ino);
 	ucpi = ufs_load_cylinder (sb, cg);
 	if (!ucpi) {
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		return;
 	}
 	ucg = ubh_get_ucg(UCPI_UBH(ucpi));
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 		ubh_sync_block(UCPI_UBH(ucpi));
 	
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 }
 
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> struct inode *ufs_new_inode(struct inode *dir, umode_t mode)</span>
 	sbi = UFS_SB(sb);
 	uspi = sbi-&gt;s_uspi;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;sbi-&gt;s_lock);</span>
 
 	/*
 	 * Try to place the inode in its parent directory
<span class="p_chunk">@@ -331,21 +331,21 @@</span> <span class="p_context"> cg_found:</span>
 			sync_dirty_buffer(bh);
 		brelse(bh);
 	}
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 
 	UFSD(&quot;allocating inode %lu\n&quot;, inode-&gt;i_ino);
 	UFSD(&quot;EXIT\n&quot;);
 	return inode;
 
 fail_remove_inode:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 	clear_nlink(inode);
 	unlock_new_inode(inode);
 	iput(inode);
 	UFSD(&quot;EXIT (FAILED): err %d\n&quot;, err);
 	return ERR_PTR(err);
 failed:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 	make_bad_inode(inode);
 	iput (inode);
 	UFSD(&quot;EXIT (FAILED): err %d\n&quot;, err);
<span class="p_header">diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c</span>
<span class="p_header">index be7d42c..2d93ab0 100644</span>
<span class="p_header">--- a/fs/ufs/inode.c</span>
<span class="p_header">+++ b/fs/ufs/inode.c</span>
<span class="p_chunk">@@ -902,6 +902,9 @@</span> <span class="p_context"> void ufs_evict_inode(struct inode * inode)</span>
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
<span class="p_del">-	if (want_delete)</span>
<span class="p_add">+	if (want_delete) {</span>
<span class="p_add">+		lock_ufs(inode-&gt;i_sb);</span>
 		ufs_free_inode(inode);
<span class="p_add">+		unlock_ufs(inode-&gt;i_sb);</span>
<span class="p_add">+	}</span>
 }
<span class="p_header">diff --git a/fs/ufs/namei.c b/fs/ufs/namei.c</span>
<span class="p_header">index fd65deb..73644c6 100644</span>
<span class="p_header">--- a/fs/ufs/namei.c</span>
<span class="p_header">+++ b/fs/ufs/namei.c</span>
<span class="p_chunk">@@ -128,12 +128,12 @@</span> <span class="p_context"> static int ufs_symlink (struct inode * dir, struct dentry * dentry,</span>
 	if (l &gt; sb-&gt;s_blocksize)
 		goto out_notlocked;
 
<span class="p_add">+	lock_ufs(dir-&gt;i_sb);</span>
 	inode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
<span class="p_del">-		goto out_notlocked;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	lock_ufs(dir-&gt;i_sb);</span>
 	if (l &gt; UFS_SB(sb)-&gt;s_uspi-&gt;s_maxsymlinklen) {
 		/* slow symlink */
 		inode-&gt;i_op = &amp;ufs_symlink_inode_operations;
<span class="p_chunk">@@ -184,9 +184,13 @@</span> <span class="p_context"> static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)</span>
 	struct inode * inode;
 	int err;
 
<span class="p_add">+	lock_ufs(dir-&gt;i_sb);</span>
<span class="p_add">+	inode_inc_link_count(dir);</span>
<span class="p_add">+</span>
 	inode = ufs_new_inode(dir, S_IFDIR|mode);
<span class="p_add">+	err = PTR_ERR(inode);</span>
 	if (IS_ERR(inode))
<span class="p_del">-		return PTR_ERR(inode);</span>
<span class="p_add">+		goto out_dir;</span>
 
 	inode-&gt;i_op = &amp;ufs_dir_inode_operations;
 	inode-&gt;i_fop = &amp;ufs_dir_operations;
<span class="p_chunk">@@ -194,9 +198,6 @@</span> <span class="p_context"> static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)</span>
 
 	inode_inc_link_count(inode);
 
<span class="p_del">-	lock_ufs(dir-&gt;i_sb);</span>
<span class="p_del">-	inode_inc_link_count(dir);</span>
<span class="p_del">-</span>
 	err = ufs_make_empty(inode, dir);
 	if (err)
 		goto out_fail;
<span class="p_chunk">@@ -206,6 +207,7 @@</span> <span class="p_context"> static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)</span>
 		goto out_fail;
 	unlock_ufs(dir-&gt;i_sb);
 
<span class="p_add">+	unlock_new_inode(inode);</span>
 	d_instantiate(dentry, inode);
 out:
 	return err;
<span class="p_chunk">@@ -215,6 +217,7 @@</span> <span class="p_context"> out_fail:</span>
 	inode_dec_link_count(inode);
 	unlock_new_inode(inode);
 	iput (inode);
<span class="p_add">+out_dir:</span>
 	inode_dec_link_count(dir);
 	unlock_ufs(dir-&gt;i_sb);
 	goto out;
<span class="p_header">diff --git a/fs/ufs/super.c b/fs/ufs/super.c</span>
<span class="p_header">index da73801..aa7d50b 100644</span>
<span class="p_header">--- a/fs/ufs/super.c</span>
<span class="p_header">+++ b/fs/ufs/super.c</span>
<span class="p_chunk">@@ -698,6 +698,7 @@</span> <span class="p_context"> static int ufs_sync_fs(struct super_block *sb, int wait)</span>
 	unsigned flags;
 
 	lock_ufs(sb);
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 
 	UFSD(&quot;ENTER\n&quot;);
 
<span class="p_chunk">@@ -715,6 +716,7 @@</span> <span class="p_context"> static int ufs_sync_fs(struct super_block *sb, int wait)</span>
 	ufs_put_cstotal(sb);
 
 	UFSD(&quot;EXIT\n&quot;);
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	unlock_ufs(sb);
 
 	return 0;
<span class="p_chunk">@@ -1281,6 +1283,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 
 	sync_filesystem(sb);
 	lock_ufs(sb);
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	uspi = UFS_SB(sb)-&gt;s_uspi;
 	flags = UFS_SB(sb)-&gt;s_flags;
 	usb1 = ubh_get_usb_first(uspi);
<span class="p_chunk">@@ -1294,6 +1297,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 	new_mount_opt = 0;
 	ufs_set_opt (new_mount_opt, ONERROR_LOCK);
 	if (!ufs_parse_options (data, &amp;new_mount_opt)) {
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1301,12 +1305,14 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 		new_mount_opt |= ufstype;
 	} else if ((new_mount_opt &amp; UFS_MOUNT_UFSTYPE) != ufstype) {
 		pr_err(&quot;ufstype can&#39;t be changed during remount\n&quot;);
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 	}
 
 	if ((*mount_flags &amp; MS_RDONLY) == (sb-&gt;s_flags &amp; MS_RDONLY)) {
 		UFS_SB(sb)-&gt;s_mount_opt = new_mount_opt;
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return 0;
 	}
<span class="p_chunk">@@ -1330,6 +1336,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 	 */
 #ifndef CONFIG_UFS_FS_WRITE
 		pr_err(&quot;ufs was compiled with read-only support, can&#39;t be mounted as read-write\n&quot;);
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 #else
<span class="p_chunk">@@ -1339,11 +1346,13 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 		    ufstype != UFS_MOUNT_UFSTYPE_SUNx86 &amp;&amp;
 		    ufstype != UFS_MOUNT_UFSTYPE_UFS2) {
 			pr_err(&quot;this ufstype is read-only supported\n&quot;);
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			unlock_ufs(sb);
 			return -EINVAL;
 		}
 		if (!ufs_read_cylinder_structures(sb)) {
 			pr_err(&quot;failed during remounting\n&quot;);
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			unlock_ufs(sb);
 			return -EPERM;
 		}
<span class="p_chunk">@@ -1351,6 +1360,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 #endif
 	}
 	UFS_SB(sb)-&gt;s_mount_opt = new_mount_opt;
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	unlock_ufs(sb);
 	return 0;
 }
<span class="p_header">diff --git a/fs/ufs/ufs.h b/fs/ufs/ufs.h</span>
<span class="p_header">index 2a07396..cf6368d 100644</span>
<span class="p_header">--- a/fs/ufs/ufs.h</span>
<span class="p_header">+++ b/fs/ufs/ufs.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> struct ufs_sb_info {</span>
 	int work_queued; /* non-zero if the delayed work is queued */
 	struct delayed_work sync_work; /* FS sync delayed work */
 	spinlock_t work_lock; /* protects sync_work and work_queued */
<span class="p_add">+	struct mutex s_lock;</span>
 };
 
 struct ufs_inode_info {
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index 25791df..e0b50ed 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index 5ba7846..44c23f4 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -195,9 +195,18 @@</span> <span class="p_context"> ACPI_INIT_GLOBAL(u8, acpi_gbl_do_not_use_xsdt, FALSE);</span>
  * address. Although ACPICA adheres to the ACPI specification which
  * requires the use of the corresponding 64-bit address if it is non-zero,
  * some machines have been found to have a corrupted non-zero 64-bit
<span class="p_del">- * address. Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ * address. Default is FALSE, do not favor the 32-bit addresses.</span>
  */
<span class="p_del">-ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, TRUE);</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, FALSE);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Optionally use 32-bit FACS table addresses.</span>
<span class="p_add">+ * It is reported that some platforms fail to resume from system suspending</span>
<span class="p_add">+ * if 64-bit FACS table address is selected:</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=74021</span>
<span class="p_add">+ * Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_facs_addresses, TRUE);</span>
 
 /*
  * Optionally truncate I/O addresses to 16 bits. Provides compatibility
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 9f2847c..803f940 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -573,6 +573,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h</span>
<span class="p_header">index b863298..3dab77c 100644</span>
<span class="p_header">--- a/include/drm/drm_crtc.h</span>
<span class="p_header">+++ b/include/drm/drm_crtc.h</span>
<span class="p_chunk">@@ -689,6 +689,8 @@</span> <span class="p_context"> struct drm_connector {</span>
 	uint8_t num_h_tile, num_v_tile;
 	uint8_t tile_h_loc, tile_v_loc;
 	uint16_t tile_h_size, tile_v_size;
<span class="p_add">+</span>
<span class="p_add">+	struct list_head destroy_list;</span>
 };
 
 /**
<span class="p_header">diff --git a/include/drm/drm_dp_mst_helper.h b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">index 00c1da9..180f8a3 100644</span>
<span class="p_header">--- a/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">+++ b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_chunk">@@ -463,6 +463,10 @@</span> <span class="p_context"> struct drm_dp_mst_topology_mgr {</span>
 	struct work_struct work;
 
 	struct work_struct tx_work;
<span class="p_add">+</span>
<span class="p_add">+	struct list_head destroy_connector_list;</span>
<span class="p_add">+	struct mutex destroy_connector_lock;</span>
<span class="p_add">+	struct work_struct destroy_connector_work;</span>
 };
 
 int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr, struct device *dev, struct drm_dp_aux *aux, int max_dpcd_transaction_bytes, int max_payloads, int conn_base_id);
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index d459cd1..2799d36 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -312,6 +312,9 @@</span> <span class="p_context"> int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 
 int acpi_resources_are_enforced(void);
 
<span class="p_add">+int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_add">+			unsigned long flags, char *desc);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_HIBERNATION
 void __init acpi_no_s4_hw_signature(void);
 #endif
<span class="p_chunk">@@ -420,6 +423,7 @@</span> <span class="p_context"> extern acpi_status acpi_pci_osc_control_set(acpi_handle handle,</span>
 #define ACPI_OST_SC_INSERT_NOT_SUPPORTED	0x82
 
 extern void acpi_early_init(void);
<span class="p_add">+extern void acpi_subsystem_init(void);</span>
 
 extern int acpi_nvs_register(__u64 start, __u64 size);
 
<span class="p_chunk">@@ -469,6 +473,7 @@</span> <span class="p_context"> static inline const char *acpi_dev_name(struct acpi_device *adev)</span>
 }
 
 static inline void acpi_early_init(void) { }
<span class="p_add">+static inline void acpi_subsystem_init(void) { }</span>
 
 static inline int early_acpi_boot_init(void)
 {
<span class="p_chunk">@@ -500,6 +505,13 @@</span> <span class="p_context"> static inline int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 	return 0;
 }
 
<span class="p_add">+static inline int acpi_reserve_region(u64 start, unsigned int length,</span>
<span class="p_add">+				      u8 space_id, unsigned long flags,</span>
<span class="p_add">+				      char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENXIO;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct acpi_table_header;
 static inline int acpi_table_parse(char *id,
 				int (*handler)(struct acpi_table_header *))
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index 5a81398..0d21dca 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -467,4 +467,61 @@</span> <span class="p_context"> static inline unsigned long vfs_pressure_ratio(unsigned long val)</span>
 {
 	return mult_frac(val, sysctl_vfs_cache_pressure, 100);
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_inode - Get the actual inode of this dentry</span>
<span class="p_add">+ * @dentry: The dentry to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper normal filesystems should use to get at their own inodes</span>
<span class="p_add">+ * in their own dentries and ignore the layering superimposed upon them.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_inode(const struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dentry-&gt;d_inode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()</span>
<span class="p_add">+ * @dentry: The dentry to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper normal filesystems should use to get at their own inodes</span>
<span class="p_add">+ * in their own dentries and ignore the layering superimposed upon them.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_inode_rcu(const struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ACCESS_ONCE(dentry-&gt;d_inode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_backing_inode - Get upper or lower inode we should be using</span>
<span class="p_add">+ * @upper: The upper layer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper that should be used to get at the inode that will be used</span>
<span class="p_add">+ * if this dentry were to be opened as a file.  The inode may be on the upper</span>
<span class="p_add">+ * dentry or it may be on a lower dentry pinned by the upper.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Normal filesystems should not use this to access their own inodes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_backing_inode(const struct dentry *upper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = upper-&gt;d_inode;</span>
<span class="p_add">+</span>
<span class="p_add">+	return inode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_backing_dentry - Get upper or lower dentry we should be using</span>
<span class="p_add">+ * @upper: The upper layer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper that should be used to get the dentry of the inode that</span>
<span class="p_add">+ * will be used if this dentry were opened as a file.  It may be the upper</span>
<span class="p_add">+ * dentry or it may be a lower dentry pinned by the upper.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Normal filesystems should not use this to access their own dentries.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct dentry *d_backing_dentry(struct dentry *upper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return upper;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 42efe13..22fc844 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -1817,6 +1817,7 @@</span> <span class="p_context"> struct file_system_type {</span>
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
<span class="p_add">+#define FS_USERNS_VISIBLE	32	/* FS must already be visible */</span>
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
<span class="p_chunk">@@ -1904,7 +1905,6 @@</span> <span class="p_context"> extern int vfs_ustat(dev_t, struct kstatfs *);</span>
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
<span class="p_del">-extern bool fs_fully_visible(struct file_system_type *);</span>
 
 extern int current_umask(void);
 
<span class="p_chunk">@@ -2662,6 +2662,8 @@</span> <span class="p_context"> extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned in</span>
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
<span class="p_add">+extern void make_empty_dir_inode(struct inode *inode);</span>
<span class="p_add">+extern bool is_empty_dir_inode(struct inode *inode);</span>
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);
<span class="p_header">diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h</span>
<span class="p_header">index fd85cb1..8f36c1d 100644</span>
<span class="p_header">--- a/include/linux/gpio/consumer.h</span>
<span class="p_header">+++ b/include/linux/gpio/consumer.h</span>
<span class="p_chunk">@@ -329,6 +329,21 @@</span> <span class="p_context"> static inline int desc_to_gpio(const struct gpio_desc *desc)</span>
 	return -EINVAL;
 }
 
<span class="p_add">+/* Child properties interface */</span>
<span class="p_add">+struct fwnode_handle;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct gpio_desc *fwnode_get_named_gpiod(</span>
<span class="p_add">+	struct fwnode_handle *fwnode, const char *propname)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOSYS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct gpio_desc *devm_get_gpiod_from_child(</span>
<span class="p_add">+	struct device *dev, const char *con_id, struct fwnode_handle *child)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOSYS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_GPIOLIB */
 
 /*
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 704b9a5..dadb421 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1157,7 +1157,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h</span>
<span class="p_header">index d4e01b3..cfc81c2 100644</span>
<span class="p_header">--- a/include/linux/kernfs.h</span>
<span class="p_header">+++ b/include/linux/kernfs.h</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> enum kernfs_node_flag {</span>
 	KERNFS_STATIC_NAME	= 0x0200,
 	KERNFS_SUICIDAL		= 0x0400,
 	KERNFS_SUICIDED		= 0x0800,
<span class="p_add">+	KERNFS_EMPTY_DIR	= 0x1000,</span>
 };
 
 /* @flags for kernfs_create_root() */
<span class="p_chunk">@@ -286,6 +287,8 @@</span> <span class="p_context"> void kernfs_destroy_root(struct kernfs_root *root);</span>
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
 					 const char *name, umode_t mode,
 					 void *priv, const void *ns);
<span class="p_add">+struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,</span>
<span class="p_add">+					    const char *name);</span>
 struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 const char *name,
 					 umode_t mode, loff_t size,
<span class="p_header">diff --git a/include/linux/kmemleak.h b/include/linux/kmemleak.h</span>
<span class="p_header">index e705467..d0a1f99 100644</span>
<span class="p_header">--- a/include/linux/kmemleak.h</span>
<span class="p_header">+++ b/include/linux/kmemleak.h</span>
<span class="p_chunk">@@ -28,7 +28,8 @@</span> <span class="p_context"></span>
 extern void kmemleak_init(void) __ref;
 extern void kmemleak_alloc(const void *ptr, size_t size, int min_count,
 			   gfp_t gfp) __ref;
<span class="p_del">-extern void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size) __ref;</span>
<span class="p_add">+extern void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,</span>
<span class="p_add">+				  gfp_t gfp) __ref;</span>
 extern void kmemleak_free(const void *ptr) __ref;
 extern void kmemleak_free_part(const void *ptr, size_t size) __ref;
 extern void kmemleak_free_percpu(const void __percpu *ptr) __ref;
<span class="p_chunk">@@ -71,7 +72,8 @@</span> <span class="p_context"> static inline void kmemleak_alloc_recursive(const void *ptr, size_t size,</span>
 					    gfp_t gfp)
 {
 }
<span class="p_del">-static inline void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size)</span>
<span class="p_add">+static inline void kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,</span>
<span class="p_add">+					 gfp_t gfp)</span>
 {
 }
 static inline void kmemleak_free(const void *ptr)
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 06ebfa1..3c1a558 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1132,7 +1132,7 @@</span> <span class="p_context"> struct nfs41_state_protection {</span>
 	struct nfs4_op_map allow;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index dfde07e..78a04ee 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -623,7 +623,10 @@</span> <span class="p_context"> static inline const char *of_prop_next_string(struct property *prop,</span>
 #if defined(CONFIG_OF) &amp;&amp; defined(CONFIG_NUMA)
 extern int of_node_to_nid(struct device_node *np);
 #else
<span class="p_del">-static inline int of_node_to_nid(struct device_node *device) { return 0; }</span>
<span class="p_add">+static inline int of_node_to_nid(struct device_node *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline struct device_node *of_find_matching_node(
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index 9603094..03d4863 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -575,9 +575,15 @@</span> <span class="p_context"> int raw_pci_read(unsigned int domain, unsigned int bus, unsigned int devfn,</span>
 int raw_pci_write(unsigned int domain, unsigned int bus, unsigned int devfn,
 		  int reg, int len, u32 val);
 
<span class="p_add">+#ifdef CONFIG_PCI_BUS_ADDR_T_64BIT</span>
<span class="p_add">+typedef u64 pci_bus_addr_t;</span>
<span class="p_add">+#else</span>
<span class="p_add">+typedef u32 pci_bus_addr_t;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 struct pci_bus_region {
<span class="p_del">-	dma_addr_t start;</span>
<span class="p_del">-	dma_addr_t end;</span>
<span class="p_add">+	pci_bus_addr_t start;</span>
<span class="p_add">+	pci_bus_addr_t end;</span>
 };
 
 struct pci_dynids {
<span class="p_chunk">@@ -994,6 +1000,7 @@</span> <span class="p_context"> int __must_check pci_assign_resource(struct pci_dev *dev, int i);</span>
 int __must_check pci_reassign_resource(struct pci_dev *dev, int i, resource_size_t add_size, resource_size_t align);
 int pci_select_bars(struct pci_dev *dev, unsigned long flags);
 bool pci_device_is_present(struct pci_dev *pdev);
<span class="p_add">+void pci_ignore_hotplug(struct pci_dev *dev);</span>
 
 /* ROM control related routines */
 int pci_enable_rom(struct pci_dev *pdev);
<span class="p_chunk">@@ -1031,11 +1038,6 @@</span> <span class="p_context"> bool pci_dev_run_wake(struct pci_dev *dev);</span>
 bool pci_check_pme_status(struct pci_dev *dev);
 void pci_pme_wakeup_bus(struct pci_bus *bus);
 
<span class="p_del">-static inline void pci_ignore_hotplug(struct pci_dev *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dev-&gt;ignore_hotplug = 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int pci_enable_wake(struct pci_dev *dev, pci_power_t state,
 				  bool enable)
 {
<span class="p_chunk">@@ -1116,7 +1118,7 @@</span> <span class="p_context"> int __must_check pci_bus_alloc_resource(struct pci_bus *bus,</span>
 
 int pci_remap_iospace(const struct resource *res, phys_addr_t phys_addr);
 
<span class="p_del">-static inline dma_addr_t pci_bus_address(struct pci_dev *pdev, int bar)</span>
<span class="p_add">+static inline pci_bus_addr_t pci_bus_address(struct pci_dev *pdev, int bar)</span>
 {
 	struct pci_bus_region region;
 
<span class="p_header">diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h</span>
<span class="p_header">index b7361f8..d8926fb 100644</span>
<span class="p_header">--- a/include/linux/sysctl.h</span>
<span class="p_header">+++ b/include/linux/sysctl.h</span>
<span class="p_chunk">@@ -188,6 +188,9 @@</span> <span class="p_context"> struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,</span>
 void unregister_sysctl_table(struct ctl_table_header * table);
 
 extern int sysctl_init(void);
<span class="p_add">+</span>
<span class="p_add">+extern struct ctl_table sysctl_mount_point[];</span>
<span class="p_add">+</span>
 #else /* CONFIG_SYSCTL */
 static inline struct ctl_table_header *register_sysctl_table(struct ctl_table * table)
 {
<span class="p_header">diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h</span>
<span class="p_header">index ddad161..68c3b0f 100644</span>
<span class="p_header">--- a/include/linux/sysfs.h</span>
<span class="p_header">+++ b/include/linux/sysfs.h</span>
<span class="p_chunk">@@ -195,6 +195,10 @@</span> <span class="p_context"> int __must_check sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,</span>
 int __must_check sysfs_move_dir_ns(struct kobject *kobj,
 				   struct kobject *new_parent_kobj,
 				   const void *new_ns);
<span class="p_add">+int __must_check sysfs_create_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					  const char *name);</span>
<span class="p_add">+void sysfs_remove_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+			      const char *name);</span>
 
 int __must_check sysfs_create_file_ns(struct kobject *kobj,
 				      const struct attribute *attr,
<span class="p_chunk">@@ -283,6 +287,17 @@</span> <span class="p_context"> static inline int sysfs_move_dir_ns(struct kobject *kobj,</span>
 	return 0;
 }
 
<span class="p_add">+static inline int sysfs_create_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					   const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sysfs_remove_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					    const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int sysfs_create_file_ns(struct kobject *kobj,
 				       const struct attribute *attr,
 				       const void *ns)
<span class="p_header">diff --git a/include/linux/types.h b/include/linux/types.h</span>
<span class="p_header">index a0bb704..20d8fb6 100644</span>
<span class="p_header">--- a/include/linux/types.h</span>
<span class="p_header">+++ b/include/linux/types.h</span>
<span class="p_chunk">@@ -142,12 +142,20 @@</span> <span class="p_context"> typedef unsigned long blkcnt_t;</span>
 #define pgoff_t unsigned long
 #endif
 
<span class="p_del">-/* A dma_addr_t can hold any valid DMA or bus address for the platform */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * A dma_addr_t can hold any valid DMA address, i.e., any address returned</span>
<span class="p_add">+ * by the DMA API.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If the DMA API only uses 32-bit addresses, dma_addr_t need only be 32</span>
<span class="p_add">+ * bits wide.  Bus addresses, e.g., PCI BARs, may be wider than 32 bits,</span>
<span class="p_add">+ * but drivers do memory-mapped I/O to ioremapped kernel virtual addresses,</span>
<span class="p_add">+ * so they don&#39;t care about the size of the actual bus addresses.</span>
<span class="p_add">+ */</span>
 #ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 typedef u64 dma_addr_t;
 #else
 typedef u32 dma_addr_t;
<span class="p_del">-#endif /* dma_addr_t */</span>
<span class="p_add">+#endif</span>
 
 #ifdef __CHECKER__
 #else
<span class="p_header">diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h</span>
<span class="p_header">index 84a53d7..1a91f97 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_queue.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_queue.h</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"> struct nf_queue_entry {</span>
 struct nf_queue_handler {
 	int			(*outfn)(struct nf_queue_entry *entry,
 					 unsigned int queuenum);
<span class="p_add">+	void			(*nf_hook_drop)(struct net *net,</span>
<span class="p_add">+						struct nf_hook_ops *ops);</span>
 };
 
 void nf_register_queue_handler(const struct nf_queue_handler *qh);
<span class="p_header">diff --git a/include/net/netns/sctp.h b/include/net/netns/sctp.h</span>
<span class="p_header">index 3573a81..8ba379f 100644</span>
<span class="p_header">--- a/include/net/netns/sctp.h</span>
<span class="p_header">+++ b/include/net/netns/sctp.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct netns_sctp {</span>
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
<span class="p_add">+	/* Lock that protects both addr_waitq and auto_asconf_splist */</span>
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index 2bb2fcf..495c87e 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -223,6 +223,10 @@</span> <span class="p_context"> struct sctp_sock {</span>
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
<span class="p_add">+</span>
<span class="p_add">+	/* These must be the last fields, as they will skipped on copies,</span>
<span class="p_add">+	 * like on accept and peeloff operations</span>
<span class="p_add">+	 */</span>
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index 61b99376..4872fb5 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -674,6 +674,7 @@</span> <span class="p_context"> asmlinkage __visible void __init start_kernel(void)</span>
 
 	check_bugs();
 
<span class="p_add">+	acpi_subsystem_init();</span>
 	sfi_init_late();
 
 	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index 04cfe8a..00e19f7 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -1924,8 +1924,6 @@</span> <span class="p_context"> static struct file_system_type cgroup_fs_type = {</span>
 	.kill_sb = cgroup_kill_sb,
 };
 
<span class="p_del">-static struct kobject *cgroup_kobj;</span>
<span class="p_del">-</span>
 /**
  * task_cgroup_path - cgroup path of a task in the first cgroup hierarchy
  * @task: target task
<span class="p_chunk">@@ -5038,13 +5036,13 @@</span> <span class="p_context"> int __init cgroup_init(void)</span>
 		}
 	}
 
<span class="p_del">-	cgroup_kobj = kobject_create_and_add(&quot;cgroup&quot;, fs_kobj);</span>
<span class="p_del">-	if (!cgroup_kobj)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;cgroup&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = register_filesystem(&amp;cgroup_fs_type);
 	if (err &lt; 0) {
<span class="p_del">-		kobject_put(cgroup_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;cgroup&quot;);</span>
 		return err;
 	}
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 7959624..b59b7b0 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -4057,20 +4057,20 @@</span> <span class="p_context"> static void ring_buffer_attach(struct perf_event *event,</span>
 		WARN_ON_ONCE(event-&gt;rcu_pending);
 
 		old_rb = event-&gt;rb;
<span class="p_del">-		event-&gt;rcu_batches = get_state_synchronize_rcu();</span>
<span class="p_del">-		event-&gt;rcu_pending = 1;</span>
<span class="p_del">-</span>
 		spin_lock_irqsave(&amp;old_rb-&gt;event_lock, flags);
 		list_del_rcu(&amp;event-&gt;rb_entry);
 		spin_unlock_irqrestore(&amp;old_rb-&gt;event_lock, flags);
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (event-&gt;rcu_pending &amp;&amp; rb) {</span>
<span class="p_del">-		cond_synchronize_rcu(event-&gt;rcu_batches);</span>
<span class="p_del">-		event-&gt;rcu_pending = 0;</span>
<span class="p_add">+		event-&gt;rcu_batches = get_state_synchronize_rcu();</span>
<span class="p_add">+		event-&gt;rcu_pending = 1;</span>
 	}
 
 	if (rb) {
<span class="p_add">+		if (event-&gt;rcu_pending) {</span>
<span class="p_add">+			cond_synchronize_rcu(event-&gt;rcu_batches);</span>
<span class="p_add">+			event-&gt;rcu_pending = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		spin_lock_irqsave(&amp;rb-&gt;event_lock, flags);
 		list_add_rcu(&amp;event-&gt;rb_entry, &amp;rb-&gt;event_list);
 		spin_unlock_irqrestore(&amp;rb-&gt;event_lock, flags);
<span class="p_header">diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c</span>
<span class="p_header">index d5d0f73..74d90a7 100644</span>
<span class="p_header">--- a/kernel/irq/devres.c</span>
<span class="p_header">+++ b/kernel/irq/devres.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 		return -ENOMEM;
 
 	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_del">-	if (rc) {</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		devres_free(dr);
 		return rc;
 	}
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 	dr-&gt;dev_id = dev_id;
 	devres_add(dev, dr);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(devm_request_any_context_irq);
 
<span class="p_header">diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig</span>
<span class="p_header">index 48b28d3..ea1d494 100644</span>
<span class="p_header">--- a/kernel/power/Kconfig</span>
<span class="p_header">+++ b/kernel/power/Kconfig</span>
<span class="p_chunk">@@ -187,7 +187,7 @@</span> <span class="p_context"> config DPM_WATCHDOG</span>
 config DPM_WATCHDOG_TIMEOUT
 	int &quot;Watchdog timeout in seconds&quot;
 	range 1 120
<span class="p_del">-	default 12</span>
<span class="p_add">+	default 60</span>
 	depends on DPM_WATCHDOG
 
 config PM_TRACE
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 2cdd353..4b52ee5 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -484,11 +484,11 @@</span> <span class="p_context"> int check_syslog_permissions(int type, bool from_file)</span>
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file &amp;&amp; type != SYSLOG_ACTION_OPEN)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto ok;</span>
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
<span class="p_chunk">@@ -498,10 +498,11 @@</span> <span class="p_context"> int check_syslog_permissions(int type, bool from_file)</span>
 				     &quot;CAP_SYS_ADMIN but no CAP_SYSLOG &quot;
 				     &quot;(deprecated).\n&quot;,
 				 current-&gt;comm, task_pid_nr(current));
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		}
 		return -EPERM;
 	}
<span class="p_add">+ok:</span>
 	return security_syslog(type);
 }
 
<span class="p_chunk">@@ -1263,10 +1264,6 @@</span> <span class="p_context"> int do_syslog(int type, char __user *buf, int len, bool from_file)</span>
 	if (error)
 		goto out;
 
<span class="p_del">-	error = security_syslog(type);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;
<span class="p_header">diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c</span>
<span class="p_header">index 0db5649..921ca41 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny.c</span>
<span class="p_header">+++ b/kernel/rcu/tiny.c</span>
<span class="p_chunk">@@ -282,6 +282,11 @@</span> <span class="p_context"> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp)</span>
 
 	/* Move the ready-to-invoke callbacks to a local list. */
 	local_irq_save(flags);
<span class="p_add">+	if (rcp-&gt;donetail == &amp;rcp-&gt;rcucblist) {</span>
<span class="p_add">+		/* No callbacks ready, so just leave. */</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	RCU_TRACE(trace_rcu_batch_start(rcp-&gt;name, 0, rcp-&gt;qlen, -1));
 	list = rcp-&gt;rcucblist;
 	rcp-&gt;rcucblist = *rcp-&gt;donetail;
<span class="p_header">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span>
<span class="p_header">index 44cfeb3..9e78f9f 100644</span>
<span class="p_header">--- a/kernel/sched/fair.c</span>
<span class="p_header">+++ b/kernel/sched/fair.c</span>
<span class="p_chunk">@@ -5028,18 +5028,21 @@</span> <span class="p_context"> again:</span>
 		 * entity, update_curr() will update its vruntime, otherwise
 		 * forget we&#39;ve ever seen it.
 		 */
<span class="p_del">-		if (curr &amp;&amp; curr-&gt;on_rq)</span>
<span class="p_del">-			update_curr(cfs_rq);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			curr = NULL;</span>
<span class="p_add">+		if (curr) {</span>
<span class="p_add">+			if (curr-&gt;on_rq)</span>
<span class="p_add">+				update_curr(cfs_rq);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				curr = NULL;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This call to check_cfs_rq_runtime() will do the throttle and</span>
<span class="p_del">-		 * dequeue its entity in the parent(s). Therefore the &#39;simple&#39;</span>
<span class="p_del">-		 * nr_running test will indeed be correct.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (unlikely(check_cfs_rq_runtime(cfs_rq)))</span>
<span class="p_del">-			goto simple;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This call to check_cfs_rq_runtime() will do the</span>
<span class="p_add">+			 * throttle and dequeue its entity in the parent(s).</span>
<span class="p_add">+			 * Therefore the &#39;simple&#39; nr_running test will indeed</span>
<span class="p_add">+			 * be correct.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (unlikely(check_cfs_rq_runtime(cfs_rq)))</span>
<span class="p_add">+				goto simple;</span>
<span class="p_add">+		}</span>
 
 		se = pick_next_entity(cfs_rq, curr);
 		cfs_rq = group_cfs_rq(se);
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 88ea2d6..3fc92a1 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -1502,12 +1502,6 @@</span> <span class="p_context"> static struct ctl_table vm_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)</span>
<span class="p_del">-static struct ctl_table binfmt_misc_table[] = {</span>
<span class="p_del">-	{ }</span>
<span class="p_del">-};</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static struct ctl_table fs_table[] = {
 	{
 		.procname	= &quot;inode-nr&quot;,
<span class="p_chunk">@@ -1661,7 +1655,7 @@</span> <span class="p_context"> static struct ctl_table fs_table[] = {</span>
 	{
 		.procname	= &quot;binfmt_misc&quot;,
 		.mode		= 0555,
<span class="p_del">-		.child		= binfmt_misc_table,</span>
<span class="p_add">+		.child		= sysctl_mount_point,</span>
 	},
 #endif
 	{
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index 210b848..acd2d34 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -799,6 +799,9 @@</span> <span class="p_context"> u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)</span>
 	if (delta.tv64 &lt; 0)
 		return 0;
 
<span class="p_add">+	if (WARN_ON(timer-&gt;state &amp; HRTIMER_STATE_ENQUEUED))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (interval.tv64 &lt; timer-&gt;base-&gt;resolution.tv64)
 		interval.tv64 = timer-&gt;base-&gt;resolution.tv64;
 
<span class="p_chunk">@@ -1225,11 +1228,14 @@</span> <span class="p_context"> static void __run_hrtimer(struct hrtimer *timer, ktime_t *now)</span>
 	 * Note: We clear the CALLBACK bit after enqueue_hrtimer and
 	 * we do not reprogramm the event hardware. Happens either in
 	 * hrtimer_start_range_ns() or in hrtimer_interrupt()
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: Because we dropped the cpu_base-&gt;lock above,</span>
<span class="p_add">+	 * hrtimer_start_range_ns() can have popped in and enqueued the timer</span>
<span class="p_add">+	 * for us already.</span>
 	 */
<span class="p_del">-	if (restart != HRTIMER_NORESTART) {</span>
<span class="p_del">-		BUG_ON(timer-&gt;state != HRTIMER_STATE_CALLBACK);</span>
<span class="p_add">+	if (restart != HRTIMER_NORESTART &amp;&amp;</span>
<span class="p_add">+	    !(timer-&gt;state &amp; HRTIMER_STATE_ENQUEUED))</span>
 		enqueue_hrtimer(timer, base);
<span class="p_del">-	}</span>
 
 	WARN_ON_ONCE(!(timer-&gt;state &amp; HRTIMER_STATE_CALLBACK));
 
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 7f2e97c..52adf02 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1056,6 +1056,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1071,6 +1074,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1385,7 +1391,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 		if (elt-&gt;op != OP_NOT)
 			cnt--;
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index 324ea9e..4393913 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -641,12 +641,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -675,11 +675,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -689,16 +688,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index a2bfd02..2870d90 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -40,6 +40,11 @@</span> <span class="p_context"> unsigned long hugepages_treat_as_movable;</span>
 int hugetlb_max_hstate __read_mostly;
 unsigned int default_hstate_idx;
 struct hstate hstates[HUGE_MAX_HSTATE];
<span class="p_add">+/*</span>
<span class="p_add">+ * Minimum page order among possible hugepage sizes, set to a proper value</span>
<span class="p_add">+ * at boot time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int minimum_order __read_mostly = UINT_MAX;</span>
 
 __initdata LIST_HEAD(huge_boot_pages);
 
<span class="p_chunk">@@ -1084,19 +1089,13 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned int order = 8 * sizeof(void *);</span>
 	unsigned long pfn;
<span class="p_del">-	struct hstate *h;</span>
 
 	if (!hugepages_supported())
 		return;
 
<span class="p_del">-	/* Set scan step to minimum hugepage size */</span>
<span class="p_del">-	for_each_hstate(h)</span>
<span class="p_del">-		if (order &gt; huge_page_order(h))</span>
<span class="p_del">-			order = huge_page_order(h);</span>
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; order));</span>
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; order)</span>
<span class="p_add">+	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
 
<span class="p_chunk">@@ -1523,10 +1522,14 @@</span> <span class="p_context"> static void __init hugetlb_init_hstates(void)</span>
 	struct hstate *h;
 
 	for_each_hstate(h) {
<span class="p_add">+		if (minimum_order &gt; huge_page_order(h))</span>
<span class="p_add">+			minimum_order = huge_page_order(h);</span>
<span class="p_add">+</span>
 		/* oversize hugepages were init&#39;ed in early boot */
 		if (!hstate_is_gigantic(h))
 			hugetlb_hstate_alloc_pages(h);
 	}
<span class="p_add">+	VM_BUG_ON(minimum_order == UINT_MAX);</span>
 }
 
 static char * __init memfmt(char *buf, unsigned long n)
<span class="p_header">diff --git a/mm/kmemleak.c b/mm/kmemleak.c</span>
<span class="p_header">index 3cda50c..1f14ef6 100644</span>
<span class="p_header">--- a/mm/kmemleak.c</span>
<span class="p_header">+++ b/mm/kmemleak.c</span>
<span class="p_chunk">@@ -193,6 +193,8 @@</span> <span class="p_context"> static struct kmem_cache *scan_area_cache;</span>
 
 /* set if tracing memory operations is enabled */
 static int kmemleak_enabled;
<span class="p_add">+/* same as above but only for the kmemleak_free() callback */</span>
<span class="p_add">+static int kmemleak_free_enabled;</span>
 /* set in the late_initcall if there were no errors */
 static int kmemleak_initialized;
 /* enables or disables early logging of the memory operations */
<span class="p_chunk">@@ -905,12 +907,13 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kmemleak_alloc);</span>
  * kmemleak_alloc_percpu - register a newly allocated __percpu object
  * @ptr:	__percpu pointer to beginning of the object
  * @size:	size of the object
<span class="p_add">+ * @gfp:	flags used for kmemleak internal memory allocations</span>
  *
  * This function is called from the kernel percpu allocator when a new object
<span class="p_del">- * (memory block) is allocated (alloc_percpu). It assumes GFP_KERNEL</span>
<span class="p_del">- * allocation.</span>
<span class="p_add">+ * (memory block) is allocated (alloc_percpu).</span>
  */
<span class="p_del">-void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size)</span>
<span class="p_add">+void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size,</span>
<span class="p_add">+				 gfp_t gfp)</span>
 {
 	unsigned int cpu;
 
<span class="p_chunk">@@ -923,7 +926,7 @@</span> <span class="p_context"> void __ref kmemleak_alloc_percpu(const void __percpu *ptr, size_t size)</span>
 	if (kmemleak_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))
 		for_each_possible_cpu(cpu)
 			create_object((unsigned long)per_cpu_ptr(ptr, cpu),
<span class="p_del">-				      size, 0, GFP_KERNEL);</span>
<span class="p_add">+				      size, 0, gfp);</span>
 	else if (kmemleak_early_log)
 		log_early(KMEMLEAK_ALLOC_PERCPU, ptr, size, 0);
 }
<span class="p_chunk">@@ -940,7 +943,7 @@</span> <span class="p_context"> void __ref kmemleak_free(const void *ptr)</span>
 {
 	pr_debug(&quot;%s(0x%p)\n&quot;, __func__, ptr);
 
<span class="p_del">-	if (kmemleak_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
<span class="p_add">+	if (kmemleak_free_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
 		delete_object_full((unsigned long)ptr);
 	else if (kmemleak_early_log)
 		log_early(KMEMLEAK_FREE, ptr, 0, 0);
<span class="p_chunk">@@ -980,7 +983,7 @@</span> <span class="p_context"> void __ref kmemleak_free_percpu(const void __percpu *ptr)</span>
 
 	pr_debug(&quot;%s(0x%p)\n&quot;, __func__, ptr);
 
<span class="p_del">-	if (kmemleak_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
<span class="p_add">+	if (kmemleak_free_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
 		for_each_possible_cpu(cpu)
 			delete_object_full((unsigned long)per_cpu_ptr(ptr,
 								      cpu));
<span class="p_chunk">@@ -1743,6 +1746,13 @@</span> <span class="p_context"> static void kmemleak_do_cleanup(struct work_struct *work)</span>
 	mutex_lock(&amp;scan_mutex);
 	stop_scan_thread();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once the scan thread has stopped, it is safe to no longer track</span>
<span class="p_add">+	 * object freeing. Ordering of the scan thread stopping and the memory</span>
<span class="p_add">+	 * accesses below is guaranteed by the kthread_stop() function.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kmemleak_free_enabled = 0;</span>
<span class="p_add">+</span>
 	if (!kmemleak_found_leaks)
 		__kmemleak_do_cleanup();
 	else
<span class="p_chunk">@@ -1769,6 +1779,8 @@</span> <span class="p_context"> static void kmemleak_disable(void)</span>
 	/* check whether it is too early for a kernel thread */
 	if (kmemleak_initialized)
 		schedule_work(&amp;cleanup_work);
<span class="p_add">+	else</span>
<span class="p_add">+		kmemleak_free_enabled = 0;</span>
 
 	pr_info(&quot;Kernel memory leak detector disabled\n&quot;);
 }
<span class="p_chunk">@@ -1833,8 +1845,10 @@</span> <span class="p_context"> void __init kmemleak_init(void)</span>
 	if (kmemleak_error) {
 		local_irq_restore(flags);
 		return;
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		kmemleak_enabled = 1;
<span class="p_add">+		kmemleak_free_enabled = 1;</span>
<span class="p_add">+	}</span>
 	local_irq_restore(flags);
 
 	/*
<span class="p_header">diff --git a/mm/percpu.c b/mm/percpu.c</span>
<span class="p_header">index d39e2f4..9584117 100644</span>
<span class="p_header">--- a/mm/percpu.c</span>
<span class="p_header">+++ b/mm/percpu.c</span>
<span class="p_chunk">@@ -1030,7 +1030,7 @@</span> <span class="p_context"> area_found:</span>
 		memset((void *)pcpu_chunk_addr(chunk, cpu, 0) + off, 0, size);
 
 	ptr = __addr_to_pcpu_ptr(chunk-&gt;base_addr + off);
<span class="p_del">-	kmemleak_alloc_percpu(ptr, size);</span>
<span class="p_add">+	kmemleak_alloc_percpu(ptr, size, gfp);</span>
 	return ptr;
 
 fail_unlock:
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index e86a9be..53fe98e 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -850,7 +850,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index a9a4a1b..8d423bc 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -247,9 +247,7 @@</span> <span class="p_context"> static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)</span>
 		if (!ns_capable(dev_net(dev)-&gt;user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
<span class="p_del">-		spin_lock_bh(&amp;br-&gt;lock);</span>
 		br_stp_set_bridge_priority(br, args[1]);
<span class="p_del">-		spin_unlock_bh(&amp;br-&gt;lock);</span>
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index c08f510..dd6c7ca 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -37,6 +37,8 @@</span> <span class="p_context"></span>
 
 static void br_multicast_start_querier(struct net_bridge *br,
 				       struct bridge_mcast_own_query *query);
<span class="p_add">+static void br_multicast_add_router(struct net_bridge *br,</span>
<span class="p_add">+				    struct net_bridge_port *port);</span>
 unsigned int br_mdb_rehash_seq;
 
 static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)
<span class="p_chunk">@@ -935,6 +937,8 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 #if IS_ENABLED(CONFIG_IPV6)
 	br_multicast_enable(&amp;port-&gt;ip6_own_query);
 #endif
<span class="p_add">+	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		br_multicast_add_router(br, port);</span>
 
 out:
 	spin_unlock(&amp;br-&gt;multicast_lock);
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 4114687..7832d07 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -243,12 +243,13 @@</span> <span class="p_context"> bool br_stp_recalculate_bridge_id(struct net_bridge *br)</span>
 	return true;
 }
 
<span class="p_del">-/* called under bridge lock */</span>
<span class="p_add">+/* Acquires and releases bridge lock */</span>
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &amp;br-&gt;port_list, list) {
<span class="p_chunk">@@ -266,6 +267,7 @@</span> <span class="p_context"> void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)</span>
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) &amp;&amp; !wasroot)
 		br_become_root_bridge(br);
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
 }
 
 /* called under bridge lock */
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index b8c3fde..e5502bd 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 8d614c9..0385351 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -971,6 +971,8 @@</span> <span class="p_context"> int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)</span>
 	rc = 0;
 	if (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
 		goto out_unlock_bh;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out_dead;</span>
 
 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
 		if (NEIGH_VAR(neigh-&gt;parms, MCAST_PROBES) +
<span class="p_chunk">@@ -1027,6 +1029,13 @@</span> <span class="p_context"> out_unlock_bh:</span>
 		write_unlock(&amp;neigh-&gt;lock);
 	local_bh_enable();
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_dead:</span>
<span class="p_add">+	if (neigh-&gt;nud_state &amp; NUD_STALE)</span>
<span class="p_add">+		goto out_unlock_bh;</span>
<span class="p_add">+	write_unlock_bh(&amp;neigh-&gt;lock);</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 1;</span>
 }
 EXPORT_SYMBOL(__neigh_event_send);
 
<span class="p_chunk">@@ -1090,6 +1099,8 @@</span> <span class="p_context"> int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,</span>
 	if (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;
 	    (old &amp; (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out;</span>
 
 	if (!(new &amp; NUD_VALID)) {
 		neigh_del_timer(neigh);
<span class="p_chunk">@@ -1239,6 +1250,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(neigh_update);</span>
  */
 void __neigh_set_probe_once(struct neighbour *neigh)
 {
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		return;</span>
 	neigh-&gt;updated = jiffies;
 	if (!(neigh-&gt;nud_state &amp; NUD_FAILED))
 		return;
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 352d183..de4dc84 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -567,7 +567,7 @@</span> <span class="p_context"> static int pktgen_if_show(struct seq_file *seq, void *v)</span>
 			   &quot;     dst_min: %s  dst_max: %s\n&quot;,
 			   pkt_dev-&gt;dst_min, pkt_dev-&gt;dst_max);
 		seq_printf(seq,
<span class="p_del">-			   &quot;        src_min: %s  src_max: %s\n&quot;,</span>
<span class="p_add">+			   &quot;     src_min: %s  src_max: %s\n&quot;,</span>
 			   pkt_dev-&gt;src_min, pkt_dev-&gt;src_max);
 	}
 
<span class="p_chunk">@@ -1267,6 +1267,9 @@</span> <span class="p_context"> static ssize_t pktgen_if_write(struct file *file,</span>
 		else if (strcmp(f, &quot;NO_TIMESTAMP&quot;) == 0)
 			pkt_dev-&gt;flags |= F_NO_TIMESTAMP;
 
<span class="p_add">+		else if (strcmp(f, &quot;!NO_TIMESTAMP&quot;) == 0)</span>
<span class="p_add">+			pkt_dev-&gt;flags &amp;= ~F_NO_TIMESTAMP;</span>
<span class="p_add">+</span>
 		else {
 			sprintf(pg_result,
 				&quot;Flag -:%s:- unknown\nAvailable flags, (prepend ! to un-set flag):\n%s&quot;,
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 3b0a8b0..0998af7 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -4414,7 +4414,7 @@</span> <span class="p_context"> struct sk_buff *alloc_skb_with_frags(unsigned long header_len,</span>
 
 		while (order) {
 			if (npages &gt;= 1 &lt;&lt; order) {
<span class="p_del">-				page = alloc_pages(gfp_mask |</span>
<span class="p_add">+				page = alloc_pages((gfp_mask &amp; ~__GFP_WAIT) |</span>
 						   __GFP_COMP |
 						   __GFP_NOWARN |
 						   __GFP_NORETRY,
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index a91f99f..3606cc5 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1888,7 +1888,7 @@</span> <span class="p_context"> bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t gfp)</span>
 
 	pfrag-&gt;offset = 0;
 	if (SKB_FRAG_PAGE_ORDER) {
<span class="p_del">-		pfrag-&gt;page = alloc_pages(gfp | __GFP_COMP |</span>
<span class="p_add">+		pfrag-&gt;page = alloc_pages((gfp &amp; ~__GFP_WAIT) | __GFP_COMP |</span>
 					  __GFP_NOWARN | __GFP_NORETRY,
 					  SKB_FRAG_PAGE_ORDER);
 		if (likely(pfrag-&gt;page)) {
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index a44773c..515f689 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -228,6 +228,8 @@</span> <span class="p_context"> int inet_listen(struct socket *sock, int backlog)</span>
 				err = 0;
 			if (err)
 				goto out;
<span class="p_add">+</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
 		}
 		err = inet_csk_listen_start(sk, backlog);
 		if (err)
<span class="p_header">diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c</span>
<span class="p_header">index 40403114..2a97140 100644</span>
<span class="p_header">--- a/net/ipv4/ipip.c</span>
<span class="p_header">+++ b/net/ipv4/ipip.c</span>
<span class="p_chunk">@@ -251,7 +251,8 @@</span> <span class="p_context"> ipip_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	p.i_key = p.o_key = p.i_flags = p.o_flags = 0;</span>
<span class="p_add">+	p.i_key = p.o_key = 0;</span>
<span class="p_add">+	p.i_flags = p.o_flags = 0;</span>
 	if (p.iph.ttl)
 		p.iph.frag_off |= htons(IP_DF);
 
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 3075723..48e9bb6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2566,10 +2566,13 @@</span> <span class="p_context"> static int do_tcp_setsockopt(struct sock *sk, int level,</span>
 
 	case TCP_FASTOPEN:
 		if (val &gt;= 0 &amp;&amp; ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_CLOSE |
<span class="p_del">-		    TCPF_LISTEN)))</span>
<span class="p_add">+		    TCPF_LISTEN))) {</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
<span class="p_add">+</span>
 			err = fastopen_init_queue(sk, val);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			err = -EINVAL;
<span class="p_add">+		}</span>
 		break;
 	case TCP_TIMESTAMP:
 		if (!tp-&gt;repair)
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index c730772..b01d5bd 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -78,8 +78,6 @@</span> <span class="p_context"> static bool __tcp_fastopen_cookie_gen(const void *path,</span>
 	struct tcp_fastopen_context *ctx;
 	bool ok = false;
 
<span class="p_del">-	tcp_fastopen_init_key_once(true);</span>
<span class="p_del">-</span>
 	rcu_read_lock();
 	ctx = rcu_dereference(tcp_fastopen_ctx);
 	if (ctx) {
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index e75d5c5..0bfe56f 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -3344,6 +3344,7 @@</span> <span class="p_context"> static int ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,</span>
 	/* Update CSA counters */
 	if (sdata-&gt;vif.csa_active &amp;&amp;
 	    (sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
<span class="p_add">+	     sdata-&gt;vif.type == NL80211_IFTYPE_MESH_POINT ||</span>
 	     sdata-&gt;vif.type == NL80211_IFTYPE_ADHOC) &amp;&amp;
 	    params-&gt;n_csa_offsets) {
 		int i;
<span class="p_header">diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c</span>
<span class="p_header">index 509bc15..53b419b 100644</span>
<span class="p_header">--- a/net/mac80211/ibss.c</span>
<span class="p_header">+++ b/net/mac80211/ibss.c</span>
<span class="p_chunk">@@ -146,6 +146,7 @@</span> <span class="p_context"> ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,</span>
 				csa_settings-&gt;chandef.chan-&gt;center_freq);
 		presp-&gt;csa_counter_offsets[0] = (pos - presp-&gt;head);
 		*pos++ = csa_settings-&gt;count;
<span class="p_add">+		presp-&gt;csa_current_counter = csa_settings-&gt;count;</span>
 	}
 
 	/* put the remaining rates in WLAN_EID_EXT_SUPP_RATES */
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index 6ab99da..05ebd07 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -249,6 +249,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -257,6 +258,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	     &quot;%s called with hardware scan in progress\n&quot;, __func__);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c</span>
<span class="p_header">index 0c8b2a7..eff8ac2 100644</span>
<span class="p_header">--- a/net/mac80211/mesh.c</span>
<span class="p_header">+++ b/net/mac80211/mesh.c</span>
<span class="p_chunk">@@ -679,6 +679,7 @@</span> <span class="p_context"> ieee80211_mesh_build_beacon(struct ieee80211_if_mesh *ifmsh)</span>
 		*pos++ = 0x0;
 		*pos++ = ieee80211_frequency_to_channel(
 				csa-&gt;settings.chandef.chan-&gt;center_freq);
<span class="p_add">+		bcn-&gt;csa_current_counter = csa-&gt;settings.count;</span>
 		bcn-&gt;csa_counter_offsets[0] = hdr_len + 6;
 		*pos++ = csa-&gt;settings.count;
 		*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;
<span class="p_header">diff --git a/net/netfilter/core.c b/net/netfilter/core.c</span>
<span class="p_header">index fea9ef5..c9b9966 100644</span>
<span class="p_header">--- a/net/netfilter/core.c</span>
<span class="p_header">+++ b/net/netfilter/core.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> void nf_unregister_hook(struct nf_hook_ops *reg)</span>
 	static_key_slow_dec(&amp;nf_hooks_needed[reg-&gt;pf][reg-&gt;hooknum]);
 #endif
 	synchronize_net();
<span class="p_add">+	nf_queue_nf_hook_drop(reg);</span>
 }
 EXPORT_SYMBOL(nf_unregister_hook);
 
<span class="p_header">diff --git a/net/netfilter/nf_internals.h b/net/netfilter/nf_internals.h</span>
<span class="p_header">index 61a3c92..aba1d7d 100644</span>
<span class="p_header">--- a/net/netfilter/nf_internals.h</span>
<span class="p_header">+++ b/net/netfilter/nf_internals.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> int nf_queue(struct sk_buff *skb, struct nf_hook_ops *elem, u_int8_t pf,</span>
 	     unsigned int hook, struct net_device *indev,
 	     struct net_device *outdev, int (*okfn)(struct sk_buff *),
 	     unsigned int queuenum);
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops);</span>
 int __init netfilter_queue_init(void);
 
 /* nf_log.c */
<span class="p_header">diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c</span>
<span class="p_header">index 4c8b68e..77ee2d4 100644</span>
<span class="p_header">--- a/net/netfilter/nf_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nf_queue.c</span>
<span class="p_chunk">@@ -95,6 +95,23 @@</span> <span class="p_context"> bool nf_queue_entry_get_refs(struct nf_queue_entry *entry)</span>
 }
 EXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);
 
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct nf_queue_handler *qh;</span>
<span class="p_add">+	struct net *net;</span>
<span class="p_add">+</span>
<span class="p_add">+	rtnl_lock();</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	qh = rcu_dereference(queue_handler);</span>
<span class="p_add">+	if (qh) {</span>
<span class="p_add">+		for_each_net(net) {</span>
<span class="p_add">+			qh-&gt;nf_hook_drop(net, ops);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Any packet that leaves via this function must come back
  * through nf_reinject().
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index 0db8515..900cedc 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -815,6 +815,27 @@</span> <span class="p_context"> static struct notifier_block nfqnl_dev_notifier = {</span>
 	.notifier_call	= nfqnl_rcv_dev_event,
 };
 
<span class="p_add">+static int nf_hook_cmp(struct nf_queue_entry *entry, unsigned long ops_ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return entry-&gt;elem == (struct nf_hook_ops *)ops_ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void nfqnl_nf_hook_drop(struct net *net, struct nf_hook_ops *hook)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfnl_queue_net *q = nfnl_queue_pernet(net);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for (i = 0; i &lt; INSTANCE_BUCKETS; i++) {</span>
<span class="p_add">+		struct nfqnl_instance *inst;</span>
<span class="p_add">+		struct hlist_head *head = &amp;q-&gt;instance_table[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_for_each_entry_rcu(inst, head, hlist)</span>
<span class="p_add">+			nfqnl_flush(inst, nf_hook_cmp, (unsigned long)hook);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfqnl_rcv_nl_event(struct notifier_block *this,
 		   unsigned long event, void *ptr)
<span class="p_chunk">@@ -1022,7 +1043,8 @@</span> <span class="p_context"> static const struct nla_policy nfqa_cfg_policy[NFQA_CFG_MAX+1] = {</span>
 };
 
 static const struct nf_queue_handler nfqh = {
<span class="p_del">-	.outfn	= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.outfn		= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.nf_hook_drop	= &amp;nfqnl_nf_hook_drop,</span>
 };
 
 static int
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 9cfe2e1..b215289 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1258,16 +1258,6 @@</span> <span class="p_context"> static void packet_sock_destruct(struct sock *sk)</span>
 	sk_refcnt_debug_dec(sk);
 }
 
<span class="p_del">-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int x = atomic_read(&amp;f-&gt;rr_cur) + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (x &gt;= num)</span>
<span class="p_del">-		x = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return x;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
<span class="p_chunk">@@ -1279,13 +1269,9 @@</span> <span class="p_context"> static unsigned int fanout_demux_lb(struct packet_fanout *f,</span>
 				    struct sk_buff *skb,
 				    unsigned int num)
 {
<span class="p_del">-	int cur, old;</span>
<span class="p_add">+	unsigned int val = atomic_inc_return(&amp;f-&gt;rr_cur);</span>
 
<span class="p_del">-	cur = atomic_read(&amp;f-&gt;rr_cur);</span>
<span class="p_del">-	while ((old = atomic_cmpxchg(&amp;f-&gt;rr_cur, cur,</span>
<span class="p_del">-				     fanout_rr_next(f, num))) != cur)</span>
<span class="p_del">-		cur = old;</span>
<span class="p_del">-	return cur;</span>
<span class="p_add">+	return val % num;</span>
 }
 
 static unsigned int fanout_demux_cpu(struct packet_fanout *f,
<span class="p_chunk">@@ -1339,7 +1325,7 @@</span> <span class="p_context"> static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,</span>
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt-&gt;af_packet_priv;
<span class="p_del">-	unsigned int num = f-&gt;num_members;</span>
<span class="p_add">+	unsigned int num = READ_ONCE(f-&gt;num_members);</span>
 	struct packet_sock *po;
 	unsigned int idx;
 
<span class="p_header">diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c</span>
<span class="p_header">index 43bac7c..58e759e 100644</span>
<span class="p_header">--- a/net/rose/af_rose.c</span>
<span class="p_header">+++ b/net/rose/af_rose.c</span>
<span class="p_chunk">@@ -192,7 +192,8 @@</span> <span class="p_context"> static void rose_kill_by_device(struct net_device *dev)</span>
 
 		if (rose-&gt;device == dev) {
 			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
<span class="p_del">-			rose-&gt;neighbour-&gt;use--;</span>
<span class="p_add">+			if (rose-&gt;neighbour)</span>
<span class="p_add">+				rose-&gt;neighbour-&gt;use--;</span>
 			rose-&gt;device = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index fc5e45b..abe7c2d 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -599,7 +599,9 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-	IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asoc)</span>
<span class="p_add">+		IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index aafe94b..4e56571 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1533,8 +1533,10 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
<span class="p_add">+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock</span>
<span class="p_add">+	 * held and that should be grabbed before socket lock.</span>
 	 */
<span class="p_del">-	local_bh_disable();</span>
<span class="p_add">+	spin_lock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 	bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
<span class="p_chunk">@@ -1544,7 +1546,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 	sk_common_release(sk);
 
 	bh_unlock_sock(sk);
<span class="p_del">-	local_bh_enable();</span>
<span class="p_add">+	spin_unlock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 
 	sock_put(sk);
 
<span class="p_chunk">@@ -3587,6 +3589,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 	if ((val &amp;&amp; sp-&gt;do_auto_asconf) || (!val &amp;&amp; !sp-&gt;do_auto_asconf))
 		return 0;
 
<span class="p_add">+	spin_lock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	if (val == 0 &amp;&amp; sp-&gt;do_auto_asconf) {
 		list_del(&amp;sp-&gt;auto_asconf_list);
 		sp-&gt;do_auto_asconf = 0;
<span class="p_chunk">@@ -3595,6 +3598,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 		    &amp;sock_net(sk)-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4128,18 +4132,28 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	local_bh_disable();
 	percpu_counter_inc(&amp;sctp_sockets_allocated);
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing can fail after this block, otherwise</span>
<span class="p_add">+	 * sctp_destroy_sock() will be called without addr_wq_lock held</span>
<span class="p_add">+	 */</span>
 	if (net-&gt;sctp.default_auto_asconf) {
<span class="p_add">+		spin_lock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 		list_add_tail(&amp;sp-&gt;auto_asconf_list,
 		    &amp;net-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
<span class="p_del">-	} else</span>
<span class="p_add">+		spin_unlock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
<span class="p_add">+	} else {</span>
 		sp-&gt;do_auto_asconf = 0;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_bh_enable();
 
 	return 0;
 }
 
<span class="p_del">-/* Cleanup any SCTP per socket resources.  */</span>
<span class="p_add">+/* Cleanup any SCTP per socket resources. Must be called with</span>
<span class="p_add">+ * sock_net(sk)-&gt;sctp.addr_wq_lock held if sp-&gt;do_auto_asconf is true</span>
<span class="p_add">+ */</span>
 static void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
<span class="p_chunk">@@ -7202,6 +7216,19 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_list = NULL;
 }
 
<span class="p_add">+static inline void sctp_copy_descendant(struct sock *sk_to,</span>
<span class="p_add">+					const struct sock *sk_from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ancestor_size = sizeof(struct inet_sock) +</span>
<span class="p_add">+			    sizeof(struct sctp_sock) -</span>
<span class="p_add">+			    offsetof(struct sctp_sock, auto_asconf_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sk_from-&gt;sk_family == PF_INET6)</span>
<span class="p_add">+		ancestor_size += sizeof(struct ipv6_pinfo);</span>
<span class="p_add">+</span>
<span class="p_add">+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
  * and its messages to the newsk.
  */
<span class="p_chunk">@@ -7216,7 +7243,6 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
<span class="p_del">-	struct list_head tmplist;</span>
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
<span class="p_chunk">@@ -7224,12 +7250,7 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	newsk-&gt;sk_sndbuf = oldsk-&gt;sk_sndbuf;
 	newsk-&gt;sk_rcvbuf = oldsk-&gt;sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
<span class="p_del">-	if (oldsp-&gt;do_auto_asconf) {</span>
<span class="p_del">-		memcpy(&amp;tmplist, &amp;newsp-&gt;auto_asconf_list, sizeof(tmplist));</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_del">-		memcpy(&amp;newsp-&gt;auto_asconf_list, &amp;tmplist, sizeof(tmplist));</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_add">+	sctp_copy_descendant(newsk, oldsk);</span>
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 9dd0ea8d..28504df 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 5488c36..da1d372 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -900,7 +900,7 @@</span> <span class="p_context"> int cfg80211_change_iface(struct cfg80211_registered_device *rdev,</span>
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
<span class="p_del">-	if (ntype != otype &amp;&amp; netif_running(dev)) {</span>
<span class="p_add">+	if (ntype != otype) {</span>
 		dev-&gt;ieee80211_ptr-&gt;use_4addr = false;
 		dev-&gt;ieee80211_ptr-&gt;mesh_id_up_len = 0;
 		wdev_lock(dev-&gt;ieee80211_ptr);
<span class="p_header">diff --git a/samples/bpf/Makefile b/samples/bpf/Makefile</span>
<span class="p_header">index b5b3600..0594a58 100644</span>
<span class="p_header">--- a/samples/bpf/Makefile</span>
<span class="p_header">+++ b/samples/bpf/Makefile</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> HOSTLOADLIBES_sockex2 += -lelf</span>
 # point this to your LLVM backend with bpf support
 LLC=$(srctree)/tools/bpf/llvm/bld/Debug+Asserts/bin/llc
 
<span class="p_del">-%.o: %.c</span>
<span class="p_add">+$(obj)/%.o: $(src)/%.c</span>
 	clang $(NOSTDINC_FLAGS) $(LINUXINCLUDE) $(EXTRA_CFLAGS) \
 		-D__KERNEL__ -Wno-unused-value -Wno-pointer-sign \
 		-O2 -emit-llvm -c $&lt; -o -| $(LLC) -march=bpf -filetype=obj -o $@
<span class="p_header">diff --git a/security/inode.c b/security/inode.c</span>
<span class="p_header">index 8e7ca62..a04489b 100644</span>
<span class="p_header">--- a/security/inode.c</span>
<span class="p_header">+++ b/security/inode.c</span>
<span class="p_chunk">@@ -215,19 +215,17 @@</span> <span class="p_context"> void securityfs_remove(struct dentry *dentry)</span>
 }
 EXPORT_SYMBOL_GPL(securityfs_remove);
 
<span class="p_del">-static struct kobject *security_kobj;</span>
<span class="p_del">-</span>
 static int __init securityfs_init(void)
 {
 	int retval;
 
<span class="p_del">-	security_kobj = kobject_create_and_add(&quot;security&quot;, kernel_kobj);</span>
<span class="p_del">-	if (!security_kobj)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	retval = sysfs_create_mount_point(kernel_kobj, &quot;security&quot;);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		return retval;</span>
 
 	retval = register_filesystem(&amp;fs_type);
 	if (retval)
<span class="p_del">-		kobject_put(security_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(kernel_kobj, &quot;security&quot;);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index 8ee997d..fc56d4d 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void ima_add_violation(struct file *file, const unsigned char *filename,</span>
 		       const char *op, const char *cause);
 int ima_init_crypto(void);
 void ima_putc(struct seq_file *m, void *data, int datalen);
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size);</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);</span>
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index 461215e..816d175 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -190,9 +190,9 @@</span> <span class="p_context"> static const struct file_operations ima_measurements_ops = {</span>
 	.release = seq_release,
 };
 
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size)</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	u32 i;</span>
 
 	for (i = 0; i &lt; size; i++)
 		seq_printf(m, &quot;%02x&quot;, *(digest + i));
<span class="p_header">diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c</span>
<span class="p_header">index d1eefb9..60ea656 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_policy.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_policy.c</span>
<span class="p_chunk">@@ -27,6 +27,8 @@</span> <span class="p_context"></span>
 #define IMA_UID		0x0008
 #define IMA_FOWNER	0x0010
 #define IMA_FSUUID	0x0020
<span class="p_add">+#define IMA_INMASK	0x0040</span>
<span class="p_add">+#define IMA_EUID	0x0080</span>
 
 #define UNKNOWN		0
 #define MEASURE		0x0001	/* same as IMA_MEASURE */
<span class="p_chunk">@@ -79,6 +81,9 @@</span> <span class="p_context"> static struct ima_rule_entry default_rules[] = {</span>
 	{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},
<span class="p_add">+	{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,</span>
<span class="p_add">+	 .flags = IMA_FSMAGIC},</span>
<span class="p_add">+	{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},</span>
 	{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,
 	 .flags = IMA_FUNC | IMA_MASK},
 	{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,
<span class="p_chunk">@@ -99,6 +104,7 @@</span> <span class="p_context"> static struct ima_rule_entry default_appraise_rules[] = {</span>
 	{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},
<span class="p_add">+	{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},</span>
 	{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},
 #ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT
 	{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .flags = IMA_FOWNER},
<span class="p_chunk">@@ -182,6 +188,9 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 	if ((rule-&gt;flags &amp; IMA_MASK) &amp;&amp;
 	    (rule-&gt;mask != mask &amp;&amp; func != POST_SETATTR))
 		return false;
<span class="p_add">+	if ((rule-&gt;flags &amp; IMA_INMASK) &amp;&amp;</span>
<span class="p_add">+	    (!(rule-&gt;mask &amp; mask) &amp;&amp; func != POST_SETATTR))</span>
<span class="p_add">+		return false;</span>
 	if ((rule-&gt;flags &amp; IMA_FSMAGIC)
 	    &amp;&amp; rule-&gt;fsmagic != inode-&gt;i_sb-&gt;s_magic)
 		return false;
<span class="p_chunk">@@ -190,6 +199,16 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 		return false;
 	if ((rule-&gt;flags &amp; IMA_UID) &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))
 		return false;
<span class="p_add">+	if (rule-&gt;flags &amp; IMA_EUID) {</span>
<span class="p_add">+		if (has_capability_noaudit(current, CAP_SETUID)) {</span>
<span class="p_add">+			if (!uid_eq(rule-&gt;uid, cred-&gt;euid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;suid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+		} else if (!uid_eq(rule-&gt;uid, cred-&gt;euid))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((rule-&gt;flags &amp; IMA_FOWNER) &amp;&amp; !uid_eq(rule-&gt;fowner, inode-&gt;i_uid))
 		return false;
 	for (i = 0; i &lt; MAX_LSM_RULES; i++) {
<span class="p_chunk">@@ -373,7 +392,8 @@</span> <span class="p_context"> enum {</span>
 	Opt_audit,
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
<span class="p_del">-	Opt_func, Opt_mask, Opt_fsmagic, Opt_uid, Opt_fowner,</span>
<span class="p_add">+	Opt_func, Opt_mask, Opt_fsmagic,</span>
<span class="p_add">+	Opt_uid, Opt_euid, Opt_fowner,</span>
 	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio
 };
 
<span class="p_chunk">@@ -394,6 +414,7 @@</span> <span class="p_context"> static match_table_t policy_tokens = {</span>
 	{Opt_fsmagic, &quot;fsmagic=%s&quot;},
 	{Opt_fsuuid, &quot;fsuuid=%s&quot;},
 	{Opt_uid, &quot;uid=%s&quot;},
<span class="p_add">+	{Opt_euid, &quot;euid=%s&quot;},</span>
 	{Opt_fowner, &quot;fowner=%s&quot;},
 	{Opt_appraise_type, &quot;appraise_type=%s&quot;},
 	{Opt_permit_directio, &quot;permit_directio&quot;},
<span class="p_chunk">@@ -435,6 +456,7 @@</span> <span class="p_context"> static void ima_log_string(struct audit_buffer *ab, char *key, char *value)</span>
 static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 {
 	struct audit_buffer *ab;
<span class="p_add">+	char *from;</span>
 	char *p;
 	int result = 0;
 
<span class="p_chunk">@@ -525,18 +547,23 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			if (entry-&gt;mask)
 				result = -EINVAL;
 
<span class="p_del">-			if ((strcmp(args[0].from, &quot;MAY_EXEC&quot;)) == 0)</span>
<span class="p_add">+			from = args[0].from;</span>
<span class="p_add">+			if (*from == &#39;^&#39;)</span>
<span class="p_add">+				from++;</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((strcmp(from, &quot;MAY_EXEC&quot;)) == 0)</span>
 				entry-&gt;mask = MAY_EXEC;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_WRITE&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_WRITE&quot;) == 0)</span>
 				entry-&gt;mask = MAY_WRITE;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_READ&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_READ&quot;) == 0)</span>
 				entry-&gt;mask = MAY_READ;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_APPEND&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_APPEND&quot;) == 0)</span>
 				entry-&gt;mask = MAY_APPEND;
 			else
 				result = -EINVAL;
 			if (!result)
<span class="p_del">-				entry-&gt;flags |= IMA_MASK;</span>
<span class="p_add">+				entry-&gt;flags |= (*args[0].from == &#39;^&#39;)</span>
<span class="p_add">+				     ? IMA_INMASK : IMA_MASK;</span>
 			break;
 		case Opt_fsmagic:
 			ima_log_string(ab, &quot;fsmagic&quot;, args[0].from);
<span class="p_chunk">@@ -566,6 +593,9 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			break;
 		case Opt_uid:
 			ima_log_string(ab, &quot;uid&quot;, args[0].from);
<span class="p_add">+		case Opt_euid:</span>
<span class="p_add">+			if (token == Opt_euid)</span>
<span class="p_add">+				ima_log_string(ab, &quot;euid&quot;, args[0].from);</span>
 
 			if (uid_valid(entry-&gt;uid)) {
 				result = -EINVAL;
<span class="p_chunk">@@ -574,11 +604,14 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 
 			result = kstrtoul(args[0].from, 10, &amp;lnum);
 			if (!result) {
<span class="p_del">-				entry-&gt;uid = make_kuid(current_user_ns(), (uid_t)lnum);</span>
<span class="p_del">-				if (!uid_valid(entry-&gt;uid) || (((uid_t)lnum) != lnum))</span>
<span class="p_add">+				entry-&gt;uid = make_kuid(current_user_ns(),</span>
<span class="p_add">+						       (uid_t) lnum);</span>
<span class="p_add">+				if (!uid_valid(entry-&gt;uid) ||</span>
<span class="p_add">+				    (uid_t)lnum != lnum)</span>
 					result = -EINVAL;
 				else
<span class="p_del">-					entry-&gt;flags |= IMA_UID;</span>
<span class="p_add">+					entry-&gt;flags |= (token == Opt_uid)</span>
<span class="p_add">+					    ? IMA_UID : IMA_EUID;</span>
 			}
 			break;
 		case Opt_fowner:
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index bcfc36c..61fbd0c 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -70,7 +70,8 @@</span> <span class="p_context"> static void ima_show_template_data_ascii(struct seq_file *m,</span>
 					 enum data_formats datafmt,
 					 struct ima_field_data *field_data)
 {
<span class="p_del">-	u8 *buf_ptr = field_data-&gt;data, buflen = field_data-&gt;len;</span>
<span class="p_add">+	u8 *buf_ptr = field_data-&gt;data;</span>
<span class="p_add">+	u32 buflen = field_data-&gt;len;</span>
 
 	switch (datafmt) {
 	case DATA_FMT_DIGEST_WITH_ALGO:
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 6da7532..7634300 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -403,7 +403,8 @@</span> <span class="p_context"> static int selinux_is_sblabel_mnt(struct super_block *sb)</span>
 
 	if (sbsec-&gt;behavior == SECURITY_FS_USE_XATTR ||
 	    sbsec-&gt;behavior == SECURITY_FS_USE_TRANS ||
<span class="p_del">-	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK)</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK ||</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_NATIVE)</span>
 		return 1;
 
 	/* Special handling for sysfs. Is genfs but also has setxattr handler*/
<span class="p_header">diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c</span>
<span class="p_header">index 138949a..181fcd3 100644</span>
<span class="p_header">--- a/security/selinux/selinuxfs.c</span>
<span class="p_header">+++ b/security/selinux/selinuxfs.c</span>
<span class="p_chunk">@@ -1899,7 +1899,6 @@</span> <span class="p_context"> static struct file_system_type sel_fs_type = {</span>
 };
 
 struct vfsmount *selinuxfs_mount;
<span class="p_del">-static struct kobject *selinuxfs_kobj;</span>
 
 static int __init init_sel_fs(void)
 {
<span class="p_chunk">@@ -1908,13 +1907,13 @@</span> <span class="p_context"> static int __init init_sel_fs(void)</span>
 	if (!selinux_enabled)
 		return 0;
 
<span class="p_del">-	selinuxfs_kobj = kobject_create_and_add(&quot;selinux&quot;, fs_kobj);</span>
<span class="p_del">-	if (!selinuxfs_kobj)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;selinux&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	err = register_filesystem(&amp;sel_fs_type);
 	if (err) {
<span class="p_del">-		kobject_put(selinuxfs_kobj);</span>
<span class="p_add">+		sysfs_remove_mount_point(fs_kobj, &quot;selinux&quot;);</span>
 		return err;
 	}
 
<span class="p_chunk">@@ -1933,7 +1932,7 @@</span> <span class="p_context"> __initcall(init_sel_fs);</span>
 #ifdef CONFIG_SECURITY_SELINUX_DISABLE
 void exit_sel_fs(void)
 {
<span class="p_del">-	kobject_put(selinuxfs_kobj);</span>
<span class="p_add">+	sysfs_remove_mount_point(fs_kobj, &quot;selinux&quot;);</span>
 	kern_unmount(selinuxfs_mount);
 	unregister_filesystem(&amp;sel_fs_type);
 }
<span class="p_header">diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c</span>
<span class="p_header">index bce4e8f..fb28f74 100644</span>
<span class="p_header">--- a/security/smack/smackfs.c</span>
<span class="p_header">+++ b/security/smack/smackfs.c</span>
<span class="p_chunk">@@ -2150,16 +2150,16 @@</span> <span class="p_context"> static const struct file_operations smk_revoke_subj_ops = {</span>
 	.llseek		= generic_file_llseek,
 };
 
<span class="p_del">-static struct kset *smackfs_kset;</span>
 /**
  * smk_init_sysfs - initialize /sys/fs/smackfs
  *
  */
 static int smk_init_sysfs(void)
 {
<span class="p_del">-	smackfs_kset = kset_create_and_add(&quot;smackfs&quot;, NULL, fs_kobj);</span>
<span class="p_del">-	if (!smackfs_kset)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	err = sysfs_create_mount_point(fs_kobj, &quot;smackfs&quot;);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 7f66dca..158ec63 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2094,6 +2094,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	{ PCI_DEVICE(0x1022, 0x780d),
 	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },
 	/* ATI HDMI */
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x1308),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0x793b),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
 	{ PCI_DEVICE(0x1002, 0x7919),
<span class="p_chunk">@@ -2102,6 +2104,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
 	{ PCI_DEVICE(0x1002, 0x970f),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x9840),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0xaa00),
 	  .driver_data = AZX_DRIVER_ATIHDMI | AZX_DCAPS_PRESET_ATI_HDMI },
 	{ PCI_DEVICE(0x1002, 0xaa08),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 008f1e6..652e6a8 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4299,6 +4299,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
 	ALC269_FIXUP_LIFEBOOK_HP_PIN,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -4319,6 +4320,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_DELL3_MIC_NO_PRESENCE,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
<span class="p_add">+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,</span>
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
<span class="p_chunk">@@ -4346,6 +4348,7 @@</span> <span class="p_context"> enum {</span>
 	ALC255_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
<span class="p_add">+	ALC292_FIXUP_TPT440_DOCK2,</span>
 	ALC283_FIXUP_BXBT2807_MIC,
 	ALC255_FIXUP_DELL_WMI_MIC_MUTE_LED,
 	ALC282_FIXUP_ASPIRE_V5_PINS,
<span class="p_chunk">@@ -4457,6 +4460,10 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4585,6 +4592,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
<span class="p_add">+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE,</span>
<span class="p_add">+	},</span>
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4787,6 +4803,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chain_id = ALC269_FIXUP_HEADSET_MODE
 	},
 	[ALC292_FIXUP_TPT440_DOCK] = {
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC292_FIXUP_TPT440_DOCK2</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ALC292_FIXUP_TPT440_DOCK2] = {</span>
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
 			{ 0x16, 0x21211010 }, /* dock headphone */
<span class="p_chunk">@@ -4838,6 +4860,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x029b, &quot;Acer 1810TZ&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;Acer AOD260&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x047c, &quot;Acer AC700&quot;, ALC269_FIXUP_ACER_AC700),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x072d, &quot;Acer Aspire V5-571G&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x080d, &quot;Acer Aspire V5-122P&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0740, &quot;Acer AO725&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0775, &quot;Acer Aspire E1-572&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK_E1_572),
<span class="p_chunk">@@ -4932,6 +4956,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9084, &quot;Sony VAIO&quot;, ALC275_FIXUP_SONY_HWEQ),
 	SND_PCI_QUIRK(0x104d, 0x9099, &quot;Sony VAIO S13&quot;, ALC275_FIXUP_SONY_DISABLE_AAMIX),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x159f, &quot;Lifebook E780&quot;, ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),</span>
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
<span class="p_header">diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c</span>
<span class="p_header">index 27141e2..a9d7348 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5645.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5645.c</span>
<span class="p_chunk">@@ -2582,6 +2582,8 @@</span> <span class="p_context"> static int rt5645_i2c_probe(struct i2c_client *i2c,</span>
 		}
 	}
 
<span class="p_add">+	INIT_DELAYED_WORK(&amp;rt5645-&gt;jack_detect_work, rt5645_jack_detect_work);</span>
<span class="p_add">+</span>
 	if (rt5645-&gt;i2c-&gt;irq) {
 		ret = request_threaded_irq(rt5645-&gt;i2c-&gt;irq, NULL, rt5645_irq,
 			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING
<span class="p_chunk">@@ -2600,8 +2602,6 @@</span> <span class="p_context"> static int rt5645_i2c_probe(struct i2c_client *i2c,</span>
 			dev_err(&amp;i2c-&gt;dev, &quot;Fail gpio_direction hp_det_gpio\n&quot;);
 	}
 
<span class="p_del">-	INIT_DELAYED_WORK(&amp;rt5645-&gt;jack_detect_work, rt5645_jack_detect_work);</span>
<span class="p_del">-</span>
 	return snd_soc_register_codec(&amp;i2c-&gt;dev, &amp;soc_codec_dev_rt5645,
 				      rt5645_dai, ARRAY_SIZE(rt5645_dai));
 }
<span class="p_header">diff --git a/sound/soc/codecs/tas2552.c b/sound/soc/codecs/tas2552.c</span>
<span class="p_header">index ae23acd..8f9d1e6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tas2552.c</span>
<span class="p_header">+++ b/sound/soc/codecs/tas2552.c</span>
<span class="p_chunk">@@ -120,6 +120,9 @@</span> <span class="p_context"> static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)</span>
 {
 	u8 cfg1_reg;
 
<span class="p_add">+	if (!tas_data-&gt;codec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (sw_shutdown)
 		cfg1_reg = 0;
 	else
<span class="p_chunk">@@ -335,7 +338,6 @@</span> <span class="p_context"> static DECLARE_TLV_DB_SCALE(dac_tlv, -7, 100, 24);</span>
 static const struct snd_kcontrol_new tas2552_snd_controls[] = {
 	SOC_SINGLE_TLV(&quot;Speaker Driver Playback Volume&quot;,
 			 TAS2552_PGA_GAIN, 0, 0x1f, 1, dac_tlv),
<span class="p_del">-	SOC_DAPM_SINGLE(&quot;Playback AMP&quot;, SND_SOC_NOPM, 0, 1, 0),</span>
 };
 
 static const struct reg_default tas2552_init_regs[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c</span>
<span class="p_header">index f439ae0..87ab899 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5102.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5102.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> struct wm5102_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index 4456b38..b90bd00 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index ada9ac1..51171e4 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -483,7 +483,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -497,7 +498,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db94931..0bb4a64 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 035bdc4..8b145b6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index a46e90d..4a4dc5c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c</span>
<span class="p_header">index 7e8bfe2..07f11fa 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8997.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8997.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct wm8997_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
<span class="p_header">diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">index cd146d4..b38b98c 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> static int imx_wm8962_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;audmux internal port setup failed\n&quot;);
 		return ret;
 	}
<span class="p_del">-	imx_audmux_v2_configure_port(ext_port,</span>
<span class="p_add">+	ret = imx_audmux_v2_configure_port(ext_port,</span>
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {
<span class="p_header">diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c</span>
<span class="p_header">index 57a16f4..6bc5e2a 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic.c</span>
<span class="p_chunk">@@ -1722,7 +1722,7 @@</span> <span class="p_context"> int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,</span>
 			goto out;
 	}
 
<span class="p_del">-	if (irq_num &gt;= kvm-&gt;arch.vgic.nr_irqs)</span>
<span class="p_add">+	if (irq_num &gt;= min(kvm-&gt;arch.vgic.nr_irqs, 1020))</span>
 		return -EINVAL;
 
 	vcpu_id = vgic_update_irq_pending(kvm, cpuid, irq_num, level);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



