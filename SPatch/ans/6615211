
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.4,000/172] 3.4.108-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.4,000/172] 3.4.108-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=109711">Zefan Li</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 16, 2015, 8:58 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1434445126-5273-1-git-send-email-lizf@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6615211/mbox/"
   >mbox</a>
|
   <a href="/patch/6615211/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6615211/">/patch/6615211/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 11E409F358
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 16 Jun 2015 09:02:09 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5EF922060A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 16 Jun 2015 09:01:59 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 47C962054A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 16 Jun 2015 09:01:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933256AbbFPJBa (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 16 Jun 2015 05:01:30 -0400
Received: from mail.kernel.org ([198.145.29.136]:58638 &quot;EHLO mail.kernel.org&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S932716AbbFPI7s (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 16 Jun 2015 04:59:48 -0400
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 0392D2054A;
	Tue, 16 Jun 2015 08:59:37 +0000 (UTC)
Received: from localhost.localdomain (unknown [183.247.163.231])
	(using TLSv1.2 with cipher AES128-SHA256 (128/128 bits))
	(No client certificate requested)
	by mail.kernel.org (Postfix) with ESMTPSA id 23BEB2053C;
	Tue, 16 Jun 2015 08:59:23 +0000 (UTC)
From: lizf@kernel.org
To: stable@vger.kernel.org
Cc: linux-kernel@vger.kernel.org, linux@roeck-us.net,
	Zefan Li &lt;lizefan@huawei.com&gt;
Subject: Re: [PATCH 3.4 000/172] 3.4.108-rc1 review
Date: Tue, 16 Jun 2015 16:58:46 +0800
Message-Id: &lt;1434445126-5273-1-git-send-email-lizf@kernel.org&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1434443587-4599-1-git-send-email-lizf@kernel.org&gt;
References: &lt;1434443587-4599-1-git-send-email-lizf@kernel.org&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=109711">Zefan Li</a> - June 16, 2015, 8:58 a.m.</div>
<pre class="content">
<span class="from">From: Zefan Li &lt;lizefan@huawei.com&gt;</span>

This is the combined patch for 3.4.106-rc1 relative to 3.4.105.

---

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f53f41a..22e3c17 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 107</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 108</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/alpha/kernel/pci-sysfs.c b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">index 53649c7..1a33355 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci-sysfs.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static int pci_mmap_resource(struct kobject *kobj,</span>
 	if (iomem_is_exclusive(res-&gt;start))
 		return -EINVAL;
 
<span class="p_del">-	pcibios_resource_to_bus(pdev, &amp;bar, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(pdev-&gt;bus, &amp;bar, res);</span>
 	vma-&gt;vm_pgoff += bar.start &gt;&gt; (PAGE_SHIFT - (sparse ? 5 : 0));
 	mmap_type = res-&gt;flags &amp; IORESOURCE_MEM ? pci_mmap_mem : pci_mmap_io;
 
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> static int sparse_mem_mmap_fits(struct pci_dev *pdev, int num)</span>
 	long dense_offset;
 	unsigned long sparse_size;
 
<span class="p_del">-	pcibios_resource_to_bus(pdev, &amp;bar, &amp;pdev-&gt;resource[num]);</span>
<span class="p_add">+	pcibios_resource_to_bus(pdev-&gt;bus, &amp;bar, &amp;pdev-&gt;resource[num]);</span>
 
 	/* All core logic chips have 4G sparse address space, except
 	   CIA which has 16G (see xxx_SPARSE_MEM and xxx_DENSE_MEM
<span class="p_header">diff --git a/arch/arm/mach-at91/pm.h b/arch/arm/mach-at91/pm.h</span>
<span class="p_header">index 89f56f3..8c3f8e8 100644</span>
<span class="p_header">--- a/arch/arm/mach-at91/pm.h</span>
<span class="p_header">+++ b/arch/arm/mach-at91/pm.h</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static inline void at91rm9200_standby(void)</span>
 		&quot;    mcr    p15, 0, %0, c7, c0, 4\n\t&quot;
 		&quot;    str    %5, [%1, %2]&quot;
 		:
<span class="p_del">-		: &quot;r&quot; (0), &quot;r&quot; (AT91_BASE_SYS), &quot;r&quot; (AT91RM9200_SDRAMC_LPR),</span>
<span class="p_add">+		: &quot;r&quot; (0), &quot;r&quot; (at91_ramc_base[0]), &quot;r&quot; (AT91RM9200_SDRAMC_LPR),</span>
 		  &quot;r&quot; (1), &quot;r&quot; (AT91RM9200_SDRAMC_SRR),
 		  &quot;r&quot; (lpr));
 }
<span class="p_header">diff --git a/arch/arm/mach-pxa/corgi.c b/arch/arm/mach-pxa/corgi.c</span>
<span class="p_header">index c1fe32d..f801fe8 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/corgi.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/corgi.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/i2c/pxa-i2c.h&gt;
 #include &lt;linux/io.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/spi/ads7846.h&gt;
 #include &lt;linux/spi/corgi_lcd.h&gt;
<span class="p_chunk">@@ -711,6 +712,8 @@</span> <span class="p_context"> static void __init corgi_init(void)</span>
 		sharpsl_nand_partitions[1].size = 53 * 1024 * 1024;
 
 	platform_add_devices(devices, ARRAY_SIZE(devices));
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init fixup_corgi(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-pxa/hx4700.c b/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_header">index b83b95a..f35a30f 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_chunk">@@ -881,6 +881,8 @@</span> <span class="p_context"> static void __init hx4700_init(void)</span>
 	mdelay(10);
 	gpio_set_value(GPIO71_HX4700_ASIC3_nRESET, 1);
 	mdelay(10);
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(H4700, &quot;HP iPAQ HX4700&quot;)
<span class="p_header">diff --git a/arch/arm/mach-pxa/poodle.c b/arch/arm/mach-pxa/poodle.c</span>
<span class="p_header">index 89d98c8..39d1068 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/poodle.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/poodle.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/i2c/pxa-i2c.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/spi/ads7846.h&gt;
 #include &lt;linux/spi/pxa2xx_spi.h&gt;
<span class="p_chunk">@@ -452,6 +453,7 @@</span> <span class="p_context"> static void __init poodle_init(void)</span>
 	pxa_set_i2c_info(NULL);
 	i2c_register_board_info(0, ARRAY_AND_SIZE(poodle_i2c_devices));
 	poodle_init_spi();
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init fixup_poodle(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-pxa/spitz.c b/arch/arm/mach-pxa/spitz.c</span>
<span class="p_header">index df2ab0f..a1647d0 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/spitz.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/spitz.c</span>
<span class="p_chunk">@@ -968,6 +968,8 @@</span> <span class="p_context"> static void __init spitz_init(void)</span>
 	spitz_nor_init();
 	spitz_nand_init();
 	spitz_i2c_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init spitz_fixup(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-sa1100/pm.c b/arch/arm/mach-sa1100/pm.c</span>
<span class="p_header">index 2fa499e..69bbe4e 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/pm.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static int sa11x0_pm_enter(suspend_state_t state)</span>
 	/*
 	 * Ensure not to come back here if it wasn&#39;t intended
 	 */
<span class="p_add">+	RCSR = RCSR_SMR;</span>
 	PSPR = 0;
 
 	/*
<span class="p_header">diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi</span>
<span class="p_header">index 1382fec..7fcb1ac 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi</span>
<span class="p_header">+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-0.dtsi</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> ethernet@b0000 {</span>
 	fsl,num_tx_queues = &lt;0x8&gt;;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
<span class="p_add">+	ranges;</span>
 
 	queue-group@b0000 {
 		#address-cells = &lt;1&gt;;
<span class="p_header">diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi</span>
<span class="p_header">index 221cd2e..9f25427 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi</span>
<span class="p_header">+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-1.dtsi</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> ethernet@b1000 {</span>
 	fsl,num_tx_queues = &lt;0x8&gt;;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
<span class="p_add">+	ranges;</span>
 
 	queue-group@b1000 {
 		#address-cells = &lt;1&gt;;
<span class="p_header">diff --git a/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi b/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi</span>
<span class="p_header">index 61456c3..cd7c318 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi</span>
<span class="p_header">+++ b/arch/powerpc/boot/dts/fsl/pq3-etsec2-2.dtsi</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"> ethernet@b2000 {</span>
 	fsl,num_tx_queues = &lt;0x8&gt;;
 	fsl,magic-packet;
 	local-mac-address = [ 00 00 00 00 00 00 ];
<span class="p_add">+	ranges;</span>
 
 	queue-group@b2000 {
 		#address-cells = &lt;1&gt;;
<span class="p_header">diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">index 89dde17..55551a8 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)</span>
 		res-&gt;name = pci_name(dev);
 		region.start = base;
 		region.end = base + size - 1;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 	}
 }
 
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> void __devinit of_scan_pci_bridge(struct pci_dev *dev)</span>
 		res-&gt;flags = flags;
 		region.start = of_read_number(&amp;ranges[1], 2);
 		region.end = region.start + size - 1;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 	}
 	sprintf(bus-&gt;name, &quot;PCI Bus %04x:%02x&quot;, pci_domain_nr(bus),
 		bus-&gt;number);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 5da8e8d..79a17f7 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> static void __devinit pnv_ioda_setup_pe_segments(struct pci_dev *dev)</span>
 
 	/* Setup IO segments */
 	if (io_res.start &lt; io_res.end) {
<span class="p_del">-		pcibios_resource_to_bus(dev, &amp;region, &amp;io_res);</span>
<span class="p_add">+		pcibios_resource_to_bus(dev-&gt;bus, &amp;region, &amp;io_res);</span>
 		pos = region.start;
 		i = pos / phb-&gt;ioda.io_segsize;
 		while(i &lt; phb-&gt;ioda.total_pe &amp;&amp; pos &lt;= region.end) {
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static void __devinit pnv_ioda_setup_pe_segments(struct pci_dev *dev)</span>
 
 	/* Setup M32 segments */
 	if (m32_res.start &lt; m32_res.end) {
<span class="p_del">-		pcibios_resource_to_bus(dev, &amp;region, &amp;m32_res);</span>
<span class="p_add">+		pcibios_resource_to_bus(dev-&gt;bus, &amp;region, &amp;m32_res);</span>
 		pos = region.start;
 		i = pos / phb-&gt;ioda.m32_segsize;
 		while(i &lt; phb-&gt;ioda.total_pe &amp;&amp; pos &lt;= region.end) {
<span class="p_header">diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">index 1c16141..1fea249 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> axon_ram_direct_access(struct block_device *device, sector_t sector,</span>
 	}
 
 	*kaddr = (void *)(bank-&gt;ph_addr + offset);
<span class="p_del">-	*pfn = virt_to_phys(kaddr) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	*pfn = virt_to_phys(*kaddr) &gt;&gt; PAGE_SHIFT;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">index 0f250d1..7e6ac1f 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)</span>
 	vcpu-&gt;arch.sie_block-&gt;ecb   = 6;
 	vcpu-&gt;arch.sie_block-&gt;eca   = 0xC1002001U;
 	vcpu-&gt;arch.sie_block-&gt;fac   = (int) (long) facilities;
<span class="p_del">-	hrtimer_init(&amp;vcpu-&gt;arch.ckc_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);</span>
<span class="p_add">+	hrtimer_init(&amp;vcpu-&gt;arch.ckc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span>
 	tasklet_init(&amp;vcpu-&gt;arch.tasklet, kvm_s390_tasklet,
 		     (unsigned long) vcpu);
 	vcpu-&gt;arch.ckc_timer.function = kvm_s390_idle_wakeup;
<span class="p_header">diff --git a/arch/sparc/kernel/pci.c b/arch/sparc/kernel/pci.c</span>
<span class="p_header">index 8c5c9a5..ab5f471 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci.c</span>
<span class="p_chunk">@@ -409,7 +409,7 @@</span> <span class="p_context"> static void __devinit pci_cfg_fake_ranges(struct pci_dev *dev,</span>
 		res2.flags = res-&gt;flags;
 		region.start = base;
 		region.end = limit + 0xfff;
<span class="p_del">-		pcibios_bus_to_resource(dev, &amp;res2, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, &amp;res2, &amp;region);</span>
 		if (!res-&gt;start)
 			res-&gt;start = res2.start;
 		if (!res-&gt;end)
<span class="p_chunk">@@ -427,7 +427,7 @@</span> <span class="p_context"> static void __devinit pci_cfg_fake_ranges(struct pci_dev *dev,</span>
 			      IORESOURCE_MEM);
 		region.start = base;
 		region.end = limit + 0xfffff;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 	}
 
 	pci_read_config_word(dev, PCI_PREF_MEMORY_BASE, &amp;mem_base_lo);
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> static void __devinit pci_cfg_fake_ranges(struct pci_dev *dev,</span>
 			      IORESOURCE_MEM | IORESOURCE_PREFETCH);
 		region.start = base;
 		region.end = limit + 0xfffff;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 	}
 }
 
<span class="p_chunk">@@ -480,7 +480,7 @@</span> <span class="p_context"> static void __devinit apb_fake_ranges(struct pci_dev *dev,</span>
 	res-&gt;flags = IORESOURCE_IO;
 	region.start = (first &lt;&lt; 21);
 	region.end = (last &lt;&lt; 21) + ((1 &lt;&lt; 21) - 1);
<span class="p_del">-	pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+	pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 
 	pci_read_config_byte(dev, APB_MEM_ADDRESS_MAP, &amp;map);
 	apb_calc_first_last(map, &amp;first, &amp;last);
<span class="p_chunk">@@ -488,7 +488,7 @@</span> <span class="p_context"> static void __devinit apb_fake_ranges(struct pci_dev *dev,</span>
 	res-&gt;flags = IORESOURCE_MEM;
 	region.start = (first &lt;&lt; 29);
 	region.end = (last &lt;&lt; 29) + ((1 &lt;&lt; 29) - 1);
<span class="p_del">-	pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+	pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 }
 
 static void __devinit pci_of_scan_bus(struct pci_pbm_info *pbm,
<span class="p_chunk">@@ -579,7 +579,7 @@</span> <span class="p_context"> static void __devinit of_scan_pci_bridge(struct pci_pbm_info *pbm,</span>
 		res-&gt;flags = flags;
 		region.start = GET_64BIT(ranges, 1);
 		region.end = region.start + size - 1;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 	}
 after_ranges:
 	sprintf(bus-&gt;name, &quot;PCI Bus %04x:%02x&quot;, pci_domain_nr(bus),
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 917c109..eda8cb9 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> config SBUS</span>
 	bool
 
 config NEED_DMA_MAP_STATE
<span class="p_del">-       def_bool (X86_64 || INTEL_IOMMU || DMA_API_DEBUG)</span>
<span class="p_add">+       def_bool (X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB)</span>
 
 config NEED_SG_DMA_LENGTH
 	def_bool y
<span class="p_header">diff --git a/arch/x86/crypto/aesni-intel_glue.c b/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_header">index c799352..51afabd 100644</span>
<span class="p_header">--- a/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_chunk">@@ -1203,7 +1203,7 @@</span> <span class="p_context"> static int __driver_rfc4106_decrypt(struct aead_request *req)</span>
 		src = kmalloc(req-&gt;cryptlen + req-&gt;assoclen, GFP_ATOMIC);
 		if (!src)
 			return -ENOMEM;
<span class="p_del">-		assoc = (src + req-&gt;cryptlen + auth_tag_len);</span>
<span class="p_add">+		assoc = (src + req-&gt;cryptlen);</span>
 		scatterwalk_map_and_copy(src, req-&gt;src, 0, req-&gt;cryptlen, 0);
 		scatterwalk_map_and_copy(assoc, req-&gt;assoc, 0,
 			req-&gt;assoclen, 0);
<span class="p_chunk">@@ -1228,7 +1228,7 @@</span> <span class="p_context"> static int __driver_rfc4106_decrypt(struct aead_request *req)</span>
 		scatterwalk_done(&amp;src_sg_walk, 0, 0);
 		scatterwalk_done(&amp;assoc_sg_walk, 0, 0);
 	} else {
<span class="p_del">-		scatterwalk_map_and_copy(dst, req-&gt;dst, 0, req-&gt;cryptlen, 1);</span>
<span class="p_add">+		scatterwalk_map_and_copy(dst, req-&gt;dst, 0, tempCipherLen, 1);</span>
 		kfree(src);
 	}
 	return retval;
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 45f9c70..8b49131 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -414,11 +414,14 @@</span> <span class="p_context"> ENTRY(ret_from_fork)</span>
 	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
 	jz   retint_restore_args
 
<span class="p_del">-	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET</span>
<span class="p_del">-	jnz  int_ret_from_sys_call</span>
<span class="p_del">-</span>
<span class="p_del">-	RESTORE_TOP_OF_STACK %rdi, -ARGOFFSET</span>
<span class="p_del">-	jmp ret_from_sys_call			# go to the SYSRET fastpath</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * By the time we get here, we have no idea whether our pt_regs,</span>
<span class="p_add">+	 * ti flags, and ti status came from the 64-bit SYSCALL fast path,</span>
<span class="p_add">+	 * the slow path, or one of the ia32entry paths.</span>
<span class="p_add">+	 * Use int_ret_from_sys_call to return, since it can safely handle</span>
<span class="p_add">+	 * all of the above.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	jmp  int_ret_from_sys_call</span>
 
 	CFI_ENDPROC
 END(ret_from_fork)
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index d398f31..310cb01 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -439,6 +439,17 @@</span> <span class="p_context"> static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+</span>
<span class="p_add">+	/* ASRock */</span>
<span class="p_add">+	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;ASRock Q1900DC-ITX&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;ASRock&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;Q1900DC-ITX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	{	/* Handle problems with rebooting on the Latitude E6320. */
 		.callback = set_pci_reboot,
 		.ident = &quot;Dell Latitude E6320&quot;,
<span class="p_chunk">@@ -690,9 +701,12 @@</span> <span class="p_context"> void native_machine_shutdown(void)</span>
 	/* Make certain I only run on the appropriate processor */
 	set_cpus_allowed_ptr(current, cpumask_of(reboot_cpu_id));
 
<span class="p_del">-	/* O.K Now that I&#39;m on the appropriate processor,</span>
<span class="p_del">-	 * stop all of the others.</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * O.K Now that I&#39;m on the appropriate processor, stop all of the</span>
<span class="p_add">+	 * others. Also disable the local irq to not receive the per-cpu</span>
<span class="p_add">+	 * timer interrupt which may trigger scheduler&#39;s load balance.</span>
 	 */
<span class="p_add">+	local_irq_disable();</span>
 	stop_other_cpus();
 #endif
 
<span class="p_header">diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c</span>
<span class="p_header">index 9bfe95f..adc049f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/traps.c</span>
<span class="p_header">+++ b/arch/x86/kernel/traps.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)</span>
 	 * then it&#39;s very likely the result of an icebp/int01 trap.
 	 * User wants a sigtrap for that.
 	 */
<span class="p_del">-	if (!dr6 &amp;&amp; user_mode(regs))</span>
<span class="p_add">+	if (!dr6 &amp;&amp; user_mode_vm(regs))</span>
 		user_icebp = 1;
 
 	/* Catch kmemcheck conditions first of all! */
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 91e8680..db08e66 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -4246,7 +4246,8 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 		if (rc != X86EMUL_CONTINUE)
 			goto done;
 	}
<span class="p_del">-	ctxt-&gt;dst.orig_val = ctxt-&gt;dst.val;</span>
<span class="p_add">+	/* Copy full 64-bit value for CMPXCHG8B.  */</span>
<span class="p_add">+	ctxt-&gt;dst.orig_val64 = ctxt-&gt;dst.val64;</span>
 
 special_insn:
 
<span class="p_header">diff --git a/arch/x86/vdso/vdso32/sigreturn.S b/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_header">index 31776d0..d7ec4e2 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 	.text
 	.globl __kernel_sigreturn
 	.type __kernel_sigreturn,@function
<span class="p_add">+	nop /* this guy is needed for .LSTARTFDEDLSI1 below (watch for HACK) */</span>
 	ALIGN
 __kernel_sigreturn:
 .LSTART_sigreturn:
<span class="p_header">diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c</span>
<span class="p_header">index 8c5ad89..89cff37 100644</span>
<span class="p_header">--- a/drivers/acpi/video.c</span>
<span class="p_header">+++ b/drivers/acpi/video.c</span>
<span class="p_chunk">@@ -1872,6 +1872,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(acpi_video_unregister);</span>
 
 static int __init acpi_video_init(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Let the module load even if ACPI is disabled (e.g. due to</span>
<span class="p_add">+	 * a broken BIOS) so that i915.ko can still be loaded on such</span>
<span class="p_add">+	 * old systems without an AcpiOpRegion.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * acpi_video_register() will report -ENODEV later as well due</span>
<span class="p_add">+	 * to acpi_disabled when i915.ko tries to register itself afterwards.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (acpi_disabled)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	dmi_check_system(video_dmi_table);
 
 	if (intel_opregion_present())
<span class="p_header">diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c</span>
<span class="p_header">index 35fc569..eac3705 100644</span>
<span class="p_header">--- a/drivers/block/nbd.c</span>
<span class="p_header">+++ b/drivers/block/nbd.c</span>
<span class="p_chunk">@@ -773,10 +773,6 @@</span> <span class="p_context"> static int __init nbd_init(void)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);</span>
<span class="p_del">-	if (!nbd_dev)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	part_shift = 0;
 	if (max_part &gt; 0) {
 		part_shift = fls(max_part);
<span class="p_chunk">@@ -798,6 +794,10 @@</span> <span class="p_context"> static int __init nbd_init(void)</span>
 	if (nbds_max &gt; 1UL &lt;&lt; (MINORBITS - part_shift))
 		return -EINVAL;
 
<span class="p_add">+	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);</span>
<span class="p_add">+	if (!nbd_dev)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; nbds_max; i++) {
 		struct gendisk *disk = alloc_disk(1 &lt;&lt; part_shift);
 		if (!disk)
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 02fbbf7..8a084bf 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393) },
 	{ USB_DEVICE(0x13d3, 0x3402) },
 	{ USB_DEVICE(0x13d3, 0x3408) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423) },</span>
 	{ USB_DEVICE(0x13d3, 0x3432) },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_chunk">@@ -149,6 +150,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU22 with sflash firmware */
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index ddb2b87..7c0b21e 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -179,6 +179,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index a81f469..96f4a50 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -124,6 +124,7 @@</span> <span class="p_context"> struct ports_device {</span>
 	 * notification
 	 */
 	struct work_struct control_work;
<span class="p_add">+	struct work_struct config_work;</span>
 
 	struct list_head ports;
 
<span class="p_chunk">@@ -1555,10 +1556,21 @@</span> <span class="p_context"> static void config_intr(struct virtio_device *vdev)</span>
 
 	portdev = vdev-&gt;priv;
 
<span class="p_add">+	if (!use_multiport(portdev))</span>
<span class="p_add">+		schedule_work(&amp;portdev-&gt;config_work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void config_work_handler(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ports_device *portdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	portdev = container_of(work, struct ports_device, control_work);</span>
 	if (!use_multiport(portdev)) {
<span class="p_add">+		struct virtio_device *vdev;</span>
 		struct port *port;
 		u16 rows, cols;
 
<span class="p_add">+		vdev = portdev-&gt;vdev;</span>
 		vdev-&gt;config-&gt;get(vdev,
 				  offsetof(struct virtio_console_config, cols),
 				  &amp;cols, sizeof(u16));
<span class="p_chunk">@@ -1752,12 +1764,14 @@</span> <span class="p_context"> static int __devinit virtcons_probe(struct virtio_device *vdev)</span>
 	spin_lock_init(&amp;portdev-&gt;ports_lock);
 	INIT_LIST_HEAD(&amp;portdev-&gt;ports);
 
<span class="p_add">+	INIT_WORK(&amp;portdev-&gt;config_work, &amp;config_work_handler);</span>
<span class="p_add">+	INIT_WORK(&amp;portdev-&gt;control_work, &amp;control_work_handler);</span>
<span class="p_add">+</span>
 	if (multiport) {
 		unsigned int nr_added_bufs;
 
 		spin_lock_init(&amp;portdev-&gt;c_ivq_lock);
 		spin_lock_init(&amp;portdev-&gt;c_ovq_lock);
<span class="p_del">-		INIT_WORK(&amp;portdev-&gt;control_work, &amp;control_work_handler);</span>
 
 		nr_added_bufs = fill_queue(portdev-&gt;c_ivq,
 					   &amp;portdev-&gt;c_ivq_lock);
<span class="p_chunk">@@ -1825,6 +1839,8 @@</span> <span class="p_context"> static void virtcons_remove(struct virtio_device *vdev)</span>
 	/* Finish up work that&#39;s lined up */
 	if (use_multiport(portdev))
 		cancel_work_sync(&amp;portdev-&gt;control_work);
<span class="p_add">+	else</span>
<span class="p_add">+		cancel_work_sync(&amp;portdev-&gt;config_work);</span>
 
 	list_for_each_entry_safe(port, port2, &amp;portdev-&gt;ports, list)
 		unplug_port(port);
<span class="p_chunk">@@ -1866,6 +1882,7 @@</span> <span class="p_context"> static int virtcons_freeze(struct virtio_device *vdev)</span>
 
 	virtqueue_disable_cb(portdev-&gt;c_ivq);
 	cancel_work_sync(&amp;portdev-&gt;control_work);
<span class="p_add">+	cancel_work_sync(&amp;portdev-&gt;config_work);</span>
 	/*
 	 * Once more: if control_work_handler() was running, it would
 	 * enable the cb as the last step.
<span class="p_header">diff --git a/drivers/cpufreq/speedstep-lib.c b/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_header">index 7047821..4ab7a21 100644</span>
<span class="p_header">--- a/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_header">+++ b/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_chunk">@@ -400,6 +400,7 @@</span> <span class="p_context"> unsigned int speedstep_get_freqs(enum speedstep_processor processor,</span>
 
 	pr_debug(&quot;previous speed is %u\n&quot;, prev_speed);
 
<span class="p_add">+	preempt_disable();</span>
 	local_irq_save(flags);
 
 	/* switch to low state */
<span class="p_chunk">@@ -464,6 +465,8 @@</span> <span class="p_context"> unsigned int speedstep_get_freqs(enum speedstep_processor processor,</span>
 
 out:
 	local_irq_restore(flags);
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
 	return ret;
 }
 EXPORT_SYMBOL_GPL(speedstep_get_freqs);
<span class="p_header">diff --git a/drivers/cpufreq/speedstep-smi.c b/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_header">index 6a457fc..b01926d 100644</span>
<span class="p_header">--- a/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_header">+++ b/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_chunk">@@ -188,6 +188,7 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 		return;
 
 	/* Disable IRQs */
<span class="p_add">+	preempt_disable();</span>
 	local_irq_save(flags);
 
 	command = (smi_sig &amp; 0xffffff00) | (smi_cmd &amp; 0xff);
<span class="p_chunk">@@ -198,9 +199,19 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 
 	do {
 		if (retry) {
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We need to enable interrupts, otherwise the blockage</span>
<span class="p_add">+			 * won&#39;t resolve.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * We disable preemption so that other processes don&#39;t</span>
<span class="p_add">+			 * run. If other processes were running, they could</span>
<span class="p_add">+			 * submit more DMA requests, making the blockage worse.</span>
<span class="p_add">+			 */</span>
 			pr_debug(&quot;retry %u, previous result %u, waiting...\n&quot;,
 					retry, result);
<span class="p_add">+			local_irq_enable();</span>
 			mdelay(retry * 50);
<span class="p_add">+			local_irq_disable();</span>
 		}
 		retry++;
 		__asm__ __volatile__(
<span class="p_chunk">@@ -217,6 +228,7 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 
 	/* enable IRQs */
 	local_irq_restore(flags);
<span class="p_add">+	preempt_enable();</span>
 
 	if (new_state == state)
 		pr_debug(&quot;change to %u MHz succeeded after %u tries &quot;
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 0924c30..593ff71 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -672,7 +672,7 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	u32 reg;
 	u64 limit, prv = 0;
 	u64 tmp_mb;
<span class="p_del">-	u32 mb, kb;</span>
<span class="p_add">+	u32 gb, mb;</span>
 	u32 rir_way;
 
 	/*
<span class="p_chunk">@@ -685,9 +685,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	pvt-&gt;tolm = GET_TOLM(reg);
 	tmp_mb = (1 + pvt-&gt;tolm) &gt;&gt; 20;
 
<span class="p_del">-	mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_del">-	debugf0(&quot;TOLM: %u.%03u GB (0x%016Lx)\n&quot;,</span>
<span class="p_del">-		mb, kb, (u64)pvt-&gt;tolm);</span>
<span class="p_add">+	gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
<span class="p_add">+	debugf0(&quot;TOHM: %u.%03u GB (0x%016Lx)\n&quot;,</span>
<span class="p_add">+		gb, (mb*1000)/1024, (u64)pvt-&gt;tohm);</span>
 
 	/* Address range is already 45:25 */
 	pci_read_config_dword(pvt-&gt;pci_sad1, TOHM,
<span class="p_chunk">@@ -695,9 +695,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 	pvt-&gt;tohm = GET_TOHM(reg);
 	tmp_mb = (1 + pvt-&gt;tohm) &gt;&gt; 20;
 
<span class="p_del">-	mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+	gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
 	debugf0(&quot;TOHM: %u.%03u GB (0x%016Lx)&quot;,
<span class="p_del">-		mb, kb, (u64)pvt-&gt;tohm);</span>
<span class="p_add">+		gb, (mb*1000)/1024, (u64)pvt-&gt;tohm);</span>
 
 	/*
 	 * Step 2) Get SAD range and SAD Interleave list
<span class="p_chunk">@@ -719,11 +719,11 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 			break;
 
 		tmp_mb = (limit + 1) &gt;&gt; 20;
<span class="p_del">-		mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+		gb = div_u64_rem(tmp_mb, 1000, &amp;mb);</span>
 		debugf0(&quot;SAD#%d %s up to %u.%03u GB (0x%016Lx) %s reg=0x%08x\n&quot;,
 			n_sads,
 			get_dram_attr(reg),
<span class="p_del">-			mb, kb,</span>
<span class="p_add">+			gb, (mb*1000)/1024,</span>
 			((u64)tmp_mb) &lt;&lt; 20L,
 			INTERLEAVE_MODE(reg) ? &quot;Interleave: 8:6&quot; : &quot;Interleave: [8:6]XOR[18:16]&quot;,
 			reg);
<span class="p_chunk">@@ -753,9 +753,9 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 			break;
 		tmp_mb = (limit + 1) &gt;&gt; 20;
 
<span class="p_del">-		mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+		gb = div_u64_rem(tmp_mb, 1000, &amp;mb);</span>
 		debugf0(&quot;TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n&quot;,
<span class="p_del">-			n_tads, mb, kb,</span>
<span class="p_add">+			n_tads, gb, (mb*1000)/1024,</span>
 			((u64)tmp_mb) &lt;&lt; 20L,
 			(u32)TAD_SOCK(reg),
 			(u32)TAD_CH(reg),
<span class="p_chunk">@@ -778,10 +778,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 					      tad_ch_nilv_offset[j],
 					      &amp;reg);
 			tmp_mb = TAD_OFFSET(reg) &gt;&gt; 20;
<span class="p_del">-			mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+			gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
 			debugf0(&quot;TAD CH#%d, offset #%d: %u.%03u GB (0x%016Lx), reg=0x%08x\n&quot;,
 				i, j,
<span class="p_del">-				mb, kb,</span>
<span class="p_add">+				gb, (mb*1000)/1024,</span>
 				((u64)tmp_mb) &lt;&lt; 20L,
 				reg);
 		}
<span class="p_chunk">@@ -803,10 +803,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 
 			tmp_mb = RIR_LIMIT(reg) &gt;&gt; 20;
 			rir_way = 1 &lt;&lt; RIR_WAY(reg);
<span class="p_del">-			mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+			gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
 			debugf0(&quot;CH#%d RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d, reg=0x%08x\n&quot;,
 				i, j,
<span class="p_del">-				mb, kb,</span>
<span class="p_add">+				gb, (mb*1000)/1024,</span>
 				((u64)tmp_mb) &lt;&lt; 20L,
 				rir_way,
 				reg);
<span class="p_chunk">@@ -817,10 +817,10 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 						      &amp;reg);
 				tmp_mb = RIR_OFFSET(reg) &lt;&lt; 6;
 
<span class="p_del">-				mb = div_u64_rem(tmp_mb, 1000, &amp;kb);</span>
<span class="p_add">+				gb = div_u64_rem(tmp_mb, 1024, &amp;mb);</span>
 				debugf0(&quot;CH#%d RIR#%d INTL#%d, offset %u.%03u GB (0x%016Lx), tgt: %d, reg=0x%08x\n&quot;,
 					i, j, k,
<span class="p_del">-					mb, kb,</span>
<span class="p_add">+					gb, (mb*1000)/1024,</span>
 					((u64)tmp_mb) &lt;&lt; 20L,
 					(u32)RIR_RNK_TGT(reg),
 					reg);
<span class="p_chunk">@@ -858,7 +858,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	u8			ch_way,sck_way;
 	u32			tad_offset;
 	u32			rir_way;
<span class="p_del">-	u32			mb, kb;</span>
<span class="p_add">+	u32			gb, mb;</span>
 	u64			ch_addr, offset, limit, prv = 0;
 
 
<span class="p_chunk">@@ -1084,10 +1084,10 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 			continue;
 
 		limit = RIR_LIMIT(reg);
<span class="p_del">-		mb = div_u64_rem(limit &gt;&gt; 20, 1000, &amp;kb);</span>
<span class="p_add">+		gb = div_u64_rem(limit &gt;&gt; 20, 1024, &amp;mb);</span>
 		debugf0(&quot;RIR#%d, limit: %u.%03u GB (0x%016Lx), way: %d\n&quot;,
 			n_rir,
<span class="p_del">-			mb, kb,</span>
<span class="p_add">+			gb, (mb*1000)/1024,</span>
 			limit,
 			1 &lt;&lt; RIR_WAY(reg));
 		if  (ch_addr &lt;= limit)
<span class="p_header">diff --git a/drivers/gpio/gpio-tps65912.c b/drivers/gpio/gpio-tps65912.c</span>
<span class="p_header">index 79e66c0..2712680 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-tps65912.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-tps65912.c</span>
<span class="p_chunk">@@ -26,9 +26,12 @@</span> <span class="p_context"> struct tps65912_gpio_data {</span>
 	struct gpio_chip gpio_chip;
 };
 
<span class="p_add">+#define to_tgd(gc) container_of(gc, struct tps65912_gpio_data, gpio_chip)</span>
<span class="p_add">+</span>
 static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 	int val;
 
 	val = tps65912_reg_read(tps65912, TPS65912_GPIO1 + offset);
<span class="p_chunk">@@ -42,7 +45,8 @@</span> <span class="p_context"> static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)</span>
 static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,
 			      int value)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	if (value)
 		tps65912_set_bits(tps65912, TPS65912_GPIO1 + offset,
<span class="p_chunk">@@ -55,7 +59,8 @@</span> <span class="p_context"> static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,</span>
 static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,
 				int value)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	/* Set the initial value */
 	tps65912_gpio_set(gc, offset, value);
<span class="p_chunk">@@ -66,7 +71,8 @@</span> <span class="p_context"> static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,</span>
 
 static int tps65912_gpio_input(struct gpio_chip *gc, unsigned offset)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	return tps65912_clear_bits(tps65912, TPS65912_GPIO1 + offset,
 								GPIO_CFG_MASK);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 8d1724c..5325c20 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -777,10 +777,8 @@</span> <span class="p_context"> static int radeon_dp_link_train_init(struct radeon_dp_link_train_info *dp_info)</span>
 		radeon_write_dpcd_reg(dp_info-&gt;radeon_connector,
 				      DP_DOWNSPREAD_CTRL, 0);
 
<span class="p_del">-	if ((dp_info-&gt;connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP) &amp;&amp;</span>
<span class="p_del">-	    (dig-&gt;panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)) {</span>
<span class="p_add">+	if (dig-&gt;panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)</span>
 		radeon_write_dpcd_reg(dp_info-&gt;radeon_connector, DP_EDP_CONFIGURATION_SET, 1);
<span class="p_del">-	}</span>
 
 	/* set the lane count on the sink */
 	tmp = dp_info-&gt;dp_lane_count;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index 01434ef..c5fe79e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -3474,6 +3474,9 @@</span> <span class="p_context"> int evergreen_init(struct radeon_device *rdev)</span>
 		}
 	}
 
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(SRBM_STATUS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_header">index 40ed0e5..8ec5b85 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_chunk">@@ -726,6 +726,10 @@</span> <span class="p_context"> int r100_irq_set(struct radeon_device *rdev)</span>
 		tmp |= RADEON_FP2_DETECT_MASK;
 	}
 	WREG32(RADEON_GEN_INT_CNTL, tmp);
<span class="p_add">+</span>
<span class="p_add">+	/* read back to post the write */</span>
<span class="p_add">+	RREG32(RADEON_GEN_INT_CNTL);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">index 1555cd6..9c7062d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_chunk">@@ -3184,6 +3184,9 @@</span> <span class="p_context"> int r600_irq_set(struct radeon_device *rdev)</span>
 		WREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, hpd3);
 	}
 
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(R_000E50_SRBM_STATUS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_bios.c b/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_header">index d306cc8..ef56e4e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static bool igp_read_bios_from_vram(struct radeon_device *rdev)</span>
 
 static bool radeon_read_bios(struct radeon_device *rdev)
 {
<span class="p_del">-	uint8_t __iomem *bios;</span>
<span class="p_add">+	uint8_t __iomem *bios, val1, val2;</span>
 	size_t size;
 
 	rdev-&gt;bios = NULL;
<span class="p_chunk">@@ -86,15 +86,19 @@</span> <span class="p_context"> static bool radeon_read_bios(struct radeon_device *rdev)</span>
 		return false;
 	}
 
<span class="p_del">-	if (size == 0 || bios[0] != 0x55 || bios[1] != 0xaa) {</span>
<span class="p_add">+	val1 = readb(&amp;bios[0]);</span>
<span class="p_add">+	val2 = readb(&amp;bios[1]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size == 0 || val1 != 0x55 || val2 != 0xaa) {</span>
 		pci_unmap_rom(rdev-&gt;pdev, bios);
 		return false;
 	}
<span class="p_del">-	rdev-&gt;bios = kmemdup(bios, size, GFP_KERNEL);</span>
<span class="p_add">+	rdev-&gt;bios = kzalloc(size, GFP_KERNEL);</span>
 	if (rdev-&gt;bios == NULL) {
 		pci_unmap_rom(rdev-&gt;pdev, bios);
 		return false;
 	}
<span class="p_add">+	memcpy_fromio(rdev-&gt;bios, bios, size);</span>
 	pci_unmap_rom(rdev-&gt;pdev, bios);
 	return true;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">index cf723c4..f3ee360 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_chunk">@@ -167,11 +167,13 @@</span> <span class="p_context"> int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)</span>
 	u32 ring = RADEON_CS_RING_GFX;
 	s32 priority = 0;
 
<span class="p_add">+	INIT_LIST_HEAD(&amp;p-&gt;validated);</span>
<span class="p_add">+</span>
 	if (!cs-&gt;num_chunks) {
 		return 0;
 	}
<span class="p_add">+</span>
 	/* get chunks */
<span class="p_del">-	INIT_LIST_HEAD(&amp;p-&gt;validated);</span>
 	p-&gt;idx = 0;
 	p-&gt;chunk_ib_idx = -1;
 	p-&gt;chunk_relocs_idx = -1;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rs600.c b/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_header">index 739eb0d..07b6dbf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_chunk">@@ -585,6 +585,10 @@</span> <span class="p_context"> int rs600_irq_set(struct radeon_device *rdev)</span>
 	WREG32(R_006540_DxMODE_INT_MASK, mode_int);
 	WREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, hpd1);
 	WREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, hpd2);
<span class="p_add">+</span>
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(R_000040_GEN_INT_CNTL);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index e710073..068b21f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -4126,6 +4126,9 @@</span> <span class="p_context"> int si_init(struct radeon_device *rdev)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(SRBM_STATUS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index db50604..e43341a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -547,21 +547,6 @@</span> <span class="p_context"> static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)</span>
 		goto out_err1;
 	}
 
<span class="p_del">-	ret = ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM,</span>
<span class="p_del">-			     (dev_priv-&gt;vram_size &gt;&gt; PAGE_SHIFT));</span>
<span class="p_del">-	if (unlikely(ret != 0)) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Failed initializing memory manager for VRAM.\n&quot;);</span>
<span class="p_del">-		goto out_err2;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_priv-&gt;has_gmr = true;</span>
<span class="p_del">-	if (ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR,</span>
<span class="p_del">-			   dev_priv-&gt;max_gmr_ids) != 0) {</span>
<span class="p_del">-		DRM_INFO(&quot;No GMR memory available. &quot;</span>
<span class="p_del">-			 &quot;Graphics memory resources are very limited.\n&quot;);</span>
<span class="p_del">-		dev_priv-&gt;has_gmr = false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dev_priv-&gt;mmio_mtrr = drm_mtrr_add(dev_priv-&gt;mmio_start,
 					   dev_priv-&gt;mmio_size, DRM_MTRR_WC);
 
<span class="p_chunk">@@ -618,6 +603,22 @@</span> <span class="p_context"> static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)</span>
 	ret = vmw_3d_resource_inc(dev_priv, true);
 	if (unlikely(ret != 0))
 		goto out_no_fifo;
<span class="p_add">+</span>
<span class="p_add">+	ret = ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM,</span>
<span class="p_add">+			     (dev_priv-&gt;vram_size &gt;&gt; PAGE_SHIFT));</span>
<span class="p_add">+	if (unlikely(ret != 0)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Failed initializing memory manager for VRAM.\n&quot;);</span>
<span class="p_add">+		goto out_no_vram;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_priv-&gt;has_gmr = true;</span>
<span class="p_add">+	if (ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR,</span>
<span class="p_add">+			   dev_priv-&gt;max_gmr_ids) != 0) {</span>
<span class="p_add">+		DRM_INFO(&quot;No GMR memory available. &quot;</span>
<span class="p_add">+			 &quot;Graphics memory resources are very limited.\n&quot;);</span>
<span class="p_add">+		dev_priv-&gt;has_gmr = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	vmw_kms_save_vga(dev_priv);
 
 	/* Start kms and overlay systems, needs fifo. */
<span class="p_chunk">@@ -663,6 +664,10 @@</span> <span class="p_context"> out_no_kms:</span>
 		vmw_kms_restore_vga(dev_priv);
 		vmw_3d_resource_dec(dev_priv, false);
 	}
<span class="p_add">+out_no_vram:</span>
<span class="p_add">+	if (dev_priv-&gt;has_gmr)</span>
<span class="p_add">+		(void) ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_add">+	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
 out_no_fifo:
 	vmw_fence_manager_takedown(dev_priv-&gt;fman);
 out_no_fman:
<span class="p_chunk">@@ -677,9 +682,6 @@</span> <span class="p_context"> out_err4:</span>
 out_err3:
 	drm_mtrr_del(dev_priv-&gt;mmio_mtrr, dev_priv-&gt;mmio_start,
 		     dev_priv-&gt;mmio_size, DRM_MTRR_WC);
<span class="p_del">-	if (dev_priv-&gt;has_gmr)</span>
<span class="p_del">-		(void) ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_del">-	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
 out_err2:
 	(void)ttm_bo_device_release(&amp;dev_priv-&gt;bdev);
 out_err1:
<span class="p_chunk">@@ -709,6 +711,11 @@</span> <span class="p_context"> static int vmw_driver_unload(struct drm_device *dev)</span>
 	}
 	vmw_kms_close(dev_priv);
 	vmw_overlay_close(dev_priv);
<span class="p_add">+</span>
<span class="p_add">+	if (dev_priv-&gt;has_gmr)</span>
<span class="p_add">+		(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_add">+	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
<span class="p_add">+</span>
 	vmw_fence_manager_takedown(dev_priv-&gt;fman);
 	if (dev_priv-&gt;stealth)
 		pci_release_region(dev-&gt;pdev, 2);
<span class="p_chunk">@@ -719,9 +726,6 @@</span> <span class="p_context"> static int vmw_driver_unload(struct drm_device *dev)</span>
 	iounmap(dev_priv-&gt;mmio_virt);
 	drm_mtrr_del(dev_priv-&gt;mmio_mtrr, dev_priv-&gt;mmio_start,
 		     dev_priv-&gt;mmio_size, DRM_MTRR_WC);
<span class="p_del">-	if (dev_priv-&gt;has_gmr)</span>
<span class="p_del">-		(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_del">-	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
 	(void)ttm_bo_device_release(&amp;dev_priv-&gt;bdev);
 	vmw_ttm_global_release(dev_priv);
 	idr_destroy(&amp;dev_priv-&gt;surface_idr);
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index a841123..d0254be 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,6 +94,14 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the combination of the addr and size requested for this memory</span>
<span class="p_add">+	 * region causes an integer overflow, return error.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (!can_do_mlock())
 		return ERR_PTR(-EPERM);
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 604556d..5b51e4e 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static void ib_uverbs_async_handler(struct ib_uverbs_file *file,</span>
 
 	entry-&gt;desc.async.element    = element;
 	entry-&gt;desc.async.event_type = event;
<span class="p_add">+	entry-&gt;desc.async.reserved   = 0;</span>
 	entry-&gt;counter               = counter;
 
 	list_add_tail(&amp;entry-&gt;list, &amp;file-&gt;async_file-&gt;event_list);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 259b067..df76538 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -44,6 +44,14 @@</span> <span class="p_context"> enum {</span>
 	MLX4_IB_VENDOR_CLASS2 = 0xa
 };
 
<span class="p_add">+/* Counters should be saturate once they reach their maximum value */</span>
<span class="p_add">+#define ASSIGN_32BIT_COUNTER(counter, value) do {\</span>
<span class="p_add">+	if ((value) &gt; (u32)~0U)			 \</span>
<span class="p_add">+		counter = cpu_to_be32((u32)~0U); \</span>
<span class="p_add">+	else					 \</span>
<span class="p_add">+		counter = cpu_to_be32(value);	 \</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 int mlx4_MAD_IFC(struct mlx4_ib_dev *dev, int ignore_mkey, int ignore_bkey,
 		 int port, struct ib_wc *in_wc, struct ib_grh *in_grh,
 		 void *in_mad, void *response_mad)
<span class="p_chunk">@@ -304,10 +312,14 @@</span> <span class="p_context"> static int ib_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,</span>
 static void edit_counter(struct mlx4_counter *cnt,
 					struct ib_pma_portcounters *pma_cnt)
 {
<span class="p_del">-	pma_cnt-&gt;port_xmit_data = cpu_to_be32((be64_to_cpu(cnt-&gt;tx_bytes)&gt;&gt;2));</span>
<span class="p_del">-	pma_cnt-&gt;port_rcv_data  = cpu_to_be32((be64_to_cpu(cnt-&gt;rx_bytes)&gt;&gt;2));</span>
<span class="p_del">-	pma_cnt-&gt;port_xmit_packets = cpu_to_be32(be64_to_cpu(cnt-&gt;tx_frames));</span>
<span class="p_del">-	pma_cnt-&gt;port_rcv_packets  = cpu_to_be32(be64_to_cpu(cnt-&gt;rx_frames));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_xmit_data,</span>
<span class="p_add">+			     (be64_to_cpu(cnt-&gt;tx_bytes) &gt;&gt; 2));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_rcv_data,</span>
<span class="p_add">+			     (be64_to_cpu(cnt-&gt;rx_bytes) &gt;&gt; 2));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_xmit_packets,</span>
<span class="p_add">+			     be64_to_cpu(cnt-&gt;tx_frames));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_rcv_packets,</span>
<span class="p_add">+			     be64_to_cpu(cnt-&gt;rx_frames));</span>
 }
 
 static int iboe_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">index 6b811e3..c7d4ef1 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_chunk">@@ -1013,12 +1013,6 @@</span> <span class="p_context"> struct qib_devdata {</span>
 	/* control high-level access to EEPROM */
 	struct mutex eep_lock;
 	uint64_t traffic_wds;
<span class="p_del">-	/* active time is kept in seconds, but logged in hours */</span>
<span class="p_del">-	atomic_t active_time;</span>
<span class="p_del">-	/* Below are nominal shadow of EEPROM, new since last EEPROM update */</span>
<span class="p_del">-	uint8_t eep_st_errs[QIB_EEP_LOG_CNT];</span>
<span class="p_del">-	uint8_t eep_st_new_errs[QIB_EEP_LOG_CNT];</span>
<span class="p_del">-	uint16_t eep_hrs;</span>
 	/*
 	 * masks for which bits of errs, hwerrs that cause
 	 * each of the counters to increment.
<span class="p_chunk">@@ -1235,8 +1229,7 @@</span> <span class="p_context"> int qib_twsi_blk_rd(struct qib_devdata *dd, int dev, int addr, void *buffer,</span>
 int qib_twsi_blk_wr(struct qib_devdata *dd, int dev, int addr,
 		    const void *buffer, int len);
 void qib_get_eeprom_info(struct qib_devdata *);
<span class="p_del">-int qib_update_eeprom_log(struct qib_devdata *dd);</span>
<span class="p_del">-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr);</span>
<span class="p_add">+#define qib_inc_eeprom_err(dd, eidx, incr)</span>
 void qib_dump_lookup_output_queue(struct qib_devdata *);
 void qib_force_pio_avail_update(struct qib_devdata *);
 void qib_clear_symerror_on_linkup(unsigned long opaque);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_eeprom.c b/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_header">index 92d9cfe..161ef71 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_chunk">@@ -263,189 +263,8 @@</span> <span class="p_context"> void qib_get_eeprom_info(struct qib_devdata *dd)</span>
 		qib_dev_err(dd, &quot;Board SN %s did not pass functional &quot;
 			    &quot;test: %s\n&quot;, dd-&gt;serial, ifp-&gt;if_comment);
 
<span class="p_del">-	memcpy(&amp;dd-&gt;eep_st_errs, &amp;ifp-&gt;if_errcntp, QIB_EEP_LOG_CNT);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Power-on (actually &quot;active&quot;) hours are kept as little-endian value</span>
<span class="p_del">-	 * in EEPROM, but as seconds in a (possibly as small as 24-bit)</span>
<span class="p_del">-	 * atomic_t while running.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	atomic_set(&amp;dd-&gt;active_time, 0);</span>
<span class="p_del">-	dd-&gt;eep_hrs = ifp-&gt;if_powerhour[0] | (ifp-&gt;if_powerhour[1] &lt;&lt; 8);</span>
<span class="p_del">-</span>
 done:
 	vfree(buf);
 
 bail:;
 }
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * qib_update_eeprom_log - copy active-time and error counters to eeprom</span>
<span class="p_del">- * @dd: the qlogic_ib device</span>
<span class="p_del">- *</span>
<span class="p_del">- * Although the time is kept as seconds in the qib_devdata struct, it is</span>
<span class="p_del">- * rounded to hours for re-write, as we have only 16 bits in EEPROM.</span>
<span class="p_del">- * First-cut code reads whole (expected) struct qib_flash, modifies,</span>
<span class="p_del">- * re-writes. Future direction: read/write only what we need, assuming</span>
<span class="p_del">- * that the EEPROM had to have been &quot;good enough&quot; for driver init, and</span>
<span class="p_del">- * if not, we aren&#39;t making it worse.</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_del">-int qib_update_eeprom_log(struct qib_devdata *dd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *buf;</span>
<span class="p_del">-	struct qib_flash *ifp;</span>
<span class="p_del">-	int len, hi_water;</span>
<span class="p_del">-	uint32_t new_time, new_hrs;</span>
<span class="p_del">-	u8 csum;</span>
<span class="p_del">-	int ret, idx;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* first, check if we actually need to do anything. */</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		if (dd-&gt;eep_st_new_errs[idx]) {</span>
<span class="p_del">-			ret = 1;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	new_time = atomic_read(&amp;dd-&gt;active_time);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret == 0 &amp;&amp; new_time &lt; 3600)</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The quick-check above determined that there is something worthy</span>
<span class="p_del">-	 * of logging, so get current contents and do a more detailed idea.</span>
<span class="p_del">-	 * read full flash, not just currently used part, since it may have</span>
<span class="p_del">-	 * been written with a newer definition</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	len = sizeof(struct qib_flash);</span>
<span class="p_del">-	buf = vmalloc(len);</span>
<span class="p_del">-	ret = 1;</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Couldn&#39;t allocate memory to read %u &quot;</span>
<span class="p_del">-			    &quot;bytes from eeprom for logging\n&quot;, len);</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Grab semaphore and read current EEPROM. If we get an</span>
<span class="p_del">-	 * error, let go, but if not, keep it until we finish write.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = mutex_lock_interruptible(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Unable to acquire EEPROM for logging\n&quot;);</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ret = qib_twsi_blk_rd(dd, dd-&gt;twsi_eeprom_dev, 0, buf, len);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Unable read EEPROM for logging\n&quot;);</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ifp = (struct qib_flash *)buf;</span>
<span class="p_del">-</span>
<span class="p_del">-	csum = flash_csum(ifp, 0);</span>
<span class="p_del">-	if (csum != ifp-&gt;if_csum) {</span>
<span class="p_del">-		mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-		qib_dev_err(dd, &quot;EEPROM cks err (0x%02X, S/B 0x%02X)\n&quot;,</span>
<span class="p_del">-			    csum, ifp-&gt;if_csum);</span>
<span class="p_del">-		ret = 1;</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	hi_water = 0;</span>
<span class="p_del">-	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		int new_val = dd-&gt;eep_st_new_errs[idx];</span>
<span class="p_del">-		if (new_val) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If we have seen any errors, add to EEPROM values</span>
<span class="p_del">-			 * We need to saturate at 0xFF (255) and we also</span>
<span class="p_del">-			 * would need to adjust the checksum if we were</span>
<span class="p_del">-			 * trying to minimize EEPROM traffic</span>
<span class="p_del">-			 * Note that we add to actual current count in EEPROM,</span>
<span class="p_del">-			 * in case it was altered while we were running.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			new_val += ifp-&gt;if_errcntp[idx];</span>
<span class="p_del">-			if (new_val &gt; 0xFF)</span>
<span class="p_del">-				new_val = 0xFF;</span>
<span class="p_del">-			if (ifp-&gt;if_errcntp[idx] != new_val) {</span>
<span class="p_del">-				ifp-&gt;if_errcntp[idx] = new_val;</span>
<span class="p_del">-				hi_water = offsetof(struct qib_flash,</span>
<span class="p_del">-						    if_errcntp) + idx;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * update our shadow (used to minimize EEPROM</span>
<span class="p_del">-			 * traffic), to match what we are about to write.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			dd-&gt;eep_st_errs[idx] = new_val;</span>
<span class="p_del">-			dd-&gt;eep_st_new_errs[idx] = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now update active-time. We would like to round to the nearest hour</span>
<span class="p_del">-	 * but unless atomic_t are sure to be proper signed ints we cannot,</span>
<span class="p_del">-	 * because we need to account for what we &quot;transfer&quot; to EEPROM and</span>
<span class="p_del">-	 * if we log an hour at 31 minutes, then we would need to set</span>
<span class="p_del">-	 * active_time to -29 to accurately count the _next_ hour.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (new_time &gt;= 3600) {</span>
<span class="p_del">-		new_hrs = new_time / 3600;</span>
<span class="p_del">-		atomic_sub((new_hrs * 3600), &amp;dd-&gt;active_time);</span>
<span class="p_del">-		new_hrs += dd-&gt;eep_hrs;</span>
<span class="p_del">-		if (new_hrs &gt; 0xFFFF)</span>
<span class="p_del">-			new_hrs = 0xFFFF;</span>
<span class="p_del">-		dd-&gt;eep_hrs = new_hrs;</span>
<span class="p_del">-		if ((new_hrs &amp; 0xFF) != ifp-&gt;if_powerhour[0]) {</span>
<span class="p_del">-			ifp-&gt;if_powerhour[0] = new_hrs &amp; 0xFF;</span>
<span class="p_del">-			hi_water = offsetof(struct qib_flash, if_powerhour);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if ((new_hrs &gt;&gt; 8) != ifp-&gt;if_powerhour[1]) {</span>
<span class="p_del">-			ifp-&gt;if_powerhour[1] = new_hrs &gt;&gt; 8;</span>
<span class="p_del">-			hi_water = offsetof(struct qib_flash, if_powerhour) + 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There is a tiny possibility that we could somehow fail to write</span>
<span class="p_del">-	 * the EEPROM after updating our shadows, but problems from holding</span>
<span class="p_del">-	 * the spinlock too long are a much bigger issue.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	if (hi_water) {</span>
<span class="p_del">-		/* we made some change to the data, uopdate cksum and write */</span>
<span class="p_del">-		csum = flash_csum(ifp, 1);</span>
<span class="p_del">-		ret = eeprom_write_with_enable(dd, 0, buf, hi_water + 1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Failed updating EEPROM\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-free_bail:</span>
<span class="p_del">-	vfree(buf);</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * qib_inc_eeprom_err - increment one of the four error counters</span>
<span class="p_del">- * that are logged to EEPROM.</span>
<span class="p_del">- * @dd: the qlogic_ib device</span>
<span class="p_del">- * @eidx: 0..3, the counter to increment</span>
<span class="p_del">- * @incr: how much to add</span>
<span class="p_del">- *</span>
<span class="p_del">- * Each counter is 8-bits, and saturates at 255 (0xFF). They</span>
<span class="p_del">- * are copied to the EEPROM (aka flash) whenever qib_update_eeprom_log()</span>
<span class="p_del">- * is called, but it can only be called in a context that allows sleep.</span>
<span class="p_del">- * This function can be called even at interrupt level.</span>
<span class="p_del">- */</span>
<span class="p_del">-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	uint new_val;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	new_val = dd-&gt;eep_st_new_errs[eidx] + incr;</span>
<span class="p_del">-	if (new_val &gt; 255)</span>
<span class="p_del">-		new_val = 255;</span>
<span class="p_del">-	dd-&gt;eep_st_new_errs[eidx] = new_val;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_header">index d0c64d5..eb60abd 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_chunk">@@ -2674,8 +2674,6 @@</span> <span class="p_context"> static void qib_get_6120_faststats(unsigned long opaque)</span>
 	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);
 	traffic_wds -= dd-&gt;traffic_wds;
 	dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-	if (traffic_wds  &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-		atomic_add(5, &amp;dd-&gt;active_time); /* S/B #define */</span>
 	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);
 
 	qib_chk_6120_errormask(dd);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_header">index 3c722f7..b62c7f2 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_chunk">@@ -3292,8 +3292,6 @@</span> <span class="p_context"> static void qib_get_7220_faststats(unsigned long opaque)</span>
 	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);
 	traffic_wds -= dd-&gt;traffic_wds;
 	dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-	if (traffic_wds  &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-		atomic_add(5, &amp;dd-&gt;active_time); /* S/B #define */</span>
 	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);
 done:
 	mod_timer(&amp;dd-&gt;stats_timer, jiffies + HZ * ACTIVITY_TIMER);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">index d252053..0d8e348 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_chunk">@@ -4841,8 +4841,6 @@</span> <span class="p_context"> static void qib_get_7322_faststats(unsigned long opaque)</span>
 		spin_lock_irqsave(&amp;ppd-&gt;dd-&gt;eep_st_lock, flags);
 		traffic_wds -= ppd-&gt;dd-&gt;traffic_wds;
 		ppd-&gt;dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-		if (traffic_wds &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-			atomic_add(ACTIVITY_TIMER, &amp;ppd-&gt;dd-&gt;active_time);</span>
 		spin_unlock_irqrestore(&amp;ppd-&gt;dd-&gt;eep_st_lock, flags);
 		if (ppd-&gt;cpspec-&gt;qdr_dfe_on &amp;&amp; (ppd-&gt;link_speed_active &amp;
 						QIB_IB_QDR) &amp;&amp;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_header">index cf0cd30..0776dd0 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_chunk">@@ -765,7 +765,6 @@</span> <span class="p_context"> static void qib_shutdown_device(struct qib_devdata *dd)</span>
 		dd-&gt;f_quiet_serdes(ppd);
 	}
 
<span class="p_del">-	qib_update_eeprom_log(dd);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_sysfs.c b/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_header">index dae5160..c01cb11 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_chunk">@@ -550,28 +550,6 @@</span> <span class="p_context"> bail:</span>
 	return ret &lt; 0 ? ret : count;
 }
 
<span class="p_del">-static ssize_t show_logged_errs(struct device *device,</span>
<span class="p_del">-				struct device_attribute *attr, char *buf)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct qib_ibdev *dev =</span>
<span class="p_del">-		container_of(device, struct qib_ibdev, ibdev.dev);</span>
<span class="p_del">-	struct qib_devdata *dd = dd_from_dev(dev);</span>
<span class="p_del">-	int idx, count;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* force consistency with actual EEPROM */</span>
<span class="p_del">-	if (qib_update_eeprom_log(dd) != 0)</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	count = 0;</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		count += scnprintf(buf + count, PAGE_SIZE - count, &quot;%d%c&quot;,</span>
<span class="p_del">-				   dd-&gt;eep_st_errs[idx],</span>
<span class="p_del">-				   idx == (QIB_EEP_LOG_CNT - 1) ? &#39;\n&#39; : &#39; &#39;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return count;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Dump tempsense regs. in decimal, to ease shell-scripts.
  */
<span class="p_chunk">@@ -618,7 +596,6 @@</span> <span class="p_context"> static DEVICE_ATTR(nctxts, S_IRUGO, show_nctxts, NULL);</span>
 static DEVICE_ATTR(nfreectxts, S_IRUGO, show_nfreectxts, NULL);
 static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
 static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
<span class="p_del">-static DEVICE_ATTR(logged_errors, S_IRUGO, show_logged_errs, NULL);</span>
 static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
 static DEVICE_ATTR(localbus_info, S_IRUGO, show_localbus_info, NULL);
 static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
<span class="p_chunk">@@ -632,7 +609,6 @@</span> <span class="p_context"> static struct device_attribute *qib_attributes[] = {</span>
 	&amp;dev_attr_nfreectxts,
 	&amp;dev_attr_serial,
 	&amp;dev_attr_boardversion,
<span class="p_del">-	&amp;dev_attr_logged_errors,</span>
 	&amp;dev_attr_tempsense,
 	&amp;dev_attr_localbus_info,
 	&amp;dev_attr_chip_reset,
<span class="p_header">diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c</span>
<span class="p_header">index 97e5f6f..6d6198a 100644</span>
<span class="p_header">--- a/drivers/input/mouse/synaptics.c</span>
<span class="p_header">+++ b/drivers/input/mouse/synaptics.c</span>
<span class="p_chunk">@@ -274,8 +274,14 @@</span> <span class="p_context"> static int synaptics_resolution(struct psmouse *psmouse)</span>
 		}
 	}
 
<span class="p_del">-	if (SYN_EXT_CAP_REQUESTS(priv-&gt;capabilities) &gt;= 7 &amp;&amp;</span>
<span class="p_del">-	    SYN_CAP_MIN_DIMENSIONS(priv-&gt;ext_cap_0c)) {</span>
<span class="p_add">+	if (SYN_CAP_MIN_DIMENSIONS(priv-&gt;ext_cap_0c) &amp;&amp;</span>
<span class="p_add">+	    (SYN_EXT_CAP_REQUESTS(priv-&gt;capabilities) &gt;= 7 ||</span>
<span class="p_add">+	     /*</span>
<span class="p_add">+	      * Firmware v8.1 does not report proper number of extended</span>
<span class="p_add">+	      * capabilities, but has been proven to report correct min</span>
<span class="p_add">+	      * coordinates.</span>
<span class="p_add">+	      */</span>
<span class="p_add">+	     SYN_ID_FULL(priv-&gt;identity) == 0x801)) {</span>
 		if (synaptics_send_cmd(psmouse, SYN_QUE_EXT_MIN_COORDS, resp)) {
 			psmouse_warn(psmouse,
 				     &quot;device claims to have min coordinates query, but I&#39;m not able to read it.\n&quot;);
<span class="p_chunk">@@ -506,6 +512,18 @@</span> <span class="p_context"> static void synaptics_parse_agm(const unsigned char buf[],</span>
 	priv-&gt;agm_pending = true;
 }
 
<span class="p_add">+static void synaptics_parse_ext_buttons(const unsigned char buf[],</span>
<span class="p_add">+					struct synaptics_data *priv,</span>
<span class="p_add">+					struct synaptics_hw_state *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int ext_bits =</span>
<span class="p_add">+		(SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) + 1) &gt;&gt; 1;</span>
<span class="p_add">+	unsigned int ext_mask = (1U &lt;&lt; ext_bits) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	hw-&gt;ext_buttons = buf[4] &amp; ext_mask;</span>
<span class="p_add">+	hw-&gt;ext_buttons |= (buf[5] &amp; ext_mask) &lt;&lt; ext_bits;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool is_forcepad;
 
 static int synaptics_parse_hw_state(const unsigned char buf[],
<span class="p_chunk">@@ -592,28 +610,9 @@</span> <span class="p_context"> static int synaptics_parse_hw_state(const unsigned char buf[],</span>
 			hw-&gt;down = ((buf[0] ^ buf[3]) &amp; 0x02) ? 1 : 0;
 		}
 
<span class="p_del">-		if (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &amp;&amp;</span>
<span class="p_add">+		if (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &gt; 0 &amp;&amp;</span>
 		    ((buf[0] ^ buf[3]) &amp; 0x02)) {
<span class="p_del">-			switch (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &amp; ~0x01) {</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * if nExtBtn is greater than 8 it should be</span>
<span class="p_del">-				 * considered invalid and treated as 0</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 8:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x08)) ? 0x80 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x08)) ? 0x40 : 0;</span>
<span class="p_del">-			case 6:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x04)) ? 0x20 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x04)) ? 0x10 : 0;</span>
<span class="p_del">-			case 4:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x02)) ? 0x08 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x02)) ? 0x04 : 0;</span>
<span class="p_del">-			case 2:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x01)) ? 0x02 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x01)) ? 0x01 : 0;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			synaptics_parse_ext_buttons(buf, priv, hw);</span>
 		}
 	} else {
 		hw-&gt;x = (((buf[1] &amp; 0x1f) &lt;&lt; 8) | buf[2]);
<span class="p_chunk">@@ -675,12 +674,35 @@</span> <span class="p_context"> static void synaptics_report_semi_mt_data(struct input_dev *dev,</span>
 	}
 }
 
<span class="p_add">+static void synaptics_report_ext_buttons(struct psmouse *psmouse,</span>
<span class="p_add">+					 const struct synaptics_hw_state *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct input_dev *dev = psmouse-&gt;dev;</span>
<span class="p_add">+	struct synaptics_data *priv = psmouse-&gt;private;</span>
<span class="p_add">+	int ext_bits = (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) + 1) &gt;&gt; 1;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Bug in FW 8.1, buttons are reported only when ExtBit is 1 */</span>
<span class="p_add">+	if (SYN_ID_FULL(priv-&gt;identity) == 0x801 &amp;&amp;</span>
<span class="p_add">+	    !((psmouse-&gt;packet[0] ^ psmouse-&gt;packet[3]) &amp; 0x02))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ext_bits; i++) {</span>
<span class="p_add">+		input_report_key(dev, BTN_0 + 2 * i,</span>
<span class="p_add">+			hw-&gt;ext_buttons &amp; (1 &lt;&lt; i));</span>
<span class="p_add">+		input_report_key(dev, BTN_1 + 2 * i,</span>
<span class="p_add">+			hw-&gt;ext_buttons &amp; (1 &lt;&lt; (i + ext_bits)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void synaptics_report_buttons(struct psmouse *psmouse,
 				     const struct synaptics_hw_state *hw)
 {
 	struct input_dev *dev = psmouse-&gt;dev;
 	struct synaptics_data *priv = psmouse-&gt;private;
<span class="p_del">-	int i;</span>
 
 	input_report_key(dev, BTN_LEFT, hw-&gt;left);
 	input_report_key(dev, BTN_RIGHT, hw-&gt;right);
<span class="p_chunk">@@ -693,8 +715,7 @@</span> <span class="p_context"> static void synaptics_report_buttons(struct psmouse *psmouse,</span>
 		input_report_key(dev, BTN_BACK, hw-&gt;down);
 	}
 
<span class="p_del">-	for (i = 0; i &lt; SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap); i++)</span>
<span class="p_del">-		input_report_key(dev, BTN_0 + i, hw-&gt;ext_buttons &amp; (1 &lt;&lt; i));</span>
<span class="p_add">+	synaptics_report_ext_buttons(psmouse, hw);</span>
 }
 
 static void synaptics_report_slot(struct input_dev *dev, int slot,
<span class="p_header">diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c</span>
<span class="p_header">index ea5dd28..489d7fb 100644</span>
<span class="p_header">--- a/drivers/md/dm-io.c</span>
<span class="p_header">+++ b/drivers/md/dm-io.c</span>
<span class="p_chunk">@@ -298,6 +298,18 @@</span> <span class="p_context"> static void do_region(int rw, unsigned region, struct dm_io_region *where,</span>
 	sector_t remaining = where-&gt;count;
 	struct request_queue *q = bdev_get_queue(where-&gt;bdev);
 	sector_t discard_sectors;
<span class="p_add">+	unsigned int uninitialized_var(special_cmd_max_sectors);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reject unsupported discard and write same requests.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rw &amp; REQ_DISCARD) {</span>
<span class="p_add">+		special_cmd_max_sectors = q-&gt;limits.max_discard_sectors;</span>
<span class="p_add">+		if (special_cmd_max_sectors == 0) {</span>
<span class="p_add">+			dec_count(io, region, -EOPNOTSUPP);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * where-&gt;count may be zero if rw holds a flush and we need to
<span class="p_chunk">@@ -321,7 +333,7 @@</span> <span class="p_context"> static void do_region(int rw, unsigned region, struct dm_io_region *where,</span>
 		store_io_and_region_in_bio(bio, io, region);
 
 		if (rw &amp; REQ_DISCARD) {
<span class="p_del">-			discard_sectors = min_t(sector_t, q-&gt;limits.max_discard_sectors, remaining);</span>
<span class="p_add">+			discard_sectors = min_t(sector_t, special_cmd_max_sectors, remaining);</span>
 			bio-&gt;bi_size = discard_sectors &lt;&lt; SECTOR_SHIFT;
 			remaining -= discard_sectors;
 		} else while (remaining) {
<span class="p_header">diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c</span>
<span class="p_header">index a3cf259..3afb9cd 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid1.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid1.c</span>
<span class="p_chunk">@@ -603,6 +603,15 @@</span> <span class="p_context"> static void write_callback(unsigned long error, void *context)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the bio is discard, return an error, but do not</span>
<span class="p_add">+	 * degrade the array.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD) {</span>
<span class="p_add">+		bio_endio(bio, -EOPNOTSUPP);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ms-&gt;nr_mirrors; i++)
 		if (test_bit(i, &amp;error))
 			fail_mirror(ms-&gt;mirror + i, DM_RAID1_WRITE_ERROR);
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index b092338..696a16b 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1444,8 +1444,6 @@</span> <span class="p_context"> out:</span>
 		full_bio-&gt;bi_end_io = pe-&gt;full_bio_end_io;
 		full_bio-&gt;bi_private = pe-&gt;full_bio_private;
 	}
<span class="p_del">-	free_pending_exception(pe);</span>
<span class="p_del">-</span>
 	increment_pending_exceptions_done_count();
 
 	up_write(&amp;s-&gt;lock);
<span class="p_chunk">@@ -1462,6 +1460,8 @@</span> <span class="p_context"> out:</span>
 	}
 
 	retry_origin_bios(s, origin_bios);
<span class="p_add">+</span>
<span class="p_add">+	free_pending_exception(pe);</span>
 }
 
 static void commit_callback(void *context, int success)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 0cf8c51..3bfbccc 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2232,7 +2232,7 @@</span> <span class="p_context"> int dm_setup_md_queue(struct mapped_device *md)</span>
 	return 0;
 }
 
<span class="p_del">-static struct mapped_device *dm_find_md(dev_t dev)</span>
<span class="p_add">+struct mapped_device *dm_get_md(dev_t dev)</span>
 {
 	struct mapped_device *md;
 	unsigned minor = MINOR(dev);
<span class="p_chunk">@@ -2243,12 +2243,15 @@</span> <span class="p_context"> static struct mapped_device *dm_find_md(dev_t dev)</span>
 	spin_lock(&amp;_minor_lock);
 
 	md = idr_find(&amp;_minor_idr, minor);
<span class="p_del">-	if (md &amp;&amp; (md == MINOR_ALLOCED ||</span>
<span class="p_del">-		   (MINOR(disk_devt(dm_disk(md))) != minor) ||</span>
<span class="p_del">-		   dm_deleting_md(md) ||</span>
<span class="p_del">-		   test_bit(DMF_FREEING, &amp;md-&gt;flags))) {</span>
<span class="p_del">-		md = NULL;</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (md) {</span>
<span class="p_add">+		if ((md == MINOR_ALLOCED ||</span>
<span class="p_add">+		     (MINOR(disk_devt(dm_disk(md))) != minor) ||</span>
<span class="p_add">+		     dm_deleting_md(md) ||</span>
<span class="p_add">+		     test_bit(DMF_FREEING, &amp;md-&gt;flags))) {</span>
<span class="p_add">+			md = NULL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		dm_get(md);</span>
 	}
 
 out:
<span class="p_chunk">@@ -2256,16 +2259,6 @@</span> <span class="p_context"> out:</span>
 
 	return md;
 }
<span class="p_del">-</span>
<span class="p_del">-struct mapped_device *dm_get_md(dev_t dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mapped_device *md = dm_find_md(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (md)</span>
<span class="p_del">-		dm_get(md);</span>
<span class="p_del">-</span>
<span class="p_del">-	return md;</span>
<span class="p_del">-}</span>
 EXPORT_SYMBOL_GPL(dm_get_md);
 
 void *dm_get_mdptr(struct mapped_device *md)
<span class="p_chunk">@@ -2302,10 +2295,16 @@</span> <span class="p_context"> static void __dm_destroy(struct mapped_device *md, bool wait)</span>
 	set_bit(DMF_FREEING, &amp;md-&gt;flags);
 	spin_unlock(&amp;_minor_lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Take suspend_lock so that presuspend and postsuspend methods</span>
<span class="p_add">+	 * do not race with internal suspend.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;md-&gt;suspend_lock);</span>
 	if (!dm_suspended_md(md)) {
 		dm_table_presuspend_targets(map);
 		dm_table_postsuspend_targets(map);
 	}
<span class="p_add">+	mutex_unlock(&amp;md-&gt;suspend_lock);</span>
 
 	/*
 	 * Rare, but there may be I/O requests still going to complete,
<span class="p_header">diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c</span>
<span class="p_header">index f6a7d7a..b14ab43 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/misc.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/misc.c</span>
<span class="p_chunk">@@ -74,6 +74,8 @@</span> <span class="p_context"> int ubi_check_volume(struct ubi_device *ubi, int vol_id)</span>
 	for (i = 0; i &lt; vol-&gt;used_ebs; i++) {
 		int size;
 
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (i == vol-&gt;used_ebs - 1)
 			size = vol-&gt;last_eb_bytes;
 		else
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index 88c39e4..81a00e4 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -475,6 +475,11 @@</span> <span class="p_context"> struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)</span>
 	skb-&gt;protocol = htons(ETH_P_CAN);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<span class="p_add">+</span>
<span class="p_add">+	skb_reset_mac_header(skb);</span>
<span class="p_add">+	skb_reset_network_header(skb);</span>
<span class="p_add">+	skb_reset_transport_header(skb);</span>
<span class="p_add">+</span>
 	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
 	memset(*cf, 0, sizeof(struct can_frame));
 
<span class="p_header">diff --git a/drivers/net/ethernet/amd/pcnet32.c b/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_header">index 86b6d8e..d63b322 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_chunk">@@ -1526,7 +1526,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 {
 	struct pcnet32_private *lp;
 	int i, media;
<span class="p_del">-	int fdx, mii, fset, dxsuflo;</span>
<span class="p_add">+	int fdx, mii, fset, dxsuflo, sram;</span>
 	int chip_version;
 	char *chipname;
 	struct net_device *dev;
<span class="p_chunk">@@ -1563,7 +1563,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 	}
 
 	/* initialize variables */
<span class="p_del">-	fdx = mii = fset = dxsuflo = 0;</span>
<span class="p_add">+	fdx = mii = fset = dxsuflo = sram = 0;</span>
 	chip_version = (chip_version &gt;&gt; 12) &amp; 0xffff;
 
 	switch (chip_version) {
<span class="p_chunk">@@ -1596,6 +1596,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		chipname = &quot;PCnet/FAST III 79C973&quot;;	/* PCI */
 		fdx = 1;
 		mii = 1;
<span class="p_add">+		sram = 1;</span>
 		break;
 	case 0x2626:
 		chipname = &quot;PCnet/Home 79C978&quot;;	/* PCI */
<span class="p_chunk">@@ -1619,6 +1620,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		chipname = &quot;PCnet/FAST III 79C975&quot;;	/* PCI */
 		fdx = 1;
 		mii = 1;
<span class="p_add">+		sram = 1;</span>
 		break;
 	case 0x2628:
 		chipname = &quot;PCnet/PRO 79C976&quot;;
<span class="p_chunk">@@ -1647,6 +1649,31 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		dxsuflo = 1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The Am79C973/Am79C975 controllers come with 12K of SRAM</span>
<span class="p_add">+	 * which we can use for the Tx/Rx buffers but most importantly,</span>
<span class="p_add">+	 * the use of SRAM allow us to use the BCR18:NOUFLO bit to avoid</span>
<span class="p_add">+	 * Tx fifo underflows.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sram) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The SRAM is being configured in two steps. First we</span>
<span class="p_add">+		 * set the SRAM size in the BCR25:SRAM_SIZE bits. According</span>
<span class="p_add">+		 * to the datasheet, each bit corresponds to a 512-byte</span>
<span class="p_add">+		 * page so we can have at most 24 pages. The SRAM_SIZE</span>
<span class="p_add">+		 * holds the value of the upper 8 bits of the 16-bit SRAM size.</span>
<span class="p_add">+		 * The low 8-bits start at 0x00 and end at 0xff. So the</span>
<span class="p_add">+		 * address range is from 0x0000 up to 0x17ff. Therefore,</span>
<span class="p_add">+		 * the SRAM_SIZE is set to 0x17. The next step is to set</span>
<span class="p_add">+		 * the BCR26:SRAM_BND midway through so the Tx and Rx</span>
<span class="p_add">+		 * buffers can share the SRAM equally.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 25, 0x17);</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 26, 0xc);</span>
<span class="p_add">+		/* And finally enable the NOUFLO bit */</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 18, a-&gt;read_bcr(ioaddr, 18) | (1 &lt;&lt; 11));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev = alloc_etherdev(sizeof(*lp));
 	if (!dev) {
 		ret = -ENOMEM;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index b8e7f3e..1e274e7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -10934,6 +10934,10 @@</span> <span class="p_context"> static int __devinit bnx2x_init_dev(struct pci_dev *pdev,</span>
 	/* clean indirect addresses */
 	pci_write_config_dword(bp-&gt;pdev, PCICFG_GRC_ADDRESS,
 			       PCICFG_VENDOR_ID_OFFSET);
<span class="p_add">+</span>
<span class="p_add">+	/* Set PCIe reset type to fundamental for EEH recovery */</span>
<span class="p_add">+	pdev-&gt;needs_freset = 1;</span>
<span class="p_add">+</span>
 	/*
 	 * Clean the following indirect addresses for all functions since it
 	 * is not used by the driver.
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index d16800f..56299e9 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -39,9 +39,7 @@</span> <span class="p_context"></span>
 
 static struct team_port *team_port_get_rcu(const struct net_device *dev)
 {
<span class="p_del">-	struct team_port *port = rcu_dereference(dev-&gt;rx_handler_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	return team_port_exists(dev) ? port : NULL;</span>
<span class="p_add">+	return rcu_dereference(dev-&gt;rx_handler_data);</span>
 }
 
 static struct team_port *team_port_get_rtnl(const struct net_device *dev)
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c</span>
<span class="p_header">index 200f165..2cc3f41 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath5k/reset.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath5k/reset.c</span>
<span class="p_chunk">@@ -476,7 +476,7 @@</span> <span class="p_context"> ath5k_hw_wisoc_reset(struct ath5k_hw *ah, u32 flags)</span>
 	regval = ioread32(reg);
 	iowrite32(regval | val, reg);
 	regval = ioread32(reg);
<span class="p_del">-	usleep_range(100, 150);</span>
<span class="p_add">+	udelay(100);	/* NB: should be atomic */</span>
 
 	/* Bring BB/MAC out of reset */
 	iowrite32(regval &amp; ~val, reg);
<span class="p_header">diff --git a/drivers/pci/hotplug.c b/drivers/pci/hotplug.c</span>
<span class="p_header">index 2b5352a..3b70f5c 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> int pci_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	if (add_uevent_var(env, &quot;PCI_SLOT_NAME=%s&quot;, pci_name(pdev)))
 		return -ENOMEM;
 
<span class="p_del">-	if (add_uevent_var(env, &quot;MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x&quot;,</span>
<span class="p_add">+	if (add_uevent_var(env, &quot;MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X&quot;,</span>
 			   pdev-&gt;vendor, pdev-&gt;device,
 			   pdev-&gt;subsystem_vendor, pdev-&gt;subsystem_device,
 			   (u8)(pdev-&gt;class &gt;&gt; 16), (u8)(pdev-&gt;class &gt;&gt; 8),
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index d62ad0b..868440f 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -44,12 +44,10 @@</span> <span class="p_context"> int no_pci_devices(void)</span>
 }
 EXPORT_SYMBOL(no_pci_devices);
 
<span class="p_del">-static struct pci_host_bridge *pci_host_bridge(struct pci_dev *dev)</span>
<span class="p_add">+static struct pci_host_bridge *pci_host_bridge(struct pci_bus *bus)</span>
 {
<span class="p_del">-	struct pci_bus *bus;</span>
 	struct pci_host_bridge *bridge;
 
<span class="p_del">-	bus = dev-&gt;bus;</span>
 	while (bus-&gt;parent)
 		bus = bus-&gt;parent;
 
<span class="p_chunk">@@ -66,10 +64,10 @@</span> <span class="p_context"> static bool resource_contains(struct resource *res1, struct resource *res2)</span>
 	return res1-&gt;start &lt;= res2-&gt;start &amp;&amp; res1-&gt;end &gt;= res2-&gt;end;
 }
 
<span class="p_del">-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,</span>
<span class="p_add">+void pcibios_resource_to_bus(struct pci_bus *bus, struct pci_bus_region *region,</span>
 			     struct resource *res)
 {
<span class="p_del">-	struct pci_host_bridge *bridge = pci_host_bridge(dev);</span>
<span class="p_add">+	struct pci_host_bridge *bridge = pci_host_bridge(bus);</span>
 	struct pci_host_bridge_window *window;
 	resource_size_t offset = 0;
 
<span class="p_chunk">@@ -94,10 +92,10 @@</span> <span class="p_context"> static bool region_contains(struct pci_bus_region *region1,</span>
 	return region1-&gt;start &lt;= region2-&gt;start &amp;&amp; region1-&gt;end &gt;= region2-&gt;end;
 }
 
<span class="p_del">-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,</span>
<span class="p_add">+void pcibios_bus_to_resource(struct pci_bus *bus, struct resource *res,</span>
 			     struct pci_bus_region *region)
 {
<span class="p_del">-	struct pci_host_bridge *bridge = pci_host_bridge(dev);</span>
<span class="p_add">+	struct pci_host_bridge *bridge = pci_host_bridge(bus);</span>
 	struct pci_host_bridge_window *window;
 	struct pci_bus_region bus_region;
 	resource_size_t offset = 0;
<span class="p_chunk">@@ -298,11 +296,11 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 			pci_write_config_dword(dev, pos + 4, 0);
 			region.start = 0;
 			region.end = sz64;
<span class="p_del">-			pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+			pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 		} else {
 			region.start = l64;
 			region.end = l64 + sz64;
<span class="p_del">-			pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+			pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 			dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;reg %x: %pR\n&quot;,
 				   pos, res);
 		}
<span class="p_chunk">@@ -314,7 +312,7 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 
 		region.start = l;
 		region.end = l + sz;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 
 		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;reg %x: %pR\n&quot;, pos, res);
 	}
<span class="p_chunk">@@ -373,7 +371,7 @@</span> <span class="p_context"> static void __devinit pci_read_bridge_io(struct pci_bus *child)</span>
 		res2.flags = res-&gt;flags;
 		region.start = base;
 		region.end = limit + 0xfff;
<span class="p_del">-		pcibios_bus_to_resource(dev, &amp;res2, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, &amp;res2, &amp;region);</span>
 		if (!res-&gt;start)
 			res-&gt;start = res2.start;
 		if (!res-&gt;end)
<span class="p_chunk">@@ -399,7 +397,7 @@</span> <span class="p_context"> static void __devinit pci_read_bridge_mmio(struct pci_bus *child)</span>
 		res-&gt;flags = (mem_base_lo &amp; PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
 		region.start = base;
 		region.end = limit + 0xfffff;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;  bridge window %pR\n&quot;, res);
 	}
 }
<span class="p_chunk">@@ -448,7 +446,7 @@</span> <span class="p_context"> static void __devinit pci_read_bridge_mmio_pref(struct pci_bus *child)</span>
 			res-&gt;flags |= IORESOURCE_MEM_64;
 		region.start = base;
 		region.end = limit + 0xfffff;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, &quot;  bridge window %pR\n&quot;, res);
 	}
 }
<span class="p_chunk">@@ -1063,24 +1061,24 @@</span> <span class="p_context"> int pci_setup_device(struct pci_dev *dev)</span>
 				region.end = 0x1F7;
 				res = &amp;dev-&gt;resource[0];
 				res-&gt;flags = LEGACY_IO_RESOURCE;
<span class="p_del">-				pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+				pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 				region.start = 0x3F6;
 				region.end = 0x3F6;
 				res = &amp;dev-&gt;resource[1];
 				res-&gt;flags = LEGACY_IO_RESOURCE;
<span class="p_del">-				pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+				pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 			}
 			if ((progif &amp; 4) == 0) {
 				region.start = 0x170;
 				region.end = 0x177;
 				res = &amp;dev-&gt;resource[2];
 				res-&gt;flags = LEGACY_IO_RESOURCE;
<span class="p_del">-				pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+				pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 				region.start = 0x376;
 				region.end = 0x376;
 				res = &amp;dev-&gt;resource[3];
 				res-&gt;flags = LEGACY_IO_RESOURCE;
<span class="p_del">-				pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+				pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 			}
 		}
 		break;
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index ffde183..c030024 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static void __devinit quirk_io_region(struct pci_dev *dev, unsigned region,</span>
 		/* Convert from PCI bus to resource space.  */
 		bus_region.start = res-&gt;start;
 		bus_region.end = res-&gt;end;
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;bus_region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;bus_region);</span>
 
 		if (pci_claim_resource(dev, nr) == 0)
 			dev_info(&amp;dev-&gt;dev, &quot;quirk: %pR claimed by %s\n&quot;,
<span class="p_header">diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c</span>
<span class="p_header">index 48ebdb2..336b999 100644</span>
<span class="p_header">--- a/drivers/pci/rom.c</span>
<span class="p_header">+++ b/drivers/pci/rom.c</span>
<span class="p_chunk">@@ -31,7 +31,7 @@</span> <span class="p_context"> int pci_enable_rom(struct pci_dev *pdev)</span>
 	if (!res-&gt;flags)
 		return -1;
 
<span class="p_del">-	pcibios_resource_to_bus(pdev, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(pdev-&gt;bus, &amp;region, res);</span>
 	pci_read_config_dword(pdev, pdev-&gt;rom_base_reg, &amp;rom_addr);
 	rom_addr &amp;= ~PCI_ROM_ADDRESS_MASK;
 	rom_addr |= region.start | PCI_ROM_ADDRESS_ENABLE;
<span class="p_chunk">@@ -69,6 +69,7 @@</span> <span class="p_context"> size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)</span>
 {
 	void __iomem *image;
 	int last_image;
<span class="p_add">+	unsigned length;</span>
 
 	image = rom;
 	do {
<span class="p_chunk">@@ -91,9 +92,9 @@</span> <span class="p_context"> size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)</span>
 		if (readb(pds + 3) != &#39;R&#39;)
 			break;
 		last_image = readb(pds + 21) &amp; 0x80;
<span class="p_del">-		/* this length is reliable */</span>
<span class="p_del">-		image += readw(pds + 16) * 512;</span>
<span class="p_del">-	} while (!last_image);</span>
<span class="p_add">+		length = readw(pds + 16);</span>
<span class="p_add">+		image += length * 512;</span>
<span class="p_add">+	} while (length &amp;&amp; !last_image);</span>
 
 	/* never return a size larger than the PCI resource window */
 	/* there are known ROMs that get the size wrong */
<span class="p_header">diff --git a/drivers/pci/setup-bus.c b/drivers/pci/setup-bus.c</span>
<span class="p_header">index 8fa2d4b..244ada4 100644</span>
<span class="p_header">--- a/drivers/pci/setup-bus.c</span>
<span class="p_header">+++ b/drivers/pci/setup-bus.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> void pci_setup_cardbus(struct pci_bus *bus)</span>
 		 bus-&gt;secondary, bus-&gt;subordinate);
 
 	res = bus-&gt;resource[0];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_IO) {
 		/*
 		 * The IO resource is allocated a range twice as large as it
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> void pci_setup_cardbus(struct pci_bus *bus)</span>
 	}
 
 	res = bus-&gt;resource[1];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_IO) {
 		dev_info(&amp;bridge-&gt;dev, &quot;  bridge window %pR\n&quot;, res);
 		pci_write_config_dword(bridge, PCI_CB_IO_BASE_1,
<span class="p_chunk">@@ -432,7 +432,7 @@</span> <span class="p_context"> void pci_setup_cardbus(struct pci_bus *bus)</span>
 	}
 
 	res = bus-&gt;resource[2];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_MEM) {
 		dev_info(&amp;bridge-&gt;dev, &quot;  bridge window %pR\n&quot;, res);
 		pci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_0,
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> void pci_setup_cardbus(struct pci_bus *bus)</span>
 	}
 
 	res = bus-&gt;resource[3];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_MEM) {
 		dev_info(&amp;bridge-&gt;dev, &quot;  bridge window %pR\n&quot;, res);
 		pci_write_config_dword(bridge, PCI_CB_MEMORY_BASE_1,
<span class="p_chunk">@@ -473,7 +473,7 @@</span> <span class="p_context"> static void pci_setup_bridge_io(struct pci_bus *bus)</span>
 
 	/* Set up the top and bottom of the PCI I/O segment for this bus. */
 	res = bus-&gt;resource[0];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_IO) {
 		pci_read_config_dword(bridge, PCI_IO_BASE, &amp;l);
 		l &amp;= 0xffff0000;
<span class="p_chunk">@@ -504,7 +504,7 @@</span> <span class="p_context"> static void pci_setup_bridge_mmio(struct pci_bus *bus)</span>
 
 	/* Set up the top and bottom of the PCI Memory segment for this bus. */
 	res = bus-&gt;resource[1];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_MEM) {
 		l = (region.start &gt;&gt; 16) &amp; 0xfff0;
 		l |= region.end &amp; 0xfff00000;
<span class="p_chunk">@@ -530,7 +530,7 @@</span> <span class="p_context"> static void pci_setup_bridge_mmio_pref(struct pci_bus *bus)</span>
 	/* Set up PREF base/limit. */
 	bu = lu = 0;
 	res = bus-&gt;resource[2];
<span class="p_del">-	pcibios_resource_to_bus(bridge, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(bridge-&gt;bus, &amp;region, res);</span>
 	if (res-&gt;flags &amp; IORESOURCE_PREFETCH) {
 		l = (region.start &gt;&gt; 16) &amp; 0xfff0;
 		l |= region.end &amp; 0xfff00000;
<span class="p_header">diff --git a/drivers/pci/setup-res.c b/drivers/pci/setup-res.c</span>
<span class="p_header">index be76eba..d427277 100644</span>
<span class="p_header">--- a/drivers/pci/setup-res.c</span>
<span class="p_header">+++ b/drivers/pci/setup-res.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> void pci_update_resource(struct pci_dev *dev, int resno)</span>
 	if (res-&gt;flags &amp; IORESOURCE_PCI_FIXED)
 		return;
 
<span class="p_del">-	pcibios_resource_to_bus(dev, &amp;region, res);</span>
<span class="p_add">+	pcibios_resource_to_bus(dev-&gt;bus, &amp;region, res);</span>
 
 	new = region.start | (res-&gt;flags &amp; PCI_REGION_FLAG_MASK);
 	if (res-&gt;flags &amp; IORESOURCE_IO)
<span class="p_header">diff --git a/drivers/pcmcia/i82092.c b/drivers/pcmcia/i82092.c</span>
<span class="p_header">index 4e8831b..099034b 100644</span>
<span class="p_header">--- a/drivers/pcmcia/i82092.c</span>
<span class="p_header">+++ b/drivers/pcmcia/i82092.c</span>
<span class="p_chunk">@@ -610,7 +610,7 @@</span> <span class="p_context"> static int i82092aa_set_mem_map(struct pcmcia_socket *socket, struct pccard_mem_</span>
 	
 	enter(&quot;i82092aa_set_mem_map&quot;);
 
<span class="p_del">-	pcibios_resource_to_bus(sock_info-&gt;dev, &amp;region, mem-&gt;res);</span>
<span class="p_add">+	pcibios_resource_to_bus(sock_info-&gt;dev-&gt;bus, &amp;region, mem-&gt;res);</span>
 	
 	map = mem-&gt;map;
 	if (map &gt; 4) {
<span class="p_header">diff --git a/drivers/pcmcia/yenta_socket.c b/drivers/pcmcia/yenta_socket.c</span>
<span class="p_header">index d07f9ac..13e76f9 100644</span>
<span class="p_header">--- a/drivers/pcmcia/yenta_socket.c</span>
<span class="p_header">+++ b/drivers/pcmcia/yenta_socket.c</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> static int yenta_set_mem_map(struct pcmcia_socket *sock, struct pccard_mem_map *</span>
 	unsigned int start, stop, card_start;
 	unsigned short word;
 
<span class="p_del">-	pcibios_resource_to_bus(socket-&gt;dev, &amp;region, mem-&gt;res);</span>
<span class="p_add">+	pcibios_resource_to_bus(socket-&gt;dev-&gt;bus, &amp;region, mem-&gt;res);</span>
 
 	map = mem-&gt;map;
 	start = region.start;
<span class="p_chunk">@@ -709,7 +709,7 @@</span> <span class="p_context"> static int yenta_allocate_res(struct yenta_socket *socket, int nr, unsigned type</span>
 	region.start = config_readl(socket, addr_start) &amp; mask;
 	region.end = config_readl(socket, addr_end) | ~mask;
 	if (region.start &amp;&amp; region.end &gt; region.start &amp;&amp; !override_bios) {
<span class="p_del">-		pcibios_bus_to_resource(dev, res, &amp;region);</span>
<span class="p_add">+		pcibios_bus_to_resource(dev-&gt;bus, res, &amp;region);</span>
 		if (pci_claim_resource(dev, PCI_BRIDGE_RESOURCES + nr) == 0)
 			return 0;
 		dev_printk(KERN_INFO, &amp;dev-&gt;dev,
<span class="p_chunk">@@ -1033,7 +1033,7 @@</span> <span class="p_context"> static void yenta_config_init(struct yenta_socket *socket)</span>
 	struct pci_dev *dev = socket-&gt;dev;
 	struct pci_bus_region region;
 
<span class="p_del">-	pcibios_resource_to_bus(socket-&gt;dev, &amp;region, &amp;dev-&gt;resource[0]);</span>
<span class="p_add">+	pcibios_resource_to_bus(socket-&gt;dev-&gt;bus, &amp;region, &amp;dev-&gt;resource[0]);</span>
 
 	config_writel(socket, CB_LEGACY_MODE_BASE, 0);
 	config_writel(socket, PCI_BASE_ADDRESS_0, region.start);
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index 375756f..348560a 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -424,7 +424,6 @@</span> <span class="p_context"> static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)</span>
 			&quot;iscsi_host_alloc failed\n&quot;);
 		return NULL;
 	}
<span class="p_del">-	shost-&gt;dma_boundary = pcidev-&gt;dma_mask;</span>
 	shost-&gt;max_id = BE2_MAX_SESSIONS;
 	shost-&gt;max_channel = 0;
 	shost-&gt;max_cmd_len = BEISCSI_MAX_CMD_LEN;
<span class="p_chunk">@@ -4399,9 +4398,9 @@</span> <span class="p_context"> free_port:</span>
 hba_free:
 	if (phba-&gt;msix_enabled)
 		pci_disable_msix(phba-&gt;pcidev);
<span class="p_del">-	iscsi_host_remove(phba-&gt;shost);</span>
 	pci_dev_put(phba-&gt;pcidev);
 	iscsi_host_free(phba-&gt;shost);
<span class="p_add">+	pci_set_drvdata(pcidev, NULL);</span>
 disable_pci:
 	pci_disable_device(pcidev);
 	return ret;
<span class="p_header">diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c</span>
<span class="p_header">index bc88cab..f5ccdcdf 100644</span>
<span class="p_header">--- a/drivers/scsi/hpsa.c</span>
<span class="p_header">+++ b/drivers/scsi/hpsa.c</span>
<span class="p_chunk">@@ -3507,10 +3507,6 @@</span> <span class="p_context"> static __devinit int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)</span>
 
 	/* Save the PCI command register */
 	pci_read_config_word(pdev, 4, &amp;command_register);
<span class="p_del">-	/* Turn the board off.  This is so that later pci_restore_state()</span>
<span class="p_del">-	 * won&#39;t turn the board on before the rest of config space is ready.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci_disable_device(pdev);</span>
 	pci_save_state(pdev);
 
 	/* find the first memory BAR, so we can find the cfg table */
<span class="p_chunk">@@ -3534,7 +3530,7 @@</span> <span class="p_context"> static __devinit int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)</span>
 	}
 	rc = write_driver_ver_to_cfgtable(cfgtable);
 	if (rc)
<span class="p_del">-		goto unmap_vaddr;</span>
<span class="p_add">+		goto unmap_cfgtable;</span>
 
 	/* If reset via doorbell register is supported, use that.
 	 * There are two such methods.  Favor the newest method.
<span class="p_chunk">@@ -3558,11 +3554,6 @@</span> <span class="p_context"> static __devinit int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)</span>
 		goto unmap_cfgtable;
 
 	pci_restore_state(pdev);
<span class="p_del">-	rc = pci_enable_device(pdev);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		dev_warn(&amp;pdev-&gt;dev, &quot;failed to enable device.\n&quot;);</span>
<span class="p_del">-		goto unmap_cfgtable;</span>
<span class="p_del">-	}</span>
 	pci_write_config_word(pdev, 4, command_register);
 
 	/* Some devices (notably the HP Smart Array 5i Controller)
<span class="p_chunk">@@ -4064,10 +4055,37 @@</span> <span class="p_context"> static void __devinit hpsa_hba_inquiry(struct ctlr_info *h)</span>
 static __devinit int hpsa_init_reset_devices(struct pci_dev *pdev)
 {
 	int rc, i;
<span class="p_add">+	void __iomem *vaddr;</span>
 
 	if (!reset_devices)
 		return 0;
 
<span class="p_add">+	/* kdump kernel is loading, we don&#39;t know in which state is</span>
<span class="p_add">+	 * the pci interface. The dev-&gt;enable_cnt is equal zero</span>
<span class="p_add">+	 * so we call enable+disable, wait a while and switch it on.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = pci_enable_device(pdev);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;Failed to enable PCI device\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pci_disable_device(pdev);</span>
<span class="p_add">+	msleep(260);			/* a randomly chosen number */</span>
<span class="p_add">+	rc = pci_enable_device(pdev);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;failed to enable device.\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pci_set_master(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaddr = pci_ioremap_bar(pdev, 0);</span>
<span class="p_add">+	if (vaddr == NULL) {</span>
<span class="p_add">+		rc = -ENOMEM;</span>
<span class="p_add">+		goto out_disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel(SA5_INTR_OFF, vaddr + SA5_REPLY_INTR_MASK_OFFSET);</span>
<span class="p_add">+	iounmap(vaddr);</span>
<span class="p_add">+</span>
 	/* Reset the controller with a PCI power-cycle or via doorbell */
 	rc = hpsa_kdump_hard_reset_controller(pdev);
 
<span class="p_chunk">@@ -4076,10 +4094,11 @@</span> <span class="p_context"> static __devinit int hpsa_init_reset_devices(struct pci_dev *pdev)</span>
 	 * &quot;performant mode&quot;.  Or, it might be 640x, which can&#39;t reset
 	 * due to concerns about shared bbwc between 6402/6404 pair.
 	 */
<span class="p_del">-	if (rc == -ENOTSUPP)</span>
<span class="p_del">-		return rc; /* just try to do the kdump anyhow. */</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		if (rc != -ENOTSUPP) /* just try to do the kdump anyhow. */</span>
<span class="p_add">+			rc = -ENODEV;</span>
<span class="p_add">+		goto out_disable;</span>
<span class="p_add">+	}</span>
 
 	/* Now try to get the controller to respond to a no-op */
 	dev_warn(&amp;pdev-&gt;dev, &quot;Waiting for controller to respond to no-op\n&quot;);
<span class="p_chunk">@@ -4090,7 +4109,11 @@</span> <span class="p_context"> static __devinit int hpsa_init_reset_devices(struct pci_dev *pdev)</span>
 			dev_warn(&amp;pdev-&gt;dev, &quot;no-op failed%s\n&quot;,
 					(i &lt; 11 ? &quot;; re-trying&quot; : &quot;&quot;));
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_disable:</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_disable_device(pdev);</span>
<span class="p_add">+	return rc;</span>
 }
 
 static __devinit int hpsa_allocate_cmd_pool(struct ctlr_info *h)
<span class="p_chunk">@@ -4191,6 +4214,7 @@</span> <span class="p_context"> static void hpsa_undo_allocations_after_kdump_soft_reset(struct ctlr_info *h)</span>
 		iounmap(h-&gt;transtable);
 	if (h-&gt;cfgtable)
 		iounmap(h-&gt;cfgtable);
<span class="p_add">+	pci_disable_device(h-&gt;pdev);</span>
 	pci_release_regions(h-&gt;pdev);
 	kfree(h);
 }
<span class="p_header">diff --git a/drivers/scsi/libsas/sas_discover.c b/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_header">index 629a086..5fbacde 100644</span>
<span class="p_header">--- a/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_header">+++ b/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_chunk">@@ -446,6 +446,7 @@</span> <span class="p_context"> static void sas_revalidate_domain(struct work_struct *work)</span>
 	struct sas_discovery_event *ev = to_sas_discovery_event(work);
 	struct asd_sas_port *port = ev-&gt;port;
 	struct sas_ha_struct *ha = port-&gt;ha;
<span class="p_add">+	struct domain_device *ddev = port-&gt;port_dev;</span>
 
 	/* prevent revalidation from finding sata links in recovery */
 	mutex_lock(&amp;ha-&gt;disco_mutex);
<span class="p_chunk">@@ -460,8 +461,9 @@</span> <span class="p_context"> static void sas_revalidate_domain(struct work_struct *work)</span>
 	SAS_DPRINTK(&quot;REVALIDATING DOMAIN on port %d, pid:%d\n&quot;, port-&gt;id,
 		    task_pid_nr(current));
 
<span class="p_del">-	if (port-&gt;port_dev)</span>
<span class="p_del">-		res = sas_ex_revalidate_domain(port-&gt;port_dev);</span>
<span class="p_add">+	if (ddev &amp;&amp; (ddev-&gt;dev_type == SAS_FANOUT_EXPANDER_DEVICE ||</span>
<span class="p_add">+		     ddev-&gt;dev_type == SAS_EDGE_EXPANDER_DEVICE))</span>
<span class="p_add">+		res = sas_ex_revalidate_domain(ddev);</span>
 
 	SAS_DPRINTK(&quot;done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n&quot;,
 		    port-&gt;id, task_pid_nr(current), res);
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index ac99b46..a30f7a0 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -1209,9 +1209,11 @@</span> <span class="p_context"> int scsi_prep_state_check(struct scsi_device *sdev, struct request *req)</span>
 				    &quot;rejecting I/O to dead device\n&quot;);
 			ret = BLKPREP_KILL;
 			break;
<span class="p_del">-		case SDEV_QUIESCE:</span>
 		case SDEV_BLOCK:
 		case SDEV_CREATED_BLOCK:
<span class="p_add">+			ret = BLKPREP_DEFER;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SDEV_QUIESCE:</span>
 			/*
 			 * If the devices is blocked we defer normal commands.
 			 */
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index eacd46b..fb119ce 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -498,7 +498,7 @@</span> <span class="p_context"> static ssize_t</span>
 sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)
 {
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int err = 0, err2;</span>
 	int len;
 
 	if (count &lt; SZ_SG_IO_HDR) {
<span class="p_chunk">@@ -527,8 +527,8 @@</span> <span class="p_context"> sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)</span>
 		goto err_out;
 	}
 err_out:
<span class="p_del">-	err = sg_finish_rem_req(srp);</span>
<span class="p_del">-	return (0 == err) ? count : err;</span>
<span class="p_add">+	err2 = sg_finish_rem_req(srp);</span>
<span class="p_add">+	return err ? : err2 ? : count;</span>
 }
 
 static ssize_t
<span class="p_header">diff --git a/drivers/scsi/sym53c8xx_2/sym_glue.c b/drivers/scsi/sym53c8xx_2/sym_glue.c</span>
<span class="p_header">index 36d1ed7..1e3d789 100644</span>
<span class="p_header">--- a/drivers/scsi/sym53c8xx_2/sym_glue.c</span>
<span class="p_header">+++ b/drivers/scsi/sym53c8xx_2/sym_glue.c</span>
<span class="p_chunk">@@ -1609,7 +1609,7 @@</span> <span class="p_context"> sym_iomap_device(struct sym_device *device)</span>
 	struct pci_bus_region bus_addr;
 	int i = 2;
 
<span class="p_del">-	pcibios_resource_to_bus(pdev, &amp;bus_addr, &amp;pdev-&gt;resource[1]);</span>
<span class="p_add">+	pcibios_resource_to_bus(pdev-&gt;bus, &amp;bus_addr, &amp;pdev-&gt;resource[1]);</span>
 	device-&gt;mmio_base = bus_addr.start;
 
 	if (device-&gt;chip.features &amp; FE_RAM) {
<span class="p_chunk">@@ -1619,7 +1619,8 @@</span> <span class="p_context"> sym_iomap_device(struct sym_device *device)</span>
 		 */
 		if (!pdev-&gt;resource[i].flags)
 			i++;
<span class="p_del">-		pcibios_resource_to_bus(pdev, &amp;bus_addr, &amp;pdev-&gt;resource[i]);</span>
<span class="p_add">+		pcibios_resource_to_bus(pdev-&gt;bus, &amp;bus_addr,</span>
<span class="p_add">+					&amp;pdev-&gt;resource[i]);</span>
 		device-&gt;ram_base = bus_addr.start;
 	}
 
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index 830adbe..1556db9 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -241,7 +241,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/staging/comedi/comedi_compat32.c b/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_header">index 41a7a62..a8a0c0f 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static int compat_cmd(struct file *file, unsigned long arg)</span>
 {
 	struct comedi_cmd __user *cmd;
 	struct comedi32_cmd_struct __user *cmd32;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc, err;</span>
 
 	cmd32 = compat_ptr(arg);
 	cmd = compat_alloc_user_space(sizeof(*cmd));
<span class="p_chunk">@@ -280,7 +280,15 @@</span> <span class="p_context"> static int compat_cmd(struct file *file, unsigned long arg)</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	return translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);</span>
<span class="p_add">+	rc = translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);</span>
<span class="p_add">+	if (rc == -EAGAIN) {</span>
<span class="p_add">+		/* Special case: copy cmd back to user. */</span>
<span class="p_add">+		err = put_compat_cmd(cmd32, cmd);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			rc = err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 
 /* Handle 32-bit COMEDI_CMDTEST ioctl. */
<span class="p_header">diff --git a/drivers/staging/vt6655/rf.c b/drivers/staging/vt6655/rf.c</span>
<span class="p_header">index b8ec783..3003363 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/rf.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/rf.c</span>
<span class="p_chunk">@@ -1029,6 +1029,7 @@</span> <span class="p_context"> unsigned char byPwrdBm = 0;</span>
 		break;
     case RATE_6M:
     case RATE_9M:
<span class="p_add">+    case RATE_12M:</span>
     case RATE_18M:
         byPwr = pDevice-&gt;abyOFDMPwrTbl[uCH];
         if (pDevice-&gt;byRFType == RF_UW2452) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tq.c b/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_header">index 977e1cf..4f447fd 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_chunk">@@ -26,36 +26,22 @@</span> <span class="p_context"></span>
 #include &quot;iscsi_target_tq.h&quot;
 #include &quot;iscsi_target.h&quot;
 
<span class="p_del">-static LIST_HEAD(active_ts_list);</span>
 static LIST_HEAD(inactive_ts_list);
<span class="p_del">-static DEFINE_SPINLOCK(active_ts_lock);</span>
 static DEFINE_SPINLOCK(inactive_ts_lock);
 static DEFINE_SPINLOCK(ts_bitmap_lock);
 
<span class="p_del">-static void iscsi_add_ts_to_active_list(struct iscsi_thread_set *ts)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;active_ts_lock);</span>
<span class="p_del">-	list_add_tail(&amp;ts-&gt;ts_list, &amp;active_ts_list);</span>
<span class="p_del">-	iscsit_global-&gt;active_ts++;</span>
<span class="p_del">-	spin_unlock(&amp;active_ts_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 extern void iscsi_add_ts_to_inactive_list(struct iscsi_thread_set *ts)
 {
<span class="p_add">+	if (!list_empty(&amp;ts-&gt;ts_list)) {</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	spin_lock(&amp;inactive_ts_lock);
 	list_add_tail(&amp;ts-&gt;ts_list, &amp;inactive_ts_list);
 	iscsit_global-&gt;inactive_ts++;
 	spin_unlock(&amp;inactive_ts_lock);
 }
 
<span class="p_del">-static void iscsi_del_ts_from_active_list(struct iscsi_thread_set *ts)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;active_ts_lock);</span>
<span class="p_del">-	list_del(&amp;ts-&gt;ts_list);</span>
<span class="p_del">-	iscsit_global-&gt;active_ts--;</span>
<span class="p_del">-	spin_unlock(&amp;active_ts_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)
 {
 	struct iscsi_thread_set *ts;
<span class="p_chunk">@@ -69,7 +55,7 @@</span> <span class="p_context"> static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)</span>
 	list_for_each_entry(ts, &amp;inactive_ts_list, ts_list)
 		break;
 
<span class="p_del">-	list_del(&amp;ts-&gt;ts_list);</span>
<span class="p_add">+	list_del_init(&amp;ts-&gt;ts_list);</span>
 	iscsit_global-&gt;inactive_ts--;
 	spin_unlock(&amp;inactive_ts_lock);
 
<span class="p_chunk">@@ -220,8 +206,6 @@</span> <span class="p_context"> static void iscsi_deallocate_extra_thread_sets(void)</span>
 
 void iscsi_activate_thread_set(struct iscsi_conn *conn, struct iscsi_thread_set *ts)
 {
<span class="p_del">-	iscsi_add_ts_to_active_list(ts);</span>
<span class="p_del">-</span>
 	spin_lock_bh(&amp;ts-&gt;ts_state_lock);
 	conn-&gt;thread_set = ts;
 	ts-&gt;conn = conn;
<span class="p_chunk">@@ -424,7 +408,6 @@</span> <span class="p_context"> struct iscsi_conn *iscsi_rx_thread_pre_handler(struct iscsi_thread_set *ts)</span>
 
 	if (ts-&gt;delay_inactive &amp;&amp; (--ts-&gt;thread_count == 0)) {
 		spin_unlock_bh(&amp;ts-&gt;ts_state_lock);
<span class="p_del">-		iscsi_del_ts_from_active_list(ts);</span>
 
 		if (!iscsit_global-&gt;in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
<span class="p_chunk">@@ -477,7 +460,6 @@</span> <span class="p_context"> struct iscsi_conn *iscsi_tx_thread_pre_handler(struct iscsi_thread_set *ts)</span>
 
 	if (ts-&gt;delay_inactive &amp;&amp; (--ts-&gt;thread_count == 0)) {
 		spin_unlock_bh(&amp;ts-&gt;ts_state_lock);
<span class="p_del">-		iscsi_del_ts_from_active_list(ts);</span>
 
 		if (!iscsit_global-&gt;in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index d34577d..8082674 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -1165,7 +1165,7 @@</span> <span class="p_context"> static u32 pscsi_get_device_type(struct se_device *dev)</span>
 	struct pscsi_dev_virt *pdv = dev-&gt;dev_ptr;
 	struct scsi_device *sd = pdv-&gt;pdv_sd;
 
<span class="p_del">-	return sd-&gt;type;</span>
<span class="p_add">+	return (sd) ? sd-&gt;type : TYPE_NO_LUN;</span>
 }
 
 static sector_t pscsi_get_blocks(struct se_device *dev)
<span class="p_header">diff --git a/drivers/target/tcm_fc/tfc_io.c b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">index dc7c0db..8d5cf53 100644</span>
<span class="p_header">--- a/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">+++ b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> void ft_invl_hw_context(struct ft_cmd *cmd)</span>
 		ep = fc_seq_exch(seq);
 		if (ep) {
 			lport = ep-&gt;lp;
<span class="p_del">-			if (lport &amp;&amp; (ep-&gt;xid &lt;= lport-&gt;lro_xid))</span>
<span class="p_add">+			if (lport &amp;&amp; (ep-&gt;xid &lt;= lport-&gt;lro_xid)) {</span>
 				/*
 				 * &quot;ddp_done&quot; trigger invalidation of HW
 				 * specific DDP context
<span class="p_chunk">@@ -345,6 +345,7 @@</span> <span class="p_context"> void ft_invl_hw_context(struct ft_cmd *cmd)</span>
 				 * identified using ep-&gt;xid)
 				 */
 				cmd-&gt;was_ddp_setup = 0;
<span class="p_add">+			}</span>
 		}
 	}
 }
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index cf9a191..bc955d7 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -173,6 +173,9 @@</span> <span class="p_context"> static int pty_signal(struct tty_struct *tty, int sig)</span>
 	unsigned long flags;
 	struct pid *pgrp;
 
<span class="p_add">+	if (sig != SIGINT &amp;&amp; sig != SIGQUIT &amp;&amp; sig != SIGTSTP)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (tty-&gt;link) {
 		spin_lock_irqsave(&amp;tty-&gt;link-&gt;ctrl_lock, flags);
 		pgrp = get_pid(tty-&gt;link-&gt;pgrp);
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 6f8f985..e4aada5 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static void moan_device(const char *str, struct pci_dev *dev)</span>
 	       &quot;Please send the output of lspci -vv, this\n&quot;
 	       &quot;message (0x%04x,0x%04x,0x%04x,0x%04x), the\n&quot;
 	       &quot;manufacturer and name of serial board or\n&quot;
<span class="p_del">-	       &quot;modem board to rmk+serial@arm.linux.org.uk.\n&quot;,</span>
<span class="p_add">+	       &quot;modem board to &lt;linux-serial@vger.kernel.org&gt;.\n&quot;,</span>
 	       pci_name(dev), str, dev-&gt;vendor, dev-&gt;device,
 	       dev-&gt;subsystem_vendor, dev-&gt;subsystem_device);
 }
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index a07eb4c..5f0b4a4 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -941,8 +941,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(start_tty);</span>
 /* We limit tty time update visibility to every 8 seconds or so. */
 static void tty_update_time(struct timespec *time)
 {
<span class="p_del">-	unsigned long sec = get_seconds() &amp; ~7;</span>
<span class="p_del">-	if ((long)(sec - time-&gt;tv_sec) &gt; 0)</span>
<span class="p_add">+	unsigned long sec = get_seconds();</span>
<span class="p_add">+	if (abs(sec - time-&gt;tv_sec) &amp; ~7)</span>
 		time-&gt;tv_sec = sec;
 }
 
<span class="p_header">diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c</span>
<span class="p_header">index f8d03da..9ab33c7 100644</span>
<span class="p_header">--- a/drivers/tty/tty_ioctl.c</span>
<span class="p_header">+++ b/drivers/tty/tty_ioctl.c</span>
<span class="p_chunk">@@ -153,11 +153,17 @@</span> <span class="p_context"> void tty_wait_until_sent(struct tty_struct *tty, long timeout)</span>
 #endif
 	if (!timeout)
 		timeout = MAX_SCHEDULE_TIMEOUT;
<span class="p_add">+</span>
 	if (wait_event_interruptible_timeout(tty-&gt;write_wait,
<span class="p_del">-			!tty_chars_in_buffer(tty), timeout) &gt;= 0) {</span>
<span class="p_del">-		if (tty-&gt;ops-&gt;wait_until_sent)</span>
<span class="p_del">-			tty-&gt;ops-&gt;wait_until_sent(tty, timeout);</span>
<span class="p_add">+			!tty_chars_in_buffer(tty), timeout) &lt; 0) {</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (timeout == MAX_SCHEDULE_TIMEOUT)</span>
<span class="p_add">+		timeout = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tty-&gt;ops-&gt;wait_until_sent)</span>
<span class="p_add">+		tty-&gt;ops-&gt;wait_until_sent(tty, timeout);</span>
 }
 EXPORT_SYMBOL(tty_wait_until_sent);
 
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 268294c..334a7b2 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -498,6 +498,7 @@</span> <span class="p_context"> void invert_screen(struct vc_data *vc, int offset, int count, int viewed)</span>
 #endif
 	if (DO_UPDATE(vc))
 		do_update_region(vc, (unsigned long) p, count);
<span class="p_add">+	notify_update(vc);</span>
 }
 
 /* used by selection: complement pointer position */
<span class="p_chunk">@@ -514,6 +515,7 @@</span> <span class="p_context"> void complement_pos(struct vc_data *vc, int offset)</span>
 		scr_writew(old, screenpos(vc, old_offset, 1));
 		if (DO_UPDATE(vc))
 			vc-&gt;vc_sw-&gt;con_putc(vc, old, oldy, oldx);
<span class="p_add">+		notify_update(vc);</span>
 	}
 
 	old_offset = offset;
<span class="p_chunk">@@ -531,8 +533,8 @@</span> <span class="p_context"> void complement_pos(struct vc_data *vc, int offset)</span>
 			oldy = (offset &gt;&gt; 1) / vc-&gt;vc_cols;
 			vc-&gt;vc_sw-&gt;con_putc(vc, new, oldy, oldx);
 		}
<span class="p_add">+		notify_update(vc);</span>
 	}
<span class="p_del">-</span>
 }
 
 static void insert_char(struct vc_data *vc, unsigned int nr)
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 0532577..25bc1d6 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1008,6 +1008,7 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	unsigned long quirks;
 	int num_rx_buf;
 	int i;
<span class="p_add">+	unsigned int elength = 0;</span>
 	int combined_interfaces = 0;
 
 	/* normal quirks */
<span class="p_chunk">@@ -1043,6 +1044,12 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	}
 
 	while (buflen &gt; 0) {
<span class="p_add">+		elength = buffer[0];</span>
<span class="p_add">+		if (!elength) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage byte\n&quot;);</span>
<span class="p_add">+			elength = 1;</span>
<span class="p_add">+			goto next_desc;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
<span class="p_chunk">@@ -1050,6 +1057,8 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_add">+			if (elength &lt; sizeof(struct usb_cdc_union_desc))</span>
<span class="p_add">+				goto next_desc;</span>
 			if (union_header) {
 				dev_err(&amp;intf-&gt;dev, &quot;More than one &quot;
 					&quot;union descriptor, skipping ...\n&quot;);
<span class="p_chunk">@@ -1058,31 +1067,38 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 			union_header = (struct usb_cdc_union_desc *)buffer;
 			break;
 		case USB_CDC_COUNTRY_TYPE: /* export through sysfs*/
<span class="p_add">+			if (elength &lt; sizeof(struct usb_cdc_country_functional_desc))</span>
<span class="p_add">+				goto next_desc;</span>
 			cfd = (struct usb_cdc_country_functional_desc *)buffer;
 			break;
 		case USB_CDC_HEADER_TYPE: /* maybe check version */
 			break; /* for now we ignore it */
 		case USB_CDC_ACM_TYPE:
<span class="p_add">+			if (elength &lt; 4)</span>
<span class="p_add">+				goto next_desc;</span>
 			ac_management_function = buffer[3];
 			break;
 		case USB_CDC_CALL_MANAGEMENT_TYPE:
<span class="p_add">+			if (elength &lt; 5)</span>
<span class="p_add">+				goto next_desc;</span>
 			call_management_function = buffer[3];
 			call_interface_num = buffer[4];
 			if ( (quirks &amp; NOT_A_MODEM) == 0 &amp;&amp; (call_management_function &amp; 3) != 3)
 				dev_err(&amp;intf-&gt;dev, &quot;This device cannot do calls on its own. It is not a modem.\n&quot;);
 			break;
 		default:
<span class="p_del">-			/* there are LOTS more CDC descriptors that</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * there are LOTS more CDC descriptors that</span>
 			 * could legitimately be found here.
 			 */
 			dev_dbg(&amp;intf-&gt;dev, &quot;Ignoring descriptor: &quot;
<span class="p_del">-					&quot;type %02x, length %d\n&quot;,</span>
<span class="p_del">-					buffer[2], buffer[0]);</span>
<span class="p_add">+					&quot;type %02x, length %ud\n&quot;,</span>
<span class="p_add">+					buffer[2], elength);</span>
 			break;
 		}
 next_desc:
<span class="p_del">-		buflen -= buffer[0];</span>
<span class="p_del">-		buffer += buffer[0];</span>
<span class="p_add">+		buflen -= elength;</span>
<span class="p_add">+		buffer += elength;</span>
 	}
 
 	if (!union_header) {
<span class="p_header">diff --git a/drivers/usb/core/buffer.c b/drivers/usb/core/buffer.c</span>
<span class="p_header">index b0585e6..19fa68a 100644</span>
<span class="p_header">--- a/drivers/usb/core/buffer.c</span>
<span class="p_header">+++ b/drivers/usb/core/buffer.c</span>
<span class="p_chunk">@@ -22,17 +22,25 @@</span> <span class="p_context"></span>
  */
 
 /* FIXME tune these based on pool statistics ... */
<span class="p_del">-static const size_t	pool_max[HCD_BUFFER_POOLS] = {</span>
<span class="p_del">-	/* platforms without dma-friendly caches might need to</span>
<span class="p_del">-	 * prevent cacheline sharing...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	32,</span>
<span class="p_del">-	128,</span>
<span class="p_del">-	512,</span>
<span class="p_del">-	PAGE_SIZE / 2</span>
<span class="p_del">-	/* bigger --&gt; allocate pages */</span>
<span class="p_add">+static size_t pool_max[HCD_BUFFER_POOLS] = {</span>
<span class="p_add">+	32, 128, 512, 2048,</span>
 };
 
<span class="p_add">+void __init usb_init_pool_max(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The pool_max values must never be smaller than</span>
<span class="p_add">+	 * ARCH_KMALLOC_MINALIGN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ARCH_KMALLOC_MINALIGN &lt;= 32)</span>
<span class="p_add">+		;			/* Original value is okay */</span>
<span class="p_add">+	else if (ARCH_KMALLOC_MINALIGN &lt;= 64)</span>
<span class="p_add">+		pool_max[0] = 64;</span>
<span class="p_add">+	else if (ARCH_KMALLOC_MINALIGN &lt;= 128)</span>
<span class="p_add">+		pool_max[0] = 0;	/* Don&#39;t use this pool */</span>
<span class="p_add">+	else</span>
<span class="p_add">+		BUILD_BUG();		/* We don&#39;t allow this */</span>
<span class="p_add">+}</span>
 
 /* SETUP primitives */
 
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 371fe69..d2ae3d9 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -444,6 +444,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	as-&gt;status = urb-&gt;status;
 	signr = as-&gt;signr;
 	if (signr) {
<span class="p_add">+		memset(&amp;sinfo, 0, sizeof(sinfo));</span>
 		sinfo.si_signo = as-&gt;signr;
 		sinfo.si_errno = as-&gt;status;
 		sinfo.si_code = SI_ASYNCIO;
<span class="p_chunk">@@ -2091,6 +2092,7 @@</span> <span class="p_context"> static void usbdev_remove(struct usb_device *udev)</span>
 		wake_up_all(&amp;ps-&gt;wait);
 		list_del_init(&amp;ps-&gt;list);
 		if (ps-&gt;discsignr) {
<span class="p_add">+			memset(&amp;sinfo, 0, sizeof(sinfo));</span>
 			sinfo.si_signo = ps-&gt;discsignr;
 			sinfo.si_errno = EPIPE;
 			sinfo.si_code = SI_ASYNCIO;
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index 35bc3ba..621ea00 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -1686,6 +1686,18 @@</span> <span class="p_context"> static int autosuspend_check(struct usb_device *udev)</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;remote wakeup needed for autosuspend\n&quot;);
 		return -EOPNOTSUPP;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the device is a direct child of the root hub and the HCD</span>
<span class="p_add">+	 * doesn&#39;t handle wakeup requests, don&#39;t allow autosuspend when</span>
<span class="p_add">+	 * wakeup is needed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (w &amp;&amp; udev-&gt;parent == udev-&gt;bus-&gt;root_hub &amp;&amp;</span>
<span class="p_add">+			bus_to_hcd(udev-&gt;bus)-&gt;cant_recv_wakeups) {</span>
<span class="p_add">+		dev_dbg(&amp;udev-&gt;dev, &quot;HCD doesn&#39;t handle wakeup requests\n&quot;);</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	udev-&gt;do_remote_wakeup = w;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 6baeada..f1d0e3c 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1528,6 +1528,7 @@</span> <span class="p_context"> static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_hcd		*hcd;
<span class="p_add">+	struct usb_device	*udev = urb-&gt;dev;</span>
 	int			retval = -EIDRM;
 	unsigned long		flags;
 
<span class="p_chunk">@@ -1539,20 +1540,19 @@</span> <span class="p_context"> int usb_hcd_unlink_urb (struct urb *urb, int status)</span>
 	spin_lock_irqsave(&amp;hcd_urb_unlink_lock, flags);
 	if (atomic_read(&amp;urb-&gt;use_count) &gt; 0) {
 		retval = 0;
<span class="p_del">-		usb_get_dev(urb-&gt;dev);</span>
<span class="p_add">+		usb_get_dev(udev);</span>
 	}
 	spin_unlock_irqrestore(&amp;hcd_urb_unlink_lock, flags);
 	if (retval == 0) {
 		hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 		retval = unlink1(hcd, urb, status);
<span class="p_del">-		usb_put_dev(urb-&gt;dev);</span>
<span class="p_add">+		if (retval == 0)</span>
<span class="p_add">+			retval = -EINPROGRESS;</span>
<span class="p_add">+		else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)</span>
<span class="p_add">+			dev_dbg(&amp;udev-&gt;dev, &quot;hcd_unlink_urb %p fail %d\n&quot;,</span>
<span class="p_add">+					urb, retval);</span>
<span class="p_add">+		usb_put_dev(udev);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	if (retval == 0)</span>
<span class="p_del">-		retval = -EINPROGRESS;</span>
<span class="p_del">-	else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)</span>
<span class="p_del">-		dev_dbg(&amp;urb-&gt;dev-&gt;dev, &quot;hcd_unlink_urb %p fail %d\n&quot;,</span>
<span class="p_del">-				urb, retval);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c</span>
<span class="p_header">index c74ba7b..8966960 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.c</span>
<span class="p_header">+++ b/drivers/usb/core/usb.c</span>
<span class="p_chunk">@@ -1010,6 +1010,7 @@</span> <span class="p_context"> static int __init usb_init(void)</span>
 		pr_info(&quot;%s: USB support disabled\n&quot;, usbcore_name);
 		return 0;
 	}
<span class="p_add">+	usb_init_pool_max();</span>
 
 	retval = usb_debugfs_init();
 	if (retval)
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index d9eaaa3..093e907 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -570,6 +570,7 @@</span> <span class="p_context"> static ssize_t ep_aio_read_retry(struct kiocb *iocb)</span>
 			break;
 	}
 	kfree(priv-&gt;buf);
<span class="p_add">+	kfree(priv-&gt;iv);</span>
 	kfree(priv);
 	return len;
 }
<span class="p_chunk">@@ -591,6 +592,7 @@</span> <span class="p_context"> static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)</span>
 	 */
 	if (priv-&gt;iv == NULL || unlikely(req-&gt;actual == 0)) {
 		kfree(req-&gt;buf);
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		iocb-&gt;private = NULL;
 		/* aio_complete() reports bytes-transferred _and_ faults */
<span class="p_chunk">@@ -626,7 +628,7 @@</span> <span class="p_context"> ep_aio_rwtail(</span>
 	struct usb_request	*req;
 	ssize_t			value;
 
<span class="p_del">-	priv = kmalloc(sizeof *priv, GFP_KERNEL);</span>
<span class="p_add">+	priv = kzalloc(sizeof *priv, GFP_KERNEL);</span>
 	if (!priv) {
 		value = -ENOMEM;
 fail:
<span class="p_chunk">@@ -634,11 +636,19 @@</span> <span class="p_context"> fail:</span>
 		return value;
 	}
 	iocb-&gt;private = priv;
<span class="p_del">-	priv-&gt;iv = iv;</span>
<span class="p_add">+	if (iv) {</span>
<span class="p_add">+		priv-&gt;iv = kmemdup(iv, nr_segs * sizeof(struct iovec),</span>
<span class="p_add">+				   GFP_KERNEL);</span>
<span class="p_add">+		if (!priv-&gt;iv) {</span>
<span class="p_add">+			kfree(priv);</span>
<span class="p_add">+			goto fail;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	priv-&gt;nr_segs = nr_segs;
 
 	value = get_ready_ep(iocb-&gt;ki_filp-&gt;f_flags, epdata);
 	if (unlikely(value &lt; 0)) {
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		goto fail;
 	}
<span class="p_chunk">@@ -672,6 +682,7 @@</span> <span class="p_context"> fail:</span>
 	mutex_unlock(&amp;epdata-&gt;lock);
 
 	if (unlikely(value)) {
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		put_ep(epdata);
 	} else
<span class="p_header">diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">index fc72d44..949303f 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_chunk">@@ -2242,6 +2242,9 @@</span> <span class="p_context"> struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,</span>
 	hcd-&gt;rsrc_start = res_start;
 	hcd-&gt;rsrc_len = res_len;
 
<span class="p_add">+	/* This driver doesn&#39;t support wakeup requests */</span>
<span class="p_add">+	hcd-&gt;cant_recv_wakeups = 1;</span>
<span class="p_add">+</span>
 	ret = usb_add_hcd(hcd, irq, irqflags);
 	if (ret)
 		goto err_unmap;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 56ec28b..a6d4393 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -383,6 +383,10 @@</span> <span class="p_context"> static void xhci_clear_port_change_bit(struct xhci_hcd *xhci, u16 wValue,</span>
 		status = PORT_PLC;
 		port_change_bit = &quot;link state&quot;;
 		break;
<span class="p_add">+	case USB_PORT_FEAT_C_PORT_CONFIG_ERROR:</span>
<span class="p_add">+		status = PORT_CEC;</span>
<span class="p_add">+		port_change_bit = &quot;config error&quot;;</span>
<span class="p_add">+		break;</span>
 	default:
 		/* Should never happen */
 		return;
<span class="p_chunk">@@ -617,6 +621,8 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 			if ((temp &amp; PORT_WRC))
 				status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_add">+			if ((temp &amp; PORT_CEC))</span>
<span class="p_add">+				status |= USB_PORT_STAT_C_CONFIG_ERROR &lt;&lt; 16;</span>
 		}
 
 		if (hcd-&gt;speed != HCD_USB3) {
<span class="p_chunk">@@ -904,6 +910,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 		case USB_PORT_FEAT_C_ENABLE:
 		case USB_PORT_FEAT_C_PORT_LINK_STATE:
<span class="p_add">+		case USB_PORT_FEAT_C_PORT_CONFIG_ERROR:</span>
 			xhci_clear_port_change_bit(xhci, wValue, wIndex,
 					port_array[wIndex], temp);
 			break;
<span class="p_chunk">@@ -957,7 +964,7 @@</span> <span class="p_context"> int xhci_hub_status_data(struct usb_hcd *hcd, char *buf)</span>
 	 */
 	status = bus_state-&gt;resuming_ports;
 
<span class="p_del">-	mask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC;</span>
<span class="p_add">+	mask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC | PORT_CEC;</span>
 
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	/* For each port, did anything change?  If so, set that bit in buf. */
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c9e39d4..710b2e9 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -36,6 +36,9 @@</span> <span class="p_context"></span>
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -102,6 +105,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_AMD)
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_AVOID_BEI;</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
 		xhci-&gt;quirks |= XHCI_EP_LIMIT_QUIRK;
<span class="p_chunk">@@ -116,7 +121,12 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 * PPT chipsets.
 		 */
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
<span class="p_del">-		xhci-&gt;quirks |= XHCI_AVOID_BEI;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;</span>
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_ASROCK_P67) {
<span class="p_chunk">@@ -131,6 +141,21 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Make sure PME works on some Intel xHCI controllers by writing 1 to clear</span>
<span class="p_add">+ * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xhci_pme_quirk(struct xhci_hcd *xhci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+	void __iomem *reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = (void __iomem *) xhci-&gt;cap_regs + 0x80a4;</span>
<span class="p_add">+	val = readl(reg);</span>
<span class="p_add">+	writel(val | BIT(28), reg);</span>
<span class="p_add">+	readl(reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* called during probe() after chip reset completes */
 static int xhci_pci_setup(struct usb_hcd *hcd)
 {
<span class="p_chunk">@@ -238,6 +263,9 @@</span> <span class="p_context"> static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)</span>
 			xhci-&gt;shared_hcd-&gt;state != HC_STATE_SUSPENDED)
 		return -EINVAL;
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_PME_STUCK_QUIRK)</span>
<span class="p_add">+		xhci_pme_quirk(xhci);</span>
<span class="p_add">+</span>
 	retval = xhci_suspend(xhci, do_wakeup);
 
 	return retval;
<span class="p_chunk">@@ -268,6 +296,9 @@</span> <span class="p_context"> static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)</span>
 	if (usb_is_intel_switchable_xhci(pdev))
 		usb_enable_xhci_ports(pdev);
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_PME_STUCK_QUIRK)</span>
<span class="p_add">+		xhci_pme_quirk(xhci);</span>
<span class="p_add">+</span>
 	retval = xhci_resume(xhci, hibernated);
 	return retval;
 }
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 950edeb..e47a4e1 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2049,7 +2049,7 @@</span> <span class="p_context"> static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 	if (event_trb != ep_ring-&gt;dequeue) {
 		/* The event was for the status stage */
 		if (event_trb == td-&gt;last_trb) {
<span class="p_del">-			if (td-&gt;urb-&gt;actual_length != 0) {</span>
<span class="p_add">+			if (td-&gt;urb_length_set) {</span>
 				/* Don&#39;t overwrite a previously set error code
 				 */
 				if ((*status == -EINPROGRESS || *status == 0) &amp;&amp;
<span class="p_chunk">@@ -2063,7 +2063,13 @@</span> <span class="p_context"> static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 					td-&gt;urb-&gt;transfer_buffer_length;
 			}
 		} else {
<span class="p_del">-		/* Maybe the event was for the data stage? */</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Maybe the event was for the data stage? If so, update</span>
<span class="p_add">+			 * already the actual_length of the URB and flag it as</span>
<span class="p_add">+			 * set, so that it is not overwritten in the event for</span>
<span class="p_add">+			 * the last TRB.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			td-&gt;urb_length_set = true;</span>
 			td-&gt;urb-&gt;actual_length =
 				td-&gt;urb-&gt;transfer_buffer_length -
 				EVENT_TRB_LEN(le32_to_cpu(event-&gt;transfer_len));
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 6c809350..80b3d85 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1,3 +1,4 @@</span> <span class="p_context"></span>
<span class="p_add">+</span>
 /*
  * xHCI host controller driver
  *
<span class="p_chunk">@@ -88,9 +89,10 @@</span> <span class="p_context"> struct xhci_cap_regs {</span>
 #define HCS_IST(p)		(((p) &gt;&gt; 0) &amp; 0xf)
 /* bits 4:7, max number of Event Ring segments */
 #define HCS_ERST_MAX(p)		(((p) &gt;&gt; 4) &amp; 0xf)
<span class="p_add">+/* bits 21:25 Hi 5 bits of Scratchpad buffers SW must allocate for the HW */</span>
 /* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
<span class="p_del">-/* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */</span>
<span class="p_del">-#define HCS_MAX_SCRATCHPAD(p)   (((p) &gt;&gt; 27) &amp; 0x1f)</span>
<span class="p_add">+/* bits 27:31 Lo 5 bits of Scratchpad buffers SW must allocate for the HW */</span>
<span class="p_add">+#define HCS_MAX_SCRATCHPAD(p)   ((((p) &gt;&gt; 16) &amp; 0x3e0) | (((p) &gt;&gt; 27) &amp; 0x1f))</span>
 
 /* HCSPARAMS3 - hcs_params3 - bitmasks */
 /* bits 0:7, Max U1 to U0 latency for the roothub ports */
<span class="p_chunk">@@ -1254,6 +1256,8 @@</span> <span class="p_context"> struct xhci_td {</span>
 	struct xhci_segment	*start_seg;
 	union xhci_trb		*first_trb;
 	union xhci_trb		*last_trb;
<span class="p_add">+	/* actual_length of the URB has already been set */</span>
<span class="p_add">+	bool			urb_length_set;</span>
 };
 
 /* xHCI command default timeout value */
<span class="p_chunk">@@ -1511,6 +1515,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_PLAT		(1 &lt;&lt; 16)
 #define XHCI_SLOW_SUSPEND	(1 &lt;&lt; 17)
 #define XHCI_SPURIOUS_WAKEUP	(1 &lt;&lt; 18)
<span class="p_add">+#define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/serial/bus.c b/drivers/usb/serial/bus.c</span>
<span class="p_header">index ed8adb0..358d2d6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/bus.c</span>
<span class="p_header">+++ b/drivers/usb/serial/bus.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"> static int usb_serial_device_probe(struct device *dev)</span>
 {
 	struct usb_serial_driver *driver;
 	struct usb_serial_port *port;
<span class="p_add">+	struct device *tty_dev;</span>
 	int retval = 0;
 	int minor;
 
<span class="p_chunk">@@ -71,12 +72,20 @@</span> <span class="p_context"> static int usb_serial_device_probe(struct device *dev)</span>
 	retval = device_create_file(dev, &amp;dev_attr_port_number);
 	if (retval) {
 		if (driver-&gt;port_remove)
<span class="p_del">-			retval = driver-&gt;port_remove(port);</span>
<span class="p_add">+			driver-&gt;port_remove(port);</span>
 		goto exit;
 	}
 
 	minor = port-&gt;number;
<span class="p_del">-	tty_register_device(usb_serial_tty_driver, minor, dev);</span>
<span class="p_add">+	tty_dev = tty_register_device(usb_serial_tty_driver, minor, dev);</span>
<span class="p_add">+	if (IS_ERR(tty_dev)) {</span>
<span class="p_add">+		retval = PTR_ERR(tty_dev);</span>
<span class="p_add">+		device_remove_file(dev, &amp;dev_attr_port_number);</span>
<span class="p_add">+		if (driver-&gt;port_remove)</span>
<span class="p_add">+			driver-&gt;port_remove(port);</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_info(&amp;port-&gt;serial-&gt;dev-&gt;dev,
 		 &quot;%s converter now attached to ttyUSB%d\n&quot;,
 		 driver-&gt;description, minor);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 8137937..5c289fc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x0846, 0x1100) }, /* NetGear Managed Switch M4100 series, M5300 series, M7100 series */
 	{ USB_DEVICE(0x08e6, 0x5501) }, /* Gemalto Prox-PU/CU contactless smartcard reader */
 	{ USB_DEVICE(0x08FD, 0x000A) }, /* Digianswer A/S , ZigBee/802.15.4 MAC Device */
<span class="p_add">+	{ USB_DEVICE(0x0908, 0x01FF) }, /* Siemens RUGGEDCOM USB Serial Console */</span>
 	{ USB_DEVICE(0x0BED, 0x1100) }, /* MEI (TM) Cashflow-SC Bill/Voucher Acceptor */
 	{ USB_DEVICE(0x0BED, 0x1101) }, /* MEI series 2000 Combo Acceptor */
 	{ USB_DEVICE(0x0FCF, 0x1003) }, /* Dynastream ANT development board */
<span class="p_chunk">@@ -152,6 +153,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x166A, 0x0305) }, /* Clipsal C-5000CT2 C-Bus Spectrum Colour Touchscreen */
 	{ USB_DEVICE(0x166A, 0x0401) }, /* Clipsal L51xx C-Bus Architectural Dimmer */
 	{ USB_DEVICE(0x166A, 0x0101) }, /* Clipsal 5560884 C-Bus Multi-room Audio Matrix Switcher */
<span class="p_add">+	{ USB_DEVICE(0x16C0, 0x09B0) }, /* Lunatico Seletek */</span>
<span class="p_add">+	{ USB_DEVICE(0x16C0, 0x09B1) }, /* Lunatico Seletek */</span>
 	{ USB_DEVICE(0x16D6, 0x0001) }, /* Jablotron serial interface */
 	{ USB_DEVICE(0x16DC, 0x0010) }, /* W-IE-NE-R Plein &amp; Baus GmbH PL512 Power Supply */
 	{ USB_DEVICE(0x16DC, 0x0011) }, /* W-IE-NE-R Plein &amp; Baus GmbH RCM Remote Control for MARATON Power Supply */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 4bfcfa7..06abee6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -628,6 +628,7 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },</span>
 	/*
 	 * ELV devices:
 	 */
<span class="p_chunk">@@ -823,6 +824,8 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELSTER_UNICOM_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_JTAGCABLEII_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_ISPCABLEIII_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CYBER_CORTEX_AV_PID),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },</span>
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_H_PID),
<span class="p_chunk">@@ -1000,6 +1003,23 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },
 	/* GE Healthcare devices */
 	{ USB_DEVICE(GE_HEALTHCARE_VID, GE_HEALTHCARE_NEMO_TRACKER_PID) },
<span class="p_add">+	/* Active Research (Actisense) devices */</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NDC_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_USG_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NGT_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NGW_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AC_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AD_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AF_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEAGAUGE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASWITCH_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_NMEA2000_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ETHERNET_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_WIFI_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_DISPLAY_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_LITE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ANALOG_PID) },</span>
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
<span class="p_chunk">@@ -1930,8 +1950,12 @@</span> <span class="p_context"> static int ftdi_8u2232c_probe(struct usb_serial *serial)</span>
 
 	dbg(&quot;%s&quot;, __func__);
 
<span class="p_del">-	if ((udev-&gt;manufacturer &amp;&amp; !strcmp(udev-&gt;manufacturer, &quot;CALAO Systems&quot;)) ||</span>
<span class="p_del">-	    (udev-&gt;product &amp;&amp; !strcmp(udev-&gt;product, &quot;BeagleBone/XDS100V2&quot;)))</span>
<span class="p_add">+	if (udev-&gt;manufacturer &amp;&amp; !strcmp(udev-&gt;manufacturer, &quot;CALAO Systems&quot;))</span>
<span class="p_add">+		return ftdi_jtag_probe(serial);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (udev-&gt;product &amp;&amp;</span>
<span class="p_add">+		(!strcmp(udev-&gt;product, &quot;BeagleBone/XDS100V2&quot;) ||</span>
<span class="p_add">+		 !strcmp(udev-&gt;product, &quot;SNAP Connect E10&quot;)))</span>
 		return ftdi_jtag_probe(serial);
 
 	return 0;
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index ecb4dee..105b982 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -38,6 +38,9 @@</span> <span class="p_context"></span>
 
 #define FTDI_LUMEL_PD12_PID	0x6002
 
<span class="p_add">+/* Cyber Cortex AV by Fabulous Silicon (http://fabuloussilicon.com) */</span>
<span class="p_add">+#define CYBER_CORTEX_AV_PID	0x8698</span>
<span class="p_add">+</span>
 /*
  * Marvell OpenRD Base, Client
  * http://www.open-rd.org
<span class="p_chunk">@@ -558,6 +561,12 @@</span> <span class="p_context"></span>
  */
 #define FTDI_NT_ORIONLXM_PID	0x7c90	/* OrionLXm Substation Automation Platform */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Synapse Wireless product ids (FTDI_VID)</span>
<span class="p_add">+ * http://www.synapse-wireless.com</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_SYNAPSE_SS200_PID 0x9090 /* SS200 - SNAP Stick 200 */</span>
<span class="p_add">+</span>
 
 /********************************/
 /** third-party VID/PID combos **/
<span class="p_chunk">@@ -1432,3 +1441,23 @@</span> <span class="p_context"></span>
  */
 #define GE_HEALTHCARE_VID		0x1901
 #define GE_HEALTHCARE_NEMO_TRACKER_PID	0x0015
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Active Research (Actisense) devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ACTISENSE_NDC_PID		0xD9A8 /* NDC USB Serial Adapter */</span>
<span class="p_add">+#define ACTISENSE_USG_PID		0xD9A9 /* USG USB Serial Adapter */</span>
<span class="p_add">+#define ACTISENSE_NGT_PID		0xD9AA /* NGT NMEA2000 Interface */</span>
<span class="p_add">+#define ACTISENSE_NGW_PID		0xD9AB /* NGW NMEA2000 Gateway */</span>
<span class="p_add">+#define ACTISENSE_D9AC_PID		0xD9AC /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AD_PID		0xD9AD /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AE_PID		0xD9AE /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AF_PID		0xD9AF /* Actisense Reserved */</span>
<span class="p_add">+#define CHETCO_SEAGAUGE_PID		0xA548 /* SeaGauge USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASWITCH_PID		0xA549 /* SeaSwitch USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASMART_NMEA2000_PID	0xA54A /* SeaSmart NMEA2000 Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_ETHERNET_PID	0xA54B /* SeaSmart Ethernet Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_WIFI_PID	0xA5AC /* SeaSmart Wifi Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_DISPLAY_PID	0xA5AD /* SeaSmart NMEA2000 Display */</span>
<span class="p_add">+#define CHETCO_SEASMART_LITE_PID	0xA5AE /* SeaSmart Lite USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASMART_ANALOG_PID	0xA5AF /* SeaSmart Analog Adapter */</span>
<span class="p_header">diff --git a/drivers/video/arkfb.c b/drivers/video/arkfb.c</span>
<span class="p_header">index 555dd4c..65196fe 100644</span>
<span class="p_header">--- a/drivers/video/arkfb.c</span>
<span class="p_header">+++ b/drivers/video/arkfb.c</span>
<span class="p_chunk">@@ -1014,7 +1014,7 @@</span> <span class="p_context"> static int __devinit ark_pci_probe(struct pci_dev *dev, const struct pci_device_</span>
 
 	vga_res.flags = IORESOURCE_IO;
 
<span class="p_del">-	pcibios_bus_to_resource(dev, &amp;vga_res, &amp;bus_reg);</span>
<span class="p_add">+	pcibios_bus_to_resource(dev-&gt;bus, &amp;vga_res, &amp;bus_reg);</span>
 
 	par-&gt;state.vgabase = (void __iomem *) vga_res.start;
 
<span class="p_header">diff --git a/drivers/video/s3fb.c b/drivers/video/s3fb.c</span>
<span class="p_header">index 2c80246..7b7af8c 100644</span>
<span class="p_header">--- a/drivers/video/s3fb.c</span>
<span class="p_header">+++ b/drivers/video/s3fb.c</span>
<span class="p_chunk">@@ -1172,7 +1172,7 @@</span> <span class="p_context"> static int __devinit s3_pci_probe(struct pci_dev *dev, const struct pci_device_i</span>
 
 	vga_res.flags = IORESOURCE_IO;
 
<span class="p_del">-	pcibios_bus_to_resource(dev, &amp;vga_res, &amp;bus_reg);</span>
<span class="p_add">+	pcibios_bus_to_resource(dev-&gt;bus, &amp;vga_res, &amp;bus_reg);</span>
 
 	par-&gt;state.vgabase = (void __iomem *) vga_res.start;
 
<span class="p_header">diff --git a/drivers/video/vt8623fb.c b/drivers/video/vt8623fb.c</span>
<span class="p_header">index 4e74d26..dfecf02 100644</span>
<span class="p_header">--- a/drivers/video/vt8623fb.c</span>
<span class="p_header">+++ b/drivers/video/vt8623fb.c</span>
<span class="p_chunk">@@ -727,7 +727,7 @@</span> <span class="p_context"> static int __devinit vt8623_pci_probe(struct pci_dev *dev, const struct pci_devi</span>
 
 	vga_res.flags = IORESOURCE_IO;
 
<span class="p_del">-	pcibios_bus_to_resource(dev, &amp;vga_res, &amp;bus_reg);</span>
<span class="p_add">+	pcibios_bus_to_resource(dev-&gt;bus, &amp;vga_res, &amp;bus_reg);</span>
 
 	par-&gt;state.vgabase = (void __iomem *) vga_res.start;
 
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 30d7be0..bb8cb69 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -16,8 +16,8 @@</span> <span class="p_context"></span>
 #include &quot;conf_space.h&quot;
 #include &quot;conf_space_quirks.h&quot;
 
<span class="p_del">-static bool permissive;</span>
<span class="p_del">-module_param(permissive, bool, 0644);</span>
<span class="p_add">+bool xen_pcibk_permissive;</span>
<span class="p_add">+module_param_named(permissive, xen_pcibk_permissive, bool, 0644);</span>
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
  * xen_pcibk_write_config_word, and xen_pcibk_write_config_byte are created. */
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)</span>
 		 * This means that some fields may still be read-only because
 		 * they have entries in the config_field list that intercept
 		 * the write and do nothing. */
<span class="p_del">-		if (dev_data-&gt;permissive || permissive) {</span>
<span class="p_add">+		if (dev_data-&gt;permissive || xen_pcibk_permissive) {</span>
 			switch (size) {
 			case 1:
 				err = pci_write_config_byte(dev, offset,
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.h b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">index e56c934..62461a8 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_chunk">@@ -64,6 +64,8 @@</span> <span class="p_context"> struct config_field_entry {</span>
 	void *data;
 };
 
<span class="p_add">+extern bool xen_pcibk_permissive;</span>
<span class="p_add">+</span>
 #define OFFSET(cfg_entry) ((cfg_entry)-&gt;base_offset+(cfg_entry)-&gt;field-&gt;offset)
 
 /* Add fields to a device - the add_fields macro expects to get a pointer to
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space_header.c b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">index 3daf862..1667a90 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_chunk">@@ -9,6 +9,10 @@</span> <span class="p_context"></span>
 #include &quot;pciback.h&quot;
 #include &quot;conf_space.h&quot;
 
<span class="p_add">+struct pci_cmd_info {</span>
<span class="p_add">+	u16 val;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct pci_bar_info {
 	u32 val;
 	u32 len_val;
<span class="p_chunk">@@ -18,22 +22,36 @@</span> <span class="p_context"> struct pci_bar_info {</span>
 #define is_enable_cmd(value) ((value)&amp;(PCI_COMMAND_MEMORY|PCI_COMMAND_IO))
 #define is_master_cmd(value) ((value)&amp;PCI_COMMAND_MASTER)
 
<span class="p_del">-static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)</span>
<span class="p_add">+/* Bits guests are allowed to control in permissive mode. */</span>
<span class="p_add">+#define PCI_COMMAND_GUEST (PCI_COMMAND_MASTER|PCI_COMMAND_SPECIAL| \</span>
<span class="p_add">+			   PCI_COMMAND_INVALIDATE|PCI_COMMAND_VGA_PALETTE| \</span>
<span class="p_add">+			   PCI_COMMAND_WAIT|PCI_COMMAND_FAST_BACK)</span>
<span class="p_add">+</span>
<span class="p_add">+static void *command_init(struct pci_dev *dev, int offset)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = xen_pcibk_read_config_word(dev, offset, value, data);</span>
<span class="p_del">-	if (!pci_is_enabled(dev))</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; PCI_ROM_RESOURCE; i++) {</span>
<span class="p_del">-		if (dev-&gt;resource[i].flags &amp; IORESOURCE_IO)</span>
<span class="p_del">-			*value |= PCI_COMMAND_IO;</span>
<span class="p_del">-		if (dev-&gt;resource[i].flags &amp; IORESOURCE_MEM)</span>
<span class="p_del">-			*value |= PCI_COMMAND_MEMORY;</span>
<span class="p_add">+	struct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cmd)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = pci_read_config_word(dev, PCI_COMMAND, &amp;cmd-&gt;val);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		kfree(cmd);</span>
<span class="p_add">+		return ERR_PTR(err);</span>
 	}
 
<span class="p_add">+	return cmd;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = pci_read_config_word(dev, offset, value);</span>
<span class="p_add">+	const struct pci_cmd_info *cmd = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	*value &amp;= PCI_COMMAND_GUEST;</span>
<span class="p_add">+	*value |= cmd-&gt;val &amp; ~PCI_COMMAND_GUEST;</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -41,6 +59,8 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 {
 	struct xen_pcibk_dev_data *dev_data;
 	int err;
<span class="p_add">+	u16 val;</span>
<span class="p_add">+	struct pci_cmd_info *cmd = data;</span>
 
 	dev_data = pci_get_drvdata(dev);
 	if (!pci_is_enabled(dev) &amp;&amp; is_enable_cmd(value)) {
<span class="p_chunk">@@ -83,6 +103,19 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 		}
 	}
 
<span class="p_add">+	cmd-&gt;val = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xen_pcibk_permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only allow the guest to control certain bits. */</span>
<span class="p_add">+	err = pci_read_config_word(dev, offset, &amp;val);</span>
<span class="p_add">+	if (err || val == value)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	value &amp;= PCI_COMMAND_GUEST;</span>
<span class="p_add">+	value |= val &amp; ~PCI_COMMAND_GUEST;</span>
<span class="p_add">+</span>
 	return pci_write_config_word(dev, offset, value);
 }
 
<span class="p_chunk">@@ -282,6 +315,8 @@</span> <span class="p_context"> static const struct config_field header_common[] = {</span>
 	{
 	 .offset    = PCI_COMMAND,
 	 .size      = 2,
<span class="p_add">+	 .init      = command_init,</span>
<span class="p_add">+	 .release   = bar_release,</span>
 	 .u.w.read  = command_read,
 	 .u.w.write = command_write,
 	},
<span class="p_header">diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">index aa9103f..ace3eea 100644</span>
<span class="p_header">--- a/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">+++ b/fs/autofs4/dev-ioctl.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)</span>
  */
 static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)
 {
<span class="p_del">-	struct autofs_dev_ioctl tmp;</span>
<span class="p_add">+	struct autofs_dev_ioctl tmp, *res;</span>
 
 	if (copy_from_user(&amp;tmp, in, sizeof(tmp)))
 		return ERR_PTR(-EFAULT);
<span class="p_chunk">@@ -103,7 +103,14 @@</span> <span class="p_context"> static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *i</span>
 	if (tmp.size &lt; sizeof(tmp))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	return memdup_user(in, tmp.size);</span>
<span class="p_add">+	if (tmp.size &gt; (PATH_MAX + sizeof(tmp)))</span>
<span class="p_add">+		return ERR_PTR(-ENAMETOOLONG);</span>
<span class="p_add">+</span>
<span class="p_add">+	res = memdup_user(in, tmp.size);</span>
<span class="p_add">+	if (!IS_ERR(res))</span>
<span class="p_add">+		res-&gt;size = tmp.size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline void free_dev_ioctl(struct autofs_dev_ioctl *param)
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 0898d99..f069765 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -1613,6 +1613,7 @@</span> <span class="p_context"> refind_writable:</span>
 			cifsFileInfo_put(inv_file);
 			spin_lock(&amp;cifs_file_list_lock);
 			++refind;
<span class="p_add">+			inv_file = NULL;</span>
 			goto refind_writable;
 		}
 	}
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 47d64e9..7b65755 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -238,10 +238,19 @@</span> <span class="p_context"> static int debugfs_show_options(struct seq_file *m, struct dentry *root)</span>
 	return 0;
 }
 
<span class="p_add">+static void debugfs_evict_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	truncate_inode_pages(&amp;inode-&gt;i_data, 0);</span>
<span class="p_add">+	end_writeback(inode);</span>
<span class="p_add">+	if (S_ISLNK(inode-&gt;i_mode))</span>
<span class="p_add">+		kfree(inode-&gt;i_private);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct super_operations debugfs_super_operations = {
 	.statfs		= simple_statfs,
 	.remount_fs	= debugfs_remount,
 	.show_options	= debugfs_show_options,
<span class="p_add">+	.evict_inode	= debugfs_evict_inode,</span>
 };
 
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
<span class="p_chunk">@@ -459,23 +468,14 @@</span> <span class="p_context"> static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)</span>
 	int ret = 0;
 
 	if (debugfs_positive(dentry)) {
<span class="p_del">-		if (dentry-&gt;d_inode) {</span>
<span class="p_del">-			dget(dentry);</span>
<span class="p_del">-			switch (dentry-&gt;d_inode-&gt;i_mode &amp; S_IFMT) {</span>
<span class="p_del">-			case S_IFDIR:</span>
<span class="p_del">-				ret = simple_rmdir(parent-&gt;d_inode, dentry);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case S_IFLNK:</span>
<span class="p_del">-				kfree(dentry-&gt;d_inode-&gt;i_private);</span>
<span class="p_del">-				/* fall through */</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				simple_unlink(parent-&gt;d_inode, dentry);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (!ret)</span>
<span class="p_del">-				d_delete(dentry);</span>
<span class="p_del">-			dput(dentry);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		dget(dentry);</span>
<span class="p_add">+		if (S_ISDIR(dentry-&gt;d_inode-&gt;i_mode))</span>
<span class="p_add">+			ret = simple_rmdir(parent-&gt;d_inode, dentry);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			simple_unlink(parent-&gt;d_inode, dentry);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			d_delete(dentry);</span>
<span class="p_add">+		dput(dentry);</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c</span>
<span class="p_header">index f04aa33..e33e0e4 100644</span>
<span class="p_header">--- a/fs/ecryptfs/file.c</span>
<span class="p_header">+++ b/fs/ecryptfs/file.c</span>
<span class="p_chunk">@@ -306,9 +306,22 @@</span> <span class="p_context"> ecryptfs_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 
 	if (ecryptfs_file_to_private(file))
 		lower_file = ecryptfs_file_to_lower(file);
<span class="p_del">-	if (lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;unlocked_ioctl)</span>
<span class="p_add">+	if (!(lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;unlocked_ioctl))</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FITRIM:</span>
<span class="p_add">+	case FS_IOC_GETFLAGS:</span>
<span class="p_add">+	case FS_IOC_SETFLAGS:</span>
<span class="p_add">+	case FS_IOC_GETVERSION:</span>
<span class="p_add">+	case FS_IOC_SETVERSION:</span>
 		rc = lower_file-&gt;f_op-&gt;unlocked_ioctl(lower_file, cmd, arg);
<span class="p_del">-	return rc;</span>
<span class="p_add">+		fsstack_copy_attr_all(file-&gt;f_path.dentry-&gt;d_inode,</span>
<span class="p_add">+				      lower_file-&gt;f_path.dentry-&gt;d_inode);</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_chunk">@@ -320,9 +333,22 @@</span> <span class="p_context"> ecryptfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 
 	if (ecryptfs_file_to_private(file))
 		lower_file = ecryptfs_file_to_lower(file);
<span class="p_del">-	if (lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;compat_ioctl)</span>
<span class="p_add">+	if (!(lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;compat_ioctl))</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FITRIM:</span>
<span class="p_add">+	case FS_IOC32_GETFLAGS:</span>
<span class="p_add">+	case FS_IOC32_SETFLAGS:</span>
<span class="p_add">+	case FS_IOC32_GETVERSION:</span>
<span class="p_add">+	case FS_IOC32_SETVERSION:</span>
 		rc = lower_file-&gt;f_op-&gt;compat_ioctl(lower_file, cmd, arg);
<span class="p_del">-	return rc;</span>
<span class="p_add">+		fsstack_copy_attr_all(file-&gt;f_path.dentry-&gt;d_inode,</span>
<span class="p_add">+				      lower_file-&gt;f_path.dentry-&gt;d_inode);</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	}</span>
 }
 #endif
 
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 5b9dfbe..91d238f 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1248,6 +1248,45 @@</span> <span class="p_context"> void install_exec_creds(struct linux_binprm *bprm)</span>
 }
 EXPORT_SYMBOL(install_exec_creds);
 
<span class="p_add">+static void bprm_fill_uid(struct linux_binprm *bprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+	unsigned int mode;</span>
<span class="p_add">+	uid_t uid;</span>
<span class="p_add">+	gid_t gid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_add">+	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_add">+	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span>
<span class="p_add">+	mode = ACCESS_ONCE(inode-&gt;i_mode);</span>
<span class="p_add">+	if (!(mode &amp; (S_ISUID|S_ISGID)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Be careful if suid/sgid is set */</span>
<span class="p_add">+	mutex_lock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reload atomically mode/uid/gid now that lock held */</span>
<span class="p_add">+	mode = inode-&gt;i_mode;</span>
<span class="p_add">+	uid = inode-&gt;i_uid;</span>
<span class="p_add">+	gid = inode-&gt;i_gid;</span>
<span class="p_add">+	mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mode &amp; S_ISUID) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;euid = uid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;egid = gid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * determine how safe it is to execute the proposed program
  * - the caller must hold -&gt;cred_guard_mutex to protect against
<span class="p_chunk">@@ -1297,36 +1336,12 @@</span> <span class="p_context"> static int check_unsafe_exec(struct linux_binprm *bprm)</span>
  */
 int prepare_binprm(struct linux_binprm *bprm)
 {
<span class="p_del">-	umode_t mode;</span>
<span class="p_del">-	struct inode * inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span>
 	int retval;
 
<span class="p_del">-	mode = inode-&gt;i_mode;</span>
 	if (bprm-&gt;file-&gt;f_op == NULL)
 		return -EACCES;
 
<span class="p_del">-	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_del">-	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_del">-	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)) {</span>
<span class="p_del">-		/* Set-uid? */</span>
<span class="p_del">-		if (mode &amp; S_ISUID) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;euid = inode-&gt;i_uid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Set-gid? */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If setgid is set but no group execute bit then this</span>
<span class="p_del">-		 * is a candidate for mandatory locking, not a setgid</span>
<span class="p_del">-		 * executable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;egid = inode-&gt;i_gid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	bprm_fill_uid(bprm);</span>
 
 	/* fill in binprm security blob */
 	retval = security_bprm_set_creds(bprm);
<span class="p_header">diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c</span>
<span class="p_header">index f4246cf..0949b83 100644</span>
<span class="p_header">--- a/fs/fuse/dev.c</span>
<span class="p_header">+++ b/fs/fuse/dev.c</span>
<span class="p_chunk">@@ -717,8 +717,8 @@</span> <span class="p_context"> static int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)</span>
 
 	newpage = buf-&gt;page;
 
<span class="p_del">-	if (WARN_ON(!PageUptodate(newpage)))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+	if (!PageUptodate(newpage))</span>
<span class="p_add">+		SetPageUptodate(newpage);</span>
 
 	ClearPageMappedToDisk(newpage);
 
<span class="p_chunk">@@ -1634,6 +1634,9 @@</span> <span class="p_context"> copy_finish:</span>
 static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,
 		       unsigned int size, struct fuse_copy_state *cs)
 {
<span class="p_add">+	/* Don&#39;t try to move pages (yet) */</span>
<span class="p_add">+	cs-&gt;move_pages = 0;</span>
<span class="p_add">+</span>
 	switch (code) {
 	case FUSE_NOTIFY_POLL:
 		return fuse_notify_poll(fc, size, cs);
<span class="p_header">diff --git a/fs/hfsplus/brec.c b/fs/hfsplus/brec.c</span>
<span class="p_header">index 2a734cf..7429c40 100644</span>
<span class="p_header">--- a/fs/hfsplus/brec.c</span>
<span class="p_header">+++ b/fs/hfsplus/brec.c</span>
<span class="p_chunk">@@ -130,13 +130,16 @@</span> <span class="p_context"> skip:</span>
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
<span class="p_del">-	if (new_node) {</span>
<span class="p_del">-		/* update parent key if we inserted a key</span>
<span class="p_del">-		 * at the start of the first node</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!rec &amp;&amp; new_node != node)</span>
<span class="p_del">-			hfs_brec_update_parent(fd);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * update parent key if we inserted a key</span>
<span class="p_add">+	 * at the start of the node and it is not the new node</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!rec &amp;&amp; new_node != node) {</span>
<span class="p_add">+		hfs_bnode_read_key(node, fd-&gt;search_key, data_off + size);</span>
<span class="p_add">+		hfs_brec_update_parent(fd);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (new_node) {</span>
 		hfs_bnode_put(fd-&gt;bnode);
 		if (!new_node-&gt;parent) {
 			hfs_btree_inc_height(tree);
<span class="p_chunk">@@ -166,9 +169,6 @@</span> <span class="p_context"> skip:</span>
 		goto again;
 	}
 
<span class="p_del">-	if (!rec)</span>
<span class="p_del">-		hfs_brec_update_parent(fd);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -368,6 +368,8 @@</span> <span class="p_context"> again:</span>
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
<span class="p_add">+	if (fd-&gt;record &lt; 0)</span>
<span class="p_add">+		return -ENOENT;</span>
 	hfs_bnode_dump(parent);
 	rec = fd-&gt;record;
 
<span class="p_header">diff --git a/fs/jffs2/scan.c b/fs/jffs2/scan.c</span>
<span class="p_header">index 7654e87..9ad5ba4 100644</span>
<span class="p_header">--- a/fs/jffs2/scan.c</span>
<span class="p_header">+++ b/fs/jffs2/scan.c</span>
<span class="p_chunk">@@ -510,6 +510,10 @@</span> <span class="p_context"> static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo</span>
 				sumlen = c-&gt;sector_size - je32_to_cpu(sm-&gt;offset);
 				sumptr = buf + buf_size - sumlen;
 
<span class="p_add">+				/* sm-&gt;offset maybe wrong but MAGIC maybe right */</span>
<span class="p_add">+				if (sumlen &gt; c-&gt;sector_size)</span>
<span class="p_add">+					goto full_scan;</span>
<span class="p_add">+</span>
 				/* Now, make sure the summary itself is available */
 				if (sumlen &gt; buf_size) {
 					/* Need to kmalloc for this. */
<span class="p_chunk">@@ -544,6 +548,7 @@</span> <span class="p_context"> static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo</span>
 		}
 	}
 
<span class="p_add">+full_scan:</span>
 	buf_ofs = jeb-&gt;offset;
 
 	if (!buf_size) {
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 5974fb5..bdcd705 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -579,7 +579,8 @@</span> <span class="p_context"> static __always_inline int __vfs_follow_link(struct nameidata *nd, const char *l</span>
 		goto fail;
 
 	if (*link == &#39;/&#39;) {
<span class="p_del">-		set_root(nd);</span>
<span class="p_add">+		if (!nd-&gt;root.mnt)</span>
<span class="p_add">+			set_root(nd);</span>
 		path_put(&amp;nd-&gt;path);
 		nd-&gt;path = nd-&gt;root;
 		path_get(&amp;nd-&gt;root);
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index 27c2969..3abfd5a 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -463,8 +463,10 @@</span> <span class="p_context"> static __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,</span>
 
 		for (i = 0; i &lt; args-&gt;csa_nrclists; i++) {
 			status = decode_rc_list(xdr, &amp;args-&gt;csa_rclists[i]);
<span class="p_del">-			if (status)</span>
<span class="p_add">+			if (status) {</span>
<span class="p_add">+				args-&gt;csa_nrclists = i;</span>
 				goto out_free;
<span class="p_add">+			}</span>
 		}
 	}
 	status = 0;
<span class="p_header">diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c</span>
<span class="p_header">index 16d16e5..62261de 100644</span>
<span class="p_header">--- a/fs/nfs/delegation.c</span>
<span class="p_header">+++ b/fs/nfs/delegation.c</span>
<span class="p_chunk">@@ -148,8 +148,8 @@</span> <span class="p_context"> void nfs_inode_reclaim_delegation(struct inode *inode, struct rpc_cred *cred,</span>
 				  &amp;delegation-&gt;flags);
 			NFS_I(inode)-&gt;delegation_state = delegation-&gt;type;
 			spin_unlock(&amp;delegation-&gt;lock);
<span class="p_del">-			put_rpccred(oldcred);</span>
 			rcu_read_unlock();
<span class="p_add">+			put_rpccred(oldcred);</span>
 		} else {
 			/* We appear to have raced with a delegation return. */
 			spin_unlock(&amp;delegation-&gt;lock);
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index b2e3ff3..ecdbae1 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"></span>
 #include &quot;alloc.h&quot;
 #include &quot;dat.h&quot;
 
<span class="p_add">+static void __nilfs_btree_init(struct nilfs_bmap *bmap);</span>
<span class="p_add">+</span>
 static struct nilfs_btree_path *nilfs_btree_alloc_path(void)
 {
 	struct nilfs_btree_path *path;
<span class="p_chunk">@@ -368,6 +370,34 @@</span> <span class="p_context"> static int nilfs_btree_node_broken(const struct nilfs_btree_node *node,</span>
 	return ret;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * nilfs_btree_root_broken - verify consistency of btree root node</span>
<span class="p_add">+ * @node: btree root node to be examined</span>
<span class="p_add">+ * @ino: inode number</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return Value: If node is broken, 1 is returned. Otherwise, 0 is returned.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
<span class="p_add">+				   unsigned long ino)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int level, flags, nchildren;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	level = nilfs_btree_node_get_level(node);</span>
<span class="p_add">+	flags = nilfs_btree_node_get_flags(node);</span>
<span class="p_add">+	nchildren = nilfs_btree_node_get_nchildren(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||</span>
<span class="p_add">+		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     nchildren &lt; 0 ||</span>
<span class="p_add">+		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {</span>
<span class="p_add">+		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,</span>
<span class="p_add">+			ino, level, flags, nchildren);</span>
<span class="p_add">+		ret = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int nilfs_btree_broken_node_block(struct buffer_head *bh)
 {
 	int ret;
<span class="p_chunk">@@ -1713,7 +1743,7 @@</span> <span class="p_context"> nilfs_btree_commit_convert_and_insert(struct nilfs_bmap *btree,</span>
 
 	/* convert and insert */
 	dat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;
<span class="p_del">-	nilfs_btree_init(btree);</span>
<span class="p_add">+	__nilfs_btree_init(btree);</span>
 	if (nreq != NULL) {
 		nilfs_bmap_commit_alloc_ptr(btree, dreq, dat);
 		nilfs_bmap_commit_alloc_ptr(btree, nreq, dat);
<span class="p_chunk">@@ -2294,12 +2324,23 @@</span> <span class="p_context"> static const struct nilfs_bmap_operations nilfs_btree_ops_gc = {</span>
 	.bop_gather_data	=	NULL,
 };
 
<span class="p_del">-int nilfs_btree_init(struct nilfs_bmap *bmap)</span>
<span class="p_add">+static void __nilfs_btree_init(struct nilfs_bmap *bmap)</span>
 {
 	bmap-&gt;b_ops = &amp;nilfs_btree_ops;
 	bmap-&gt;b_nchildren_per_block =
 		NILFS_BTREE_NODE_NCHILDREN_MAX(nilfs_btree_node_size(bmap));
<span class="p_del">-	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int nilfs_btree_init(struct nilfs_bmap *bmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	__nilfs_btree_init(bmap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nilfs_btree_root_broken(nilfs_btree_get_root(bmap),</span>
<span class="p_add">+				    bmap-&gt;b_inode-&gt;i_ino))</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+	return ret;</span>
 }
 
 void nilfs_btree_init_gc(struct nilfs_bmap *bmap)
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 8021098..dc79934 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -2387,10 +2387,14 @@</span> <span class="p_context"> out_dio:</span>
 	/* buffered aio wouldn&#39;t have proper lock coverage today */
 	BUG_ON(ret == -EIOCBQUEUED &amp;&amp; !(file-&gt;f_flags &amp; O_DIRECT));
 
<span class="p_add">+	if (unlikely(written &lt;= 0))</span>
<span class="p_add">+		goto no_sync;</span>
<span class="p_add">+</span>
 	if (((file-&gt;f_flags &amp; O_DSYNC) &amp;&amp; !direct_io) || IS_SYNC(inode) ||
 	    ((file-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !direct_io)) {
<span class="p_del">-		ret = filemap_fdatawrite_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-					       *ppos + count - 1);</span>
<span class="p_add">+		ret = filemap_fdatawrite_range(file-&gt;f_mapping,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - written,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - 1);</span>
 		if (ret &lt; 0)
 			written = ret;
 
<span class="p_chunk">@@ -2403,10 +2407,12 @@</span> <span class="p_context"> out_dio:</span>
 		}
 
 		if (!ret)
<span class="p_del">-			ret = filemap_fdatawait_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-						      *ppos + count - 1);</span>
<span class="p_add">+			ret = filemap_fdatawait_range(file-&gt;f_mapping,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - written,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - 1);</span>
 	}
 
<span class="p_add">+no_sync:</span>
 	/*
 	 * deep in g_f_a_w_n()-&gt;ocfs2_direct_IO we pass in a ocfs2_dio_end_io
 	 * function pointer which is called when o_direct io completes so that
<span class="p_chunk">@@ -2468,9 +2474,7 @@</span> <span class="p_context"> static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,</span>
 	struct address_space *mapping = out-&gt;f_mapping;
 	struct inode *inode = mapping-&gt;host;
 	struct splice_desc sd = {
<span class="p_del">-		.total_len = len,</span>
 		.flags = flags,
<span class="p_del">-		.pos = *ppos,</span>
 		.u.file = out,
 	};
 
<span class="p_chunk">@@ -2480,6 +2484,12 @@</span> <span class="p_context"> static ssize_t ocfs2_file_splice_write(struct pipe_inode_info *pipe,</span>
 			out-&gt;f_path.dentry-&gt;d_name.len,
 			out-&gt;f_path.dentry-&gt;d_name.name, len);
 
<span class="p_add">+	ret = generic_write_checks(out, ppos, &amp;len, 0);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	sd.total_len = len;</span>
<span class="p_add">+	sd.pos = *ppos;</span>
<span class="p_add">+</span>
 	if (pipe-&gt;inode)
 		mutex_lock_nested(&amp;pipe-&gt;inode-&gt;i_mutex, I_MUTEX_PARENT);
 
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index bed6a3c..67c5210 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -991,13 +991,17 @@</span> <span class="p_context"> generic_file_splice_write(struct pipe_inode_info *pipe, struct file *out,</span>
 	struct address_space *mapping = out-&gt;f_mapping;
 	struct inode *inode = mapping-&gt;host;
 	struct splice_desc sd = {
<span class="p_del">-		.total_len = len,</span>
 		.flags = flags,
<span class="p_del">-		.pos = *ppos,</span>
 		.u.file = out,
 	};
 	ssize_t ret;
 
<span class="p_add">+	ret = generic_write_checks(out, ppos, &amp;len, S_ISBLK(inode-&gt;i_mode));</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	sd.total_len = len;</span>
<span class="p_add">+	sd.pos = *ppos;</span>
<span class="p_add">+</span>
 	pipe_lock(pipe);
 
 	splice_from_pipe_begin(&amp;sd);
<span class="p_header">diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h</span>
<span class="p_header">index 4053cbd..ddce23d 100644</span>
<span class="p_header">--- a/include/linux/blk_types.h</span>
<span class="p_header">+++ b/include/linux/blk_types.h</span>
<span class="p_chunk">@@ -144,7 +144,9 @@</span> <span class="p_context"> enum rq_flag_bits {</span>
 	__REQ_ELVPRIV,		/* elevator private data attached */
 	__REQ_FAILED,		/* set if the request failed */
 	__REQ_QUIET,		/* don&#39;t worry about errors */
<span class="p_del">-	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests */</span>
<span class="p_add">+	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests and also</span>
<span class="p_add">+				   for requests for which the SCSI &quot;quiesce&quot;</span>
<span class="p_add">+				   state must be ignored. */</span>
 	__REQ_ALLOCED,		/* request came from our alloc pool */
 	__REQ_COPY_USER,	/* contains copies of user pages */
 	__REQ_FLUSH_SEQ,	/* request for flush sequence */
<span class="p_header">diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h</span>
<span class="p_header">index a6dfe69..fac26cb 100644</span>
<span class="p_header">--- a/include/linux/fsnotify.h</span>
<span class="p_header">+++ b/include/linux/fsnotify.h</span>
<span class="p_chunk">@@ -101,8 +101,10 @@</span> <span class="p_context"> static inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,</span>
 		new_dir_mask |= FS_ISDIR;
 	}
 
<span class="p_del">-	fsnotify(old_dir, old_dir_mask, old_dir, FSNOTIFY_EVENT_INODE, old_name, fs_cookie);</span>
<span class="p_del">-	fsnotify(new_dir, new_dir_mask, new_dir, FSNOTIFY_EVENT_INODE, new_name, fs_cookie);</span>
<span class="p_add">+	fsnotify(old_dir, old_dir_mask, source, FSNOTIFY_EVENT_INODE, old_name,</span>
<span class="p_add">+		 fs_cookie);</span>
<span class="p_add">+	fsnotify(new_dir, new_dir_mask, source, FSNOTIFY_EVENT_INODE, new_name,</span>
<span class="p_add">+		 fs_cookie);</span>
 
 	if (target)
 		fsnotify_link_count(target);
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index e444f5b..469c953 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -648,9 +648,9 @@</span> <span class="p_context"> void pci_fixup_cardbus(struct pci_bus *);</span>
 
 /* Generic PCI functions used internally */
 
<span class="p_del">-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,</span>
<span class="p_add">+void pcibios_resource_to_bus(struct pci_bus *bus, struct pci_bus_region *region,</span>
 			     struct resource *res);
<span class="p_del">-void pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,</span>
<span class="p_add">+void pcibios_bus_to_resource(struct pci_bus *bus, struct resource *res,</span>
 			     struct pci_bus_region *region);
 void pcibios_scan_specific_bus(int busn);
 extern struct pci_bus *pci_find_bus(int domain, int busnr);
<span class="p_header">diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h</span>
<span class="p_header">index 815cc4b..feb77716 100644</span>
<span class="p_header">--- a/include/linux/usb/hcd.h</span>
<span class="p_header">+++ b/include/linux/usb/hcd.h</span>
<span class="p_chunk">@@ -126,6 +126,7 @@</span> <span class="p_context"> struct usb_hcd {</span>
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
<span class="p_add">+	unsigned		cant_recv_wakeups:1;</span>
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
<span class="p_chunk">@@ -399,6 +400,7 @@</span> <span class="p_context"> extern const struct dev_pm_ops usb_hcd_pci_pm_ops;</span>
 #endif /* CONFIG_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
<span class="p_add">+void usb_init_pool_max(void);</span>
 int hcd_buffer_create(struct usb_hcd *hcd);
 void hcd_buffer_destroy(struct usb_hcd *hcd);
 
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">index 67b847d..d1342c2 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_chunk">@@ -2598,7 +2598,7 @@</span> <span class="p_context"> static int kdb_summary(int argc, const char **argv)</span>
 #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
 	kdb_printf(&quot;\nMemTotal:       %8lu kB\nMemFree:        %8lu kB\n&quot;
 		   &quot;Buffers:        %8lu kB\n&quot;,
<span class="p_del">-		   val.totalram, val.freeram, val.bufferram);</span>
<span class="p_add">+		   K(val.totalram), K(val.freeram), K(val.bufferram));</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 0466297..461b6e0 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3877,6 +3877,13 @@</span> <span class="p_context"> static void perf_pending_event(struct irq_work *entry)</span>
 {
 	struct perf_event *event = container_of(entry,
 			struct perf_event, pending);
<span class="p_add">+	int rctx;</span>
<span class="p_add">+</span>
<span class="p_add">+	rctx = perf_swevent_get_recursion_context();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we &#39;fail&#39; here, that&#39;s OK, it means recursion is already disabled</span>
<span class="p_add">+	 * and we won&#39;t recurse &#39;further&#39;.</span>
<span class="p_add">+	 */</span>
 
 	if (event-&gt;pending_disable) {
 		event-&gt;pending_disable = 0;
<span class="p_chunk">@@ -3887,6 +3894,9 @@</span> <span class="p_context"> static void perf_pending_event(struct irq_work *entry)</span>
 		event-&gt;pending_wakeup = 0;
 		perf_event_wakeup(event);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (rctx &gt;= 0)</span>
<span class="p_add">+		perf_swevent_put_recursion_context(rctx);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/printk.c b/kernel/printk.c</span>
<span class="p_header">index 544c021..cb72d9c 100644</span>
<span class="p_header">--- a/kernel/printk.c</span>
<span class="p_header">+++ b/kernel/printk.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static struct console *exclusive_console;</span>
  */
 struct console_cmdline
 {
<span class="p_del">-	char	name[8];			/* Name of the driver	    */</span>
<span class="p_add">+	char	name[16];			/* Name of the driver	    */</span>
 	int	index;				/* Minor dev. to use	    */
 	char	*options;			/* Options for the driver   */
 #ifdef CONFIG_A11Y_BRAILLE_CONSOLE
<span class="p_chunk">@@ -1498,6 +1498,7 @@</span> <span class="p_context"> void register_console(struct console *newcon)</span>
 	 */
 	for (i = 0; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[0];
 			i++) {
<span class="p_add">+		BUILD_BUG_ON(sizeof(console_cmdline[i].name) != sizeof(newcon-&gt;name));</span>
 		if (strcmp(console_cmdline[i].name, newcon-&gt;name) != 0)
 			continue;
 		if (newcon-&gt;index &gt;= 0 &amp;&amp;
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 5701cb9..2f8363e 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -4031,10 +4031,13 @@</span> <span class="p_context"> void rt_mutex_setprio(struct task_struct *p, int prio)</span>
 	if (running)
 		p-&gt;sched_class-&gt;put_prev_task(rq, p);
 
<span class="p_del">-	if (rt_prio(prio))</span>
<span class="p_add">+	if (rt_prio(prio)) {</span>
 		p-&gt;sched_class = &amp;rt_sched_class;
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (rt_prio(oldprio))</span>
<span class="p_add">+			p-&gt;rt.timeout = 0;</span>
 		p-&gt;sched_class = &amp;fair_sched_class;
<span class="p_add">+	}</span>
 
 	p-&gt;prio = prio;
 
<span class="p_header">diff --git a/kernel/softirq.c b/kernel/softirq.c</span>
<span class="p_header">index 671f959..5cc401e 100644</span>
<span class="p_header">--- a/kernel/softirq.c</span>
<span class="p_header">+++ b/kernel/softirq.c</span>
<span class="p_chunk">@@ -194,22 +194,28 @@</span> <span class="p_context"> void local_bh_enable_ip(unsigned long ip)</span>
 EXPORT_SYMBOL(local_bh_enable_ip);
 
 /*
<span class="p_del">- * We restart softirq processing MAX_SOFTIRQ_RESTART times,</span>
<span class="p_del">- * and we fall back to softirqd after that.</span>
<span class="p_add">+ * We restart softirq processing for at most MAX_SOFTIRQ_RESTART times,</span>
<span class="p_add">+ * but break the loop if need_resched() is set or after 2 ms.</span>
<span class="p_add">+ * The MAX_SOFTIRQ_TIME provides a nice upper bound in most cases, but in</span>
<span class="p_add">+ * certain cases, such as stop_machine(), jiffies may cease to</span>
<span class="p_add">+ * increment and so we need the MAX_SOFTIRQ_RESTART limit as</span>
<span class="p_add">+ * well to make sure we eventually return from this method.</span>
  *
<span class="p_del">- * This number has been established via experimentation.</span>
<span class="p_add">+ * These limits have been established via experimentation. </span>
  * The two things to balance is latency against fairness -
  * we want to handle softirqs as soon as possible, but they
  * should not be able to lock up the box.
  */
<span class="p_add">+#define MAX_SOFTIRQ_TIME  msecs_to_jiffies(2)</span>
 #define MAX_SOFTIRQ_RESTART 10
 
 asmlinkage void __do_softirq(void)
 {
 	struct softirq_action *h;
 	__u32 pending;
<span class="p_del">-	int max_restart = MAX_SOFTIRQ_RESTART;</span>
<span class="p_add">+	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;</span>
 	int cpu;
<span class="p_add">+	int max_restart = MAX_SOFTIRQ_RESTART;</span>
 
 	pending = local_softirq_pending();
 	account_system_vtime(current);
<span class="p_chunk">@@ -255,11 +261,13 @@</span> <span class="p_context"> restart:</span>
 	local_irq_disable();
 
 	pending = local_softirq_pending();
<span class="p_del">-	if (pending &amp;&amp; --max_restart)</span>
<span class="p_del">-		goto restart;</span>
<span class="p_add">+	if (pending) {</span>
<span class="p_add">+		if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;</span>
<span class="p_add">+		    --max_restart)</span>
<span class="p_add">+			goto restart;</span>
 
<span class="p_del">-	if (pending)</span>
 		wakeup_softirqd();
<span class="p_add">+	}</span>
 
 	lockdep_softirq_exit();
 
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 5b6bd45..ffea326 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -1014,6 +1014,12 @@</span> <span class="p_context"> ftrace_filter_lseek(struct file *file, loff_t offset, int whence)</span>
 	return ret;
 }
 
<span class="p_add">+#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="p_add">+static int ftrace_graph_active;</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define ftrace_graph_active 0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #ifdef CONFIG_DYNAMIC_FTRACE
 
 #ifndef CONFIG_FTRACE_MCOUNT_RECORD
<span class="p_chunk">@@ -2056,24 +2062,36 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 
 static void ftrace_startup_sysctl(void)
 {
<span class="p_add">+	int command;</span>
<span class="p_add">+</span>
 	if (unlikely(ftrace_disabled))
 		return;
 
 	/* Force update next time */
 	saved_ftrace_func = NULL;
 	/* ftrace_start_up is true if we want ftrace running */
<span class="p_del">-	if (ftrace_start_up)</span>
<span class="p_del">-		ftrace_run_update_code(FTRACE_UPDATE_CALLS);</span>
<span class="p_add">+	if (ftrace_start_up) {</span>
<span class="p_add">+		command = FTRACE_UPDATE_CALLS;</span>
<span class="p_add">+		if (ftrace_graph_active)</span>
<span class="p_add">+			command |= FTRACE_START_FUNC_RET;</span>
<span class="p_add">+		ftrace_startup_enable(command);</span>
<span class="p_add">+	}</span>
 }
 
 static void ftrace_shutdown_sysctl(void)
 {
<span class="p_add">+	int command;</span>
<span class="p_add">+</span>
 	if (unlikely(ftrace_disabled))
 		return;
 
 	/* ftrace_start_up is true if ftrace is running */
<span class="p_del">-	if (ftrace_start_up)</span>
<span class="p_del">-		ftrace_run_update_code(FTRACE_DISABLE_CALLS);</span>
<span class="p_add">+	if (ftrace_start_up) {</span>
<span class="p_add">+		command = FTRACE_DISABLE_CALLS;</span>
<span class="p_add">+		if (ftrace_graph_active)</span>
<span class="p_add">+			command |= FTRACE_STOP_FUNC_RET;</span>
<span class="p_add">+		ftrace_run_update_code(command);</span>
<span class="p_add">+	}</span>
 }
 
 static cycle_t		ftrace_update_time;
<span class="p_chunk">@@ -4445,12 +4463,12 @@</span> <span class="p_context"> ftrace_enable_sysctl(struct ctl_table *table, int write,</span>
 
 	if (ftrace_enabled) {
 
<span class="p_del">-		ftrace_startup_sysctl();</span>
<span class="p_del">-</span>
 		/* we are starting ftrace again */
 		if (ftrace_ops_list != &amp;ftrace_list_end)
 			update_ftrace_function();
 
<span class="p_add">+		ftrace_startup_sysctl();</span>
<span class="p_add">+</span>
 	} else {
 		/* stopping ftrace calls (just send to ftrace_stub) */
 		ftrace_trace_function = ftrace_stub;
<span class="p_chunk">@@ -4465,7 +4483,6 @@</span> <span class="p_context"> ftrace_enable_sysctl(struct ctl_table *table, int write,</span>
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 
<span class="p_del">-static int ftrace_graph_active;</span>
 static struct notifier_block ftrace_suspend_notifier;
 
 int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index efd6820..bc36e28 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2401,9 +2401,10 @@</span> <span class="p_context"> void __unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,</span>
 			continue;
 
 		/*
<span class="p_del">-		 * HWPoisoned hugepage is already unmapped and dropped reference</span>
<span class="p_add">+		 * Migrating hugepage or HWPoisoned hugepage is already</span>
<span class="p_add">+		 * unmapped and its refcount is dropped</span>
 		 */
<span class="p_del">-		if (unlikely(is_hugetlb_entry_hwpoisoned(pte)))</span>
<span class="p_add">+		if (unlikely(!pte_present(pte)))</span>
 			continue;
 
 		page = pte_page(pte);
<span class="p_chunk">@@ -2813,6 +2814,7 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	struct page *pagecache_page = NULL;
 	static DEFINE_MUTEX(hugetlb_instantiation_mutex);
 	struct hstate *h = hstate_vma(vma);
<span class="p_add">+	int need_wait_lock = 0;</span>
 
 	address &amp;= huge_page_mask(h);
 
<span class="p_chunk">@@ -2846,6 +2848,16 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	ret = 0;
 
 	/*
<span class="p_add">+	 * entry could be a migration/hwpoison entry at this point, so this</span>
<span class="p_add">+	 * check prevents the kernel from going below assuming that we have</span>
<span class="p_add">+	 * a active hugepage in pagecache. This goto expects the 2nd page fault,</span>
<span class="p_add">+	 * and is_hugetlb_entry_(migration|hwpoisoned) check will properly</span>
<span class="p_add">+	 * handle it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!pte_present(entry))</span>
<span class="p_add">+		goto out_mutex;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * If we are going to COW the mapping later, we examine the pending
 	 * reservations for this page now. This will ensure that any
 	 * allocations necessary to record that reservation occur outside the
<span class="p_chunk">@@ -2864,29 +2876,32 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 								vma, address);
 	}
 
<span class="p_add">+	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check for a racing update before calling hugetlb_cow */</span>
<span class="p_add">+	if (unlikely(!pte_same(entry, huge_ptep_get(ptep))))</span>
<span class="p_add">+		goto out_page_table_lock;</span>
<span class="p_add">+</span>
 	/*
 	 * hugetlb_cow() requires page locks of pte_page(entry) and
 	 * pagecache_page, so here we need take the former one
 	 * when page != pagecache_page or !pagecache_page.
<span class="p_del">-	 * Note that locking order is always pagecache_page -&gt; page,</span>
<span class="p_del">-	 * so no worry about deadlock.</span>
 	 */
 	page = pte_page(entry);
<span class="p_del">-	get_page(page);</span>
 	if (page != pagecache_page)
<span class="p_del">-		lock_page(page);</span>
<span class="p_add">+		if (!trylock_page(page)) {</span>
<span class="p_add">+			need_wait_lock = 1;</span>
<span class="p_add">+			goto out_page_table_lock;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-	/* Check for a racing update before calling hugetlb_cow */</span>
<span class="p_del">-	if (unlikely(!pte_same(entry, huge_ptep_get(ptep))))</span>
<span class="p_del">-		goto out_page_table_lock;</span>
<span class="p_add">+	get_page(page);</span>
 
 
 	if (flags &amp; FAULT_FLAG_WRITE) {
 		if (!pte_write(entry)) {
 			ret = hugetlb_cow(mm, vma, address, ptep, entry,
 							pagecache_page);
<span class="p_del">-			goto out_page_table_lock;</span>
<span class="p_add">+			goto out_put_page;</span>
 		}
 		entry = pte_mkdirty(entry);
 	}
<span class="p_chunk">@@ -2895,6 +2910,10 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 						flags &amp; FAULT_FLAG_WRITE))
 		update_mmu_cache(vma, address, ptep);
 
<span class="p_add">+out_put_page:</span>
<span class="p_add">+	if (page != pagecache_page)</span>
<span class="p_add">+		unlock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
 out_page_table_lock:
 	spin_unlock(&amp;mm-&gt;page_table_lock);
 
<span class="p_chunk">@@ -3034,7 +3053,22 @@</span> <span class="p_context"> void hugetlb_change_protection(struct vm_area_struct *vma,</span>
 			continue;
 		if (huge_pmd_unshare(mm, &amp;address, ptep))
 			continue;
<span class="p_del">-		if (!huge_pte_none(huge_ptep_get(ptep))) {</span>
<span class="p_add">+		pte = huge_ptep_get(ptep);</span>
<span class="p_add">+		if (unlikely(is_hugetlb_entry_hwpoisoned(pte)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (unlikely(is_hugetlb_entry_migration(pte))) {</span>
<span class="p_add">+			swp_entry_t entry = pte_to_swp_entry(pte);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (is_write_migration_entry(entry)) {</span>
<span class="p_add">+				pte_t newpte;</span>
<span class="p_add">+</span>
<span class="p_add">+				make_migration_entry_read(&amp;entry);</span>
<span class="p_add">+				newpte = swp_entry_to_pte(entry);</span>
<span class="p_add">+				set_huge_pte_at(mm, address, ptep, newpte);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!huge_pte_none(pte)) {</span>
 			pte = huge_ptep_get_and_clear(mm, address, ptep);
 			pte = pte_mkhuge(pte_modify(pte, newprot));
 			set_huge_pte_at(mm, address, ptep, pte);
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 45cd14f..02aef93 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3845,7 +3845,7 @@</span> <span class="p_context"> int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,</span>
 	if (follow_phys(vma, addr, write, &amp;prot, &amp;phys_addr))
 		return -EINVAL;
 
<span class="p_del">-	maddr = ioremap_prot(phys_addr, PAGE_SIZE, prot);</span>
<span class="p_add">+	maddr = ioremap_prot(phys_addr, PAGE_ALIGN(len + offset), prot);</span>
 	if (write)
 		memcpy_toio(maddr + offset, buf, len);
 	else
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 208e70f..cb6456d 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> struct percpu_counter vm_committed_as ____cacheline_aligned_in_smp;</span>
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
<span class="p_del">-	unsigned long free, allowed;</span>
<span class="p_add">+	long free, allowed;</span>
 
 	vm_acct_memory(pages);
 
<span class="p_header">diff --git a/mm/nommu.c b/mm/nommu.c</span>
<span class="p_header">index d3afb47..3f282f9 100644</span>
<span class="p_header">--- a/mm/nommu.c</span>
<span class="p_header">+++ b/mm/nommu.c</span>
<span class="p_chunk">@@ -1916,7 +1916,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(unmap_mapping_range);</span>
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
<span class="p_del">-	unsigned long free, allowed;</span>
<span class="p_add">+	long free, allowed;</span>
 
 	vm_acct_memory(pages);
 
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index 057884c..ecd1c4c 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -716,7 +716,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 * scale global setpoint to bdi&#39;s:
 	 *	bdi_setpoint = setpoint * bdi_thresh / thresh
 	 */
<span class="p_del">-	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh + 1);</span>
<span class="p_add">+	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh | 1);</span>
 	bdi_setpoint = setpoint * (u64)x &gt;&gt; 16;
 	/*
 	 * Use span=(8*write_bw) in single bdi case as indicated by
<span class="p_chunk">@@ -766,8 +766,11 @@</span> <span class="p_context"> static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,</span>
 	 *                   bw * elapsed + write_bandwidth * (period - elapsed)
 	 * write_bandwidth = ---------------------------------------------------
 	 *                                          period
<span class="p_add">+	 *</span>
<span class="p_add">+	 * @written may have decreased due to account_page_redirty().</span>
<span class="p_add">+	 * Avoid underflowing @bw calculation.</span>
 	 */
<span class="p_del">-	bw = written - bdi-&gt;written_stamp;</span>
<span class="p_add">+	bw = written - min(written, bdi-&gt;written_stamp);</span>
 	bw *= HZ;
 	if (unlikely(elapsed &gt; period)) {
 		do_div(bw, elapsed);
<span class="p_chunk">@@ -831,7 +834,7 @@</span> <span class="p_context"> static void global_update_bandwidth(unsigned long thresh,</span>
 				    unsigned long now)
 {
 	static DEFINE_SPINLOCK(dirty_lock);
<span class="p_del">-	static unsigned long update_time;</span>
<span class="p_add">+	static unsigned long update_time = INITIAL_JIFFIES;</span>
 
 	/*
 	 * check locklessly first to optimize away locking for the most time
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 54ac6e9..aff0637 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -1882,18 +1882,24 @@</span> <span class="p_context"> redo:</span>
 /* Unfreeze all the cpu partial slabs */
 static void unfreeze_partials(struct kmem_cache *s)
 {
<span class="p_del">-	struct kmem_cache_node *n = NULL;</span>
<span class="p_add">+	struct kmem_cache_node *n = NULL, *n2 = NULL;</span>
 	struct kmem_cache_cpu *c = this_cpu_ptr(s-&gt;cpu_slab);
 	struct page *page, *discard_page = NULL;
 
 	while ((page = c-&gt;partial)) {
<span class="p_del">-		enum slab_modes { M_PARTIAL, M_FREE };</span>
<span class="p_del">-		enum slab_modes l, m;</span>
 		struct page new;
 		struct page old;
 
 		c-&gt;partial = page-&gt;next;
<span class="p_del">-		l = M_FREE;</span>
<span class="p_add">+</span>
<span class="p_add">+		n2 = get_node(s, page_to_nid(page));</span>
<span class="p_add">+		if (n != n2) {</span>
<span class="p_add">+			if (n)</span>
<span class="p_add">+				spin_unlock(&amp;n-&gt;list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			n = n2;</span>
<span class="p_add">+			spin_lock(&amp;n-&gt;list_lock);</span>
<span class="p_add">+		}</span>
 
 		do {
 
<span class="p_chunk">@@ -1906,43 +1912,17 @@</span> <span class="p_context"> static void unfreeze_partials(struct kmem_cache *s)</span>
 
 			new.frozen = 0;
 
<span class="p_del">-			if (!new.inuse &amp;&amp; (!n || n-&gt;nr_partial &gt; s-&gt;min_partial))</span>
<span class="p_del">-				m = M_FREE;</span>
<span class="p_del">-			else {</span>
<span class="p_del">-				struct kmem_cache_node *n2 = get_node(s,</span>
<span class="p_del">-							page_to_nid(page));</span>
<span class="p_del">-</span>
<span class="p_del">-				m = M_PARTIAL;</span>
<span class="p_del">-				if (n != n2) {</span>
<span class="p_del">-					if (n)</span>
<span class="p_del">-						spin_unlock(&amp;n-&gt;list_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-					n = n2;</span>
<span class="p_del">-					spin_lock(&amp;n-&gt;list_lock);</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			if (l != m) {</span>
<span class="p_del">-				if (l == M_PARTIAL) {</span>
<span class="p_del">-					remove_partial(n, page);</span>
<span class="p_del">-					stat(s, FREE_REMOVE_PARTIAL);</span>
<span class="p_del">-				} else {</span>
<span class="p_del">-					add_partial(n, page,</span>
<span class="p_del">-						DEACTIVATE_TO_TAIL);</span>
<span class="p_del">-					stat(s, FREE_ADD_PARTIAL);</span>
<span class="p_del">-				}</span>
<span class="p_del">-</span>
<span class="p_del">-				l = m;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
 		} while (!cmpxchg_double_slab(s, page,
 				old.freelist, old.counters,
 				new.freelist, new.counters,
 				&quot;unfreezing slab&quot;));
 
<span class="p_del">-		if (m == M_FREE) {</span>
<span class="p_add">+		if (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt; s-&gt;min_partial)) {</span>
 			page-&gt;next = discard_page;
 			discard_page = page;
<span class="p_add">+		} else {</span>
<span class="p_add">+			add_partial(n, page, DEACTIVATE_TO_TAIL);</span>
<span class="p_add">+			stat(s, FREE_ADD_PARTIAL);</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/can/af_can.c b/net/can/af_can.c</span>
<span class="p_header">index 0ce2ad0..7d9dff222 100644</span>
<span class="p_header">--- a/net/can/af_can.c</span>
<span class="p_header">+++ b/net/can/af_can.c</span>
<span class="p_chunk">@@ -244,6 +244,9 @@</span> <span class="p_context"> int can_send(struct sk_buff *skb, int loop)</span>
 	}
 
 	skb-&gt;protocol = htons(ETH_P_CAN);
<span class="p_add">+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_reset_mac_header(skb);</span>
 	skb_reset_network_header(skb);
 	skb_reset_transport_header(skb);
 
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 3cd37e9..43c6dd8 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1144,14 +1144,10 @@</span> <span class="p_context"> static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {</span>
 };
 
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
<span class="p_del">-	[IFLA_VF_MAC]		= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_mac) },</span>
<span class="p_del">-	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_vlan) },</span>
<span class="p_del">-	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_tx_rate) },</span>
<span class="p_del">-	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_spoofchk) },</span>
<span class="p_add">+	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },</span>
<span class="p_add">+	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },</span>
<span class="p_add">+	[IFLA_VF_TX_RATE]	= { .len = sizeof(struct ifla_vf_tx_rate) },</span>
<span class="p_add">+	[IFLA_VF_SPOOFCHK]	= { .len = sizeof(struct ifla_vf_spoofchk) },</span>
 };
 
 static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
<span class="p_chunk">@@ -1698,10 +1694,10 @@</span> <span class="p_context"> static int rtnl_group_changelink(struct net *net, int group,</span>
 		struct ifinfomsg *ifm,
 		struct nlattr **tb)
 {
<span class="p_del">-	struct net_device *dev;</span>
<span class="p_add">+	struct net_device *dev, *aux;</span>
 	int err;
 
<span class="p_del">-	for_each_netdev(net, dev) {</span>
<span class="p_add">+	for_each_netdev_safe(net, dev, aux) {</span>
 		if (dev-&gt;group == group) {
 			err = do_setlink(dev, ifm, tb, NULL, 0);
 			if (err &lt; 0)
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index c8643a3..4cfba3d 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)</span>
 	u32 *p = NULL;
 
 	if (!(rt-&gt;dst.flags &amp; DST_HOST))
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		return dst_cow_metrics_generic(dst, old);</span>
 
 	if (!rt-&gt;rt6i_peer)
 		rt6_bind_peer(rt, 1);
<span class="p_header">diff --git a/net/irda/ircomm/ircomm_tty.c b/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_header">index 6b9d5a0..20fec0d 100644</span>
<span class="p_header">--- a/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_header">+++ b/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_chunk">@@ -843,7 +843,9 @@</span> <span class="p_context"> static void ircomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)</span>
 	orig_jiffies = jiffies;
 
 	/* Set poll time to 200 ms */
<span class="p_del">-	poll_time = IRDA_MIN(timeout, msecs_to_jiffies(200));</span>
<span class="p_add">+	poll_time = msecs_to_jiffies(200);</span>
<span class="p_add">+	if (timeout)</span>
<span class="p_add">+		poll_time = min_t(unsigned long, timeout, poll_time);</span>
 
 	spin_lock_irqsave(&amp;self-&gt;spinlock, flags);
 	while (self-&gt;tx_skb &amp;&amp; self-&gt;tx_skb-&gt;len) {
<span class="p_header">diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c</span>
<span class="p_header">index 64d3ce5..df2b6ac 100644</span>
<span class="p_header">--- a/net/mac80211/agg-rx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-rx.c</span>
<span class="p_chunk">@@ -49,8 +49,6 @@</span> <span class="p_context"> static void ieee80211_free_tid_rx(struct rcu_head *h)</span>
 		container_of(h, struct tid_ampdu_rx, rcu_head);
 	int i;
 
<span class="p_del">-	del_timer_sync(&amp;tid_rx-&gt;reorder_timer);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; tid_rx-&gt;buf_size; i++)
 		dev_kfree_skb(tid_rx-&gt;reorder_buf[i]);
 	kfree(tid_rx-&gt;reorder_buf);
<span class="p_chunk">@@ -94,6 +92,12 @@</span> <span class="p_context"> void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,</span>
 
 	del_timer_sync(&amp;tid_rx-&gt;session_timer);
 
<span class="p_add">+	/* make sure ieee80211_sta_reorder_release() doesn&#39;t re-arm the timer */</span>
<span class="p_add">+	spin_lock_bh(&amp;tid_rx-&gt;reorder_lock);</span>
<span class="p_add">+	tid_rx-&gt;removed = true;</span>
<span class="p_add">+	spin_unlock_bh(&amp;tid_rx-&gt;reorder_lock);</span>
<span class="p_add">+	del_timer_sync(&amp;tid_rx-&gt;reorder_timer);</span>
<span class="p_add">+</span>
 	call_rcu(&amp;tid_rx-&gt;rcu_head, ieee80211_free_tid_rx);
 }
 
<span class="p_header">diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h</span>
<span class="p_header">index 226be13..ca07c5e 100644</span>
<span class="p_header">--- a/net/mac80211/ieee80211_i.h</span>
<span class="p_header">+++ b/net/mac80211/ieee80211_i.h</span>
<span class="p_chunk">@@ -54,11 +54,25 @@</span> <span class="p_context"> struct ieee80211_local;</span>
 
 #define TU_TO_EXP_TIME(x)	(jiffies + usecs_to_jiffies((x) * 1024))
 
<span class="p_del">-#define IEEE80211_DEFAULT_UAPSD_QUEUES \</span>
<span class="p_del">-	(IEEE80211_WMM_IE_STA_QOSINFO_AC_BK |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Some APs experience problems when working with U-APSD. Decreasing the</span>
<span class="p_add">+ * probability of that happening by using legacy mode for all ACs but VO isn&#39;t</span>
<span class="p_add">+ * enough.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Cisco 4410N originally forced us to enable VO by default only because it</span>
<span class="p_add">+ * treated non-VO ACs as legacy.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * However some APs (notably Netgear R7000) silently reclassify packets to</span>
<span class="p_add">+ * different ACs. Since u-APSD ACs require trigger frames for frame retrieval</span>
<span class="p_add">+ * clients would never see some frames (e.g. ARP responses) or would fetch them</span>
<span class="p_add">+ * accidentally after a long time.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It makes little sense to enable u-APSD queues by default because it needs</span>
<span class="p_add">+ * userspace applications to be aware of it to actually take advantage of the</span>
<span class="p_add">+ * possible additional powersavings. Implicitly depending on driver autotrigger</span>
<span class="p_add">+ * frame support doesn&#39;t make much sense.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IEEE80211_DEFAULT_UAPSD_QUEUES 0</span>
 
 #define IEEE80211_DEFAULT_MAX_SP_LEN		\
 	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 24f2a41..6202d05 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -668,9 +668,10 @@</span> <span class="p_context"> static void ieee80211_sta_reorder_release(struct ieee80211_hw *hw,</span>
 
  set_release_timer:
 
<span class="p_del">-		mod_timer(&amp;tid_agg_rx-&gt;reorder_timer,</span>
<span class="p_del">-			  tid_agg_rx-&gt;reorder_time[j] + 1 +</span>
<span class="p_del">-			  HT_RX_REORDER_BUF_TIMEOUT);</span>
<span class="p_add">+		if (!tid_agg_rx-&gt;removed)</span>
<span class="p_add">+			mod_timer(&amp;tid_agg_rx-&gt;reorder_timer,</span>
<span class="p_add">+				  tid_agg_rx-&gt;reorder_time[j] + 1 +</span>
<span class="p_add">+				  HT_RX_REORDER_BUF_TIMEOUT);</span>
 	} else {
 		del_timer(&amp;tid_agg_rx-&gt;reorder_timer);
 	}
<span class="p_chunk">@@ -1926,6 +1927,9 @@</span> <span class="p_context"> ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)</span>
 	hdr = (struct ieee80211_hdr *) skb-&gt;data;
 	mesh_hdr = (struct ieee80211s_hdr *) (skb-&gt;data + hdrlen);
 
<span class="p_add">+	if (ieee80211_drop_unencrypted(rx, hdr-&gt;frame_control))</span>
<span class="p_add">+		return RX_DROP_MONITOR;</span>
<span class="p_add">+</span>
 	/* frame is in RMC, don&#39;t forward */
 	if (ieee80211_is_data(hdr-&gt;frame_control) &amp;&amp;
 	    is_multicast_ether_addr(hdr-&gt;addr1) &amp;&amp;
<span class="p_header">diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h</span>
<span class="p_header">index 249f4d0..4e6ece8 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.h</span>
<span class="p_header">+++ b/net/mac80211/sta_info.h</span>
<span class="p_chunk">@@ -106,6 +106,7 @@</span> <span class="p_context"> enum ieee80211_sta_info_flags {</span>
  * @buf_size: reorder buffer size at receiver
  * @failed_bar_ssn: ssn of the last failed BAR tx attempt
  * @bar_pending: BAR needs to be re-sent
<span class="p_add">+ * @removed: this session is removed (but might have been found due to RCU)</span>
  *
  * This structure&#39;s lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
<span class="p_chunk">@@ -169,6 +170,7 @@</span> <span class="p_context"> struct tid_ampdu_rx {</span>
 	u16 buf_size;
 	u16 timeout;
 	u8 dialog_token;
<span class="p_add">+	bool removed;</span>
 };
 
 /**
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index b7fc3dd..f4f24be 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -544,9 +544,11 @@</span> <span class="p_context"> ieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)</span>
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx-&gt;skb);
 
<span class="p_del">-	if (unlikely(tx-&gt;sdata-&gt;control_port_protocol == tx-&gt;skb-&gt;protocol &amp;&amp;</span>
<span class="p_del">-		     tx-&gt;sdata-&gt;control_port_no_encrypt))</span>
<span class="p_del">-		info-&gt;flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;</span>
<span class="p_add">+	if (unlikely(tx-&gt;sdata-&gt;control_port_protocol == tx-&gt;skb-&gt;protocol)) {</span>
<span class="p_add">+		if (tx-&gt;sdata-&gt;control_port_no_encrypt)</span>
<span class="p_add">+			info-&gt;flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;</span>
<span class="p_add">+		info-&gt;flags |= IEEE80211_TX_CTL_USE_MINRATE;</span>
<span class="p_add">+	}</span>
 
 	return TX_CONTINUE;
 }
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ftp.c b/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_header">index e39f693..fe3c8d7 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_chunk">@@ -183,6 +183,8 @@</span> <span class="p_context"> static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 	struct nf_conn *ct;
 	struct net *net;
 
<span class="p_add">+	*diff = 0;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn&#39;t work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
<span class="p_chunk">@@ -191,8 +193,6 @@</span> <span class="p_context"> static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 		return 1;
 #endif
 
<span class="p_del">-	*diff = 0;</span>
<span class="p_del">-</span>
 	/* Only useful for established sessions */
 	if (cp-&gt;state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
<span class="p_chunk">@@ -318,6 +318,9 @@</span> <span class="p_context"> static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 	struct ip_vs_conn *n_cp;
 	struct net *net;
 
<span class="p_add">+	/* no diff required for incoming packets */</span>
<span class="p_add">+	*diff = 0;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn&#39;t work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
<span class="p_chunk">@@ -326,9 +329,6 @@</span> <span class="p_context"> static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 		return 1;
 #endif
 
<span class="p_del">-	/* no diff required for incoming packets */</span>
<span class="p_del">-	*diff = 0;</span>
<span class="p_del">-</span>
 	/* Only useful for established sessions */
 	if (cp-&gt;state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">index 8a0d6d6..6a5555c 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_chunk">@@ -763,6 +763,8 @@</span> <span class="p_context"> static void ip_vs_proc_conn(struct net *net, struct ip_vs_conn_param *param,</span>
 			IP_VS_DBG(2, &quot;BACKUP, add new conn. failed\n&quot;);
 			return;
 		}
<span class="p_add">+		if (!(flags &amp; IP_VS_CONN_F_TEMPLATE))</span>
<span class="p_add">+			kfree(param-&gt;pe_data);</span>
 	} else if (!cp-&gt;dest) {
 		dest = ip_vs_try_bind_dest(cp);
 		if (dest)
<span class="p_chunk">@@ -1064,6 +1066,7 @@</span> <span class="p_context"> static inline int ip_vs_proc_sync_conn(struct net *net, __u8 *p, __u8 *msg_end)</span>
 				(opt_flags &amp; IPVS_OPT_F_SEQ_DATA ? &amp;opt : NULL)
 				);
 #endif
<span class="p_add">+	ip_vs_pe_put(param.pe);</span>
 	return 0;
 	/* Error exit */
 out:
<span class="p_header">diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c</span>
<span class="p_header">index ce60cf0..9139a26 100644</span>
<span class="p_header">--- a/net/netfilter/nf_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nf_queue.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> int nf_queue(struct sk_buff *skb,</span>
 	 * returned by nf_queue.  For instance, callers rely on -ECANCELED to mean
 	 * &#39;ignore this hook&#39;.
 	 */
<span class="p_del">-	if (IS_ERR(segs))</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs))</span>
 		goto out_err;
 	queued = 0;
 	err = 0;
<span class="p_header">diff --git a/net/netfilter/xt_socket.c b/net/netfilter/xt_socket.c</span>
<span class="p_header">index 72bb07f..eb5086c 100644</span>
<span class="p_header">--- a/net/netfilter/xt_socket.c</span>
<span class="p_header">+++ b/net/netfilter/xt_socket.c</span>
<span class="p_chunk">@@ -205,12 +205,13 @@</span> <span class="p_context"> static int</span>
 extract_icmp6_fields(const struct sk_buff *skb,
 		     unsigned int outside_hdrlen,
 		     int *protocol,
<span class="p_del">-		     struct in6_addr **raddr,</span>
<span class="p_del">-		     struct in6_addr **laddr,</span>
<span class="p_add">+		     const struct in6_addr **raddr,</span>
<span class="p_add">+		     const struct in6_addr **laddr,</span>
 		     __be16 *rport,
<span class="p_del">-		     __be16 *lport)</span>
<span class="p_add">+		     __be16 *lport,</span>
<span class="p_add">+		     struct ipv6hdr *ipv6_var)</span>
 {
<span class="p_del">-	struct ipv6hdr *inside_iph, _inside_iph;</span>
<span class="p_add">+	const struct ipv6hdr *inside_iph;</span>
 	struct icmp6hdr *icmph, _icmph;
 	__be16 *ports, _ports[2];
 	u8 inside_nexthdr;
<span class="p_chunk">@@ -225,12 +226,14 @@</span> <span class="p_context"> extract_icmp6_fields(const struct sk_buff *skb,</span>
 	if (icmph-&gt;icmp6_type &amp; ICMPV6_INFOMSG_MASK)
 		return 1;
 
<span class="p_del">-	inside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph), sizeof(_inside_iph), &amp;_inside_iph);</span>
<span class="p_add">+	inside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph),</span>
<span class="p_add">+					sizeof(*ipv6_var), ipv6_var);</span>
 	if (inside_iph == NULL)
 		return 1;
 	inside_nexthdr = inside_iph-&gt;nexthdr;
 
<span class="p_del">-	inside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) + sizeof(_inside_iph),</span>
<span class="p_add">+	inside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) +</span>
<span class="p_add">+					      sizeof(*ipv6_var),</span>
 					 &amp;inside_nexthdr, &amp;inside_fragoff);
 	if (inside_hdrlen &lt; 0)
 		return 1; /* hjm: Packet has no/incomplete transport layer headers. */
<span class="p_chunk">@@ -258,10 +261,10 @@</span> <span class="p_context"> extract_icmp6_fields(const struct sk_buff *skb,</span>
 static bool
 socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
 {
<span class="p_del">-	struct ipv6hdr *iph = ipv6_hdr(skb);</span>
<span class="p_add">+	struct ipv6hdr ipv6_var, *iph = ipv6_hdr(skb);</span>
 	struct udphdr _hdr, *hp = NULL;
 	struct sock *sk;
<span class="p_del">-	struct in6_addr *daddr, *saddr;</span>
<span class="p_add">+	const struct in6_addr *daddr, *saddr;</span>
 	__be16 dport, sport;
 	int thoff, tproto;
 	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par-&gt;matchinfo;
<span class="p_chunk">@@ -285,7 +288,7 @@</span> <span class="p_context"> socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)</span>
 
 	} else if (tproto == IPPROTO_ICMPV6) {
 		if (extract_icmp6_fields(skb, thoff, &amp;tproto, &amp;saddr, &amp;daddr,
<span class="p_del">-					 &amp;sport, &amp;dport))</span>
<span class="p_add">+					 &amp;sport, &amp;dport, &amp;ipv6_var))</span>
 			return false;
 	} else {
 		return false;
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index e66341e..a92d635 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -269,8 +269,10 @@</span> <span class="p_context"> static int queue_gso_packets(int dp_ifindex, struct sk_buff *skb,</span>
 	int err;
 
 	segs = skb_gso_segment(skb, NETIF_F_SG | NETIF_F_HW_CSUM);
<span class="p_del">-	if (IS_ERR(skb))</span>
<span class="p_del">-		return PTR_ERR(skb);</span>
<span class="p_add">+	if (IS_ERR(segs))</span>
<span class="p_add">+		return PTR_ERR(segs);</span>
<span class="p_add">+	if (segs == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	/* Queue all of the segments. */
 	skb = segs;
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 76cb304..af4dd9e 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -911,7 +911,7 @@</span> <span class="p_context"> static unsigned int cache_poll(struct file *filp, poll_table *wait,</span>
 	poll_wait(filp, &amp;queue_wait, wait);
 
 	/* alway allow write */
<span class="p_del">-	mask = POLL_OUT | POLLWRNORM;</span>
<span class="p_add">+	mask = POLLOUT | POLLWRNORM;</span>
 
 	if (!rp)
 		return mask;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index 745973b..5547bd8 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	if (rc) {
 		dprintk(&quot;RPC:       %s: ib_query_device failed %d\n&quot;,
 			__func__, rc);
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 
 	if (devattr.device_cap_flags &amp; IB_DEVICE_LOCAL_DMA_LKEY) {
<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 		printk(KERN_ERR &quot;%s: invalid memory registration mode %d\n&quot;,
 				__func__, memreg);
 		rc = -EINVAL;
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 	dprintk(&quot;RPC:       %s: memory registration strategy is %d\n&quot;,
 		__func__, memreg);
<span class="p_chunk">@@ -596,6 +596,10 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	ia-&gt;ri_memreg_strategy = memreg;
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out3:</span>
<span class="p_add">+	ib_dealloc_pd(ia-&gt;ri_pd);</span>
<span class="p_add">+	ia-&gt;ri_pd = NULL;</span>
 out2:
 	rdma_destroy_id(ia-&gt;ri_id);
 	ia-&gt;ri_id = NULL;
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 63c1807..263cbd8 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -2810,6 +2810,14 @@</span> <span class="p_context"> static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)</span>
 	if (parse_station_flags(info, dev-&gt;ieee80211_ptr-&gt;iftype, &amp;params))
 		return -EINVAL;
 
<span class="p_add">+	/* HT requires QoS, but if we don&#39;t have that just ignore HT/VHT</span>
<span class="p_add">+	 * as userspace might just pass through the capabilities from the IEs</span>
<span class="p_add">+	 * directly, rather than enforcing this restriction and returning an</span>
<span class="p_add">+	 * error in this case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(params.sta_flags_set &amp; BIT(NL80211_STA_FLAG_WME)))</span>
<span class="p_add">+		params.ht_capa = NULL;</span>
<span class="p_add">+</span>
 	switch (dev-&gt;ieee80211_ptr-&gt;iftype) {
 	case NL80211_IFTYPE_AP:
 	case NL80211_IFTYPE_AP_VLAN:
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index 95a338c..11dd2fb 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -151,6 +151,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct sk_buff *skb)</span>
 	kfree_skb(skb);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
<span class="p_add">+	if (segs == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	do {
 		struct sk_buff *nskb = segs-&gt;next;
<span class="p_header">diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c</span>
<span class="p_header">index 0a9891e..3bf9045 100644</span>
<span class="p_header">--- a/security/selinux/selinuxfs.c</span>
<span class="p_header">+++ b/security/selinux/selinuxfs.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static ssize_t sel_write_enforce(struct file *file, const char __user *buf,</span>
 		goto out;
 
 	/* No partial writes. */
<span class="p_del">-	length = EINVAL;</span>
<span class="p_add">+	length = -EINVAL;</span>
 	if (*ppos != 0)
 		goto out;
 
<span class="p_header">diff --git a/security/smack/smack.h b/security/smack/smack.h</span>
<span class="p_header">index 4ede719..cde4cc1 100644</span>
<span class="p_header">--- a/security/smack/smack.h</span>
<span class="p_header">+++ b/security/smack/smack.h</span>
<span class="p_chunk">@@ -298,6 +298,16 @@</span> <span class="p_context"> static inline char *smk_of_current(void)</span>
 	return smk_of_task(current_security());
 }
 
<span class="p_add">+static inline char *smk_of_task_struct(const struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *skp;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	skp = smk_of_task(__task_cred(t)-&gt;security);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return skp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * logging functions
  */
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index 45c32f0..82df24d 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -41,8 +41,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/binfmts.h&gt;
 #include &quot;smack.h&quot;
 
<span class="p_del">-#define task_security(task)	(task_cred_xxx((task), security))</span>
<span class="p_del">-</span>
 #define TRANS_TRUE	&quot;TRUE&quot;
 #define TRANS_TRUE_SIZE	4
 
<span class="p_chunk">@@ -164,7 +162,7 @@</span> <span class="p_context"> static int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)</span>
 	if (rc != 0)
 		return rc;
 
<span class="p_del">-	tsp = smk_of_task(task_security(ctp));</span>
<span class="p_add">+	tsp = smk_of_task_struct(ctp);</span>
 	smk_ad_init(&amp;ad, __func__, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, ctp);
 
<span class="p_chunk">@@ -190,7 +188,7 @@</span> <span class="p_context"> static int smack_ptrace_traceme(struct task_struct *ptp)</span>
 	if (rc != 0)
 		return rc;
 
<span class="p_del">-	tsp = smk_of_task(task_security(ptp));</span>
<span class="p_add">+	tsp = smk_of_task_struct(ptp);</span>
 	smk_ad_init(&amp;ad, __func__, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, ptp);
 
<span class="p_chunk">@@ -1518,7 +1516,7 @@</span> <span class="p_context"> static int smk_curacc_on_task(struct task_struct *p, int access,</span>
 
 	smk_ad_init(&amp;ad, caller, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, p);
<span class="p_del">-	return smk_curacc(smk_of_task(task_security(p)), access, &amp;ad);</span>
<span class="p_add">+	return smk_curacc(smk_of_task_struct(p), access, &amp;ad);</span>
 }
 
 /**
<span class="p_chunk">@@ -1564,7 +1562,7 @@</span> <span class="p_context"> static int smack_task_getsid(struct task_struct *p)</span>
  */
 static void smack_task_getsecid(struct task_struct *p, u32 *secid)
 {
<span class="p_del">-	*secid = smack_to_secid(smk_of_task(task_security(p)));</span>
<span class="p_add">+	*secid = smack_to_secid(smk_of_task_struct(p));</span>
 }
 
 /**
<span class="p_chunk">@@ -1676,7 +1674,7 @@</span> <span class="p_context"> static int smack_task_kill(struct task_struct *p, struct siginfo *info,</span>
 	 * can write the receiver.
 	 */
 	if (secid == 0)
<span class="p_del">-		return smk_curacc(smk_of_task(task_security(p)), MAY_WRITE,</span>
<span class="p_add">+		return smk_curacc(smk_of_task_struct(p), MAY_WRITE,</span>
 				  &amp;ad);
 	/*
 	 * If the secid isn&#39;t 0 we&#39;re dealing with some USB IO
<span class="p_chunk">@@ -1684,7 +1682,7 @@</span> <span class="p_context"> static int smack_task_kill(struct task_struct *p, struct siginfo *info,</span>
 	 * we can&#39;t take privilege into account.
 	 */
 	return smk_access(smack_from_secid(secid),
<span class="p_del">-			  smk_of_task(task_security(p)), MAY_WRITE, &amp;ad);</span>
<span class="p_add">+			  smk_of_task_struct(p), MAY_WRITE, &amp;ad);</span>
 }
 
 /**
<span class="p_chunk">@@ -1697,9 +1695,13 @@</span> <span class="p_context"> static int smack_task_wait(struct task_struct *p)</span>
 {
 	struct smk_audit_info ad;
 	char *sp = smk_of_current();
<span class="p_del">-	char *tsp = smk_of_forked(task_security(p));</span>
<span class="p_add">+	char *tsp;</span>
 	int rc;
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	tsp = smk_of_forked(__task_cred(p)-&gt;security);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	/* we don&#39;t log here, we can be overriden */
 	rc = smk_access(tsp, sp, MAY_WRITE, NULL);
 	if (rc == 0)
<span class="p_chunk">@@ -1736,7 +1738,7 @@</span> <span class="p_context"> static int smack_task_wait(struct task_struct *p)</span>
 static void smack_task_to_inode(struct task_struct *p, struct inode *inode)
 {
 	struct inode_smack *isp = inode-&gt;i_security;
<span class="p_del">-	isp-&gt;smk_inode = smk_of_task(task_security(p));</span>
<span class="p_add">+	isp-&gt;smk_inode = smk_of_task_struct(p);</span>
 }
 
 /*
<span class="p_chunk">@@ -2719,7 +2721,7 @@</span> <span class="p_context"> static int smack_getprocattr(struct task_struct *p, char *name, char **value)</span>
 	if (strcmp(name, &quot;current&quot;) != 0)
 		return -EINVAL;
 
<span class="p_del">-	cp = kstrdup(smk_of_task(task_security(p)), GFP_KERNEL);</span>
<span class="p_add">+	cp = kstrdup(smk_of_task_struct(p), GFP_KERNEL);</span>
 	if (cp == NULL)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index e773d5e..8fb4d24 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1164,6 +1164,10 @@</span> <span class="p_context"> static int snd_ctl_elem_add(struct snd_ctl_file *file,</span>
 
 	if (info-&gt;count &lt; 1)
 		return -EINVAL;
<span class="p_add">+	if (!*info-&gt;id.name)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (strnlen(info-&gt;id.name, sizeof(info-&gt;id.name)) &gt;= sizeof(info-&gt;id.name))</span>
<span class="p_add">+		return -EINVAL;</span>
 	access = info-&gt;access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
 		(info-&gt;access &amp; (SNDRV_CTL_ELEM_ACCESS_READWRITE|
 				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
<span class="p_header">diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c</span>
<span class="p_header">index 3a90793..65195a1 100644</span>
<span class="p_header">--- a/sound/core/pcm_native.c</span>
<span class="p_header">+++ b/sound/core/pcm_native.c</span>
<span class="p_chunk">@@ -1382,6 +1382,8 @@</span> <span class="p_context"> static int snd_pcm_do_drain_init(struct snd_pcm_substream *substream, int state)</span>
 			if (! snd_pcm_playback_empty(substream)) {
 				snd_pcm_do_start(substream, SNDRV_PCM_STATE_DRAINING);
 				snd_pcm_post_start(substream, SNDRV_PCM_STATE_DRAINING);
<span class="p_add">+			} else {</span>
<span class="p_add">+				runtime-&gt;status-&gt;state = SNDRV_PCM_STATE_SETUP;</span>
 			}
 			break;
 		case SNDRV_PCM_STATE_RUNNING:
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 9461a00..b16a37f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -759,7 +759,7 @@</span> <span class="p_context"> static void alc_auto_setup_eapd(struct hda_codec *codec, bool on)</span>
 {
 	/* We currently only handle front, HP */
 	static hda_nid_t pins[] = {
<span class="p_del">-		0x0f, 0x10, 0x14, 0x15, 0</span>
<span class="p_add">+		0x0f, 0x10, 0x14, 0x15, 0x17, 0</span>
 	};
 	hda_nid_t *p;
 	for (p = pins; *p; p++)
<span class="p_header">diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c</span>
<span class="p_header">index 0481d94..c1cdd02 100644</span>
<span class="p_header">--- a/sound/pci/riptide/riptide.c</span>
<span class="p_header">+++ b/sound/pci/riptide/riptide.c</span>
<span class="p_chunk">@@ -2026,32 +2026,43 @@</span> <span class="p_context"> snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)</span>
 {
 	static int dev;
 	struct gameport *gameport;
<span class="p_add">+	int ret;</span>
 
 	if (dev &gt;= SNDRV_CARDS)
 		return -ENODEV;
<span class="p_add">+</span>
 	if (!enable[dev]) {
<span class="p_del">-		dev++;</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+		ret = -ENOENT;</span>
<span class="p_add">+		goto inc_dev;</span>
 	}
 
<span class="p_del">-	if (!joystick_port[dev++])</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (!joystick_port[dev]) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto inc_dev;</span>
<span class="p_add">+	}</span>
 
 	gameport = gameport_allocate_port();
<span class="p_del">-	if (!gameport)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!gameport) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto inc_dev;</span>
<span class="p_add">+	}</span>
 	if (!request_region(joystick_port[dev], 8, &quot;Riptide gameport&quot;)) {
 		snd_printk(KERN_WARNING
 			   &quot;Riptide: cannot grab gameport 0x%x\n&quot;,
 			   joystick_port[dev]);
 		gameport_free_port(gameport);
<span class="p_del">-		return -EBUSY;</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		goto inc_dev;</span>
 	}
 
 	gameport-&gt;io = joystick_port[dev];
 	gameport_register_port(gameport);
 	pci_set_drvdata(pci, gameport);
<span class="p_del">-	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+inc_dev:</span>
<span class="p_add">+	dev++;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
<span class="p_header">diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c</span>
<span class="p_header">index bc030a2..0627ffe 100644</span>
<span class="p_header">--- a/sound/pci/rme9652/hdspm.c</span>
<span class="p_header">+++ b/sound/pci/rme9652/hdspm.c</span>
<span class="p_chunk">@@ -6042,6 +6042,12 @@</span> <span class="p_context"> static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)</span>
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
<span class="p_add">+		snd_pcm_hw_constraint_minmax(runtime,</span>
<span class="p_add">+					     SNDRV_PCM_HW_PARAM_PERIODS,</span>
<span class="p_add">+					     2, 2);</span>
<span class="p_add">+		snd_pcm_hw_constraint_minmax(runtime,</span>
<span class="p_add">+					     SNDRV_PCM_HW_PARAM_PERIODS,</span>
<span class="p_add">+					     2, 2);</span>
 		break;
 	}
 
<span class="p_header">diff --git a/sound/soc/codecs/adav80x.c b/sound/soc/codecs/adav80x.c</span>
<span class="p_header">index ebd7b37..81e0e27 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adav80x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adav80x.c</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static int adav80x_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	unsigned int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	unsigned int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static int adav80x_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = adav80x-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = adav80x-&gt;deemph;</span>
 	return 0;
 };
 
<span class="p_header">diff --git a/sound/soc/codecs/ak4641.c b/sound/soc/codecs/ak4641.c</span>
<span class="p_header">index c4d165a..e1773e0 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ak4641.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ak4641.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> static int ak4641_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int ak4641_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = ak4641-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = ak4641-&gt;deemph;</span>
 	return 0;
 };
 
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index bf71412..f9e2bda 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int cs4271_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = cs4271-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = cs4271-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static int cs4271_put_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	cs4271-&gt;deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	cs4271-&gt;deemph = ucontrol-&gt;value.integer.value[0];</span>
 	return cs4271_set_deemph(codec);
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c</span>
<span class="p_header">index 87cbf14..e8a7608f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/sgtl5000.c</span>
<span class="p_header">+++ b/sound/soc/codecs/sgtl5000.c</span>
<span class="p_chunk">@@ -1107,13 +1107,7 @@</span> <span class="p_context"> static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)</span>
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
 	} else if (vddio &gt;= 3100 &amp;&amp; vdda &gt;= 3100) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * if vddio and vddd &gt; 3.1v,</span>
<span class="p_del">-		 * charge pump should be clean before set ana_pwr</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,</span>
<span class="p_del">-				SGTL5000_VDDC_CHRGPMP_POWERUP, 0);</span>
<span class="p_del">-</span>
<span class="p_add">+		ana_pwr &amp;= ~SGTL5000_VDDC_CHRGPMP_POWERUP;</span>
 		/* VDDC use VDDIO rail */
 		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
 		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO &lt;&lt;
<span class="p_header">diff --git a/sound/soc/codecs/wm2000.c b/sound/soc/codecs/wm2000.c</span>
<span class="p_header">index bb9f070..fb1f0a7 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm2000.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm2000.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> static int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec-&gt;dev);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm2000-&gt;anc_active;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm2000-&gt;anc_active;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -591,7 +591,7 @@</span> <span class="p_context"> static int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec-&gt;dev);
<span class="p_del">-	int anc_active = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int anc_active = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (anc_active &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -607,7 +607,7 @@</span> <span class="p_context"> static int wm2000_speaker_get(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec-&gt;dev);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm2000-&gt;spk_ena;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm2000-&gt;spk_ena;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -617,7 +617,7 @@</span> <span class="p_context"> static int wm2000_speaker_put(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm2000_priv *wm2000 = dev_get_drvdata(codec-&gt;dev);
<span class="p_del">-	int val = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int val = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (val &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8731.c b/sound/soc/codecs/wm8731.c</span>
<span class="p_header">index 8b5afc1..3616b5b 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8731.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8731.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static int wm8731_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8731-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8731-&gt;deemph;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static int wm8731_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 	int ret = 0;
 
 	if (deemph &gt; 1)
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.c b/sound/soc/codecs/wm8903.c</span>
<span class="p_header">index 77758542..776653d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.c</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> static int wm8903_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8903-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8903-&gt;deemph;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static int wm8903_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 	int ret = 0;
 
 	if (deemph &gt; 1)
<span class="p_header">diff --git a/sound/soc/codecs/wm8904.c b/sound/soc/codecs/wm8904.c</span>
<span class="p_header">index c93e360..19f3040 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8904.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8904.c</span>
<span class="p_chunk">@@ -528,7 +528,7 @@</span> <span class="p_context"> static int wm8904_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8904-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8904-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> static int wm8904_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 61fe974..4696f66 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static int wm8955_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8955-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8955-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -402,7 +402,7 @@</span> <span class="p_context"> static int wm8955_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index a09d7eb..a3e4831 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> static int wm8960_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8960-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8960-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> static int wm8960_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/omap/omap-pcm.c b/sound/soc/omap/omap-pcm.c</span>
<span class="p_header">index 5a649da..96bce55a 100644</span>
<span class="p_header">--- a/sound/soc/omap/omap-pcm.c</span>
<span class="p_header">+++ b/sound/soc/omap/omap-pcm.c</span>
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> static struct snd_pcm_ops omap_pcm_ops = {</span>
 	.mmap		= omap_pcm_mmap,
 };
 
<span class="p_del">-static u64 omap_pcm_dmamask = DMA_BIT_MASK(64);</span>
<span class="p_add">+static u64 omap_pcm_dmamask = DMA_BIT_MASK(32);</span>
 
 static int omap_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 	int stream)
<span class="p_chunk">@@ -384,7 +384,7 @@</span> <span class="p_context"> static int omap_pcm_new(struct snd_soc_pcm_runtime *rtd)</span>
 	if (!card-&gt;dev-&gt;dma_mask)
 		card-&gt;dev-&gt;dma_mask = &amp;omap_pcm_dmamask;
 	if (!card-&gt;dev-&gt;coherent_dma_mask)
<span class="p_del">-		card-&gt;dev-&gt;coherent_dma_mask = DMA_BIT_MASK(64);</span>
<span class="p_add">+		card-&gt;dev-&gt;coherent_dma_mask = DMA_BIT_MASK(32);</span>
 
 	if (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) {
 		ret = omap_pcm_preallocate_dma_buffer(pcm,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index fb95069..040d101 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static const struct rc_config {</span>
 	{ USB_ID(0x041e, 0x3040), 2, 2, 6, 6,  2,  0x6e91 }, /* Live! 24-bit */
 	{ USB_ID(0x041e, 0x3042), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 */
 	{ USB_ID(0x041e, 0x30df), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */
<span class="p_add">+	{ USB_ID(0x041e, 0x3237), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */</span>
 	{ USB_ID(0x041e, 0x3048), 2, 2, 6, 6,  2,  0x6e91 }, /* Toshiba SB0500 */
 };
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 5ef3579..2ad5d77 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -1871,6 +1871,36 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 		}
 	}
 },
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x0582, 0x0159),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		/* .vendor_name = &quot;Roland&quot;, */</span>
<span class="p_add">+		/* .product_name = &quot;UA-22&quot;, */</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp; (const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
 
 /* Guillemot devices */
 {
<span class="p_header">diff --git a/tools/perf/Makefile b/tools/perf/Makefile</span>
<span class="p_header">index 2db7ba0..331647c 100644</span>
<span class="p_header">--- a/tools/perf/Makefile</span>
<span class="p_header">+++ b/tools/perf/Makefile</span>
<span class="p_chunk">@@ -816,10 +816,10 @@</span> <span class="p_context"> $(OUTPUT)util/rbtree.o: ../../lib/rbtree.c $(OUTPUT)PERF-CFLAGS</span>
 	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) -DETC_PERFCONFIG=&#39;&quot;$(ETC_PERFCONFIG_SQ)&quot;&#39; $&lt;
 
 $(OUTPUT)util/scripting-engines/trace-event-perl.o: util/scripting-engines/trace-event-perl.c $(OUTPUT)PERF-CFLAGS
<span class="p_del">-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow $&lt;</span>
<span class="p_add">+	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow -Wno-undef -Wno-switch-default $&lt;</span>
 
 $(OUTPUT)scripts/perl/Perf-Trace-Util/Context.o: scripts/perl/Perf-Trace-Util/Context.c $(OUTPUT)PERF-CFLAGS
<span class="p_del">-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-nested-externs $&lt;</span>
<span class="p_add">+	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-nested-externs -Wno-undef -Wno-switch-default $&lt;</span>
 
 $(OUTPUT)util/scripting-engines/trace-event-python.o: util/scripting-engines/trace-event-python.c $(OUTPUT)PERF-CFLAGS
 	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PYTHON_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow $&lt;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



