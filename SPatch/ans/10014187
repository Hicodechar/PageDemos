
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.93 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.93</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 18, 2017, 8:53 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171018085332.GB17836@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10014187/mbox/"
   >mbox</a>
|
   <a href="/patch/10014187/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10014187/">/patch/10014187/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AD4BC602C8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:55:22 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 95B0428AE8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:55:22 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 88CF128AF9; Wed, 18 Oct 2017 08:55:22 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9CD2828AE8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:55:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S936510AbdJRIy5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 18 Oct 2017 04:54:57 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:33852 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S934196AbdJRIxZ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 18 Oct 2017 04:53:25 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 2D86789E;
	Wed, 18 Oct 2017 08:53:24 +0000 (UTC)
Date: Wed, 18 Oct 2017 10:53:32 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.93
Message-ID: &lt;20171018085332.GB17836@kroah.com&gt;
References: &lt;20171018085327.GA17836@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171018085327.GA17836@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 18, 2017, 8:53 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index fab2d640a27e..77a17fb24b6d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 92</span>
<span class="p_add">+SUBLEVEL = 93</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 6da2e4a6ba39..dd058aa8a3b5 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -2360,7 +2360,6 @@</span> <span class="p_context"> dcopuop:</span>
 					break;
 				default:
 					/* Reserved R6 ops */
<span class="p_del">-					pr_err(&quot;Reserved MIPS R6 CMP.condn.S operation\n&quot;);</span>
 					return SIGILL;
 				}
 			}
<span class="p_chunk">@@ -2434,7 +2433,6 @@</span> <span class="p_context"> dcopuop:</span>
 					break;
 				default:
 					/* Reserved R6 ops */
<span class="p_del">-					pr_err(&quot;Reserved MIPS R6 CMP.condn.D operation\n&quot;);</span>
 					return SIGILL;
 				}
 			}
<span class="p_header">diff --git a/arch/x86/include/asm/alternative-asm.h b/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_header">index e7636bac7372..6c98821fef5e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_chunk">@@ -62,8 +62,10 @@</span> <span class="p_context"></span>
 #define new_len2		145f-144f
 
 /*
<span class="p_del">- * max without conditionals. Idea adapted from:</span>
<span class="p_add">+ * gas compatible max based on the idea from:</span>
  * http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax
<span class="p_add">+ *</span>
<span class="p_add">+ * The additional &quot;-&quot; is needed because gas uses a &quot;true&quot; value of -1.</span>
  */
 #define alt_max_short(a, b)	((a) ^ (((a) ^ (b)) &amp; -(-((a) &lt; (b)))))
 
<span class="p_header">diff --git a/arch/x86/include/asm/alternative.h b/arch/x86/include/asm/alternative.h</span>
<span class="p_header">index 7bfc85bbb8ff..09936e9c8154 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/alternative.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/alternative.h</span>
<span class="p_chunk">@@ -102,12 +102,12 @@</span> <span class="p_context"> static inline int alternatives_text_reserved(void *start, void *end)</span>
 	alt_end_marker &quot;:\n&quot;
 
 /*
<span class="p_del">- * max without conditionals. Idea adapted from:</span>
<span class="p_add">+ * gas compatible max based on the idea from:</span>
  * http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax
  *
<span class="p_del">- * The additional &quot;-&quot; is needed because gas works with s32s.</span>
<span class="p_add">+ * The additional &quot;-&quot; is needed because gas uses a &quot;true&quot; value of -1.</span>
  */
<span class="p_del">-#define alt_max_short(a, b)	&quot;((&quot; a &quot;) ^ (((&quot; a &quot;) ^ (&quot; b &quot;)) &amp; -(-((&quot; a &quot;) - (&quot; b &quot;)))))&quot;</span>
<span class="p_add">+#define alt_max_short(a, b)	&quot;((&quot; a &quot;) ^ (((&quot; a &quot;) ^ (&quot; b &quot;)) &amp; -(-((&quot; a &quot;) &lt; (&quot; b &quot;)))))&quot;</span>
 
 /*
  * Pad the second replacement alternative with additional NOPs if it is
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index a018dff00808..9114588e3e61 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -10369,7 +10369,7 @@</span> <span class="p_context"> static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,</span>
 	 * (KVM doesn&#39;t change it)- no reason to call set_cr4_guest_host_mask();
 	 */
 	vcpu-&gt;arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);
<span class="p_del">-	kvm_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
<span class="p_add">+	vmx_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
 
 	nested_ept_uninit_mmu_context(vcpu);
 
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 14263fab94d3..68bbc835bacc 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1320,6 +1320,7 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 		offset = uaddr &amp; ~PAGE_MASK;
 		for (j = cur_page; j &lt; page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
<span class="p_add">+			unsigned short prev_bi_vcnt = bio-&gt;bi_vcnt;</span>
 
 			if (len &lt;= 0)
 				break;
<span class="p_chunk">@@ -1334,6 +1335,13 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 					    bytes)
 				break;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * check if vector was merged with previous</span>
<span class="p_add">+			 * drop page reference if needed</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (bio-&gt;bi_vcnt == prev_bi_vcnt)</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+</span>
 			len -= bytes;
 			offset = 0;
 		}
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index 359754591653..b2cd109d9171 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -274,12 +274,14 @@</span> <span class="p_context"> static int shash_async_finup(struct ahash_request *req)</span>
 
 int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)
 {
<span class="p_del">-	struct scatterlist *sg = req-&gt;src;</span>
<span class="p_del">-	unsigned int offset = sg-&gt;offset;</span>
 	unsigned int nbytes = req-&gt;nbytes;
<span class="p_add">+	struct scatterlist *sg;</span>
<span class="p_add">+	unsigned int offset;</span>
 	int err;
 
<span class="p_del">-	if (nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset)) {</span>
<span class="p_add">+	if (nbytes &amp;&amp;</span>
<span class="p_add">+	    (sg = req-&gt;src, offset = sg-&gt;offset,</span>
<span class="p_add">+	     nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset))) {</span>
 		void *data;
 
 		data = kmap_atomic(sg_page(sg));
<span class="p_header">diff --git a/drivers/dma/edma.c b/drivers/dma/edma.c</span>
<span class="p_header">index 16fe773fb846..85674a8d0436 100644</span>
<span class="p_header">--- a/drivers/dma/edma.c</span>
<span class="p_header">+++ b/drivers/dma/edma.c</span>
<span class="p_chunk">@@ -1126,11 +1126,24 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 	struct edma_desc *edesc;
 	struct device *dev = chan-&gt;device-&gt;dev;
 	struct edma_chan *echan = to_edma_chan(chan);
<span class="p_del">-	unsigned int width, pset_len;</span>
<span class="p_add">+	unsigned int width, pset_len, array_size;</span>
 
 	if (unlikely(!echan || !len))
 		return NULL;
 
<span class="p_add">+	/* Align the array size (acnt block) with the transfer properties */</span>
<span class="p_add">+	switch (__ffs((src | dest | len))) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		array_size = SZ_32K - 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		array_size = SZ_32K - 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		array_size = SZ_32K - 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (len &lt; SZ_64K) {
 		/*
 		 * Transfer size less than 64K can be handled with one paRAM
<span class="p_chunk">@@ -1152,7 +1165,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 		 * When the full_length is multibple of 32767 one slot can be
 		 * used to complete the transfer.
 		 */
<span class="p_del">-		width = SZ_32K - 1;</span>
<span class="p_add">+		width = array_size;</span>
 		pset_len = rounddown(len, width);
 		/* One slot is enough for lengths multiple of (SZ_32K -1) */
 		if (unlikely(pset_len == len))
<span class="p_chunk">@@ -1202,7 +1215,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 		}
 		dest += pset_len;
 		src += pset_len;
<span class="p_del">-		pset_len = width = len % (SZ_32K - 1);</span>
<span class="p_add">+		pset_len = width = len % array_size;</span>
 
 		ret = edma_config_pset(chan, &amp;edesc-&gt;pset[1], src, dest, 1,
 				       width, pset_len, DMA_MEM_TO_MEM);
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index 0df32fe0e345..b0eeb5090c91 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -971,6 +971,8 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
<span class="p_add">+	int num_descriptors;</span>
<span class="p_add">+	size_t offset = offsetof(struct hid_descriptor, desc);</span>
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev-&gt;descriptor.idVendor),
 			le16_to_cpu(dev-&gt;descriptor.idProduct));
<span class="p_chunk">@@ -993,10 +995,18 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	if (hdesc-&gt;bLength &lt; sizeof(struct hid_descriptor)) {</span>
<span class="p_add">+		dbg_hid(&quot;hid descriptor is too short\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hid-&gt;version = le16_to_cpu(hdesc-&gt;bcdHID);
 	hid-&gt;country = hdesc-&gt;bCountryCode;
 
<span class="p_del">-	for (n = 0; n &lt; hdesc-&gt;bNumDescriptors; n++)</span>
<span class="p_add">+	num_descriptors = min_t(int, hdesc-&gt;bNumDescriptors,</span>
<span class="p_add">+	       (hdesc-&gt;bLength - offset) / sizeof(struct hid_class_descriptor));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; n &lt; num_descriptors; n++)</span>
 		if (hdesc-&gt;desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc-&gt;desc[n].wDescriptorLength);
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index a0ef57483ebb..52c36394dba5 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -3096,6 +3096,7 @@</span> <span class="p_context"> static size_t amd_iommu_unmap(struct iommu_domain *dom, unsigned long iova,</span>
 	mutex_unlock(&amp;domain-&gt;api_lock);
 
 	domain_flush_tlb_pde(domain);
<span class="p_add">+	domain_flush_complete(domain);</span>
 
 	return unmap_size;
 }
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index f18491cf793c..5fecae0ba52e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -2903,6 +2903,7 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 	struct brcmf_cfg80211_info *cfg = ifp-&gt;drvr-&gt;config;
 	s32 status;
 	struct brcmf_escan_result_le *escan_result_le;
<span class="p_add">+	u32 escan_buflen;</span>
 	struct brcmf_bss_info_le *bss_info_le;
 	struct brcmf_bss_info_le *bss = NULL;
 	u32 bi_length;
<span class="p_chunk">@@ -2919,11 +2920,23 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 
 	if (status == BRCMF_E_STATUS_PARTIAL) {
 		brcmf_dbg(SCAN, &quot;ESCAN Partial result\n&quot;);
<span class="p_add">+		if (e-&gt;datalen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;invalid event data length\n&quot;);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		escan_result_le = (struct brcmf_escan_result_le *) data;
 		if (!escan_result_le) {
 			brcmf_err(&quot;Invalid escan result (NULL pointer)\n&quot;);
 			goto exit;
 		}
<span class="p_add">+		escan_buflen = le32_to_cpu(escan_result_le-&gt;buflen);</span>
<span class="p_add">+		if (escan_buflen &gt; WL_ESCAN_BUF_SIZE ||</span>
<span class="p_add">+		    escan_buflen &gt; e-&gt;datalen ||</span>
<span class="p_add">+		    escan_buflen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;Invalid escan buffer length: %d\n&quot;,</span>
<span class="p_add">+				  escan_buflen);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		if (le16_to_cpu(escan_result_le-&gt;bss_count) != 1) {
 			brcmf_err(&quot;Invalid bss_count %d: ignoring\n&quot;,
 				  escan_result_le-&gt;bss_count);
<span class="p_chunk">@@ -2940,9 +2953,8 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 		}
 
 		bi_length = le32_to_cpu(bss_info_le-&gt;length);
<span class="p_del">-		if (bi_length != (le32_to_cpu(escan_result_le-&gt;buflen) -</span>
<span class="p_del">-					WL_ESCAN_RESULTS_FIXED_SIZE)) {</span>
<span class="p_del">-			brcmf_err(&quot;Invalid bss_info length %d: ignoring\n&quot;,</span>
<span class="p_add">+		if (bi_length != escan_buflen -	WL_ESCAN_RESULTS_FIXED_SIZE) {</span>
<span class="p_add">+			brcmf_err(&quot;Ignoring invalid bss_info length: %d\n&quot;,</span>
 				  bi_length);
 			goto exit;
 		}
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index 1a8ea775de08..984cd2f05c4a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1906,6 +1906,11 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	struct iwl_mvm_mc_iter_data *data = _data;
 	struct iwl_mvm *mvm = data-&gt;mvm;
 	struct iwl_mcast_filter_cmd *cmd = mvm-&gt;mcast_filter_cmd;
<span class="p_add">+	struct iwl_host_cmd hcmd = {</span>
<span class="p_add">+		.id = MCAST_FILTER_CMD,</span>
<span class="p_add">+		.flags = CMD_ASYNC,</span>
<span class="p_add">+		.dataflags[0] = IWL_HCMD_DFL_NOCOPY,</span>
<span class="p_add">+	};</span>
 	int ret, len;
 
 	/* if we don&#39;t have free ports, mcast frames will be dropped */
<span class="p_chunk">@@ -1920,7 +1925,10 @@</span> <span class="p_context"> static void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,</span>
 	memcpy(cmd-&gt;bssid, vif-&gt;bss_conf.bssid, ETH_ALEN);
 	len = roundup(sizeof(*cmd) + cmd-&gt;count * ETH_ALEN, 4);
 
<span class="p_del">-	ret = iwl_mvm_send_cmd_pdu(mvm, MCAST_FILTER_CMD, CMD_ASYNC, len, cmd);</span>
<span class="p_add">+	hcmd.len[0] = len;</span>
<span class="p_add">+	hcmd.data[0] = cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iwl_mvm_send_cmd(mvm, &amp;hcmd);</span>
 	if (ret)
 		IWL_ERR(mvm, &quot;mcast filter cmd error. ret=%d\n&quot;, ret);
 }
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index e2641d4dfdd6..d186d0282a38 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -1905,6 +1905,8 @@</span> <span class="p_context"> static DEVICE_ATTR_RO(suspended);</span>
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
<span class="p_add">+	struct usb_gadget_strings	*gstr = cdev-&gt;driver-&gt;strings[0];</span>
<span class="p_add">+	struct usb_string		*dev_str = gstr-&gt;strings;</span>
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
<span class="p_chunk">@@ -1924,6 +1926,9 @@</span> <span class="p_context"> static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)</span>
 
 	composite_dev_cleanup(cdev);
 
<span class="p_add">+	if (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev-&gt;def_manufacturer)</span>
<span class="p_add">+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = &quot;&quot;;</span>
<span class="p_add">+</span>
 	kfree(cdev-&gt;def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index db645c38055d..8080a11947b7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -420,6 +420,7 @@</span> <span class="p_context"> static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)</span>
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
<span class="p_add">+	unsigned int power_bit;</span>
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
<span class="p_chunk">@@ -430,17 +431,19 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 			return;
 
 	set_link_state_by_speed(dum_hcd);
<span class="p_add">+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?</span>
<span class="p_add">+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);</span>
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* Currently !connected or in reset */
<span class="p_del">-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||</span>
<span class="p_add">+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||</span>
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
<span class="p_del">-		unsigned disconnect = USB_PORT_STAT_CONNECTION &amp;</span>
<span class="p_add">+		unsigned int disconnect = power_bit &amp;</span>
 				dum_hcd-&gt;old_status &amp; (~dum_hcd-&gt;port_status);
<span class="p_del">-		unsigned reset = USB_PORT_STAT_RESET &amp;</span>
<span class="p_add">+		unsigned int reset = USB_PORT_STAT_RESET &amp;</span>
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index d95cd1a72b66..8bb9367ada45 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -858,9 +858,9 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 		fifo-&gt;name, usbhs_pipe_number(pipe), pkt-&gt;length, pkt-&gt;zero);
 
 	usbhs_pipe_running(pipe, 1);
<span class="p_del">-	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);
 	dma_async_issue_pending(chan);
<span class="p_add">+	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_enable(pipe);
 
 xfer_work_end:
<span class="p_header">diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c</span>
<span class="p_header">index 3806e7014199..2938153fe7b1 100644</span>
<span class="p_header">--- a/drivers/usb/serial/console.c</span>
<span class="p_header">+++ b/drivers/usb/serial/console.c</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> static int usb_console_setup(struct console *co, char *options)</span>
 	tty_kref_put(tty);
  reset_open_count:
 	port-&gt;port.count = 0;
<span class="p_add">+	info-&gt;port = NULL;</span>
 	usb_autopm_put_interface(serial-&gt;interface);
  error_get_interface:
 	usb_serial_put(serial);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 41a6513646de..1f5ecf905b7d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE032) }, /* ELV TFD500 Data Logger */</span>
 	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
 	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
 	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index e0385d6c0abb..30344efc123f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1015,6 +1015,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
 	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 4fcf1cecb6d7..f9d15bd62785 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -609,6 +609,13 @@</span> <span class="p_context"></span>
 #define ADI_GNICE_PID		0xF000
 #define ADI_GNICEPLUS_PID	0xF001
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Cypress WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CYPRESS_VID			0x04B4</span>
<span class="p_add">+#define CYPRESS_WICED_BT_USB_PID	0x009B</span>
<span class="p_add">+#define CYPRESS_WICED_WL_USB_PID	0xF900</span>
<span class="p_add">+</span>
 /*
  * Microchip Technology, Inc.
  *
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 2a9944326210..db3d34c2c82e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -522,6 +522,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 
 /* TP-LINK Incorporated products */
 #define TPLINK_VENDOR_ID			0x2357
<span class="p_add">+#define TPLINK_PRODUCT_LTE			0x000D</span>
 #define TPLINK_PRODUCT_MA180			0x0201
 
 /* Changhong products */
<span class="p_chunk">@@ -2011,6 +2012,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600A) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600E) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(TPLINK_VENDOR_ID, TPLINK_PRODUCT_LTE, 0xff, 0x00, 0x00) },	/* TP-Link LTE Module */</span>
 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(TPLINK_VENDOR_ID, 0x9000),					/* TP-Link MA260 */
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 652b4334b26d..e1c1e329c877 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -174,6 +174,10 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81b3)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
 	{DEVICE_SWI(0x413c, 0x81b5)},	/* Dell Wireless 5811e QDL */
 	{DEVICE_SWI(0x413c, 0x81b6)},	/* Dell Wireless 5811e QDL */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81cf)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d0)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d1)},   /* Dell Wireless 5818 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d2)},   /* Dell Wireless 5818 */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index e2f6a79e9b01..8225de3c9743 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -351,6 +351,8 @@</span> <span class="p_context"> struct smb_version_operations {</span>
 	unsigned int (*calc_smb_size)(void *);
 	/* check for STATUS_PENDING and process it in a positive case */
 	bool (*is_status_pending)(char *, struct TCP_Server_Info *, int);
<span class="p_add">+	/* check for STATUS_NETWORK_SESSION_EXPIRED */</span>
<span class="p_add">+	bool (*is_session_expired)(char *);</span>
 	/* send oplock break response */
 	int (*oplock_response)(struct cifs_tcon *, struct cifs_fid *,
 			       struct cifsInodeInfo *);
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index b60150e5b5ce..0c92af11f4f4 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -1460,6 +1460,13 @@</span> <span class="p_context"> cifs_readv_receive(struct TCP_Server_Info *server, struct mid_q_entry *mid)</span>
 		return length;
 	server-&gt;total_read += length;
 
<span class="p_add">+	if (server-&gt;ops-&gt;is_session_expired &amp;&amp;</span>
<span class="p_add">+	    server-&gt;ops-&gt;is_session_expired(buf)) {</span>
<span class="p_add">+		cifs_reconnect(server);</span>
<span class="p_add">+		wake_up(&amp;server-&gt;response_q);</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (server-&gt;ops-&gt;is_status_pending &amp;&amp;
 	    server-&gt;ops-&gt;is_status_pending(buf, server, 0)) {
 		discard_remaining_data(server);
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index b377aa8f266f..0a2bf9462637 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -850,6 +850,13 @@</span> <span class="p_context"> standard_receive3(struct TCP_Server_Info *server, struct mid_q_entry *mid)</span>
 		cifs_dump_mem(&quot;Bad SMB: &quot;, buf,
 			min_t(unsigned int, server-&gt;total_read, 48));
 
<span class="p_add">+	if (server-&gt;ops-&gt;is_session_expired &amp;&amp;</span>
<span class="p_add">+	    server-&gt;ops-&gt;is_session_expired(buf)) {</span>
<span class="p_add">+		cifs_reconnect(server);</span>
<span class="p_add">+		wake_up(&amp;server-&gt;response_q);</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (server-&gt;ops-&gt;is_status_pending &amp;&amp;
 	    server-&gt;ops-&gt;is_status_pending(buf, server, length))
 		return -1;
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index 1d125d3d0d89..e6b1795fbf2a 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -963,6 +963,18 @@</span> <span class="p_context"> smb2_is_status_pending(char *buf, struct TCP_Server_Info *server, int length)</span>
 	return true;
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+smb2_is_session_expired(char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct smb2_hdr *hdr = (struct smb2_hdr *)buf;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hdr-&gt;Status != STATUS_NETWORK_SESSION_EXPIRED)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	cifs_dbg(FYI, &quot;Session expired\n&quot;);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 smb2_oplock_response(struct cifs_tcon *tcon, struct cifs_fid *fid,
 		     struct cifsInodeInfo *cinode)
<span class="p_chunk">@@ -1552,6 +1564,7 @@</span> <span class="p_context"> struct smb_version_operations smb20_operations = {</span>
 	.close_dir = smb2_close_dir,
 	.calc_smb_size = smb2_calc_size,
 	.is_status_pending = smb2_is_status_pending,
<span class="p_add">+	.is_session_expired = smb2_is_session_expired,</span>
 	.oplock_response = smb2_oplock_response,
 	.queryfs = smb2_queryfs,
 	.mand_lock = smb2_mand_lock,
<span class="p_chunk">@@ -1633,6 +1646,7 @@</span> <span class="p_context"> struct smb_version_operations smb21_operations = {</span>
 	.close_dir = smb2_close_dir,
 	.calc_smb_size = smb2_calc_size,
 	.is_status_pending = smb2_is_status_pending,
<span class="p_add">+	.is_session_expired = smb2_is_session_expired,</span>
 	.oplock_response = smb2_oplock_response,
 	.queryfs = smb2_queryfs,
 	.mand_lock = smb2_mand_lock,
<span class="p_chunk">@@ -1715,6 +1729,7 @@</span> <span class="p_context"> struct smb_version_operations smb30_operations = {</span>
 	.close_dir = smb2_close_dir,
 	.calc_smb_size = smb2_calc_size,
 	.is_status_pending = smb2_is_status_pending,
<span class="p_add">+	.is_session_expired = smb2_is_session_expired,</span>
 	.oplock_response = smb2_oplock_response,
 	.queryfs = smb2_queryfs,
 	.mand_lock = smb2_mand_lock,
<span class="p_chunk">@@ -1803,6 +1818,7 @@</span> <span class="p_context"> struct smb_version_operations smb311_operations = {</span>
 	.close_dir = smb2_close_dir,
 	.calc_smb_size = smb2_calc_size,
 	.is_status_pending = smb2_is_status_pending,
<span class="p_add">+	.is_session_expired = smb2_is_session_expired,</span>
 	.oplock_response = smb2_oplock_response,
 	.queryfs = smb2_queryfs,
 	.mand_lock = smb2_mand_lock,
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index c772fdf36cd9..44f49d86d714 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -823,7 +823,8 @@</span> <span class="p_context"> out:</span>
 	 */
 	if (sdio-&gt;boundary) {
 		ret = dio_send_cur_page(dio, sdio, map_bh);
<span class="p_del">-		dio_bio_submit(dio, sdio);</span>
<span class="p_add">+		if (sdio-&gt;bio)</span>
<span class="p_add">+			dio_bio_submit(dio, sdio);</span>
 		page_cache_release(sdio-&gt;cur_page);
 		sdio-&gt;cur_page = NULL;
 	}
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 45ef9975caec..a8b1749d79a8 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -559,7 +559,7 @@</span> <span class="p_context"> static loff_t ext4_seek_data(struct file *file, loff_t offset, loff_t maxsize)</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
 	isize = i_size_read(inode);
<span class="p_del">-	if (offset &gt;= isize) {</span>
<span class="p_add">+	if (offset &lt; 0 || offset &gt;= isize) {</span>
 		mutex_unlock(&amp;inode-&gt;i_mutex);
 		return -ENXIO;
 	}
<span class="p_chunk">@@ -632,7 +632,7 @@</span> <span class="p_context"> static loff_t ext4_seek_hole(struct file *file, loff_t offset, loff_t maxsize)</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
 	isize = i_size_read(inode);
<span class="p_del">-	if (offset &gt;= isize) {</span>
<span class="p_add">+	if (offset &lt; 0 || offset &gt;= isize) {</span>
 		mutex_unlock(&amp;inode-&gt;i_mutex);
 		return -ENXIO;
 	}
<span class="p_header">diff --git a/include/sound/seq_virmidi.h b/include/sound/seq_virmidi.h</span>
<span class="p_header">index a03acd0d398a..695257ae64ac 100644</span>
<span class="p_header">--- a/include/sound/seq_virmidi.h</span>
<span class="p_header">+++ b/include/sound/seq_virmidi.h</span>
<span class="p_chunk">@@ -60,6 +60,7 @@</span> <span class="p_context"> struct snd_virmidi_dev {</span>
 	int port;			/* created/attached port */
 	unsigned int flags;		/* SNDRV_VIRMIDI_* */
 	rwlock_t filelist_lock;
<span class="p_add">+	struct rw_semaphore filelist_sem;</span>
 	struct list_head filelist;
 };
 
<span class="p_header">diff --git a/kernel/rcu/tree.c b/kernel/rcu/tree.c</span>
<span class="p_header">index f07343b54fe5..8a62cbfe1f2f 100644</span>
<span class="p_header">--- a/kernel/rcu/tree.c</span>
<span class="p_header">+++ b/kernel/rcu/tree.c</span>
<span class="p_chunk">@@ -759,6 +759,12 @@</span> <span class="p_context"> void rcu_irq_exit(void)</span>
 
 	local_irq_save(flags);
 	rdtp = this_cpu_ptr(&amp;rcu_dynticks);
<span class="p_add">+</span>
<span class="p_add">+	/* Page faults can happen in NMI handlers, so check... */</span>
<span class="p_add">+	if (READ_ONCE(rdtp-&gt;dynticks_nmi_nesting))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	RCU_LOCKDEP_WARN(!irqs_disabled(), &quot;rcu_irq_exit() invoked with irqs enabled!!!&quot;);</span>
 	oldval = rdtp-&gt;dynticks_nesting;
 	rdtp-&gt;dynticks_nesting--;
 	WARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &amp;&amp;
<span class="p_chunk">@@ -887,6 +893,12 @@</span> <span class="p_context"> void rcu_irq_enter(void)</span>
 
 	local_irq_save(flags);
 	rdtp = this_cpu_ptr(&amp;rcu_dynticks);
<span class="p_add">+</span>
<span class="p_add">+	/* Page faults can happen in NMI handlers, so check... */</span>
<span class="p_add">+	if (READ_ONCE(rdtp-&gt;dynticks_nmi_nesting))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	RCU_LOCKDEP_WARN(!irqs_disabled(), &quot;rcu_irq_enter() invoked with irqs enabled!!!&quot;);</span>
 	oldval = rdtp-&gt;dynticks_nesting;
 	rdtp-&gt;dynticks_nesting++;
 	WARN_ON_ONCE(IS_ENABLED(CONFIG_RCU_EQS_DEBUG) &amp;&amp;
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 8ece212aa3d2..7950506395a8 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -485,6 +485,14 @@</span> <span class="p_context"> nl80211_plan_policy[NL80211_SCHED_SCAN_PLAN_MAX + 1] = {</span>
 	[NL80211_SCHED_SCAN_PLAN_ITERATIONS] = { .type = NLA_U32 },
 };
 
<span class="p_add">+/* policy for packet pattern attributes */</span>
<span class="p_add">+static const struct nla_policy</span>
<span class="p_add">+nl80211_packet_pattern_policy[MAX_NL80211_PKTPAT + 1] = {</span>
<span class="p_add">+	[NL80211_PKTPAT_MASK] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_PATTERN] = { .type = NLA_BINARY, },</span>
<span class="p_add">+	[NL80211_PKTPAT_OFFSET] = { .type = NLA_U32 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int nl80211_prepare_wdev_dump(struct sk_buff *skb,
 				     struct netlink_callback *cb,
 				     struct cfg80211_registered_device **rdev,
<span class="p_chunk">@@ -9410,7 +9418,7 @@</span> <span class="p_context"> static int nl80211_set_wowlan(struct sk_buff *skb, struct genl_info *info)</span>
 			u8 *mask_pat;
 
 			nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
<span class="p_del">-				  nla_len(pat), NULL);</span>
<span class="p_add">+				  nla_len(pat), nl80211_packet_pattern_policy);</span>
 			err = -EINVAL;
 			if (!pat_tb[NL80211_PKTPAT_MASK] ||
 			    !pat_tb[NL80211_PKTPAT_PATTERN])
<span class="p_chunk">@@ -9660,7 +9668,7 @@</span> <span class="p_context"> static int nl80211_parse_coalesce_rule(struct cfg80211_registered_device *rdev,</span>
 		u8 *mask_pat;
 
 		nla_parse(pat_tb, MAX_NL80211_PKTPAT, nla_data(pat),
<span class="p_del">-			  nla_len(pat), NULL);</span>
<span class="p_add">+			  nla_len(pat), nl80211_packet_pattern_policy);</span>
 		if (!pat_tb[NL80211_PKTPAT_MASK] ||
 		    !pat_tb[NL80211_PKTPAT_PATTERN])
 			return -EINVAL;
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index e326c1d80416..e847b9923c19 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1260,6 +1260,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_info info;
 	struct snd_seq_port_callback *callback;
<span class="p_add">+	int port_idx;</span>
 
 	if (copy_from_user(&amp;info, arg, sizeof(info)))
 		return -EFAULT;
<span class="p_chunk">@@ -1273,7 +1274,9 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 		return -ENOMEM;
 
 	if (client-&gt;type == USER_CLIENT &amp;&amp; info.kernel) {
<span class="p_del">-		snd_seq_delete_port(client, port-&gt;addr.port);</span>
<span class="p_add">+		port_idx = port-&gt;addr.port;</span>
<span class="p_add">+		snd_seq_port_unlock(port);</span>
<span class="p_add">+		snd_seq_delete_port(client, port_idx);</span>
 		return -EINVAL;
 	}
 	if (client-&gt;type == KERNEL_CLIENT) {
<span class="p_chunk">@@ -1294,6 +1297,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 
 	snd_seq_set_port_info(port, &amp;info);
 	snd_seq_system_client_ev_port_start(port-&gt;addr.client, port-&gt;addr.port);
<span class="p_add">+	snd_seq_port_unlock(port);</span>
 
 	if (copy_to_user(arg, &amp;info, sizeof(info)))
 		return -EFAULT;
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index fe686ee41c6d..f04714d70bf7 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -122,7 +122,9 @@</span> <span class="p_context"> static void port_subs_info_init(struct snd_seq_port_subs_info *grp)</span>
 }
 
 
<span class="p_del">-/* create a port, port number is returned (-1 on failure) */</span>
<span class="p_add">+/* create a port, port number is returned (-1 on failure);</span>
<span class="p_add">+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately</span>
<span class="p_add">+ */</span>
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
<span class="p_chunk">@@ -151,6 +153,7 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	snd_use_lock_init(&amp;new_port-&gt;use_lock);
 	port_subs_info_init(&amp;new_port-&gt;c_src);
 	port_subs_info_init(&amp;new_port-&gt;c_dest);
<span class="p_add">+	snd_use_lock_use(&amp;new_port-&gt;use_lock);</span>
 
 	num = port &gt;= 0 ? port : 0;
 	mutex_lock(&amp;client-&gt;ports_mutex);
<span class="p_chunk">@@ -165,9 +168,9 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	list_add_tail(&amp;new_port-&gt;list, &amp;p-&gt;list);
 	client-&gt;num_ports++;
 	new_port-&gt;addr.port = num;	/* store the port number in the port */
<span class="p_add">+	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 	write_unlock_irqrestore(&amp;client-&gt;ports_lock, flags);
 	mutex_unlock(&amp;client-&gt;ports_mutex);
<span class="p_del">-	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 
 	return new_port;
 }
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 81134e067184..3b126af4a026 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -77,13 +77,17 @@</span> <span class="p_context"> static void snd_virmidi_init_event(struct snd_virmidi *vmidi,</span>
  * decode input event and put to read buffer of each opened file
  */
 static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,
<span class="p_del">-					 struct snd_seq_event *ev)</span>
<span class="p_add">+					 struct snd_seq_event *ev,</span>
<span class="p_add">+					 bool atomic)</span>
 {
 	struct snd_virmidi *vmidi;
 	unsigned char msg[4];
 	int len;
 
<span class="p_del">-	read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		down_read(&amp;rdev-&gt;filelist_sem);</span>
 	list_for_each_entry(vmidi, &amp;rdev-&gt;filelist, list) {
 		if (!vmidi-&gt;trigger)
 			continue;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,</span>
 				snd_rawmidi_receive(vmidi-&gt;substream, msg, len);
 		}
 	}
<span class="p_del">-	read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		up_read(&amp;rdev-&gt;filelist_sem);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -115,7 +122,7 @@</span> <span class="p_context"> int snd_virmidi_receive(struct snd_rawmidi *rmidi, struct snd_seq_event *ev)</span>
 	struct snd_virmidi_dev *rdev;
 
 	rdev = rmidi-&gt;private_data;
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, true);</span>
 }
 #endif  /*  0  */
 
<span class="p_chunk">@@ -130,7 +137,7 @@</span> <span class="p_context"> static int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,</span>
 	rdev = private_data;
 	if (!(rdev-&gt;flags &amp; SNDRV_VIRMIDI_USE))
 		return 0; /* ignored */
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, atomic);</span>
 }
 
 /*
<span class="p_chunk">@@ -209,7 +216,6 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 	struct snd_virmidi *vmidi;
<span class="p_del">-	unsigned long flags;</span>
 
 	vmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);
 	if (vmidi == NULL)
<span class="p_chunk">@@ -223,9 +229,11 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	vmidi-&gt;client = rdev-&gt;client;
 	vmidi-&gt;port = rdev-&gt;port;	
 	runtime-&gt;private_data = vmidi;
<span class="p_del">-	write_lock_irqsave(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_add_tail(&amp;vmidi-&gt;list, &amp;rdev-&gt;filelist);
<span class="p_del">-	write_unlock_irqrestore(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	vmidi-&gt;rdev = rdev;
 	return 0;
 }
<span class="p_chunk">@@ -264,9 +272,11 @@</span> <span class="p_context"> static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
 	write_lock_irq(&amp;rdev-&gt;filelist_lock);
 	list_del(&amp;vmidi-&gt;list);
 	write_unlock_irq(&amp;rdev-&gt;filelist_lock);
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	snd_midi_event_free(vmidi-&gt;parser);
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
<span class="p_chunk">@@ -520,6 +530,7 @@</span> <span class="p_context"> int snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmi</span>
 	rdev-&gt;rmidi = rmidi;
 	rdev-&gt;device = device;
 	rdev-&gt;client = -1;
<span class="p_add">+	init_rwsem(&amp;rdev-&gt;filelist_sem);</span>
 	rwlock_init(&amp;rdev-&gt;filelist_lock);
 	INIT_LIST_HEAD(&amp;rdev-&gt;filelist);
 	rdev-&gt;seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;
<span class="p_header">diff --git a/sound/usb/caiaq/device.c b/sound/usb/caiaq/device.c</span>
<span class="p_header">index b871ba407e4e..4458190149d1 100644</span>
<span class="p_header">--- a/sound/usb/caiaq/device.c</span>
<span class="p_header">+++ b/sound/usb/caiaq/device.c</span>
<span class="p_chunk">@@ -469,10 +469,12 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	err = snd_usb_caiaq_send_command(cdev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto err_kill_urb;</span>
 
<span class="p_del">-	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ)) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_kill_urb;</span>
<span class="p_add">+	}</span>
 
 	usb_string(usb_dev, usb_dev-&gt;descriptor.iManufacturer,
 		   cdev-&gt;vendor_name, CAIAQ_USB_STR_LEN);
<span class="p_chunk">@@ -507,6 +509,10 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	setup_card(cdev);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ err_kill_urb:</span>
<span class="p_add">+	usb_kill_urb(&amp;cdev-&gt;ep1_in_urb);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int snd_probe(struct usb_interface *intf,
<span class="p_header">diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c</span>
<span class="p_header">index 183311cb849e..be78078a10ba 100644</span>
<span class="p_header">--- a/sound/usb/line6/driver.c</span>
<span class="p_header">+++ b/sound/usb/line6/driver.c</span>
<span class="p_chunk">@@ -586,9 +586,10 @@</span> <span class="p_context"> int line6_probe(struct usb_interface *interface,</span>
 	return 0;
 
  error:
<span class="p_del">-	if (line6-&gt;disconnect)</span>
<span class="p_del">-		line6-&gt;disconnect(line6);</span>
<span class="p_del">-	snd_card_free(card);</span>
<span class="p_add">+	/* we can call disconnect callback here because no close-sync is</span>
<span class="p_add">+	 * needed yet at this point</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	line6_disconnect(interface);</span>
 	return ret;
 }
 EXPORT_SYMBOL_GPL(line6_probe);
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 696de5ac69be..a23efc8671d6 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -2161,6 +2161,9 @@</span> <span class="p_context"> static int parse_audio_unit(struct mixer_build *state, int unitid)</span>
 
 static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)
 {
<span class="p_add">+	/* kill pending URBs */</span>
<span class="p_add">+	snd_usb_mixer_disconnect(mixer);</span>
<span class="p_add">+</span>
 	kfree(mixer-&gt;id_elems);
 	if (mixer-&gt;urb) {
 		kfree(mixer-&gt;urb-&gt;transfer_buffer);
<span class="p_chunk">@@ -2504,8 +2507,13 @@</span> <span class="p_context"> _error:</span>
 
 void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
 {
<span class="p_del">-	usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_del">-	usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	if (mixer-&gt;disconnected)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (mixer-&gt;urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_add">+	if (mixer-&gt;rc_urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	mixer-&gt;disconnected = true;</span>
 }
 
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h</span>
<span class="p_header">index 2b4b067646ab..545d99b09706 100644</span>
<span class="p_header">--- a/sound/usb/mixer.h</span>
<span class="p_header">+++ b/sound/usb/mixer.h</span>
<span class="p_chunk">@@ -22,6 +22,8 @@</span> <span class="p_context"> struct usb_mixer_interface {</span>
 	struct urb *rc_urb;
 	struct usb_ctrlrequest *rc_setup_packet;
 	u8 rc_buffer[6];
<span class="p_add">+</span>
<span class="p_add">+	bool disconnected;</span>
 };
 
 #define MAX_CHANNELS	16	/* max logical channels */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



