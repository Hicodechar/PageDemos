
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt13 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt13</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 11, 2015, 10:27 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1434018421-27751-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6586931/mbox/"
   >mbox</a>
|
   <a href="/patch/6586931/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6586931/">/patch/6586931/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 586169FB24
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 11 Jun 2015 10:28:01 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id EB9342064E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 11 Jun 2015 10:27:54 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id ED76E20649
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 11 Jun 2015 10:27:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754285AbbFKK1i (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 11 Jun 2015 06:27:38 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:43719 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751682AbbFKK1F (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 11 Jun 2015 06:27:05 -0400
Received: from 1.general.henrix.uk.vpn ([10.172.192.212] helo=localhost)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1Z2zhP-00081y-7y; Thu, 11 Jun 2015 10:27:03 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt13
Date: Thu, 11 Jun 2015 11:27:01 +0100
Message-Id: &lt;1434018421-27751-2-git-send-email-luis.henriques@canonical.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1434018421-27751-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1434018421-27751-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-5.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD, UNPARSEABLE_RELAY,
	URIBL_SBL autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - June 11, 2015, 10:27 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/virtual/kvm/mmu.txt b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">index 53838d9c6295..c59bd9bc41ef 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_chunk">@@ -169,6 +169,10 @@</span> <span class="p_context"> Shadow pages contain the following information:</span>
     Contains the value of cr4.smep &amp;&amp; !cr0.wp for which the page is valid
     (pages for which this is true are different from other pages; see the
     treatment of cr0.wp=0 below).
<span class="p_add">+  role.smap_andnot_wp:</span>
<span class="p_add">+    Contains the value of cr4.smap &amp;&amp; !cr0.wp for which the page is valid</span>
<span class="p_add">+    (pages for which this is true are different from other pages; see the</span>
<span class="p_add">+    treatment of cr0.wp=0 below).</span>
   gfn:
     Either the guest page table containing the translations shadowed by this
     page, or the base page frame for linear translations.  See role.direct.
<span class="p_chunk">@@ -344,10 +348,16 @@</span> <span class="p_context"> on fault type:</span>
 
 (user write faults generate a #PF)
 
<span class="p_del">-In the first case there is an additional complication if CR4.SMEP is</span>
<span class="p_del">-enabled: since we&#39;ve turned the page into a kernel page, the kernel may now</span>
<span class="p_del">-execute it.  We handle this by also setting spte.nx.  If we get a user</span>
<span class="p_del">-fetch or read fault, we&#39;ll change spte.u=1 and spte.nx=gpte.nx back.</span>
<span class="p_add">+In the first case there are two additional complications:</span>
<span class="p_add">+- if CR4.SMEP is enabled: since we&#39;ve turned the page into a kernel page,</span>
<span class="p_add">+  the kernel may now execute it.  We handle this by also setting spte.nx.</span>
<span class="p_add">+  If we get a user fetch or read fault, we&#39;ll change spte.u=1 and</span>
<span class="p_add">+  spte.nx=gpte.nx back.</span>
<span class="p_add">+- if CR4.SMAP is disabled: since the page has been changed to a kernel</span>
<span class="p_add">+  page, it can not be reused when CR4.SMAP is enabled. We set</span>
<span class="p_add">+  CR4.SMAP &amp;&amp; !CR0.WP into shadow page&#39;s role to avoid this case. Note,</span>
<span class="p_add">+  here we do not care the case that CR4.SMAP is enabled since KVM will</span>
<span class="p_add">+  directly inject #PF to guest due to failed permission check.</span>
 
 To prevent an spte that was converted into a kernel page with cr0.wp=0
 from being written by the kernel after cr0.wp has changed to 1, we make
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index c2c3ab88cea7..a640df642e5e 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt12</span>
<span class="p_add">+EXTRAVERSION =-ckt13</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> CONFIG_SHELL := $(shell if [ -x &quot;$$BASH&quot; ]; then echo $$BASH; \</span>
 
 HOSTCC       = gcc
 HOSTCXX      = g++
<span class="p_del">-HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer</span>
<span class="p_add">+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -std=gnu89</span>
 HOSTCXXFLAGS = -O2
 
 ifeq ($(shell $(HOSTCC) -v 2&gt;&amp;1 | grep -c &quot;clang version&quot;), 1)
<span class="p_chunk">@@ -406,7 +406,8 @@</span> <span class="p_context"> KBUILD_CPPFLAGS := -D__KERNEL__</span>
 KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
<span class="p_del">-		   -Wno-format-security</span>
<span class="p_add">+		   -Wno-format-security \</span>
<span class="p_add">+		   -std=gnu89</span>
 
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-trats2.dts b/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_header">index 77878447b312..0cee640ea9c9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_chunk">@@ -639,7 +639,7 @@</span> <span class="p_context"></span>
 
 			display-timings {
 				timing-0 {
<span class="p_del">-					clock-frequency = &lt;0&gt;;</span>
<span class="p_add">+					clock-frequency = &lt;57153600&gt;;</span>
 					hactive = &lt;720&gt;;
 					vactive = &lt;1280&gt;;
 					hfront-porch = &lt;5&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx27.dtsi b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">index a75555c39533..e721736fe879 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_chunk">@@ -499,7 +499,7 @@</span> <span class="p_context"></span>
 
 			fec: ethernet@1002b000 {
 				compatible = &quot;fsl,imx27-fec&quot;;
<span class="p_del">-				reg = &lt;0x1002b000 0x4000&gt;;</span>
<span class="p_add">+				reg = &lt;0x1002b000 0x1000&gt;;</span>
 				interrupts = &lt;50&gt;;
 				clocks = &lt;&amp;clks 48&gt;, &lt;&amp;clks 67&gt;;
 				clock-names = &quot;ipg&quot;, &quot;ahb&quot;;
<span class="p_header">diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile</span>
<span class="p_header">index 38ddd9f83d0e..03120e656aea 100644</span>
<span class="p_header">--- a/arch/arm/kernel/Makefile</span>
<span class="p_header">+++ b/arch/arm/kernel/Makefile</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o</span>
 
 obj-$(CONFIG_ARM_VIRT_EXT)	+= hyp-stub.o
 ifeq ($(CONFIG_ARM_PSCI),y)
<span class="p_del">-obj-y				+= psci.o</span>
<span class="p_add">+obj-y				+= psci.o psci-call.o</span>
 obj-$(CONFIG_SMP)		+= psci_smp.o
 endif
 
<span class="p_header">diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S</span>
<span class="p_header">index 7139d4a7dea7..29b81fc959fe 100644</span>
<span class="p_header">--- a/arch/arm/kernel/entry-common.S</span>
<span class="p_header">+++ b/arch/arm/kernel/entry-common.S</span>
<span class="p_chunk">@@ -32,7 +32,9 @@</span> <span class="p_context"> ret_fast_syscall:</span>
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
<span class="p_del">-	ldr	r1, [tsk, #TI_FLAGS]</span>
<span class="p_add">+	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing</span>
<span class="p_add">+	tst	r1, #_TIF_SYSCALL_WORK</span>
<span class="p_add">+	bne	__sys_trace_return</span>
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 	asm_trace_hardirqs_on
<span class="p_header">diff --git a/arch/arm/kernel/psci-call.S b/arch/arm/kernel/psci-call.S</span>
new file mode 100644
<span class="p_header">index 000000000000..a78e9e1e206d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/kernel/psci-call.S</span>
<span class="p_chunk">@@ -0,0 +1,31 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2015 ARM Limited</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Mark Rutland &lt;mark.rutland@arm.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/opcodes-sec.h&gt;</span>
<span class="p_add">+#include &lt;asm/opcodes-virt.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* int __invoke_psci_fn_hvc(u32 function_id, u32 arg0, u32 arg1, u32 arg2) */</span>
<span class="p_add">+ENTRY(__invoke_psci_fn_hvc)</span>
<span class="p_add">+	__HVC(0)</span>
<span class="p_add">+	bx	lr</span>
<span class="p_add">+ENDPROC(__invoke_psci_fn_hvc)</span>
<span class="p_add">+</span>
<span class="p_add">+/* int __invoke_psci_fn_smc(u32 function_id, u32 arg0, u32 arg1, u32 arg2) */</span>
<span class="p_add">+ENTRY(__invoke_psci_fn_smc)</span>
<span class="p_add">+	__SMC(0)</span>
<span class="p_add">+	bx	lr</span>
<span class="p_add">+ENDPROC(__invoke_psci_fn_smc)</span>
<span class="p_header">diff --git a/arch/arm/kernel/psci.c b/arch/arm/kernel/psci.c</span>
<span class="p_header">index f73891b6b730..f90fdf4ce7c7 100644</span>
<span class="p_header">--- a/arch/arm/kernel/psci.c</span>
<span class="p_header">+++ b/arch/arm/kernel/psci.c</span>
<span class="p_chunk">@@ -23,8 +23,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/compiler.h&gt;
 #include &lt;asm/errno.h&gt;
<span class="p_del">-#include &lt;asm/opcodes-sec.h&gt;</span>
<span class="p_del">-#include &lt;asm/opcodes-virt.h&gt;</span>
 #include &lt;asm/psci.h&gt;
 #include &lt;asm/system_misc.h&gt;
 
<span class="p_chunk">@@ -33,6 +31,9 @@</span> <span class="p_context"> struct psci_operations psci_ops;</span>
 static int (*invoke_psci_fn)(u32, u32, u32, u32);
 typedef int (*psci_initcall_t)(const struct device_node *);
 
<span class="p_add">+asmlinkage int __invoke_psci_fn_hvc(u32, u32, u32, u32);</span>
<span class="p_add">+asmlinkage int __invoke_psci_fn_smc(u32, u32, u32, u32);</span>
<span class="p_add">+</span>
 enum psci_function {
 	PSCI_FN_CPU_SUSPEND,
 	PSCI_FN_CPU_ON,
<span class="p_chunk">@@ -71,40 +72,6 @@</span> <span class="p_context"> static u32 psci_power_state_pack(struct psci_power_state state)</span>
 		 &amp; PSCI_0_2_POWER_STATE_AFFL_MASK);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * The following two functions are invoked via the invoke_psci_fn pointer</span>
<span class="p_del">- * and will not be inlined, allowing us to piggyback on the AAPCS.</span>
<span class="p_del">- */</span>
<span class="p_del">-static noinline int __invoke_psci_fn_hvc(u32 function_id, u32 arg0, u32 arg1,</span>
<span class="p_del">-					 u32 arg2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	asm volatile(</span>
<span class="p_del">-			__asmeq(&quot;%0&quot;, &quot;r0&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%1&quot;, &quot;r1&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%2&quot;, &quot;r2&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%3&quot;, &quot;r3&quot;)</span>
<span class="p_del">-			__HVC(0)</span>
<span class="p_del">-		: &quot;+r&quot; (function_id)</span>
<span class="p_del">-		: &quot;r&quot; (arg0), &quot;r&quot; (arg1), &quot;r&quot; (arg2));</span>
<span class="p_del">-</span>
<span class="p_del">-	return function_id;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static noinline int __invoke_psci_fn_smc(u32 function_id, u32 arg0, u32 arg1,</span>
<span class="p_del">-					 u32 arg2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	asm volatile(</span>
<span class="p_del">-			__asmeq(&quot;%0&quot;, &quot;r0&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%1&quot;, &quot;r1&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%2&quot;, &quot;r2&quot;)</span>
<span class="p_del">-			__asmeq(&quot;%3&quot;, &quot;r3&quot;)</span>
<span class="p_del">-			__SMC(0)</span>
<span class="p_del">-		: &quot;+r&quot; (function_id)</span>
<span class="p_del">-		: &quot;r&quot; (arg0), &quot;r&quot; (arg1), &quot;r&quot; (arg2));</span>
<span class="p_del">-</span>
<span class="p_del">-	return function_id;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int psci_get_version(void)
 {
 	int err;
<span class="p_header">diff --git a/arch/arm/mach-gemini/common.h b/arch/arm/mach-gemini/common.h</span>
<span class="p_header">index 38a45260a7c8..dd883698ff7e 100644</span>
<span class="p_header">--- a/arch/arm/mach-gemini/common.h</span>
<span class="p_header">+++ b/arch/arm/mach-gemini/common.h</span>
<span class="p_chunk">@@ -12,6 +12,8 @@</span> <span class="p_context"></span>
 #ifndef __GEMINI_COMMON_H__
 #define __GEMINI_COMMON_H__
 
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+</span>
 struct mtd_partition;
 
 extern void gemini_map_io(void);
<span class="p_chunk">@@ -26,6 +28,6 @@</span> <span class="p_context"> extern int platform_register_pflash(unsigned int size,</span>
 				    struct mtd_partition *parts,
 				    unsigned int nr_parts);
 
<span class="p_del">-extern void gemini_restart(char mode, const char *cmd);</span>
<span class="p_add">+extern void gemini_restart(enum reboot_mode mode, const char *cmd);</span>
 
 #endif /* __GEMINI_COMMON_H__ */
<span class="p_header">diff --git a/arch/arm/mach-gemini/reset.c b/arch/arm/mach-gemini/reset.c</span>
<span class="p_header">index b26659759e27..21a6d6d4f9c4 100644</span>
<span class="p_header">--- a/arch/arm/mach-gemini/reset.c</span>
<span class="p_header">+++ b/arch/arm/mach-gemini/reset.c</span>
<span class="p_chunk">@@ -14,7 +14,9 @@</span> <span class="p_context"></span>
 #include &lt;mach/hardware.h&gt;
 #include &lt;mach/global_reg.h&gt;
 
<span class="p_del">-void gemini_restart(char mode, const char *cmd)</span>
<span class="p_add">+#include &quot;common.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+void gemini_restart(enum reboot_mode mode, const char *cmd)</span>
 {
 	__raw_writel(RESET_GLOBAL | RESET_CPU1,
 		     IO_ADDRESS(GEMINI_GLOBAL_BASE) + GLOBAL_RESET);
<span class="p_header">diff --git a/arch/arm/mach-mvebu/coherency.c b/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_header">index 2ffccd4eb084..01efe130912e 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/coherency.c</span>
<span class="p_chunk">@@ -448,8 +448,9 @@</span> <span class="p_context"> static int __init coherency_late_init(void)</span>
 			armada_375_coherency_init_wa();
 	}
 
<span class="p_del">-	bus_register_notifier(&amp;platform_bus_type,</span>
<span class="p_del">-			      &amp;mvebu_hwcc_nb);</span>
<span class="p_add">+	if (coherency_available())</span>
<span class="p_add">+		bus_register_notifier(&amp;platform_bus_type,</span>
<span class="p_add">+				      &amp;mvebu_hwcc_nb);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 6e3ba8d112a2..8a7c998f789d 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -1118,22 +1118,22 @@</span> <span class="p_context"> void __init sanity_check_meminfo(void)</span>
 			}
 
 			/*
<span class="p_del">-			 * Find the first non-section-aligned page, and point</span>
<span class="p_add">+			 * Find the first non-pmd-aligned page, and point</span>
 			 * memblock_limit at it. This relies on rounding the
<span class="p_del">-			 * limit down to be section-aligned, which happens at</span>
<span class="p_del">-			 * the end of this function.</span>
<span class="p_add">+			 * limit down to be pmd-aligned, which happens at the</span>
<span class="p_add">+			 * end of this function.</span>
 			 *
 			 * With this algorithm, the start or end of almost any
<span class="p_del">-			 * bank can be non-section-aligned. The only exception</span>
<span class="p_del">-			 * is that the start of the bank 0 must be section-</span>
<span class="p_add">+			 * bank can be non-pmd-aligned. The only exception is</span>
<span class="p_add">+			 * that the start of the bank 0 must be section-</span>
 			 * aligned, since otherwise memory would need to be
 			 * allocated when mapping the start of bank 0, which
 			 * occurs before any free memory is mapped.
 			 */
 			if (!memblock_limit) {
<span class="p_del">-				if (!IS_ALIGNED(block_start, SECTION_SIZE))</span>
<span class="p_add">+				if (!IS_ALIGNED(block_start, PMD_SIZE))</span>
 					memblock_limit = block_start;
<span class="p_del">-				else if (!IS_ALIGNED(block_end, SECTION_SIZE))</span>
<span class="p_add">+				else if (!IS_ALIGNED(block_end, PMD_SIZE))</span>
 					memblock_limit = arm_lowmem_limit;
 			}
 
<span class="p_chunk">@@ -1143,12 +1143,12 @@</span> <span class="p_context"> void __init sanity_check_meminfo(void)</span>
 	high_memory = __va(arm_lowmem_limit - 1) + 1;
 
 	/*
<span class="p_del">-	 * Round the memblock limit down to a section size.  This</span>
<span class="p_add">+	 * Round the memblock limit down to a pmd size.  This</span>
 	 * helps to ensure that we will allocate memory from the
<span class="p_del">-	 * last full section, which should be mapped.</span>
<span class="p_add">+	 * last full pmd, which should be mapped.</span>
 	 */
 	if (memblock_limit)
<span class="p_del">-		memblock_limit = round_down(memblock_limit, SECTION_SIZE);</span>
<span class="p_add">+		memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
 	if (!memblock_limit)
 		memblock_limit = arm_lowmem_limit;
 
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index fb5503ce016f..75ee31c95ff3 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -441,10 +441,21 @@</span> <span class="p_context"> static inline void emit_udiv(u8 rd, u8 rm, u8 rn, struct jit_ctx *ctx)</span>
 		return;
 	}
 #endif
<span class="p_del">-	if (rm != ARM_R0)</span>
<span class="p_del">-		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_K instructions, rm is ARM_R4</span>
<span class="p_add">+	 * (r_A) and rn is ARM_R0 (r_scratch) so load rn first into</span>
<span class="p_add">+	 * ARM_R1 to avoid accidentally overwriting ARM_R0 with rm</span>
<span class="p_add">+	 * before using it as a source for ARM_R1.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_X rm is ARM_R4 (r_A) and rn is</span>
<span class="p_add">+	 * ARM_R5 (r_X) so there is no particular register overlap</span>
<span class="p_add">+	 * issues.</span>
<span class="p_add">+	 */</span>
 	if (rn != ARM_R1)
 		emit(ARM_MOV_R(ARM_R1, rn), ctx);
<span class="p_add">+	if (rm != ARM_R0)</span>
<span class="p_add">+		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
 
 	ctx-&gt;seen |= SEEN_CALL;
 	emit_mov_i(ARM_R3, (u32)jit_udiv, ctx);
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index 893802645efe..0ada77e5d9e7 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> static void __dma_free_coherent(struct device *dev, size_t size,</span>
 
 		dma_release_from_contiguous(dev,
 					phys_to_page(paddr),
<span class="p_del">-					size &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+					PAGE_ALIGN(size) &gt;&gt; PAGE_SHIFT);</span>
 	} else {
 		swiotlb_free_coherent(dev, size, vaddr, dma_handle);
 	}
<span class="p_chunk">@@ -138,6 +138,8 @@</span> <span class="p_context"> static void __dma_free_noncoherent(struct device *dev, size_t size,</span>
 {
 	void *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));
 
<span class="p_add">+	size = PAGE_ALIGN(size);</span>
<span class="p_add">+</span>
 	vunmap(vaddr);
 	__dma_free_coherent(dev, size, swiotlb_addr, dma_handle, attrs);
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/elf.h b/arch/parisc/include/asm/elf.h</span>
<span class="p_header">index 3391d061eccc..78c9fd32c554 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/elf.h</span>
<span class="p_chunk">@@ -348,6 +348,10 @@</span> <span class="p_context"> struct pt_regs;	/* forward declaration... */</span>
 
 #define ELF_HWCAP	0
 
<span class="p_add">+#define STACK_RND_MASK	(is_32bit_task() ? \</span>
<span class="p_add">+				0x7ff &gt;&gt; (PAGE_SHIFT - 12) : \</span>
<span class="p_add">+				0x3ffff &gt;&gt; (PAGE_SHIFT - 12))</span>
<span class="p_add">+</span>
 struct mm_struct;
 extern unsigned long arch_randomize_brk(struct mm_struct *);
 #define arch_randomize_brk arch_randomize_brk
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index e1ffea2f9a0b..5aba01ac457f 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -77,6 +77,9 @@</span> <span class="p_context"> static unsigned long mmap_upper_limit(void)</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	return PAGE_ALIGN(STACK_TOP - stack_base);
 }
 
<span class="p_header">diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">index f096e72262f4..1db685104ffc 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.opd)
 	}
 
<span class="p_add">+	. = ALIGN(256);</span>
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 #ifndef CONFIG_RELOCATABLE
<span class="p_header">diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">index 7940dc90e80b..b258110da952 100644</span>
<span class="p_header">--- a/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">+++ b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_chunk">@@ -16,11 +16,12 @@</span> <span class="p_context"></span>
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
<span class="p_del">-	u8 icv[16];</span>
<span class="p_del">-	u8 key[16];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 };
 
 struct ghash_desc_ctx {
<span class="p_add">+	u8 icv[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
<span class="p_chunk">@@ -28,8 +29,10 @@</span> <span class="p_context"> struct ghash_desc_ctx {</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_add">+	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
 	memset(dctx, 0, sizeof(*dctx));
<span class="p_add">+	memcpy(dctx-&gt;key, ctx-&gt;key, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -45,7 +48,6 @@</span> <span class="p_context"> static int ghash_setkey(struct crypto_shash *tfm,</span>
 	}
 
 	memcpy(ctx-&gt;key, key, GHASH_BLOCK_SIZE);
<span class="p_del">-	memset(ctx-&gt;icv, 0, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -54,7 +56,6 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	unsigned int n;
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 		src += n;
 
 		if (!dctx-&gt;bytes) {
<span class="p_del">-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,</span>
<span class="p_add">+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,</span>
 					      GHASH_BLOCK_SIZE);
 			if (ret != GHASH_BLOCK_SIZE)
 				return -EIO;
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 
 	n = srclen &amp; ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);</span>
 		if (ret != n)
 			return -EIO;
 		src += n;
<span class="p_chunk">@@ -94,7 +95,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 	return 0;
 }
 
<span class="p_del">-static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
<span class="p_add">+static int ghash_flush(struct ghash_desc_ctx *dctx)</span>
 {
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -104,24 +105,24 @@</span> <span class="p_context"> static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
 
 		memset(pos, 0, dctx-&gt;bytes);
 
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);</span>
 		if (ret != GHASH_BLOCK_SIZE)
 			return -EIO;
<span class="p_add">+</span>
<span class="p_add">+		dctx-&gt;bytes = 0;</span>
 	}
 
<span class="p_del">-	dctx-&gt;bytes = 0;</span>
 	return 0;
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	int ret;
 
<span class="p_del">-	ret = ghash_flush(ctx, dctx);</span>
<span class="p_add">+	ret = ghash_flush(dctx);</span>
 	if (!ret)
<span class="p_del">-		memcpy(dst, ctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		memcpy(dst, dctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 12c8ea635f4d..04fe4a66c3ec 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> config SBUS</span>
 
 config NEED_DMA_MAP_STATE
 	def_bool y
<span class="p_del">-	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG</span>
<span class="p_add">+	depends on X86_64 || INTEL_IOMMU || DMA_API_DEBUG || SWIOTLB</span>
 
 config NEED_SG_DMA_LENGTH
 	def_bool y
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 3d9bcc6b9d99..554dcdf7ad82 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -203,6 +203,7 @@</span> <span class="p_context"> union kvm_mmu_page_role {</span>
 		unsigned nxe:1;
 		unsigned cr0_wp:1;
 		unsigned smep_andnot_wp:1;
<span class="p_add">+		unsigned smap_andnot_wp:1;</span>
 	};
 };
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_rapl.c b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">index 619f7699487a..0ee067ee830f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_chunk">@@ -664,6 +664,7 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 		break;
 	case 60: /* Haswell */
 	case 69: /* Haswell-Celeron */
<span class="p_add">+	case 61: /* Broadwell */</span>
 		rapl_cntr_mask = RAPL_IDX_HSW;
 		rapl_pmu_events_group.attrs = rapl_events_hsw_attr;
 		break;
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index 93d2c04c6f8f..f2e281cf8c19 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -330,13 +330,16 @@</span> <span class="p_context"> int __copy_instruction(u8 *dest, u8 *src)</span>
 {
 	struct insn insn;
 	kprobe_opcode_t buf[MAX_INSN_SIZE];
<span class="p_add">+	int length;</span>
 
 	kernel_insn_init(&amp;insn, (void *)recover_probed_instruction(buf, (unsigned long)src));
 	insn_get_length(&amp;insn);
<span class="p_add">+	length = insn.length;</span>
<span class="p_add">+</span>
 	/* Another subsystem puts a breakpoint, failed to recover */
 	if (insn.opcode.bytes[0] == BREAKPOINT_INSTRUCTION)
 		return 0;
<span class="p_del">-	memcpy(dest, insn.kaddr, insn.length);</span>
<span class="p_add">+	memcpy(dest, insn.kaddr, length);</span>
 
 #ifdef CONFIG_X86_64
 	if (insn_rip_relative(&amp;insn)) {
<span class="p_chunk">@@ -366,7 +369,7 @@</span> <span class="p_context"> int __copy_instruction(u8 *dest, u8 *src)</span>
 		*(s32 *) disp = (s32) newdisp;
 	}
 #endif
<span class="p_del">-	return insn.length;</span>
<span class="p_add">+	return length;</span>
 }
 
 static int arch_copy_kprobe(struct kprobe *p)
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 1bbf6861507e..458ae4d1324d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3609,8 +3609,8 @@</span> <span class="p_context"> static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,</span>
 	}
 }
 
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_del">-		struct kvm_mmu *mmu, bool ept)</span>
<span class="p_add">+static void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+				      struct kvm_mmu *mmu, bool ept)</span>
 {
 	unsigned bit, byte, pfec;
 	u8 map;
<span class="p_chunk">@@ -3791,6 +3791,7 @@</span> <span class="p_context"> static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)</span>
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context)
 {
 	bool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);
<span class="p_add">+	bool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);</span>
 	ASSERT(vcpu);
 	ASSERT(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));
 
<span class="p_chunk">@@ -3808,6 +3809,8 @@</span> <span class="p_context"> void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context)</span>
 	vcpu-&gt;arch.mmu.base_role.cr0_wp  = is_write_protection(vcpu);
 	vcpu-&gt;arch.mmu.base_role.smep_andnot_wp
 		= smep &amp;&amp; !is_write_protection(vcpu);
<span class="p_add">+	context-&gt;base_role.smap_andnot_wp</span>
<span class="p_add">+		= smap &amp;&amp; !is_write_protection(vcpu);</span>
 }
 EXPORT_SYMBOL_GPL(kvm_init_shadow_mmu);
 
<span class="p_chunk">@@ -4079,12 +4082,18 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 		       const u8 *new, int bytes)
 {
 	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
<span class="p_del">-	union kvm_mmu_page_role mask = { .word = 0 };</span>
 	struct kvm_mmu_page *sp;
 	LIST_HEAD(invalid_list);
 	u64 entry, gentry, *spte;
 	int npte;
 	bool remote_flush, local_flush, zap_page;
<span class="p_add">+	union kvm_mmu_page_role mask = (union kvm_mmu_page_role) {</span>
<span class="p_add">+		.cr0_wp = 1,</span>
<span class="p_add">+		.cr4_pae = 1,</span>
<span class="p_add">+		.nxe = 1,</span>
<span class="p_add">+		.smep_andnot_wp = 1,</span>
<span class="p_add">+		.smap_andnot_wp = 1,</span>
<span class="p_add">+	};</span>
 
 	/*
 	 * If we don&#39;t have indirect shadow pages, it means no page is
<span class="p_chunk">@@ -4110,7 +4119,6 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 	++vcpu-&gt;kvm-&gt;stat.mmu_pte_write;
 	kvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);
 
<span class="p_del">-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;</span>
 	for_each_gfn_indirect_valid_sp(vcpu-&gt;kvm, sp, gfn) {
 		if (detect_write_misaligned(sp, gpa, bytes) ||
 		      detect_write_flooding(sp)) {
<span class="p_header">diff --git a/arch/x86/kvm/mmu.h b/arch/x86/kvm/mmu.h</span>
<span class="p_header">index b982112d2ca5..1d4548867c86 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.h</span>
<span class="p_chunk">@@ -79,8 +79,6 @@</span> <span class="p_context"> int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct);</span>
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context);
 void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context,
 		bool execonly);
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
<span class="p_del">-		bool ept);</span>
 
 static inline unsigned int kvm_mmu_available_pages(struct kvm *kvm)
 {
<span class="p_chunk">@@ -174,6 +172,8 @@</span> <span class="p_context"> static inline bool permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
 	int index = (pfec &gt;&gt; 1) +
 		    (smap &gt;&gt; (X86_EFLAGS_AC_BIT - PFERR_RSVD_BIT + 1));
 
<span class="p_add">+	WARN_ON(pfec &amp; PFERR_RSVD_MASK);</span>
<span class="p_add">+</span>
 	return (mmu-&gt;permissions[index] &gt;&gt; pte_access) &amp; 1;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">index 410776528265..484711d2c71f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">+++ b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_chunk">@@ -706,6 +706,13 @@</span> <span class="p_context"> static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code,</span>
 					      mmu_is_nested(vcpu));
 		if (likely(r != RET_MMIO_PF_INVALID))
 			return r;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * page fault with PFEC.RSVD  = 1 is caused by shadow</span>
<span class="p_add">+		 * page fault, should not be used to walk guest page</span>
<span class="p_add">+		 * table.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		error_code &amp;= ~PFERR_RSVD_MASK;</span>
 	};
 
 	r = mmu_topup_memory_caches(vcpu);
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 6018e319d7fb..e05ef62906f4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -648,8 +648,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_set_xcr);</span>
 int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 {
 	unsigned long old_cr4 = kvm_read_cr4(vcpu);
<span class="p_del">-	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |</span>
<span class="p_del">-				   X86_CR4_PAE | X86_CR4_SMEP;</span>
<span class="p_add">+	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |</span>
<span class="p_add">+				   X86_CR4_SMEP | X86_CR4_SMAP;</span>
<span class="p_add">+</span>
 	if (cr4 &amp; CR4_RESERVED_BITS)
 		return 1;
 
<span class="p_chunk">@@ -690,9 +691,6 @@</span> <span class="p_context"> int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)</span>
 	    (!(cr4 &amp; X86_CR4_PCIDE) &amp;&amp; (old_cr4 &amp; X86_CR4_PCIDE)))
 		kvm_mmu_reset_context(vcpu);
 
<span class="p_del">-	if ((cr4 ^ old_cr4) &amp; X86_CR4_SMAP)</span>
<span class="p_del">-		update_permission_bitmask(vcpu, vcpu-&gt;arch.walk_mmu, false);</span>
<span class="p_del">-</span>
 	if ((cr4 ^ old_cr4) &amp; X86_CR4_OSXSAVE)
 		kvm_update_cpuid(vcpu);
 
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index dcee40b5a330..cde88080969b 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -906,7 +906,12 @@</span> <span class="p_context"> void bpf_int_jit_compile(struct sk_filter *prog)</span>
 	}
 	ctx.cleanup_addr = proglen;
 
<span class="p_del">-	for (pass = 0; pass &lt; 10; pass++) {</span>
<span class="p_add">+	/* JITed image shrinks with every pass and the loop iterates</span>
<span class="p_add">+	 * until the image stops shrinking. Very large bpf programs</span>
<span class="p_add">+	 * may converge on the last pass. In such case do one more</span>
<span class="p_add">+	 * pass to emit the final image</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (pass = 0; pass &lt; 10 || image; pass++) {</span>
 		proglen = do_jit(prog, addrs, image, oldproglen, &amp;ctx);
 		if (proglen &lt;= 0) {
 			image = NULL;
<span class="p_header">diff --git a/arch/x86/vdso/Makefile b/arch/x86/vdso/Makefile</span>
<span class="p_header">index 61b04fe36e66..265803394896 100644</span>
<span class="p_header">--- a/arch/x86/vdso/Makefile</span>
<span class="p_header">+++ b/arch/x86/vdso/Makefile</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> VDSO_LDFLAGS_vdso.lds = -m64 -Wl,-soname=linux-vdso.so.1 \</span>
 $(obj)/vdso64.so.dbg: $(src)/vdso.lds $(vobjs) FORCE
 	$(call if_changed,vdso)
 
<span class="p_del">-HOST_EXTRACFLAGS += -I$(srctree)/tools/include</span>
<span class="p_add">+HOST_EXTRACFLAGS += -I$(srctree)/tools/include -I$(srctree)/include/uapi -I$(srctree)/arch/x86/include/uapi</span>
 hostprogs-y			+= vdso2c
 
 quiet_cmd_vdso2c = VDSO2C  $@
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index bad25b070fe0..1b2d872c7398 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 		request_mem_region(addr, length, desc);
 }
 
<span class="p_del">-static int __init acpi_reserve_resources(void)</span>
<span class="p_add">+static void __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -201,10 +201,7 @@</span> <span class="p_context"> static int __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
<span class="p_del">-device_initcall(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1827,6 +1824,7 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_add">+	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue(&quot;kacpi_hotplug&quot;, 0);
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 3b18399290b3..8e7574afb716 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> enum board_ids {</span>
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
<span class="p_add">+	board_ahci_avn,</span>
 	board_ahci_mcp65,
 	board_ahci_mcp77,
 	board_ahci_mcp89,
<span class="p_chunk">@@ -84,6 +85,8 @@</span> <span class="p_context"> enum board_ids {</span>
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline);</span>
 static void ahci_mcp89_apple_enable(struct pci_dev *pdev);
 static bool is_mcp89_apple(struct pci_dev *pdev);
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
<span class="p_chunk">@@ -107,6 +110,11 @@</span> <span class="p_context"> static struct ata_port_operations ahci_p5wdh_ops = {</span>
 	.hardreset		= ahci_p5wdh_hardreset,
 };
 
<span class="p_add">+static struct ata_port_operations ahci_avn_ops = {</span>
<span class="p_add">+	.inherits		= &amp;ahci_ops,</span>
<span class="p_add">+	.hardreset		= ahci_avn_hardreset,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] = {
<span class="p_chunk">@@ -151,6 +159,12 @@</span> <span class="p_context"> static const struct ata_port_info ahci_port_info[] = {</span>
 		.port_ops	= &amp;ahci_ops,
 	},
 	/* by chipsets */
<span class="p_add">+	[board_ahci_avn] = {</span>
<span class="p_add">+		.flags		= AHCI_FLAG_COMMON,</span>
<span class="p_add">+		.pio_mask	= ATA_PIO4,</span>
<span class="p_add">+		.udma_mask	= ATA_UDMA6,</span>
<span class="p_add">+		.port_ops	= &amp;ahci_avn_ops,</span>
<span class="p_add">+	},</span>
 	[board_ahci_mcp65] = {
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
 				 AHCI_HFLAG_YES_NCQ),
<span class="p_chunk">@@ -290,14 +304,14 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci }, /* Avoton RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn }, /* Avoton RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x2823), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x2827), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci }, /* Wellsburg AHCI */
<span class="p_chunk">@@ -675,6 +689,79 @@</span> <span class="p_context"> static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,</span>
 	return rc;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * ahci_avn_hardreset - attempt more aggressive recovery of Avoton ports.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It has been observed with some SSDs that the timing of events in the</span>
<span class="p_add">+ * link synchronization phase can leave the port in a state that can not</span>
<span class="p_add">+ * be recovered by a SATA-hard-reset alone.  The failing signature is</span>
<span class="p_add">+ * SStatus.DET stuck at 1 (&quot;Device presence detected but Phy</span>
<span class="p_add">+ * communication not established&quot;).  It was found that unloading and</span>
<span class="p_add">+ * reloading the driver when this problem occurs allows the drive</span>
<span class="p_add">+ * connection to be recovered (DET advanced to 0x3).  The critical</span>
<span class="p_add">+ * component of reloading the driver is that the port state machines are</span>
<span class="p_add">+ * reset by bouncing &quot;port enable&quot; in the AHCI PCS configuration</span>
<span class="p_add">+ * register.  So, reproduce that effect by bouncing a port whenever we</span>
<span class="p_add">+ * see DET==1 after a reset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned long *timing = sata_ehc_deb_timing(&amp;link-&gt;eh_context);</span>
<span class="p_add">+	struct ata_port *ap = link-&gt;ap;</span>
<span class="p_add">+	struct ahci_port_priv *pp = ap-&gt;private_data;</span>
<span class="p_add">+	struct ahci_host_priv *hpriv = ap-&gt;host-&gt;private_data;</span>
<span class="p_add">+	u8 *d2h_fis = pp-&gt;rx_fis + RX_FIS_D2H_REG;</span>
<span class="p_add">+	unsigned long tmo = deadline - jiffies;</span>
<span class="p_add">+	struct ata_taskfile tf;</span>
<span class="p_add">+	bool online;</span>
<span class="p_add">+	int rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;ENTER\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_stop_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		u16 val;</span>
<span class="p_add">+		u32 sstatus;</span>
<span class="p_add">+		int port = ap-&gt;port_no;</span>
<span class="p_add">+		struct ata_host *host = ap-&gt;host;</span>
<span class="p_add">+		struct pci_dev *pdev = to_pci_dev(host-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* clear D2H reception area to properly wait for D2H FIS */</span>
<span class="p_add">+		ata_tf_init(link-&gt;device, &amp;tf);</span>
<span class="p_add">+		tf.command = ATA_BUSY;</span>
<span class="p_add">+		ata_tf_to_fis(&amp;tf, 0, 0, d2h_fis);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = sata_link_hardreset(link, timing, deadline, &amp;online,</span>
<span class="p_add">+				ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sata_scr_read(link, SCR_STATUS, &amp;sstatus) != 0 ||</span>
<span class="p_add">+				(sstatus &amp; 0xf) != 1)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ata_link_printk(link, KERN_INFO, &quot;avn bounce port%d\n&quot;,</span>
<span class="p_add">+				port);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, 0x92, &amp;val);</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; port);</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		ata_msleep(ap, 1000);</span>
<span class="p_add">+		val |= 1 &lt;&lt; port;</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		deadline += tmo;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hpriv-&gt;start_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (online)</span>
<span class="p_add">+		*class = ahci_dev_classify(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;EXIT, rc=%d, class=%u\n&quot;, rc, *class);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index d72ce0470309..86c3c24b835f 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1712,8 +1712,7 @@</span> <span class="p_context"> static void ahci_handle_port_interrupt(struct ata_port *ap,</span>
 	if (unlikely(resetting))
 		status &amp;= ~PORT_IRQ_BAD_PMP;
 
<span class="p_del">-	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_del">-	if (ap-&gt;link.lpm_policy &gt; ATA_LPM_MAX_POWER) {</span>
<span class="p_add">+	if (sata_lpm_ignore_phy_events(&amp;ap-&gt;link)) {</span>
 		status &amp;= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&amp;ap-&gt;link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index e1ad6e53073d..29358ff3e05e 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4225,9 +4225,11 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 
 	/* devices that don&#39;t properly handle queued TRIM commands */
 	{ &quot;Micron_M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
<span class="p_del">-	{ &quot;Crucial_CT???M500SSD*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_del">-	{ &quot;Micron_M550*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_del">-	{ &quot;Crucial_CT*M550SSD*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Micron_M5[15]0*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Crucial_CT*MX100*&quot;,		&quot;MU01&quot;, ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
 
 	/*
 	 * Some WD SATA-I drives spin up and down erratically when the link
<span class="p_chunk">@@ -6813,6 +6815,38 @@</span> <span class="p_context"> u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,</span>
 	return tmp;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored</span>
<span class="p_add">+ *	@link: Link receiving the event</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Test whether the received PHY event has to be ignored or not.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	LOCKING:</span>
<span class="p_add">+ *	None:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	RETURNS:</span>
<span class="p_add">+ *	True if the event has to be ignored.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sata_lpm_ignore_phy_events(struct ata_link *link)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long lpm_timeout = link-&gt;last_lpm_change +</span>
<span class="p_add">+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_add">+	if (link-&gt;lpm_policy &gt; ATA_LPM_MAX_POWER)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ignore the first PHY event after the LPM policy changed</span>
<span class="p_add">+	 * as it is might be spurious</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((link-&gt;flags &amp; ATA_LFLAG_CHANGED) &amp;&amp;</span>
<span class="p_add">+	    time_before(jiffies, lpm_timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);</span>
<span class="p_add">+</span>
 /*
  * Dummy port_ops
  */
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index dad83df555c4..4ec95b76f6a1 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -3490,6 +3490,9 @@</span> <span class="p_context"> static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,</span>
 		}
 	}
 
<span class="p_add">+	link-&gt;last_lpm_change = jiffies;</span>
<span class="p_add">+	link-&gt;flags |= ATA_LFLAG_CHANGED;</span>
<span class="p_add">+</span>
 	return 0;
 
 fail:
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 17afc51f3054..35286fe52823 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -489,6 +489,10 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 	buf += 16;
 
 	if (memcmp(buf, &quot;_DMI_&quot;, 5) == 0 &amp;&amp; dmi_checksum(buf, 15)) {
<span class="p_add">+		if (smbios_ver)</span>
<span class="p_add">+			dmi_ver = smbios_ver;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);</span>
 		dmi_num = (buf[13] &lt;&lt; 8) | buf[12];
 		dmi_len = (buf[7] &lt;&lt; 8) | buf[6];
 		dmi_base = (buf[11] &lt;&lt; 24) | (buf[10] &lt;&lt; 16) |
<span class="p_chunk">@@ -496,12 +500,9 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 
 		if (dmi_walk_early(dmi_decode) == 0) {
 			if (smbios_ver) {
<span class="p_del">-				dmi_ver = smbios_ver;</span>
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			} else {
<span class="p_del">-				dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 |</span>
<span class="p_del">-					   (buf[14] &amp; 0x0F);</span>
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			}
<span class="p_header">diff --git a/drivers/gpio/gpio-kempld.c b/drivers/gpio/gpio-kempld.c</span>
<span class="p_header">index 1e5e51987d31..b6ea5494ac78 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-kempld.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-kempld.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int kempld_gpio_get_direction(struct gpio_chip *chip, unsigned offset)</span>
 		= container_of(chip, struct kempld_gpio_data, chip);
 	struct kempld_device_data *pld = gpio-&gt;pld;
 
<span class="p_del">-	return kempld_gpio_get_bit(pld, KEMPLD_GPIO_DIR_NUM(offset), offset);</span>
<span class="p_add">+	return !kempld_gpio_get_bit(pld, KEMPLD_GPIO_DIR_NUM(offset), offset);</span>
 }
 
 static int kempld_gpio_pincount(struct kempld_device_data *pld)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 574d1f4ec7e5..0cf54a4b83bd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -5456,7 +5456,7 @@</span> <span class="p_context"> static int cik_pcie_gart_enable(struct radeon_device *rdev)</span>
 	 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	for (i = 1; i &lt; 16; i++) {
 		if (i &lt; 8)
 			WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index 1d0c08de1731..41ddc14bfab3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1270,7 +1270,8 @@</span> <span class="p_context"> static int cayman_pcie_gart_enable(struct radeon_device *rdev)</span>
 	 */
 	for (i = 1; i &lt; 8; i++) {
 		WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i &lt;&lt; 2), 0);
<span class="p_del">-		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2), rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2),</span>
<span class="p_add">+			rdev-&gt;vm_manager.max_pfn - 1);</span>
 		WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
 			rdev-&gt;gart.table_addr &gt;&gt; 12);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index b9368bc50570..5040fac05655 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -4087,7 +4087,7 @@</span> <span class="p_context"> static int si_pcie_gart_enable(struct radeon_device *rdev)</span>
 	/* empty context1-15 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	/* Assign the pt base to something valid for now; the pts used for
 	 * the VMs are determined by the application and setup and assigned
 	 * on the fly in the vm part of radeon_gart.c
<span class="p_header">diff --git a/drivers/hwmon/nct6775.c b/drivers/hwmon/nct6775.c</span>
<span class="p_header">index 59d9a3fc96b7..a2e63b309fe6 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct6775.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct6775.c</span>
<span class="p_chunk">@@ -986,6 +986,7 @@</span> <span class="p_context"> nct6775_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				 (*t)-&gt;dev_attr.attr.name, tg-&gt;base + i);
 			if ((*t)-&gt;s2) {
 				a2 = &amp;su-&gt;u.a2;
<span class="p_add">+				sysfs_attr_init(&amp;a2-&gt;dev_attr.attr);</span>
 				a2-&gt;dev_attr.attr.name = su-&gt;name;
 				a2-&gt;nr = (*t)-&gt;u.s.nr + i;
 				a2-&gt;index = (*t)-&gt;u.s.index;
<span class="p_chunk">@@ -996,6 +997,7 @@</span> <span class="p_context"> nct6775_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				*attrs = &amp;a2-&gt;dev_attr.attr;
 			} else {
 				a = &amp;su-&gt;u.a1;
<span class="p_add">+				sysfs_attr_init(&amp;a-&gt;dev_attr.attr);</span>
 				a-&gt;dev_attr.attr.name = su-&gt;name;
 				a-&gt;index = (*t)-&gt;u.index + i;
 				a-&gt;dev_attr.attr.mode =
<span class="p_header">diff --git a/drivers/hwmon/ntc_thermistor.c b/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_header">index ae66f42c4d6d..387ea83783df 100644</span>
<span class="p_header">--- a/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_header">+++ b/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_chunk">@@ -193,8 +193,10 @@</span> <span class="p_context"> static struct ntc_thermistor_platform_data *</span>
 ntc_thermistor_parse_dt(struct platform_device *pdev)
 {
 	struct iio_channel *chan;
<span class="p_add">+	enum iio_chan_type type;</span>
 	struct device_node *np = pdev-&gt;dev.of_node;
 	struct ntc_thermistor_platform_data *pdata;
<span class="p_add">+	int ret;</span>
 
 	if (!np)
 		return NULL;
<span class="p_chunk">@@ -207,6 +209,13 @@</span> <span class="p_context"> ntc_thermistor_parse_dt(struct platform_device *pdev)</span>
 	if (IS_ERR(chan))
 		return ERR_CAST(chan);
 
<span class="p_add">+	ret = iio_get_channel_type(chan, &amp;type);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ERR_PTR(ret);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IIO_VOLTAGE)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (of_property_read_u32(np, &quot;pullup-uv&quot;, &amp;pdata-&gt;pullup_uv))
 		return ERR_PTR(-ENODEV);
 	if (of_property_read_u32(np, &quot;pullup-ohm&quot;, &amp;pdata-&gt;pullup_ohm))
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index a2abf7c2ce3b..36cb5139e48e 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -458,6 +458,7 @@</span> <span class="p_context"> int st_accel_common_probe(struct iio_dev *indio_dev,</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;accel_info;
<span class="p_add">+	mutex_init(&amp;adata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">index 41d3a5efd62c..c7637716fa8f 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_chunk">@@ -856,6 +856,7 @@</span> <span class="p_context"> static int xadc_read_raw(struct iio_dev *indio_dev,</span>
 			switch (chan-&gt;address) {
 			case XADC_REG_VCCINT:
 			case XADC_REG_VCCAUX:
<span class="p_add">+			case XADC_REG_VREFP:</span>
 			case XADC_REG_VCCBRAM:
 			case XADC_REG_VCCPINT:
 			case XADC_REG_VCCPAUX:
<span class="p_chunk">@@ -996,7 +997,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 	.num_event_specs = (_alarm) ? ARRAY_SIZE(xadc_voltage_events) : 0, \
 	.scan_index = (_scan_index), \
 	.scan_type = { \
<span class="p_del">-		.sign = &#39;u&#39;, \</span>
<span class="p_add">+		.sign = ((_addr) == XADC_REG_VREFN) ? &#39;s&#39; : &#39;u&#39;, \</span>
 		.realbits = 12, \
 		.storagebits = 16, \
 		.shift = 4, \
<span class="p_chunk">@@ -1008,7 +1009,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 static const struct iio_chan_spec xadc_channels[] = {
 	XADC_CHAN_TEMP(0, 8, XADC_REG_TEMP),
 	XADC_CHAN_VOLTAGE(0, 9, XADC_REG_VCCINT, &quot;vccint&quot;, true),
<span class="p_del">-	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCINT, &quot;vccaux&quot;, true),</span>
<span class="p_add">+	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCAUX, &quot;vccaux&quot;, true),</span>
 	XADC_CHAN_VOLTAGE(2, 14, XADC_REG_VCCBRAM, &quot;vccbram&quot;, true),
 	XADC_CHAN_VOLTAGE(3, 5, XADC_REG_VCCPINT, &quot;vccpint&quot;, true),
 	XADC_CHAN_VOLTAGE(4, 6, XADC_REG_VCCPAUX, &quot;vccpaux&quot;, true),
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc.h b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">index c7487e8d7f80..54adc5087210 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_chunk">@@ -145,9 +145,9 @@</span> <span class="p_context"> static inline int xadc_write_adc_reg(struct xadc *xadc, unsigned int reg,</span>
 #define XADC_REG_MAX_VCCPINT	0x28
 #define XADC_REG_MAX_VCCPAUX	0x29
 #define XADC_REG_MAX_VCCO_DDR	0x2a
<span class="p_del">-#define XADC_REG_MIN_VCCPINT	0x2b</span>
<span class="p_del">-#define XADC_REG_MIN_VCCPAUX	0x2c</span>
<span class="p_del">-#define XADC_REG_MIN_VCCO_DDR	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPINT	0x2c</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPAUX	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCO_DDR	0x2e</span>
 
 #define XADC_REG_CONF0		0x40
 #define XADC_REG_CONF1		0x41
<span class="p_header">diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">index e8b932fed70e..4cafb43f948e 100644</span>
<span class="p_header">--- a/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">+++ b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_chunk">@@ -271,8 +271,6 @@</span> <span class="p_context"> int st_sensors_init_sensor(struct iio_dev *indio_dev,</span>
 	struct st_sensor_data *sdata = iio_priv(indio_dev);
 	int err = 0;
 
<span class="p_del">-	mutex_init(&amp;sdata-&gt;tb.buf_lock);</span>
<span class="p_del">-</span>
 	if (pdata)
 		err = st_sensors_set_drdy_int_pin(indio_dev, pdata);
 
<span class="p_header">diff --git a/drivers/iio/gyro/st_gyro_core.c b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">index ed74a9069989..bd6015d01d08 100644</span>
<span class="p_header">--- a/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">+++ b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_chunk">@@ -310,6 +310,7 @@</span> <span class="p_context"> int st_gyro_common_probe(struct iio_dev *indio_dev,</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;gyro_info;
<span class="p_add">+	mutex_init(&amp;gdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/light/hid-sensor-prox.c b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">index 412bae86d6ae..c95b9682f0da 100644</span>
<span class="p_header">--- a/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">+++ b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_chunk">@@ -43,8 +43,6 @@</span> <span class="p_context"> struct prox_state {</span>
 static const struct iio_chan_spec prox_channels[] = {
 	{
 		.type = IIO_PROXIMITY,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">index 4d55151893af..04ec7bae5655 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_chunk">@@ -362,6 +362,7 @@</span> <span class="p_context"> int st_magn_common_probe(struct iio_dev *indio_dev,</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;magn_info;
<span class="p_add">+	mutex_init(&amp;mdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/pressure/hid-sensor-press.c b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">index 2c0d2a4fed8c..759b153f1955 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_chunk">@@ -47,8 +47,6 @@</span> <span class="p_context"> struct press_state {</span>
 static const struct iio_chan_spec press_channels[] = {
 	{
 		.type = IIO_PRESSURE,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index cd7e01f3a93b..1aa7c18471a8 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -395,6 +395,7 @@</span> <span class="p_context"> int st_press_common_probe(struct iio_dev *indio_dev,</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;press_info;
<span class="p_add">+	mutex_init(&amp;pdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_msg.c b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">index b85ddbc979e0..e5558b2660f2 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 
 #include &quot;iwpm_util.h&quot;
 
<span class="p_del">-static const char iwpm_ulib_name[] = &quot;iWarpPortMapperUser&quot;;</span>
<span class="p_add">+static const char iwpm_ulib_name[IWPM_ULIBNAME_SIZE] = &quot;iWarpPortMapperUser&quot;;</span>
 static int iwpm_ulib_version = 3;
 static int iwpm_user_pid = IWPM_PID_UNDEFINED;
 static atomic_t echo_nlmsg_seq;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index b865f55e4b62..b94686f62eb8 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> static void elantech_report_semi_mt_data(struct input_dev *dev,</span>
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
<span class="p_del">-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);</span>
<span class="p_add">+	elantech_set_slot(dev, 1, num_fingers &gt;= 2, x2, y2);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c</span>
<span class="p_header">index 0bf1e4edf04d..19da22249bd8 100644</span>
<span class="p_header">--- a/drivers/lguest/core.c</span>
<span class="p_header">+++ b/drivers/lguest/core.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> static void unmap_switcher(void)</span>
 bool lguest_address_ok(const struct lguest *lg,
 		       unsigned long addr, unsigned long len)
 {
<span class="p_del">-	return (addr+len) / PAGE_SIZE &lt; lg-&gt;pfn_limit &amp;&amp; (addr+len &gt;= addr);</span>
<span class="p_add">+	return addr+len &lt;= lg-&gt;pfn_limit * PAGE_SIZE &amp;&amp; (addr+len &gt;= addr);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index b1b9efb5359f..6d7d2f3059a7 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -1941,7 +1941,8 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 
 	conf-&gt;slab_cache = sc;
 	conf-&gt;active_name = 1-conf-&gt;active_name;
<span class="p_del">-	conf-&gt;pool_size = newsize;</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		conf-&gt;pool_size = newsize;</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">index bb585d940901..6be0878893ad 100644</span>
<span class="p_header">--- a/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_chunk">@@ -1294,7 +1294,7 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 
 	if (ios-&gt;clock) {
 		unsigned int clock_min = ~0U;
<span class="p_del">-		u32 clkdiv;</span>
<span class="p_add">+		int clkdiv;</span>
 
 		clk_prepare(host-&gt;mck);
 		unprepare_clk = true;
<span class="p_chunk">@@ -1323,7 +1323,12 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 		/* Calculate clock divider */
 		if (host-&gt;caps.has_odd_clk_div) {
 			clkdiv = DIV_ROUND_UP(host-&gt;bus_hz, clock_min) - 2;
<span class="p_del">-			if (clkdiv &gt; 511) {</span>
<span class="p_add">+			if (clkdiv &lt; 0) {</span>
<span class="p_add">+				dev_warn(&amp;mmc-&gt;class_dev,</span>
<span class="p_add">+					 &quot;clock %u too fast; using %lu\n&quot;,</span>
<span class="p_add">+					 clock_min, host-&gt;bus_hz / 2);</span>
<span class="p_add">+				clkdiv = 0;</span>
<span class="p_add">+			} else if (clkdiv &gt; 511) {</span>
 				dev_warn(&amp;mmc-&gt;class_dev,
 				         &quot;clock %u too slow; using %lu\n&quot;,
 				         clock_min, host-&gt;bus_hz / (511 + 2));
<span class="p_header">diff --git a/drivers/net/can/xilinx_can.c b/drivers/net/can/xilinx_can.c</span>
<span class="p_header">index 5e8b5609c067..479e962c0492 100644</span>
<span class="p_header">--- a/drivers/net/can/xilinx_can.c</span>
<span class="p_header">+++ b/drivers/net/can/xilinx_can.c</span>
<span class="p_chunk">@@ -508,10 +508,11 @@</span> <span class="p_context"> static int xcan_rx(struct net_device *ndev)</span>
 			cf-&gt;can_id |= CAN_RTR_FLAG;
 	}
 
<span class="p_del">-	if (!(id_xcan &amp; XCAN_IDR_SRR_MASK)) {</span>
<span class="p_del">-		data[0] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW1_OFFSET);</span>
<span class="p_del">-		data[1] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW2_OFFSET);</span>
<span class="p_add">+	/* DW1/DW2 must always be read to remove message from RXFIFO */</span>
<span class="p_add">+	data[0] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW1_OFFSET);</span>
<span class="p_add">+	data[1] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW2_OFFSET);</span>
 
<span class="p_add">+	if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG)) {</span>
 		/* Change Xilinx CAN data format to socketCAN data format */
 		if (cf-&gt;can_dlc &gt; 0)
 			*(__be32 *)(cf-&gt;data) = cpu_to_be32(data[0]);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index 4d2dc17fd31b..b554cc9e492d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -1037,7 +1037,7 @@</span> <span class="p_context"> static void igb_reset_q_vector(struct igb_adapter *adapter, int v_idx)</span>
 		adapter-&gt;tx_ring[q_vector-&gt;tx.ring-&gt;queue_index] = NULL;
 
 	if (q_vector-&gt;rx.ring)
<span class="p_del">-		adapter-&gt;tx_ring[q_vector-&gt;rx.ring-&gt;queue_index] = NULL;</span>
<span class="p_add">+		adapter-&gt;rx_ring[q_vector-&gt;rx.ring-&gt;queue_index] = NULL;</span>
 
 	netif_napi_del(&amp;q_vector-&gt;napi);
 
<span class="p_chunk">@@ -1208,6 +1208,8 @@</span> <span class="p_context"> static int igb_alloc_q_vector(struct igb_adapter *adapter,</span>
 	q_vector = adapter-&gt;q_vector[v_idx];
 	if (!q_vector)
 		q_vector = kzalloc(size, GFP_KERNEL);
<span class="p_add">+	else</span>
<span class="p_add">+		memset(q_vector, 0, size);</span>
 	if (!q_vector)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index c3e4da9e79ca..8067b8fbb0ee 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)</span>
 	 * payload data instead.
 	 */
 	usbnet_set_skb_tx_stats(skb_out, n,
<span class="p_del">-				ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
<span class="p_add">+				(long)ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
 
 	return skb_out;
 
<span class="p_header">diff --git a/drivers/net/wireless/rt2x00/rt2800usb.c b/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_header">index 8444313eabe2..8694dddcce9a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_chunk">@@ -1040,6 +1040,7 @@</span> <span class="p_context"> static struct usb_device_id rt2800usb_device_table[] = {</span>
 	{ USB_DEVICE(0x07d1, 0x3c17) },
 	{ USB_DEVICE(0x2001, 0x3317) },
 	{ USB_DEVICE(0x2001, 0x3c1b) },
<span class="p_add">+	{ USB_DEVICE(0x2001, 0x3c25) },</span>
 	/* Draytek */
 	{ USB_DEVICE(0x07fa, 0x7712) },
 	/* DVICO */
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 0398d3ea15b0..cdd0dd7a938a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,</span>
 
 	do {
 		status = usb_control_msg(udev, pipe, request, reqtype, value,
<span class="p_del">-					 index, pdata, len, 0); /*max. timeout*/</span>
<span class="p_add">+					 index, pdata, len, 1000);</span>
 		if (status &lt; 0) {
 			/* firmware download is checksumed, don&#39;t retry */
 			if ((value &gt;= FW_8192C_START_ADDRESS &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h</span>
<span class="p_header">index d48dea8fab1b..02c6973f24a3 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_gbl.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_gbl.h</span>
<span class="p_chunk">@@ -750,8 +750,6 @@</span> <span class="p_context"> extern void qla8044_set_idc_dontreset(struct scsi_qla_host *ha);</span>
 extern int qla8044_rd_direct(struct scsi_qla_host *vha, const uint32_t crb_reg);
 extern void qla8044_wr_direct(struct scsi_qla_host *vha,
 			      const uint32_t crb_reg, const uint32_t value);
<span class="p_del">-extern inline void qla8044_set_qsnt_ready(struct scsi_qla_host *vha);</span>
<span class="p_del">-extern inline void qla8044_need_reset_handler(struct scsi_qla_host *vha);</span>
 extern int qla8044_device_state_handler(struct scsi_qla_host *vha);
 extern void qla8044_clear_qsnt_ready(struct scsi_qla_host *vha);
 extern void qla8044_clear_drv_active(struct qla_hw_data *);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_nx2.c b/drivers/scsi/qla2xxx/qla_nx2.c</span>
<span class="p_header">index da9e3902f219..fdfd863305db 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_nx2.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_nx2.c</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> qla8044_rmw_crb_reg(struct scsi_qla_host *vha,</span>
 	return;
 }
 
<span class="p_del">-inline void</span>
<span class="p_add">+static inline void</span>
 qla8044_set_qsnt_ready(struct scsi_qla_host *vha)
 {
 	uint32_t qsnt_state;
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index ed2e99eca336..2e4708dff208 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1585,6 +1585,7 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 {
 	u64 start_lba = blk_rq_pos(scmd-&gt;request);
 	u64 end_lba = blk_rq_pos(scmd-&gt;request) + (scsi_bufflen(scmd) / 512);
<span class="p_add">+	u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
 	u64 bad_lba;
 	int info_valid;
 	/*
<span class="p_chunk">@@ -1606,16 +1607,9 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 	if (scsi_bufflen(scmd) &lt;= scmd-&gt;device-&gt;sector_size)
 		return 0;
 
<span class="p_del">-	if (scmd-&gt;device-&gt;sector_size &lt; 512) {</span>
<span class="p_del">-		/* only legitimate sector_size here is 256 */</span>
<span class="p_del">-		start_lba &lt;&lt;= 1;</span>
<span class="p_del">-		end_lba &lt;&lt;= 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* be careful ... don&#39;t want any overflows */</span>
<span class="p_del">-		unsigned int factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_del">-		do_div(start_lba, factor);</span>
<span class="p_del">-		do_div(end_lba, factor);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* be careful ... don&#39;t want any overflows */</span>
<span class="p_add">+	do_div(start_lba, factor);</span>
<span class="p_add">+	do_div(end_lba, factor);</span>
 
 	/* The bad lba was reported incorrectly, we have no idea where
 	 * the error is.
<span class="p_chunk">@@ -2182,8 +2176,7 @@</span> <span class="p_context"> got_data:</span>
 	if (sector_size != 512 &amp;&amp;
 	    sector_size != 1024 &amp;&amp;
 	    sector_size != 2048 &amp;&amp;
<span class="p_del">-	    sector_size != 4096 &amp;&amp;</span>
<span class="p_del">-	    sector_size != 256) {</span>
<span class="p_add">+	    sector_size != 4096) {</span>
 		sd_printk(KERN_NOTICE, sdkp, &quot;Unsupported sector size %d.\n&quot;,
 			  sector_size);
 		/*
<span class="p_chunk">@@ -2234,8 +2227,6 @@</span> <span class="p_context"> got_data:</span>
 		sdkp-&gt;capacity &lt;&lt;= 2;
 	else if (sector_size == 1024)
 		sdkp-&gt;capacity &lt;&lt;= 1;
<span class="p_del">-	else if (sector_size == 256)</span>
<span class="p_del">-		sdkp-&gt;capacity &gt;&gt;= 1;</span>
 
 	blk_queue_physical_block_size(sdp-&gt;request_queue,
 				      sdkp-&gt;physical_block_size);
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 97892f258043..3bb6646bb406 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1625,8 +1625,7 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 		break;
 	default:
 		vm_srb-&gt;data_in = UNKNOWN_TYPE;
<span class="p_del">-		vm_srb-&gt;win8_extension.srb_flags |= (SRB_FLAGS_DATA_IN |</span>
<span class="p_del">-						     SRB_FLAGS_DATA_OUT);</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.srb_flags |= SRB_FLAGS_NO_DATA_TRANSFER;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/spi/spi-bitbang.c b/drivers/spi/spi-bitbang.c</span>
<span class="p_header">index dc7d2c2d643e..fecdda270c5d 100644</span>
<span class="p_header">--- a/drivers/spi/spi-bitbang.c</span>
<span class="p_header">+++ b/drivers/spi/spi-bitbang.c</span>
<span class="p_chunk">@@ -184,7 +184,6 @@</span> <span class="p_context"> int spi_bitbang_setup(struct spi_device *spi)</span>
 {
 	struct spi_bitbang_cs	*cs = spi-&gt;controller_state;
 	struct spi_bitbang	*bitbang;
<span class="p_del">-	int			retval;</span>
 	unsigned long		flags;
 
 	bitbang = spi_master_get_devdata(spi-&gt;master);
<span class="p_chunk">@@ -201,9 +200,11 @@</span> <span class="p_context"> int spi_bitbang_setup(struct spi_device *spi)</span>
 	if (!cs-&gt;txrx_word)
 		return -EINVAL;
 
<span class="p_del">-	retval = bitbang-&gt;setup_transfer(spi, NULL);</span>
<span class="p_del">-	if (retval &lt; 0)</span>
<span class="p_del">-		return retval;</span>
<span class="p_add">+	if (bitbang-&gt;setup_transfer) {</span>
<span class="p_add">+		int retval = bitbang-&gt;setup_transfer(spi, NULL);</span>
<span class="p_add">+		if (retval &lt; 0)</span>
<span class="p_add">+			return retval;</span>
<span class="p_add">+	}</span>
 
 	dev_dbg(&amp;spi-&gt;dev, &quot;%s, %u nsec/bit\n&quot;, __func__, 2 * cs-&gt;nsecs);
 
<span class="p_chunk">@@ -299,9 +300,11 @@</span> <span class="p_context"> static int spi_bitbang_transfer_one(struct spi_master *master,</span>
 
 		/* init (-1) or override (1) transfer params */
 		if (do_setup != 0) {
<span class="p_del">-			status = bitbang-&gt;setup_transfer(spi, t);</span>
<span class="p_del">-			if (status &lt; 0)</span>
<span class="p_del">-				break;</span>
<span class="p_add">+			if (bitbang-&gt;setup_transfer) {</span>
<span class="p_add">+				status = bitbang-&gt;setup_transfer(spi, t);</span>
<span class="p_add">+				if (status &lt; 0)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+			}</span>
 			if (do_setup == -1)
 				do_setup = 0;
 		}
<span class="p_header">diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">index 10ce2c1805bb..233e0768d1ef 100644</span>
<span class="p_header">--- a/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">+++ b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 	unsigned int start_flag;
 	unsigned int payload_size;
 	unsigned short packet_type;
<span class="p_del">-	int dummy_cnt;</span>
<span class="p_add">+	int total_len;</span>
 	u32 packet_size_sum = r-&gt;offset;
 	int index;
 	int ret = TO_HOST_INVALID_PACKET;
<span class="p_chunk">@@ -176,10 +176,10 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		dummy_cnt = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
<span class="p_add">+		total_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
 
 		if (len - packet_size_sum &lt;
<span class="p_del">-			MUX_HEADER_SIZE + payload_size + dummy_cnt) {</span>
<span class="p_add">+			total_len) {</span>
 			pr_err(&quot;invalid payload : %d %d %04x\n&quot;,
 			       payload_size, len, packet_type);
 			break;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		packet_size_sum += MUX_HEADER_SIZE + payload_size + dummy_cnt;</span>
<span class="p_add">+		packet_size_sum += total_len;</span>
 		if (len - packet_size_sum &lt;= MUX_HEADER_SIZE + 2) {
 			ret = r-&gt;callback(NULL,
 					0,
<span class="p_chunk">@@ -361,7 +361,6 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	struct mux_pkt_header *mux_header;
 	struct mux_tx *t = NULL;
 	static u32 seq_num = 1;
<span class="p_del">-	int dummy_cnt;</span>
 	int total_len;
 	int ret;
 	unsigned long flags;
<span class="p_chunk">@@ -374,9 +373,7 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 
 	spin_lock_irqsave(&amp;mux_dev-&gt;write_lock, flags);
 
<span class="p_del">-	dummy_cnt = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
<span class="p_del">-</span>
<span class="p_del">-	total_len = len + MUX_HEADER_SIZE + dummy_cnt;</span>
<span class="p_add">+	total_len = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
 
 	t = alloc_mux_tx(total_len);
 	if (!t) {
<span class="p_chunk">@@ -392,7 +389,8 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	mux_header-&gt;packet_type = __cpu_to_le16(packet_type[tty_index]);
 
 	memcpy(t-&gt;buf+MUX_HEADER_SIZE, data, len);
<span class="p_del">-	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, dummy_cnt);</span>
<span class="p_add">+	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, total_len - MUX_HEADER_SIZE -</span>
<span class="p_add">+	       len);</span>
 
 	t-&gt;len = total_len;
 	t-&gt;callback = cb;
<span class="p_header">diff --git a/drivers/staging/rtl8192e/rtllib.h b/drivers/staging/rtl8192e/rtllib.h</span>
<span class="p_header">index 83f5f57373a6..59dc0782df44 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192e/rtllib.h</span>
<span class="p_header">+++ b/drivers/staging/rtl8192e/rtllib.h</span>
<span class="p_chunk">@@ -2761,7 +2761,6 @@</span> <span class="p_context"> extern void rtllib_stop_scan(struct rtllib_device *ieee);</span>
 extern bool rtllib_act_scanning(struct rtllib_device *ieee, bool sync_scan);
 extern void rtllib_stop_scan_syncro(struct rtllib_device *ieee);
 extern void rtllib_start_scan_syncro(struct rtllib_device *ieee, u8 is_mesh);
<span class="p_del">-extern inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee);</span>
 extern u8 MgntQuery_MgntFrameTxRate(struct rtllib_device *ieee);
 extern void rtllib_sta_ps_send_null_frame(struct rtllib_device *ieee,
 					  short pwr);
<span class="p_chunk">@@ -2943,12 +2942,12 @@</span> <span class="p_context"> void rtllib_softmac_scan_syncro(struct rtllib_device *ieee, u8 is_mesh);</span>
 
 extern const long rtllib_wlan_frequencies[];
 
<span class="p_del">-extern inline void rtllib_increment_scans(struct rtllib_device *ieee)</span>
<span class="p_add">+static inline void rtllib_increment_scans(struct rtllib_device *ieee)</span>
 {
 	ieee-&gt;scans++;
 }
 
<span class="p_del">-extern inline int rtllib_get_scans(struct rtllib_device *ieee)</span>
<span class="p_add">+static inline int rtllib_get_scans(struct rtllib_device *ieee)</span>
 {
 	return ieee-&gt;scans;
 }
<span class="p_header">diff --git a/drivers/staging/rtl8192e/rtllib_softmac.c b/drivers/staging/rtl8192e/rtllib_softmac.c</span>
<span class="p_header">index 684ceed17232..79524c542f0f 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192e/rtllib_softmac.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8192e/rtllib_softmac.c</span>
<span class="p_chunk">@@ -341,7 +341,7 @@</span> <span class="p_context"> inline void softmac_ps_mgmt_xmit(struct sk_buff *skb,</span>
 	}
 }
 
<span class="p_del">-inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)</span>
<span class="p_add">+static inline struct sk_buff *rtllib_probe_req(struct rtllib_device *ieee)</span>
 {
 	unsigned int len, rate_len;
 	u8 *tag;
<span class="p_header">diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_header">index e0aa069fe9b1..1040bab9702a 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_header">+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h</span>
<span class="p_chunk">@@ -2238,7 +2238,7 @@</span> <span class="p_context"> static inline void *ieee80211_priv(struct net_device *dev)</span>
 	return ((struct ieee80211_device *)netdev_priv(dev))-&gt;priv;
 }
 
<span class="p_del">-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
<span class="p_add">+static inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 &amp;&amp; essid[0] == &#39; &#39;)
<span class="p_chunk">@@ -2254,7 +2254,7 @@</span> <span class="p_context"> extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
 	return 1;
 }
 
<span class="p_del">-extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)</span>
<span class="p_add">+static inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mode)</span>
 {
 	/*
 	 * It is possible for both access points and our device to support
<span class="p_chunk">@@ -2280,7 +2280,7 @@</span> <span class="p_context"> extern inline int ieee80211_is_valid_mode(struct ieee80211_device *ieee, int mod</span>
 	return 0;
 }
 
<span class="p_del">-extern inline int ieee80211_get_hdrlen(u16 fc)</span>
<span class="p_add">+static inline int ieee80211_get_hdrlen(u16 fc)</span>
 {
 	int hdrlen = IEEE80211_3ADDR_LEN;
 
<span class="p_chunk">@@ -2564,12 +2564,12 @@</span> <span class="p_context"> void ieee80211_softmac_scan_syncro(struct ieee80211_device *ieee);</span>
 
 extern const long ieee80211_wlan_frequencies[];
 
<span class="p_del">-extern inline void ieee80211_increment_scans(struct ieee80211_device *ieee)</span>
<span class="p_add">+static inline void ieee80211_increment_scans(struct ieee80211_device *ieee)</span>
 {
 	ieee-&gt;scans++;
 }
 
<span class="p_del">-extern inline int ieee80211_get_scans(struct ieee80211_device *ieee)</span>
<span class="p_add">+static inline int ieee80211_get_scans(struct ieee80211_device *ieee)</span>
 {
 	return ieee-&gt;scans;
 }
<span class="p_header">diff --git a/drivers/staging/rtl8712/ieee80211.h b/drivers/staging/rtl8712/ieee80211.h</span>
<span class="p_header">index da4000e49da6..8269be80437a 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/ieee80211.h</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/ieee80211.h</span>
<span class="p_chunk">@@ -734,7 +734,7 @@</span> <span class="p_context"> enum ieee80211_state {</span>
 #define IEEE_G            (1&lt;&lt;2)
 #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
 
<span class="p_del">-extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
<span class="p_add">+static inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
 {
 	/* Single white space is for Linksys APs */
 	if (essid_len == 1 &amp;&amp; essid[0] == &#39; &#39;)
<span class="p_chunk">@@ -748,7 +748,7 @@</span> <span class="p_context"> extern inline int ieee80211_is_empty_essid(const char *essid, int essid_len)</span>
 	return 1;
 }
 
<span class="p_del">-extern inline int ieee80211_get_hdrlen(u16 fc)</span>
<span class="p_add">+static inline int ieee80211_get_hdrlen(u16 fc)</span>
 {
 	int hdrlen = 24;
 
<span class="p_header">diff --git a/drivers/staging/wlags49_h2/wl_internal.h b/drivers/staging/wlags49_h2/wl_internal.h</span>
<span class="p_header">index 78129e93920f..1ecb5cb44bd5 100644</span>
<span class="p_header">--- a/drivers/staging/wlags49_h2/wl_internal.h</span>
<span class="p_header">+++ b/drivers/staging/wlags49_h2/wl_internal.h</span>
<span class="p_chunk">@@ -1013,7 +1013,7 @@</span> <span class="p_context"> static inline void wl_unlock(struct wl_private *lp,</span>
 /* Interrupt enable disable functions                               */
 /********************************************************************/
 
<span class="p_del">-extern inline void wl_act_int_on(struct wl_private *lp)</span>
<span class="p_add">+static inline void wl_act_int_on(struct wl_private *lp)</span>
 {
 	/*
 	 * Only do something when the driver is handling
<span class="p_chunk">@@ -1025,7 +1025,7 @@</span> <span class="p_context"> extern inline void wl_act_int_on(struct wl_private *lp)</span>
 	}
 }
 
<span class="p_del">-extern inline void wl_act_int_off(struct wl_private *lp)</span>
<span class="p_add">+static inline void wl_act_int_off(struct wl_private *lp)</span>
 {
 	/*
 	 * Only do something when the driver is handling
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index 7a986d401d3f..fe88c1bcffbb 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -520,6 +520,7 @@</span> <span class="p_context"> static int pscsi_configure_device(struct se_device *dev)</span>
 					&quot; pdv_host_id: %d\n&quot;, pdv-&gt;pdv_host_id);
 				return -EINVAL;
 			}
<span class="p_add">+			pdv-&gt;pdv_lld_host = sh;</span>
 		}
 	} else {
 		if (phv-&gt;phv_mode == PHV_VIRTUAL_HOST_ID) {
<span class="p_chunk">@@ -602,6 +603,8 @@</span> <span class="p_context"> static void pscsi_free_device(struct se_device *dev)</span>
 		if ((phv-&gt;phv_mode == PHV_LLD_SCSI_HOST_NO) &amp;&amp;
 		    (phv-&gt;phv_lld_host != NULL))
 			scsi_host_put(phv-&gt;phv_lld_host);
<span class="p_add">+		else if (pdv-&gt;pdv_lld_host)</span>
<span class="p_add">+			scsi_host_put(pdv-&gt;pdv_lld_host);</span>
 
 		if ((sd-&gt;type == TYPE_DISK) || (sd-&gt;type == TYPE_ROM))
 			scsi_device_put(sd);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.h b/drivers/target/target_core_pscsi.h</span>
<span class="p_header">index 1bd757dff8ee..820d3052b775 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.h</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> struct pscsi_dev_virt {</span>
 	int	pdv_lun_id;
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
<span class="p_add">+	struct Scsi_Host *pdv_lld_host;</span>
 } ____cacheline_aligned;
 
 typedef enum phv_modes {
<span class="p_header">diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c</span>
<span class="p_header">index 9d1420acb391..e6f1acc71996 100644</span>
<span class="p_header">--- a/drivers/thermal/armada_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/armada_thermal.c</span>
<span class="p_chunk">@@ -240,9 +240,9 @@</span> <span class="p_context"> static const struct armada_thermal_data armada380_data = {</span>
 	.is_valid_shift = 10,
 	.temp_shift = 0,
 	.temp_mask = 0x3ff,
<span class="p_del">-	.coef_b = 1169498786UL,</span>
<span class="p_del">-	.coef_m = 2000000UL,</span>
<span class="p_del">-	.coef_div = 4289,</span>
<span class="p_add">+	.coef_b = 2931108200UL,</span>
<span class="p_add">+	.coef_m = 5000000UL,</span>
<span class="p_add">+	.coef_div = 10502,</span>
 	.inverted = true,
 };
 
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 8eb65f26fcae..59a7da7c6c5e 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 			return -ENOMEM;
 	}
 
<span class="p_del">-	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0);</span>
<span class="p_add">+	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);</span>
 	info-&gt;vtermno = HVC_COOKIE;
 
 	spin_lock(&amp;xencons_lock);
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index 2ebe47b78a3e..5bfd8076b21f 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -3166,7 +3166,7 @@</span> <span class="p_context"> static int gsmtty_break_ctl(struct tty_struct *tty, int state)</span>
 	return gsmtty_modem_update(dlci, encode);
 }
 
<span class="p_del">-static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
<span class="p_add">+static void gsmtty_cleanup(struct tty_struct *tty)</span>
 {
 	struct gsm_dlci *dlci = tty-&gt;driver_data;
 	struct gsm_mux *gsm = dlci-&gt;gsm;
<span class="p_chunk">@@ -3174,7 +3174,6 @@</span> <span class="p_context"> static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
 	dlci_put(dlci);
 	dlci_put(gsm-&gt;dlci[0]);
 	mux_put(gsm);
<span class="p_del">-	driver-&gt;ttys[tty-&gt;index] = NULL;</span>
 }
 
 /* Virtual ttys for the demux */
<span class="p_chunk">@@ -3195,7 +3194,7 @@</span> <span class="p_context"> static const struct tty_operations gsmtty_ops = {</span>
 	.tiocmget		= gsmtty_tiocmget,
 	.tiocmset		= gsmtty_tiocmset,
 	.break_ctl		= gsmtty_break_ctl,
<span class="p_del">-	.remove			= gsmtty_remove,</span>
<span class="p_add">+	.cleanup		= gsmtty_cleanup,</span>
 };
 
 
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index 45a94a77d986..451296b2b71f 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -1297,6 +1297,7 @@</span> <span class="p_context"> static void purge_configs_funcs(struct gadget_info *gi)</span>
 			}
 		}
 		c-&gt;next_interface_id = 0;
<span class="p_add">+		memset(c-&gt;interface, 0, sizeof(c-&gt;interface));</span>
 		c-&gt;superspeed = 0;
 		c-&gt;highspeed = 0;
 		c-&gt;fullspeed = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index f176280e2fcf..3303132d875e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2061,8 +2061,13 @@</span> <span class="p_context"> static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
<span class="p_add">+		frame-&gt;status = -EPROTO;</span>
<span class="p_add">+		skip_td = true;</span>
<span class="p_add">+		break;</span>
 	case COMP_TX_ERR:
 		frame-&gt;status = -EPROTO;
<span class="p_add">+		if (event_trb != td-&gt;last_trb)</span>
<span class="p_add">+			return 0;</span>
 		skip_td = true;
 		break;
 	case COMP_STOP:
<span class="p_chunk">@@ -2670,7 +2675,7 @@</span> <span class="p_context"> irqreturn_t xhci_irq(struct usb_hcd *hcd)</span>
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&amp;xhci-&gt;lock);
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		return IRQ_HANDLED;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index d40a72b69f26..a70e45c7c440 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1267,7 +1267,7 @@</span> <span class="p_context"> union xhci_trb {</span>
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
<span class="p_del">-#define TRBS_PER_SEGMENT	64</span>
<span class="p_add">+#define TRBS_PER_SEGMENT	256</span>
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 8d114b9733ed..02de4cf48a5b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -127,6 +127,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index e9bad928039f..521959370b66 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -61,7 +61,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },</span>
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index 71fd9da1d6e7..e3b7af8adfb7 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"></span>
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
<span class="p_del">-/* Samsung I330 phone cradle */</span>
<span class="p_del">-#define SAMSUNG_VENDOR_ID	0x04e8</span>
<span class="p_del">-#define SAMSUNG_PRODUCT_ID	0x8001</span>
<span class="p_del">-</span>
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index bf2bd40e5f2a..60afb39eb73c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID),</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index 40528ca4d274..1b79286e385a 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -760,6 +760,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
<span class="p_add">+/* Reported by Christian Schaller &lt;cschalle@redhat.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,</span>
<span class="p_add">+		&quot;LaCie&quot;,</span>
<span class="p_add">+		&quot;External HDD&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don&#39;t.
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 31ac2eec06e4..bb2aab85f8e9 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -956,7 +956,7 @@</span> <span class="p_context"> unsigned xen_evtchn_nr_channels(void)</span>
 }
 EXPORT_SYMBOL_GPL(xen_evtchn_nr_channels);
 
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)</span>
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq, ret;
<span class="p_chunk">@@ -970,8 +970,12 @@</span> <span class="p_context"> int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
 		if (irq &lt; 0)
 			goto out;
 
<span class="p_del">-		irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_del">-					      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		if (percpu)</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_add">+						      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip,</span>
<span class="p_add">+						      handle_edge_irq, &quot;virq&quot;);</span>
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
<span class="p_chunk">@@ -1061,7 +1065,7 @@</span> <span class="p_context"> int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,</span>
 {
 	int irq, retval;
 
<span class="p_del">-	irq = bind_virq_to_irq(virq, cpu);</span>
<span class="p_add">+	irq = bind_virq_to_irq(virq, cpu, irqflags &amp; IRQF_PERCPU);</span>
 	if (irq &lt; 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 44bdf7b200c3..c13a138c1016 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -820,7 +820,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 			total_size = total_mapping_size(elf_phdata,
 							loc-&gt;elf_ex.e_phnum);
 			if (!total_size) {
<span class="p_del">-				error = -EINVAL;</span>
<span class="p_add">+				retval = -EINVAL;</span>
 				goto out_free_dentry;
 			}
 		}
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index e2dc0874a1f0..05a041a134c4 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1132,13 +1132,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename. */
 		if (need_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 68a0843250c9..993ed0aba99a 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -662,6 +662,9 @@</span> <span class="p_context"> int setup_arg_pages(struct linux_binprm *bprm,</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	/* Make sure we didn&#39;t let the argument array grow too large. */
 	if (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">index 0074e0d23d6e..44c89188c62c 100644</span>
<span class="p_header">--- a/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">+++ b/fs/ext4/ext4_jbd2.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)</span>
 		ext4_put_nojournal(handle);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!handle-&gt;h_transaction) {</span>
<span class="p_add">+		err = jbd2_journal_stop(handle);</span>
<span class="p_add">+		return handle-&gt;h_err ? handle-&gt;h_err : err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sb = handle-&gt;h_transaction-&gt;t_journal-&gt;j_private;
 	err = handle-&gt;h_err;
 	rc = jbd2_journal_stop(handle);
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 99d74306e770..a2c5bb7e71bb 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
 	ext4_lblk_t last = lblock + len - 1;
 
<span class="p_del">-	if (lblock &gt; last)</span>
<span class="p_add">+	if (len == 0 || lblock &gt; last)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_header">diff --git a/fs/fhandle.c b/fs/fhandle.c</span>
<span class="p_header">index 999ff5c3cab0..d59712dfa3e7 100644</span>
<span class="p_header">--- a/fs/fhandle.c</span>
<span class="p_header">+++ b/fs/fhandle.c</span>
<span class="p_chunk">@@ -195,8 +195,9 @@</span> <span class="p_context"> static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,</span>
 		goto out_err;
 	}
 	/* copy the full handle */
<span class="p_del">-	if (copy_from_user(handle, ufh,</span>
<span class="p_del">-			   sizeof(struct file_handle) +</span>
<span class="p_add">+	*handle = f_handle;</span>
<span class="p_add">+	if (copy_from_user(&amp;handle-&gt;f_handle,</span>
<span class="p_add">+			   &amp;ufh-&gt;f_handle,</span>
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
<span class="p_header">diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c</span>
<span class="p_header">index bcbef08a4d8f..a5f72a36c6c8 100644</span>
<span class="p_header">--- a/fs/jbd2/recovery.c</span>
<span class="p_header">+++ b/fs/jbd2/recovery.c</span>
<span class="p_chunk">@@ -839,15 +839,23 @@</span> <span class="p_context"> static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,</span>
 {
 	jbd2_journal_revoke_header_t *header;
 	int offset, max;
<span class="p_add">+	int csum_size = 0;</span>
<span class="p_add">+	__u32 rcount;</span>
 	int record_len = 4;
 
 	header = (jbd2_journal_revoke_header_t *) bh-&gt;b_data;
 	offset = sizeof(jbd2_journal_revoke_header_t);
<span class="p_del">-	max = be32_to_cpu(header-&gt;r_count);</span>
<span class="p_add">+	rcount = be32_to_cpu(header-&gt;r_count);</span>
 
 	if (!jbd2_revoke_block_csum_verify(journal, header))
 		return -EINVAL;
 
<span class="p_add">+	if (jbd2_journal_has_csum_v2or3(journal))</span>
<span class="p_add">+		csum_size = sizeof(struct jbd2_journal_revoke_tail);</span>
<span class="p_add">+	if (rcount &gt; journal-&gt;j_blocksize - csum_size)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	max = rcount;</span>
<span class="p_add">+</span>
 	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))
 		record_len = 8;
 
<span class="p_header">diff --git a/fs/jbd2/revoke.c b/fs/jbd2/revoke.c</span>
<span class="p_header">index d5e95a175c92..8ecf9b92f163 100644</span>
<span class="p_header">--- a/fs/jbd2/revoke.c</span>
<span class="p_header">+++ b/fs/jbd2/revoke.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 {
 	int csum_size = 0;
 	struct buffer_head *descriptor;
<span class="p_del">-	int offset;</span>
<span class="p_add">+	int sz, offset;</span>
 	journal_header_t *header;
 
 	/* If we are already aborting, this all becomes a noop.  We
<span class="p_chunk">@@ -600,9 +600,14 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 	if (jbd2_journal_has_csum_v2or3(journal))
 		csum_size = sizeof(struct jbd2_journal_revoke_tail);
 
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
<span class="p_add">+		sz = 8;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sz = 4;</span>
<span class="p_add">+</span>
 	/* Make sure we have a descriptor with space left for the record */
 	if (descriptor) {
<span class="p_del">-		if (offset &gt;= journal-&gt;j_blocksize - csum_size) {</span>
<span class="p_add">+		if (offset + sz &gt; journal-&gt;j_blocksize - csum_size) {</span>
 			flush_descriptor(journal, descriptor, offset, write_op);
 			descriptor = NULL;
 		}
<span class="p_chunk">@@ -625,16 +630,13 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 		*descriptorp = descriptor;
 	}
 
<span class="p_del">-	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {</span>
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
 		* ((__be64 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be64(record-&gt;blocknr);
<span class="p_del">-		offset += 8;</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else</span>
 		* ((__be32 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be32(record-&gt;blocknr);
<span class="p_del">-		offset += 4;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	offset += sz;</span>
 
 	*offsetp = offset;
 }
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 6f0f590cc5a3..99ebbd72a064 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -551,7 +551,6 @@</span> <span class="p_context"> int jbd2_journal_extend(handle_t *handle, int nblocks)</span>
 	int result;
 	int wanted;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -627,7 +626,6 @@</span> <span class="p_context"> int jbd2__journal_restart(handle_t *handle, int nblocks, gfp_t gfp_mask)</span>
 	tid_t		tid;
 	int		need_to_start, ret;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	/* If we&#39;ve had an abort of any type, don&#39;t even think about
 	 * actually doing the restart! */
 	if (is_handle_aborted(handle))
<span class="p_chunk">@@ -791,7 +789,6 @@</span> <span class="p_context"> do_get_write_access(handle_t *handle, struct journal_head *jh,</span>
 	int need_copy = 0;
 	unsigned long start_lock, time_lock;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1057,7 +1054,6 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 	int err;
 
 	jbd_debug(5, &quot;journal_head %p\n&quot;, jh);
<span class="p_del">-	WARN_ON(!transaction);</span>
 	err = -EROFS;
 	if (is_handle_aborted(handle))
 		goto out;
<span class="p_chunk">@@ -1272,7 +1268,6 @@</span> <span class="p_context"> int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)</span>
 	struct journal_head *jh;
 	int ret = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1403,7 +1398,6 @@</span> <span class="p_context"> int jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)</span>
 	int err = 0;
 	int was_modified = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1536,8 +1530,22 @@</span> <span class="p_context"> int jbd2_journal_stop(handle_t *handle)</span>
 	tid_t tid;
 	pid_t pid;
 
<span class="p_del">-	if (!transaction)</span>
<span class="p_del">-		goto free_and_exit;</span>
<span class="p_add">+	if (!transaction) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Handle is already detached from the transaction so</span>
<span class="p_add">+		 * there is nothing to do other than decrease a refcount,</span>
<span class="p_add">+		 * or free the handle if refcount drops to zero</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (--handle-&gt;h_ref &gt; 0) {</span>
<span class="p_add">+			jbd_debug(4, &quot;h_ref %d -&gt; %d\n&quot;, handle-&gt;h_ref + 1,</span>
<span class="p_add">+							 handle-&gt;h_ref);</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (handle-&gt;h_rsv_handle)</span>
<span class="p_add">+				jbd2_free_handle(handle-&gt;h_rsv_handle);</span>
<span class="p_add">+			goto free_and_exit;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	journal = transaction-&gt;t_journal;
 
 	J_ASSERT(journal_current_handle() == handle);
<span class="p_chunk">@@ -2379,7 +2387,6 @@</span> <span class="p_context"> int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode)</span>
 	transaction_t *transaction = handle-&gt;h_transaction;
 	journal_t *journal;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index e34d9842be3e..a666b6bb0433 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3661,10 +3661,17 @@</span> <span class="p_context"> static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_s</span>
 	return nfserr_old_stateid;
 }
 
<span class="p_add">+static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ols-&gt;st_stateowner-&gt;so_is_open_owner &amp;&amp;</span>
<span class="p_add">+	    !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	return nfs_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 {
 	struct nfs4_stid *s;
<span class="p_del">-	struct nfs4_ol_stateid *ols;</span>
 	__be32 status;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
<span class="p_chunk">@@ -3691,12 +3698,8 @@</span> <span class="p_context"> static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)</span>
 		return nfserr_deleg_revoked;
 	case NFS4_OPEN_STID:
 	case NFS4_LOCK_STID:
<span class="p_del">-		ols = openlockstateid(s);</span>
<span class="p_del">-		if (ols-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-	    			&amp;&amp; !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags</span>
<span class="p_del">-						&amp; NFS4_OO_CONFIRMED))</span>
<span class="p_del">-			return nfserr_bad_stateid;</span>
<span class="p_del">-		return nfs_ok;</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(openlockstateid(s));</span>
<span class="p_add">+		return status;</span>
 	default:
 		printk(&quot;unknown stateid type %x\n&quot;, s-&gt;sc_type);
 	case NFS4_CLOSED_STID:
<span class="p_chunk">@@ -3783,8 +3786,8 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,</span>
 		status = nfs4_check_fh(current_fh, stp);
 		if (status)
 			goto out;
<span class="p_del">-		if (stp-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-		    &amp;&amp; !(openowner(stp-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_add">+		if (status)</span>
 			goto out;
 		status = nfs4_check_openmode(stp, flags);
 		if (status)
<span class="p_header">diff --git a/fs/omfs/inode.c b/fs/omfs/inode.c</span>
<span class="p_header">index ec58c7659183..a6f4e60423a9 100644</span>
<span class="p_header">--- a/fs/omfs/inode.c</span>
<span class="p_header">+++ b/fs/omfs/inode.c</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> nomem:</span>
 }
 
 enum {
<span class="p_del">-	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask</span>
<span class="p_add">+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err</span>
 };
 
 static const match_table_t tokens = {
<span class="p_chunk">@@ -370,6 +370,7 @@</span> <span class="p_context"> static const match_table_t tokens = {</span>
 	{Opt_umask, &quot;umask=%o&quot;},
 	{Opt_dmask, &quot;dmask=%o&quot;},
 	{Opt_fmask, &quot;fmask=%o&quot;},
<span class="p_add">+	{Opt_err, NULL},</span>
 };
 
 static int parse_options(char *options, struct omfs_sb_info *sbi)
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index bf08a9fbb97e..9a46e23cb769 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -1365,6 +1365,7 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 	struct udf_sb_info *sbi = UDF_SB(inode-&gt;i_sb);
 	struct udf_inode_info *iinfo = UDF_I(inode);
 	unsigned int link_count;
<span class="p_add">+	int bs = inode-&gt;i_sb-&gt;s_blocksize;</span>
 
 	fe = (struct fileEntry *)bh-&gt;b_data;
 	efe = (struct extendedFileEntry *)bh-&gt;b_data;
<span class="p_chunk">@@ -1385,41 +1386,38 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 	if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {
 		iinfo-&gt;i_efe = 1;
 		iinfo-&gt;i_use = 0;
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs -</span>
 					sizeof(struct extendedFileEntry))) {
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct extendedFileEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					sizeof(struct extendedFileEntry));</span>
<span class="p_add">+		       bs - sizeof(struct extendedFileEntry));</span>
 	} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {
 		iinfo-&gt;i_efe = 0;
 		iinfo-&gt;i_use = 0;
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-						sizeof(struct fileEntry))) {</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs - sizeof(struct fileEntry))) {</span>
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct fileEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize - sizeof(struct fileEntry));</span>
<span class="p_add">+		       bs - sizeof(struct fileEntry));</span>
 	} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {
 		iinfo-&gt;i_efe = 0;
 		iinfo-&gt;i_use = 1;
 		iinfo-&gt;i_lenAlloc = le32_to_cpu(
 				((struct unallocSpaceEntry *)bh-&gt;b_data)-&gt;
 				 lengthAllocDescs);
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs -</span>
 					sizeof(struct unallocSpaceEntry))) {
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct unallocSpaceEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					sizeof(struct unallocSpaceEntry));</span>
<span class="p_add">+		       bs - sizeof(struct unallocSpaceEntry));</span>
 		return;
 	}
 
<span class="p_chunk">@@ -1496,6 +1494,19 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 		iinfo-&gt;i_checkpoint = le32_to_cpu(efe-&gt;checkpoint);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Sanity check length of allocation descriptors and extended attrs to</span>
<span class="p_add">+	 * avoid integer overflows</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iinfo-&gt;i_lenEAttr &gt; bs || iinfo-&gt;i_lenAlloc &gt; bs) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Now do exact checks */</span>
<span class="p_add">+	if (udf_file_entry_alloc_offset(inode) + iinfo-&gt;i_lenAlloc &gt; bs) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	/* Sanity checks for files in ICB so that we don&#39;t get confused later */
 	if (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
 		/*
<span class="p_chunk">@@ -1507,8 +1518,7 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 			return;
 		}
 		/* File in ICB has to fit in there... */
<span class="p_del">-		if (inode-&gt;i_size &gt; inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					udf_file_entry_alloc_offset(inode)) {</span>
<span class="p_add">+		if (inode-&gt;i_size &gt; bs - udf_file_entry_alloc_offset(inode)) {</span>
 			make_bad_inode(inode);
 			return;
 		}
<span class="p_header">diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">index 09480c57f069..ced1dd9dd095 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_chunk">@@ -382,23 +382,31 @@</span> <span class="p_context"> xfs_attr3_root_inactive(</span>
 	return error;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * xfs_attr_inactive kills all traces of an attribute fork on an inode. It</span>
<span class="p_add">+ * removes both the on-disk and in-memory inode fork. Note that this also has to</span>
<span class="p_add">+ * handle the condition of inodes without attributes but with an attribute fork</span>
<span class="p_add">+ * configured, so we can&#39;t use xfs_inode_hasattr() here.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The in-memory attribute fork is removed even on error.</span>
<span class="p_add">+ */</span>
 int
<span class="p_del">-xfs_attr_inactive(xfs_inode_t *dp)</span>
<span class="p_add">+xfs_attr_inactive(</span>
<span class="p_add">+	struct xfs_inode	*dp)</span>
 {
<span class="p_del">-	xfs_trans_t *trans;</span>
<span class="p_del">-	xfs_mount_t *mp;</span>
<span class="p_del">-	int error;</span>
<span class="p_add">+	struct xfs_trans	*trans;</span>
<span class="p_add">+	struct xfs_mount	*mp;</span>
<span class="p_add">+	int			cancel_flags = 0;</span>
<span class="p_add">+	int			lock_mode = XFS_ILOCK_SHARED;</span>
<span class="p_add">+	int			error = 0;</span>
 
 	mp = dp-&gt;i_mount;
 	ASSERT(! XFS_NOT_DQATTACHED(mp, dp));
 
<span class="p_del">-	xfs_ilock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_del">-	if (!xfs_inode_hasattr(dp) ||</span>
<span class="p_del">-	    dp-&gt;i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_del">-		xfs_iunlock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_add">+	xfs_ilock(dp, lock_mode);</span>
<span class="p_add">+	if (!XFS_IFORK_Q(dp))</span>
<span class="p_add">+		goto out_destroy_fork;</span>
<span class="p_add">+	xfs_iunlock(dp, lock_mode);</span>
 
 	/*
 	 * Start our first transaction of the day.
<span class="p_chunk">@@ -410,13 +418,18 @@</span> <span class="p_context"> xfs_attr_inactive(xfs_inode_t *dp)</span>
 	 * the inode in every transaction to let it float upward through
 	 * the log.
 	 */
<span class="p_add">+	lock_mode = 0;</span>
 	trans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);
 	error = xfs_trans_reserve(trans, &amp;M_RES(mp)-&gt;tr_attrinval, 0, 0);
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		xfs_trans_cancel(trans, 0);</span>
<span class="p_del">-		return(error);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	xfs_ilock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		goto out_cancel;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_mode = XFS_ILOCK_EXCL;</span>
<span class="p_add">+	cancel_flags = XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT;</span>
<span class="p_add">+	xfs_ilock(dp, lock_mode);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!XFS_IFORK_Q(dp))</span>
<span class="p_add">+		goto out_cancel;</span>
 
 	/*
 	 * No need to make quota reservations here. We expect to release some
<span class="p_chunk">@@ -424,29 +437,31 @@</span> <span class="p_context"> xfs_attr_inactive(xfs_inode_t *dp)</span>
 	 */
 	xfs_trans_ijoin(trans, dp, 0);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Decide on what work routines to call based on the inode size.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!xfs_inode_hasattr(dp) ||</span>
<span class="p_del">-	    dp-&gt;i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_del">-		error = 0;</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	/* invalidate and truncate the attribute fork extents */</span>
<span class="p_add">+	if (dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_add">+		error = xfs_attr3_root_inactive(&amp;trans, dp);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out_cancel;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = xfs_itruncate_extents(&amp;trans, dp, XFS_ATTR_FORK, 0);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out_cancel;</span>
 	}
<span class="p_del">-	error = xfs_attr3_root_inactive(&amp;trans, dp);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
 
<span class="p_del">-	error = xfs_itruncate_extents(&amp;trans, dp, XFS_ATTR_FORK, 0);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	/* Reset the attribute fork - this also destroys the in-core fork */</span>
<span class="p_add">+	xfs_attr_fork_remove(dp, trans);</span>
 
 	error = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_del">-</span>
<span class="p_add">+	xfs_iunlock(dp, lock_mode);</span>
 	return(error);
 
<span class="p_del">-out:</span>
<span class="p_del">-	xfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);</span>
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_add">+out_cancel:</span>
<span class="p_add">+	xfs_trans_cancel(trans, cancel_flags);</span>
<span class="p_add">+out_destroy_fork:</span>
<span class="p_add">+	/* kill the in-core attr fork before we drop the inode lock */</span>
<span class="p_add">+	if (dp-&gt;i_afp)</span>
<span class="p_add">+		xfs_idestroy_fork(dp, XFS_ATTR_FORK);</span>
<span class="p_add">+	if (lock_mode)</span>
<span class="p_add">+		xfs_iunlock(dp, lock_mode);</span>
 	return(error);
 }
<span class="p_header">diff --git a/fs/xfs/xfs_attr_leaf.c b/fs/xfs/xfs_attr_leaf.c</span>
<span class="p_header">index 28712d29e43c..26aa249529c2 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_leaf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_leaf.c</span>
<span class="p_chunk">@@ -500,8 +500,8 @@</span> <span class="p_context"> xfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)</span>
  * After the last attribute is removed revert to original inode format,
  * making all literal area available to the data fork once more.
  */
<span class="p_del">-STATIC void</span>
<span class="p_del">-xfs_attr_fork_reset(</span>
<span class="p_add">+void</span>
<span class="p_add">+xfs_attr_fork_remove(</span>
 	struct xfs_inode	*ip,
 	struct xfs_trans	*tp)
 {
<span class="p_chunk">@@ -567,7 +567,7 @@</span> <span class="p_context"> xfs_attr_shortform_remove(xfs_da_args_t *args)</span>
 	    (mp-&gt;m_flags &amp; XFS_MOUNT_ATTR2) &amp;&amp;
 	    (dp-&gt;i_d.di_format != XFS_DINODE_FMT_BTREE) &amp;&amp;
 	    !(args-&gt;op_flags &amp; XFS_DA_OP_ADDNAME)) {
<span class="p_del">-		xfs_attr_fork_reset(dp, args-&gt;trans);</span>
<span class="p_add">+		xfs_attr_fork_remove(dp, args-&gt;trans);</span>
 	} else {
 		xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
 		dp-&gt;i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);
<span class="p_chunk">@@ -830,7 +830,7 @@</span> <span class="p_context"> xfs_attr3_leaf_to_shortform(</span>
 	if (forkoff == -1) {
 		ASSERT(dp-&gt;i_mount-&gt;m_flags &amp; XFS_MOUNT_ATTR2);
 		ASSERT(dp-&gt;i_d.di_format != XFS_DINODE_FMT_BTREE);
<span class="p_del">-		xfs_attr_fork_reset(dp, args-&gt;trans);</span>
<span class="p_add">+		xfs_attr_fork_remove(dp, args-&gt;trans);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/fs/xfs/xfs_attr_leaf.h b/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_header">index e2929da7c3ba..4f3a60aa93d4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> int	xfs_attr_shortform_remove(struct xfs_da_args *args);</span>
 int	xfs_attr_shortform_list(struct xfs_attr_list_context *context);
 int	xfs_attr_shortform_allfit(struct xfs_buf *bp, struct xfs_inode *dp);
 int	xfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes);
<span class="p_del">-</span>
<span class="p_add">+void	xfs_attr_fork_remove(struct xfs_inode *ip, struct xfs_trans *tp);</span>
 
 /*
  * Internal routines when attribute fork size == XFS_LBSIZE(mp).
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 162a4b688a0c..97f066419ee1 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -1890,21 +1890,17 @@</span> <span class="p_context"> xfs_inactive(</span>
 	/*
 	 * If there are attributes associated with the file then blow them away
 	 * now.  The code calls a routine that recursively deconstructs the
<span class="p_del">-	 * attribute fork.  We need to just commit the current transaction</span>
<span class="p_del">-	 * because we can&#39;t use it for xfs_attr_inactive().</span>
<span class="p_add">+	 * attribute fork. If also blows away the in-core attribute fork.</span>
 	 */
<span class="p_del">-	if (ip-&gt;i_d.di_anextents &gt; 0) {</span>
<span class="p_del">-		ASSERT(ip-&gt;i_d.di_forkoff != 0);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (XFS_IFORK_Q(ip)) {</span>
 		error = xfs_attr_inactive(ip);
 		if (error)
 			return;
 	}
 
<span class="p_del">-	if (ip-&gt;i_afp)</span>
<span class="p_del">-		xfs_idestroy_fork(ip, XFS_ATTR_FORK);</span>
<span class="p_del">-</span>
<span class="p_add">+	ASSERT(!ip-&gt;i_afp);</span>
 	ASSERT(ip-&gt;i_d.di_anextents == 0);
<span class="p_add">+	ASSERT(ip-&gt;i_d.di_forkoff == 0);</span>
 
 	/*
 	 * Free the inode.
<span class="p_header">diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h</span>
<span class="p_header">index 2dd405c9be78..45c39a37f924 100644</span>
<span class="p_header">--- a/include/drm/drm_pciids.h</span>
<span class="p_header">+++ b/include/drm/drm_pciids.h</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"></span>
 	{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
<span class="p_add">+	{0x1002, 0x665f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \</span>
 	{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 622459aea211..91aac2525c09 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -204,6 +204,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_LFLAG_SW_ACTIVITY	= (1 &lt;&lt; 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 &lt;&lt; 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 &lt;&lt; 9), /* limit recovery to one reset */
<span class="p_add">+	ATA_LFLAG_CHANGED	= (1 &lt;&lt; 10), /* LPM state changed on this link */</span>
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 &lt;&lt; 0), /* host supports slave dev */
<span class="p_chunk">@@ -308,6 +309,12 @@</span> <span class="p_context"> enum {</span>
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
<span class="p_add">+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might</span>
<span class="p_add">+	 * be a spurious PHY event, so ignore the first PHY event that</span>
<span class="p_add">+	 * occurs within 10s after the policy change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ATA_TMOUT_SPURIOUS_PHY	= 10000,</span>
<span class="p_add">+</span>
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
<span class="p_chunk">@@ -786,6 +793,8 @@</span> <span class="p_context"> struct ata_link {</span>
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		last_lpm_change; /* when last LPM change happened */</span>
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
<span class="p_chunk">@@ -1199,6 +1208,7 @@</span> <span class="p_context"> extern struct ata_device *ata_dev_pair(struct ata_device *adev);</span>
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
<span class="p_add">+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);</span>
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
<span class="p_header">diff --git a/include/linux/sched/rt.h b/include/linux/sched/rt.h</span>
<span class="p_header">index 6341f5be6e24..a30b172df6e1 100644</span>
<span class="p_header">--- a/include/linux/sched/rt.h</span>
<span class="p_header">+++ b/include/linux/sched/rt.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"> static inline int rt_task(struct task_struct *p)</span>
 #ifdef CONFIG_RT_MUTEXES
 extern int rt_mutex_getprio(struct task_struct *p);
 extern void rt_mutex_setprio(struct task_struct *p, int prio);
<span class="p_del">-extern int rt_mutex_check_prio(struct task_struct *task, int newprio);</span>
<span class="p_add">+extern int rt_mutex_get_effective_prio(struct task_struct *task, int newprio);</span>
 extern struct task_struct *rt_mutex_get_top_task(struct task_struct *task);
 extern void rt_mutex_adjust_pi(struct task_struct *p);
 static inline bool tsk_is_pi_blocked(struct task_struct *tsk)
<span class="p_chunk">@@ -31,9 +31,10 @@</span> <span class="p_context"> static inline int rt_mutex_getprio(struct task_struct *p)</span>
 	return p-&gt;normal_prio;
 }
 
<span class="p_del">-static inline int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+static inline int rt_mutex_get_effective_prio(struct task_struct *task,</span>
<span class="p_add">+					      int newprio)</span>
 {
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 static inline struct task_struct *rt_mutex_get_top_task(struct task_struct *task)
<span class="p_header">diff --git a/include/xen/events.h b/include/xen/events.h</span>
<span class="p_header">index 8bee7a75e850..7c69e1d650e6 100644</span>
<span class="p_header">--- a/include/xen/events.h</span>
<span class="p_header">+++ b/include/xen/events.h</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"> int bind_evtchn_to_irqhandler(unsigned int evtchn,</span>
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);</span>
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index f9878d16b80b..3c9082036365 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -265,15 +265,17 @@</span> <span class="p_context"> struct task_struct *rt_mutex_get_top_task(struct task_struct *task)</span>
 }
 
 /*
<span class="p_del">- * Called by sched_setscheduler() to check whether the priority change</span>
<span class="p_del">- * is overruled by a possible priority boosting.</span>
<span class="p_add">+ * Called by sched_setscheduler() to get the priority which will be</span>
<span class="p_add">+ * effective after the change.</span>
  */
<span class="p_del">-int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+int rt_mutex_get_effective_prio(struct task_struct *task, int newprio)</span>
 {
 	if (!task_has_pi_waiters(task))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return newprio;</span>
 
<span class="p_del">-	return task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio;</span>
<span class="p_add">+	if (task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio)</span>
<span class="p_add">+		return task_top_pi_waiter(task)-&gt;task-&gt;prio;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 3775cafdfb4a..fd876c5fcb13 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -3311,6 +3311,9 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	module_bug_cleanup(mod);
 	mutex_unlock(&amp;module_mutex);
 
<span class="p_add">+	blocking_notifier_call_chain(&amp;module_notify_list,</span>
<span class="p_add">+				     MODULE_STATE_GOING, mod);</span>
<span class="p_add">+</span>
 	/* we can&#39;t deallocate the module until we clear memory protection */
 	unset_module_init_ro_nx(mod);
 	unset_module_core_ro_nx(mod);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 6356f644a47b..5c89af9ea192 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -3251,15 +3251,18 @@</span> <span class="p_context"> static void __setscheduler_params(struct task_struct *p,</span>
 
 /* Actually do priority change: must hold pi &amp; rq lock. */
 static void __setscheduler(struct rq *rq, struct task_struct *p,
<span class="p_del">-			   const struct sched_attr *attr)</span>
<span class="p_add">+			   const struct sched_attr *attr, bool keep_boost)</span>
 {
 	__setscheduler_params(p, attr);
 
 	/*
<span class="p_del">-	 * If we get here, there was no pi waiters boosting the</span>
<span class="p_del">-	 * task. It is safe to use the normal prio.</span>
<span class="p_add">+	 * Keep a potential priority boosting if called from</span>
<span class="p_add">+	 * sched_setscheduler().</span>
 	 */
<span class="p_del">-	p-&gt;prio = normal_prio(p);</span>
<span class="p_add">+	if (keep_boost)</span>
<span class="p_add">+		p-&gt;prio = rt_mutex_get_effective_prio(p, normal_prio(p));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		p-&gt;prio = normal_prio(p);</span>
 
 	if (dl_prio(p-&gt;prio))
 		p-&gt;sched_class = &amp;dl_sched_class;
<span class="p_chunk">@@ -3345,7 +3348,7 @@</span> <span class="p_context"> static int __sched_setscheduler(struct task_struct *p,</span>
 	int newprio = dl_policy(attr-&gt;sched_policy) ? MAX_DL_PRIO - 1 :
 		      MAX_RT_PRIO - 1 - attr-&gt;sched_priority;
 	int retval, oldprio, oldpolicy = -1, on_rq, running;
<span class="p_del">-	int policy = attr-&gt;sched_policy;</span>
<span class="p_add">+	int new_effective_prio, policy = attr-&gt;sched_policy;</span>
 	unsigned long flags;
 	const struct sched_class *prev_class;
 	struct rq *rq;
<span class="p_chunk">@@ -3527,15 +3530,14 @@</span> <span class="p_context"> change:</span>
 	oldprio = p-&gt;prio;
 
 	/*
<span class="p_del">-	 * Special case for priority boosted tasks.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * If the new priority is lower or equal (user space view)</span>
<span class="p_del">-	 * than the current (boosted) priority, we just store the new</span>
<span class="p_add">+	 * Take priority boosted tasks into account. If the new</span>
<span class="p_add">+	 * effective priority is unchanged, we just store the new</span>
 	 * normal parameters and do not touch the scheduler class and
 	 * the runqueue. This will be done when the task deboost
 	 * itself.
 	 */
<span class="p_del">-	if (rt_mutex_check_prio(p, newprio)) {</span>
<span class="p_add">+	new_effective_prio = rt_mutex_get_effective_prio(p, newprio);</span>
<span class="p_add">+	if (new_effective_prio == oldprio) {</span>
 		__setscheduler_params(p, attr);
 		task_rq_unlock(rq, p, &amp;flags);
 		return 0;
<span class="p_chunk">@@ -3549,7 +3551,7 @@</span> <span class="p_context"> change:</span>
 		p-&gt;sched_class-&gt;put_prev_task(rq, p);
 
 	prev_class = p-&gt;sched_class;
<span class="p_del">-	__setscheduler(rq, p, attr);</span>
<span class="p_add">+	__setscheduler(rq, p, attr, true);</span>
 
 	if (running)
 		p-&gt;sched_class-&gt;set_curr_task(rq);
<span class="p_chunk">@@ -7112,7 +7114,7 @@</span> <span class="p_context"> static void normalize_task(struct rq *rq, struct task_struct *p)</span>
 	on_rq = p-&gt;on_rq;
 	if (on_rq)
 		dequeue_task(rq, p, 0);
<span class="p_del">-	__setscheduler(rq, p, &amp;attr);</span>
<span class="p_add">+	__setscheduler(rq, p, &amp;attr, false);</span>
 	if (on_rq) {
 		enqueue_task(rq, p, 0);
 		resched_task(rq-&gt;curr);
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index 8f5330d74f47..7832affffda5 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -2560,7 +2560,7 @@</span> <span class="p_context"> static void __init check_numabalancing_enable(void)</span>
 	if (numabalancing_override)
 		set_numabalancing_state(numabalancing_override == 1);
 
<span class="p_del">-	if (nr_node_ids &gt; 1 &amp;&amp; !numabalancing_override) {</span>
<span class="p_add">+	if (num_online_nodes() &gt; 1 &amp;&amp; !numabalancing_override) {</span>
 		pr_info(&quot;%s automatic NUMA balancing. &quot;
 			&quot;Configure with numa_balancing= or the &quot;
 			&quot;kernel.numa_balancing sysctl&quot;,
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index eb73398dd237..799379e81264 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 
 		err = br_ip6_multicast_add_group(br, port, &amp;grec-&gt;grec_mca,
 						 vid);
<span class="p_del">-		if (!err)</span>
<span class="p_add">+		if (err)</span>
 			break;
 	}
 
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index 8cbd41f5c424..446548de09f8 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -1959,20 +1959,29 @@</span> <span class="p_context"> static void kick_requests(struct ceph_osd_client *osdc, bool force_resend,</span>
 		err = __map_request(osdc, req,
 				    force_resend || force_resend_writes);
 		dout(&quot;__map_request returned %d\n&quot;, err);
<span class="p_del">-		if (err == 0)</span>
<span class="p_del">-			continue;  /* no change and no osd was specified */</span>
 		if (err &lt; 0)
 			continue;  /* hrm! */
<span class="p_del">-		if (req-&gt;r_osd == NULL) {</span>
<span class="p_del">-			dout(&quot;tid %llu maps to no valid osd\n&quot;, req-&gt;r_tid);</span>
<span class="p_del">-			needmap++;  /* request a newer map */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (req-&gt;r_osd == NULL || err &gt; 0) {</span>
<span class="p_add">+			if (req-&gt;r_osd == NULL) {</span>
<span class="p_add">+				dout(&quot;lingering %p tid %llu maps to no osd\n&quot;,</span>
<span class="p_add">+				     req, req-&gt;r_tid);</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * A homeless lingering request makes</span>
<span class="p_add">+				 * no sense, as it&#39;s job is to keep</span>
<span class="p_add">+				 * a particular OSD connection open.</span>
<span class="p_add">+				 * Request a newer map and kick the</span>
<span class="p_add">+				 * request, knowing that it won&#39;t be</span>
<span class="p_add">+				 * resent until we actually get a map</span>
<span class="p_add">+				 * that can tell us where to send it.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				needmap++;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req, req-&gt;r_tid,</span>
<span class="p_del">-		     req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_del">-		__register_request(osdc, req);</span>
<span class="p_del">-		__unregister_linger_request(osdc, req);</span>
<span class="p_add">+			dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req,</span>
<span class="p_add">+			     req-&gt;r_tid, req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_add">+			__register_request(osdc, req);</span>
<span class="p_add">+			__unregister_linger_request(osdc, req);</span>
<span class="p_add">+		}</span>
 	}
 	reset_changed_osds(osdc);
 	mutex_unlock(&amp;osdc-&gt;request_mutex);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 5b2e13a7b790..d53aee9cbfe2 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -903,6 +903,10 @@</span> <span class="p_context"> static int ip_error(struct sk_buff *skb)</span>
 	bool send;
 	int code;
 
<span class="p_add">+	/* IP on this device is disabled. */</span>
<span class="p_add">+	if (!in_dev)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	net = dev_net(rt-&gt;dst.dev);
 	if (!IN_DEV_FORWARD(in_dev)) {
 		switch (rt-&gt;dst.error) {
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index e68e0d4af6c9..0c0255136992 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> void tcp_time_wait(struct sock *sk, int state, int timeo)</span>
 			tw-&gt;tw_v6_daddr = sk-&gt;sk_v6_daddr;
 			tw-&gt;tw_v6_rcv_saddr = sk-&gt;sk_v6_rcv_saddr;
 			tw-&gt;tw_tclass = np-&gt;tclass;
<span class="p_del">-			tw-&gt;tw_flowlabel = np-&gt;flow_label &gt;&gt; 12;</span>
<span class="p_add">+			tw-&gt;tw_flowlabel = be32_to_cpu(np-&gt;flow_label &amp; IPV6_FLOWLABEL_MASK);</span>
 			tw-&gt;tw_ipv6only = np-&gt;ipv6only;
 		}
 #endif
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 4bffae914120..5c3f0dc1c754 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -694,6 +694,7 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 {
 	struct rt6_info *iter = NULL;
 	struct rt6_info **ins;
<span class="p_add">+	struct rt6_info **fallback_ins = NULL;</span>
 	int replace = (info-&gt;nlh &amp;&amp;
 		       (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE));
 	int add = (!info-&gt;nlh ||
<span class="p_chunk">@@ -717,8 +718,13 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 			    (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL))
 				return -EEXIST;
 			if (replace) {
<span class="p_del">-				found++;</span>
<span class="p_del">-				break;</span>
<span class="p_add">+				if (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {</span>
<span class="p_add">+					found++;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (rt_can_ecmp)</span>
<span class="p_add">+					fallback_ins = fallback_ins ?: ins;</span>
<span class="p_add">+				goto next_iter;</span>
 			}
 
 			if (iter-&gt;dst.dev == rt-&gt;dst.dev &amp;&amp;
<span class="p_chunk">@@ -754,9 +760,17 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 		if (iter-&gt;rt6i_metric &gt; rt-&gt;rt6i_metric)
 			break;
 
<span class="p_add">+next_iter:</span>
 		ins = &amp;iter-&gt;dst.rt6_next;
 	}
 
<span class="p_add">+	if (fallback_ins &amp;&amp; !found) {</span>
<span class="p_add">+		/* No ECMP-able route found, replace first non-ECMP one */</span>
<span class="p_add">+		ins = fallback_ins;</span>
<span class="p_add">+		iter = *ins;</span>
<span class="p_add">+		found++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Reset round-robin state, if necessary */
 	if (ins == &amp;fn-&gt;leaf)
 		fn-&gt;rr_ptr = NULL;
<span class="p_chunk">@@ -817,6 +831,8 @@</span> <span class="p_context"> add:</span>
 		}
 
 	} else {
<span class="p_add">+		int nsiblings;</span>
<span class="p_add">+</span>
 		if (!found) {
 			if (add)
 				goto add;
<span class="p_chunk">@@ -837,8 +853,27 @@</span> <span class="p_context"> add:</span>
 			info-&gt;nl_net-&gt;ipv6.rt6_stats-&gt;fib_route_nodes++;
 			fn-&gt;fn_flags |= RTN_RTINFO;
 		}
<span class="p_add">+		nsiblings = iter-&gt;rt6i_nsiblings;</span>
 		fib6_purge_rt(iter, fn, info-&gt;nl_net);
 		rt6_release(iter);
<span class="p_add">+</span>
<span class="p_add">+		if (nsiblings) {</span>
<span class="p_add">+			/* Replacing an ECMP route, remove all siblings */</span>
<span class="p_add">+			ins = &amp;rt-&gt;dst.rt6_next;</span>
<span class="p_add">+			iter = *ins;</span>
<span class="p_add">+			while (iter) {</span>
<span class="p_add">+				if (rt6_qualify_for_ecmp(iter)) {</span>
<span class="p_add">+					*ins = iter-&gt;dst.rt6_next;</span>
<span class="p_add">+					fib6_purge_rt(iter, fn, info-&gt;nl_net);</span>
<span class="p_add">+					rt6_release(iter);</span>
<span class="p_add">+					nsiblings--;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					ins = &amp;iter-&gt;dst.rt6_next;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				iter = *ins;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			WARN_ON(nsiblings != 0);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 07b1eee067b1..4967b50cdf52 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -2432,9 +2432,9 @@</span> <span class="p_context"> static int ip6_route_multipath(struct fib6_config *cfg, int add)</span>
 	int attrlen;
 	int err = 0, last_err = 0;
 
<span class="p_add">+	remaining = cfg-&gt;fc_mp_len;</span>
 beginning:
 	rtnh = (struct rtnexthop *)cfg-&gt;fc_mp;
<span class="p_del">-	remaining = cfg-&gt;fc_mp_len;</span>
 
 	/* Parse a Multipath Entry */
 	while (rtnh_ok(rtnh, remaining)) {
<span class="p_chunk">@@ -2464,15 +2464,19 @@</span> <span class="p_context"> beginning:</span>
 				 * next hops that have been already added.
 				 */
 				add = 0;
<span class="p_add">+				remaining = cfg-&gt;fc_mp_len - remaining;</span>
 				goto beginning;
 			}
 		}
 		/* Because each route is added like a single route we remove
<span class="p_del">-		 * this flag after the first nexthop (if there is a collision,</span>
<span class="p_del">-		 * we have already fail to add the first nexthop:</span>
<span class="p_del">-		 * fib6_add_rt2node() has reject it).</span>
<span class="p_add">+		 * these flags after the first nexthop: if there is a collision,</span>
<span class="p_add">+		 * we have already failed to add the first nexthop:</span>
<span class="p_add">+		 * fib6_add_rt2node() has rejected it; when replacing, old</span>
<span class="p_add">+		 * nexthops have been replaced by first new, the rest should</span>
<span class="p_add">+		 * be added to it.</span>
 		 */
<span class="p_del">-		cfg-&gt;fc_nlinfo.nlh-&gt;nlmsg_flags &amp;= ~NLM_F_EXCL;</span>
<span class="p_add">+		cfg-&gt;fc_nlinfo.nlh-&gt;nlmsg_flags &amp;= ~(NLM_F_EXCL |</span>
<span class="p_add">+						     NLM_F_REPLACE);</span>
 		rtnh = rtnh_next(rtnh, &amp;remaining);
 	}
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index d15a5484076f..f9f8bb3c2605 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -920,7 +920,7 @@</span> <span class="p_context"> static void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)</span>
 			tcptw-&gt;tw_rcv_wnd &gt;&gt; tw-&gt;tw_rcv_wscale,
 			tcp_time_stamp + tcptw-&gt;tw_ts_offset,
 			tcptw-&gt;tw_ts_recent, tw-&gt;tw_bound_dev_if, tcp_twsk_md5_key(tcptw),
<span class="p_del">-			tw-&gt;tw_tclass, (tw-&gt;tw_flowlabel &lt;&lt; 12));</span>
<span class="p_add">+			tw-&gt;tw_tclass, cpu_to_be32(tw-&gt;tw_flowlabel));</span>
 
 	inet_twsk_put(tw);
 }
<span class="p_header">diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h</span>
<span class="p_header">index 6b943c29937b..d7a4c0ff66ff 100644</span>
<span class="p_header">--- a/net/mac80211/ieee80211_i.h</span>
<span class="p_header">+++ b/net/mac80211/ieee80211_i.h</span>
<span class="p_chunk">@@ -203,6 +203,8 @@</span> <span class="p_context"> enum ieee80211_packet_rx_flags {</span>
  * @IEEE80211_RX_CMNTR: received on cooked monitor already
  * @IEEE80211_RX_BEACON_REPORTED: This frame was already reported
  *	to cfg80211_report_obss_beacon().
<span class="p_add">+ * @IEEE80211_RX_REORDER_TIMER: this frame is released by the</span>
<span class="p_add">+ *	reorder buffer timeout timer, not the normal RX path</span>
  *
  * These flags are used across handling multiple interfaces
  * for a single frame.
<span class="p_chunk">@@ -210,6 +212,7 @@</span> <span class="p_context"> enum ieee80211_packet_rx_flags {</span>
 enum ieee80211_rx_flags {
 	IEEE80211_RX_CMNTR		= BIT(0),
 	IEEE80211_RX_BEACON_REPORTED	= BIT(1),
<span class="p_add">+	IEEE80211_RX_REORDER_TIMER	= BIT(2),</span>
 };
 
 struct ieee80211_rx_data {
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 07fb67803097..3ee2abd4007e 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -1968,7 +1968,8 @@</span> <span class="p_context"> ieee80211_deliver_skb(struct ieee80211_rx_data *rx)</span>
 		/* deliver to local stack */
 		skb-&gt;protocol = eth_type_trans(skb, dev);
 		memset(skb-&gt;cb, 0, sizeof(skb-&gt;cb));
<span class="p_del">-		if (rx-&gt;local-&gt;napi)</span>
<span class="p_add">+		if (!(rx-&gt;flags &amp; IEEE80211_RX_REORDER_TIMER) &amp;&amp;</span>
<span class="p_add">+		    rx-&gt;local-&gt;napi)</span>
 			napi_gro_receive(rx-&gt;local-&gt;napi, skb);
 		else
 			netif_receive_skb(skb);
<span class="p_chunk">@@ -3038,7 +3039,7 @@</span> <span class="p_context"> void ieee80211_release_reorder_timeout(struct sta_info *sta, int tid)</span>
 		/* This is OK -- must be QoS data frame */
 		.security_idx = tid,
 		.seqno_idx = tid,
<span class="p_del">-		.flags = 0,</span>
<span class="p_add">+		.flags = IEEE80211_RX_REORDER_TIMER,</span>
 	};
 	struct tid_ampdu_rx *tid_agg_rx;
 
<span class="p_header">diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c</span>
<span class="p_header">index 6ee2b5863572..f21b142dee1f 100644</span>
<span class="p_header">--- a/net/mac80211/wep.c</span>
<span class="p_header">+++ b/net/mac80211/wep.c</span>
<span class="p_chunk">@@ -98,8 +98,7 @@</span> <span class="p_context"> static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,</span>
 
 	hdr-&gt;frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
<span class="p_del">-	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN ||</span>
<span class="p_del">-		    skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
<span class="p_add">+	if (WARN_ON(skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
 		return NULL;
 
 	hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
<span class="p_chunk">@@ -169,6 +168,9 @@</span> <span class="p_context"> int ieee80211_wep_encrypt(struct ieee80211_local *local,</span>
 	size_t len;
 	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
 
<span class="p_add">+	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
 	if (!iv)
 		return -1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index 581a6584ed0c..285ae0dc1e03 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -3779,6 +3779,9 @@</span> <span class="p_context"> static void __net_exit ip_vs_control_net_cleanup_sysctl(struct net *net)</span>
 	cancel_work_sync(&amp;ipvs-&gt;defense_work.work);
 	unregister_net_sysctl_table(ipvs-&gt;sysctl_hdr);
 	ip_vs_stop_estimator(net, &amp;ipvs-&gt;tot_stats);
<span class="p_add">+</span>
<span class="p_add">+	if (!net_eq(net, &amp;init_net))</span>
<span class="p_add">+		kfree(ipvs-&gt;sysctl_tbl);</span>
 }
 
 #else
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 58bed7599db7..04de05ae7c5e 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -812,10 +812,8 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 		if (dev-&gt;flags &amp; IFF_UP)
 			dev_deactivate(dev);
 
<span class="p_del">-		if (new &amp;&amp; new-&gt;ops-&gt;attach) {</span>
<span class="p_del">-			new-&gt;ops-&gt;attach(new);</span>
<span class="p_del">-			num_q = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+			goto skip;</span>
 
 		for (i = 0; i &lt; num_q; i++) {
 			struct netdev_queue *dev_queue = dev_ingress_queue(dev);
<span class="p_chunk">@@ -831,12 +829,16 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 				qdisc_destroy(old);
 		}
 
<span class="p_add">+skip:</span>
 		if (!ingress) {
 			notify_and_destroy(net, skb, n, classid,
 					   dev-&gt;qdisc, new);
 			if (new &amp;&amp; !new-&gt;ops-&gt;attach)
 				atomic_inc(&amp;new-&gt;refcnt);
 			dev-&gt;qdisc = new ? : &amp;noop_qdisc;
<span class="p_add">+</span>
<span class="p_add">+			if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+				new-&gt;ops-&gt;attach(new);</span>
 		} else {
 			notify_and_destroy(net, skb, n, classid, old, new);
 		}
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 4980af97d87c..fc7ba8cabb72 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -2011,14 +2011,12 @@</span> <span class="p_context"> static int ___sys_sendmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	int err, ctl_len, total_len;
 
 	err = -EFAULT;
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	if (msg_sys-&gt;msg_iovlen &gt; UIO_FASTIOV) {
 		err = -EMSGSIZE;
<span class="p_chunk">@@ -2223,14 +2221,12 @@</span> <span class="p_context"> static int ___sys_recvmsg(struct socket *sock, struct msghdr __user *msg,</span>
 	struct sockaddr __user *uaddr;
 	int __user *uaddr_len;
 
<span class="p_del">-	if (MSG_CMSG_COMPAT &amp; flags) {</span>
<span class="p_del">-		if (get_compat_msghdr(msg_sys, msg_compat))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (MSG_CMSG_COMPAT &amp; flags)</span>
<span class="p_add">+		err = get_compat_msghdr(msg_sys, msg_compat);</span>
<span class="p_add">+	else</span>
 		err = copy_msghdr_from_user(msg_sys, msg);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
 	if (msg_sys-&gt;msg_iovlen &gt; UIO_FASTIOV) {
 		err = -EMSGSIZE;
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index 1ec19f6f0c2b..eeeba5adee6d 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -793,20 +793,26 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 {
 	u32 value_follows;
 	int err;
<span class="p_add">+	struct page *scratch;</span>
<span class="p_add">+</span>
<span class="p_add">+	scratch = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+	if (!scratch)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	xdr_set_scratch_buffer(xdr, page_address(scratch), PAGE_SIZE);</span>
 
 	/* res-&gt;status */
 	err = gssx_dec_status(xdr, &amp;res-&gt;status);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 
 	/* res-&gt;context_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_ctx(xdr, res-&gt;context_handle);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;context_handle = NULL;
 	}
<span class="p_chunk">@@ -814,11 +820,11 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;output_token */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_buffer(xdr, res-&gt;output_token);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;output_token = NULL;
 	}
<span class="p_chunk">@@ -826,14 +832,17 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;delegated_cred_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		/* we do not support upcall servers sending this data. */
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* res-&gt;options */
 	err = gssx_dec_option_array(xdr, &amp;res-&gt;options);
 
<span class="p_add">+out_free:</span>
<span class="p_add">+	__free_page(scratch);</span>
 	return err;
 }
<span class="p_header">diff --git a/sound/oss/sequencer.c b/sound/oss/sequencer.c</span>
<span class="p_header">index c0eea1dfe90f..f19da4b47c1d 100644</span>
<span class="p_header">--- a/sound/oss/sequencer.c</span>
<span class="p_header">+++ b/sound/oss/sequencer.c</span>
<span class="p_chunk">@@ -681,13 +681,8 @@</span> <span class="p_context"> static int seq_timing_event(unsigned char *event_rec)</span>
 			break;
 
 		case TMR_ECHO:
<span class="p_del">-			if (seq_mode == SEQ_2)</span>
<span class="p_del">-				seq_copy_to_input(event_rec, 8);</span>
<span class="p_del">-			else</span>
<span class="p_del">-			{</span>
<span class="p_del">-				parm = (parm &lt;&lt; 8 | SEQ_ECHO);</span>
<span class="p_del">-				seq_copy_to_input((unsigned char *) &amp;parm, 4);</span>
<span class="p_del">-			}</span>
<span class="p_add">+			parm = (parm &lt;&lt; 8 | SEQ_ECHO);</span>
<span class="p_add">+			seq_copy_to_input((unsigned char *) &amp;parm, 4);</span>
 			break;
 
 		default:;
<span class="p_chunk">@@ -1324,7 +1319,6 @@</span> <span class="p_context"> int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a</span>
 	int mode = translate_mode(file);
 	struct synth_info inf;
 	struct seq_event_rec event_rec;
<span class="p_del">-	unsigned long flags;</span>
 	int __user *p = arg;
 
 	orig_dev = dev = dev &gt;&gt; 4;
<span class="p_chunk">@@ -1479,9 +1473,7 @@</span> <span class="p_context"> int sequencer_ioctl(int dev, struct file *file, unsigned int cmd, void __user *a</span>
 		case SNDCTL_SEQ_OUTOFBAND:
 			if (copy_from_user(&amp;event_rec, arg, sizeof(event_rec)))
 				return -EFAULT;
<span class="p_del">-			spin_lock_irqsave(&amp;lock,flags);</span>
 			play_event(event_rec.arr);
<span class="p_del">-			spin_unlock_irqrestore(&amp;lock,flags);</span>
 			return 0;
 
 		case SNDCTL_MIDI_INFO:
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index c7c3c153be31..db4a157bfc1b 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -3582,6 +3582,14 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_conexant[] = {</span>
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = &quot;CX20665&quot;,
 	  .patch = patch_conexant_auto },
<span class="p_add">+	{ .id = 0x14f150f1, .name = &quot;CX20721&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f2, .name = &quot;CX20722&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f3, .name = &quot;CX20723&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f4, .name = &quot;CX20724&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
 	{ .id = 0x14f1510f, .name = &quot;CX20751/2&quot;,
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = &quot;CX20751/2&quot;,
<span class="p_chunk">@@ -3616,6 +3624,10 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ab&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ac&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b8&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b9&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f1&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f3&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f4&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f1510f&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15110&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15111&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 7b16c8ca5faf..e4239715a5e6 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4879,6 +4879,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),</span>
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Thinkpad SL410/510&quot;, ALC269_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x17aa, 0x215e, &quot;Thinkpad L512&quot;, ALC269_FIXUP_SKU_IGNORE),
<span class="p_chunk">@@ -4905,6 +4906,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5026, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
 	SND_PCI_QUIRK(0x17aa, 0x9e54, &quot;LENOVO NB&quot;, ALC269_FIXUP_LENOVO_EAPD),
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 2341fc334163..6ba0b5517c40 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 		if (led_set_func(TPACPI_LED_MUTE, false) &gt;= 0) {
 			old_vmaster_hook = spec-&gt;vmaster_mute.hook;
 			spec-&gt;vmaster_mute.hook = update_tpacpi_mute_led;
<span class="p_del">-			spec-&gt;vmaster_mute_enum = 1;</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_header">diff --git a/sound/soc/codecs/mc13783.c b/sound/soc/codecs/mc13783.c</span>
<span class="p_header">index 9965277b595a..3e8642de299f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/mc13783.c</span>
<span class="p_header">+++ b/sound/soc/codecs/mc13783.c</span>
<span class="p_chunk">@@ -623,14 +623,14 @@</span> <span class="p_context"> static int mc13783_probe(struct snd_soc_codec *codec)</span>
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_CODEC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	if (priv-&gt;dac_ssi_port == MC13783_SSI1_PORT)
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index de65ad096248..1f5a5eebfd67 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route audio_paths[] = {</span>
 	{ &quot;Right Input Mixer&quot;, &quot;Boost Switch&quot;, &quot;Right Boost Mixer&quot;, },
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT1&quot;, },  /* Really Boost Switch */
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT2&quot; },
<span class="p_del">-	{ &quot;Right Input Mixer&quot;, NULL, &quot;LINPUT3&quot; },</span>
<span class="p_add">+	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT3&quot; },</span>
 
 	{ &quot;Left ADC&quot;, NULL, &quot;Left Input Mixer&quot; },
 	{ &quot;Right ADC&quot;, NULL, &quot;Right Input Mixer&quot; },
<span class="p_header">diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c</span>
<span class="p_header">index 9719d3ca8e47..d54c10e4fa90 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8994.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8994.c</span>
<span class="p_chunk">@@ -2753,7 +2753,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static int fs_ratios[] = {
<span class="p_del">-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536</span>
<span class="p_add">+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536</span>
 };
 
 static int bclk_divs[] = {
<span class="p_header">diff --git a/tools/vm/Makefile b/tools/vm/Makefile</span>
<span class="p_header">index 3d907dacf2ac..c604f3ec628a 100644</span>
<span class="p_header">--- a/tools/vm/Makefile</span>
<span class="p_header">+++ b/tools/vm/Makefile</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
 TARGETS=page-types slabinfo
 
 LIB_DIR = ../lib/api
<span class="p_del">-LIBS = $(LIB_DIR)/libapikfs.a</span>
<span class="p_add">+LIBS = $(LIB_DIR)/libapi.a</span>
 
 CC = $(CROSS_COMPILE)gcc
 CFLAGS = -Wall -Wextra -I../lib/

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



