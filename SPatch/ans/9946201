
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,07/14] openrisc: initial SMP support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,07/14] openrisc: initial SMP support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=153221">Stafford Horne</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 10, 2017, 6:49 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170910064926.5874-8-shorne@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9946201/mbox/"
   >mbox</a>
|
   <a href="/patch/9946201/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9946201/">/patch/9946201/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3B9BF60224 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Sep 2017 06:51:30 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2960F28A4A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Sep 2017 06:51:30 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1DE6128A70; Sun, 10 Sep 2017 06:51:30 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.5 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM, RCVD_IN_DNSWL_HI,
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D04DD28A72
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 Sep 2017 06:51:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751458AbdIJGus (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 10 Sep 2017 02:50:48 -0400
Received: from mail-pf0-f178.google.com ([209.85.192.178]:35196 &quot;EHLO
	mail-pf0-f178.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750965AbdIJGuo (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 10 Sep 2017 02:50:44 -0400
Received: by mail-pf0-f178.google.com with SMTP id g13so9911181pfm.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Sat, 09 Sep 2017 23:50:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=bjf+Xl2uQauHpL/hmfPePnh1mJOtHjyzLYZBg8tT1SQ=;
	b=FVU12G/dlwF9rL7wqau1dRHpVMhtK29yeFoOY9TUqyrk/Z0wJTy2DkWi9jWaDSjYfF
	ZFteDJI6PJaJ1zYNzBohopH4ha6ClBpHKEP60ihTdLAmuBoAXc6mNArUewaBE7otiEUQ
	1NeaKZdWxcILQOZ2AD8sM6fmrdCxf3s3dxlc8McCK1R9xIfKWre6gYB20KpGTGV53U4p
	nCAAAtrer2OLDnVTC8jIN/N5EcboJxxxbtRL+Bc/0rCH1s3SDk6Zdnxnv/isknkD0Oxg
	eRuJvrj5UiLWVZjk2V435gLjKwGGlDcdfoog3wo1gmRvHpstlsLJxItmlQCIn2/EIuQ/
	W29A==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=bjf+Xl2uQauHpL/hmfPePnh1mJOtHjyzLYZBg8tT1SQ=;
	b=q7UwykYtoZcC9AvXEaVuvHHdqb234BBzlOkxVByJ32+BpB02J82wR6zFAwFlCxCzp0
	7t6NR9Nj5iXkV+H4aQGYrNXoT/9DeAE0QrofVdwt7zU4A0/hcOXjWNrJ0H3/B+dlNgTQ
	XYFjAXon5M4sISem4LYtdyCkr0uDueUEVw4Jz4TGKnk1kvQqPkDpm+xPrcN5HrDqIU7k
	c5W3t+5hAUMa1qoWZb2VdEfIbum5atLi8So12Zo7XNw0R/TrDOc7VYZ4wVEbbo4lyiPW
	klUJYVKUhY3Q6z6qQZ4OjdYvNTUypNEt3yHiraT2KDzjLu74o83ZEIFsMvBkUHlVJeOA
	Df3g==
X-Gm-Message-State: AHPjjUhsQq1+h33ASsL7CeJerzVaFP8Fs37jD6Kd/2MHWJA734HWKG0I
	vZuoLp8rVKVM3DFdIUZQ4Q==
X-Google-Smtp-Source: ADKCNb5jjqeOQrgKEPJjL536Fk80maRQ4uAWIXvjOJW2KT+2tdQYGsDSCzdG/zyzhFxGXHxqKzrpIw==
X-Received: by 10.98.100.206 with SMTP id y197mr8179326pfb.53.1505026242666; 
	Sat, 09 Sep 2017 23:50:42 -0700 (PDT)
Received: from localhost (g186.58-98-166.ppp.wakwak.ne.jp. [58.98.166.186])
	by smtp.gmail.com with ESMTPSA id
	133sm11416094pfy.2.2017.09.09.23.50.41
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Sat, 09 Sep 2017 23:50:42 -0700 (PDT)
From: Stafford Horne &lt;shorne@gmail.com&gt;
To: LKML &lt;linux-kernel@vger.kernel.org&gt;
Cc: Openrisc &lt;openrisc@lists.librecores.org&gt;,
	Stefan Kristiansson &lt;stefan.kristiansson@saunalahti.fi&gt;,
	Stafford Horne &lt;shorne@gmail.com&gt;, Jonas Bonn &lt;jonas@southpole.se&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	Jan Henrik Weinstock &lt;jan.weinstock@ice.rwth-aachen.de&gt;,
	Sebastian Macke &lt;sebastian@macke.de&gt;,
	Bart Van Assche &lt;bart.vanassche@sandisk.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Doug Ledford &lt;dledford@redhat.com&gt;,
	Alexander Duyck &lt;alexander.h.duyck@intel.com&gt;,
	Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;,
	Rob Herring &lt;robh@kernel.org&gt;, Olof Kindgren &lt;olof.kindgren@gmail.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;,
	Ingo Molnar &lt;mingo@kernel.org&gt;
Subject: [PATCH v2 07/14] openrisc: initial SMP support
Date: Sun, 10 Sep 2017 15:49:19 +0900
Message-Id: &lt;20170910064926.5874-8-shorne@gmail.com&gt;
X-Mailer: git-send-email 2.13.5
In-Reply-To: &lt;20170910064926.5874-1-shorne@gmail.com&gt;
References: &lt;20170910064926.5874-1-shorne@gmail.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=153221">Stafford Horne</a> - Sept. 10, 2017, 6:49 a.m.</div>
<pre class="content">
<span class="from">From: Stefan Kristiansson &lt;stefan.kristiansson@saunalahti.fi&gt;</span>

This patch introduces the SMP support for the OpenRISC architecture.
The SMP architecture requires cores which have multicore features which
have been introduced a few years back including:

 - New SPRS SPR_COREID SPR_NUMCORES
 - Shadow SPRs
 - Atomic Instructions
 - Cache Coherency
 - A wired in IPI controller

This patch adds all of the SMP specific changes to core infrastructure,
it looks big but it needs to go all together as its hard to split this
one up.

Boot loader spinning of second cpu is not supported yet, it&#39;s assumed
that Linux is booted straight after cpu reset.

The bulk of these changes are trivial changes to refactor to use per cpu
data structures throughout.  The addition of the smp.c and changes in
time.c are the changes.  Some specific notes:

MM changes
----------
The reason why this is created as an array, and not with DEFINE_PER_CPU
is that doing it this way, we&#39;ll save a load in the tlb-miss handler
(the load from __per_cpu_offset).

TLB Flush
---------
The SMP implementation of flush_tlb_* works by sending out a
function-call IPI to all the non-local cpus by using the generic
on_each_cpu() function.

Currently, all flush_tlb_* functions will result in a flush_tlb_all(),
which has always been the behaviour in the UP case.

CPU INFO
--------
This creates a per cpu cpuinfo struct and fills it out accordingly for
each activated cpu.  show_cpuinfo is also updated to reflect new version
information in later versions of the spec.

SMP API
-------
This imitates the arm64 implementation by having a smp_cross_call
callback that can be set by set_smp_cross_call to initiate an IPI and a
handle_IPI function that is expected to be called from an IPI irqchip
driver.
<span class="signed-off-by">
Signed-off-by: Stefan Kristiansson &lt;stefan.kristiansson@saunalahti.fi&gt;</span>
[shorne@gmail.com: added cpu stop, checkpatch fixes, wrote commit message]
<span class="signed-off-by">Signed-off-by: Stafford Horne &lt;shorne@gmail.com&gt;</span>
---

Changes since v1
 - Added time.h for timer initialization
 - Don&#39;t crash on boot if IPI initialization fails
 - Removed volatile on secondary_release flag (checkpatch report)
 - Change ipi variable name from ipi_msg from

 arch/openrisc/Kconfig                   |  17 ++-
 arch/openrisc/include/asm/cpuinfo.h     |   7 +-
 arch/openrisc/include/asm/mmu_context.h |   2 +-
 arch/openrisc/include/asm/pgtable.h     |   2 +-
 arch/openrisc/include/asm/serial.h      |   2 +-
 arch/openrisc/include/asm/smp.h         |  26 ++++
 arch/openrisc/include/asm/spr_defs.h    |  14 ++
 arch/openrisc/include/asm/time.h        |  15 ++
 arch/openrisc/include/asm/tlbflush.h    |  25 +++-
 arch/openrisc/kernel/Makefile           |   1 +
 arch/openrisc/kernel/dma.c              |  14 +-
 arch/openrisc/kernel/head.S             |  97 ++++++++++++-
 arch/openrisc/kernel/setup.c            | 165 ++++++++++++++--------
 arch/openrisc/kernel/smp.c              | 235 ++++++++++++++++++++++++++++++++
 arch/openrisc/kernel/time.c             |  51 ++++---
 arch/openrisc/lib/delay.c               |   2 +-
 arch/openrisc/mm/fault.c                |   4 +-
 arch/openrisc/mm/init.c                 |   2 +-
 arch/openrisc/mm/tlb.c                  |  16 +--
 19 files changed, 584 insertions(+), 113 deletions(-)
 create mode 100644 arch/openrisc/include/asm/smp.h
 create mode 100644 arch/openrisc/include/asm/time.h
 create mode 100644 arch/openrisc/kernel/smp.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig</span>
<span class="p_header">index 34eb4e90f56c..2b3898ede888 100644</span>
<span class="p_header">--- a/arch/openrisc/Kconfig</span>
<span class="p_header">+++ b/arch/openrisc/Kconfig</span>
<span class="p_chunk">@@ -21,8 +21,10 @@</span> <span class="p_context"> config OPENRISC</span>
 	select HAVE_UID16
 	select GENERIC_ATOMIC64
 	select GENERIC_CLOCKEVENTS
<span class="p_add">+	select GENERIC_CLOCKEVENTS_BROADCAST</span>
 	select GENERIC_STRNCPY_FROM_USER
 	select GENERIC_STRNLEN_USER
<span class="p_add">+	select GENERIC_SMP_IDLE_THREAD</span>
 	select MODULES_USE_ELF_RELA
 	select HAVE_DEBUG_STACKOVERFLOW
 	select OR1K_PIC
<span class="p_chunk">@@ -107,8 +109,19 @@</span> <span class="p_context"> config OPENRISC_HAVE_INST_DIV</span>
 endmenu
 
 config NR_CPUS
<span class="p_del">-	int</span>
<span class="p_del">-	default &quot;1&quot;</span>
<span class="p_add">+	int &quot;Maximum number of CPUs (2-32)&quot;</span>
<span class="p_add">+	range 2 32</span>
<span class="p_add">+	depends on SMP</span>
<span class="p_add">+	default &quot;2&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+config SMP</span>
<span class="p_add">+	bool &quot;Symmetric Multi-Processing support&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This enables support for systems with more than one CPU. If you have</span>
<span class="p_add">+	  a system with only one CPU, say N. If you have a system with more</span>
<span class="p_add">+	  than one CPU, say Y.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If you don&#39;t know what to do here, say N.</span>
 
 source kernel/Kconfig.hz
 source kernel/Kconfig.preempt
<span class="p_header">diff --git a/arch/openrisc/include/asm/cpuinfo.h b/arch/openrisc/include/asm/cpuinfo.h</span>
<span class="p_header">index ec10679d6429..4ea0a33eba6c 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/cpuinfo.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/cpuinfo.h</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
 #ifndef __ASM_OPENRISC_CPUINFO_H
 #define __ASM_OPENRISC_CPUINFO_H
 
<span class="p_del">-struct cpuinfo {</span>
<span class="p_add">+struct cpuinfo_or1k {</span>
 	u32 clock_frequency;
 
 	u32 icache_size;
<span class="p_chunk">@@ -29,8 +29,11 @@</span> <span class="p_context"> struct cpuinfo {</span>
 	u32 dcache_size;
 	u32 dcache_block_size;
 	u32 dcache_ways;
<span class="p_add">+</span>
<span class="p_add">+	u16 coreid;</span>
 };
 
<span class="p_del">-extern struct cpuinfo cpuinfo;</span>
<span class="p_add">+extern struct cpuinfo_or1k cpuinfo_or1k[NR_CPUS];</span>
<span class="p_add">+extern void setup_cpuinfo(void);</span>
 
 #endif /* __ASM_OPENRISC_CPUINFO_H */
<span class="p_header">diff --git a/arch/openrisc/include/asm/mmu_context.h b/arch/openrisc/include/asm/mmu_context.h</span>
<span class="p_header">index e94b814d2e3c..c380d8caf84f 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> extern void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
  * registers like cr3 on the i386
  */
 
<span class="p_del">-extern volatile pgd_t *current_pgd;   /* defined in arch/openrisc/mm/fault.c */</span>
<span class="p_add">+extern volatile pgd_t *current_pgd[]; /* defined in arch/openrisc/mm/fault.c */</span>
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 {
<span class="p_header">diff --git a/arch/openrisc/include/asm/pgtable.h b/arch/openrisc/include/asm/pgtable.h</span>
<span class="p_header">index ff97374ca069..47eae2f78d2d 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> extern void paging_init(void);</span>
  * 64 MB of vmalloc area is comparable to what&#39;s available on other arches.
  */
 
<span class="p_del">-#define VMALLOC_START	(PAGE_OFFSET-0x04000000)</span>
<span class="p_add">+#define VMALLOC_START	(PAGE_OFFSET-0x04000000UL)</span>
 #define VMALLOC_END	(PAGE_OFFSET)
 #define VMALLOC_VMADDR(x) ((unsigned long)(x))
 
<span class="p_header">diff --git a/arch/openrisc/include/asm/serial.h b/arch/openrisc/include/asm/serial.h</span>
<span class="p_header">index 270a45241639..cb5932f5447a 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/serial.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/serial.h</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
  * it needs to be correct to get the early console working.
  */
 
<span class="p_del">-#define BASE_BAUD (cpuinfo.clock_frequency/16)</span>
<span class="p_add">+#define BASE_BAUD (cpuinfo_or1k[smp_processor_id()].clock_frequency/16)</span>
 
 #endif /* __KERNEL__ */
 
<span class="p_header">diff --git a/arch/openrisc/include/asm/smp.h b/arch/openrisc/include/asm/smp.h</span>
new file mode 100644
<span class="p_header">index 000000000000..e21d2f12b5b6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/smp.h</span>
<span class="p_chunk">@@ -0,0 +1,26 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Stefan Kristiansson &lt;stefan.kristiansson@saunalahti.fi&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is licensed under the terms of the GNU General Public License</span>
<span class="p_add">+ * version 2.  This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="p_add">+ * kind, whether express or implied.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASM_OPENRISC_SMP_H</span>
<span class="p_add">+#define __ASM_OPENRISC_SMP_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/spr.h&gt;</span>
<span class="p_add">+#include &lt;asm/spr_defs.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define raw_smp_processor_id()	(current_thread_info()-&gt;cpu)</span>
<span class="p_add">+#define hard_smp_processor_id()	mfspr(SPR_COREID)</span>
<span class="p_add">+</span>
<span class="p_add">+extern void smp_init_cpus(void);</span>
<span class="p_add">+</span>
<span class="p_add">+extern void arch_send_call_function_single_ipi(int cpu);</span>
<span class="p_add">+extern void arch_send_call_function_ipi_mask(const struct cpumask *mask);</span>
<span class="p_add">+</span>
<span class="p_add">+extern void set_smp_cross_call(void (*)(const struct cpumask *, unsigned int));</span>
<span class="p_add">+extern void handle_IPI(unsigned int ipi_msg);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASM_OPENRISC_SMP_H */</span>
<span class="p_header">diff --git a/arch/openrisc/include/asm/spr_defs.h b/arch/openrisc/include/asm/spr_defs.h</span>
<span class="p_header">index 367dac70326a..154b5a1ee579 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/spr_defs.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/spr_defs.h</span>
<span class="p_chunk">@@ -51,6 +51,11 @@</span> <span class="p_context"></span>
 #define SPR_ICCFGR	(SPRGROUP_SYS + 6)
 #define SPR_DCFGR	(SPRGROUP_SYS + 7)
 #define SPR_PCCFGR	(SPRGROUP_SYS + 8)
<span class="p_add">+#define SPR_VR2		(SPRGROUP_SYS + 9)</span>
<span class="p_add">+#define SPR_AVR		(SPRGROUP_SYS + 10)</span>
<span class="p_add">+#define SPR_EVBAR	(SPRGROUP_SYS + 11)</span>
<span class="p_add">+#define SPR_AECR	(SPRGROUP_SYS + 12)</span>
<span class="p_add">+#define SPR_AESR	(SPRGROUP_SYS + 13)</span>
 #define SPR_NPC         (SPRGROUP_SYS + 16)  /* CZ 21/06/01 */
 #define SPR_SR		(SPRGROUP_SYS + 17)  /* CZ 21/06/01 */
 #define SPR_PPC         (SPRGROUP_SYS + 18)  /* CZ 21/06/01 */
<span class="p_chunk">@@ -61,6 +66,8 @@</span> <span class="p_context"></span>
 #define SPR_EEAR_LAST	(SPRGROUP_SYS + 63)
 #define SPR_ESR_BASE	(SPRGROUP_SYS + 64)
 #define SPR_ESR_LAST	(SPRGROUP_SYS + 79)
<span class="p_add">+#define SPR_COREID	(SPRGROUP_SYS + 128)</span>
<span class="p_add">+#define SPR_NUMCORES	(SPRGROUP_SYS + 129)</span>
 #define SPR_GPR_BASE	(SPRGROUP_SYS + 1024)
 
 /* Data MMU group */
<span class="p_chunk">@@ -135,12 +142,19 @@</span> <span class="p_context"></span>
 #define SPR_VR_CFG	0x00ff0000  /* Processor configuration */
 #define SPR_VR_RES	0x0000ffc0  /* Reserved */
 #define SPR_VR_REV	0x0000003f  /* Processor revision */
<span class="p_add">+#define SPR_VR_UVRP	0x00000040  /* Updated Version Registers Present */</span>
 
 #define SPR_VR_VER_OFF	24
 #define SPR_VR_CFG_OFF	16
 #define SPR_VR_REV_OFF	0
 
 /*
<span class="p_add">+ * Bit definitions for the Version Register 2</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SPR_VR2_CPUID	0xff000000  /* Processor ID */</span>
<span class="p_add">+#define SPR_VR2_VER	0x00ffffff  /* Processor version */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Bit definitions for the Unit Present Register
  *
  */
<span class="p_header">diff --git a/arch/openrisc/include/asm/time.h b/arch/openrisc/include/asm/time.h</span>
new file mode 100644
<span class="p_header">index 000000000000..fe83a34a7d68</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/time.h</span>
<span class="p_chunk">@@ -0,0 +1,15 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OpenRISC timer API</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2017 by Stafford Horne (shorne@gmail.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="p_add">+ * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="p_add">+ * for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __ASM_OR1K_TIME_H</span>
<span class="p_add">+#define __ASM_OR1K_TIME_H</span>
<span class="p_add">+</span>
<span class="p_add">+extern void openrisc_clockevent_init(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASM_OR1K_TIME_H */</span>
<span class="p_header">diff --git a/arch/openrisc/include/asm/tlbflush.h b/arch/openrisc/include/asm/tlbflush.h</span>
<span class="p_header">index 6a2accd6cb67..94227f0eaf6d 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -33,13 +33,26 @@</span> <span class="p_context"></span>
  *  - flush_tlb_page(vma, vmaddr) flushes one page
  *  - flush_tlb_range(mm, start, end) flushes a range of pages
  */
<span class="p_add">+extern void local_flush_tlb_all(void);</span>
<span class="p_add">+extern void local_flush_tlb_mm(struct mm_struct *mm);</span>
<span class="p_add">+extern void local_flush_tlb_page(struct vm_area_struct *vma,</span>
<span class="p_add">+				 unsigned long addr);</span>
<span class="p_add">+extern void local_flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_add">+				  unsigned long start,</span>
<span class="p_add">+				  unsigned long end);</span>
 
<span class="p_del">-void flush_tlb_all(void);</span>
<span class="p_del">-void flush_tlb_mm(struct mm_struct *mm);</span>
<span class="p_del">-void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);</span>
<span class="p_del">-void flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_del">-		     unsigned long start,</span>
<span class="p_del">-		     unsigned long end);</span>
<span class="p_add">+#ifndef CONFIG_SMP</span>
<span class="p_add">+#define flush_tlb_all	local_flush_tlb_all</span>
<span class="p_add">+#define flush_tlb_mm	local_flush_tlb_mm</span>
<span class="p_add">+#define flush_tlb_page	local_flush_tlb_page</span>
<span class="p_add">+#define flush_tlb_range	local_flush_tlb_range</span>
<span class="p_add">+#else</span>
<span class="p_add">+extern void flush_tlb_all(void);</span>
<span class="p_add">+extern void flush_tlb_mm(struct mm_struct *mm);</span>
<span class="p_add">+extern void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr);</span>
<span class="p_add">+extern void flush_tlb_range(struct vm_area_struct *vma, unsigned long start,</span>
<span class="p_add">+			    unsigned long end);</span>
<span class="p_add">+#endif</span>
 
 static inline void flush_tlb(void)
 {
<span class="p_header">diff --git a/arch/openrisc/kernel/Makefile b/arch/openrisc/kernel/Makefile</span>
<span class="p_header">index ec6d9d37cefd..7d94643c878d 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/Makefile</span>
<span class="p_header">+++ b/arch/openrisc/kernel/Makefile</span>
<span class="p_chunk">@@ -8,6 +8,7 @@</span> <span class="p_context"> obj-y	:= setup.o or32_ksyms.o process.o dma.o \</span>
 	   traps.o time.o irq.o entry.o ptrace.o signal.o \
 	   sys_call_table.o
 
<span class="p_add">+obj-$(CONFIG_SMP)		+= smp.o</span>
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_OF)		+= prom.o
 
<span class="p_header">diff --git a/arch/openrisc/kernel/dma.c b/arch/openrisc/kernel/dma.c</span>
<span class="p_header">index b10369b7e31b..a945f00011b4 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/dma.c</span>
<span class="p_header">+++ b/arch/openrisc/kernel/dma.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> page_set_nocache(pte_t *pte, unsigned long addr,</span>
 		 unsigned long next, struct mm_walk *walk)
 {
 	unsigned long cl;
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
 
 	pte_val(*pte) |= _PAGE_CI;
 
<span class="p_chunk">@@ -42,7 +43,7 @@</span> <span class="p_context"> page_set_nocache(pte_t *pte, unsigned long addr,</span>
 	flush_tlb_page(NULL, addr);
 
 	/* Flush page out of dcache */
<span class="p_del">-	for (cl = __pa(addr); cl &lt; __pa(next); cl += cpuinfo.dcache_block_size)</span>
<span class="p_add">+	for (cl = __pa(addr); cl &lt; __pa(next); cl += cpuinfo-&gt;dcache_block_size)</span>
 		mtspr(SPR_DCBFR, cl);
 
 	return 0;
<span class="p_chunk">@@ -140,6 +141,7 @@</span> <span class="p_context"> or1k_map_page(struct device *dev, struct page *page,</span>
 {
 	unsigned long cl;
 	dma_addr_t addr = page_to_phys(page) + offset;
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
 
 	if (attrs &amp; DMA_ATTR_SKIP_CPU_SYNC)
 		return addr;
<span class="p_chunk">@@ -148,13 +150,13 @@</span> <span class="p_context"> or1k_map_page(struct device *dev, struct page *page,</span>
 	case DMA_TO_DEVICE:
 		/* Flush the dcache for the requested range */
 		for (cl = addr; cl &lt; addr + size;
<span class="p_del">-		     cl += cpuinfo.dcache_block_size)</span>
<span class="p_add">+		     cl += cpuinfo-&gt;dcache_block_size)</span>
 			mtspr(SPR_DCBFR, cl);
 		break;
 	case DMA_FROM_DEVICE:
 		/* Invalidate the dcache for the requested range */
 		for (cl = addr; cl &lt; addr + size;
<span class="p_del">-		     cl += cpuinfo.dcache_block_size)</span>
<span class="p_add">+		     cl += cpuinfo-&gt;dcache_block_size)</span>
 			mtspr(SPR_DCBIR, cl);
 		break;
 	default:
<span class="p_chunk">@@ -213,9 +215,10 @@</span> <span class="p_context"> or1k_sync_single_for_cpu(struct device *dev,</span>
 {
 	unsigned long cl;
 	dma_addr_t addr = dma_handle;
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
 
 	/* Invalidate the dcache for the requested range */
<span class="p_del">-	for (cl = addr; cl &lt; addr + size; cl += cpuinfo.dcache_block_size)</span>
<span class="p_add">+	for (cl = addr; cl &lt; addr + size; cl += cpuinfo-&gt;dcache_block_size)</span>
 		mtspr(SPR_DCBIR, cl);
 }
 
<span class="p_chunk">@@ -226,9 +229,10 @@</span> <span class="p_context"> or1k_sync_single_for_device(struct device *dev,</span>
 {
 	unsigned long cl;
 	dma_addr_t addr = dma_handle;
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
 
 	/* Flush the dcache for the requested range */
<span class="p_del">-	for (cl = addr; cl &lt; addr + size; cl += cpuinfo.dcache_block_size)</span>
<span class="p_add">+	for (cl = addr; cl &lt; addr + size; cl += cpuinfo-&gt;dcache_block_size)</span>
 		mtspr(SPR_DCBFR, cl);
 }
 
<span class="p_header">diff --git a/arch/openrisc/kernel/head.S b/arch/openrisc/kernel/head.S</span>
<span class="p_header">index 1e49895408f4..a9972dc103f8 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/head.S</span>
<span class="p_header">+++ b/arch/openrisc/kernel/head.S</span>
<span class="p_chunk">@@ -158,12 +158,38 @@</span> <span class="p_context"></span>
 
 /* =========================================================[ macros ]=== */
 
<span class="p_del">-</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
 #define GET_CURRENT_PGD(reg,t1)					\
 	LOAD_SYMBOL_2_GPR(reg,current_pgd)			;\
<span class="p_add">+	l.mfspr	t1,r0,SPR_COREID				;\</span>
<span class="p_add">+	l.slli	t1,t1,2						;\</span>
<span class="p_add">+	l.add	reg,reg,t1					;\</span>
 	tophys  (t1,reg)					;\
 	l.lwz   reg,0(t1)
<span class="p_add">+#else</span>
<span class="p_add">+#define GET_CURRENT_PGD(reg,t1)					\</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(reg,current_pgd)			;\</span>
<span class="p_add">+	tophys  (t1,reg)					;\</span>
<span class="p_add">+	l.lwz   reg,0(t1)</span>
<span class="p_add">+#endif</span>
 
<span class="p_add">+/* Load r10 from current_thread_info_set - clobbers r1 and r30 */</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+#define GET_CURRENT_THREAD_INFO					\</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(r1,current_thread_info_set)		;\</span>
<span class="p_add">+	tophys  (r30,r1)					;\</span>
<span class="p_add">+	l.mfspr	r10,r0,SPR_COREID				;\</span>
<span class="p_add">+	l.slli	r10,r10,2					;\</span>
<span class="p_add">+	l.add	r30,r30,r10					;\</span>
<span class="p_add">+	/* r10: current_thread_info  */				;\</span>
<span class="p_add">+	l.lwz   r10,0(r30)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define GET_CURRENT_THREAD_INFO					\</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(r1,current_thread_info_set)		;\</span>
<span class="p_add">+	tophys  (r30,r1)					;\</span>
<span class="p_add">+	/* r10: current_thread_info  */				;\</span>
<span class="p_add">+	l.lwz   r10,0(r30)</span>
<span class="p_add">+#endif</span>
 
 /*
  * DSCR: this is a common hook for handling exceptions. it will save
<span class="p_chunk">@@ -206,10 +232,7 @@</span> <span class="p_context"></span>
 	l.bnf   2f                            /* kernel_mode */	;\
 	 EXCEPTION_T_STORE_SP                 /* delay slot */	;\
 1: /* user_mode:   */						;\
<span class="p_del">-	LOAD_SYMBOL_2_GPR(r1,current_thread_info_set)		;\</span>
<span class="p_del">-	tophys  (r30,r1)					;\</span>
<span class="p_del">-	/* r10: current_thread_info  */				;\</span>
<span class="p_del">-	l.lwz   r10,0(r30)					;\</span>
<span class="p_add">+	GET_CURRENT_THREAD_INFO	 				;\</span>
 	tophys  (r30,r10)					;\
 	l.lwz   r1,(TI_KSP)(r30)				;\
 	/* fall through */					;\
<span class="p_chunk">@@ -530,6 +553,12 @@</span> <span class="p_context"> _start:</span>
 	CLEAR_GPR(r30)
 	CLEAR_GPR(r31)
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	l.mfspr	r26,r0,SPR_COREID</span>
<span class="p_add">+	l.sfeq	r26,r0</span>
<span class="p_add">+	l.bnf	secondary_wait</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+#endif</span>
 	/*
 	 * set up initial ksp and current
 	 */
<span class="p_chunk">@@ -681,6 +710,64 @@</span> <span class="p_context"> _flush_tlb:</span>
 	l.jr	r9
 	 l.nop
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+secondary_wait:</span>
<span class="p_add">+	l.mfspr	r25,r0,SPR_COREID</span>
<span class="p_add">+	l.movhi	r3,hi(secondary_release)</span>
<span class="p_add">+	l.ori	r3,r3,lo(secondary_release)</span>
<span class="p_add">+	tophys(r4, r3)</span>
<span class="p_add">+	l.lwz	r3,0(r4)</span>
<span class="p_add">+	l.sfeq	r25,r3</span>
<span class="p_add">+	l.bnf	secondary_wait</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+	/* fall through to secondary_init */</span>
<span class="p_add">+</span>
<span class="p_add">+secondary_init:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * set up initial ksp and current</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(r10, secondary_thread_info)</span>
<span class="p_add">+	tophys	(r30,r10)</span>
<span class="p_add">+	l.lwz	r10,0(r30)</span>
<span class="p_add">+	l.addi	r1,r10,THREAD_SIZE</span>
<span class="p_add">+	tophys	(r30,r10)</span>
<span class="p_add">+	l.sw	TI_KSP(r30),r1</span>
<span class="p_add">+</span>
<span class="p_add">+	l.jal	_ic_enable</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+</span>
<span class="p_add">+	l.jal	_dc_enable</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+</span>
<span class="p_add">+	l.jal	_flush_tlb</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * enable dmmu &amp; immu</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	l.mfspr	r30,r0,SPR_SR</span>
<span class="p_add">+	l.movhi	r28,hi(SPR_SR_DME | SPR_SR_IME)</span>
<span class="p_add">+	l.ori	r28,r28,lo(SPR_SR_DME | SPR_SR_IME)</span>
<span class="p_add">+	l.or	r30,r30,r28</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This is a bit tricky, we need to switch over from physical addresses</span>
<span class="p_add">+	 * to virtual addresses on the fly.</span>
<span class="p_add">+	 * To do that, we first set up ESR with the IME and DME bits set.</span>
<span class="p_add">+	 * Then EPCR is set to secondary_start and then a l.rfe is issued to</span>
<span class="p_add">+	 * &quot;jump&quot; to that.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	l.mtspr	r0,r30,SPR_ESR_BASE</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(r30, secondary_start)</span>
<span class="p_add">+	l.mtspr	r0,r30,SPR_EPCR_BASE</span>
<span class="p_add">+	l.rfe</span>
<span class="p_add">+</span>
<span class="p_add">+secondary_start:</span>
<span class="p_add">+	LOAD_SYMBOL_2_GPR(r30, secondary_start_kernel)</span>
<span class="p_add">+	l.jr    r30</span>
<span class="p_add">+	 l.nop</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* ========================================[ cache ]=== */
 
 	/* alignment here so we don&#39;t change memory offsets with
<span class="p_header">diff --git a/arch/openrisc/kernel/setup.c b/arch/openrisc/kernel/setup.c</span>
<span class="p_header">index dbf5ee95a0d5..9d28ab14d139 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/openrisc/kernel/setup.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static void __init setup_memory(void)</span>
 	memblock_dump_all();
 }
 
<span class="p_del">-struct cpuinfo cpuinfo;</span>
<span class="p_add">+struct cpuinfo_or1k cpuinfo_or1k[NR_CPUS];</span>
 
 static void print_cpuinfo(void)
 {
<span class="p_chunk">@@ -101,12 +101,13 @@</span> <span class="p_context"> static void print_cpuinfo(void)</span>
 	unsigned long vr = mfspr(SPR_VR);
 	unsigned int version;
 	unsigned int revision;
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
 
 	version = (vr &amp; SPR_VR_VER) &gt;&gt; 24;
 	revision = (vr &amp; SPR_VR_REV);
 
 	printk(KERN_INFO &quot;CPU: OpenRISC-%x (revision %d) @%d MHz\n&quot;,
<span class="p_del">-	       version, revision, cpuinfo.clock_frequency / 1000000);</span>
<span class="p_add">+	       version, revision, cpuinfo-&gt;clock_frequency / 1000000);</span>
 
 	if (!(upr &amp; SPR_UPR_UP)) {
 		printk(KERN_INFO
<span class="p_chunk">@@ -117,15 +118,15 @@</span> <span class="p_context"> static void print_cpuinfo(void)</span>
 	if (upr &amp; SPR_UPR_DCP)
 		printk(KERN_INFO
 		       &quot;-- dcache: %4d bytes total, %2d bytes/line, %d way(s)\n&quot;,
<span class="p_del">-		       cpuinfo.dcache_size, cpuinfo.dcache_block_size,</span>
<span class="p_del">-		       cpuinfo.dcache_ways);</span>
<span class="p_add">+		       cpuinfo-&gt;dcache_size, cpuinfo-&gt;dcache_block_size,</span>
<span class="p_add">+		       cpuinfo-&gt;dcache_ways);</span>
 	else
 		printk(KERN_INFO &quot;-- dcache disabled\n&quot;);
 	if (upr &amp; SPR_UPR_ICP)
 		printk(KERN_INFO
 		       &quot;-- icache: %4d bytes total, %2d bytes/line, %d way(s)\n&quot;,
<span class="p_del">-		       cpuinfo.icache_size, cpuinfo.icache_block_size,</span>
<span class="p_del">-		       cpuinfo.icache_ways);</span>
<span class="p_add">+		       cpuinfo-&gt;icache_size, cpuinfo-&gt;icache_block_size,</span>
<span class="p_add">+		       cpuinfo-&gt;icache_ways);</span>
 	else
 		printk(KERN_INFO &quot;-- icache disabled\n&quot;);
 
<span class="p_chunk">@@ -153,38 +154,58 @@</span> <span class="p_context"> static void print_cpuinfo(void)</span>
 		printk(KERN_INFO &quot;-- custom unit(s)\n&quot;);
 }
 
<span class="p_add">+static struct device_node *setup_find_cpu_node(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 hwid;</span>
<span class="p_add">+	struct device_node *cpun;</span>
<span class="p_add">+	struct device_node *cpus = of_find_node_by_path(&quot;/cpus&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_available_child_of_node(cpus, cpun) {</span>
<span class="p_add">+		if (of_property_read_u32(cpun, &quot;reg&quot;, &amp;hwid))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (hwid == cpu)</span>
<span class="p_add">+			return cpun;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init setup_cpuinfo(void)
 {
 	struct device_node *cpu;
 	unsigned long iccfgr, dccfgr;
 	unsigned long cache_set_size;
<span class="p_add">+	int cpu_id = smp_processor_id();</span>
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[cpu_id];</span>
 
<span class="p_del">-	cpu = of_find_compatible_node(NULL, NULL, &quot;opencores,or1200-rtlsvn481&quot;);</span>
<span class="p_add">+	cpu = setup_find_cpu_node(cpu_id);</span>
 	if (!cpu)
<span class="p_del">-		panic(&quot;No compatible CPU found in device tree...\n&quot;);</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t find CPU%d in device tree...\n&quot;, cpu_id);</span>
 
 	iccfgr = mfspr(SPR_ICCFGR);
<span class="p_del">-	cpuinfo.icache_ways = 1 &lt;&lt; (iccfgr &amp; SPR_ICCFGR_NCW);</span>
<span class="p_add">+	cpuinfo-&gt;icache_ways = 1 &lt;&lt; (iccfgr &amp; SPR_ICCFGR_NCW);</span>
 	cache_set_size = 1 &lt;&lt; ((iccfgr &amp; SPR_ICCFGR_NCS) &gt;&gt; 3);
<span class="p_del">-	cpuinfo.icache_block_size = 16 &lt;&lt; ((iccfgr &amp; SPR_ICCFGR_CBS) &gt;&gt; 7);</span>
<span class="p_del">-	cpuinfo.icache_size =</span>
<span class="p_del">-	    cache_set_size * cpuinfo.icache_ways * cpuinfo.icache_block_size;</span>
<span class="p_add">+	cpuinfo-&gt;icache_block_size = 16 &lt;&lt; ((iccfgr &amp; SPR_ICCFGR_CBS) &gt;&gt; 7);</span>
<span class="p_add">+	cpuinfo-&gt;icache_size =</span>
<span class="p_add">+	    cache_set_size * cpuinfo-&gt;icache_ways * cpuinfo-&gt;icache_block_size;</span>
 
 	dccfgr = mfspr(SPR_DCCFGR);
<span class="p_del">-	cpuinfo.dcache_ways = 1 &lt;&lt; (dccfgr &amp; SPR_DCCFGR_NCW);</span>
<span class="p_add">+	cpuinfo-&gt;dcache_ways = 1 &lt;&lt; (dccfgr &amp; SPR_DCCFGR_NCW);</span>
 	cache_set_size = 1 &lt;&lt; ((dccfgr &amp; SPR_DCCFGR_NCS) &gt;&gt; 3);
<span class="p_del">-	cpuinfo.dcache_block_size = 16 &lt;&lt; ((dccfgr &amp; SPR_DCCFGR_CBS) &gt;&gt; 7);</span>
<span class="p_del">-	cpuinfo.dcache_size =</span>
<span class="p_del">-	    cache_set_size * cpuinfo.dcache_ways * cpuinfo.dcache_block_size;</span>
<span class="p_add">+	cpuinfo-&gt;dcache_block_size = 16 &lt;&lt; ((dccfgr &amp; SPR_DCCFGR_CBS) &gt;&gt; 7);</span>
<span class="p_add">+	cpuinfo-&gt;dcache_size =</span>
<span class="p_add">+	    cache_set_size * cpuinfo-&gt;dcache_ways * cpuinfo-&gt;dcache_block_size;</span>
 
 	if (of_property_read_u32(cpu, &quot;clock-frequency&quot;,
<span class="p_del">-				 &amp;cpuinfo.clock_frequency)) {</span>
<span class="p_add">+				 &amp;cpuinfo-&gt;clock_frequency)) {</span>
 		printk(KERN_WARNING
 		       &quot;Device tree missing CPU &#39;clock-frequency&#39; parameter.&quot;
 		       &quot;Assuming frequency 25MHZ&quot;
 		       &quot;This is probably not what you want.&quot;);
 	}
 
<span class="p_add">+	cpuinfo-&gt;coreid = mfspr(SPR_COREID);</span>
<span class="p_add">+</span>
 	of_node_put(cpu);
 
 	print_cpuinfo();
<span class="p_chunk">@@ -251,8 +272,8 @@</span> <span class="p_context"> void __init detect_unit_config(unsigned long upr, unsigned long mask,</span>
 void calibrate_delay(void)
 {
 	const int *val;
<span class="p_del">-	struct device_node *cpu = NULL;</span>
<span class="p_del">-	cpu = of_find_compatible_node(NULL, NULL, &quot;opencores,or1200-rtlsvn481&quot;);</span>
<span class="p_add">+	struct device_node *cpu = setup_find_cpu_node(smp_processor_id());</span>
<span class="p_add">+</span>
 	val = of_get_property(cpu, &quot;clock-frequency&quot;, NULL);
 	if (!val)
 		panic(&quot;no cpu &#39;clock-frequency&#39; parameter in device tree&quot;);
<span class="p_chunk">@@ -268,6 +289,10 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 
 	setup_cpuinfo();
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	smp_init_cpus();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* process 1&#39;s initial memory region is the kernel code/data */
 	init_mm.start_code = (unsigned long)_stext;
 	init_mm.end_code = (unsigned long)_etext;
<span class="p_chunk">@@ -302,54 +327,78 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 
 static int show_cpuinfo(struct seq_file *m, void *v)
 {
<span class="p_del">-	unsigned long vr;</span>
<span class="p_del">-	int version, revision;</span>
<span class="p_add">+	unsigned int vr, cpucfgr;</span>
<span class="p_add">+	unsigned int avr;</span>
<span class="p_add">+	unsigned int version;</span>
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = v;</span>
 
 	vr = mfspr(SPR_VR);
<span class="p_del">-	version = (vr &amp; SPR_VR_VER) &gt;&gt; 24;</span>
<span class="p_del">-	revision = vr &amp; SPR_VR_REV;</span>
<span class="p_del">-</span>
<span class="p_del">-	seq_printf(m,</span>
<span class="p_del">-		  &quot;cpu\t\t: OpenRISC-%x\n&quot;</span>
<span class="p_del">-		  &quot;revision\t: %d\n&quot;</span>
<span class="p_del">-		  &quot;frequency\t: %ld\n&quot;</span>
<span class="p_del">-		  &quot;dcache size\t: %d bytes\n&quot;</span>
<span class="p_del">-		  &quot;dcache block size\t: %d bytes\n&quot;</span>
<span class="p_del">-		  &quot;dcache ways\t: %d\n&quot;</span>
<span class="p_del">-		  &quot;icache size\t: %d bytes\n&quot;</span>
<span class="p_del">-		  &quot;icache block size\t: %d bytes\n&quot;</span>
<span class="p_del">-		  &quot;icache ways\t: %d\n&quot;</span>
<span class="p_del">-		  &quot;immu\t\t: %d entries, %lu ways\n&quot;</span>
<span class="p_del">-		  &quot;dmmu\t\t: %d entries, %lu ways\n&quot;</span>
<span class="p_del">-		  &quot;bogomips\t: %lu.%02lu\n&quot;,</span>
<span class="p_del">-		  version,</span>
<span class="p_del">-		  revision,</span>
<span class="p_del">-		  loops_per_jiffy * HZ,</span>
<span class="p_del">-		  cpuinfo.dcache_size,</span>
<span class="p_del">-		  cpuinfo.dcache_block_size,</span>
<span class="p_del">-		  cpuinfo.dcache_ways,</span>
<span class="p_del">-		  cpuinfo.icache_size,</span>
<span class="p_del">-		  cpuinfo.icache_block_size,</span>
<span class="p_del">-		  cpuinfo.icache_ways,</span>
<span class="p_del">-		  1 &lt;&lt; ((mfspr(SPR_DMMUCFGR) &amp; SPR_DMMUCFGR_NTS) &gt;&gt; 2),</span>
<span class="p_del">-		  1 + (mfspr(SPR_DMMUCFGR) &amp; SPR_DMMUCFGR_NTW),</span>
<span class="p_del">-		  1 &lt;&lt; ((mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTS) &gt;&gt; 2),</span>
<span class="p_del">-		  1 + (mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTW),</span>
<span class="p_del">-		  (loops_per_jiffy * HZ) / 500000,</span>
<span class="p_del">-		  ((loops_per_jiffy * HZ) / 5000) % 100);</span>
<span class="p_add">+	cpucfgr = mfspr(SPR_CPUCFGR);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	seq_printf(m, &quot;processor\t\t: %d\n&quot;, cpuinfo-&gt;coreid);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	if (vr &amp; SPR_VR_UVRP) {</span>
<span class="p_add">+		vr = mfspr(SPR_VR2);</span>
<span class="p_add">+		version = vr &amp; SPR_VR2_VER;</span>
<span class="p_add">+		avr = mfspr(SPR_AVR);</span>
<span class="p_add">+		seq_printf(m, &quot;cpu architecture\t: &quot;</span>
<span class="p_add">+			   &quot;OpenRISC 1000 (%d.%d-rev%d)\n&quot;,</span>
<span class="p_add">+			   (avr &gt;&gt; 24) &amp; 0xff,</span>
<span class="p_add">+			   (avr &gt;&gt; 16) &amp; 0xff,</span>
<span class="p_add">+			   (avr &gt;&gt; 8) &amp; 0xff);</span>
<span class="p_add">+		seq_printf(m, &quot;cpu implementation id\t: 0x%x\n&quot;,</span>
<span class="p_add">+			   (vr &amp; SPR_VR2_CPUID) &gt;&gt; 24);</span>
<span class="p_add">+		seq_printf(m, &quot;cpu version\t\t: 0x%x\n&quot;, version);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		version = (vr &amp; SPR_VR_VER) &gt;&gt; 24;</span>
<span class="p_add">+		seq_printf(m, &quot;cpu\t\t\t: OpenRISC-%x\n&quot;, version);</span>
<span class="p_add">+		seq_printf(m, &quot;revision\t\t: %d\n&quot;, vr &amp; SPR_VR_REV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	seq_printf(m, &quot;frequency\t\t: %ld\n&quot;, loops_per_jiffy * HZ);</span>
<span class="p_add">+	seq_printf(m, &quot;dcache size\t\t: %d bytes\n&quot;, cpuinfo-&gt;dcache_size);</span>
<span class="p_add">+	seq_printf(m, &quot;dcache block size\t: %d bytes\n&quot;,</span>
<span class="p_add">+		   cpuinfo-&gt;dcache_block_size);</span>
<span class="p_add">+	seq_printf(m, &quot;dcache ways\t\t: %d\n&quot;, cpuinfo-&gt;dcache_ways);</span>
<span class="p_add">+	seq_printf(m, &quot;icache size\t\t: %d bytes\n&quot;, cpuinfo-&gt;icache_size);</span>
<span class="p_add">+	seq_printf(m, &quot;icache block size\t: %d bytes\n&quot;,</span>
<span class="p_add">+		   cpuinfo-&gt;icache_block_size);</span>
<span class="p_add">+	seq_printf(m, &quot;icache ways\t\t: %d\n&quot;, cpuinfo-&gt;icache_ways);</span>
<span class="p_add">+	seq_printf(m, &quot;immu\t\t\t: %d entries, %lu ways\n&quot;,</span>
<span class="p_add">+		   1 &lt;&lt; ((mfspr(SPR_DMMUCFGR) &amp; SPR_DMMUCFGR_NTS) &gt;&gt; 2),</span>
<span class="p_add">+		   1 + (mfspr(SPR_DMMUCFGR) &amp; SPR_DMMUCFGR_NTW));</span>
<span class="p_add">+	seq_printf(m, &quot;dmmu\t\t\t: %d entries, %lu ways\n&quot;,</span>
<span class="p_add">+		   1 &lt;&lt; ((mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTS) &gt;&gt; 2),</span>
<span class="p_add">+		   1 + (mfspr(SPR_IMMUCFGR) &amp; SPR_IMMUCFGR_NTW));</span>
<span class="p_add">+	seq_printf(m, &quot;bogomips\t\t: %lu.%02lu\n&quot;,</span>
<span class="p_add">+		   (loops_per_jiffy * HZ) / 500000,</span>
<span class="p_add">+		   ((loops_per_jiffy * HZ) / 5000) % 100);</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_puts(m, &quot;features\t\t: &quot;);</span>
<span class="p_add">+	seq_printf(m, &quot;%s &quot;, cpucfgr &amp; SPR_CPUCFGR_OB32S ? &quot;orbis32&quot; : &quot;&quot;);</span>
<span class="p_add">+	seq_printf(m, &quot;%s &quot;, cpucfgr &amp; SPR_CPUCFGR_OB64S ? &quot;orbis64&quot; : &quot;&quot;);</span>
<span class="p_add">+	seq_printf(m, &quot;%s &quot;, cpucfgr &amp; SPR_CPUCFGR_OF32S ? &quot;orfpx32&quot; : &quot;&quot;);</span>
<span class="p_add">+	seq_printf(m, &quot;%s &quot;, cpucfgr &amp; SPR_CPUCFGR_OF64S ? &quot;orfpx64&quot; : &quot;&quot;);</span>
<span class="p_add">+	seq_printf(m, &quot;%s &quot;, cpucfgr &amp; SPR_CPUCFGR_OV64S ? &quot;orvdx64&quot; : &quot;&quot;);</span>
<span class="p_add">+	seq_puts(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_puts(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_del">-static void *c_start(struct seq_file *m, loff_t * pos)</span>
<span class="p_add">+static void *c_start(struct seq_file *m, loff_t *pos)</span>
 {
<span class="p_del">-	/* We only have one CPU... */</span>
<span class="p_del">-	return *pos &lt; 1 ? (void *)1 : NULL;</span>
<span class="p_add">+	*pos = cpumask_next(*pos - 1, cpu_online_mask);</span>
<span class="p_add">+	if ((*pos) &lt; nr_cpu_ids)</span>
<span class="p_add">+		return &amp;cpuinfo_or1k[*pos];</span>
<span class="p_add">+	return NULL;</span>
 }
 
<span class="p_del">-static void *c_next(struct seq_file *m, void *v, loff_t * pos)</span>
<span class="p_add">+static void *c_next(struct seq_file *m, void *v, loff_t *pos)</span>
 {
<span class="p_del">-	++*pos;</span>
<span class="p_del">-	return NULL;</span>
<span class="p_add">+	(*pos)++;</span>
<span class="p_add">+	return c_start(m, pos);</span>
 }
 
 static void c_stop(struct seq_file *m, void *v)
<span class="p_header">diff --git a/arch/openrisc/kernel/smp.c b/arch/openrisc/kernel/smp.c</span>
new file mode 100644
<span class="p_header">index 000000000000..fd724123229a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/openrisc/kernel/smp.c</span>
<span class="p_chunk">@@ -0,0 +1,235 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Stefan Kristiansson &lt;stefan.kristiansson@saunalahti.fi&gt;</span>
<span class="p_add">+ * Copyright (C) 2017 Stafford Horne &lt;shorne@gmail.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Based on arm64 and arc implementations</span>
<span class="p_add">+ * Copyright (C) 2013 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is licensed under the terms of the GNU General Public License</span>
<span class="p_add">+ * version 2.  This program is licensed &quot;as is&quot; without any warranty of any</span>
<span class="p_add">+ * kind, whether express or implied.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;asm/cpuinfo.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/time.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void (*smp_cross_call)(const struct cpumask *, unsigned int);</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long secondary_release = -1;</span>
<span class="p_add">+struct thread_info *secondary_thread_info;</span>
<span class="p_add">+</span>
<span class="p_add">+enum ipi_msg_type {</span>
<span class="p_add">+	IPI_RESCHEDULE,</span>
<span class="p_add">+	IPI_CALL_FUNC,</span>
<span class="p_add">+	IPI_CALL_FUNC_SINGLE,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_SPINLOCK(boot_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+static void boot_secondary(unsigned int cpu, struct task_struct *idle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * set synchronisation state between this boot processor</span>
<span class="p_add">+	 * and the secondary one</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;boot_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	secondary_release = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * now the secondary core is starting up let it run its</span>
<span class="p_add">+	 * calibrations, then wait for it to finish</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_unlock(&amp;boot_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_boot_cpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_init_cpus(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; NR_CPUS; i++)</span>
<span class="p_add">+		set_cpu_possible(i, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialise the present map, which describes the set of CPUs</span>
<span class="p_add">+	 * actually populated at the present time.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; max_cpus; i++)</span>
<span class="p_add">+		set_cpu_present(i, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_cpus_done(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static DECLARE_COMPLETION(cpu_running);</span>
<span class="p_add">+</span>
<span class="p_add">+int __cpu_up(unsigned int cpu, struct task_struct *idle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (smp_cross_call == NULL) {</span>
<span class="p_add">+		pr_warn(&quot;CPU%u: failed to start, IPI controller missing&quot;,</span>
<span class="p_add">+			cpu);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	secondary_thread_info = task_thread_info(idle);</span>
<span class="p_add">+	current_pgd[cpu] = init_mm.pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+	boot_secondary(cpu, idle);</span>
<span class="p_add">+	if (!wait_for_completion_timeout(&amp;cpu_running,</span>
<span class="p_add">+					msecs_to_jiffies(1000))) {</span>
<span class="p_add">+		pr_crit(&quot;CPU%u: failed to start\n&quot;, cpu);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage __init void secondary_start_kernel(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = &amp;init_mm;</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * All kernel threads share the same mm context; grab a</span>
<span class="p_add">+	 * reference and switch to it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+	current-&gt;active_mm = mm;</span>
<span class="p_add">+	cpumask_set_cpu(cpu, mm_cpumask(mm));</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;CPU%u: Booted secondary processor\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_cpuinfo();</span>
<span class="p_add">+	openrisc_clockevent_init();</span>
<span class="p_add">+</span>
<span class="p_add">+	notify_cpu_starting(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * OK, now it&#39;s safe to let the boot CPU continue</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_cpu_online(cpu, true);</span>
<span class="p_add">+	complete(&amp;cpu_running);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * OK, it&#39;s off to the idle thread for us</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void handle_IPI(unsigned int ipi_msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (ipi_msg) {</span>
<span class="p_add">+	case IPI_RESCHEDULE:</span>
<span class="p_add">+		scheduler_ipi();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case IPI_CALL_FUNC:</span>
<span class="p_add">+		generic_smp_call_function_interrupt();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case IPI_CALL_FUNC_SINGLE:</span>
<span class="p_add">+		generic_smp_call_function_single_interrupt();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		WARN(1, &quot;CPU%u: Unknown IPI message 0x%x\n&quot;, cpu, ipi_msg);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_reschedule(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smp_cross_call(cpumask_of(cpu), IPI_RESCHEDULE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void stop_this_cpu(void *dummy)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Remove this CPU */</span>
<span class="p_add">+	set_cpu_online(smp_processor_id(), false);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	/* CPU Doze */</span>
<span class="p_add">+	if (mfspr(SPR_UPR) &amp; SPR_UPR_PMP)</span>
<span class="p_add">+		mtspr(SPR_PMR, mfspr(SPR_PMR) | SPR_PMR_DME);</span>
<span class="p_add">+	/* If that didn&#39;t work, infinite loop */</span>
<span class="p_add">+	while (1)</span>
<span class="p_add">+		;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smp_call_function(stop_this_cpu, NULL, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* not supported, yet */</span>
<span class="p_add">+int setup_profiling_timer(unsigned int multiplier)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init set_smp_cross_call(void (*fn)(const struct cpumask *, unsigned int))</span>
<span class="p_add">+{</span>
<span class="p_add">+	smp_cross_call = fn;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smp_cross_call(cpumask_of(cpu), IPI_CALL_FUNC_SINGLE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(const struct cpumask *mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smp_cross_call(mask, IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* TLB flush operations - Performed on each CPU*/</span>
<span class="p_add">+static inline void ipi_flush_tlb_all(void *ignored)</span>
<span class="p_add">+{</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void flush_tlb_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_flush_tlb_all, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * FIXME: implement proper functionality instead of flush_tlb_all.</span>
<span class="p_add">+ * *But*, as things currently stands, the local_tlb_flush_* functions will</span>
<span class="p_add">+ * all boil down to local_tlb_flush_all anyway.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void flush_tlb_mm(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_flush_tlb_all, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_flush_tlb_all, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_add">+		     unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_flush_tlb_all, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/openrisc/kernel/time.c b/arch/openrisc/kernel/time.c</span>
<span class="p_header">index 687c11d048d7..ab04eaedbf8d 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/time.c</span>
<span class="p_header">+++ b/arch/openrisc/kernel/time.c</span>
<span class="p_chunk">@@ -53,13 +53,32 @@</span> <span class="p_context"> static int openrisc_timer_set_next_event(unsigned long delta,</span>
  * timers) we cannot enable the PERIODIC feature.  The tick timer can run using
  * one-shot events, so no problem.
  */
<span class="p_add">+DEFINE_PER_CPU(struct clock_event_device, clockevent_openrisc_timer);</span>
 
<span class="p_del">-static struct clock_event_device clockevent_openrisc_timer = {</span>
<span class="p_del">-	.name = &quot;openrisc_timer_clockevent&quot;,</span>
<span class="p_del">-	.features = CLOCK_EVT_FEAT_ONESHOT,</span>
<span class="p_del">-	.rating = 300,</span>
<span class="p_del">-	.set_next_event = openrisc_timer_set_next_event,</span>
<span class="p_del">-};</span>
<span class="p_add">+void openrisc_clockevent_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct clock_event_device *evt =</span>
<span class="p_add">+		&amp;per_cpu(clockevent_openrisc_timer, cpu);</span>
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	mtspr(SPR_TTMR, SPR_TTMR_CR);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	evt-&gt;broadcast = tick_broadcast;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	evt-&gt;name = &quot;openrisc_timer_clockevent&quot;,</span>
<span class="p_add">+	evt-&gt;features = CLOCK_EVT_FEAT_ONESHOT,</span>
<span class="p_add">+	evt-&gt;rating = 300,</span>
<span class="p_add">+	evt-&gt;set_next_event = openrisc_timer_set_next_event,</span>
<span class="p_add">+</span>
<span class="p_add">+	evt-&gt;cpumask = cpumask_of(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We only have 28 bits */</span>
<span class="p_add">+	clockevents_config_and_register(evt, cpuinfo-&gt;clock_frequency,</span>
<span class="p_add">+					100, 0x0fffffff);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
 
 static inline void timer_ack(void)
 {
<span class="p_chunk">@@ -83,7 +102,9 @@</span> <span class="p_context"> static inline void timer_ack(void)</span>
 irqreturn_t __irq_entry timer_interrupt(struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
<span class="p_del">-	struct clock_event_device *evt = &amp;clockevent_openrisc_timer;</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct clock_event_device *evt =</span>
<span class="p_add">+		&amp;per_cpu(clockevent_openrisc_timer, cpu);</span>
 
 	timer_ack();
 
<span class="p_chunk">@@ -99,24 +120,12 @@</span> <span class="p_context"> irqreturn_t __irq_entry timer_interrupt(struct pt_regs *regs)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static __init void openrisc_clockevent_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	clockevent_openrisc_timer.cpumask = cpumask_of(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We only have 28 bits */</span>
<span class="p_del">-	clockevents_config_and_register(&amp;clockevent_openrisc_timer,</span>
<span class="p_del">-					cpuinfo.clock_frequency,</span>
<span class="p_del">-					100, 0x0fffffff);</span>
<span class="p_del">-</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * Clocksource: Based on OpenRISC timer/counter
  *
  * This sets up the OpenRISC Tick Timer as a clock source.  The tick timer
  * is 32 bits wide and runs at the CPU clock frequency.
  */
<span class="p_del">-</span>
 static u64 openrisc_timer_read(struct clocksource *cs)
 {
 	return (u64) mfspr(SPR_TTCR);
<span class="p_chunk">@@ -132,7 +141,9 @@</span> <span class="p_context"> static struct clocksource openrisc_timer = {</span>
 
 static int __init openrisc_timer_init(void)
 {
<span class="p_del">-	if (clocksource_register_hz(&amp;openrisc_timer, cpuinfo.clock_frequency))</span>
<span class="p_add">+	struct cpuinfo_or1k *cpuinfo = &amp;cpuinfo_or1k[smp_processor_id()];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (clocksource_register_hz(&amp;openrisc_timer, cpuinfo-&gt;clock_frequency))</span>
 		panic(&quot;failed to register clocksource&quot;);
 
 	/* Enable the incrementer: &#39;continuous&#39; mode with interrupt disabled */
<span class="p_header">diff --git a/arch/openrisc/lib/delay.c b/arch/openrisc/lib/delay.c</span>
<span class="p_header">index 8b13fdf43ec6..a92bd621aa1f 100644</span>
<span class="p_header">--- a/arch/openrisc/lib/delay.c</span>
<span class="p_header">+++ b/arch/openrisc/lib/delay.c</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"></span>
 
 int read_current_timer(unsigned long *timer_value)
 {
<span class="p_del">-	*timer_value = mfspr(SPR_TTCR);</span>
<span class="p_add">+	*timer_value = get_cycles();</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/openrisc/mm/fault.c b/arch/openrisc/mm/fault.c</span>
<span class="p_header">index e310ab499385..d0021dfae20a 100644</span>
<span class="p_header">--- a/arch/openrisc/mm/fault.c</span>
<span class="p_header">+++ b/arch/openrisc/mm/fault.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> unsigned long pte_errors;	/* updated by do_page_fault() */</span>
 /* __PHX__ :: - check the vmalloc_fault in do_page_fault()
  *            - also look into include/asm-or32/mmu_context.h
  */
<span class="p_del">-volatile pgd_t *current_pgd;</span>
<span class="p_add">+volatile pgd_t *current_pgd[NR_CPUS];</span>
 
 extern void die(char *, struct pt_regs *, long);
 
<span class="p_chunk">@@ -319,7 +319,7 @@</span> <span class="p_context"> asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long address,</span>
 
 		phx_mmu(&quot;vmalloc_fault&quot;);
 */
<span class="p_del">-		pgd = (pgd_t *)current_pgd + offset;</span>
<span class="p_add">+		pgd = (pgd_t *)current_pgd[smp_processor_id()] + offset;</span>
 		pgd_k = init_mm.pgd + offset;
 
 		/* Since we&#39;re two-level, we don&#39;t need to do both
<span class="p_header">diff --git a/arch/openrisc/mm/init.c b/arch/openrisc/mm/init.c</span>
<span class="p_header">index f67d82b9d22f..6972d5d6f23f 100644</span>
<span class="p_header">--- a/arch/openrisc/mm/init.c</span>
<span class="p_header">+++ b/arch/openrisc/mm/init.c</span>
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> void __init paging_init(void)</span>
 	 * (even if it is most probably not used until the next
 	 *  switch_mm)
 	 */
<span class="p_del">-	current_pgd = init_mm.pgd;</span>
<span class="p_add">+	current_pgd[smp_processor_id()] = init_mm.pgd;</span>
 
 	end = (unsigned long)__va(max_low_pfn * PAGE_SIZE);
 
<span class="p_header">diff --git a/arch/openrisc/mm/tlb.c b/arch/openrisc/mm/tlb.c</span>
<span class="p_header">index 683bd4d31c7c..6c253a2e86bc 100644</span>
<span class="p_header">--- a/arch/openrisc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/openrisc/mm/tlb.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_del">-void flush_tlb_all(void)</span>
<span class="p_add">+void local_flush_tlb_all(void)</span>
 {
 	int i;
 	unsigned long num_tlb_sets;
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> void flush_tlb_all(void)</span>
 #define flush_itlb_page_no_eir(addr) \
 	mtspr_off(SPR_ITLBMR_BASE(0), ITLB_OFFSET(addr), 0);
 
<span class="p_del">-void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_add">+void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)</span>
 {
 	if (have_dtlbeir)
 		flush_dtlb_page_eir(addr);
<span class="p_chunk">@@ -99,8 +99,8 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)</span>
 		flush_itlb_page_no_eir(addr);
 }
 
<span class="p_del">-void flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_del">-		     unsigned long start, unsigned long end)</span>
<span class="p_add">+void local_flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_add">+			   unsigned long start, unsigned long end)</span>
 {
 	int addr;
 	bool dtlbeir;
<span class="p_chunk">@@ -129,13 +129,13 @@</span> <span class="p_context"> void flush_tlb_range(struct vm_area_struct *vma,</span>
  * This should be changed to loop over over mm and call flush_tlb_range.
  */
 
<span class="p_del">-void flush_tlb_mm(struct mm_struct *mm)</span>
<span class="p_add">+void local_flush_tlb_mm(struct mm_struct *mm)</span>
 {
 
 	/* Was seeing bugs with the mm struct passed to us. Scrapped most of
 	   this function. */
 	/* Several architctures do this */
<span class="p_del">-	flush_tlb_all();</span>
<span class="p_add">+	local_flush_tlb_all();</span>
 }
 
 /* called in schedule() just before actually doing the switch_to */
<span class="p_chunk">@@ -149,14 +149,14 @@</span> <span class="p_context"> void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 	 * might be invalid at points where we still need to derefer
 	 * the pgd.
 	 */
<span class="p_del">-	current_pgd = next-&gt;pgd;</span>
<span class="p_add">+	current_pgd[smp_processor_id()] = next-&gt;pgd;</span>
 
 	/* We don&#39;t have context support implemented, so flush all
 	 * entries belonging to previous map
 	 */
 
 	if (prev != next)
<span class="p_del">-		flush_tlb_mm(prev);</span>
<span class="p_add">+		local_flush_tlb_mm(prev);</span>
 
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



