
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.2,000/152] 3.2.84-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.2,000/152] 3.2.84-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 14, 2016, 4:05 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1479096317.3755.13.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9426391/mbox/"
   >mbox</a>
|
   <a href="/patch/9426391/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9426391/">/patch/9426391/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	133E860471 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Nov 2016 04:06:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E58B728068
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Nov 2016 04:06:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D281D288F3; Mon, 14 Nov 2016 04:06:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D5D5428068
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 14 Nov 2016 04:05:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S941299AbcKNEFq (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 13 Nov 2016 23:05:46 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:48164 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S933472AbcKNEF3 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 13 Nov 2016 23:05:29 -0500
Received: from [2a02:8011:400e:2:6f00:88c8:c921:d332] (helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256) (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1c68WI-0005T6-HH; Mon, 14 Nov 2016 04:05:23 +0000
Received: from ben by deadeye with local (Exim 4.87)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1c68WI-00083w-21; Mon, 14 Nov 2016 04:05:22 +0000
Message-ID: &lt;1479096317.3755.13.camel@decadent.org.uk&gt;
Subject: Re: [PATCH 3.2 000/152] 3.2.84-rc1 review
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: torvalds@linux-foundation.org, Guenter Roeck &lt;linux@roeck-us.net&gt;,
	akpm@linux-foundation.org
Date: Mon, 14 Nov 2016 04:05:17 +0000
In-Reply-To: &lt;lsq.1479082446.271293126@decadent.org.uk&gt;
References: &lt;lsq.1479082446.271293126@decadent.org.uk&gt;
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-J33oBKbWyqNpXO9gLZtz&quot;
X-Mailer: Evolution 3.22.1-2 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 2a02:8011:400e:2:6f00:88c8:c921:d332
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Nov. 14, 2016, 4:05 a.m.</div>
<pre class="content">
This is the combined diff for 3.2.84-rc1 relative to 3.2.83.

Ben.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/filesystems/porting b/Documentation/filesystems/porting</span>
<span class="p_header">index b4a3d765ff9a..56a9c6eab33f 100644</span>
<span class="p_header">--- a/Documentation/filesystems/porting</span>
<span class="p_header">+++ b/Documentation/filesystems/porting</span>
<span class="p_chunk">@@ -288,8 +288,8 @@</span> <span class="p_context"> implementing on-disk size changes.  Start with a copy of the old inode_setattr</span>
 and vmtruncate, and the reorder the vmtruncate + foofs_vmtruncate sequence to
 be in order of zeroing blocks using block_truncate_page or similar helpers,
 size update and on finally on-disk truncation which should not fail.
<span class="p_del">-inode_change_ok now includes the size checks for ATTR_SIZE and must be called</span>
<span class="p_del">-in the beginning of -&gt;setattr unconditionally.</span>
<span class="p_add">+setattr_prepare (which used to be inode_change_ok) now includes the size checks</span>
<span class="p_add">+for ATTR_SIZE and must be called in the beginning of -&gt;setattr unconditionally.</span>
 
 [mandatory]
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 716cdade034d..c8266a0f6a9d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 83</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 84</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/alpha/include/asm/uaccess.h b/arch/alpha/include/asm/uaccess.h</span>
<span class="p_header">index b49ec2f8d6e3..3cd61320e024 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -371,14 +371,6 @@</span> <span class="p_context"> __copy_tofrom_user_nocheck(void *to, const void *from, long len)</span>
 	return __cu_len;
 }
 
<span class="p_del">-extern inline long</span>
<span class="p_del">-__copy_tofrom_user(void *to, const void *from, long len, const void __user *validate)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (__access_ok((unsigned long)validate, len, get_fs()))</span>
<span class="p_del">-		len = __copy_tofrom_user_nocheck(to, from, len);</span>
<span class="p_del">-	return len;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #define __copy_to_user(to,from,n)					\
 ({									\
 	__chk_user_ptr(to);						\
<span class="p_chunk">@@ -393,17 +385,22 @@</span> <span class="p_context"> __copy_tofrom_user(void *to, const void *from, long len, const void __user *vali</span>
 #define __copy_to_user_inatomic __copy_to_user
 #define __copy_from_user_inatomic __copy_from_user
 
<span class="p_del">-</span>
 extern inline long
 copy_to_user(void __user *to, const void *from, long n)
 {
<span class="p_del">-	return __copy_tofrom_user((__force void *)to, from, n, to);</span>
<span class="p_add">+	if (likely(__access_ok((unsigned long)to, n, get_fs())))</span>
<span class="p_add">+		n = __copy_tofrom_user_nocheck((__force void *)to, from, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 extern inline long
 copy_from_user(void *to, const void __user *from, long n)
 {
<span class="p_del">-	return __copy_tofrom_user(to, (__force void *)from, n, from);</span>
<span class="p_add">+	if (likely(__access_ok((unsigned long)from, n, get_fs())))</span>
<span class="p_add">+		n = __copy_tofrom_user_nocheck(to, (__force void *)from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 extern void __do_clear_user(void);
<span class="p_header">diff --git a/arch/arm/common/sa1111.c b/arch/arm/common/sa1111.c</span>
<span class="p_header">index 61691cdbdcf2..cab1725a1017 100644</span>
<span class="p_header">--- a/arch/arm/common/sa1111.c</span>
<span class="p_header">+++ b/arch/arm/common/sa1111.c</span>
<span class="p_chunk">@@ -878,9 +878,9 @@</span> <span class="p_context"> struct sa1111_save_data {</span>
 
 #ifdef CONFIG_PM
 
<span class="p_del">-static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
<span class="p_add">+static int sa1111_suspend_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags;
 	unsigned int val;
<span class="p_chunk">@@ -938,9 +938,9 @@</span> <span class="p_context"> static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
  *	restored by their respective drivers, and must be called
  *	via LDM after this function.
  */
<span class="p_del">-static int sa1111_resume(struct platform_device *dev)</span>
<span class="p_add">+static int sa1111_resume_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags, id;
 	void __iomem *base;
<span class="p_chunk">@@ -956,7 +956,7 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 	id = sa1111_readl(sachip-&gt;base + SA1111_SKID);
 	if ((id &amp; SKID_ID_MASK) != SKID_SA1111_ID) {
 		__sa1111_remove(sachip);
<span class="p_del">-		platform_set_drvdata(dev, NULL);</span>
<span class="p_add">+		dev_set_drvdata(dev, NULL);</span>
 		kfree(save);
 		return 0;
 	}
<span class="p_chunk">@@ -1002,8 +1002,8 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 }
 
 #else
<span class="p_del">-#define sa1111_suspend NULL</span>
<span class="p_del">-#define sa1111_resume  NULL</span>
<span class="p_add">+#define sa1111_suspend_noirq NULL</span>
<span class="p_add">+#define sa1111_resume_noirq  NULL</span>
 #endif
 
 static int __devinit sa1111_probe(struct platform_device *pdev)
<span class="p_chunk">@@ -1037,6 +1037,11 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static struct dev_pm_ops sa1111_pm_ops = {</span>
<span class="p_add">+	.suspend_noirq = sa1111_suspend_noirq,</span>
<span class="p_add">+	.resume_noirq = sa1111_resume_noirq,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  *	Not sure if this should be on the system bus or not yet.
  *	We really want some way to register a system device at
<span class="p_chunk">@@ -1049,10 +1054,9 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 static struct platform_driver sa1111_device_driver = {
 	.probe		= sa1111_probe,
 	.remove		= sa1111_remove,
<span class="p_del">-	.suspend	= sa1111_suspend,</span>
<span class="p_del">-	.resume		= sa1111_resume,</span>
 	.driver		= {
 		.name	= &quot;sa1111&quot;,
<span class="p_add">+		.pm	= &amp;sa1111_pm_ops,</span>
 	},
 };
 
<span class="p_header">diff --git a/arch/arm/kernel/sys_oabi-compat.c b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">index af0aaebf4de6..32884a6006cf 100644</span>
<span class="p_header">--- a/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_header">+++ b/arch/arm/kernel/sys_oabi-compat.c</span>
<span class="p_chunk">@@ -275,8 +275,12 @@</span> <span class="p_context"> asmlinkage long sys_oabi_epoll_wait(int epfd,</span>
 	mm_segment_t fs;
 	long ret, err, i;
 
<span class="p_del">-	if (maxevents &lt;= 0 || maxevents &gt; (INT_MAX/sizeof(struct epoll_event)))</span>
<span class="p_add">+	if (maxevents &lt;= 0 ||</span>
<span class="p_add">+			maxevents &gt; (INT_MAX/sizeof(*kbuf)) ||</span>
<span class="p_add">+			maxevents &gt; (INT_MAX/sizeof(*events)))</span>
 		return -EINVAL;
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, events, sizeof(*events) * maxevents))</span>
<span class="p_add">+		return -EFAULT;</span>
 	kbuf = kmalloc(sizeof(*kbuf) * maxevents, GFP_KERNEL);
 	if (!kbuf)
 		return -ENOMEM;
<span class="p_chunk">@@ -313,6 +317,8 @@</span> <span class="p_context"> asmlinkage long sys_oabi_semtimedop(int semid,</span>
 
 	if (nsops &lt; 1 || nsops &gt; SEMOPM)
 		return -EINVAL;
<span class="p_add">+	if (!access_ok(VERIFY_READ, tsops, sizeof(*tsops) * nsops))</span>
<span class="p_add">+		return -EFAULT;</span>
 	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
 	if (!sops)
 		return -ENOMEM;
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">index eef43e2e163e..d8a185d7bdc1 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_hwmod_3xxx_data.c</span>
<span class="p_chunk">@@ -1470,8 +1470,20 @@</span> <span class="p_context"> static struct omap_hwmod omap3xxx_dss_dispc_hwmod = {</span>
  * display serial interface controller
  */
 
<span class="p_add">+static struct omap_hwmod_class_sysconfig omap3xxx_dsi_sysc = {</span>
<span class="p_add">+	.rev_offs	= 0x0000,</span>
<span class="p_add">+	.sysc_offs	= 0x0010,</span>
<span class="p_add">+	.syss_offs	= 0x0014,</span>
<span class="p_add">+	.sysc_flags	= (SYSC_HAS_AUTOIDLE | SYSC_HAS_CLOCKACTIVITY |</span>
<span class="p_add">+			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |</span>
<span class="p_add">+			   SYSC_HAS_SOFTRESET | SYSS_HAS_RESET_STATUS),</span>
<span class="p_add">+	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),</span>
<span class="p_add">+	.sysc_fields	= &amp;omap_hwmod_sysc_type1,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct omap_hwmod_class omap3xxx_dsi_hwmod_class = {
 	.name = &quot;dsi&quot;,
<span class="p_add">+	.sysc	= &amp;omap3xxx_dsi_sysc,</span>
 };
 
 static struct omap_hwmod_irq_info omap3xxx_dsi1_irqs[] = {
<span class="p_header">diff --git a/arch/avr32/include/asm/uaccess.h b/arch/avr32/include/asm/uaccess.h</span>
<span class="p_header">index 245b2ee213c9..a0a9b8c31041 100644</span>
<span class="p_header">--- a/arch/avr32/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/avr32/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> extern __kernel_size_t __copy_user(void *to, const void *from,</span>
 
 extern __kernel_size_t copy_to_user(void __user *to, const void *from,
 				    __kernel_size_t n);
<span class="p_del">-extern __kernel_size_t copy_from_user(void *to, const void __user *from,</span>
<span class="p_add">+extern __kernel_size_t ___copy_from_user(void *to, const void __user *from,</span>
 				      __kernel_size_t n);
 
 static inline __kernel_size_t __copy_to_user(void __user *to, const void *from,
<span class="p_chunk">@@ -88,6 +88,15 @@</span> <span class="p_context"> static inline __kernel_size_t __copy_from_user(void *to,</span>
 {
 	return __copy_user(to, (const void __force *)from, n);
 }
<span class="p_add">+static inline __kernel_size_t copy_from_user(void *to,</span>
<span class="p_add">+					       const void __user *from,</span>
<span class="p_add">+					       __kernel_size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t res = ___copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 
 #define __copy_to_user_inatomic __copy_to_user
 #define __copy_from_user_inatomic __copy_from_user
<span class="p_header">diff --git a/arch/avr32/kernel/avr32_ksyms.c b/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_header">index d93ead02daed..7c6cf14f0985 100644</span>
<span class="p_header">--- a/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_header">+++ b/arch/avr32/kernel/avr32_ksyms.c</span>
<span class="p_chunk">@@ -36,7 +36,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_page);</span>
 /*
  * Userspace access stuff.
  */
<span class="p_del">-EXPORT_SYMBOL(copy_from_user);</span>
<span class="p_add">+EXPORT_SYMBOL(___copy_from_user);</span>
 EXPORT_SYMBOL(copy_to_user);
 EXPORT_SYMBOL(__copy_user);
 EXPORT_SYMBOL(strncpy_from_user);
<span class="p_header">diff --git a/arch/avr32/lib/copy_user.S b/arch/avr32/lib/copy_user.S</span>
<span class="p_header">index ea59c04b07de..075373471da1 100644</span>
<span class="p_header">--- a/arch/avr32/lib/copy_user.S</span>
<span class="p_header">+++ b/arch/avr32/lib/copy_user.S</span>
<span class="p_chunk">@@ -23,13 +23,13 @@</span> <span class="p_context"></span>
 	 */
 	.text
 	.align	1
<span class="p_del">-	.global	copy_from_user</span>
<span class="p_del">-	.type	copy_from_user, @function</span>
<span class="p_del">-copy_from_user:</span>
<span class="p_add">+	.global	___copy_from_user</span>
<span class="p_add">+	.type	___copy_from_user, @function</span>
<span class="p_add">+___copy_from_user:</span>
 	branch_if_kernel r8, __copy_user
 	ret_if_privileged r8, r11, r10, r10
 	rjmp	__copy_user
<span class="p_del">-	.size	copy_from_user, . - copy_from_user</span>
<span class="p_add">+	.size	___copy_from_user, . - ___copy_from_user</span>
 
 	.global	copy_to_user
 	.type	copy_to_user, @function
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/pio.c b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">index 903c7d81d0d5..a8e208eaf2a4 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> void __init at32_init_pio(struct platform_device *pdev)</span>
 	struct resource *regs;
 	struct pio_device *pio;
 
<span class="p_del">-	if (pdev-&gt;id &gt; MAX_NR_PIO_DEVICES) {</span>
<span class="p_add">+	if (pdev-&gt;id &gt;= MAX_NR_PIO_DEVICES) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;only %d PIO devices supported\n&quot;,
 			MAX_NR_PIO_DEVICES);
 		return;
<span class="p_header">diff --git a/arch/blackfin/include/asm/uaccess.h b/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_header">index 5cc111502822..8f9d497a20a3 100644</span>
<span class="p_header">--- a/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/blackfin/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -194,11 +194,12 @@</span> <span class="p_context"> static inline int bad_user_access_length(void)</span>
 static inline unsigned long __must_check
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n))) {</span>
 		memcpy(to, (const void __force *)from, n);
<span class="p_del">-	else</span>
<span class="p_del">-		return n;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
 }
 
 static inline unsigned long __must_check
<span class="p_header">diff --git a/arch/cris/include/asm/uaccess.h b/arch/cris/include/asm/uaccess.h</span>
<span class="p_header">index 914540801c5e..93bfa8acc38b 100644</span>
<span class="p_header">--- a/arch/cris/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/cris/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -176,30 +176,6 @@</span> <span class="p_context"> extern unsigned long __copy_user(void __user *to, const void *from, unsigned lon</span>
 extern unsigned long __copy_user_zeroing(void *to, const void __user *from, unsigned long n);
 extern unsigned long __do_clear_user(void __user *to, unsigned long n);
 
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_copy_to_user(void __user *to, const void *from, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __copy_user(to,from,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_user_zeroing(to,from,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-__generic_clear_user(void __user *to, unsigned long n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __do_clear_user(to,n);</span>
<span class="p_del">-	return n;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline long
 __strncpy_from_user(char *dst, const char __user *src, long count)
 {
<span class="p_chunk">@@ -262,7 +238,7 @@</span> <span class="p_context"> __constant_copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 	else if (n == 24)
 		__asm_copy_from_user_24(to, from, ret);
 	else
<span class="p_del">-		ret = __generic_copy_from_user(to, from, n);</span>
<span class="p_add">+		ret = __copy_user_zeroing(to, from, n);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -312,7 +288,7 @@</span> <span class="p_context"> __constant_copy_to_user(void __user *to, const void *from, unsigned long n)</span>
 	else if (n == 24)
 		__asm_copy_to_user_24(to, from, ret);
 	else
<span class="p_del">-		ret = __generic_copy_to_user(to, from, n);</span>
<span class="p_add">+		ret = __copy_user(to, from, n);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -344,26 +320,43 @@</span> <span class="p_context"> __constant_clear_user(void __user *to, unsigned long n)</span>
 	else if (n == 24)
 		__asm_clear_24(to, ret);
 	else
<span class="p_del">-		ret = __generic_clear_user(to, n);</span>
<span class="p_add">+		ret = __do_clear_user(to, n);</span>
 
 	return ret;
 }
 
 
<span class="p_del">-#define clear_user(to, n)			\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_clear_user(to, n) :			\</span>
<span class="p_del">- __generic_clear_user(to, n))</span>
<span class="p_add">+static inline size_t clear_user(void __user *to, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_clear_user(to, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __do_clear_user(to, n);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define copy_from_user(to, from, n)		\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_copy_from_user(to, from, n) :	\</span>
<span class="p_del">- __generic_copy_from_user(to, from, n))</span>
<span class="p_add">+static inline size_t copy_from_user(void *to, const void __user *from, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_READ, from, n))) {</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_copy_from_user(to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __copy_user_zeroing(to, from, n);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#define copy_to_user(to, from, n)		\</span>
<span class="p_del">-(__builtin_constant_p(n) ?			\</span>
<span class="p_del">- __constant_copy_to_user(to, from, n) :		\</span>
<span class="p_del">- __generic_copy_to_user(to, from, n))</span>
<span class="p_add">+static inline size_t copy_to_user(void __user *to, const void *from, size_t n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		return n;</span>
<span class="p_add">+	if (__builtin_constant_p(n))</span>
<span class="p_add">+		return __constant_copy_to_user(to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return __copy_user(to, from, n);</span>
<span class="p_add">+}</span>
 
 /* We let the __ versions of copy_from/to_user inline, because they&#39;re often
  * used in fast paths and have only a small space overhead.
<span class="p_header">diff --git a/arch/frv/include/asm/uaccess.h b/arch/frv/include/asm/uaccess.h</span>
<span class="p_header">index 0b67ec5b4414..3a74137eeef8 100644</span>
<span class="p_header">--- a/arch/frv/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/frv/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -263,19 +263,25 @@</span> <span class="p_context"> do {							\</span>
 extern long __memset_user(void *dst, unsigned long count);
 extern long __memcpy_user(void *dst, const void *src, unsigned long count);
 
<span class="p_del">-#define clear_user(dst,count)			__memset_user(____force(dst), (count))</span>
<span class="p_add">+#define __clear_user(dst,count)			__memset_user(____force(dst), (count))</span>
 #define __copy_from_user_inatomic(to, from, n)	__memcpy_user((to), ____force(from), (n))
 #define __copy_to_user_inatomic(to, from, n)	__memcpy_user(____force(to), (from), (n))
 
 #else
 
<span class="p_del">-#define clear_user(dst,count)			(memset(____force(dst), 0, (count)), 0)</span>
<span class="p_add">+#define __clear_user(dst,count)			(memset(____force(dst), 0, (count)), 0)</span>
 #define __copy_from_user_inatomic(to, from, n)	(memcpy((to), ____force(from), (n)), 0)
 #define __copy_to_user_inatomic(to, from, n)	(memcpy(____force(to), (from), (n)), 0)
 
 #endif
 
<span class="p_del">-#define __clear_user clear_user</span>
<span class="p_add">+static inline unsigned long __must_check</span>
<span class="p_add">+clear_user(void __user *to, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(__access_ok(to, n)))</span>
<span class="p_add">+		n = __clear_user(to, n);</span>
<span class="p_add">+	return n;</span>
<span class="p_add">+}</span>
 
 static inline unsigned long __must_check
 __copy_to_user(void __user *to, const void *from, unsigned long n)
<span class="p_header">diff --git a/arch/hexagon/include/asm/uaccess.h b/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_header">index 7e706eadbf0a..c73897c5f7b3 100644</span>
<span class="p_header">--- a/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/hexagon/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -102,7 +102,8 @@</span> <span class="p_context"> static inline long hexagon_strncpy_from_user(char *dst, const char __user *src,</span>
 {
 	long res = __strnlen_user(src, n);
 
<span class="p_del">-	/* return from strnlen can&#39;t be zero -- that would be rubbish. */</span>
<span class="p_add">+	if (unlikely(!res))</span>
<span class="p_add">+		return -EFAULT;</span>
 
 	if (res &gt; n) {
 		copy_from_user(dst, src, n);
<span class="p_header">diff --git a/arch/ia64/include/asm/uaccess.h b/arch/ia64/include/asm/uaccess.h</span>
<span class="p_header">index 449c8c0fa2bd..810926c56e31 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -262,17 +262,15 @@</span> <span class="p_context"> __copy_from_user (void *to, const void __user *from, unsigned long count)</span>
 	__cu_len;									\
 })
 
<span class="p_del">-#define copy_from_user(to, from, n)							\</span>
<span class="p_del">-({											\</span>
<span class="p_del">-	void *__cu_to = (to);								\</span>
<span class="p_del">-	const void __user *__cu_from = (from);						\</span>
<span class="p_del">-	long __cu_len = (n);								\</span>
<span class="p_del">-											\</span>
<span class="p_del">-	__chk_user_ptr(__cu_from);							\</span>
<span class="p_del">-	if (__access_ok(__cu_from, __cu_len, get_fs()))					\</span>
<span class="p_del">-		__cu_len = __copy_user((__force void __user *) __cu_to, __cu_from, __cu_len);	\</span>
<span class="p_del">-	__cu_len;									\</span>
<span class="p_del">-})</span>
<span class="p_add">+static inline unsigned long</span>
<span class="p_add">+copy_from_user(void *to, const void __user *from, unsigned long n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(__access_ok(from, n, get_fs())))</span>
<span class="p_add">+		n = __copy_user((__force void __user *) to, from, n);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
<span class="p_add">+	return n;</span>
<span class="p_add">+}</span>
 
 #define __copy_in_user(to, from, size)	__copy_user((to), (from), (size))
 
<span class="p_header">diff --git a/arch/m32r/include/asm/uaccess.h b/arch/m32r/include/asm/uaccess.h</span>
<span class="p_header">index 1c7047bea200..a26d28d59ae6 100644</span>
<span class="p_header">--- a/arch/m32r/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/m32r/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> extern int fixup_exception(struct pt_regs *regs);</span>
 #define __get_user_nocheck(x,ptr,size)					\
 ({									\
 	long __gu_err = 0;						\
<span class="p_del">-	unsigned long __gu_val;						\</span>
<span class="p_add">+	unsigned long __gu_val = 0;					\</span>
 	might_sleep();							\
 	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
 	(x) = (__typeof__(*(ptr)))__gu_val;				\
<span class="p_header">diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_header">index 072b0077abf9..7a5b1ee22586 100644</span>
<span class="p_header">--- a/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/microblaze/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> extern long __user_bad(void);</span>
 
 #define __get_user(x, ptr)						\
 ({									\
<span class="p_del">-	unsigned long __gu_val;						\</span>
<span class="p_add">+	unsigned long __gu_val = 0;					\</span>
 	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
 	long __gu_err;							\
 	switch (sizeof(*(ptr))) {					\
<span class="p_chunk">@@ -364,10 +364,13 @@</span> <span class="p_context"> extern long __user_bad(void);</span>
 static inline long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	might_sleep();
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_from_user(to, from, n);</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 #define __copy_to_user(to, from, n)	\
<span class="p_header">diff --git a/arch/mips/kernel/scall64-n32.S b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">index 5476ce4ca35e..cf6852086055 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-n32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-n32.S</span>
<span class="p_chunk">@@ -366,7 +366,7 @@</span> <span class="p_context"> EXPORT(sysn32_call_table)</span>
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key
 	PTR	sys_request_key
<span class="p_del">-	PTR	sys_keyctl			/* 6245 */</span>
<span class="p_add">+	PTR	compat_sys_keyctl		/* 6245 */</span>
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch
<span class="p_header">diff --git a/arch/mips/kernel/scall64-o32.S b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">index 6651759edde0..4eb5391007ee 100644</span>
<span class="p_header">--- a/arch/mips/kernel/scall64-o32.S</span>
<span class="p_header">+++ b/arch/mips/kernel/scall64-o32.S</span>
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> sys_call_table:</span>
 	PTR	sys_ni_syscall			/* available, was setaltroot */
 	PTR	sys_add_key			/* 4280 */
 	PTR	sys_request_key
<span class="p_del">-	PTR	sys_keyctl</span>
<span class="p_add">+	PTR	compat_sys_keyctl</span>
 	PTR	sys_set_thread_area
 	PTR	sys_inotify_init
 	PTR	sys_inotify_add_watch		/* 4285 */
<span class="p_header">diff --git a/arch/mips/mm/sc-rm7k.c b/arch/mips/mm/sc-rm7k.c</span>
<span class="p_header">index 274af3be1442..a30eb5d7d50a 100644</span>
<span class="p_header">--- a/arch/mips/mm/sc-rm7k.c</span>
<span class="p_header">+++ b/arch/mips/mm/sc-rm7k.c</span>
<span class="p_chunk">@@ -162,7 +162,7 @@</span> <span class="p_context"> static void rm7k_tc_disable(void)</span>
 	local_irq_save(flags);
 	blast_rm7k_tcache();
 	clear_c0_config(RM7K_CONF_TE);
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 
 static void rm7k_sc_disable(void)
<span class="p_header">diff --git a/arch/mn10300/include/asm/uaccess.h b/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_header">index 780560b330d9..570a25db8df2 100644</span>
<span class="p_header">--- a/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/mn10300/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -181,6 +181,7 @@</span> <span class="p_context"> struct __large_struct { unsigned long buf[100]; };</span>
 		&quot;2:\n&quot;						\
 		&quot;	.section	.fixup,\&quot;ax\&quot;\n&quot;	\
 		&quot;3:\n\t&quot;					\
<span class="p_add">+		&quot;	mov		0,%1\n&quot;			\</span>
 		&quot;	mov		%3,%0\n&quot;		\
 		&quot;	jmp		2b\n&quot;			\
 		&quot;	.previous\n&quot;				\
<span class="p_header">diff --git a/arch/mn10300/lib/usercopy.c b/arch/mn10300/lib/usercopy.c</span>
<span class="p_header">index 7826e6c364e7..a29c5dc2ab5e 100644</span>
<span class="p_header">--- a/arch/mn10300/lib/usercopy.c</span>
<span class="p_header">+++ b/arch/mn10300/lib/usercopy.c</span>
<span class="p_chunk">@@ -9,7 +9,8 @@</span> <span class="p_context"></span>
  * as published by the Free Software Foundation; either version
  * 2 of the Licence, or (at your option) any later version.
  */
<span class="p_del">-#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 unsigned long
 __generic_copy_to_user(void *to, const void *from, unsigned long n)
<span class="p_chunk">@@ -24,6 +25,8 @@</span> <span class="p_context"> __generic_copy_from_user(void *to, const void *from, unsigned long n)</span>
 {
 	if (access_ok(VERIFY_READ, from, n))
 		__copy_user_zeroing(to, from, n);
<span class="p_add">+	else</span>
<span class="p_add">+		memset(to, 0, n);</span>
 	return n;
 }
 
<span class="p_header">diff --git a/arch/openrisc/include/asm/uaccess.h b/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_header">index c310e45b538e..1acfe52f6929 100644</span>
<span class="p_header">--- a/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/openrisc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -274,28 +274,20 @@</span> <span class="p_context"> __copy_tofrom_user(void *to, const void *from, unsigned long size);</span>
 static inline unsigned long
 copy_from_user(void *to, const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n);</span>
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+	unsigned long res = n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_tofrom_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline unsigned long
 copy_to_user(void *to, const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, n))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n);</span>
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, to, n)))</span>
<span class="p_add">+		n = __copy_tofrom_user(to, from, n);</span>
 	return n;
 }
 
<span class="p_chunk">@@ -304,13 +296,8 @@</span> <span class="p_context"> extern unsigned long __clear_user(void *addr, unsigned long size);</span>
 static inline __must_check unsigned long
 clear_user(void *addr, unsigned long size)
 {
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, addr, size))</span>
<span class="p_del">-		return __clear_user(addr, size);</span>
<span class="p_del">-	if ((unsigned long)addr &lt; TASK_SIZE) {</span>
<span class="p_del">-		unsigned long over = (unsigned long)addr + size - TASK_SIZE;</span>
<span class="p_del">-		return __clear_user(addr, size - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, addr, size)))</span>
<span class="p_add">+		size = __clear_user(addr, size);</span>
 	return size;
 }
 
<span class="p_header">diff --git a/arch/parisc/include/asm/errno.h b/arch/parisc/include/asm/errno.h</span>
<span class="p_header">index 135ad6047e51..290112edb9ca 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/errno.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/errno.h</span>
<span class="p_chunk">@@ -97,10 +97,10 @@</span> <span class="p_context"></span>
 #define	ENOTCONN	235	/* Transport endpoint is not connected */
 #define	ESHUTDOWN	236	/* Cannot send after transport endpoint shutdown */
 #define	ETOOMANYREFS	237	/* Too many references: cannot splice */
<span class="p_del">-#define EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
 #define	ETIMEDOUT	238	/* Connection timed out */
 #define	ECONNREFUSED	239	/* Connection refused */
<span class="p_del">-#define EREMOTERELEASE	240	/* Remote peer released connection */</span>
<span class="p_add">+#define	EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
<span class="p_add">+#define	EREMOTERELEASE	240	/* Remote peer released connection */</span>
 #define	EHOSTDOWN	241	/* Host is down */
 #define	EHOSTUNREACH	242	/* No route to host */
 
<span class="p_header">diff --git a/arch/parisc/include/asm/uaccess.h b/arch/parisc/include/asm/uaccess.h</span>
<span class="p_header">index 337353de237b..a615403907a2 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -10,6 +10,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/errno.h&gt;
 #include &lt;asm-generic/uaccess-unaligned.h&gt;
 
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+</span>
 #define VERIFY_READ 0
 #define VERIFY_WRITE 1
 
<span class="p_chunk">@@ -255,13 +257,14 @@</span> <span class="p_context"> static inline unsigned long __must_check copy_from_user(void *to,</span>
                                           unsigned long n)
 {
         int sz = __compiletime_object_size(to);
<span class="p_del">-        int ret = -EFAULT;</span>
<span class="p_add">+        unsigned long ret = n;</span>
 
         if (likely(sz == -1 || !__builtin_constant_p(n) || sz &gt;= n))
                 ret = __copy_from_user(to, from, n);
         else
                 copy_from_user_overflow();
<span class="p_del">-</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		memset(to + (n - ret), 0, ret);</span>
         return ret;
 }
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/uaccess.h b/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_header">index bd0fb8495154..4d4a30ccc249 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -332,30 +332,17 @@</span> <span class="p_context"> extern unsigned long __copy_tofrom_user(void __user *to,</span>
 static inline unsigned long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
 		return __copy_tofrom_user((__force void __user *)to, from, n);
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user((__force void __user *)to, from,</span>
<span class="p_del">-				n - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	memset(to, 0, n);</span>
 	return n;
 }
 
 static inline unsigned long copy_to_user(void __user *to,
 		const void *from, unsigned long n)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
 	if (access_ok(VERIFY_WRITE, to, n))
 		return __copy_tofrom_user(to, (__force void __user *)from, n);
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + n - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, (__force void __user *)from,</span>
<span class="p_del">-				n - over) + over;</span>
<span class="p_del">-	}</span>
 	return n;
 }
 
<span class="p_chunk">@@ -446,10 +433,6 @@</span> <span class="p_context"> static inline unsigned long clear_user(void __user *addr, unsigned long size)</span>
 	might_sleep();
 	if (likely(access_ok(VERIFY_WRITE, addr, size)))
 		return __clear_user(addr, size);
<span class="p_del">-	if ((unsigned long)addr &lt; TASK_SIZE) {</span>
<span class="p_del">-		unsigned long over = (unsigned long)addr + size - TASK_SIZE;</span>
<span class="p_del">-		return __clear_user(addr, size - over) + over;</span>
<span class="p_del">-	}</span>
 	return size;
 }
 
<span class="p_header">diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c</span>
<span class="p_header">index f4b78a39b79b..9a5ec9aacbc1 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/numa.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/numa.c</span>
<span class="p_chunk">@@ -1275,17 +1275,33 @@</span> <span class="p_context"> int hot_add_scn_to_nid(unsigned long scn_addr)</span>
 static u64 hot_add_drconf_memory_max(void)
 {
         struct device_node *memory = NULL;
<span class="p_add">+	struct device_node *dn = NULL;</span>
         unsigned int drconf_cell_cnt = 0;
         u64 lmb_size = 0;
         const u32 *dm = 0;
<span class="p_add">+	const __be64 *lrdr = NULL;</span>
<span class="p_add">+	struct of_drconf_cell drmem;</span>
<span class="p_add">+</span>
<span class="p_add">+	dn = of_find_node_by_path(&quot;/rtas&quot;);</span>
<span class="p_add">+	if (dn) {</span>
<span class="p_add">+		lrdr = of_get_property(dn, &quot;ibm,lrdr-capacity&quot;, NULL);</span>
<span class="p_add">+		of_node_put(dn);</span>
<span class="p_add">+		if (lrdr)</span>
<span class="p_add">+			return be64_to_cpup(lrdr);</span>
<span class="p_add">+	}</span>
 
         memory = of_find_node_by_path(&quot;/ibm,dynamic-reconfiguration-memory&quot;);
         if (memory) {
                 drconf_cell_cnt = of_get_drconf_memory(memory, &amp;dm);
                 lmb_size = of_get_lmb_size(memory);
<span class="p_add">+</span>
<span class="p_add">+		/* Advance to the last cell, each cell has 6 32 bit integers */</span>
<span class="p_add">+		dm += (drconf_cell_cnt - 1) * 6;</span>
<span class="p_add">+		read_drconf_cell(&amp;drmem, &amp;dm);</span>
                 of_node_put(memory);
<span class="p_add">+		return drmem.base_addr + lmb_size;</span>
         }
<span class="p_del">-        return lmb_size * drconf_cell_cnt;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/s390/include/asm/auxvec.h b/arch/s390/include/asm/auxvec.h</span>
<span class="p_header">index a1f153e89133..c53e08442255 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/auxvec.h</span>
<span class="p_chunk">@@ -3,4 +3,6 @@</span> <span class="p_context"></span>
 
 #define AT_SYSINFO_EHDR		33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/s390/include/asm/elf.h b/arch/s390/include/asm/elf.h</span>
<span class="p_header">index 547f1a6a35d4..c6e4c837c248 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/elf.h</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> do {								\</span>
 
 #define STACK_RND_MASK	0x7ffUL
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							    \
 do {									    \
 	if (vdso_enabled)						    \
<span class="p_header">diff --git a/arch/s390/include/asm/uaccess.h b/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">index 2b23885e81e9..7aee41b624ff 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -147,28 +147,28 @@</span> <span class="p_context"> extern int __put_user_bad(void) __attribute__((noreturn));</span>
 	__chk_user_ptr(ptr);					\
 	switch (sizeof(*(ptr))) {				\
 	case 1: {						\
<span class="p_del">-		unsigned char __x;				\</span>
<span class="p_add">+		unsigned char __x = 0;				\</span>
 		__gu_err = __get_user_fn(sizeof (*(ptr)),	\
 					 ptr, &amp;__x);		\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 2: {						\
<span class="p_del">-		unsigned short __x;				\</span>
<span class="p_add">+		unsigned short __x = 0;				\</span>
 		__gu_err = __get_user_fn(sizeof (*(ptr)),	\
 					 ptr, &amp;__x);		\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 4: {						\
<span class="p_del">-		unsigned int __x;				\</span>
<span class="p_add">+		unsigned int __x = 0;				\</span>
 		__gu_err = __get_user_fn(sizeof (*(ptr)),	\
 					 ptr, &amp;__x);		\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
 		break;						\
 	};							\
 	case 8: {						\
<span class="p_del">-		unsigned long long __x;				\</span>
<span class="p_add">+		unsigned long long __x = 0;			\</span>
 		__gu_err = __get_user_fn(sizeof (*(ptr)),	\
 					 ptr, &amp;__x);		\
 		(x) = *(__force __typeof__(*(ptr)) *) &amp;__x;	\
<span class="p_header">diff --git a/arch/score/include/asm/uaccess.h b/arch/score/include/asm/uaccess.h</span>
<span class="p_header">index ab66ddde777b..69326dfb894d 100644</span>
<span class="p_header">--- a/arch/score/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/score/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> do {									\</span>
 		__get_user_asm(val, &quot;lw&quot;, ptr);				\
 		 break;							\
 	case 8: 							\
<span class="p_del">-		if ((copy_from_user((void *)&amp;val, ptr, 8)) == 0)	\</span>
<span class="p_add">+		if (__copy_from_user((void *)&amp;val, ptr, 8) == 0)	\</span>
 			__gu_err = 0;					\
 		else							\
 			__gu_err = -EFAULT;				\
<span class="p_chunk">@@ -183,6 +183,8 @@</span> <span class="p_context"> do {									\</span>
 									\
 	if (likely(access_ok(VERIFY_READ, __gu_ptr, size)))		\
 		__get_user_common((x), size, __gu_ptr);			\
<span class="p_add">+	else								\</span>
<span class="p_add">+		(x) = 0;						\</span>
 									\
 	__gu_err;							\
 })
<span class="p_chunk">@@ -196,6 +198,7 @@</span> <span class="p_context"> do {									\</span>
 		&quot;2:\n&quot;							\
 		&quot;.section .fixup,\&quot;ax\&quot;\n&quot;				\
 		&quot;3:li	%0, %4\n&quot;					\
<span class="p_add">+		&quot;li	%1, 0\n&quot;					\</span>
 		&quot;j	2b\n&quot;						\
 		&quot;.previous\n&quot;						\
 		&quot;.section __ex_table,\&quot;a\&quot;\n&quot;				\
<span class="p_chunk">@@ -293,35 +296,34 @@</span> <span class="p_context"> extern int __copy_tofrom_user(void *to, const void *from, unsigned long len);</span>
 static inline unsigned long
 copy_from_user(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_add">+	unsigned long res = len;</span>
 
<span class="p_del">-	if (access_ok(VERIFY_READ, from, len))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, len)))</span>
<span class="p_add">+		res = __copy_tofrom_user(to, from, len);</span>
 
<span class="p_del">-	if ((unsigned long)from &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)from + len - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len - over) + over;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return len;</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (len - res), 0, res);</span>
<span class="p_add">+</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline unsigned long
 copy_to_user(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	unsigned long over;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (access_ok(VERIFY_WRITE, to, len))</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_WRITE, to, len)))</span>
<span class="p_add">+		len = __copy_tofrom_user(to, from, len);</span>
 
<span class="p_del">-	if ((unsigned long)to &lt; TASK_SIZE) {</span>
<span class="p_del">-		over = (unsigned long)to + len - TASK_SIZE;</span>
<span class="p_del">-		return __copy_tofrom_user(to, from, len - over) + over;</span>
<span class="p_del">-	}</span>
 	return len;
 }
 
<span class="p_del">-#define __copy_from_user(to, from, len)	\</span>
<span class="p_del">-		__copy_tofrom_user((to), (from), (len))</span>
<span class="p_add">+static inline unsigned long</span>
<span class="p_add">+__copy_from_user(void *to, const void *from, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long left = __copy_tofrom_user(to, from, len);</span>
<span class="p_add">+	if (unlikely(left))</span>
<span class="p_add">+		memset(to + (len - left), 0, left);</span>
<span class="p_add">+	return left;</span>
<span class="p_add">+}</span>
 
 #define __copy_to_user(to, from, len)		\
 		__copy_tofrom_user((to), (from), (len))
<span class="p_chunk">@@ -335,17 +337,17 @@</span> <span class="p_context"> __copy_to_user_inatomic(void *to, const void *from, unsigned long len)</span>
 static inline unsigned long
 __copy_from_user_inatomic(void *to, const void *from, unsigned long len)
 {
<span class="p_del">-	return __copy_from_user(to, from, len);</span>
<span class="p_add">+	return __copy_tofrom_user(to, from, len);</span>
 }
 
<span class="p_del">-#define __copy_in_user(to, from, len)	__copy_from_user(to, from, len)</span>
<span class="p_add">+#define __copy_in_user(to, from, len)	__copy_tofrom_user(to, from, len)</span>
 
 static inline unsigned long
 copy_in_user(void *to, const void *from, unsigned long len)
 {
 	if (access_ok(VERIFY_READ, from, len) &amp;&amp;
 		      access_ok(VERFITY_WRITE, to, len))
<span class="p_del">-		return copy_from_user(to, from, len);</span>
<span class="p_add">+		return __copy_tofrom_user(to, from, len);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/sh/include/asm/uaccess.h b/arch/sh/include/asm/uaccess.h</span>
<span class="p_header">index 075848f43b6a..0e7971185be5 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -175,7 +175,10 @@</span> <span class="p_context"> copy_from_user(void *to, const void __user *from, unsigned long n)</span>
 	__kernel_size_t __copy_size = (__kernel_size_t) n;
 
 	if (__copy_size &amp;&amp; __access_ok(__copy_from, __copy_size))
<span class="p_del">-		return __copy_user(to, from, __copy_size);</span>
<span class="p_add">+		__copy_size = __copy_user(to, from, __copy_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(__copy_size))</span>
<span class="p_add">+		memset(to + (n - __copy_size), 0, __copy_size);</span>
 
 	return __copy_size;
 }
<span class="p_header">diff --git a/arch/sh/include/asm/uaccess_64.h b/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_header">index 56fd20b8cdcc..1a48a4ab8c69 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/uaccess_64.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #define __get_user_size(x,ptr,size,retval)			\
 do {								\
 	retval = 0;						\
<span class="p_add">+	x = 0;							\</span>
 	switch (size) {						\
 	case 1:							\
 		retval = __get_user_asm_b((void *)&amp;x,		\
<span class="p_header">diff --git a/arch/sparc/include/asm/uaccess_32.h b/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_header">index 8303ac481034..43c2a0df4368 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/uaccess_32.h</span>
<span class="p_chunk">@@ -264,8 +264,10 @@</span> <span class="p_context"> static inline unsigned long copy_from_user(void *to, const void __user *from, un</span>
 {
 	if (n &amp;&amp; __access_ok((unsigned long) from, n))
 		return __copy_user((__force void __user *) to, from, n);
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		memset(to, 0, n);</span>
 		return n;
<span class="p_add">+	}</span>
 }
 
 static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
<span class="p_header">diff --git a/arch/x86/ia32/ia32entry.S b/arch/x86/ia32/ia32entry.S</span>
<span class="p_header">index 95b4eb3424a0..2b5527726ae1 100644</span>
<span class="p_header">--- a/arch/x86/ia32/ia32entry.S</span>
<span class="p_header">+++ b/arch/x86/ia32/ia32entry.S</span>
<span class="p_chunk">@@ -791,7 +791,7 @@</span> <span class="p_context"> ia32_sys_call_table:</span>
 	.quad quiet_ni_syscall		/* 285: sys_altroot */
 	.quad sys_add_key
 	.quad sys_request_key
<span class="p_del">-	.quad sys_keyctl</span>
<span class="p_add">+	.quad compat_sys_keyctl</span>
 	.quad sys_ioprio_set
 	.quad sys_ioprio_get		/* 290 */
 	.quad sys_inotify_init
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 169be8938b96..a7973ddf2d1b 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -17,7 +17,14 @@</span> <span class="p_context"></span>
 
 static inline void __native_flush_tlb(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If current-&gt;mm == NULL then we borrow a mm which may change during a</span>
<span class="p_add">+	 * task switch and therefore we must not be preempted while we write CR3</span>
<span class="p_add">+	 * back:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	native_write_cr3(native_read_cr3());
<span class="p_add">+	preempt_enable();</span>
 }
 
 static inline void __native_flush_tlb_global(void)
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index 838a3b40a4b0..8fcd92e9589b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -1481,6 +1481,9 @@</span> <span class="p_context"> void __init enable_IR_x2apic(void)</span>
 	int ret, x2apic_enabled = 0;
 	int dmar_table_init_ret;
 
<span class="p_add">+	if (skip_ioapic_setup)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	dmar_table_init_ret = dmar_table_init();
 	if (dmar_table_init_ret &amp;&amp; !x2apic_supported())
 		return;
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index 3755ef494390..083a36eb2a06 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -11,13 +11,20 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/acpi.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 #include &lt;linux/pci_ids.h&gt;
<span class="p_add">+#include &lt;linux/bcma/bcma.h&gt;</span>
<span class="p_add">+#include &lt;linux/bcma/bcma_regs.h&gt;</span>
 #include &lt;asm/pci-direct.h&gt;
 #include &lt;asm/dma.h&gt;
 #include &lt;asm/io_apic.h&gt;
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/iommu.h&gt;
 #include &lt;asm/gart.h&gt;
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define dev_err(msg)  pr_err(&quot;pci 0000:%02x:%02x.%d: %s&quot;, bus, slot, func, msg)</span>
 
 static void __init fix_hypertransport_config(int num, int slot, int func)
 {
<span class="p_chunk">@@ -73,6 +80,13 @@</span> <span class="p_context"> static void __init nvidia_bugs(int num, int slot, int func)</span>
 #ifdef CONFIG_ACPI
 #ifdef CONFIG_X86_IO_APIC
 	/*
<span class="p_add">+	 * Only applies to Nvidia root ports (bus 0) and not to</span>
<span class="p_add">+	 * Nvidia graphics cards with PCI ports on secondary buses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (num)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * All timer overrides on Nvidia are
 	 * wrong unless HPET is enabled.
 	 * Unfortunately that&#39;s not true on many Asus boards.
<span class="p_chunk">@@ -192,6 +206,62 @@</span> <span class="p_context"> static void __init ati_bugs_contd(int num, int slot, int func)</span>
 }
 #endif
 
<span class="p_add">+#define BCM4331_MMIO_SIZE	16384</span>
<span class="p_add">+#define BCM4331_PM_CAP		0x40</span>
<span class="p_add">+#define bcma_aread32(reg)	ioread32(mmio + 1 * BCMA_CORE_SIZE + reg)</span>
<span class="p_add">+#define bcma_awrite32(reg, val)	iowrite32(val, mmio + 1 * BCMA_CORE_SIZE + reg)</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init apple_airport_reset(int bus, int slot, int func)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *mmio;</span>
<span class="p_add">+	u16 pmcsr;</span>
<span class="p_add">+	u64 addr;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dmi_match(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Card may have been put into PCI_D3hot by grub quirk */</span>
<span class="p_add">+	pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pmcsr &amp; PCI_PM_CTRL_STATE_MASK) != PCI_D0) {</span>
<span class="p_add">+		pmcsr &amp;= ~PCI_PM_CTRL_STATE_MASK;</span>
<span class="p_add">+		write_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL, pmcsr);</span>
<span class="p_add">+		mdelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+		pmcsr = read_pci_config_16(bus, slot, func, BCM4331_PM_CAP + PCI_PM_CTRL);</span>
<span class="p_add">+		if ((pmcsr &amp; PCI_PM_CTRL_STATE_MASK) != PCI_D0) {</span>
<span class="p_add">+			dev_err(&quot;Cannot power up Apple AirPort card\n&quot;);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	addr  =      read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);</span>
<span class="p_add">+	addr |= (u64)read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_1) &lt;&lt; 32;</span>
<span class="p_add">+	addr &amp;= PCI_BASE_ADDRESS_MEM_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	mmio = early_ioremap(addr, BCM4331_MMIO_SIZE);</span>
<span class="p_add">+	if (!mmio) {</span>
<span class="p_add">+		dev_err(&quot;Cannot iomap Apple AirPort card\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;Resetting Apple AirPort card (left enabled by EFI)\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; bcma_aread32(BCMA_RESET_ST) &amp;&amp; i &lt; 30; i++)</span>
<span class="p_add">+		udelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+	bcma_awrite32(BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);</span>
<span class="p_add">+	bcma_aread32(BCMA_RESET_CTL);</span>
<span class="p_add">+	udelay(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	bcma_awrite32(BCMA_RESET_CTL, 0);</span>
<span class="p_add">+	bcma_aread32(BCMA_RESET_CTL);</span>
<span class="p_add">+	udelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+	early_iounmap(mmio, BCM4331_MMIO_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define QFLAG_APPLY_ONCE 	0x1
 #define QFLAG_APPLIED		0x2
 #define QFLAG_DONE		(QFLAG_APPLY_ONCE|QFLAG_APPLIED)
<span class="p_chunk">@@ -204,12 +274,6 @@</span> <span class="p_context"> struct chipset {</span>
 	void (*f)(int num, int slot, int func);
 };
 
<span class="p_del">-/*</span>
<span class="p_del">- * Only works for devices on the root bus. If you add any devices</span>
<span class="p_del">- * not on bus 0 readd another loop level in early_quirks(). But</span>
<span class="p_del">- * be careful because at least the Nvidia quirk here relies on</span>
<span class="p_del">- * only matching on bus 0.</span>
<span class="p_del">- */</span>
 static struct chipset early_qrk[] __initdata = {
 	{ PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID,
 	  PCI_CLASS_BRIDGE_PCI, PCI_ANY_ID, QFLAG_APPLY_ONCE, nvidia_bugs },
<span class="p_chunk">@@ -221,9 +285,13 @@</span> <span class="p_context"> static struct chipset early_qrk[] __initdata = {</span>
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs },
 	{ PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_SBX00_SMBUS,
 	  PCI_CLASS_SERIAL_SMBUS, PCI_ANY_ID, 0, ati_bugs_contd },
<span class="p_add">+	{ PCI_VENDOR_ID_BROADCOM, 0x4331,</span>
<span class="p_add">+	  PCI_CLASS_NETWORK_OTHER, PCI_ANY_ID, 0, apple_airport_reset},</span>
 	{}
 };
 
<span class="p_add">+static void __init early_pci_scan_bus(int bus);</span>
<span class="p_add">+</span>
 /**
  * check_dev_quirk - apply early quirks to a given PCI device
  * @num: bus number
<span class="p_chunk">@@ -232,7 +300,7 @@</span> <span class="p_context"> static struct chipset early_qrk[] __initdata = {</span>
  *
  * Check the vendor &amp; device ID against the early quirks table.
  *
<span class="p_del">- * If the device is single function, let early_quirks() know so we don&#39;t</span>
<span class="p_add">+ * If the device is single function, let early_pci_scan_bus() know so we don&#39;t</span>
  * poke at this device again.
  */
 static int __init check_dev_quirk(int num, int slot, int func)
<span class="p_chunk">@@ -241,6 +309,7 @@</span> <span class="p_context"> static int __init check_dev_quirk(int num, int slot, int func)</span>
 	u16 vendor;
 	u16 device;
 	u8 type;
<span class="p_add">+	u8 sec;</span>
 	int i;
 
 	class = read_pci_config_16(num, slot, func, PCI_CLASS_DEVICE);
<span class="p_chunk">@@ -268,25 +337,36 @@</span> <span class="p_context"> static int __init check_dev_quirk(int num, int slot, int func)</span>
 
 	type = read_pci_config_byte(num, slot, func,
 				    PCI_HEADER_TYPE);
<span class="p_add">+</span>
<span class="p_add">+	if ((type &amp; 0x7f) == PCI_HEADER_TYPE_BRIDGE) {</span>
<span class="p_add">+		sec = read_pci_config_byte(num, slot, func, PCI_SECONDARY_BUS);</span>
<span class="p_add">+		if (sec &gt; num)</span>
<span class="p_add">+			early_pci_scan_bus(sec);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(type &amp; 0x80))
 		return -1;
 
 	return 0;
 }
 
<span class="p_del">-void __init early_quirks(void)</span>
<span class="p_add">+static void __init early_pci_scan_bus(int bus)</span>
 {
 	int slot, func;
 
<span class="p_del">-	if (!early_pci_allowed())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	/* Poor man&#39;s PCI discovery */
<span class="p_del">-	/* Only scan the root bus */</span>
 	for (slot = 0; slot &lt; 32; slot++)
 		for (func = 0; func &lt; 8; func++) {
 			/* Only probe function 0 on single fn devices */
<span class="p_del">-			if (check_dev_quirk(0, slot, func))</span>
<span class="p_add">+			if (check_dev_quirk(bus, slot, func))</span>
 				break;
 		}
 }
<span class="p_add">+</span>
<span class="p_add">+void __init early_quirks(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!early_pci_allowed())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	early_pci_scan_bus(0);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index af5b675c7f68..d21b32eeaa59 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -52,12 +52,12 @@</span> <span class="p_context"> asm (&quot;.pushsection .entry.text, \&quot;ax\&quot;\n&quot;</span>
      &quot;.popsection&quot;);
 
 /* identity function, which can be inlined */
<span class="p_del">-u32 _paravirt_ident_32(u32 x)</span>
<span class="p_add">+u32 notrace _paravirt_ident_32(u32 x)</span>
 {
 	return x;
 }
 
<span class="p_del">-u64 _paravirt_ident_64(u64 x)</span>
<span class="p_add">+u64 notrace _paravirt_ident_64(u64 x)</span>
 {
 	return x;
 }
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index fb8c23d2fdf6..bd0ed47989e4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -4999,22 +4999,27 @@</span> <span class="p_context"> static void nested_free_vmcs02(struct vcpu_vmx *vmx, gpa_t vmptr)</span>
 
 /*
  * Free all VMCSs saved for this vcpu, except the one pointed by
<span class="p_del">- * vmx-&gt;loaded_vmcs. These include the VMCSs in vmcs02_pool (except the one</span>
<span class="p_del">- * currently used, if running L2), and vmcs01 when running L2.</span>
<span class="p_add">+ * vmx-&gt;loaded_vmcs. We must be running L1, so vmx-&gt;loaded_vmcs</span>
<span class="p_add">+ * must be &amp;vmx-&gt;vmcs01.</span>
  */
 static void nested_free_all_saved_vmcss(struct vcpu_vmx *vmx)
 {
 	struct vmcs02_list *item, *n;
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(vmx-&gt;loaded_vmcs != &amp;vmx-&gt;vmcs01);</span>
 	list_for_each_entry_safe(item, n, &amp;vmx-&gt;nested.vmcs02_pool, list) {
<span class="p_del">-		if (vmx-&gt;loaded_vmcs != &amp;item-&gt;vmcs02)</span>
<span class="p_del">-			free_loaded_vmcs(&amp;item-&gt;vmcs02);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Something will leak if the above WARN triggers.  Better than</span>
<span class="p_add">+		 * a use-after-free.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (vmx-&gt;loaded_vmcs == &amp;item-&gt;vmcs02)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		free_loaded_vmcs(&amp;item-&gt;vmcs02);</span>
 		list_del(&amp;item-&gt;list);
 		kfree(item);
<span class="p_add">+		vmx-&gt;nested.vmcs02_num--;</span>
 	}
<span class="p_del">-	vmx-&gt;nested.vmcs02_num = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (vmx-&gt;loaded_vmcs != &amp;vmx-&gt;vmcs01)</span>
<span class="p_del">-		free_loaded_vmcs(&amp;vmx-&gt;vmcs01);</span>
 }
 
 /*
<span class="p_chunk">@@ -6307,13 +6312,44 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 #undef R
 #undef Q
 
<span class="p_add">+static void vmx_load_vmcs01(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vmx-&gt;loaded_vmcs == &amp;vmx-&gt;vmcs01)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu = get_cpu();</span>
<span class="p_add">+	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;vmcs01;</span>
<span class="p_add">+	vmx_vcpu_put(vcpu);</span>
<span class="p_add">+	vmx_vcpu_load(vcpu, cpu);</span>
<span class="p_add">+	vcpu-&gt;cpu = cpu;</span>
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensure that the current vmcs of the logical processor is the</span>
<span class="p_add">+ * vmcs01 of the vcpu before calling free_nested().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+       struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+       vcpu_load(vcpu);</span>
<span class="p_add">+       vmx_load_vmcs01(vcpu);</span>
<span class="p_add">+       free_nested(vmx);</span>
<span class="p_add">+       vcpu_put(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vmx_free_vcpu(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
 
 	free_vpid(vmx);
<span class="p_add">+	leave_guest_mode(vcpu);</span>
<span class="p_add">+	vmx_free_vcpu_nested(vcpu);</span>
 	free_loaded_vmcs(vmx-&gt;loaded_vmcs);
<span class="p_del">-	free_nested(vmx);</span>
 	kfree(vmx-&gt;guest_msrs);
 	kvm_vcpu_uninit(vcpu);
 	kmem_cache_free(kvm_vcpu_cache, vmx);
<span class="p_chunk">@@ -7059,18 +7095,12 @@</span> <span class="p_context"> void load_vmcs12_host_state(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 static void nested_vmx_vmexit(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_del">-	int cpu;</span>
 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 
 	leave_guest_mode(vcpu);
 	prepare_vmcs12(vcpu, vmcs12);
 
<span class="p_del">-	cpu = get_cpu();</span>
<span class="p_del">-	vmx-&gt;loaded_vmcs = &amp;vmx-&gt;vmcs01;</span>
<span class="p_del">-	vmx_vcpu_put(vcpu);</span>
<span class="p_del">-	vmx_vcpu_load(vcpu, cpu);</span>
<span class="p_del">-	vcpu-&gt;cpu = cpu;</span>
<span class="p_del">-	put_cpu();</span>
<span class="p_add">+	vmx_load_vmcs01(vcpu);</span>
 
 	/* if no vmcs02 cache requested, remove the one we used */
 	if (VMCS02_POOL_SIZE == 0)
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index 424d1fa1c039..4c3f6db08626 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -829,6 +829,7 @@</span> <span class="p_context"> static void disk_seqf_stop(struct seq_file *seqf, void *v)</span>
 	if (iter) {
 		class_dev_iter_exit(iter);
 		kfree(iter);
<span class="p_add">+		seqf-&gt;private = NULL;</span>
 	}
 }
 
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 7b69d7a902a9..a5284e0a523d 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -238,6 +238,8 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		return blkcipher_walk_done(desc, walk, -EINVAL);
 	}
 
<span class="p_add">+	bsize = min(walk-&gt;blocksize, n);</span>
<span class="p_add">+</span>
 	walk-&gt;flags &amp;= ~(BLKCIPHER_WALK_SLOW | BLKCIPHER_WALK_COPY |
 			 BLKCIPHER_WALK_DIFF);
 	if (!scatterwalk_aligned(&amp;walk-&gt;in, alignmask) ||
<span class="p_chunk">@@ -250,7 +252,6 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		}
 	}
 
<span class="p_del">-	bsize = min(walk-&gt;blocksize, n);</span>
 	n = scatterwalk_clamp(&amp;walk-&gt;in, n);
 	n = scatterwalk_clamp(&amp;walk-&gt;out, n);
 
<span class="p_header">diff --git a/crypto/cryptd.c b/crypto/cryptd.c</span>
<span class="p_header">index 75c415d37086..d85fab975514 100644</span>
<span class="p_header">--- a/crypto/cryptd.c</span>
<span class="p_header">+++ b/crypto/cryptd.c</span>
<span class="p_chunk">@@ -565,9 +565,14 @@</span> <span class="p_context"> static int cryptd_hash_export(struct ahash_request *req, void *out)</span>
 
 static int cryptd_hash_import(struct ahash_request *req, const void *in)
 {
<span class="p_del">-	struct cryptd_hash_request_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+	struct cryptd_hash_ctx *ctx = crypto_ahash_ctx(tfm);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	desc-&gt;tfm = ctx-&gt;child;</span>
<span class="p_add">+	desc-&gt;flags = req-&gt;base.flags;</span>
 
<span class="p_del">-	return crypto_shash_import(&amp;rctx-&gt;desc, in);</span>
<span class="p_add">+	return crypto_shash_import(desc, in);</span>
 }
 
 static int cryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index 943cbceca426..9e47c4dfa91c 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -711,7 +711,9 @@</span> <span class="p_context"> static struct crypto_instance *crypto_gcm_alloc_common(struct rtattr **tb,</span>
 
 	ghash_alg = crypto_find_alg(ghash_name, &amp;crypto_ahash_type,
 				    CRYPTO_ALG_TYPE_HASH,
<span class="p_del">-				    CRYPTO_ALG_TYPE_AHASH_MASK);</span>
<span class="p_add">+				    CRYPTO_ALG_TYPE_AHASH_MASK |</span>
<span class="p_add">+				    crypto_requires_sync(algt-&gt;type,</span>
<span class="p_add">+							 algt-&gt;mask));</span>
 	err = PTR_ERR(ghash_alg);
 	if (IS_ERR(ghash_alg))
 		return ERR_PTR(err);
<span class="p_header">diff --git a/crypto/scatterwalk.c b/crypto/scatterwalk.c</span>
<span class="p_header">index 41e529af0773..8b5969987c0d 100644</span>
<span class="p_header">--- a/crypto/scatterwalk.c</span>
<span class="p_header">+++ b/crypto/scatterwalk.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> static void scatterwalk_pagedone(struct scatter_walk *walk, int out,</span>
 
 void scatterwalk_done(struct scatter_walk *walk, int out, int more)
 {
<span class="p_del">-	if (!(scatterwalk_pagelen(walk) &amp; (PAGE_SIZE - 1)) || !more)</span>
<span class="p_add">+	if (!more || walk-&gt;offset &gt;= walk-&gt;sg-&gt;offset + walk-&gt;sg-&gt;length ||</span>
<span class="p_add">+	    !(walk-&gt;offset &amp; (PAGE_SIZE - 1)))</span>
 		scatterwalk_pagedone(walk, out, more);
 }
 EXPORT_SYMBOL_GPL(scatterwalk_done);
<span class="p_header">diff --git a/drivers/bcma/bcma_private.h b/drivers/bcma/bcma_private.h</span>
<span class="p_header">index fda56bde36b8..3872e0d833be 100644</span>
<span class="p_header">--- a/drivers/bcma/bcma_private.h</span>
<span class="p_header">+++ b/drivers/bcma/bcma_private.h</span>
<span class="p_chunk">@@ -8,8 +8,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bcma/bcma.h&gt;
 #include &lt;linux/delay.h&gt;
 
<span class="p_del">-#define BCMA_CORE_SIZE		0x1000</span>
<span class="p_del">-</span>
 struct bcma_bus;
 
 /* main.c */
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 0b87fb6cc365..5554a5b713a9 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -118,6 +118,8 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432) },
 	{ USB_DEVICE(0x13d3, 0x3472) },
 	{ USB_DEVICE(0x13d3, 0x3474) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487) },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -182,6 +184,8 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 1cba113f27ce..59838695c46b 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -203,6 +203,8 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index f8e94fe197b9..0c4885dd43b8 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -176,16 +176,15 @@</span> <span class="p_context"> static int get_burstcount(struct tpm_chip *chip)</span>
 {
 	unsigned long stop;
 	int burstcnt;
<span class="p_add">+	u32 value;</span>
 
 	/* wait for burstcount */
 	/* which timeout value, spec has 2 answers (c &amp; d) */
 	stop = jiffies + chip-&gt;vendor.timeout_d;
 	do {
<span class="p_del">-		burstcnt = ioread8(chip-&gt;vendor.iobase +</span>
<span class="p_del">-				   TPM_STS(chip-&gt;vendor.locality) + 1);</span>
<span class="p_del">-		burstcnt += ioread8(chip-&gt;vendor.iobase +</span>
<span class="p_del">-				    TPM_STS(chip-&gt;vendor.locality) +</span>
<span class="p_del">-				    2) &lt;&lt; 8;</span>
<span class="p_add">+		value = ioread32(chip-&gt;vendor.iobase +</span>
<span class="p_add">+				 TPM_STS(chip-&gt;vendor.locality));</span>
<span class="p_add">+		burstcnt = (value &gt;&gt; 8) &amp; 0xFFFF;</span>
 		if (burstcnt)
 			return burstcnt;
 		msleep(TPM_TIMEOUT);
<span class="p_header">diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c</span>
<span class="p_header">index 7c869b73a57e..418c4da54fdc 100644</span>
<span class="p_header">--- a/drivers/firewire/net.c</span>
<span class="p_header">+++ b/drivers/firewire/net.c</span>
<span class="p_chunk">@@ -677,6 +677,9 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 	int retval;
 	u16 ether_type;
 
<span class="p_add">+	if (len &lt;= RFC2374_UNFRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&amp;hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
<span class="p_chunk">@@ -702,7 +705,12 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
 	}
<span class="p_add">+</span>
 	/* A datagram fragment has been received, now the fun begins. */
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt;= RFC2374_FRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w1 = ntohl(buf[1]);
 	buf += 2;
 	len -= RFC2374_FRAG_HDR_SIZE;
<span class="p_chunk">@@ -716,6 +724,9 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 	datagram_label = fwnet_get_hdr_dgl(&amp;hdr);
 	dg_size = fwnet_get_hdr_dg_size(&amp;hdr); /* ??? + 1 */
 
<span class="p_add">+	if (fg_off + len &gt; dg_size)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 
 	peer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);
<span class="p_chunk">@@ -822,6 +833,22 @@</span> <span class="p_context"> static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,</span>
 	fw_send_response(card, r, rcode);
 }
 
<span class="p_add">+static int gasp_source_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[0]) &gt;&gt; 16;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_specifier_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (be32_to_cpu(p[0]) &amp; 0xffff) &lt;&lt; 8 |</span>
<span class="p_add">+	       (be32_to_cpu(p[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_version(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[1]) &amp; 0xffffff;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		u32 cycle, size_t header_length, void *header, void *data)
 {
<span class="p_chunk">@@ -832,9 +859,6 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 	__be32 *buf_ptr;
 	int retval;
 	u32 length;
<span class="p_del">-	u16 source_node_id;</span>
<span class="p_del">-	u32 specifier_id;</span>
<span class="p_del">-	u32 ver;</span>
 	unsigned long offset;
 	unsigned long flags;
 
<span class="p_chunk">@@ -852,17 +876,13 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
<span class="p_del">-	specifier_id =    (be32_to_cpu(buf_ptr[0]) &amp; 0xffff) &lt;&lt; 8</span>
<span class="p_del">-			| (be32_to_cpu(buf_ptr[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_del">-	ver = be32_to_cpu(buf_ptr[1]) &amp; 0xffffff;</span>
<span class="p_del">-	source_node_id = be32_to_cpu(buf_ptr[0]) &gt;&gt; 16;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (specifier_id == IANA_SPECIFIER_ID &amp;&amp; ver == RFC2734_SW_VERSION) {</span>
<span class="p_del">-		buf_ptr += 2;</span>
<span class="p_del">-		length -= IEEE1394_GASP_HDR_SIZE;</span>
<span class="p_del">-		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,</span>
<span class="p_add">+	if (length &gt; IEEE1394_GASP_HDR_SIZE &amp;&amp;</span>
<span class="p_add">+	    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &amp;&amp;</span>
<span class="p_add">+	    gasp_version(buf_ptr) == RFC2734_SW_VERSION)</span>
<span class="p_add">+		fwnet_incoming_packet(dev, buf_ptr + 2,</span>
<span class="p_add">+				      length - IEEE1394_GASP_HDR_SIZE,</span>
<span class="p_add">+				      gasp_source_id(buf_ptr),</span>
 				      context-&gt;card-&gt;generation, true);
<span class="p_del">-	}</span>
 
 	packet.payload_length = dev-&gt;rcv_buffer_size;
 	packet.interrupt = 1;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 20110b4ad791..4ca454bf69a3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -2675,6 +2675,9 @@</span> <span class="p_context"> int drm_mode_page_flip_ioctl(struct drm_device *dev,</span>
 	unsigned long flags;
 	int ret = -EINVAL;
 
<span class="p_add">+	if (!drm_core_check_feature(dev, DRIVER_MODESET))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (page_flip-&gt;flags &amp; ~DRM_MODE_PAGE_FLIP_FLAGS ||
 	    page_flip-&gt;reserved != 0)
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index 72f460e22b76..bcfcfbb32877 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -68,6 +68,8 @@</span> <span class="p_context"></span>
 #define EDID_QUIRK_DETAILED_SYNC_PP		(1 &lt;&lt; 6)
 /* Force reduced-blanking timings for detailed modes */
 #define EDID_QUIRK_FORCE_REDUCED_BLANKING	(1 &lt;&lt; 7)
<span class="p_add">+/* Force 6bpc */</span>
<span class="p_add">+#define EDID_QUIRK_FORCE_6BPC			(1 &lt;&lt; 10)</span>
 
 struct detailed_mode_closure {
 	struct drm_connector *connector;
<span class="p_chunk">@@ -94,6 +96,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 	/* Unknown Acer */
 	{ &quot;ACR&quot;, 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
 
<span class="p_add">+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */</span>
<span class="p_add">+	{ &quot;AEO&quot;, 0, EDID_QUIRK_FORCE_6BPC },</span>
<span class="p_add">+</span>
 	/* Belinea 10 15 55 */
 	{ &quot;MAX&quot;, 1516, EDID_QUIRK_PREFER_LARGE_60 },
 	{ &quot;MAX&quot;, 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
<span class="p_chunk">@@ -1752,6 +1757,9 @@</span> <span class="p_context"> int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)</span>
 
 	drm_add_display_info(edid, &amp;connector-&gt;display_info);
 
<span class="p_add">+	if (quirks &amp; EDID_QUIRK_FORCE_6BPC)</span>
<span class="p_add">+		connector-&gt;display_info.bpc = 6;</span>
<span class="p_add">+</span>
 	return num_modes;
 }
 EXPORT_SYMBOL(drm_add_edid_modes);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 473bd330032e..fde52a05d919 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -1138,7 +1138,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		p1pll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_add">+		if ((frev &lt; 2) &amp;&amp; (crev &lt; 2))</span>
 			p1pll-&gt;pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);
 		else
<span class="p_chunk">@@ -1147,7 +1147,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		p1pll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_add">+		if (((frev &lt; 2) &amp;&amp; (crev &gt;= 4)) || (frev &gt;= 2)) {</span>
 			p1pll-&gt;lcd_pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll-&gt;lcd_pll_out_min == 0)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 6303fc8fcb8e..40633f3ad044 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1589,7 +1589,6 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 						      1);
 			/* no HPD on analog connectors */
 			radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -1787,8 +1786,10 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_chunk">@@ -1860,7 +1861,6 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-		connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 		connector-&gt;interlace_allowed = true;
 		connector-&gt;doublescan_allowed = true;
 		break;
<span class="p_chunk">@@ -1945,10 +1945,13 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
<span class="p_add">+</span>
 	connector-&gt;display_info.subpixel_order = subpixel_order;
 	drm_sysfs_connector_add(connector);
 	if (connector_type == DRM_MODE_CONNECTOR_LVDS) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index 0b5468bfaf54..a4327436221b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -248,8 +248,8 @@</span> <span class="p_context"> static int radeon_move_blit(struct ttm_buffer_object *bo,</span>
 	if (unlikely(r)) {
 		return r;
 	}
<span class="p_del">-	old_start = old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	new_start = new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	old_start = (u64)old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	new_start = (u64)new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
 
 	switch (old_mem-&gt;mem_type) {
 	case TTM_PL_VRAM:
<span class="p_header">diff --git a/drivers/hwmon/adt7411.c b/drivers/hwmon/adt7411.c</span>
<span class="p_header">index 5cc3e3784b42..aa09f269a7d6 100644</span>
<span class="p_header">--- a/drivers/hwmon/adt7411.c</span>
<span class="p_header">+++ b/drivers/hwmon/adt7411.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 
 #define ADT7411_REG_CFG1			0x18
 #define ADT7411_CFG1_START_MONITOR		(1 &lt;&lt; 0)
<span class="p_add">+#define ADT7411_CFG1_RESERVED_BIT3		(1 &lt;&lt; 3)</span>
 
 #define ADT7411_REG_CFG2			0x19
 #define ADT7411_CFG2_DISABLE_AVG		(1 &lt;&lt; 5)
<span class="p_chunk">@@ -291,8 +292,10 @@</span> <span class="p_context"> static int __devinit adt7411_probe(struct i2c_client *client,</span>
 	mutex_init(&amp;data-&gt;device_lock);
 	mutex_init(&amp;data-&gt;update_lock);
 
<span class="p_add">+	/* According to the datasheet, we must only write 1 to bit 3 */</span>
 	ret = adt7411_modify_bit(client, ADT7411_REG_CFG1,
<span class="p_del">-				 ADT7411_CFG1_START_MONITOR, 1);</span>
<span class="p_add">+				 ADT7411_CFG1_RESERVED_BIT3</span>
<span class="p_add">+				 | ADT7411_CFG1_START_MONITOR, 1);</span>
 	if (ret &lt; 0)
 		goto exit_free;
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-eg20t.c b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">index 2cda65bf2c0e..46f7bea0385c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_chunk">@@ -893,13 +893,6 @@</span> <span class="p_context"> static int __devinit pch_i2c_probe(struct pci_dev *pdev,</span>
 	/* Set the number of I2C channel instance */
 	adap_info-&gt;ch_num = id-&gt;driver_data;
 
<span class="p_del">-	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_del">-		  KBUILD_MODNAME, adap_info);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_del">-		goto err_request_irq;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {
 		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;
 		adap_info-&gt;pch_i2c_suspended = false;
<span class="p_chunk">@@ -916,6 +909,17 @@</span> <span class="p_context"> static int __devinit pch_i2c_probe(struct pci_dev *pdev,</span>
 		adap_info-&gt;pch_data[i].pch_base_address = base_addr + 0x100 * i;
 
 		pch_adap-&gt;dev.parent = &amp;pdev-&gt;dev;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_add">+		  KBUILD_MODNAME, adap_info);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_add">+		goto err_request_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {</span>
<span class="p_add">+		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;</span>
 
 		pch_i2c_init(&amp;adap_info-&gt;pch_data[i]);
 		ret = i2c_add_adapter(pch_adap);
<span class="p_header">diff --git a/drivers/infiniband/core/multicast.c b/drivers/infiniband/core/multicast.c</span>
<span class="p_header">index d2360a8ef0b2..180d7f436ed5 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/multicast.c</span>
<span class="p_chunk">@@ -106,7 +106,6 @@</span> <span class="p_context"> struct mcast_group {</span>
 	atomic_t		refcount;
 	enum mcast_group_state	state;
 	struct ib_sa_query	*query;
<span class="p_del">-	int			query_id;</span>
 	u16			pkey_index;
 	u8			leave_state;
 	int			retries;
<span class="p_chunk">@@ -339,11 +338,7 @@</span> <span class="p_context"> static int send_join(struct mcast_group *group, struct mcast_member *member)</span>
 				       member-&gt;multicast.comp_mask,
 				       3000, GFP_KERNEL, join_handler, group,
 				       &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static int send_leave(struct mcast_group *group, u8 leave_state)
<span class="p_chunk">@@ -363,11 +358,7 @@</span> <span class="p_context"> static int send_leave(struct mcast_group *group, u8 leave_state)</span>
 				       IB_SA_MCMEMBER_REC_JOIN_STATE,
 				       3000, GFP_KERNEL, leave_handler,
 				       group, &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static void join_group(struct mcast_group *group, struct mcast_member *member,
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">index 86df632ea612..19b70c0c56dd 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_chunk">@@ -434,6 +434,7 @@</span> <span class="p_context"> void ipoib_send(struct net_device *dev, struct sk_buff *skb,</span>
 		struct ipoib_ah *address, u32 qpn);
 void ipoib_reap_ah(struct work_struct *work);
 
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid);</span>
 void ipoib_mark_paths_invalid(struct net_device *dev);
 void ipoib_flush_paths(struct net_device *dev);
 struct ipoib_dev_priv *ipoib_intf_alloc(const char *format);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 376785364420..0bbe030d26a8 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1288,6 +1288,8 @@</span> <span class="p_context"> void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx)</span>
 	}
 }
 
<span class="p_add">+#define QPN_AND_OPTIONS_OFFSET	4</span>
<span class="p_add">+</span>
 static void ipoib_cm_tx_start(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
<span class="p_chunk">@@ -1296,6 +1298,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 	struct ipoib_neigh *neigh;
 	struct ipoib_cm_tx *p;
 	unsigned long flags;
<span class="p_add">+	struct ipoib_path *path;</span>
 	int ret;
 
 	struct ib_sa_path_rec pathrec;
<span class="p_chunk">@@ -1308,7 +1311,19 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		p = list_entry(priv-&gt;cm.start_list.next, typeof(*p), list);
 		list_del_init(&amp;p-&gt;list);
 		neigh = p-&gt;neigh;
<span class="p_add">+</span>
 		qpn = IPOIB_QPN(neigh-&gt;neighbour-&gt;ha);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * As long as the search is with these 2 locks,</span>
<span class="p_add">+		 * path existence indicates its validity.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		path = __path_find(dev, neigh-&gt;neighbour-&gt;ha + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+		if (!path) {</span>
<span class="p_add">+			pr_info(&quot;%s ignore not valid path %pI6\n&quot;,</span>
<span class="p_add">+				__func__,</span>
<span class="p_add">+				neigh-&gt;neighbour-&gt;ha + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+			goto free_neigh;</span>
<span class="p_add">+		}</span>
 		memcpy(&amp;pathrec, &amp;p-&gt;path-&gt;pathrec, sizeof pathrec);
 
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1320,6 +1335,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
 		if (ret) {
<span class="p_add">+free_neigh:</span>
 			neigh = p-&gt;neigh;
 			if (neigh) {
 				neigh-&gt;cm = NULL;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index 4115be54ba3b..1282cb31653d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -973,8 +973,17 @@</span> <span class="p_context"> static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv,</span>
 	}
 
 	if (level == IPOIB_FLUSH_LIGHT) {
<span class="p_add">+		int oper_up;</span>
 		ipoib_mark_paths_invalid(dev);
<span class="p_add">+		/* Set IPoIB operation as down to prevent races between:</span>
<span class="p_add">+		 * the flush flow which leaves MCG and on the fly joins</span>
<span class="p_add">+		 * which can happen during that time. mcast restart task</span>
<span class="p_add">+		 * should deal with join requests we missed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		oper_up = test_and_clear_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_mcast_dev_flush(dev);
<span class="p_add">+		if (oper_up)</span>
<span class="p_add">+			set_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 	}
 
 	if (level &gt;= IPOIB_FLUSH_NORMAL)
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 1740b8217c4d..ae3b1d21e9eb 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -208,7 +208,7 @@</span> <span class="p_context"> static int ipoib_change_mtu(struct net_device *dev, int new_mtu)</span>
 	return 0;
 }
 
<span class="p_del">-static struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node *n = priv-&gt;path_tree.rb_node;
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index 7f39abd566c2..37471e004a29 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -825,6 +825,9 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct usb_endpoint_descriptor *ep_irq_in;
 	int i, error;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints != 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	for (i = 0; xpad_device[i].idVendor; i++) {
 		if ((le16_to_cpu(udev-&gt;descriptor.idVendor) == xpad_device[i].idVendor) &amp;&amp;
 		    (le16_to_cpu(udev-&gt;descriptor.idProduct) == xpad_device[i].idProduct))
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 178e75d6bb06..1284b9221179 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -1223,6 +1223,7 @@</span> <span class="p_context"> static int __init i8042_create_kbd_port(void)</span>
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
 	serio-&gt;close		= i8042_port_close;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	strlcpy(serio-&gt;name, &quot;i8042 KBD port&quot;, sizeof(serio-&gt;name));
<span class="p_chunk">@@ -1248,6 +1249,7 @@</span> <span class="p_context"> static int __init i8042_create_aux_port(int idx)</span>
 	serio-&gt;write		= i8042_aux_write;
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	if (idx &lt; 0) {
<span class="p_chunk">@@ -1310,21 +1312,6 @@</span> <span class="p_context"> static void __devexit i8042_unregister_ports(void)</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Checks whether port belongs to i8042 controller.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool i8042_check_port_owner(const struct serio *port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; I8042_NUM_PORTS; i++)</span>
<span class="p_del">-		if (i8042_ports[i].serio == port)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(i8042_check_port_owner);</span>
<span class="p_del">-</span>
 static void i8042_free_irqs(void)
 {
 	if (i8042_aux_irq_registered)
<span class="p_header">diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c</span>
<span class="p_header">index 07a8363f3c5c..b5ec313cb9c9 100644</span>
<span class="p_header">--- a/drivers/input/serio/libps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/libps2.c</span>
<span class="p_chunk">@@ -57,19 +57,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(ps2_sendbyte);</span>
 
 void ps2_begin_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	mutex_lock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_lock_chip();</span>
<span class="p_add">+	mutex_lock(m);</span>
 }
 EXPORT_SYMBOL(ps2_begin_command);
 
 void ps2_end_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_unlock_chip();</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	mutex_unlock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	mutex_unlock(m);</span>
 }
 EXPORT_SYMBOL(ps2_end_command);
 
<span class="p_header">diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c</span>
<span class="p_header">index 746b5e8bcacd..63226d1c67f3 100644</span>
<span class="p_header">--- a/drivers/md/dm-flakey.c</span>
<span class="p_header">+++ b/drivers/md/dm-flakey.c</span>
<span class="p_chunk">@@ -279,10 +279,16 @@</span> <span class="p_context"> static int flakey_map(struct dm_target *ti, struct bio *bio,</span>
 		map_context-&gt;ll = 1;
 
 		/*
<span class="p_del">-		 * Map reads as normal.</span>
<span class="p_add">+		 * Map reads as normal only if corrupt_bio_byte set.</span>
 		 */
<span class="p_del">-		if (bio_data_dir(bio) == READ)</span>
<span class="p_del">-			goto map_bio;</span>
<span class="p_add">+		if (bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			/* If flags were specified, only corrupt those that match. */</span>
<span class="p_add">+			if (fc-&gt;corrupt_bio_byte &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_add">+			    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_add">+				goto map_bio;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * Drop writes?
<span class="p_chunk">@@ -321,12 +327,13 @@</span> <span class="p_context"> static int flakey_end_io(struct dm_target *ti, struct bio *bio,</span>
 
 	/*
 	 * Corrupt successful READs while in down state.
<span class="p_del">-	 * If flags were specified, only corrupt those that match.</span>
 	 */
<span class="p_del">-	if (fc-&gt;corrupt_bio_byte &amp;&amp; !error &amp;&amp; bio_submitted_while_down &amp;&amp;</span>
<span class="p_del">-	    (bio_data_dir(bio) == READ) &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_del">-	    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_del">-		corrupt_bio_data(bio, fc);</span>
<span class="p_add">+	if (!error &amp;&amp; bio_submitted_while_down &amp;&amp; (bio_data_dir(bio) == READ)) {</span>
<span class="p_add">+		if (fc-&gt;corrupt_bio_byte)</span>
<span class="p_add">+			corrupt_bio_data(bio, fc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_header">diff --git a/drivers/media/video/usbvision/usbvision-video.c b/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_header">index 902140e8db3e..8f7408116362 100644</span>
<span class="p_header">--- a/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_header">+++ b/drivers/media/video/usbvision/usbvision-video.c</span>
<span class="p_chunk">@@ -1502,13 +1502,6 @@</span> <span class="p_context"> static int __devinit usbvision_probe(struct usb_interface *intf,</span>
 	printk(KERN_INFO &quot;%s: %s found\n&quot;, __func__,
 				usbvision_device_data[model].model_string);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * this is a security check.</span>
<span class="p_del">-	 * an exploit using an incorrect bInterfaceNumber is known</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ifnum &gt;= USB_MAXINTERFACES || !dev-&gt;actconfig-&gt;interface[ifnum])</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
 	if (usbvision_device_data[model].interface &gt;= 0)
 		interface = &amp;dev-&gt;actconfig-&gt;interface[usbvision_device_data[model].interface]-&gt;altsetting[0];
 	else if (ifnum &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces)
<span class="p_header">diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">index 744ca5cacc9b..f9fa3fad728e 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_chunk">@@ -75,15 +75,15 @@</span> <span class="p_context"> static int __init init_msp_flash(void)</span>
 
 	printk(KERN_NOTICE &quot;Found %d PMC flash devices\n&quot;, fcnt);
 
<span class="p_del">-	msp_flash = kmalloc(fcnt * sizeof(struct map_info *), GFP_KERNEL);</span>
<span class="p_add">+	msp_flash = kcalloc(fcnt, sizeof(*msp_flash), GFP_KERNEL);</span>
 	if (!msp_flash)
 		return -ENOMEM;
 
<span class="p_del">-	msp_parts = kmalloc(fcnt * sizeof(struct mtd_partition *), GFP_KERNEL);</span>
<span class="p_add">+	msp_parts = kcalloc(fcnt, sizeof(*msp_parts), GFP_KERNEL);</span>
 	if (!msp_parts)
 		goto free_msp_flash;
 
<span class="p_del">-	msp_maps = kcalloc(fcnt, sizeof(struct mtd_info), GFP_KERNEL);</span>
<span class="p_add">+	msp_maps = kcalloc(fcnt, sizeof(*msp_maps), GFP_KERNEL);</span>
 	if (!msp_maps)
 		goto free_msp_parts;
 
<span class="p_header">diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">index c153e1f77f90..4aa25d73dfef 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_chunk">@@ -239,6 +239,9 @@</span> <span class="p_context"> static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)</span>
 	unsigned long flags;
 	u32 val;
 
<span class="p_add">+	/* Reset ECC hardware */</span>
<span class="p_add">+	davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;davinci_nand_lock, flags);
 
 	/* Start 4-bit ECC calculation for read/write */
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 46ed2962ad08..89b85838cf3f 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2229,7 +2229,7 @@</span> <span class="p_context"> static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,</span>
 		uint8_t *wbuf = buf;
 
 		/* Partial page write? */
<span class="p_del">-		if (unlikely(column || writelen &lt; (mtd-&gt;writesize - 1))) {</span>
<span class="p_add">+		if (unlikely(column || writelen &lt; mtd-&gt;writesize)) {</span>
 			cached = 0;
 			bytes = min_t(int, bytes - column, (int) writelen);
 			chip-&gt;pagebuf = -1;
<span class="p_header">diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c</span>
<span class="p_header">index 1f9c3637755a..5c87c94d6eab 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/build.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/build.c</span>
<span class="p_chunk">@@ -974,6 +974,9 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset)</span>
 			goto out_detach;
 	}
 
<span class="p_add">+	/* Make device &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	ubi_devices[ubi_num] = ubi;</span>
<span class="p_add">+</span>
 	err = uif_init(ubi, &amp;ref);
 	if (err)
 		goto out_detach;
<span class="p_chunk">@@ -1017,7 +1020,6 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset)</span>
 	wake_up_process(ubi-&gt;bgt_thread);
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	ubi_devices[ubi_num] = ubi;</span>
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
<span class="p_chunk">@@ -1028,6 +1030,7 @@</span> <span class="p_context"> out_uif:</span>
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
<span class="p_add">+	ubi_devices[ubi_num] = NULL;</span>
 	ubi_wl_close(ubi);
 	free_internal_volumes(ubi);
 	vfree(ubi-&gt;vtbl);
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index 217b0a3893fc..a1f434e1b29f 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/if_arp.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/can.h&gt;
 #include &lt;linux/can/dev.h&gt;
 #include &lt;linux/can/netlink.h&gt;
<span class="p_chunk">@@ -361,9 +362,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(can_free_echo_skb);</span>
 /*
  * CAN device restart for bus-off recovery
  */
<span class="p_del">-void can_restart(unsigned long data)</span>
<span class="p_add">+void can_restart(struct net_device *dev)</span>
 {
<span class="p_del">-	struct net_device *dev = (struct net_device *)data;</span>
 	struct can_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -403,6 +403,14 @@</span> <span class="p_context"> restart:</span>
 		dev_err(dev-&gt;dev.parent, &quot;Error %d during restart&quot;, err);
 }
 
<span class="p_add">+static void can_restart_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct delayed_work *dwork = to_delayed_work(work);</span>
<span class="p_add">+	struct can_priv *priv = container_of(dwork, struct can_priv, restart_work);</span>
<span class="p_add">+</span>
<span class="p_add">+	can_restart(priv-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int can_restart_now(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -416,8 +424,8 @@</span> <span class="p_context"> int can_restart_now(struct net_device *dev)</span>
 	if (priv-&gt;state != CAN_STATE_BUS_OFF)
 		return -EBUSY;
 
<span class="p_del">-	/* Runs as soon as possible in the timer context */</span>
<span class="p_del">-	mod_timer(&amp;priv-&gt;restart_timer, jiffies);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
<span class="p_add">+	can_restart(dev);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -439,8 +447,8 @@</span> <span class="p_context"> void can_bus_off(struct net_device *dev)</span>
 	priv-&gt;can_stats.bus_off++;
 
 	if (priv-&gt;restart_ms)
<span class="p_del">-		mod_timer(&amp;priv-&gt;restart_timer,</span>
<span class="p_del">-			  jiffies + (priv-&gt;restart_ms * HZ) / 1000);</span>
<span class="p_add">+		schedule_delayed_work(&amp;priv-&gt;restart_work,</span>
<span class="p_add">+				      msecs_to_jiffies(priv-&gt;restart_ms));</span>
 }
 EXPORT_SYMBOL_GPL(can_bus_off);
 
<span class="p_chunk">@@ -515,6 +523,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 		return NULL;
 
 	priv = netdev_priv(dev);
<span class="p_add">+	priv-&gt;dev = dev;</span>
 
 	if (echo_skb_max) {
 		priv-&gt;echo_skb_max = echo_skb_max;
<span class="p_chunk">@@ -524,7 +533,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 
 	priv-&gt;state = CAN_STATE_STOPPED;
 
<span class="p_del">-	init_timer(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;priv-&gt;restart_work, can_restart_work);</span>
 
 	return dev;
 }
<span class="p_chunk">@@ -558,8 +567,6 @@</span> <span class="p_context"> int open_candev(struct net_device *dev)</span>
 	if (!netif_carrier_ok(dev))
 		netif_carrier_on(dev);
 
<span class="p_del">-	setup_timer(&amp;priv-&gt;restart_timer, can_restart, (unsigned long)dev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(open_candev);
<span class="p_chunk">@@ -574,7 +581,7 @@</span> <span class="p_context"> void close_candev(struct net_device *dev)</span>
 {
 	struct can_priv *priv = netdev_priv(dev);
 
<span class="p_del">-	del_timer_sync(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
 	can_flush_echo_skb(dev);
 }
 EXPORT_SYMBOL_GPL(close_candev);
<span class="p_header">diff --git a/drivers/net/ethernet/ethoc.c b/drivers/net/ethernet/ethoc.c</span>
<span class="p_header">index 251b635fe75a..b3b22f487b41 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ethoc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ethoc.c</span>
<span class="p_chunk">@@ -976,7 +976,7 @@</span> <span class="p_context"> static int __devinit ethoc_probe(struct platform_device *pdev)</span>
 	if (!priv-&gt;iobase) {
 		dev_err(&amp;pdev-&gt;dev, &quot;cannot remap I/O memory space\n&quot;);
 		ret = -ENXIO;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 
 	if (netdev-&gt;mem_end) {
<span class="p_chunk">@@ -985,7 +985,7 @@</span> <span class="p_context"> static int __devinit ethoc_probe(struct platform_device *pdev)</span>
 		if (!priv-&gt;membase) {
 			dev_err(&amp;pdev-&gt;dev, &quot;cannot remap memory space\n&quot;);
 			ret = -ENXIO;
<span class="p_del">-			goto error;</span>
<span class="p_add">+			goto free;</span>
 		}
 	} else {
 		/* Allocate buffer memory */
<span class="p_chunk">@@ -996,7 +996,7 @@</span> <span class="p_context"> static int __devinit ethoc_probe(struct platform_device *pdev)</span>
 			dev_err(&amp;pdev-&gt;dev, &quot;cannot allocate %dB buffer\n&quot;,
 				buffer_size);
 			ret = -ENOMEM;
<span class="p_del">-			goto error;</span>
<span class="p_add">+			goto free;</span>
 		}
 		netdev-&gt;mem_end = netdev-&gt;mem_start + buffer_size;
 		priv-&gt;dma_alloc = buffer_size;
<span class="p_chunk">@@ -1007,7 +1007,7 @@</span> <span class="p_context"> static int __devinit ethoc_probe(struct platform_device *pdev)</span>
 		128, (netdev-&gt;mem_end - netdev-&gt;mem_start + 1) / ETHOC_BUFSIZ);
 	if (num_bd &lt; 4) {
 		ret = -ENODEV;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 	/* num_tx must be a power of two */
 	priv-&gt;num_tx = rounddown_pow_of_two(num_bd &gt;&gt; 1);
<span class="p_chunk">@@ -1019,7 +1019,7 @@</span> <span class="p_context"> static int __devinit ethoc_probe(struct platform_device *pdev)</span>
 	priv-&gt;vma = devm_kzalloc(&amp;pdev-&gt;dev, num_bd*sizeof(void*), GFP_KERNEL);
 	if (!priv-&gt;vma) {
 		ret = -ENOMEM;
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto free;</span>
 	}
 
 	/* Allow the platform setup code to pass in a MAC address. */
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index 9907ac78aed0..4810d2628b10 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -2275,8 +2275,6 @@</span> <span class="p_context"> ppp_unregister_channel(struct ppp_channel *chan)</span>
 	spin_lock_bh(&amp;pn-&gt;all_channels_lock);
 	list_del(&amp;pch-&gt;list);
 	spin_unlock_bh(&amp;pn-&gt;all_channels_lock);
<span class="p_del">-	put_net(pch-&gt;chan_net);</span>
<span class="p_del">-	pch-&gt;chan_net = NULL;</span>
 
 	pch-&gt;file.dead = 1;
 	wake_up_interruptible(&amp;pch-&gt;file.rwait);
<span class="p_chunk">@@ -2883,6 +2881,9 @@</span> <span class="p_context"> ppp_disconnect_channel(struct channel *pch)</span>
  */
 static void ppp_destroy_channel(struct channel *pch)
 {
<span class="p_add">+	put_net(pch-&gt;chan_net);</span>
<span class="p_add">+	pch-&gt;chan_net = NULL;</span>
<span class="p_add">+</span>
 	atomic_dec(&amp;channel_count);
 
 	if (!pch-&gt;file.dead) {
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmsmac/stf.c b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">index d8f528eb180c..6fc47ff0c9f9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> void</span>
 brcms_c_stf_ss_algo_channel_get(struct brcms_c_info *wlc, u16 *ss_algo_channel,
 			    u16 chanspec)
 {
<span class="p_del">-	struct tx_power power;</span>
<span class="p_add">+	struct tx_power power = { };</span>
 	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
<span class="p_header">diff --git a/drivers/pps/clients/pps_parport.c b/drivers/pps/clients/pps_parport.c</span>
<span class="p_header">index e1b4705ae3ec..7e9bcd4a187e 100644</span>
<span class="p_header">--- a/drivers/pps/clients/pps_parport.c</span>
<span class="p_header">+++ b/drivers/pps/clients/pps_parport.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static void parport_detach(struct parport *port)</span>
 	struct pps_client_pp *device;
 
 	/* FIXME: oooh, this is ugly! */
<span class="p_del">-	if (strcmp(pardev-&gt;name, KBUILD_MODNAME))</span>
<span class="p_add">+	if (!pardev || strcmp(pardev-&gt;name, KBUILD_MODNAME))</span>
 		/* not our port */
 		return;
 
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 65894f05a801..a0630eb41ae1 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -1593,9 +1593,18 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	unsigned long long now;
 	int expires;
 
<span class="p_add">+	cqr = (struct dasd_ccw_req *) intparm;</span>
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
<span class="p_add">+			if (cqr &amp;&amp; cqr-&gt;status == DASD_CQR_CLEAR_PENDING) {</span>
<span class="p_add">+				device = (struct dasd_device *) cqr-&gt;startdev;</span>
<span class="p_add">+				cqr-&gt;status = DASD_CQR_CLEARED;</span>
<span class="p_add">+				dasd_device_clear_timer(device);</span>
<span class="p_add">+				wake_up(&amp;dasd_flush_wq);</span>
<span class="p_add">+				dasd_schedule_device_bh(device);</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			}</span>
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, &quot;%s: &quot;
<span class="p_chunk">@@ -1611,7 +1620,6 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	}
 
 	now = get_clock();
<span class="p_del">-	cqr = (struct dasd_ccw_req *) intparm;</span>
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&amp;irb-&gt;scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">index 1254431d3053..e68febdf1a40 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
<span class="p_del">-	unsigned size;</span>
<span class="p_add">+	unsigned int size, osize;</span>
 	int retval;
 
 	if (dev-&gt;in_reset) {
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
<span class="p_del">-	size = le16_to_cpu(kfib-&gt;header.Size) + sizeof(struct aac_fibhdr);</span>
<span class="p_add">+	osize = size = le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr);</span>
 	if (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))
 		size = le16_to_cpu(kfib-&gt;header.SenderSize);
 	if (size &gt; dev-&gt;max_fib_size) {
<span class="p_chunk">@@ -118,6 +119,14 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	/* Sanity check the second copy */</span>
<span class="p_add">+	if ((osize != le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr))</span>
<span class="p_add">+		|| (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))) {</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (kfib-&gt;header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
<span class="p_header">diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">index f980600f78a8..2dcbb970deba 100644</span>
<span class="p_header">--- a/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">+++ b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_chunk">@@ -1803,7 +1803,8 @@</span> <span class="p_context"> static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,</span>
 
 	case ARCMSR_MESSAGE_WRITE_WQBUFFER: {
 		unsigned char *ver_addr;
<span class="p_del">-		int32_t my_empty_len, user_len, wqbuf_firstindex, wqbuf_lastindex;</span>
<span class="p_add">+		uint32_t user_len;</span>
<span class="p_add">+		int32_t my_empty_len, wqbuf_firstindex, wqbuf_lastindex;</span>
 		uint8_t *pQbuffer, *ptmpuserbuffer;
 
 		ver_addr = kmalloc(1032, GFP_ATOMIC);
<span class="p_chunk">@@ -1820,6 +1821,11 @@</span> <span class="p_context"> static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,</span>
 		}
 		ptmpuserbuffer = ver_addr;
 		user_len = pcmdmessagefld-&gt;cmdmessage.Length;
<span class="p_add">+		if (user_len &gt; 1032) {</span>
<span class="p_add">+			retvalue = ARCMSR_MESSAGE_FAIL;</span>
<span class="p_add">+			kfree(ver_addr);</span>
<span class="p_add">+			goto message_out;</span>
<span class="p_add">+		}</span>
 		memcpy(ptmpuserbuffer, pcmdmessagefld-&gt;messagedatabuffer, user_len);
 		wqbuf_lastindex = acb-&gt;wqbuf_lastindex;
 		wqbuf_firstindex = acb-&gt;wqbuf_firstindex;
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 3b1ba103de2b..10550f3c7b45 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -3508,7 +3508,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance-&gt;pdev, IORESOURCE_MEM);
 	instance-&gt;bar = find_first_bit(&amp;bar_list, sizeof(unsigned long));
<span class="p_del">-	if (pci_request_selected_regions(instance-&gt;pdev, instance-&gt;bar,</span>
<span class="p_add">+	if (pci_request_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar,</span>
 					 &quot;megasas: LSI&quot;)) {
 		printk(KERN_DEBUG &quot;megasas: IO memory region busy!\n&quot;);
 		return -EBUSY;
<span class="p_chunk">@@ -3661,7 +3661,7 @@</span> <span class="p_context"> fail_ready_state:</span>
 	iounmap(instance-&gt;reg_set);
 
       fail_ioremap:
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -3682,7 +3682,7 @@</span> <span class="p_context"> static void megasas_release_mfi(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 3e0f71c155a3..1951f4e73bb5 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2026,7 +2026,7 @@</span> <span class="p_context"> megasas_release_fusion(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/iio/accel/kxsd9.c b/drivers/staging/iio/accel/kxsd9.c</span>
<span class="p_header">index 5541ed38e090..3ec7e34e8ada 100644</span>
<span class="p_header">--- a/drivers/staging/iio/accel/kxsd9.c</span>
<span class="p_header">+++ b/drivers/staging/iio/accel/kxsd9.c</span>
<span class="p_chunk">@@ -163,11 +163,13 @@</span> <span class="p_context"> static int kxsd9_read_raw(struct iio_dev *indio_dev,</span>
 		if (ret &lt; 0)
 			goto error_ret;
 		*val = ret;
<span class="p_add">+		ret = IIO_VAL_INT;</span>
 		break;
 	case (1 &lt;&lt; IIO_CHAN_INFO_SCALE_SHARED):
 		ret = spi_w8r8(st-&gt;us, KXSD9_READ(KXSD9_REG_CTRL_C));
 		if (ret &lt; 0)
 			goto error_ret;
<span class="p_add">+		*val = 0;</span>
 		*val2 = kxsd9_micro_scales[ret &amp; KXSD9_FS_MASK];
 		ret = IIO_VAL_INT_PLUS_MICRO;
 		break;
<span class="p_header">diff --git a/drivers/staging/pohmelfs/Kconfig b/drivers/staging/pohmelfs/Kconfig</span>
<span class="p_header">index 8d53b1a1e715..b88769c03ccb 100644</span>
<span class="p_header">--- a/drivers/staging/pohmelfs/Kconfig</span>
<span class="p_header">+++ b/drivers/staging/pohmelfs/Kconfig</span>
<span class="p_chunk">@@ -1,5 +1,6 @@</span> <span class="p_context"></span>
 config POHMELFS
 	tristate &quot;POHMELFS filesystem support&quot;
<span class="p_add">+	depends on BROKEN</span>
 	depends on NET
 	select CONNECTOR
 	select CRYPTO
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 626e75b60caa..808d171bd1af 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -1237,8 +1237,6 @@</span> <span class="p_context"> int s3c24xx_serial_probe(struct platform_device *dev,</span>
 	dbg(&quot;s3c24xx_serial_probe(%p, %p) %d\n&quot;, dev, info, probe_index);
 
 	ourport = &amp;s3c24xx_serial_ports[probe_index];
<span class="p_del">-	probe_index++;</span>
<span class="p_del">-</span>
 	dbg(&quot;%s: initialising port %p...\n&quot;, __func__, ourport);
 
 	ret = s3c24xx_serial_init_port(ourport, info, dev);
<span class="p_chunk">@@ -1275,6 +1273,8 @@</span> <span class="p_context"> int __devexit s3c24xx_serial_remove(struct platform_device *dev)</span>
 		uart_remove_one_port(&amp;s3c24xx_uart_drv, port);
 	}
 
<span class="p_add">+	probe_index++;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c</span>
<span class="p_header">index a605549ee28f..89c07d69a54a 100644</span>
<span class="p_header">--- a/drivers/tty/vt/keyboard.c</span>
<span class="p_header">+++ b/drivers/tty/vt/keyboard.c</span>
<span class="p_chunk">@@ -386,34 +386,22 @@</span> <span class="p_context"> static void to_utf8(struct vc_data *vc, uint c)</span>
  */
 void compute_shiftstate(void)
 {
<span class="p_del">-	unsigned int i, j, k, sym, val;</span>
<span class="p_add">+	unsigned int k, sym, val;</span>
 
 	shift_state = 0;
 	memset(shift_down, 0, sizeof(shift_down));
 
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(key_down); i++) {</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!key_down[i])</span>
<span class="p_add">+	for_each_set_bit(k, key_down, min(NR_KEYS, KEY_CNT)) {</span>
<span class="p_add">+		sym = U(key_maps[0][k]);</span>
<span class="p_add">+		if (KTYP(sym) != KT_SHIFT &amp;&amp; KTYP(sym) != KT_SLOCK)</span>
 			continue;
 
<span class="p_del">-		k = i * BITS_PER_LONG;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (j = 0; j &lt; BITS_PER_LONG; j++, k++) {</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!test_bit(k, key_down))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		val = KVAL(sym);</span>
<span class="p_add">+		if (val == KVAL(K_CAPSSHIFT))</span>
<span class="p_add">+			val = KVAL(K_SHIFT);</span>
 
<span class="p_del">-			sym = U(key_maps[0][k]);</span>
<span class="p_del">-			if (KTYP(sym) != KT_SHIFT &amp;&amp; KTYP(sym) != KT_SLOCK)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			val = KVAL(sym);</span>
<span class="p_del">-			if (val == KVAL(K_CAPSSHIFT))</span>
<span class="p_del">-				val = KVAL(K_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-			shift_down[val]++;</span>
<span class="p_del">-			shift_state |= (1 &lt;&lt; val);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		shift_down[val]++;</span>
<span class="p_add">+		shift_state |= BIT(val);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 3d96de0b278c..a1b384ecabba 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1156,7 +1156,6 @@</span> <span class="p_context"> made_compressed_probe:</span>
 	spin_lock_init(&amp;acm-&gt;write_lock);
 	spin_lock_init(&amp;acm-&gt;read_lock);
 	mutex_init(&amp;acm-&gt;mutex);
<span class="p_del">-	acm-&gt;rx_endpoint = usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress);</span>
 	acm-&gt;is_int_ep = usb_endpoint_xfer_int(epread);
 	if (acm-&gt;is_int_ep)
 		acm-&gt;bInterval = epread-&gt;bInterval;
<span class="p_chunk">@@ -1205,14 +1204,14 @@</span> <span class="p_context"> made_compressed_probe:</span>
 		urb-&gt;transfer_dma = rb-&gt;dma;
 		if (acm-&gt;is_int_ep) {
 			usb_fill_int_urb(urb, acm-&gt;dev,
<span class="p_del">-					 acm-&gt;rx_endpoint,</span>
<span class="p_add">+					 usb_rcvintpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					 rb-&gt;base,
 					 acm-&gt;readsize,
 					 acm_read_bulk_callback, rb,
 					 acm-&gt;bInterval);
 		} else {
 			usb_fill_bulk_urb(urb, acm-&gt;dev,
<span class="p_del">-					  acm-&gt;rx_endpoint,</span>
<span class="p_add">+					  usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					  rb-&gt;base,
 					  acm-&gt;readsize,
 					  acm_read_bulk_callback, rb);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index dfd66bb5977a..32ef178b8f86 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -95,7 +95,6 @@</span> <span class="p_context"> struct acm {</span>
 	struct urb *read_urbs[ACM_NR];
 	struct acm_rb read_buffers[ACM_NR];
 	int rx_buflimit;
<span class="p_del">-	int rx_endpoint;</span>
 	spinlock_t read_lock;
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index ffc69891318a..5a28a14ffa1b 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -144,6 +144,31 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 	}
 }
 
<span class="p_add">+static const unsigned short low_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 8,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 8,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short full_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1023,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 64,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short high_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short super_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
<span class="p_chunk">@@ -152,6 +177,8 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
<span class="p_add">+	unsigned int maxp;</span>
<span class="p_add">+	const unsigned short *maxpacket_maxes;</span>
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
<span class="p_chunk">@@ -186,8 +213,10 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	memcpy(&amp;endpoint-&gt;desc, d, n);
 	INIT_LIST_HEAD(&amp;endpoint-&gt;urb_list);
 
<span class="p_del">-	/* Fix up bInterval values outside the legal range. Use 32 ms if no</span>
<span class="p_del">-	 * proper value can be guessed. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fix up bInterval values outside the legal range.</span>
<span class="p_add">+	 * Use 10 or 8 ms if no proper value can be guessed.</span>
<span class="p_add">+	 */</span>
 	i = 0;		/* i = min, j = max, n = default */
 	j = 255;
 	if (usb_endpoint_xfer_int(d)) {
<span class="p_chunk">@@ -195,13 +224,15 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 		switch (to_usb_device(ddev)-&gt;speed) {
 		case USB_SPEED_SUPER:
 		case USB_SPEED_HIGH:
<span class="p_del">-			/* Many device manufacturers are using full-speed</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Many device manufacturers are using full-speed</span>
 			 * bInterval values in high-speed interrupt endpoint
<span class="p_del">-			 * descriptors. Try to fix those and fall back to a</span>
<span class="p_del">-			 * 32 ms default value otherwise. */</span>
<span class="p_add">+			 * descriptors. Try to fix those and fall back to an</span>
<span class="p_add">+			 * 8-ms default value otherwise.</span>
<span class="p_add">+			 */</span>
 			n = fls(d-&gt;bInterval*8);
 			if (n == 0)
<span class="p_del">-				n = 9;	/* 32 ms = 2^(9-1) uframes */</span>
<span class="p_add">+				n = 7;	/* 8 ms = 2^(7-1) uframes */</span>
 			j = 16;
 
 			/*
<span class="p_chunk">@@ -216,10 +247,12 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			}
 			break;
 		default:		/* USB_SPEED_FULL or _LOW */
<span class="p_del">-			/* For low-speed, 10 ms is the official minimum.</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * For low-speed, 10 ms is the official minimum.</span>
 			 * But some &quot;overclocked&quot; devices might want faster
<span class="p_del">-			 * polling so we&#39;ll allow it. */</span>
<span class="p_del">-			n = 32;</span>
<span class="p_add">+			 * polling so we&#39;ll allow it.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			n = 10;</span>
 			break;
 		}
 	} else if (usb_endpoint_xfer_isoc(d)) {
<span class="p_chunk">@@ -227,10 +260,10 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 		j = 16;
 		switch (to_usb_device(ddev)-&gt;speed) {
 		case USB_SPEED_HIGH:
<span class="p_del">-			n = 9;		/* 32 ms = 2^(9-1) uframes */</span>
<span class="p_add">+			n = 7;		/* 8 ms = 2^(7-1) uframes */</span>
 			break;
 		default:		/* USB_SPEED_FULL */
<span class="p_del">-			n = 6;		/* 32 ms = 2^(6-1) frames */</span>
<span class="p_add">+			n = 4;		/* 8 ms = 2^(4-1) frames */</span>
 			break;
 		}
 	}
<span class="p_chunk">@@ -258,6 +291,41 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
<span class="p_add">+	/* Validate the wMaxPacketSize field */</span>
<span class="p_add">+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the highest legal maxpacket size for this endpoint */</span>
<span class="p_add">+	i = 0;		/* additional transactions per microframe */</span>
<span class="p_add">+	switch (to_usb_device(ddev)-&gt;speed) {</span>
<span class="p_add">+	case USB_SPEED_LOW:</span>
<span class="p_add">+		maxpacket_maxes = low_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_FULL:</span>
<span class="p_add">+		maxpacket_maxes = full_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_HIGH:</span>
<span class="p_add">+		/* Bits 12..11 are allowed only for HS periodic endpoints */</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {</span>
<span class="p_add">+			i = maxp &amp; (BIT(12) | BIT(11));</span>
<span class="p_add">+			maxp &amp;= ~i;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		maxpacket_maxes = high_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_SUPER:</span>
<span class="p_add">+		maxpacket_maxes = super_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (maxp &gt; j) {</span>
<span class="p_add">+		dev_warn(ddev, &quot;config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n&quot;,</span>
<span class="p_add">+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);</span>
<span class="p_add">+		maxp = j;</span>
<span class="p_add">+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
<span class="p_chunk">@@ -265,9 +333,6 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
<span class="p_del">-		unsigned maxp;</span>
<span class="p_del">-</span>
<span class="p_del">-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;</span>
 		if (maxp != 512)
 			dev_warn(ddev, &quot;config %d interface %d altsetting %d &quot;
 				&quot;bulk endpoint 0x%X has invalid maxpacket %d\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index ed11901ab8ab..45d3007cf86e 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1281,11 +1281,17 @@</span> <span class="p_context"> static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,</span>
 	as-&gt;urb-&gt;setup_packet = (unsigned char *)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = uurb-&gt;number_of_packets;
<span class="p_del">-	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_del">-			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ep-&gt;desc.bInterval) {</span>
<span class="p_add">+		if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = 1 &lt;&lt;</span>
<span class="p_add">+					min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	as-&gt;urb-&gt;context = as;
 	as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; uurb-&gt;number_of_packets; u++) {
<span class="p_header">diff --git a/drivers/usb/gadget/fsl_qe_udc.c b/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_header">index e00cf92409ce..4e2b5a901ffe 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -1883,11 +1883,8 @@</span> <span class="p_context"> static int qe_get_frame(struct usb_gadget *gadget)</span>
 
 	tmp = in_be16(&amp;udc_controller-&gt;usb_param-&gt;frame_n);
 	if (tmp &amp; 0x8000)
<span class="p_del">-		tmp = tmp &amp; 0x07ff;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tmp = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (int)tmp;</span>
<span class="p_add">+		return tmp &amp; 0x07ff;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 /* Tries to wake up the host connected to this gadget
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 860581308f87..13bb316e832b 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -278,6 +278,9 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 
 	ret = 0;
 	virt_dev = xhci-&gt;devs[slot_id];
<span class="p_add">+	if (!virt_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	cmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);
 	if (!cmd) {
 		xhci_dbg(xhci, &quot;Couldn&#39;t allocate command structure.\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 50af559183eb..cc6aa66f4278 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -252,12 +252,13 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
 	}
<span class="p_del">-	usb_hcd_pci_remove(dev);</span>
 
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci-&gt;quirks &amp; XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
 
<span class="p_add">+	usb_hcd_pci_remove(dev);</span>
<span class="p_add">+</span>
 	kfree(xhci);
 }
 
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 6fb551476cca..2eb39b39ea1b 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -760,15 +760,22 @@</span> <span class="p_context"> static void usbhsf_dma_prepare_tasklet(unsigned long data)</span>
 {
 	struct usbhs_pkt *pkt = (struct usbhs_pkt *)data;
 	struct usbhs_pipe *pipe = pkt-&gt;pipe;
<span class="p_del">-	struct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	struct usbhs_fifo *fifo;</span>
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
 	struct scatterlist sg;
 	struct dma_async_tx_descriptor *desc;
<span class="p_del">-	struct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);</span>
<span class="p_add">+	struct dma_chan *chan;</span>
 	struct device *dev = usbhs_priv_to_dev(priv);
 	enum dma_data_direction dir;
 	dma_cookie_t cookie;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
<span class="p_add">+	fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	if (!fifo)</span>
<span class="p_add">+		goto xfer_work_end;</span>
 
<span class="p_add">+	chan = usbhsf_dma_chan_get(fifo, pkt);</span>
 	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
 
 	sg_init_table(&amp;sg, 1);
<span class="p_chunk">@@ -781,7 +788,7 @@</span> <span class="p_context"> static void usbhsf_dma_prepare_tasklet(unsigned long data)</span>
 						  DMA_PREP_INTERRUPT |
 						  DMA_CTRL_ACK);
 	if (!desc)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 
 	desc-&gt;callback		= usbhsf_dma_complete;
 	desc-&gt;callback_param	= pipe;
<span class="p_chunk">@@ -789,7 +796,7 @@</span> <span class="p_context"> static void usbhsf_dma_prepare_tasklet(unsigned long data)</span>
 	cookie = desc-&gt;tx_submit(desc);
 	if (cookie &lt; 0) {
 		dev_err(dev, &quot;Failed to submit dma descriptor\n&quot;);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 	}
 
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
<span class="p_chunk">@@ -797,6 +804,9 @@</span> <span class="p_context"> static void usbhsf_dma_prepare_tasklet(unsigned long data)</span>
 
 	usbhsf_dma_start(pipe, fifo);
 	dma_async_issue_pending(chan);
<span class="p_add">+</span>
<span class="p_add">+xfer_work_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 0b1fc0776b82..eb465621193b 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -472,6 +472,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
 
 	/*
 	 * if it already have pipe,
<span class="p_chunk">@@ -480,7 +483,8 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	if (uep-&gt;pipe) {
 		usbhs_pipe_clear(uep-&gt;pipe);
 		usbhs_pipe_sequence_data0(uep-&gt;pipe);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto usbhsg_ep_enable_end;</span>
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
<span class="p_chunk">@@ -508,6 +512,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		ret = 0;
 	}
 
<span class="p_add">+usbhsg_ep_enable_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index f0b752591f2e..93fe0077f108 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -672,6 +672,8 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },</span>
 	{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },
<span class="p_chunk">@@ -1030,6 +1032,7 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
<span class="p_add">+	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },</span>
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index c2e80ebe34a9..559669786a20 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -406,6 +406,12 @@</span> <span class="p_context"></span>
 #define FTDI_4N_GALAXY_DE_3_PID	0xF3C2
 
 /*
<span class="p_add">+ * Ivium Technologies product IDs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_PALMSENS_PID	0xf440</span>
<span class="p_add">+#define FTDI_IVIUM_XSTAT_PID	0xf441</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Linx Technologies product ids
  */
 #define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
<span class="p_chunk">@@ -667,6 +673,12 @@</span> <span class="p_context"></span>
 #define INTREPID_NEOVI_PID	0x0701
 
 /*
<span class="p_add">+ * WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WICED_VID		0x0A5C</span>
<span class="p_add">+#define WICED_USB20706V2_PID	0x6422</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Definitions for ID TECH (www.idt-net.com) devices
  */
 #define IDTECH_VID		0x0ACD	/* ID TECH Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index 8e02ff2b7d7f..e3609b84b7a8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -1320,7 +1320,7 @@</span> <span class="p_context"> static int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 
 	if (urb-&gt;transfer_buffer == NULL) {
 		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,
<span class="p_del">-					       GFP_KERNEL);</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (urb-&gt;transfer_buffer == NULL) {
 			dev_err(&amp;port-&gt;dev, &quot;%s no more kernel memory...\n&quot;,
 				__func__);
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 80fc40a0c99a..59fdb84d016f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1524,8 +1524,8 @@</span> <span class="p_context"> static int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 	}
 
 	if (urb-&gt;transfer_buffer == NULL) {
<span class="p_del">-		urb-&gt;transfer_buffer =</span>
<span class="p_del">-		    kmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 
 		if (urb-&gt;transfer_buffer == NULL) {
 			dev_err(&amp;port-&gt;dev, &quot;%s no more kernel memory...\n&quot;,
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index d541b2540837..10e79b76e8d1 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -273,6 +273,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG3		0x1043
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
<span class="p_add">+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -511,6 +512,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define VIATELECOM_VENDOR_ID			0x15eb
 #define VIATELECOM_PRODUCT_CDS7			0x0001
 
<span class="p_add">+/* WeTelecom products */</span>
<span class="p_add">+#define WETELECOM_VENDOR_ID			0x22de</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD200		0x6801</span>
<span class="p_add">+#define WETELECOM_PRODUCT_6802			0x6802</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD300		0x6803</span>
<span class="p_add">+</span>
 /* some devices interfaces need special handling due to a number of reasons */
 enum option_blacklist_reason {
 		OPTION_BLACKLIST_NONE = 0,
<span class="p_chunk">@@ -1193,6 +1200,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
<span class="p_chunk">@@ -1942,8 +1951,12 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */</span>
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },</span>
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 28153fb2225d..2975c5089dac 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -142,6 +142,8 @@</span> <span class="p_context"> static void leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	/* We can only do one array worth at a time. */
 	num = min(num, ARRAY_SIZE(vb-&gt;pfns));
 
<span class="p_add">+	/* We can&#39;t release more pages than taken */</span>
<span class="p_add">+	num = min(num, (size_t)vb-&gt;num_pages);</span>
 	for (vb-&gt;num_pfns = 0; vb-&gt;num_pfns &lt; num; vb-&gt;num_pfns++) {
 		page = list_first_entry(&amp;vb-&gt;pages, struct page, lru);
 		list_del(&amp;page-&gt;lru);
<span class="p_header">diff --git a/drivers/xen/xenfs/xenbus.c b/drivers/xen/xenfs/xenbus.c</span>
<span class="p_header">index bbd000f88af7..98559b05aacd 100644</span>
<span class="p_header">--- a/drivers/xen/xenfs/xenbus.c</span>
<span class="p_header">+++ b/drivers/xen/xenfs/xenbus.c</span>
<span class="p_chunk">@@ -310,11 +310,18 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 			rc = -ENOMEM;
 			goto out;
 		}
<span class="p_add">+	} else if (msg_type == XS_TRANSACTION_END) {</span>
<span class="p_add">+		list_for_each_entry(trans, &amp;u-&gt;transactions, list)</span>
<span class="p_add">+			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		if (&amp;trans-&gt;list == &amp;u-&gt;transactions)</span>
<span class="p_add">+			return -ESRCH;</span>
 	}
 
 	reply = xenbus_dev_request_and_reply(&amp;u-&gt;u.msg);
 	if (IS_ERR(reply)) {
<span class="p_del">-		kfree(trans);</span>
<span class="p_add">+		if (msg_type == XS_TRANSACTION_START)</span>
<span class="p_add">+			kfree(trans);</span>
 		rc = PTR_ERR(reply);
 		goto out;
 	}
<span class="p_chunk">@@ -324,12 +331,7 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 
 		list_add(&amp;trans-&gt;list, &amp;u-&gt;transactions);
 	} else if (msg_type == XS_TRANSACTION_END) {
<span class="p_del">-		list_for_each_entry(trans, &amp;u-&gt;transactions, list)</span>
<span class="p_del">-			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		BUG_ON(&amp;trans-&gt;list == &amp;u-&gt;transactions);</span>
 		list_del(&amp;trans-&gt;list);
<span class="p_del">-</span>
 		kfree(trans);
 	}
 
<span class="p_header">diff --git a/fs/9p/acl.c b/fs/9p/acl.c</span>
<span class="p_header">index 9a1d42630751..a4188cfcc9f9 100644</span>
<span class="p_header">--- a/fs/9p/acl.c</span>
<span class="p_header">+++ b/fs/9p/acl.c</span>
<span class="p_chunk">@@ -319,32 +319,26 @@</span> <span class="p_context"> static int v9fs_xattr_set_acl(struct dentry *dentry, const char *name,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			retval = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (retval &lt; 0)</span>
<span class="p_add">+			struct iattr iattr;</span>
<span class="p_add">+</span>
<span class="p_add">+			retval = posix_acl_update_mode(inode, &amp;iattr.ia_mode, &amp;acl);</span>
<span class="p_add">+			if (retval)</span>
 				goto err_out;
<span class="p_del">-			else {</span>
<span class="p_del">-				struct iattr iattr;</span>
<span class="p_del">-				if (retval == 0) {</span>
<span class="p_del">-					/*</span>
<span class="p_del">-					 * ACL can be represented</span>
<span class="p_del">-					 * by the mode bits. So don&#39;t</span>
<span class="p_del">-					 * update ACL.</span>
<span class="p_del">-					 */</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-					value = NULL;</span>
<span class="p_del">-					size = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				/* Updte the mode bits */</span>
<span class="p_del">-				iattr.ia_mode = ((mode &amp; S_IALLUGO) |</span>
<span class="p_del">-						 (inode-&gt;i_mode &amp; ~S_IALLUGO));</span>
<span class="p_del">-				iattr.ia_valid = ATTR_MODE;</span>
<span class="p_del">-				/* FIXME should we update ctime ?</span>
<span class="p_del">-				 * What is the following setxattr update the</span>
<span class="p_del">-				 * mode ?</span>
<span class="p_add">+			if (!acl) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * ACL can be represented</span>
<span class="p_add">+				 * by the mode bits. So don&#39;t</span>
<span class="p_add">+				 * update ACL.</span>
 				 */
<span class="p_del">-				v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
<span class="p_add">+				value = NULL;</span>
<span class="p_add">+				size = 0;</span>
 			}
<span class="p_add">+			iattr.ia_valid = ATTR_MODE;</span>
<span class="p_add">+			/* FIXME should we update ctime ?</span>
<span class="p_add">+			 * What is the following setxattr update the</span>
<span class="p_add">+			 * mode ?</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index adedfd401a30..34defa195a80 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -1068,7 +1068,7 @@</span> <span class="p_context"> static int v9fs_vfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct p9_wstat wstat;
 
 	P9_DPRINTK(P9_DEBUG_VFS, &quot;\n&quot;);
<span class="p_del">-	retval = inode_change_ok(dentry-&gt;d_inode, iattr);</span>
<span class="p_add">+	retval = setattr_prepare(dentry, iattr);</span>
 	if (retval)
 		return retval;
 
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index dbbc83f6dc3b..781e56e328eb 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -538,7 +538,7 @@</span> <span class="p_context"> int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)</span>
 
 	P9_DPRINTK(P9_DEBUG_VFS, &quot;\n&quot;);
 
<span class="p_del">-	retval = inode_change_ok(dentry-&gt;d_inode, iattr);</span>
<span class="p_add">+	retval = setattr_prepare(dentry, iattr);</span>
 	if (retval)
 		return retval;
 
<span class="p_header">diff --git a/fs/adfs/inode.c b/fs/adfs/inode.c</span>
<span class="p_header">index 1dab6a174d6a..c5e42d8c06a1 100644</span>
<span class="p_header">--- a/fs/adfs/inode.c</span>
<span class="p_header">+++ b/fs/adfs/inode.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> adfs_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 	int error;
 	
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 
 	/*
 	 * we can&#39;t change the UID or GID of any file -
<span class="p_header">diff --git a/fs/affs/inode.c b/fs/affs/inode.c</span>
<span class="p_header">index 88a4b0b50058..abda0dc63ec3 100644</span>
<span class="p_header">--- a/fs/affs/inode.c</span>
<span class="p_header">+++ b/fs/affs/inode.c</span>
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> affs_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 
 	pr_debug(&quot;AFFS: notify_change(%lu,0x%x)\n&quot;,inode-&gt;i_ino,attr-&gt;ia_valid);
 
<span class="p_del">-	error = inode_change_ok(inode,attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/attr.c b/fs/attr.c</span>
<span class="p_header">index b8f55c40fb1d..a7f0c75734c2 100644</span>
<span class="p_header">--- a/fs/attr.c</span>
<span class="p_header">+++ b/fs/attr.c</span>
<span class="p_chunk">@@ -16,19 +16,22 @@</span> <span class="p_context"></span>
 #include &lt;linux/evm.h&gt;
 
 /**
<span class="p_del">- * inode_change_ok - check if attribute changes to an inode are allowed</span>
<span class="p_del">- * @inode:	inode to check</span>
<span class="p_add">+ * setattr_prepare - check if attribute changes to a dentry are allowed</span>
<span class="p_add">+ * @dentry:	dentry to check</span>
  * @attr:	attributes to change
  *
  * Check if we are allowed to change the attributes contained in @attr
<span class="p_del">- * in the given inode.  This includes the normal unix access permission</span>
<span class="p_del">- * checks, as well as checks for rlimits and others.</span>
<span class="p_add">+ * in the given dentry.  This includes the normal unix access permission</span>
<span class="p_add">+ * checks, as well as checks for rlimits and others. The function also clears</span>
<span class="p_add">+ * SGID bit from mode if user is not allowed to set it. Also file capabilities</span>
<span class="p_add">+ * and IMA extended attributes are cleared if ATTR_KILL_PRIV is set.</span>
  *
  * Should be called as the first thing in -&gt;setattr implementations,
  * possibly after taking additional locks.
  */
<span class="p_del">-int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
<span class="p_add">+int setattr_prepare(struct dentry *dentry, struct iattr *attr)</span>
 {
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 
 	/*
<span class="p_chunk">@@ -43,7 +46,7 @@</span> <span class="p_context"> int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
 
 	/* If force is set do it anyway. */
 	if (ia_valid &amp; ATTR_FORCE)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto kill_priv;</span>
 
 	/* Make sure a caller can chown. */
 	if ((ia_valid &amp; ATTR_UID) &amp;&amp;
<span class="p_chunk">@@ -74,9 +77,19 @@</span> <span class="p_context"> int inode_change_ok(const struct inode *inode, struct iattr *attr)</span>
 			return -EPERM;
 	}
 
<span class="p_add">+kill_priv:</span>
<span class="p_add">+	/* User has permission for the change */</span>
<span class="p_add">+	if (ia_valid &amp; ATTR_KILL_PRIV) {</span>
<span class="p_add">+		int error;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = security_inode_killpriv(dentry);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
<span class="p_del">-EXPORT_SYMBOL(inode_change_ok);</span>
<span class="p_add">+EXPORT_SYMBOL(setattr_prepare);</span>
 
 /**
  * inode_newsize_ok - may this inode be truncated to a given size
<span class="p_chunk">@@ -196,13 +209,11 @@</span> <span class="p_context"> int notify_change(struct dentry * dentry, struct iattr * attr)</span>
 	if (!(ia_valid &amp; ATTR_MTIME_SET))
 		attr-&gt;ia_mtime = now;
 	if (ia_valid &amp; ATTR_KILL_PRIV) {
<span class="p_del">-		attr-&gt;ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
<span class="p_del">-		ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
 		error = security_inode_need_killpriv(dentry);
<span class="p_del">-		if (error &gt; 0)</span>
<span class="p_del">-			error = security_inode_killpriv(dentry);</span>
<span class="p_del">-		if (error)</span>
<span class="p_add">+		if (error &lt; 0)</span>
 			return error;
<span class="p_add">+		if (error == 0)</span>
<span class="p_add">+			ia_valid = attr-&gt;ia_valid &amp;= ~ATTR_KILL_PRIV;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index 89b156d85d63..9f55b545ea44 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -118,8 +118,8 @@</span> <span class="p_context"> static int btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
 		}
 		ret = 0;
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 9a7efbec8c63..d84977d16b02 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -3533,7 +3533,7 @@</span> <span class="p_context"> static int btrfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (btrfs_root_readonly(root))
 		return -EROFS;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index eb6a0e6f6ecd..360072f42afe 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1302,6 +1302,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 	int namelen;
 	int ret = 0;
 
<span class="p_add">+	if (!S_ISDIR(file-&gt;f_dentry-&gt;d_inode-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	if (root-&gt;fs_info-&gt;sb-&gt;s_flags &amp; MS_RDONLY)
 		return -EROFS;
 
<span class="p_chunk">@@ -1350,6 +1353,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create(struct file *file,</span>
 	struct btrfs_ioctl_vol_args *vol_args;
 	int ret;
 
<span class="p_add">+	if (!S_ISDIR(file-&gt;f_dentry-&gt;d_inode-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -1372,6 +1378,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_v2(struct file *file,</span>
 	u64 *ptr = NULL;
 	bool readonly = false;
 
<span class="p_add">+	if (!S_ISDIR(file-&gt;f_dentry-&gt;d_inode-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -1848,6 +1857,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 	int ret;
 	int err = 0;
 
<span class="p_add">+	if (!S_ISDIR(dir-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_header">diff --git a/fs/ceph/file.c b/fs/ceph/file.c</span>
<span class="p_header">index ed72428d9c75..3cdf137e9c5b 100644</span>
<span class="p_header">--- a/fs/ceph/file.c</span>
<span class="p_header">+++ b/fs/ceph/file.c</span>
<span class="p_chunk">@@ -793,17 +793,15 @@</span> <span class="p_context"> out:</span>
 static loff_t ceph_llseek(struct file *file, loff_t offset, int origin)
 {
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	loff_t ret;</span>
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	__ceph_do_pending_vmtruncate(inode);
 
 	if (origin == SEEK_END || origin == SEEK_DATA || origin == SEEK_HOLE) {
 		ret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE);
<span class="p_del">-		if (ret &lt; 0) {</span>
<span class="p_del">-			offset = ret;</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto out;
<span class="p_del">-		}</span>
 	}
 
 	switch (origin) {
<span class="p_chunk">@@ -818,7 +816,7 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int origin)</span>
 		 * write() or lseek() might have altered it
 		 */
 		if (offset == 0) {
<span class="p_del">-			offset = file-&gt;f_pos;</span>
<span class="p_add">+			ret = file-&gt;f_pos;</span>
 			goto out;
 		}
 		offset += file-&gt;f_pos;
<span class="p_chunk">@@ -839,7 +837,7 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int origin)</span>
 	}
 
 	if (offset &lt; 0 || offset &gt; inode-&gt;i_sb-&gt;s_maxbytes) {
<span class="p_del">-		offset = -EINVAL;</span>
<span class="p_add">+		ret = -EINVAL;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -848,10 +846,11 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int origin)</span>
 		file-&gt;f_pos = offset;
 		file-&gt;f_version = 0;
 	}
<span class="p_add">+	ret = offset;</span>
 
 out:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
<span class="p_del">-	return offset;</span>
<span class="p_add">+	return ret;</span>
 }
 
 const struct file_operations ceph_file_fops = {
<span class="p_header">diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c</span>
<span class="p_header">index 8e889b773d24..6a6c2e3f99ad 100644</span>
<span class="p_header">--- a/fs/ceph/inode.c</span>
<span class="p_header">+++ b/fs/ceph/inode.c</span>
<span class="p_chunk">@@ -1541,7 +1541,7 @@</span> <span class="p_context"> int ceph_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	__ceph_do_pending_vmtruncate(inode);
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err != 0)
 		return err;
 
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index 1dc0af7f34c0..91f66c518a54 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -1948,7 +1948,7 @@</span> <span class="p_context"> cifs_setattr_unix(struct dentry *direntry, struct iattr *attrs)</span>
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_NO_PERM)
 		attrs-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	rc = inode_change_ok(inode, attrs);</span>
<span class="p_add">+	rc = setattr_prepare(direntry, attrs);</span>
 	if (rc &lt; 0)
 		goto out;
 
<span class="p_chunk">@@ -2089,7 +2089,7 @@</span> <span class="p_context"> cifs_setattr_nounix(struct dentry *direntry, struct iattr *attrs)</span>
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_NO_PERM)
 		attrs-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	rc = inode_change_ok(inode, attrs);</span>
<span class="p_add">+	rc = setattr_prepare(direntry, attrs);</span>
 	if (rc &lt; 0) {
 		FreeXid(xid);
 		return rc;
<span class="p_header">diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c</span>
<span class="p_header">index 782569be0bb4..03935798a45e 100644</span>
<span class="p_header">--- a/fs/ecryptfs/inode.c</span>
<span class="p_header">+++ b/fs/ecryptfs/inode.c</span>
<span class="p_chunk">@@ -1026,7 +1026,7 @@</span> <span class="p_context"> static int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)</span>
 	}
 	mutex_unlock(&amp;crypt_stat-&gt;cs_mutex);
 
<span class="p_del">-	rc = inode_change_ok(inode, ia);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, ia);</span>
 	if (rc)
 		goto out;
 	if (ia-&gt;ia_valid &amp; ATTR_SIZE) {
<span class="p_header">diff --git a/fs/exofs/inode.c b/fs/exofs/inode.c</span>
<span class="p_header">index f6dbf7768ce6..b43884261c48 100644</span>
<span class="p_header">--- a/fs/exofs/inode.c</span>
<span class="p_header">+++ b/fs/exofs/inode.c</span>
<span class="p_chunk">@@ -1018,7 +1018,7 @@</span> <span class="p_context"> int exofs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	if (unlikely(error))
 		return error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (unlikely(error))
 		return error;
 
<span class="p_header">diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c</span>
<span class="p_header">index 35d6a3cfd9ff..e38a9b61af3f 100644</span>
<span class="p_header">--- a/fs/ext2/acl.c</span>
<span class="p_header">+++ b/fs/ext2/acl.c</span>
<span class="p_chunk">@@ -194,15 +194,11 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					mark_inode_dirty(inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				mark_inode_dirty(inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c</span>
<span class="p_header">index 5a45b8fef4e6..0d0f1a63b691 100644</span>
<span class="p_header">--- a/fs/ext2/inode.c</span>
<span class="p_header">+++ b/fs/ext2/inode.c</span>
<span class="p_chunk">@@ -1530,7 +1530,7 @@</span> <span class="p_context"> int ext2_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext3/acl.c b/fs/ext3/acl.c</span>
<span class="p_header">index 3091f62e55b6..880d3d64bb14 100644</span>
<span class="p_header">--- a/fs/ext3/acl.c</span>
<span class="p_header">+++ b/fs/ext3/acl.c</span>
<span class="p_chunk">@@ -199,15 +199,11 @@</span> <span class="p_context"> ext3_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT3_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					ext3_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				ext3_mark_inode_dirty(handle, inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext3/inode.c b/fs/ext3/inode.c</span>
<span class="p_header">index 71b263fbca32..ff33188d225e 100644</span>
<span class="p_header">--- a/fs/ext3/inode.c</span>
<span class="p_header">+++ b/fs/ext3/inode.c</span>
<span class="p_chunk">@@ -223,8 +223,12 @@</span> <span class="p_context"> void ext3_evict_inode (struct inode *inode)</span>
 	 *
 	 * Note that directories do not have this problem because they don&#39;t
 	 * use page cache.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The s_journal check handles the case when ext3_get_journal() fails</span>
<span class="p_add">+	 * and puts the journal inode.</span>
 	 */
 	if (inode-&gt;i_nlink &amp;&amp; ext3_should_journal_data(inode) &amp;&amp;
<span class="p_add">+	    EXT3_SB(inode-&gt;i_sb)-&gt;s_journal &amp;&amp;</span>
 	    (S_ISLNK(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode))) {
 		tid_t commit_tid = atomic_read(&amp;ei-&gt;i_datasync_tid);
 		journal_t *journal = EXT3_SB(inode-&gt;i_sb)-&gt;s_journal;
<span class="p_chunk">@@ -3271,7 +3275,7 @@</span> <span class="p_context"> int ext3_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int error, rc = 0;
 	const unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c</span>
<span class="p_header">index 8535c45dfceb..5d419a496d96 100644</span>
<span class="p_header">--- a/fs/ext4/acl.c</span>
<span class="p_header">+++ b/fs/ext4/acl.c</span>
<span class="p_chunk">@@ -198,15 +198,11 @@</span> <span class="p_context"> ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_del">-				ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_add">+			ext4_mark_inode_dirty(handle, inode);</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index e3d65abb41b3..bb40a70ed412 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -319,9 +319,13 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_fsblk_t block = ext4_ext_pblock(ext);
 	int len = ext4_ext_get_actual_len(ext);
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
<span class="p_del">-	ext4_lblk_t last = lblock + len - 1;</span>
 
<span class="p_del">-	if (len == 0 || lblock &gt; last)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We allow neither:</span>
<span class="p_add">+	 *  - zero length</span>
<span class="p_add">+	 *  - overflow/wrap-around</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (lblock + len &lt;= lblock)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 010f050a87b3..ff2e369de040 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -142,9 +142,9 @@</span> <span class="p_context"> void ext4_evict_inode(struct inode *inode)</span>
 		 * Note that directories do not have this problem because they
 		 * don&#39;t use page cache.
 		 */
<span class="p_del">-		if (ext4_should_journal_data(inode) &amp;&amp;</span>
<span class="p_del">-		    (S_ISLNK(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode)) &amp;&amp;</span>
<span class="p_del">-		    inode-&gt;i_ino != EXT4_JOURNAL_INO) {</span>
<span class="p_add">+		if (inode-&gt;i_ino != EXT4_JOURNAL_INO &amp;&amp;</span>
<span class="p_add">+		    ext4_should_journal_data(inode) &amp;&amp;</span>
<span class="p_add">+		    (S_ISLNK(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode))) {</span>
 			journal_t *journal = EXT4_SB(inode-&gt;i_sb)-&gt;s_journal;
 			tid_t commit_tid = EXT4_I(inode)-&gt;i_datasync_tid;
 
<span class="p_chunk">@@ -4291,7 +4291,7 @@</span> <span class="p_context"> int ext4_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int orphan = 0;
 	const unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 7c03826bde26..242fe11aea20 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -2824,7 +2824,7 @@</span> <span class="p_context"> ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,</span>
 		ext4_error(sb, &quot;Allocating blocks %llu-%llu which overlap &quot;
 			   &quot;fs metadata\n&quot;, block, block+len);
 		/* File system mounted not to panic on error
<span class="p_del">-		 * Fix the bitmap and repeat the block allocation</span>
<span class="p_add">+		 * Fix the bitmap and return EIO</span>
 		 * We leak some of the blocks here.
 		 */
 		ext4_lock_group(sb, ac-&gt;ac_b_ex.fe_group);
<span class="p_chunk">@@ -2833,7 +2833,7 @@</span> <span class="p_context"> ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,</span>
 		ext4_unlock_group(sb, ac-&gt;ac_b_ex.fe_group);
 		err = ext4_handle_dirty_metadata(handle, NULL, bitmap_bh);
 		if (!err)
<span class="p_del">-			err = -EAGAIN;</span>
<span class="p_add">+			err = -EIO;</span>
 		goto out_err;
 	}
 
<span class="p_chunk">@@ -4401,18 +4401,7 @@</span> <span class="p_context"> repeat:</span>
 	}
 	if (likely(ac-&gt;ac_status == AC_STATUS_FOUND)) {
 		*errp = ext4_mb_mark_diskspace_used(ac, handle, reserv_clstrs);
<span class="p_del">-		if (*errp == -EAGAIN) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * drop the reference that we took</span>
<span class="p_del">-			 * in ext4_mb_use_best_found</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			ext4_mb_release_context(ac);</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_group = 0;</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_start = 0;</span>
<span class="p_del">-			ac-&gt;ac_b_ex.fe_len = 0;</span>
<span class="p_del">-			ac-&gt;ac_status = AC_STATUS_CONTINUE;</span>
<span class="p_del">-			goto repeat;</span>
<span class="p_del">-		} else if (*errp)</span>
<span class="p_add">+		if (*errp)</span>
 		errout:
 			ext4_discard_allocated_blocks(ac);
 		else {
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 52b8ac740201..7266a2e5befc 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -2097,6 +2097,7 @@</span> <span class="p_context"> int ext4_group_desc_csum_verify(struct ext4_sb_info *sbi, __u32 block_group,</span>
 
 /* Called at mount-time, super-block is locked */
 static int ext4_check_descriptors(struct super_block *sb,
<span class="p_add">+				  ext4_fsblk_t sb_block,</span>
 				  ext4_group_t *first_not_zeroed)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
<span class="p_chunk">@@ -2127,6 +2128,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			grp = i;
 
 		block_bitmap = ext4_block_bitmap(sb, gdp);
<span class="p_add">+		if (block_bitmap == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Block bitmap for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (block_bitmap &lt; first_block || block_bitmap &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
 			       &quot;Block bitmap for group %u not in group &quot;
<span class="p_chunk">@@ -2134,6 +2140,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			return 0;
 		}
 		inode_bitmap = ext4_inode_bitmap(sb, gdp);
<span class="p_add">+		if (inode_bitmap == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Inode bitmap for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (inode_bitmap &lt; first_block || inode_bitmap &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
 			       &quot;Inode bitmap for group %u not in group &quot;
<span class="p_chunk">@@ -2141,6 +2152,11 @@</span> <span class="p_context"> static int ext4_check_descriptors(struct super_block *sb,</span>
 			return 0;
 		}
 		inode_table = ext4_inode_table(sb, gdp);
<span class="p_add">+		if (inode_table == sb_block) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;</span>
<span class="p_add">+				 &quot;Inode table for group %u overlaps &quot;</span>
<span class="p_add">+				 &quot;superblock&quot;, i);</span>
<span class="p_add">+		}</span>
 		if (inode_table &lt; first_block ||
 		    inode_table + sbi-&gt;s_itb_per_group - 1 &gt; last_block) {
 			ext4_msg(sb, KERN_ERR, &quot;ext4_check_descriptors: &quot;
<span class="p_chunk">@@ -2246,6 +2262,16 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 	while (es-&gt;s_last_orphan) {
 		struct inode *inode;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We may have encountered an error during cleanup; if</span>
<span class="p_add">+		 * so, skip the rest.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (EXT4_SB(sb)-&gt;s_mount_state &amp; EXT4_ERROR_FS) {</span>
<span class="p_add">+			jbd_debug(1, &quot;Skipping orphan recovery on fs with errors.\n&quot;);</span>
<span class="p_add">+			es-&gt;s_last_orphan = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		inode = ext4_orphan_get(sb, le32_to_cpu(es-&gt;s_last_orphan));
 		if (IS_ERR(inode)) {
 			es-&gt;s_last_orphan = 0;
<span class="p_chunk">@@ -3429,6 +3455,13 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto failed_mount;
 	}
 
<span class="p_add">+	if (le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks) &gt; (blocksize / 4)) {</span>
<span class="p_add">+		ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+			 &quot;Number of reserved GDT blocks insanely large: %d&quot;,</span>
<span class="p_add">+			 le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks));</span>
<span class="p_add">+		goto failed_mount;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (sb-&gt;s_blocksize != blocksize) {
 		/* Validate the filesystem blocksize */
 		if (!sb_set_blocksize(sb, blocksize)) {
<span class="p_chunk">@@ -3657,7 +3690,7 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 			goto failed_mount2;
 		}
 	}
<span class="p_del">-	if (!ext4_check_descriptors(sb, &amp;first_not_zeroed)) {</span>
<span class="p_add">+	if (!ext4_check_descriptors(sb, logical_sb_block, &amp;first_not_zeroed)) {</span>
 		ext4_msg(sb, KERN_ERR, &quot;group descriptors corrupted!&quot;);
 		goto failed_mount2;
 	}
<span class="p_header">diff --git a/fs/fat/file.c b/fs/fat/file.c</span>
<span class="p_header">index c118acf16e43..ef4753ee220d 100644</span>
<span class="p_header">--- a/fs/fat/file.c</span>
<span class="p_header">+++ b/fs/fat/file.c</span>
<span class="p_chunk">@@ -382,7 +382,7 @@</span> <span class="p_context"> int fat_setattr(struct dentry *dentry, struct iattr *attr)</span>
 			attr-&gt;ia_valid &amp;= ~TIMES_SET_FLAGS;
 	}
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	attr-&gt;ia_valid = ia_valid;
 	if (error) {
 		if (sbi-&gt;options.quiet)
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index e13558ca4b09..15c1d2948f4a 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1298,7 +1298,7 @@</span> <span class="p_context"> static int fuse_do_setattr(struct dentry *entry, struct iattr *attr,</span>
 	if (!(fc-&gt;flags &amp; FUSE_DEFAULT_PERMISSIONS))
 		attr-&gt;ia_valid |= ATTR_FORCE;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(entry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/generic_acl.c b/fs/generic_acl.c</span>
<span class="p_header">index d0dddaceac59..a3f3e70f9750 100644</span>
<span class="p_header">--- a/fs/generic_acl.c</span>
<span class="p_header">+++ b/fs/generic_acl.c</span>
<span class="p_chunk">@@ -86,16 +86,17 @@</span> <span class="p_context"> generic_acl_set(struct dentry *dentry, const char *name, const void *value,</span>
 		if (error)
 			goto failed;
 		switch (type) {
<span class="p_del">-		case ACL_TYPE_ACCESS:</span>
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+		case ACL_TYPE_ACCESS: {</span>
<span class="p_add">+			struct posix_acl *saved_acl = acl;</span>
<span class="p_add">+</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (acl == NULL)</span>
<span class="p_add">+				posix_acl_release(saved_acl);</span>
<span class="p_add">+			if (error)</span>
 				goto failed;
 			inode-&gt;i_ctime = CURRENT_TIME;
<span class="p_del">-			if (error == 0) {</span>
<span class="p_del">-				posix_acl_release(acl);</span>
<span class="p_del">-				acl = NULL;</span>
<span class="p_del">-			}</span>
 			break;
<span class="p_add">+		}</span>
 		case ACL_TYPE_DEFAULT:
 			if (!S_ISDIR(inode-&gt;i_mode)) {
 				error = -EINVAL;
<span class="p_header">diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c</span>
<span class="p_header">index 65978d7885c8..75f6085da350 100644</span>
<span class="p_header">--- a/fs/gfs2/acl.c</span>
<span class="p_header">+++ b/fs/gfs2/acl.c</span>
<span class="p_chunk">@@ -277,16 +277,14 @@</span> <span class="p_context"> static int gfs2_xattr_system_set(struct dentry *dentry, const char *name,</span>
 		goto out_release;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_add">+		struct posix_acl *saved_acl = acl;</span>
<span class="p_add">+		umode_t mode;</span>
 
<span class="p_del">-		if (error &lt;= 0) {</span>
<span class="p_del">-			posix_acl_release(acl);</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error || acl == NULL)</span>
<span class="p_add">+			posix_acl_release(saved_acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 
 		error = gfs2_set_mode(inode, mode);
 		if (error)
<span class="p_header">diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c</span>
<span class="p_header">index cfd4959b218c..d4f83804b008 100644</span>
<span class="p_header">--- a/fs/gfs2/inode.c</span>
<span class="p_header">+++ b/fs/gfs2/inode.c</span>
<span class="p_chunk">@@ -1646,7 +1646,7 @@</span> <span class="p_context"> static int gfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/hfs/inode.c b/fs/hfs/inode.c</span>
<span class="p_header">index a1a9fdcd2a00..532d6cb2dca8 100644</span>
<span class="p_header">--- a/fs/hfs/inode.c</span>
<span class="p_header">+++ b/fs/hfs/inode.c</span>
<span class="p_chunk">@@ -588,7 +588,7 @@</span> <span class="p_context"> int hfs_inode_setattr(struct dentry *dentry, struct iattr * attr)</span>
 	struct hfs_sb_info *hsb = HFS_SB(inode-&gt;i_sb);
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr); /* basic permission checks */</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr); /* basic permission checks */</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/hfsplus/inode.c b/fs/hfsplus/inode.c</span>
<span class="p_header">index 40e1413be4cf..63a252428370 100644</span>
<span class="p_header">--- a/fs/hfsplus/inode.c</span>
<span class="p_header">+++ b/fs/hfsplus/inode.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> static int hfsplus_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 8db3979cdba6..3f3b1bd7d751 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -792,7 +792,7 @@</span> <span class="p_context"> int hostfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	int fd = HOSTFS_I(inode)-&gt;fd;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -955,10 +955,11 @@</span> <span class="p_context"> static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)</span>
 
 	if (S_ISLNK(root_inode-&gt;i_mode)) {
 		char *name = follow_link(host_root_path);
<span class="p_del">-		if (IS_ERR(name))</span>
<span class="p_add">+		if (IS_ERR(name)) {</span>
 			err = PTR_ERR(name);
<span class="p_del">-		else</span>
<span class="p_del">-			err = read_name(root_inode, name);</span>
<span class="p_add">+			goto out_put;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = read_name(root_inode, name);</span>
 		kfree(name);
 		if (err)
 			goto out_put;
<span class="p_header">diff --git a/fs/hpfs/inode.c b/fs/hpfs/inode.c</span>
<span class="p_header">index 3b2cec29972b..00fc9434501a 100644</span>
<span class="p_header">--- a/fs/hpfs/inode.c</span>
<span class="p_header">+++ b/fs/hpfs/inode.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> int hpfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if ((attr-&gt;ia_valid &amp; ATTR_SIZE) &amp;&amp; attr-&gt;ia_size &gt; inode-&gt;i_size)
 		goto out_unlock;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		goto out_unlock;
 
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index ebab116b0779..55573322d1bb 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> static int hugetlbfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	BUG_ON(!inode);
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/jffs2/acl.c b/fs/jffs2/acl.c</span>
<span class="p_header">index 926d02068a14..d963e55f98fb 100644</span>
<span class="p_header">--- a/fs/jffs2/acl.c</span>
<span class="p_header">+++ b/fs/jffs2/acl.c</span>
<span class="p_chunk">@@ -227,9 +227,10 @@</span> <span class="p_context"> static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			if (inode-&gt;i_mode != mode) {
 				struct iattr attr;
<span class="p_chunk">@@ -241,8 +242,6 @@</span> <span class="p_context"> static int jffs2_set_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
 				if (rc &lt; 0)
 					return rc;
 			}
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/jffs2/fs.c b/fs/jffs2/fs.c</span>
<span class="p_header">index 4b8afe39a87f..73652b2093b4 100644</span>
<span class="p_header">--- a/fs/jffs2/fs.c</span>
<span class="p_header">+++ b/fs/jffs2/fs.c</span>
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> int jffs2_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 {
 	int rc;
 
<span class="p_del">-	rc = inode_change_ok(dentry-&gt;d_inode, iattr);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, iattr);</span>
 	if (rc)
 		return rc;
 
<span class="p_header">diff --git a/fs/jfs/file.c b/fs/jfs/file.c</span>
<span class="p_header">index 844f9460cb11..5ab3a0c214b5 100644</span>
<span class="p_header">--- a/fs/jfs/file.c</span>
<span class="p_header">+++ b/fs/jfs/file.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> int jfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int rc;
 
<span class="p_del">-	rc = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	rc = setattr_prepare(dentry, iattr);</span>
 	if (rc)
 		return rc;
 
<span class="p_header">diff --git a/fs/jfs/xattr.c b/fs/jfs/xattr.c</span>
<span class="p_header">index 26683e15b3ac..1078c9382429 100644</span>
<span class="p_header">--- a/fs/jfs/xattr.c</span>
<span class="p_header">+++ b/fs/jfs/xattr.c</span>
<span class="p_chunk">@@ -693,9 +693,11 @@</span> <span class="p_context"> static int can_set_system_xattr(struct inode *inode, const char *name,</span>
 			return rc;
 		}
 		if (acl) {
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_add">+			struct posix_acl *dummy = acl;</span>
<span class="p_add">+</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;dummy);</span>
 			posix_acl_release(acl);
<span class="p_del">-			if (rc &lt; 0) {</span>
<span class="p_add">+			if (rc) {</span>
 				printk(KERN_ERR
 				       &quot;posix_acl_equiv_mode returned %d\n&quot;,
 				       rc);
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index ce85edf8aca5..d2f43c9068d2 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> int simple_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 
 	WARN_ON_ONCE(inode-&gt;i_op-&gt;truncate);
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/logfs/file.c b/fs/logfs/file.c</span>
<span class="p_header">index b548c87a86f1..562bbc62bec2 100644</span>
<span class="p_header">--- a/fs/logfs/file.c</span>
<span class="p_header">+++ b/fs/logfs/file.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> static int logfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int err = 0;
 
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/minix/file.c b/fs/minix/file.c</span>
<span class="p_header">index 4493ce695ab8..d23e13cbfb0c 100644</span>
<span class="p_header">--- a/fs/minix/file.c</span>
<span class="p_header">+++ b/fs/minix/file.c</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> static int minix_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ncpfs/inode.c b/fs/ncpfs/inode.c</span>
<span class="p_header">index cbd1a61c110a..dce88e9399a4 100644</span>
<span class="p_header">--- a/fs/ncpfs/inode.c</span>
<span class="p_header">+++ b/fs/ncpfs/inode.c</span>
<span class="p_chunk">@@ -880,7 +880,7 @@</span> <span class="p_context"> int ncp_notify_change(struct dentry *dentry, struct iattr *attr)</span>
 	/* ageing the dentry to force validation */
 	ncp_age_dentry(server, dentry);
 
<span class="p_del">-	result = inode_change_ok(inode, attr);</span>
<span class="p_add">+	result = setattr_prepare(dentry, attr);</span>
 	if (result &lt; 0)
 		goto out;
 
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index 6d22d356937b..9839726fe40c 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -878,7 +878,7 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	if (hdr_arg.minorversion == 0) {
 		cps.clp = nfs4_find_client_ident(hdr_arg.cb_ident);
 		if (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))
<span class="p_del">-			return rpc_drop_reply;</span>
<span class="p_add">+			goto out_invalidcred;</span>
 	}
 
 	hdr_res.taglen = hdr_arg.taglen;
<span class="p_chunk">@@ -905,6 +905,10 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	nfs_put_client(cps.clp);
 	dprintk(&quot;%s: done, status = %u\n&quot;, __func__, ntohl(status));
 	return rpc_success;
<span class="p_add">+</span>
<span class="p_add">+out_invalidcred:</span>
<span class="p_add">+	pr_warn_ratelimited(&quot;NFS: NFSv4 callback contains invalid cred\n&quot;);</span>
<span class="p_add">+	return rpc_autherr_badcred;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 9fc799828ea7..0ba9bf7704d1 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -5360,14 +5360,21 @@</span> <span class="p_context"> static int _nfs4_proc_create_session(struct nfs_client *clp)</span>
 
 	status = rpc_call_sync(session-&gt;clp-&gt;cl_rpcclient, &amp;msg, RPC_TASK_TIMEOUT);
 
<span class="p_add">+	switch (status) {</span>
<span class="p_add">+	case -NFS4ERR_STALE_CLIENTID:</span>
<span class="p_add">+	case -NFS4ERR_DELAY:</span>
<span class="p_add">+	case -ETIMEDOUT:</span>
<span class="p_add">+	case -EACCES:</span>
<span class="p_add">+	case -EAGAIN:</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	clp-&gt;cl_seqid++;</span>
 	if (!status)
 		/* Verify the session&#39;s negotiated channel_attrs values */
 		status = nfs4_verify_channel_attrs(&amp;args, session);
<span class="p_del">-	if (!status) {</span>
<span class="p_del">-		/* Increment the clientid slot sequence id */</span>
<span class="p_del">-		clp-&gt;cl_seqid++;</span>
<span class="p_del">-	}</span>
 
<span class="p_add">+out:</span>
 	return status;
 }
 
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index 301391a0bffc..fccc545d1292 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -747,6 +747,9 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		file-&gt;f_path.dentry-&gt;d_name.name, count,
 		(long long)(page_offset(page) + offset));
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	/* If we&#39;re not using byte range locks, and we know the page
 	 * is up to date, it may be more efficient to extend the write
 	 * to cover the entire page in order to avoid fragmentation
<span class="p_chunk">@@ -764,7 +767,7 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		nfs_set_pageerror(page);
 	else
 		__set_page_dirty_nobuffers(page);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	dprintk(&quot;NFS:       nfs_updatepage returns %d (isize %lld)\n&quot;,
 			status, (long long)i_size_read(inode));
 	return status;
<span class="p_header">diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c</span>
<span class="p_header">index e2e7914aff3b..855e3f80e4e1 100644</span>
<span class="p_header">--- a/fs/nfsd/vfs.c</span>
<span class="p_header">+++ b/fs/nfsd/vfs.c</span>
<span class="p_chunk">@@ -301,17 +301,19 @@</span> <span class="p_context"> commit_metadata(struct svc_fh *fhp)</span>
  * NFS semantics and what Linux expects.
  */
 static void
<span class="p_del">-nfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)</span>
<span class="p_add">+nfsd_sanitize_attrs(struct dentry *dentry, struct iattr *iap)</span>
 {
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+</span>
 	/*
 	 * NFSv2 does not differentiate between &quot;set-[ac]time-to-now&quot;
 	 * which only requires access, and &quot;set-[ac]time-to-X&quot; which
 	 * requires ownership.
 	 * So if it looks like it might be &quot;set both to the same time which
<span class="p_del">-	 * is close to now&quot;, and if inode_change_ok fails, then we</span>
<span class="p_add">+	 * is close to now&quot;, and if setattr_prepare fails, then we</span>
 	 * convert to &quot;set to now&quot; instead of &quot;set to explicit time&quot;
 	 *
<span class="p_del">-	 * We only call inode_change_ok as the last test as technically</span>
<span class="p_add">+	 * We only call setattr_prepare as the last test as technically</span>
 	 * it is not an interface that we should be using.
 	 */
 #define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)
<span class="p_chunk">@@ -329,7 +331,7 @@</span> <span class="p_context"> nfsd_sanitize_attrs(struct inode *inode, struct iattr *iap)</span>
 		if (delta &lt; 0)
 			delta = -delta;
 		if (delta &lt; MAX_TOUCH_TIME_ERROR &amp;&amp;
<span class="p_del">-		    inode_change_ok(inode, iap) != 0) {</span>
<span class="p_add">+		    setattr_prepare(dentry, iap) != 0) {</span>
 			/*
 			 * Turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME.
 			 * This will cause notify_change to set these times
<span class="p_chunk">@@ -437,7 +439,7 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 	if (!iap-&gt;ia_valid)
 		goto out;
 
<span class="p_del">-	nfsd_sanitize_attrs(inode, iap);</span>
<span class="p_add">+	nfsd_sanitize_attrs(dentry, iap);</span>
 
 	/*
 	 * The size case is special, it changes the file in addition to the
<span class="p_header">diff --git a/fs/nilfs2/inode.c b/fs/nilfs2/inode.c</span>
<span class="p_header">index b2d8a967d1d6..3a708189e7a9 100644</span>
<span class="p_header">--- a/fs/nilfs2/inode.c</span>
<span class="p_header">+++ b/fs/nilfs2/inode.c</span>
<span class="p_chunk">@@ -792,7 +792,7 @@</span> <span class="p_context"> int nilfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 	struct super_block *sb = inode-&gt;i_sb;
 	int err;
 
<span class="p_del">-	err = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, iattr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/ntfs/inode.c b/fs/ntfs/inode.c</span>
<span class="p_header">index 97e2dacbc867..c84f026c79ab 100644</span>
<span class="p_header">--- a/fs/ntfs/inode.c</span>
<span class="p_header">+++ b/fs/ntfs/inode.c</span>
<span class="p_chunk">@@ -2890,7 +2890,7 @@</span> <span class="p_context"> int ntfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int err;
 	unsigned int ia_valid = attr-&gt;ia_valid;
 
<span class="p_del">-	err = inode_change_ok(vi, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		goto out;
 	/* We do not support NTFS ACLs yet. */
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index a7219075b4de..7e6e1f826358 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -247,14 +247,11 @@</span> <span class="p_context"> static int ocfs2_set_acl(handle_t *handle,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
 			else {
<span class="p_del">-				if (ret == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-</span>
 				ret = ocfs2_acl_set_mode(inode, di_bh,
 							 handle, mode);
 				if (ret)
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">index f65bdcf61526..6d97883e2652 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_chunk">@@ -265,7 +265,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
<span class="p_del">-	u8 old_owner = res-&gt;owner;</span>
 
 	mlog(0, &quot;type=%d, convert_type=%d, busy=%d\n&quot;, lock-&gt;ml.type,
 	     lock-&gt;ml.convert_type, res-&gt;state &amp; DLM_LOCK_RES_IN_PROGRESS);
<span class="p_chunk">@@ -332,7 +331,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 
 	spin_lock(&amp;res-&gt;spinlock);
 	res-&gt;state &amp;= ~DLM_LOCK_RES_IN_PROGRESS;
<span class="p_del">-	lock-&gt;convert_pending = 0;</span>
 	/* if it failed, move it back to granted queue.
 	 * if master returns DLM_NORMAL and then down before sending ast,
 	 * it may have already been moved to granted queue, reset to
<span class="p_chunk">@@ -341,12 +339,14 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
<span class="p_del">-	} else if ((res-&gt;state &amp; DLM_LOCK_RES_RECOVERING) ||</span>
<span class="p_del">-			(old_owner != res-&gt;owner)) {</span>
<span class="p_del">-		mlog(0, &quot;res %.*s is in recovering or has been recovered.\n&quot;,</span>
<span class="p_del">-				res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="p_add">+	} else if (!lock-&gt;convert_pending) {</span>
<span class="p_add">+		mlog(0, &quot;%s: res %.*s, owner died and lock has been moved back &quot;</span>
<span class="p_add">+				&quot;to granted list, retry convert.\n&quot;,</span>
<span class="p_add">+				dlm-&gt;name, res-&gt;lockname.len, res-&gt;lockname.name);</span>
 		status = DLM_RECOVERING;
 	}
<span class="p_add">+</span>
<span class="p_add">+	lock-&gt;convert_pending = 0;</span>
 bail:
 	spin_unlock(&amp;res-&gt;spinlock);
 
<span class="p_header">diff --git a/fs/ocfs2/dlmfs/dlmfs.c b/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_header">index b42076797049..d0ab0bfd1efa 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmfs/dlmfs.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static int dlmfs_file_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 
 	attr-&gt;ia_valid &amp;= ~ATTR_SIZE;
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 6a7a3d9a56b8..a678e2287f52 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1127,7 +1127,7 @@</span> <span class="p_context"> int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (!(attr-&gt;ia_valid &amp; OCFS2_VALID_ATTRS))
 		return 0;
 
<span class="p_del">-	status = inode_change_ok(inode, attr);</span>
<span class="p_add">+	status = setattr_prepare(dentry, attr);</span>
 	if (status)
 		return status;
 
<span class="p_chunk">@@ -1518,7 +1518,8 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 				       u64 start, u64 len)
 {
 	int ret = 0;
<span class="p_del">-	u64 tmpend, end = start + len;</span>
<span class="p_add">+	u64 tmpend = 0;</span>
<span class="p_add">+	u64 end = start + len;</span>
 	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);
 	unsigned int csize = osb-&gt;s_clustersize;
 	handle_t *handle;
<span class="p_chunk">@@ -1550,18 +1551,31 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 	}
 
 	/*
<span class="p_del">-	 * We want to get the byte offset of the end of the 1st cluster.</span>
<span class="p_add">+	 * If start is on a cluster boundary and end is somewhere in another</span>
<span class="p_add">+	 * cluster, we have not COWed the cluster starting at start, unless</span>
<span class="p_add">+	 * end is also within the same cluster. So, in this case, we skip this</span>
<span class="p_add">+	 * first call to ocfs2_zero_range_for_truncate() truncate and move on</span>
<span class="p_add">+	 * to the next one.</span>
 	 */
<span class="p_del">-	tmpend = (u64)osb-&gt;s_clustersize + (start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_del">-	if (tmpend &gt; end)</span>
<span class="p_del">-		tmpend = end;</span>
<span class="p_add">+	if ((start &amp; (csize - 1)) != 0) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We want to get the byte offset of the end of the 1st</span>
<span class="p_add">+		 * cluster.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmpend = (u64)osb-&gt;s_clustersize +</span>
<span class="p_add">+			(start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_add">+		if (tmpend &gt; end)</span>
<span class="p_add">+			tmpend = end;</span>
 
<span class="p_del">-	trace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,</span>
<span class="p_del">-						 (unsigned long long)tmpend);</span>
<span class="p_add">+		trace_ocfs2_zero_partial_clusters_range1(</span>
<span class="p_add">+			(unsigned long long)start,</span>
<span class="p_add">+			(unsigned long long)tmpend);</span>
 
<span class="p_del">-	ret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		mlog_errno(ret);</span>
<span class="p_add">+		ret = ocfs2_zero_range_for_truncate(inode, handle, start,</span>
<span class="p_add">+						    tmpend);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			mlog_errno(ret);</span>
<span class="p_add">+	}</span>
 
 	if (tmpend &lt; end) {
 		/*
<span class="p_header">diff --git a/fs/omfs/file.c b/fs/omfs/file.c</span>
<span class="p_header">index 2c6d95257a4d..26972e74b9aa 100644</span>
<span class="p_header">--- a/fs/omfs/file.c</span>
<span class="p_header">+++ b/fs/omfs/file.c</span>
<span class="p_chunk">@@ -345,7 +345,7 @@</span> <span class="p_context"> static int omfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index 6c70ab22a3e3..0ff20797e162 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -341,6 +341,36 @@</span> <span class="p_context"> static int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)</span>
         return not_equiv;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * posix_acl_update_mode  -  update mode in set_acl</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update the file mode when setting an ACL: compute the new file permission</span>
<span class="p_add">+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new</span>
<span class="p_add">+ * file mode, set *acl to NULL to indicate that no ACL should be set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As with chmod, clear the setgit bit if the caller is not in the owning group</span>
<span class="p_add">+ * or capable of CAP_FSETID (see inode_change_ok).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called from set_acl inode operations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,</span>
<span class="p_add">+			  struct posix_acl **acl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = posix_acl_equiv_mode(*acl, &amp;mode);</span>
<span class="p_add">+	if (error &lt; 0)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (error == 0)</span>
<span class="p_add">+		*acl = NULL;</span>
<span class="p_add">+	if (!in_group_p(inode-&gt;i_gid) &amp;&amp; !capable(CAP_FSETID))</span>
<span class="p_add">+		mode &amp;= ~S_ISGID;</span>
<span class="p_add">+	*mode_p = mode;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(posix_acl_update_mode);</span>
<span class="p_add">+</span>
 /*
  * Modify the ACL for the chmod syscall.
  */
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 402976ab746a..2c38a3e4fa51 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -558,7 +558,7 @@</span> <span class="p_context"> int proc_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (attr-&gt;ia_valid &amp; ATTR_MODE)
 		return -EPERM;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/proc/generic.c b/fs/proc/generic.c</span>
<span class="p_header">index 10090d9c7ad5..d0d6bb6e62c8 100644</span>
<span class="p_header">--- a/fs/proc/generic.c</span>
<span class="p_header">+++ b/fs/proc/generic.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)</span>
 	struct proc_dir_entry *de = PDE(inode);
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index 0be1aa46d9d1..ec205953fd58 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -387,7 +387,7 @@</span> <span class="p_context"> static int proc_sys_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	if (attr-&gt;ia_valid &amp; (ATTR_MODE | ATTR_UID | ATTR_GID))
 		return -EPERM;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ramfs/file-nommu.c b/fs/ramfs/file-nommu.c</span>
<span class="p_header">index d5378d028589..b79c545340a7 100644</span>
<span class="p_header">--- a/fs/ramfs/file-nommu.c</span>
<span class="p_header">+++ b/fs/ramfs/file-nommu.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int ramfs_nommu_setattr(struct dentry *dentry, struct iattr *ia)</span>
 	int ret = 0;
 
 	/* POSIX UID/GID verification for setting inode attributes */
<span class="p_del">-	ret = inode_change_ok(inode, ia);</span>
<span class="p_add">+	ret = setattr_prepare(dentry, ia);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/fs/reiserfs/inode.c b/fs/reiserfs/inode.c</span>
<span class="p_header">index fcb07e5a5159..ff10dda73bb5 100644</span>
<span class="p_header">--- a/fs/reiserfs/inode.c</span>
<span class="p_header">+++ b/fs/reiserfs/inode.c</span>
<span class="p_chunk">@@ -3107,7 +3107,7 @@</span> <span class="p_context"> int reiserfs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int depth;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">index 6da0396e5052..1d4f4c74d2c3 100644</span>
<span class="p_header">--- a/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">+++ b/fs/reiserfs/xattr_acl.c</span>
<span class="p_chunk">@@ -272,13 +272,9 @@</span> <span class="p_context"> reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index dba43c3ea3af..253a33b8c57a 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -184,8 +184,10 @@</span> <span class="p_context"> ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span>
 		size -= n;
 		buf += n;
 		copied += n;
<span class="p_del">-		if (!m-&gt;count)</span>
<span class="p_add">+		if (!m-&gt;count) {</span>
<span class="p_add">+			m-&gt;from = 0;</span>
 			m-&gt;index++;
<span class="p_add">+		}</span>
 		if (!size)
 			goto Done;
 	}
<span class="p_header">diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c</span>
<span class="p_header">index 9db61a41c1ad..6f54e62f464e 100644</span>
<span class="p_header">--- a/fs/sysfs/inode.c</span>
<span class="p_header">+++ b/fs/sysfs/inode.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> int sysfs_setattr(struct dentry *dentry, struct iattr *iattr)</span>
 		return -EINVAL;
 
 	mutex_lock(&amp;sysfs_mutex);
<span class="p_del">-	error = inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, iattr);</span>
 	if (error)
 		goto out;
 
<span class="p_header">diff --git a/fs/sysv/file.c b/fs/sysv/file.c</span>
<span class="p_header">index 0a65939508e9..e48fe258479f 100644</span>
<span class="p_header">--- a/fs/sysv/file.c</span>
<span class="p_header">+++ b/fs/sysv/file.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int sysv_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ubifs/file.c b/fs/ubifs/file.c</span>
<span class="p_header">index 9df621795ed2..3cc9067b714e 100644</span>
<span class="p_header">--- a/fs/ubifs/file.c</span>
<span class="p_header">+++ b/fs/ubifs/file.c</span>
<span class="p_chunk">@@ -1260,7 +1260,7 @@</span> <span class="p_context"> int ubifs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 
 	dbg_gen(&quot;ino %lu, mode %#x, ia_valid %#x&quot;,
 		inode-&gt;i_ino, inode-&gt;i_mode, attr-&gt;ia_valid);
<span class="p_del">-	err = inode_change_ok(inode, attr);</span>
<span class="p_add">+	err = setattr_prepare(dentry, attr);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/fs/ubifs/tnc_commit.c b/fs/ubifs/tnc_commit.c</span>
<span class="p_header">index 4c15f07a8bb2..ff108db16b75 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc_commit.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc_commit.c</span>
<span class="p_chunk">@@ -373,7 +373,7 @@</span> <span class="p_context"> static int layout_in_gaps(struct ubifs_info *c, int cnt)</span>
 
 	p = c-&gt;gap_lebs;
 	do {
<span class="p_del">-		ubifs_assert(p &lt; c-&gt;gap_lebs + sizeof(int) * c-&gt;lst.idx_lebs);</span>
<span class="p_add">+		ubifs_assert(p &lt; c-&gt;gap_lebs + c-&gt;lst.idx_lebs);</span>
 		written = layout_leb_in_gaps(c, p);
 		if (written &lt; 0) {
 			err = written;
<span class="p_header">diff --git a/fs/udf/file.c b/fs/udf/file.c</span>
<span class="p_header">index 874c9e3c0686..26f9b5206a78 100644</span>
<span class="p_header">--- a/fs/udf/file.c</span>
<span class="p_header">+++ b/fs/udf/file.c</span>
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"> static int udf_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/ufs/truncate.c b/fs/ufs/truncate.c</span>
<span class="p_header">index f04f89fbd4d9..92cde998aead 100644</span>
<span class="p_header">--- a/fs/ufs/truncate.c</span>
<span class="p_header">+++ b/fs/ufs/truncate.c</span>
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> int ufs_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	unsigned int ia_valid = attr-&gt;ia_valid;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/fs/utimes.c b/fs/utimes.c</span>
<span class="p_header">index ba653f3dc1bc..cc428b21d789 100644</span>
<span class="p_header">--- a/fs/utimes.c</span>
<span class="p_header">+++ b/fs/utimes.c</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> static int utimes_common(struct path *path, struct timespec *times)</span>
 			newattrs.ia_valid |= ATTR_MTIME_SET;
 		}
 		/*
<span class="p_del">-		 * Tell inode_change_ok(), that this is an explicit time</span>
<span class="p_add">+		 * Tell setattr_prepare(), that this is an explicit time</span>
 		 * update, even if neither ATTR_ATIME_SET nor ATTR_MTIME_SET
 		 * were used.
 		 */
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int utimes_common(struct path *path, struct timespec *times)</span>
 		/*
 		 * If times is NULL (or both times are UTIME_NOW),
 		 * then we need to check permissions, because
<span class="p_del">-		 * inode_change_ok() won&#39;t do it.</span>
<span class="p_add">+		 * setattr_prepare() won&#39;t do it.</span>
 		 */
 		error = -EACCES;
                 if (IS_IMMUTABLE(inode))
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index ac702a6eab9b..ebed5a825a58 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -223,7 +223,7 @@</span> <span class="p_context"> xfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)</span>
 }
 
 static int
<span class="p_del">-xfs_set_mode(struct inode *inode, umode_t mode)</span>
<span class="p_add">+xfs_set_mode(struct dentry *dentry, struct inode *inode, umode_t mode)</span>
 {
 	int error = 0;
 
<span class="p_chunk">@@ -234,7 +234,8 @@</span> <span class="p_context"> xfs_set_mode(struct inode *inode, umode_t mode)</span>
 		iattr.ia_mode = mode;
 		iattr.ia_ctime = current_fs_time(inode-&gt;i_sb);
 
<span class="p_del">-		error = -xfs_setattr_nonsize(XFS_I(inode), &amp;iattr, XFS_ATTR_NOACL);</span>
<span class="p_add">+		error = -xfs_setattr_nonsize(dentry, XFS_I(inode), &amp;iattr,</span>
<span class="p_add">+					     XFS_ATTR_NOACL);</span>
 	}
 
 	return error;
<span class="p_chunk">@@ -290,7 +291,7 @@</span> <span class="p_context"> xfs_inherit_acl(struct inode *inode, struct posix_acl *acl)</span>
 	if (error &gt; 0)
 		inherit = 1;
 
<span class="p_del">-	error = xfs_set_mode(inode, mode);</span>
<span class="p_add">+	error = xfs_set_mode(NULL, inode, mode);</span>
 	if (error)
 		goto out;
 
<span class="p_chunk">@@ -383,18 +384,15 @@</span> <span class="p_context"> xfs_xattr_acl_set(struct dentry *dentry, const char *name,</span>
 		goto out_release;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_add">+		struct posix_acl *saved_acl = acl;</span>
<span class="p_add">+		umode_t mode;</span>
 
<span class="p_del">-		if (error &lt;= 0) {</span>
<span class="p_del">-			posix_acl_release(acl);</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		error = xfs_set_mode(inode, mode);</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error || acl == NULL)</span>
<span class="p_add">+			posix_acl_release(saved_acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		error = xfs_set_mode(dentry, inode, mode);</span>
 		if (error)
 			goto out_release;
 	}
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index 8ae937a18da3..ba1d4779ece6 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -1026,7 +1026,8 @@</span> <span class="p_context"> xfs_file_fallocate(</span>
 	if (file-&gt;f_flags &amp; O_DSYNC)
 		attr_flags |= XFS_ATTR_SYNC;
 
<span class="p_del">-	error = -xfs_change_file_space(ip, cmd, &amp;bf, 0, attr_flags);</span>
<span class="p_add">+	error = -xfs_change_file_space(file-&gt;f_dentry, cmd, &amp;bf, 0,</span>
<span class="p_add">+				       attr_flags);</span>
 	if (error)
 		goto out_unlock;
 
<span class="p_chunk">@@ -1036,7 +1037,8 @@</span> <span class="p_context"> xfs_file_fallocate(</span>
 
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = new_size;
<span class="p_del">-		error = -xfs_setattr_size(ip, &amp;iattr, XFS_ATTR_NOLOCK);</span>
<span class="p_add">+		error = -xfs_setattr_size(file-&gt;f_dentry, &amp;iattr,</span>
<span class="p_add">+					  XFS_ATTR_NOLOCK);</span>
 	}
 
 out_unlock:
<span class="p_header">diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">index eb519de68047..5a213c96d51f 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ioctl.c</span>
<span class="p_chunk">@@ -632,7 +632,8 @@</span> <span class="p_context"> xfs_ioc_space(</span>
 	if (ioflags &amp; IO_INVIS)
 		attr_flags |= XFS_ATTR_DMI;
 
<span class="p_del">-	error = xfs_change_file_space(ip, cmd, bf, filp-&gt;f_pos, attr_flags);</span>
<span class="p_add">+	error = xfs_change_file_space(filp-&gt;f_dentry, cmd, bf, filp-&gt;f_pos,</span>
<span class="p_add">+				      attr_flags);</span>
 	return -error;
 }
 
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index 1c01f04f46d2..a20378e34122 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -531,6 +531,7 @@</span> <span class="p_context"> xfs_setattr_mode(</span>
 
 int
 xfs_setattr_nonsize(
<span class="p_add">+	struct dentry		*dentry,</span>
 	struct xfs_inode	*ip,
 	struct iattr		*iattr,
 	int			flags)
<span class="p_chunk">@@ -553,9 +554,15 @@</span> <span class="p_context"> xfs_setattr_nonsize(</span>
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return XFS_ERROR(EIO);
 
<span class="p_del">-	error = -inode_change_ok(inode, iattr);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return XFS_ERROR(error);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * dentry can be NULL only when we&#39;re called from xfs_inherit_acl(),</span>
<span class="p_add">+	 * in which case no permission checks are needed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dentry) {</span>
<span class="p_add">+		error = -setattr_prepare(dentry, iattr);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return XFS_ERROR(error);</span>
<span class="p_add">+	}</span>
 
 	ASSERT((mask &amp; ATTR_SIZE) == 0);
 
<span class="p_chunk">@@ -755,12 +762,13 @@</span> <span class="p_context"> out_dqrele:</span>
  */
 int
 xfs_setattr_size(
<span class="p_del">-	struct xfs_inode	*ip,</span>
<span class="p_add">+	struct dentry		*dentry,</span>
 	struct iattr		*iattr,
 	int			flags)
 {
<span class="p_add">+	struct inode		*inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct xfs_inode	*ip = XFS_I(inode);</span>
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_del">-	struct inode		*inode = VFS_I(ip);</span>
 	int			mask = iattr-&gt;ia_valid;
 	struct xfs_trans	*tp;
 	int			error;
<span class="p_chunk">@@ -776,7 +784,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	if (XFS_FORCED_SHUTDOWN(mp))
 		return XFS_ERROR(EIO);
 
<span class="p_del">-	error = -inode_change_ok(inode, iattr);</span>
<span class="p_add">+	error = -setattr_prepare(dentry, iattr);</span>
 	if (error)
 		return XFS_ERROR(error);
 
<span class="p_chunk">@@ -802,7 +810,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 		 */
 		xfs_iunlock(ip, lock_flags);
 		iattr-&gt;ia_valid &amp;= ~ATTR_SIZE;
<span class="p_del">-		return xfs_setattr_nonsize(ip, iattr, 0);</span>
<span class="p_add">+		return xfs_setattr_nonsize(dentry, ip, iattr, 0);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -950,8 +958,8 @@</span> <span class="p_context"> xfs_vn_setattr(</span>
 	struct iattr	*iattr)
 {
 	if (iattr-&gt;ia_valid &amp; ATTR_SIZE)
<span class="p_del">-		return -xfs_setattr_size(XFS_I(dentry-&gt;d_inode), iattr, 0);</span>
<span class="p_del">-	return -xfs_setattr_nonsize(XFS_I(dentry-&gt;d_inode), iattr, 0);</span>
<span class="p_add">+		return -xfs_setattr_size(dentry, iattr, 0);</span>
<span class="p_add">+	return -xfs_setattr_nonsize(dentry, XFS_I(dentry-&gt;d_inode), iattr, 0);</span>
 }
 
 #define XFS_FIEMAP_FLAGS	(FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)
<span class="p_header">diff --git a/fs/xfs/xfs_vnodeops.c b/fs/xfs/xfs_vnodeops.c</span>
<span class="p_header">index ee98d0bf0f6a..feb9e7556829 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_vnodeops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_vnodeops.c</span>
<span class="p_chunk">@@ -2234,12 +2234,13 @@</span> <span class="p_context"> xfs_free_file_space(</span>
  */
 int
 xfs_change_file_space(
<span class="p_del">-	xfs_inode_t	*ip,</span>
<span class="p_add">+	struct dentry	*dentry,</span>
 	int		cmd,
 	xfs_flock64_t	*bf,
 	xfs_off_t	offset,
 	int		attr_flags)
 {
<span class="p_add">+	xfs_inode_t	*ip = XFS_I(dentry-&gt;d_inode);</span>
 	xfs_mount_t	*mp = ip-&gt;i_mount;
 	int		clrprealloc;
 	int		error;
<span class="p_chunk">@@ -2329,7 +2330,7 @@</span> <span class="p_context"> xfs_change_file_space(</span>
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = startoffset;
 
<span class="p_del">-		error = xfs_setattr_size(ip, &amp;iattr, attr_flags);</span>
<span class="p_add">+		error = xfs_setattr_size(dentry, &amp;iattr, attr_flags);</span>
 
 		if (error)
 			return error;
<span class="p_header">diff --git a/fs/xfs/xfs_vnodeops.h b/fs/xfs/xfs_vnodeops.h</span>
<span class="p_header">index c0f7714b98d0..938c4267d44b 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_vnodeops.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_vnodeops.h</span>
<span class="p_chunk">@@ -13,8 +13,9 @@</span> <span class="p_context"> struct xfs_inode;</span>
 struct xfs_iomap;
 
 
<span class="p_del">-int xfs_setattr_nonsize(struct xfs_inode *ip, struct iattr *vap, int flags);</span>
<span class="p_del">-int xfs_setattr_size(struct xfs_inode *ip, struct iattr *vap, int flags);</span>
<span class="p_add">+int xfs_setattr_nonsize(struct dentry *dentry, struct xfs_inode *ip,</span>
<span class="p_add">+			struct iattr *vap, int flags);</span>
<span class="p_add">+int xfs_setattr_size(struct dentry *dentry, struct iattr *vap, int flags);</span>
 #define	XFS_ATTR_DMI		0x01	/* invocation from a DMI function */
 #define	XFS_ATTR_NONBLOCK	0x02	/* return EAGAIN if operation would block */
 #define XFS_ATTR_NOLOCK		0x04	/* Don&#39;t grab any conflicting locks */
<span class="p_chunk">@@ -37,7 +38,7 @@</span> <span class="p_context"> int xfs_readdir(struct xfs_inode	*dp, void *dirent, size_t bufsize,</span>
 int xfs_symlink(struct xfs_inode *dp, struct xfs_name *link_name,
 		const char *target_path, mode_t mode, struct xfs_inode **ipp);
 int xfs_set_dmattrs(struct xfs_inode *ip, u_int evmask, u_int16_t state);
<span class="p_del">-int xfs_change_file_space(struct xfs_inode *ip, int cmd,</span>
<span class="p_add">+int xfs_change_file_space(struct dentry *dentry, int cmd,</span>
 		xfs_flock64_t *bf, xfs_off_t offset, int attr_flags);
 int xfs_rename(struct xfs_inode *src_dp, struct xfs_name *src_name,
 		struct xfs_inode *src_ip, struct xfs_inode *target_dp,
<span class="p_header">diff --git a/include/asm-generic/uaccess.h b/include/asm-generic/uaccess.h</span>
<span class="p_header">index ac68c999b6c2..5ba2c4570bd3 100644</span>
<span class="p_header">--- a/include/asm-generic/uaccess.h</span>
<span class="p_header">+++ b/include/asm-generic/uaccess.h</span>
<span class="p_chunk">@@ -221,13 +221,17 @@</span> <span class="p_context"> extern int __put_user_bad(void) __attribute__((noreturn));</span>
 	might_sleep();						\
 	access_ok(VERIFY_READ, ptr, sizeof(*ptr)) ?		\
 		__get_user(x, ptr) :				\
<span class="p_del">-		-EFAULT;					\</span>
<span class="p_add">+		((x) = (__typeof__(*(ptr)))0,-EFAULT);		\</span>
 })
 
 static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)
 {
<span class="p_del">-	size = __copy_from_user(x, ptr, size);</span>
<span class="p_del">-	return size ? -EFAULT : size;</span>
<span class="p_add">+	size_t n = __copy_from_user(x, ptr, size);</span>
<span class="p_add">+	if (unlikely(n)) {</span>
<span class="p_add">+		memset(x + (size - n), 0, n);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
 }
 
 extern int __get_user_bad(void) __attribute__((noreturn));
<span class="p_chunk">@@ -243,11 +247,13 @@</span> <span class="p_context"> extern int __get_user_bad(void) __attribute__((noreturn));</span>
 static inline long copy_from_user(void *to,
 		const void __user * from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	might_sleep();
<span class="p_del">-	if (access_ok(VERIFY_READ, from, n))</span>
<span class="p_del">-		return __copy_from_user(to, from, n);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return n;</span>
<span class="p_add">+	if (likely(access_ok(VERIFY_READ, from, n)))</span>
<span class="p_add">+		res = __copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline long copy_to_user(void __user *to,
<span class="p_header">diff --git a/include/linux/bcma/bcma.h b/include/linux/bcma/bcma.h</span>
<span class="p_header">index 4d4b59de9467..7553789b9729 100644</span>
<span class="p_header">--- a/include/linux/bcma/bcma.h</span>
<span class="p_header">+++ b/include/linux/bcma/bcma.h</span>
<span class="p_chunk">@@ -124,6 +124,7 @@</span> <span class="p_context"> struct bcma_host_ops {</span>
 #define BCMA_CORE_DEFAULT		0xFFF
 
 #define BCMA_MAX_NR_CORES		16
<span class="p_add">+#define BCMA_CORE_SIZE			0x1000</span>
 
 struct bcma_device {
 	struct bcma_bus *bus;
<span class="p_header">diff --git a/include/linux/bcma/bcma_regs.h b/include/linux/bcma/bcma_regs.h</span>
<span class="p_header">index 9faae2ae02e8..b644d4392e43 100644</span>
<span class="p_header">--- a/include/linux/bcma/bcma_regs.h</span>
<span class="p_header">+++ b/include/linux/bcma/bcma_regs.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #define  BCMA_IOST_BIST_DONE		0x8000
 #define BCMA_RESET_CTL			0x0800
 #define  BCMA_RESET_CTL_RESET		0x0001
<span class="p_add">+#define BCMA_RESET_ST			0x0804</span>
 
 /* BCMA PCI config space registers. */
 #define BCMA_PCI_PMCSR			0x44
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index a0969fcb72b9..309d2aa3dfd8 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> enum can_mode {</span>
  * CAN common private data
  */
 struct can_priv {
<span class="p_add">+	struct net_device *dev;</span>
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming;
<span class="p_chunk">@@ -41,7 +42,7 @@</span> <span class="p_context"> struct can_priv {</span>
 	u32 ctrlmode_supported;
 
 	int restart_ms;
<span class="p_del">-	struct timer_list restart_timer;</span>
<span class="p_add">+	struct delayed_work restart_work;</span>
 
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_mode)(struct net_device *dev, enum can_mode mode);
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index a509bee30c50..8c63ec58b015 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -2615,7 +2615,7 @@</span> <span class="p_context"> extern int buffer_migrate_page(struct address_space *,</span>
 #define buffer_migrate_page NULL
 #endif
 
<span class="p_del">-extern int inode_change_ok(const struct inode *, struct iattr *);</span>
<span class="p_add">+extern int setattr_prepare(struct dentry *, struct iattr *);</span>
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
<span class="p_header">diff --git a/include/linux/i8042.h b/include/linux/i8042.h</span>
<span class="p_header">index a986ff588944..801c307f6fcc 100644</span>
<span class="p_header">--- a/include/linux/i8042.h</span>
<span class="p_header">+++ b/include/linux/i8042.h</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> struct serio;</span>
 void i8042_lock_chip(void);
 void i8042_unlock_chip(void);
 int i8042_command(unsigned char *param, int command);
<span class="p_del">-bool i8042_check_port_owner(const struct serio *);</span>
 int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio));
 int i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,
<span class="p_chunk">@@ -59,11 +58,6 @@</span> <span class="p_context"> static inline int i8042_command(unsigned char *param, int command)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static inline bool i8042_check_port_owner(const struct serio *serio)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio))
 {
<span class="p_header">diff --git a/include/linux/mroute.h b/include/linux/mroute.h</span>
<span class="p_header">index 46caaf44339d..4e364bb6d1aa 100644</span>
<span class="p_header">--- a/include/linux/mroute.h</span>
<span class="p_header">+++ b/include/linux/mroute.h</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> struct mfc_cache {</span>
 struct rtmsg;
 extern int ipmr_get_route(struct net *net, struct sk_buff *skb,
 			  __be32 saddr, __be32 daddr,
<span class="p_del">-			  struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			  struct rtmsg *rtm, int nowait, u32 portid);</span>
 #endif
 
 #endif
<span class="p_header">diff --git a/include/linux/mroute6.h b/include/linux/mroute6.h</span>
<span class="p_header">index a3759cb0ac10..9b30150c973a 100644</span>
<span class="p_header">--- a/include/linux/mroute6.h</span>
<span class="p_header">+++ b/include/linux/mroute6.h</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> struct mfc6_cache {</span>
 #ifdef __KERNEL__
 struct rtmsg;
 extern int ip6mr_get_route(struct net *net, struct sk_buff *skb,
<span class="p_del">-			   struct rtmsg *rtm, int nowait);</span>
<span class="p_add">+			   struct rtmsg *rtm, int nowait, u32 portid);</span>
 
 #ifdef CONFIG_IPV6_MROUTE
 extern struct sock *mroute6_socket(struct net *net, struct sk_buff *skb);
<span class="p_header">diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h</span>
<span class="p_header">index b7681102a4b9..da432868954f 100644</span>
<span class="p_header">--- a/include/linux/posix_acl.h</span>
<span class="p_header">+++ b/include/linux/posix_acl.h</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> extern struct posix_acl *posix_acl_from_mode(umode_t, gfp_t);</span>
 extern int posix_acl_equiv_mode(const struct posix_acl *, umode_t *);
 extern int posix_acl_create(struct posix_acl **, gfp_t, umode_t *);
 extern int posix_acl_chmod(struct posix_acl **, gfp_t, umode_t);
<span class="p_add">+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);</span>
 
 extern struct posix_acl *get_posix_acl(struct inode *, int);
 extern int set_posix_acl(struct inode *, int, struct posix_acl *);
<span class="p_header">diff --git a/include/linux/serio.h b/include/linux/serio.h</span>
<span class="p_header">index ca82861b0e46..34b403a6d284 100644</span>
<span class="p_header">--- a/include/linux/serio.h</span>
<span class="p_header">+++ b/include/linux/serio.h</span>
<span class="p_chunk">@@ -33,7 +33,8 @@</span> <span class="p_context"> struct serio {</span>
 
 	struct serio_device_id id;
 
<span class="p_del">-	spinlock_t lock;		/* protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	/* Protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	spinlock_t lock;</span>
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
<span class="p_chunk">@@ -42,16 +43,29 @@</span> <span class="p_context"> struct serio {</span>
 	void (*stop)(struct serio *);
 
 	struct serio *parent;
<span class="p_del">-	struct list_head child_node;	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	struct list_head child_node;</span>
 	struct list_head children;
<span class="p_del">-	unsigned int depth;		/* level of nesting in serio hierarchy */</span>
<span class="p_add">+	/* Level of nesting in serio hierarchy */</span>
<span class="p_add">+	unsigned int depth;</span>
 
<span class="p_del">-	struct serio_driver *drv;	/* accessed from interrupt, must be protected by serio-&gt;lock and serio-&gt;sem */</span>
<span class="p_del">-	struct mutex drv_mutex;		/* protects serio-&gt;drv so attributes can pin driver */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * serio-&gt;drv is accessed from interrupt handlers; when modifying</span>
<span class="p_add">+	 * caller should acquire serio-&gt;drv_mutex and serio-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct serio_driver *drv;</span>
<span class="p_add">+	/* Protects serio-&gt;drv so attributes can pin current driver */</span>
<span class="p_add">+	struct mutex drv_mutex;</span>
 
 	struct device dev;
 
 	struct list_head node;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For use by PS/2 layer when several ports share hardware and</span>
<span class="p_add">+	 * may get indigestion when exposed to concurrent access (i8042).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct mutex *ps2_cmd_mutex;</span>
 };
 #define to_serio_port(d)	container_of(d, struct serio, dev)
 
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index e90235fb1b18..0f4e1d419bfb 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1293,6 +1293,8 @@</span> <span class="p_context"> static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unli</span>
 {
 	if (sk-&gt;sk_send_head == skb_unlinked)
 		sk-&gt;sk_send_head = NULL;
<span class="p_add">+	if (tcp_sk(sk)-&gt;highest_sack == skb_unlinked)</span>
<span class="p_add">+		tcp_sk(sk)-&gt;highest_sack = NULL;</span>
 }
 
 static inline void tcp_init_send_head(struct sock *sk)
<span class="p_header">diff --git a/kernel/sched.c b/kernel/sched.c</span>
<span class="p_header">index fb554299ca44..ffa3190df1ed 100644</span>
<span class="p_header">--- a/kernel/sched.c</span>
<span class="p_header">+++ b/kernel/sched.c</span>
<span class="p_chunk">@@ -2084,19 +2084,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(account_system_vtime);</span>
 
 #endif /* CONFIG_IRQ_TIME_ACCOUNTING */
 
<span class="p_del">-static inline void account_reset_rq(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_irq_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_del">-	rq-&gt;prev_steal_time = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING</span>
<span class="p_del">-	rq-&gt;prev_steal_time_rq = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PARAVIRT
 static inline u64 steal_ticks(u64 steal)
 {
<span class="p_chunk">@@ -2846,6 +2833,28 @@</span> <span class="p_context"> try_to_wake_up(struct task_struct *p, unsigned int state, int wake_flags)</span>
 	success = 1; /* we&#39;re going to change -&gt;state */
 	cpu = task_cpu(p);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure we load p-&gt;on_rq _after_ p-&gt;state, otherwise it would</span>
<span class="p_add">+	 * be possible to, falsely, observe p-&gt;on_rq == 0 and get stuck</span>
<span class="p_add">+	 * in smp_cond_load_acquire() below.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * sched_ttwu_pending()                 try_to_wake_up()</span>
<span class="p_add">+	 *   [S] p-&gt;on_rq = 1;                  [L] P-&gt;state</span>
<span class="p_add">+	 *       UNLOCK rq-&gt;lock  -----.</span>
<span class="p_add">+	 *                              \</span>
<span class="p_add">+	 *				 +---   RMB</span>
<span class="p_add">+	 * schedule()                   /</span>
<span class="p_add">+	 *       LOCK rq-&gt;lock    -----&#39;</span>
<span class="p_add">+	 *       UNLOCK rq-&gt;lock</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * [task p]</span>
<span class="p_add">+	 *   [S] p-&gt;state = UNINTERRUPTIBLE     [L] p-&gt;on_rq</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Pairs with the UNLOCK+LOCK on rq-&gt;lock from the</span>
<span class="p_add">+	 * last wakeup of our task and the schedule that got our task</span>
<span class="p_add">+	 * current.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_rmb();</span>
 	if (p-&gt;on_rq &amp;&amp; ttwu_remote(p, wake_flags))
 		goto stat;
 
<span class="p_chunk">@@ -6869,7 +6878,6 @@</span> <span class="p_context"> migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)</span>
 
 	case CPU_UP_PREPARE:
 		rq-&gt;calc_load_update = calc_load_update;
<span class="p_del">-		account_reset_rq(rq);</span>
 		break;
 
 	case CPU_ONLINE:
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index f4b93a207026..ca7396e4aff4 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -3331,13 +3331,6 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	static struct tracer *old_tracer;
 	ssize_t sret;
 
<span class="p_del">-	/* return any leftover data */</span>
<span class="p_del">-	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_del">-	if (sret != -EBUSY)</span>
<span class="p_del">-		return sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_del">-</span>
 	/* copy the tracer to avoid using a global lock all around */
 	mutex_lock(&amp;trace_types_lock);
 	if (unlikely(old_tracer != current_trace &amp;&amp; current_trace)) {
<span class="p_chunk">@@ -3352,6 +3345,14 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	 * is protected.
 	 */
 	mutex_lock(&amp;iter-&gt;mutex);
<span class="p_add">+</span>
<span class="p_add">+	/* return any leftover data */</span>
<span class="p_add">+	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_add">+	if (sret != -EBUSY)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_add">+</span>
 	if (iter-&gt;trace-&gt;read) {
 		sret = iter-&gt;trace-&gt;read(iter, filp, ubuf, cnt, ppos);
 		if (sret)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index c52095ce40b4..390f0ac4eed6 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1417,6 +1417,10 @@</span> <span class="p_context"> static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
 		 * and reducing the surplus.
 		 */
 		spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+</span>
<span class="p_add">+		/* yield cpu to avoid soft lockup */</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		ret = alloc_fresh_huge_page(h, nodes_allowed);
 		spin_lock(&amp;hugetlb_lock);
 		if (!ret)
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index 6741c9df5c80..168b980ac919 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -238,7 +238,8 @@</span> <span class="p_context"> static inline struct rmap_item *alloc_rmap_item(void)</span>
 {
 	struct rmap_item *rmap_item;
 
<span class="p_del">-	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL);</span>
<span class="p_add">+	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |</span>
<span class="p_add">+						__GFP_NORETRY | __GFP_NOWARN);</span>
 	if (rmap_item)
 		ksm_rmap_items++;
 	return rmap_item;
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index 83efac6ddef0..0a9d8919ddfa 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> static int shmem_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
<span class="p_del">-	error = inode_change_ok(inode, attr);</span>
<span class="p_add">+	error = setattr_prepare(dentry, attr);</span>
 	if (error)
 		return error;
 
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 74e59cdd047b..6c89d61aaa6f 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -630,7 +630,7 @@</span> <span class="p_context"> static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname, ch</span>
 			break;
 		}
 
<span class="p_del">-		if (get_user(opt, (u32 __user *) optval)) {</span>
<span class="p_add">+		if (get_user(opt, (u16 __user *) optval)) {</span>
 			err = -EFAULT;
 			break;
 		}
<span class="p_header">diff --git a/net/bluetooth/rfcomm/sock.c b/net/bluetooth/rfcomm/sock.c</span>
<span class="p_header">index 93a824179458..6c74264875c9 100644</span>
<span class="p_header">--- a/net/bluetooth/rfcomm/sock.c</span>
<span class="p_header">+++ b/net/bluetooth/rfcomm/sock.c</span>
<span class="p_chunk">@@ -349,15 +349,19 @@</span> <span class="p_context"> static int rfcomm_sock_create(struct net *net, struct socket *sock,</span>
 
 static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
 {
<span class="p_del">-	struct sockaddr_rc *sa = (struct sockaddr_rc *) addr;</span>
<span class="p_add">+	struct sockaddr_rc sa;</span>
 	struct sock *sk = sock-&gt;sk;
<span class="p_del">-	int err = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	BT_DBG(&quot;sk %p %s&quot;, sk, batostr(&amp;sa-&gt;rc_bdaddr));</span>
<span class="p_add">+	int len, err = 0;</span>
 
 	if (!addr || addr-&gt;sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
<span class="p_add">+	memset(&amp;sa, 0, sizeof(sa));</span>
<span class="p_add">+	len = min_t(unsigned int, sizeof(sa), addr_len);</span>
<span class="p_add">+	memcpy(&amp;sa, addr, len);</span>
<span class="p_add">+</span>
<span class="p_add">+	BT_DBG(&quot;sk %p %s&quot;, sk, batostr(&amp;sa.rc_bdaddr));</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	if (sk-&gt;sk_state != BT_OPEN) {
<span class="p_chunk">@@ -372,12 +376,13 @@</span> <span class="p_context"> static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr</span>
 
 	write_lock_bh(&amp;rfcomm_sk_list.lock);
 
<span class="p_del">-	if (sa-&gt;rc_channel &amp;&amp; __rfcomm_get_sock_by_addr(sa-&gt;rc_channel, &amp;sa-&gt;rc_bdaddr)) {</span>
<span class="p_add">+	if (sa.rc_channel &amp;&amp;</span>
<span class="p_add">+	    __rfcomm_get_sock_by_addr(sa.rc_channel, &amp;sa.rc_bdaddr)) {</span>
 		err = -EADDRINUSE;
 	} else {
 		/* Save source address */
<span class="p_del">-		bacpy(&amp;bt_sk(sk)-&gt;src, &amp;sa-&gt;rc_bdaddr);</span>
<span class="p_del">-		rfcomm_pi(sk)-&gt;channel = sa-&gt;rc_channel;</span>
<span class="p_add">+		bacpy(&amp;bt_sk(sk)-&gt;src, &amp;sa.rc_bdaddr);</span>
<span class="p_add">+		rfcomm_pi(sk)-&gt;channel = sa.rc_channel;</span>
 		sk-&gt;sk_state = BT_BOUND;
 	}
 
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index 95b47ff4ce6f..6558a9182793 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -2058,7 +2058,7 @@</span> <span class="p_context"> rtattr_failure:</span>
 
 int ipmr_get_route(struct net *net, struct sk_buff *skb,
 		   __be32 saddr, __be32 daddr,
<span class="p_del">-		   struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+		   struct rtmsg *rtm, int nowait, u32 portid)</span>
 {
 	struct mfc_cache *cache;
 	struct mr_table *mrt;
<span class="p_chunk">@@ -2098,6 +2098,7 @@</span> <span class="p_context"> int ipmr_get_route(struct net *net, struct sk_buff *skb,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).pid = portid;</span>
 		skb_push(skb2, sizeof(struct iphdr));
 		skb_reset_network_header(skb2);
 		iph = ip_hdr(skb2);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 8e79a9e04276..3026b65f9a84 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -3077,7 +3077,8 @@</span> <span class="p_context"> static int rt_fill_info(struct net *net,</span>
 		    IPV4_DEVCONF_ALL(net, MC_FORWARDING)) {
 			int err = ipmr_get_route(net, skb,
 						 rt-&gt;rt_src, rt-&gt;rt_dst,
<span class="p_del">-						 r, nowait);</span>
<span class="p_add">+						 r, nowait, pid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index e61481009801..918ecd724c1b 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -220,7 +220,8 @@</span> <span class="p_context"> void tcp_select_initial_window(int __space, __u32 mss,</span>
 		/* Set window scaling on max possible window
 		 * See RFC1323 for an explanation of the limit to 14
 		 */
<span class="p_del">-		space = max_t(u32, sysctl_tcp_rmem[2], sysctl_rmem_max);</span>
<span class="p_add">+		space = max_t(u32, space, sysctl_tcp_rmem[2]);</span>
<span class="p_add">+		space = max_t(u32, space, sysctl_rmem_max);</span>
 		space = min_t(u32, space, *window_clamp);
 		while (space &gt; 65535 &amp;&amp; (*rcv_wscale) &lt; 14) {
 			space &gt;&gt;= 1;
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index 02b3c827dfe0..7a3923b3e828 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -2137,8 +2137,8 @@</span> <span class="p_context"> rtattr_failure:</span>
 	return -EMSGSIZE;
 }
 
<span class="p_del">-int ip6mr_get_route(struct net *net,</span>
<span class="p_del">-		    struct sk_buff *skb, struct rtmsg *rtm, int nowait)</span>
<span class="p_add">+int ip6mr_get_route(struct net *net, struct sk_buff *skb, struct rtmsg *rtm,</span>
<span class="p_add">+		    int nowait, u32 portid)</span>
 {
 	int err;
 	struct mr6_table *mrt;
<span class="p_chunk">@@ -2176,6 +2176,7 @@</span> <span class="p_context"> int ip6mr_get_route(struct net *net,</span>
 			return -ENOMEM;
 		}
 
<span class="p_add">+		NETLINK_CB(skb2).pid = portid;</span>
 		skb_reset_transport_header(skb2);
 
 		skb_put(skb2, sizeof(struct ipv6hdr));
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 3a8776d9b895..d4059fa59548 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -2416,7 +2416,9 @@</span> <span class="p_context"> static int rt6_fill_node(struct net *net,</span>
 	if (iif) {
 #ifdef CONFIG_IPV6_MROUTE
 		if (ipv6_addr_is_multicast(&amp;rt-&gt;rt6i_dst.addr)) {
<span class="p_del">-			int err = ip6mr_get_route(net, skb, rtm, nowait);</span>
<span class="p_add">+			int err = ip6mr_get_route(net, skb, rtm, nowait,</span>
<span class="p_add">+						  pid);</span>
<span class="p_add">+</span>
 			if (err &lt;= 0) {
 				if (!nowait) {
 					if (err == 0)
<span class="p_header">diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c</span>
<span class="p_header">index 03c8ea9deaf6..078967fbb809 100644</span>
<span class="p_header">--- a/net/irda/af_irda.c</span>
<span class="p_header">+++ b/net/irda/af_irda.c</span>
<span class="p_chunk">@@ -846,7 +846,7 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	struct sock *sk = sock-&gt;sk;
 	struct irda_sock *new, *self = irda_sk(sk);
 	struct sock *newsk;
<span class="p_del">-	struct sk_buff *skb;</span>
<span class="p_add">+	struct sk_buff *skb = NULL;</span>
 	int err;
 
 	IRDA_DEBUG(2, &quot;%s()\n&quot;, __func__);
<span class="p_chunk">@@ -916,7 +916,6 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	err = -EPERM; /* value does not seem to make sense. -arnd */
 	if (!new-&gt;tsap) {
 		IRDA_DEBUG(0, &quot;%s(), dup failed!\n&quot;, __func__);
<span class="p_del">-		kfree_skb(skb);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -935,7 +934,6 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	/* Clean up the original one to keep it in listen state */
 	irttp_listen(self-&gt;tsap);
 
<span class="p_del">-	kfree_skb(skb);</span>
 	sk-&gt;sk_ack_backlog--;
 
 	newsock-&gt;state = SS_CONNECTED;
<span class="p_chunk">@@ -943,6 +941,7 @@</span> <span class="p_context"> static int irda_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	irda_connect_response(new);
 	err = 0;
 out:
<span class="p_add">+	kfree_skb(skb);</span>
 	release_sock(sk);
 	return err;
 }
<span class="p_chunk">@@ -1040,8 +1039,11 @@</span> <span class="p_context"> static int irda_connect(struct socket *sock, struct sockaddr *uaddr,</span>
 	}
 
 	/* Check if we have opened a local TSAP */
<span class="p_del">-	if (!self-&gt;tsap)</span>
<span class="p_del">-		irda_open_tsap(self, LSAP_ANY, addr-&gt;sir_name);</span>
<span class="p_add">+	if (!self-&gt;tsap) {</span>
<span class="p_add">+		err = irda_open_tsap(self, LSAP_ANY, addr-&gt;sir_name);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+	}</span>
 
 	/* Move to connecting socket, start sending Connect Requests */
 	sock-&gt;state = SS_CONNECTING;
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index 767bf4afefbd..0417743b09e5 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -914,10 +914,8 @@</span> <span class="p_context"> static int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,</span>
 
 	pls = l2tp_session_priv(session);
 	tunnel = l2tp_sock_to_tunnel(pls-&gt;tunnel_sock);
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_del">-		error = -EBADF;</span>
<span class="p_add">+	if (tunnel == NULL)</span>
 		goto end_put_sess;
<span class="p_del">-	}</span>
 
 	inet = inet_sk(tunnel-&gt;sock);
 	if (tunnel-&gt;version == 2) {
<span class="p_chunk">@@ -955,12 +953,11 @@</span> <span class="p_context"> static int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,</span>
 	}
 
 	*usockaddr_len = len;
<span class="p_add">+	error = 0;</span>
 
 	sock_put(pls-&gt;tunnel_sock);
 end_put_sess:
 	sock_put(sk);
<span class="p_del">-	error = 0;</span>
<span class="p_del">-</span>
 end:
 	return error;
 }
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">index a80b0cb03f17..275906c9a342 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_chunk">@@ -716,9 +716,6 @@</span> <span class="p_context"> nfqnl_recv_verdict(struct sock *ctnl, struct sk_buff *skb,</span>
 	unsigned int verdict;
 	struct nf_queue_entry *entry;
 
<span class="p_del">-	queue = instance_lookup(queue_num);</span>
<span class="p_del">-	if (!queue)</span>
<span class="p_del">-</span>
 	queue = verdict_instance_lookup(queue_num, NETLINK_CB(skb).pid);
 	if (IS_ERR(queue))
 		return PTR_ERR(queue);
<span class="p_header">diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">index bcecae0f00c6..290c7bb8865b 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_kapi.c</span>
<span class="p_chunk">@@ -710,7 +710,11 @@</span> <span class="p_context"> socket_setattr_return:</span>
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
<span class="p_del">-	cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -889,7 +893,11 @@</span> <span class="p_context"> req_setattr_return:</span>
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
<span class="p_del">-	cipso_v4_req_delattr(req);</span>
<span class="p_add">+	switch (req-&gt;rsk_ops-&gt;family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_req_delattr(req);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index c80c16248a3c..efd443dbacf9 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1167,11 +1167,16 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 		*statp = procp-&gt;pc_func(rqstp, rqstp-&gt;rq_argp, rqstp-&gt;rq_resp);
 
 		/* Encode reply */
<span class="p_del">-		if (rqstp-&gt;rq_dropme) {</span>
<span class="p_add">+		if (*statp == rpc_drop_reply || rqstp-&gt;rq_dropme) {</span>
 			if (procp-&gt;pc_release)
 				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);
 			goto dropit;
 		}
<span class="p_add">+		if (*statp == rpc_autherr_badcred) {</span>
<span class="p_add">+			if (procp-&gt;pc_release)</span>
<span class="p_add">+				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);</span>
<span class="p_add">+			goto err_bad_auth;</span>
<span class="p_add">+		}</span>
 		if (*statp == rpc_success &amp;&amp;
 		    (xdr = procp-&gt;pc_encode) &amp;&amp;
 		    !xdr(rqstp, resv-&gt;iov_base+resv-&gt;iov_len, rqstp-&gt;rq_resp)) {
<span class="p_header">diff --git a/net/xfrm/xfrm_state.c b/net/xfrm/xfrm_state.c</span>
<span class="p_header">index 9414b9c5b1e4..45f8d9256081 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_state.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_state.c</span>
<span class="p_chunk">@@ -351,6 +351,7 @@</span> <span class="p_context"> static void xfrm_state_gc_destroy(struct xfrm_state *x)</span>
 {
 	tasklet_hrtimer_cancel(&amp;x-&gt;mtimer);
 	del_timer_sync(&amp;x-&gt;rtimer);
<span class="p_add">+	kfree(x-&gt;aead);</span>
 	kfree(x-&gt;aalg);
 	kfree(x-&gt;ealg);
 	kfree(x-&gt;calg);
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index ede01a8d9f4e..09542248f72b 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -558,9 +558,12 @@</span> <span class="p_context"> static struct xfrm_state *xfrm_state_construct(struct net *net,</span>
 	if (err)
 		goto error;
 
<span class="p_del">-	if (attrs[XFRMA_SEC_CTX] &amp;&amp;</span>
<span class="p_del">-	    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	if (attrs[XFRMA_SEC_CTX]) {</span>
<span class="p_add">+		err = security_xfrm_state_alloc(x,</span>
<span class="p_add">+						nla_data(attrs[XFRMA_SEC_CTX]));</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+	}</span>
 
 	if ((err = xfrm_alloc_replay_state_esn(&amp;x-&gt;replay_esn, &amp;x-&gt;preplay_esn,
 					       attrs[XFRMA_REPLAY_ESN_VAL])))
<span class="p_header">diff --git a/security/keys/proc.c b/security/keys/proc.c</span>
<span class="p_header">index 49bbc97943ad..3f7b4102a350 100644</span>
<span class="p_header">--- a/security/keys/proc.c</span>
<span class="p_header">+++ b/security/keys/proc.c</span>
<span class="p_chunk">@@ -188,7 +188,7 @@</span> <span class="p_context"> static int proc_keys_show(struct seq_file *m, void *v)</span>
 	struct timespec now;
 	unsigned long timo;
 	key_ref_t key_ref, skey_ref;
<span class="p_del">-	char xbuf[12];</span>
<span class="p_add">+	char xbuf[16];</span>
 	int rc;
 
 	key_ref = make_key_ref(key, 0);
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 96c62e58d950..132856b16b8d 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -150,6 +150,8 @@</span> <span class="p_context"> void snd_ctl_notify(struct snd_card *card, unsigned int mask,</span>
 	
 	if (snd_BUG_ON(!card || !id))
 		return;
<span class="p_add">+	if (card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
 	read_lock(&amp;card-&gt;ctl_files_rwlock);
 #if defined(CONFIG_SND_MIXER_OSS) || defined(CONFIG_SND_MIXER_OSS_MODULE)
 	card-&gt;mixer_oss_change_count++;
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index 14e7453969af..25f636536ec9 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -1609,11 +1609,13 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 		return -EBUSY;
 	}
 	list_add_tail(&amp;rmidi-&gt;list, &amp;snd_rawmidi_devices);
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
 	sprintf(name, &quot;midiC%iD%i&quot;, rmidi-&gt;card-&gt;number, rmidi-&gt;device);
 	if ((err = snd_register_device(SNDRV_DEVICE_TYPE_RAWMIDI,
 				       rmidi-&gt;card, rmidi-&gt;device,
 				       &amp;snd_rawmidi_f_ops, rmidi, name)) &lt; 0) {
 		snd_printk(KERN_ERR &quot;unable to register rawmidi device %i:%i\n&quot;, rmidi-&gt;card-&gt;number, rmidi-&gt;device);
<span class="p_add">+		mutex_lock(&amp;register_mutex);</span>
 		list_del(&amp;rmidi-&gt;list);
 		mutex_unlock(&amp;register_mutex);
 		return err;
<span class="p_chunk">@@ -1621,6 +1623,7 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 	if (rmidi-&gt;ops &amp;&amp; rmidi-&gt;ops-&gt;dev_register &amp;&amp;
 	    (err = rmidi-&gt;ops-&gt;dev_register(rmidi)) &lt; 0) {
 		snd_unregister_device(SNDRV_DEVICE_TYPE_RAWMIDI, rmidi-&gt;card, rmidi-&gt;device);
<span class="p_add">+		mutex_lock(&amp;register_mutex);</span>
 		list_del(&amp;rmidi-&gt;list);
 		mutex_unlock(&amp;register_mutex);
 		return err;
<span class="p_chunk">@@ -1649,7 +1652,6 @@</span> <span class="p_context"> static int snd_rawmidi_dev_register(struct snd_device *device)</span>
 		}
 	}
 #endif /* CONFIG_SND_OSSEMUL */
<span class="p_del">-	mutex_unlock(&amp;register_mutex);</span>
 	sprintf(name, &quot;midi%d&quot;, rmidi-&gt;device);
 	entry = snd_info_create_card_entry(rmidi-&gt;card, name, rmidi-&gt;card-&gt;proc_root);
 	if (entry) {
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index bce3fe051fbf..5628b6548d18 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -34,6 +34,9 @@</span> <span class="p_context"></span>
 #include &lt;sound/initval.h&gt;
 #include &lt;linux/kmod.h&gt;
 
<span class="p_add">+/* internal flags */</span>
<span class="p_add">+#define SNDRV_TIMER_IFLG_PAUSED		0x00010000</span>
<span class="p_add">+</span>
 #if defined(CONFIG_SND_HRTIMER) || defined(CONFIG_SND_HRTIMER_MODULE)
 #define DEFAULT_TIMER_LIMIT 4
 #elif defined(CONFIG_SND_RTCTIMER) || defined(CONFIG_SND_RTCTIMER_MODULE)
<span class="p_chunk">@@ -290,8 +293,19 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	}
 	timeri-&gt;slave_class = tid-&gt;dev_sclass;
 	timeri-&gt;slave_id = slave_id;
<span class="p_del">-	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open)</span>
<span class="p_del">-		timer-&gt;hw.open(timer);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open) {</span>
<span class="p_add">+		int err = timer-&gt;hw.open(timer);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			kfree(timeri-&gt;owner);</span>
<span class="p_add">+			kfree(timeri);</span>
<span class="p_add">+</span>
<span class="p_add">+			module_put(timer-&gt;module);</span>
<span class="p_add">+			mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_add_tail(&amp;timeri-&gt;open_list, &amp;timer-&gt;open_list_head);
 	snd_timer_check_master(timeri);
 	mutex_unlock(&amp;register_mutex);
<span class="p_chunk">@@ -299,8 +313,7 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	return 0;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance *timeri,</span>
<span class="p_del">-			   int keep_flag, int event);</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);</span>
 
 /*
  * close a timer instance
<span class="p_chunk">@@ -342,7 +355,7 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		spin_unlock_irq(&amp;timer-&gt;lock);
 		mutex_lock(&amp;register_mutex);
 		list_del(&amp;timeri-&gt;open_list);
<span class="p_del">-		if (timer &amp;&amp; list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
<span class="p_add">+		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_chunk">@@ -494,8 +507,7 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	return result;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
<span class="p_del">-			   int keep_flag, int event)</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)</span>
 {
 	struct snd_timer *timer;
 	unsigned long flags;
<span class="p_chunk">@@ -504,21 +516,19 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		return -ENXIO;
 
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {
<span class="p_del">-		if (!keep_flag) {</span>
<span class="p_del">-			spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_del">-			if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)) {</span>
<span class="p_del">-				spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
<span class="p_del">-				return -EBUSY;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (timeri-&gt;timer)</span>
<span class="p_del">-				spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_del">-			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_del">-			if (timeri-&gt;timer)</span>
<span class="p_del">-				spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_add">+		if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)) {</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
<span class="p_add">+			return -EBUSY;</span>
 		}
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
 		goto __end;
 	}
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -544,9 +554,11 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 			}
 		}
 	}
<span class="p_del">-	if (!keep_flag)</span>
<span class="p_del">-		timeri-&gt;flags &amp;=</span>
<span class="p_del">-			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
<span class="p_add">+	timeri-&gt;flags &amp;= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
<span class="p_add">+	if (event == SNDRV_TIMER_EVENT_STOP)</span>
<span class="p_add">+		timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_PAUSED;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		timeri-&gt;flags |= SNDRV_TIMER_IFLG_PAUSED;</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
<span class="p_chunk">@@ -565,7 +577,7 @@</span> <span class="p_context"> int snd_timer_stop(struct snd_timer_instance *timeri)</span>
 	unsigned long flags;
 	int err;
 
<span class="p_del">-	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);</span>
<span class="p_add">+	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);</span>
 	if (err &lt; 0)
 		return err;
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -589,6 +601,10 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 
 	if (timeri == NULL)
 		return result;
<span class="p_add">+	/* timer can continue only after pause */</span>
<span class="p_add">+	if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_PAUSED))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE)
 		return snd_timer_start_slave(timeri);
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -614,7 +630,7 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
<span class="p_del">-	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);</span>
<span class="p_add">+	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);</span>
 }
 
 /*
<span class="p_chunk">@@ -822,6 +838,7 @@</span> <span class="p_context"> int snd_timer_new(struct snd_card *card, char *id, struct snd_timer_id *tid,</span>
 	timer-&gt;tmr_subdevice = tid-&gt;subdevice;
 	if (id)
 		strlcpy(timer-&gt;id, id, sizeof(timer-&gt;id));
<span class="p_add">+	timer-&gt;sticks = 1;</span>
 	INIT_LIST_HEAD(&amp;timer-&gt;device_list);
 	INIT_LIST_HEAD(&amp;timer-&gt;open_list_head);
 	INIT_LIST_HEAD(&amp;timer-&gt;active_list_head);
<span class="p_chunk">@@ -1792,6 +1809,9 @@</span> <span class="p_context"> static int snd_timer_user_continue(struct file *file)</span>
 	tu = file-&gt;private_data;
 	if (!tu-&gt;timeri)
 		return -EBADFD;
<span class="p_add">+	/* start timer instead of continue if it&#39;s not used before */</span>
<span class="p_add">+	if (!(tu-&gt;timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_PAUSED))</span>
<span class="p_add">+		return snd_timer_user_start(file);</span>
 	tu-&gt;timeri-&gt;lost = 0;
 	return (err = snd_timer_continue(tu-&gt;timeri)) &lt; 0 ? err : 0;
 }
<span class="p_chunk">@@ -1929,6 +1949,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 		tu-&gt;qused--;
 		spin_unlock_irq(&amp;tu-&gt;qlock);
 
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;tread) {
 			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[qhead],
 					 sizeof(struct snd_timer_tread)))
<span class="p_chunk">@@ -1938,6 +1959,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 					 sizeof(struct snd_timer_read)))
 				err = -EFAULT;
 		}
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 
 		spin_lock_irq(&amp;tu-&gt;qlock);
 		if (err &lt; 0)
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 8b0617a648d1..375e0539597c 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> void vcpu_load(struct kvm_vcpu *vcpu)</span>
 	kvm_arch_vcpu_load(vcpu, cpu);
 	put_cpu();
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_load);</span>
 
 void vcpu_put(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -165,6 +166,7 @@</span> <span class="p_context"> void vcpu_put(struct kvm_vcpu *vcpu)</span>
 	preempt_enable();
 	mutex_unlock(&amp;vcpu-&gt;mutex);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_put);</span>
 
 static void ack_flush(void *_completed)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



