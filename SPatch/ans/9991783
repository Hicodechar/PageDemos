
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.54 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.54</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 8, 2017, 8:58 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171008085832.GB31408@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9991783/mbox/"
   >mbox</a>
|
   <a href="/patch/9991783/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9991783/">/patch/9991783/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	F033260231 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BE07C28650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id AC8BA28660; Sun,  8 Oct 2017 08:58:46 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9FB3B28650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753475AbdJHI6d (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 8 Oct 2017 04:58:33 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:32894 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751457AbdJHI6Z (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 8 Oct 2017 04:58:25 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id A17C297;
	Sun,  8 Oct 2017 08:58:23 +0000 (UTC)
Date: Sun, 8 Oct 2017 10:58:32 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.54
Message-ID: &lt;20171008085832.GB31408@kroah.com&gt;
References: &lt;20171008085823.GA31408@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171008085823.GA31408@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 8, 2017, 8:58 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..6ec1a880ac18</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
<span class="p_chunk">@@ -0,0 +1,46 @@</span> <span class="p_context"></span>
<span class="p_add">+THS8135 Video DAC</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+This is the binding for Texas Instruments THS8135 Video DAC bridge.</span>
<span class="p_add">+</span>
<span class="p_add">+Required properties:</span>
<span class="p_add">+</span>
<span class="p_add">+- compatible: Must be &quot;ti,ths8135&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+Required nodes:</span>
<span class="p_add">+</span>
<span class="p_add">+This device has two video ports. Their connections are modelled using the OF</span>
<span class="p_add">+graph bindings specified in Documentation/devicetree/bindings/graph.txt.</span>
<span class="p_add">+</span>
<span class="p_add">+- Video port 0 for RGB input</span>
<span class="p_add">+- Video port 1 for VGA output</span>
<span class="p_add">+</span>
<span class="p_add">+Example</span>
<span class="p_add">+-------</span>
<span class="p_add">+</span>
<span class="p_add">+vga-bridge {</span>
<span class="p_add">+	compatible = &quot;ti,ths8135&quot;;</span>
<span class="p_add">+	#address-cells = &lt;1&gt;;</span>
<span class="p_add">+	#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+	ports {</span>
<span class="p_add">+		#address-cells = &lt;1&gt;;</span>
<span class="p_add">+		#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+		port@0 {</span>
<span class="p_add">+			reg = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_in: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;lcdc_out_vga&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
<span class="p_add">+		port@1 {</span>
<span class="p_add">+			reg = &lt;1&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_out: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;vga_con_in&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt b/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..b3629405f568</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt</span>
<span class="p_chunk">@@ -0,0 +1,18 @@</span> <span class="p_context"></span>
<span class="p_add">+* AVIA HX711 ADC chip for weight cells</span>
<span class="p_add">+  Bit-banging driver</span>
<span class="p_add">+</span>
<span class="p_add">+Required properties:</span>
<span class="p_add">+ - compatible:	Should be &quot;avia,hx711&quot;</span>
<span class="p_add">+ - sck-gpios:	Definition of the GPIO for the clock</span>
<span class="p_add">+ - dout-gpios:	Definition of the GPIO for data-out</span>
<span class="p_add">+		See Documentation/devicetree/bindings/gpio/gpio.txt</span>
<span class="p_add">+ - avdd-supply:	Definition of the regulator used as analog supply</span>
<span class="p_add">+</span>
<span class="p_add">+Example:</span>
<span class="p_add">+weight@0 {</span>
<span class="p_add">+	compatible = &quot;avia,hx711&quot;;</span>
<span class="p_add">+	sck-gpios = &lt;&amp;gpio3 10 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	dout-gpios = &lt;&amp;gpio0 7 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	avdd-suppy = &lt;&amp;avdd&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_header">index f0a48ea78659..bceffffb7502 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> atmel	Atmel Corporation</span>
 auo	AU Optronics Corporation
 auvidea Auvidea GmbH
 avago	Avago Technologies
<span class="p_add">+avia	avia semiconductor</span>
 avic	Shanghai AVIC Optoelectronics Co., Ltd.
 axis	Axis Communications AB
 boe	BOE Technology Group Co., Ltd.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 98e3be659b21..8370937bbb22 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 53</span>
<span class="p_add">+SUBLEVEL = 54</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/Kconfig-nommu b/arch/arm/Kconfig-nommu</span>
<span class="p_header">index aed66d5df7f1..b7576349528c 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig-nommu</span>
<span class="p_header">+++ b/arch/arm/Kconfig-nommu</span>
<span class="p_chunk">@@ -34,8 +34,7 @@</span> <span class="p_context"> config PROCESSOR_ID</span>
 	  used instead of the auto-probing which utilizes the register.
 
 config REMAP_VECTORS_TO_RAM
<span class="p_del">-	bool &#39;Install vectors to the beginning of RAM&#39; if DRAM_BASE</span>
<span class="p_del">-	depends on DRAM_BASE</span>
<span class="p_add">+	bool &#39;Install vectors to the beginning of RAM&#39;</span>
 	help
 	  The kernel needs to change the hardware exception vectors.
 	  In nommu mode, the hardware exception vectors are normally
<span class="p_header">diff --git a/arch/arm/boot/dts/am335x-chilisom.dtsi b/arch/arm/boot/dts/am335x-chilisom.dtsi</span>
<span class="p_header">index f9ee5859c154..1b43ebd08b38 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am335x-chilisom.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am335x-chilisom.dtsi</span>
<span class="p_chunk">@@ -124,6 +124,14 @@</span> <span class="p_context"></span>
 
 &amp;rtc {
 	system-power-controller;
<span class="p_add">+</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;ext_wakeup&gt;;</span>
<span class="p_add">+	pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	ext_wakeup: ext-wakeup {</span>
<span class="p_add">+		pins = &quot;ext_wakeup0&quot;;</span>
<span class="p_add">+		input-enable;</span>
<span class="p_add">+	};</span>
 };
 
 /* NAND Flash */
<span class="p_header">diff --git a/arch/arm/boot/dts/bcm953012k.dts b/arch/arm/boot/dts/bcm953012k.dts</span>
<span class="p_header">index 05a985a20378..6208e85acd9d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/bcm953012k.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/bcm953012k.dts</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"></span>
 	};
 
 	memory {
<span class="p_del">-		reg = &lt;0x00000000 0x10000000&gt;;</span>
<span class="p_add">+		reg = &lt;0x80000000 0x10000000&gt;;</span>
 	};
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-odroid-common.dtsi b/arch/arm/boot/dts/exynos4412-odroid-common.dtsi</span>
<span class="p_header">index 8aa19ba14436..5282d69e55bd 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412-odroid-common.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-odroid-common.dtsi</span>
<span class="p_chunk">@@ -97,11 +97,11 @@</span> <span class="p_context"></span>
 	thermal-zones {
 		cpu_thermal: cpu-thermal {
 			cooling-maps {
<span class="p_del">-				map0 {</span>
<span class="p_add">+				cooling_map0: map0 {</span>
 				     /* Corresponds to 800MHz at freq_table */
 				     cooling-device = &lt;&amp;cpu0 7 7&gt;;
 				};
<span class="p_del">-				map1 {</span>
<span class="p_add">+				cooling_map1: map1 {</span>
 				     /* Corresponds to 200MHz at freq_table */
 				     cooling-device = &lt;&amp;cpu0 13 13&gt;;
 			       };
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-odroidu3.dts b/arch/arm/boot/dts/exynos4412-odroidu3.dts</span>
<span class="p_header">index 99634c54dca9..7504a5aa538e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412-odroidu3.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-odroidu3.dts</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 
 /dts-v1/;
 #include &quot;exynos4412-odroid-common.dtsi&quot;
<span class="p_add">+#include &quot;exynos4412-prime.dtsi&quot;</span>
 
 / {
 	model = &quot;Hardkernel ODROID-U3 board based on Exynos4412&quot;;
<span class="p_chunk">@@ -47,11 +48,11 @@</span> <span class="p_context"></span>
 			cooling-maps {
 				map0 {
 				     trip = &lt;&amp;cpu_alert1&gt;;
<span class="p_del">-				     cooling-device = &lt;&amp;cpu0 7 7&gt;;</span>
<span class="p_add">+				     cooling-device = &lt;&amp;cpu0 9 9&gt;;</span>
 				};
 				map1 {
 				     trip = &lt;&amp;cpu_alert2&gt;;
<span class="p_del">-				     cooling-device = &lt;&amp;cpu0 13 13&gt;;</span>
<span class="p_add">+				     cooling-device = &lt;&amp;cpu0 15 15&gt;;</span>
 				};
 				map2 {
 				     trip = &lt;&amp;cpu_alert0&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-odroidx2.dts b/arch/arm/boot/dts/exynos4412-odroidx2.dts</span>
<span class="p_header">index 4d228858f172..d6e92ebc3874 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412-odroidx2.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-odroidx2.dts</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 */
 
 #include &quot;exynos4412-odroidx.dts&quot;
<span class="p_add">+#include &quot;exynos4412-prime.dtsi&quot;</span>
 
 / {
 	model = &quot;Hardkernel ODROID-X2 board based on Exynos4412&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-prime.dtsi b/arch/arm/boot/dts/exynos4412-prime.dtsi</span>
new file mode 100644
<span class="p_header">index 000000000000..e75bc170c89c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-prime.dtsi</span>
<span class="p_chunk">@@ -0,0 +1,41 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Samsung&#39;s Exynos4412 Prime SoC device tree source</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (c) 2016 Samsung Electronics Co., Ltd.</span>
<span class="p_add">+ *		http://www.samsung.com</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Exynos4412 Prime SoC revision supports higher CPU frequencies than</span>
<span class="p_add">+ * non-Prime version.  Therefore we need to update OPPs table and</span>
<span class="p_add">+ * thermal maps accordingly.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+&amp;cpu0_opp_1500 {</span>
<span class="p_add">+	/delete-property/turbo-mode;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+&amp;cpu0_opp_table {</span>
<span class="p_add">+	opp@1600000000 {</span>
<span class="p_add">+		opp-hz = /bits/ 64 &lt;1600000000&gt;;</span>
<span class="p_add">+		opp-microvolt = &lt;1350000&gt;;</span>
<span class="p_add">+		clock-latency-ns = &lt;200000&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+	opp@1704000000 {</span>
<span class="p_add">+		opp-hz = /bits/ 64 &lt;1704000000&gt;;</span>
<span class="p_add">+		opp-microvolt = &lt;1350000&gt;;</span>
<span class="p_add">+		clock-latency-ns = &lt;200000&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+&amp;cooling_map0 {</span>
<span class="p_add">+	cooling-device = &lt;&amp;cpu0 9 9&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+&amp;cooling_map1 {</span>
<span class="p_add">+	cooling-device = &lt;&amp;cpu0 15 15&gt;;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412.dtsi b/arch/arm/boot/dts/exynos4412.dtsi</span>
<span class="p_header">index 40beede46e55..3ebdf01d814c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412.dtsi</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"></span>
 			opp-microvolt = &lt;1287500&gt;;
 			clock-latency-ns = &lt;200000&gt;;
 		};
<span class="p_del">-		opp@1500000000 {</span>
<span class="p_add">+		cpu0_opp_1500: opp@1500000000 {</span>
 			opp-hz = /bits/ 64 &lt;1500000000&gt;;
 			opp-microvolt = &lt;1350000&gt;;
 			clock-latency-ns = &lt;200000&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/mt2701.dtsi b/arch/arm/boot/dts/mt2701.dtsi</span>
<span class="p_header">index 18596a2c58a1..77c6b931dc24 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/mt2701.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/mt2701.dtsi</span>
<span class="p_chunk">@@ -174,4 +174,40 @@</span> <span class="p_context"></span>
 		clocks = &lt;&amp;uart_clk&gt;;
 		status = &quot;disabled&quot;;
 	};
<span class="p_add">+</span>
<span class="p_add">+	mmsys: syscon@14000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-mmsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x14000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	imgsys: syscon@15000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-imgsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x15000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	vdecsys: syscon@16000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-vdecsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x16000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	hifsys: syscon@1a000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-hifsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x1a000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	ethsys: syscon@1b000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-ethsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x1b000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	bdpsys: syscon@1c000000 {</span>
<span class="p_add">+		compatible = &quot;mediatek,mt2701-bdpsys&quot;, &quot;syscon&quot;;</span>
<span class="p_add">+		reg = &lt;0 0x1c000000 0 0x1000&gt;;</span>
<span class="p_add">+		#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+	};</span>
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7790.dtsi b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">index 351fcc2f87df..b6c6410ca384 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_chunk">@@ -1493,7 +1493,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof0: spi@e6e20000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e20000 0 0x0064&gt;;
 		interrupts = &lt;GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp0_clks R8A7790_CLK_MSIOF0&gt;;
<span class="p_chunk">@@ -1507,7 +1508,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof1: spi@e6e10000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e10000 0 0x0064&gt;;
 		interrupts = &lt;GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF1&gt;;
<span class="p_chunk">@@ -1521,7 +1523,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof2: spi@e6e00000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e00000 0 0x0064&gt;;
 		interrupts = &lt;GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF2&gt;;
<span class="p_chunk">@@ -1535,7 +1538,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof3: spi@e6c90000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6c90000 0 0x0064&gt;;
 		interrupts = &lt;GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF3&gt;;
<span class="p_header">diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c</span>
<span class="p_header">index 31dde8b6f2ea..8ba0e2e5ad97 100644</span>
<span class="p_header">--- a/arch/arm/mach-at91/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-at91/pm.c</span>
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> static void at91sam9_sdram_standby(void)</span>
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
<span class="p_del">-static const struct of_device_id const ramc_ids[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id ramc_ids[] __initconst = {</span>
 	{ .compatible = &quot;atmel,at91rm9200-sdramc&quot;, .data = at91rm9200_standby },
 	{ .compatible = &quot;atmel,at91sam9260-sdramc&quot;, .data = at91sam9_sdram_standby },
 	{ .compatible = &quot;atmel,at91sam9g45-ddramc&quot;, .data = at91_ddr_standby },
<span class="p_header">diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_header">index cf3f8658f0e5..a55a7ecf146a 100644</span>
<span class="p_header">--- a/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_header">+++ b/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> struct bcm_kona_smc_data {</span>
 	unsigned result;
 };
 
<span class="p_del">-static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id bcm_kona_smc_ids[] __initconst = {</span>
 	{.compatible = &quot;brcm,kona-smc&quot;},
 	{.compatible = &quot;bcm,kona-smc&quot;}, /* deprecated name */
 	{},
<span class="p_header">diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_header">index 03da3813f1ab..7d5a44a06648 100644</span>
<span class="p_header">--- a/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_header">+++ b/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {</span>
 	.power_off	= csn3xxx_usb_power_off,
 };
 
<span class="p_del">-static const struct of_dev_auxdata const cns3xxx_auxdata[] __initconst = {</span>
<span class="p_add">+static const struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {</span>
 	{ &quot;intel,usb-ehci&quot;, CNS3XXX_USB_BASE, &quot;ehci-platform&quot;, &amp;cns3xxx_usb_ehci_pdata },
 	{ &quot;intel,usb-ohci&quot;, CNS3XXX_USB_OHCI_BASE, &quot;ohci-platform&quot;, &amp;cns3xxx_usb_ohci_pdata },
 	{ &quot;cavium,cns3420-ahci&quot;, CNS3XXX_SATA2_BASE, &quot;ahci&quot;, NULL },
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_header">index 5b2f5138d938..f1ca9479491b 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_chunk">@@ -713,7 +713,7 @@</span> <span class="p_context"> static struct omap_prcm_init_data scrm_data __initdata = {</span>
 };
 #endif
 
<span class="p_del">-static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {</span>
 #ifdef CONFIG_SOC_AM33XX
 	{ .compatible = &quot;ti,am3-prcm&quot;, .data = &amp;am3_prm_data },
 #endif
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">index 2028167fff31..d76b1e5eb8ba 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.c</span>
<span class="p_chunk">@@ -559,7 +559,7 @@</span> <span class="p_context"> struct i2c_init_data {</span>
 	u8 hsscll_12;
 };
 
<span class="p_del">-static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {</span>
<span class="p_add">+static const struct i2c_init_data omap4_i2c_timing_data[] __initconst = {</span>
 	{
 		.load = 50,
 		.loadbits = 0x3,
<span class="p_header">diff --git a/arch/arm/mach-spear/time.c b/arch/arm/mach-spear/time.c</span>
<span class="p_header">index 9ccffc1d0f28..aaaa6781b9fe 100644</span>
<span class="p_header">--- a/arch/arm/mach-spear/time.c</span>
<span class="p_header">+++ b/arch/arm/mach-spear/time.c</span>
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> static void __init spear_clockevent_init(int irq)</span>
 	setup_irq(irq, &amp;spear_timer_irq);
 }
 
<span class="p_del">-static const struct of_device_id const timer_of_match[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id timer_of_match[] __initconst = {</span>
 	{ .compatible = &quot;st,spear-timer&quot;, },
 	{ },
 };
<span class="p_header">diff --git a/arch/mips/ath79/clock.c b/arch/mips/ath79/clock.c</span>
<span class="p_header">index cc3a1e33a600..7e2bb12b64ea 100644</span>
<span class="p_header">--- a/arch/mips/ath79/clock.c</span>
<span class="p_header">+++ b/arch/mips/ath79/clock.c</span>
<span class="p_chunk">@@ -508,16 +508,19 @@</span> <span class="p_context"> static void __init ath79_clocks_init_dt_ng(struct device_node *np)</span>
 		ar9330_clk_init(ref_clk, pll_base);
 	else {
 		pr_err(&quot;%s: could not find any appropriate clk_init()\n&quot;, dnfn);
<span class="p_del">-		goto err_clk;</span>
<span class="p_add">+		goto err_iounmap;</span>
 	}
 
 	if (of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data)) {
 		pr_err(&quot;%s: could not register clk provider\n&quot;, dnfn);
<span class="p_del">-		goto err_clk;</span>
<span class="p_add">+		goto err_iounmap;</span>
 	}
 
 	return;
 
<span class="p_add">+err_iounmap:</span>
<span class="p_add">+	iounmap(pll_base);</span>
<span class="p_add">+</span>
 err_clk:
 	clk_put(ref_clk);
 
<span class="p_header">diff --git a/arch/mips/include/asm/irq.h b/arch/mips/include/asm/irq.h</span>
<span class="p_header">index 956db6e201d1..ddd1c918103b 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/irq.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/irq.h</span>
<span class="p_chunk">@@ -18,9 +18,24 @@</span> <span class="p_context"></span>
 #include &lt;irq.h&gt;
 
 #define IRQ_STACK_SIZE			THREAD_SIZE
<span class="p_add">+#define IRQ_STACK_START			(IRQ_STACK_SIZE - sizeof(unsigned long))</span>
 
 extern void *irq_stack[NR_CPUS];
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The highest address on the IRQ stack contains a dummy frame put down in</span>
<span class="p_add">+ * genex.S (handle_int &amp; except_vec_vi_handler) which is structured as follows:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   top ------------</span>
<span class="p_add">+ *       | task sp  | &lt;- irq_stack[cpu] + IRQ_STACK_START</span>
<span class="p_add">+ *       ------------</span>
<span class="p_add">+ *       |          | &lt;- First frame of IRQ context</span>
<span class="p_add">+ *       ------------</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * task sp holds a copy of the task stack pointer where the struct pt_regs</span>
<span class="p_add">+ * from exception entry can be found.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline bool on_irq_stack(int cpu, unsigned long sp)
 {
 	unsigned long low = (unsigned long)irq_stack[cpu];
<span class="p_header">diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c</span>
<span class="p_header">index 4be2763f835d..bfff6ea45d51 100644</span>
<span class="p_header">--- a/arch/mips/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/mips/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -103,6 +103,7 @@</span> <span class="p_context"> void output_thread_info_defines(void)</span>
 	DEFINE(_THREAD_SIZE, THREAD_SIZE);
 	DEFINE(_THREAD_MASK, THREAD_MASK);
 	DEFINE(_IRQ_STACK_SIZE, IRQ_STACK_SIZE);
<span class="p_add">+	DEFINE(_IRQ_STACK_START, IRQ_STACK_START);</span>
 	BLANK();
 }
 
<span class="p_header">diff --git a/arch/mips/kernel/cps-vec.S b/arch/mips/kernel/cps-vec.S</span>
<span class="p_header">index 59476a607add..a00e87b0256d 100644</span>
<span class="p_header">--- a/arch/mips/kernel/cps-vec.S</span>
<span class="p_header">+++ b/arch/mips/kernel/cps-vec.S</span>
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> LEAF(mips_cps_get_bootcfg)</span>
 	END(mips_cps_get_bootcfg)
 
 LEAF(mips_cps_boot_vpes)
<span class="p_del">-	PTR_L	ta2, COREBOOTCFG_VPEMASK(a0)</span>
<span class="p_add">+	lw	ta2, COREBOOTCFG_VPEMASK(a0)</span>
 	PTR_L	ta3, COREBOOTCFG_VPECONFIG(a0)
 
 #if defined(CONFIG_CPU_MIPSR6)
<span class="p_header">diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S</span>
<span class="p_header">index 2ac6c2625c13..ae810da4d499 100644</span>
<span class="p_header">--- a/arch/mips/kernel/genex.S</span>
<span class="p_header">+++ b/arch/mips/kernel/genex.S</span>
<span class="p_chunk">@@ -215,9 +215,11 @@</span> <span class="p_context"> NESTED(handle_int, PT_SIZE, sp)</span>
 	beq	t0, t1, 2f
 
 	/* Switch to IRQ stack */
<span class="p_del">-	li	t1, _IRQ_STACK_SIZE</span>
<span class="p_add">+	li	t1, _IRQ_STACK_START</span>
 	PTR_ADD sp, t0, t1
 
<span class="p_add">+	/* Save task&#39;s sp on IRQ stack so that unwinding can follow it */</span>
<span class="p_add">+	LONG_S	s1, 0(sp)</span>
 2:
 	jal	plat_irq_dispatch
 
<span class="p_chunk">@@ -325,9 +327,11 @@</span> <span class="p_context"> NESTED(except_vec_vi_handler, 0, sp)</span>
 	beq	t0, t1, 2f
 
 	/* Switch to IRQ stack */
<span class="p_del">-	li	t1, _IRQ_STACK_SIZE</span>
<span class="p_add">+	li	t1, _IRQ_STACK_START</span>
 	PTR_ADD sp, t0, t1
 
<span class="p_add">+	/* Save task&#39;s sp on IRQ stack so that unwinding can follow it */</span>
<span class="p_add">+	LONG_S	s1, 0(sp)</span>
 2:
 	jalr	v0
 
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index fbbf5fcc695a..1b50958a1373 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -487,31 +487,52 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 					      unsigned long pc,
 					      unsigned long *ra)
 {
<span class="p_add">+	unsigned long low, high, irq_stack_high;</span>
 	struct mips_frame_info info;
 	unsigned long size, ofs;
<span class="p_add">+	struct pt_regs *regs;</span>
 	int leaf;
<span class="p_del">-	extern void ret_from_irq(void);</span>
<span class="p_del">-	extern void ret_from_exception(void);</span>
 
 	if (!stack_page)
 		return 0;
 
 	/*
<span class="p_del">-	 * If we reached the bottom of interrupt context,</span>
<span class="p_del">-	 * return saved pc in pt_regs.</span>
<span class="p_add">+	 * IRQ stacks start at IRQ_STACK_START</span>
<span class="p_add">+	 * task stacks at THREAD_SIZE - 32</span>
 	 */
<span class="p_del">-	if (pc == (unsigned long)ret_from_irq ||</span>
<span class="p_del">-	    pc == (unsigned long)ret_from_exception) {</span>
<span class="p_del">-		struct pt_regs *regs;</span>
<span class="p_del">-		if (*sp &gt;= stack_page &amp;&amp;</span>
<span class="p_del">-		    *sp + sizeof(*regs) &lt;= stack_page + THREAD_SIZE - 32) {</span>
<span class="p_del">-			regs = (struct pt_regs *)*sp;</span>
<span class="p_del">-			pc = regs-&gt;cp0_epc;</span>
<span class="p_del">-			if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
<span class="p_del">-				*sp = regs-&gt;regs[29];</span>
<span class="p_del">-				*ra = regs-&gt;regs[31];</span>
<span class="p_del">-				return pc;</span>
<span class="p_del">-			}</span>
<span class="p_add">+	low = stack_page;</span>
<span class="p_add">+	if (!preemptible() &amp;&amp; on_irq_stack(raw_smp_processor_id(), *sp)) {</span>
<span class="p_add">+		high = stack_page + IRQ_STACK_START;</span>
<span class="p_add">+		irq_stack_high = high;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		high = stack_page + THREAD_SIZE - 32;</span>
<span class="p_add">+		irq_stack_high = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we reached the top of the interrupt stack, start unwinding</span>
<span class="p_add">+	 * the interrupted task stack.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(*sp == irq_stack_high)) {</span>
<span class="p_add">+		unsigned long task_sp = *(unsigned long *)*sp;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check that the pointer saved in the IRQ stack head points to</span>
<span class="p_add">+		 * something within the stack of the current task</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!object_is_on_stack((void *)task_sp))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Follow pointer to tasks kernel stack frame where interrupted</span>
<span class="p_add">+		 * state was saved.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regs = (struct pt_regs *)task_sp;</span>
<span class="p_add">+		pc = regs-&gt;cp0_epc;</span>
<span class="p_add">+		if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
<span class="p_add">+			*sp = regs-&gt;regs[29];</span>
<span class="p_add">+			*ra = regs-&gt;regs[31];</span>
<span class="p_add">+			return pc;</span>
 		}
 		return 0;
 	}
<span class="p_chunk">@@ -532,8 +553,7 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 	if (leaf &lt; 0)
 		return 0;
 
<span class="p_del">-	if (*sp &lt; stack_page ||</span>
<span class="p_del">-	    *sp + info.frame_size &gt; stack_page + THREAD_SIZE - 32)</span>
<span class="p_add">+	if (*sp &lt; low || *sp + info.frame_size &gt; high)</span>
 		return 0;
 
 	if (leaf)
<span class="p_header">diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">index d5de67591735..f0a0e6d62be3 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> SECTIONS</span>
 	 * Force .bss to 64K alignment so that .bss..swapper_pg_dir
 	 * gets that alignment.	 .sbss should be empty, so there will be
 	 * no holes after __init_end. */
<span class="p_del">-	BSS_SECTION(0, 0x10000, 0)</span>
<span class="p_add">+	BSS_SECTION(0, 0x10000, 8)</span>
 
 	_end = . ;
 
<span class="p_header">diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">index 90565477dfbd..95bec460b651 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_chunk">@@ -469,8 +469,8 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 			panic(&quot;Failed to load xbar nodes from devicetree&quot;);
 		if (of_address_to_resource(np_xbar, 0, &amp;res_xbar))
 			panic(&quot;Failed to get xbar resources&quot;);
<span class="p_del">-		if (request_mem_region(res_xbar.start, resource_size(&amp;res_xbar),</span>
<span class="p_del">-			res_xbar.name) &lt; 0)</span>
<span class="p_add">+		if (!request_mem_region(res_xbar.start, resource_size(&amp;res_xbar),</span>
<span class="p_add">+			res_xbar.name))</span>
 			panic(&quot;Failed to get xbar resources&quot;);
 
 		ltq_xbar_membase = ioremap_nocache(res_xbar.start,
<span class="p_header">diff --git a/arch/mips/ralink/mt7620.c b/arch/mips/ralink/mt7620.c</span>
<span class="p_header">index 3c7c9bf57bf3..6f892c1f3ad7 100644</span>
<span class="p_header">--- a/arch/mips/ralink/mt7620.c</span>
<span class="p_header">+++ b/arch/mips/ralink/mt7620.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> static struct rt2880_pmx_func spi_cs1_grp_mt7628[] = {</span>
 
 static struct rt2880_pmx_func spis_grp_mt7628[] = {
 	FUNC(&quot;pwm_uart2&quot;, 3, 14, 4),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 14, 4),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 14, 4),</span>
 	FUNC(&quot;gpio&quot;, 1, 14, 4),
 	FUNC(&quot;spis&quot;, 0, 14, 4),
 };
<span class="p_chunk">@@ -190,28 +190,28 @@</span> <span class="p_context"> static struct rt2880_pmx_func gpio_grp_mt7628[] = {</span>
 
 static struct rt2880_pmx_func p4led_kn_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 30, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 30, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 30, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 30, 1),
 	FUNC(&quot;p4led_kn&quot;, 0, 30, 1),
 };
 
 static struct rt2880_pmx_func p3led_kn_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 31, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 31, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 31, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 31, 1),
 	FUNC(&quot;p3led_kn&quot;, 0, 31, 1),
 };
 
 static struct rt2880_pmx_func p2led_kn_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 32, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 32, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 32, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 32, 1),
 	FUNC(&quot;p2led_kn&quot;, 0, 32, 1),
 };
 
 static struct rt2880_pmx_func p1led_kn_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 33, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 33, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 33, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 33, 1),
 	FUNC(&quot;p1led_kn&quot;, 0, 33, 1),
 };
<span class="p_chunk">@@ -232,28 +232,28 @@</span> <span class="p_context"> static struct rt2880_pmx_func wled_kn_grp_mt7628[] = {</span>
 
 static struct rt2880_pmx_func p4led_an_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 39, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 39, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 39, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 39, 1),
 	FUNC(&quot;p4led_an&quot;, 0, 39, 1),
 };
 
 static struct rt2880_pmx_func p3led_an_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 40, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 40, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 40, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 40, 1),
 	FUNC(&quot;p3led_an&quot;, 0, 40, 1),
 };
 
 static struct rt2880_pmx_func p2led_an_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 41, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 41, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 41, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 41, 1),
 	FUNC(&quot;p2led_an&quot;, 0, 41, 1),
 };
 
 static struct rt2880_pmx_func p1led_an_grp_mt7628[] = {
 	FUNC(&quot;jtag&quot;, 3, 42, 1),
<span class="p_del">-	FUNC(&quot;util&quot;, 2, 42, 1),</span>
<span class="p_add">+	FUNC(&quot;utif&quot;, 2, 42, 1),</span>
 	FUNC(&quot;gpio&quot;, 1, 42, 1),
 	FUNC(&quot;p1led_an&quot;, 0, 42, 1),
 };
<span class="p_header">diff --git a/arch/mips/ralink/rt3883.c b/arch/mips/ralink/rt3883.c</span>
<span class="p_header">index 9e4631acfcb5..3e68e35daf21 100644</span>
<span class="p_header">--- a/arch/mips/ralink/rt3883.c</span>
<span class="p_header">+++ b/arch/mips/ralink/rt3883.c</span>
<span class="p_chunk">@@ -145,5 +145,5 @@</span> <span class="p_context"> void prom_soc_init(struct ralink_soc_info *soc_info)</span>
 
 	rt2880_pinmux_data = rt3883_pinmux_data;
 
<span class="p_del">-	ralink_soc == RT3883_SOC;</span>
<span class="p_add">+	ralink_soc = RT3883_SOC;</span>
 }
<span class="p_header">diff --git a/arch/parisc/kernel/perf.c b/arch/parisc/kernel/perf.c</span>
<span class="p_header">index 518f4f5f1f43..d63d42533133 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/perf.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/perf.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"></span>
  *  the PDC INTRIGUE calls.  This is done to eliminate bugs introduced
  *  in various PDC revisions.  The code is much more maintainable
  *  and reliable this way vs having to debug on every version of PDC
<span class="p_del">- *  on every box. </span>
<span class="p_add">+ *  on every box.</span>
  */
 
 #include &lt;linux/capability.h&gt;
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr);</span>
 static int perf_release(struct inode *inode, struct file *file);
 static int perf_open(struct inode *inode, struct file *file);
 static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t *ppos);
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos);</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos);</span>
 static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 static void perf_start_counters(void);
 static int perf_stop_counters(uint32_t *raddr);
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> extern void perf_intrigue_disable_perf_counters (void);</span>
 /*
  * configure:
  *
<span class="p_del">- * Configure the cpu with a given data image.  First turn off the counters, </span>
<span class="p_add">+ * Configure the cpu with a given data image.  First turn off the counters,</span>
  * then download the image, then turn the counters back on.
  */
 static int perf_config(uint32_t *image_ptr)
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr)</span>
 	error = perf_stop_counters(raddr);
 	if (error != 0) {
 		printk(&quot;perf_config: perf_stop_counters = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to write image\n&quot;);
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> printk(&quot;Preparing to write image\n&quot;);</span>
 	error = perf_write_image((uint64_t *)image_ptr);
 	if (error != 0) {
 		printk(&quot;perf_config: DOWNLOAD = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to start counters\n&quot;);
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> printk(&quot;Preparing to start counters\n&quot;);</span>
 }
 
 /*
<span class="p_del">- * Open the device and initialize all of its memory.  The device is only </span>
<span class="p_add">+ * Open the device and initialize all of its memory.  The device is only</span>
  * opened once, but can be &quot;queried&quot; by multiple processes that know its
  * file descriptor.
  */
<span class="p_chunk">@@ -298,8 +298,8 @@</span> <span class="p_context"> static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t</span>
  * called on the processor that the download should happen
  * on.
  */
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos)</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos)</span>
 {
 	int err;
 	size_t image_size;
<span class="p_chunk">@@ -307,11 +307,11 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 	uint32_t interface_type;
 	uint32_t test;
 
<span class="p_del">-	if (perf_processor_interface == ONYX_INTF) </span>
<span class="p_add">+	if (perf_processor_interface == ONYX_INTF)</span>
 		image_size = PCXU_IMAGE_SIZE;
<span class="p_del">-	else if (perf_processor_interface == CUDA_INTF) </span>
<span class="p_add">+	else if (perf_processor_interface == CUDA_INTF)</span>
 		image_size = PCXW_IMAGE_SIZE;
<span class="p_del">-	else </span>
<span class="p_add">+	else</span>
 		return -EFAULT;
 
 	if (!capable(CAP_SYS_ADMIN))
<span class="p_chunk">@@ -331,22 +331,22 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 
 	/* First check the machine type is correct for
 	   the requested image */
<span class="p_del">-        if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_del">-		       (interface_type != CUDA_INTF)) ||</span>
<span class="p_del">-	    ((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_del">-	               (interface_type != ONYX_INTF))) </span>
<span class="p_add">+	if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != CUDA_INTF)) ||</span>
<span class="p_add">+		((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != ONYX_INTF)))</span>
 		return -EINVAL;
 
 	/* Next check to make sure the requested image
 	   is valid */
<span class="p_del">-	if (((interface_type == CUDA_INTF) &amp;&amp; </span>
<span class="p_add">+	if (((interface_type == CUDA_INTF) &amp;&amp;</span>
 		       (test &gt;= MAX_CUDA_IMAGES)) ||
<span class="p_del">-	    ((interface_type == ONYX_INTF) &amp;&amp; </span>
<span class="p_del">-		       (test &gt;= MAX_ONYX_IMAGES))) </span>
<span class="p_add">+	    ((interface_type == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+		       (test &gt;= MAX_ONYX_IMAGES)))</span>
 		return -EINVAL;
 
 	/* Copy the image into the processor */
<span class="p_del">-	if (interface_type == CUDA_INTF) </span>
<span class="p_add">+	if (interface_type == CUDA_INTF)</span>
 		return perf_config(cuda_images[test]);
 	else
 		return perf_config(onyx_images[test]);
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 static void perf_patch_images(void)
 {
 #if 0 /* FIXME!! */
<span class="p_del">-/* </span>
<span class="p_add">+/*</span>
  * NOTE:  this routine is VERY specific to the current TLB image.
  * If the image is changed, this routine might also need to be changed.
  */
<span class="p_chunk">@@ -368,9 +368,9 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 	extern void $i_dtlb_miss_2_0();
 	extern void PA2_0_iva();
 
<span class="p_del">-	/* </span>
<span class="p_add">+	/*</span>
 	 * We can only use the lower 32-bits, the upper 32-bits should be 0
<span class="p_del">-	 * anyway given this is in the kernel </span>
<span class="p_add">+	 * anyway given this is in the kernel</span>
 	 */
 	uint32_t itlb_addr  = (uint32_t)&amp;($i_itlb_miss_2_0);
 	uint32_t dtlb_addr  = (uint32_t)&amp;($i_dtlb_miss_2_0);
<span class="p_chunk">@@ -378,21 +378,21 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	if (perf_processor_interface == ONYX_INTF) {
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBHANDMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBHANDMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBHANDMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[BIG_CPI][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[BIG_CPI][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
<span class="p_chunk">@@ -405,24 +405,24 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	} else if (perf_processor_interface == CUDA_INTF) {
 		/* Cuda interface */
<span class="p_del">-		cuda_images[TLBMISS][16] =  </span>
<span class="p_add">+		cuda_images[TLBMISS][16] =</span>
 			(cuda_images[TLBMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[TLBHANDMISS][16] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][16] =</span>
 			(cuda_images[TLBHANDMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBHANDMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBHANDMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[BIG_CPI][16] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][16] =</span>
 			(cuda_images[BIG_CPI][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[BIG_CPI][17] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[BIG_CPI][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 	} else {
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 /*
  * ioctl routine
<span class="p_del">- * All routines effect the processor that they are executed on.  Thus you </span>
<span class="p_add">+ * All routines effect the processor that they are executed on.  Thus you</span>
  * must be running on the processor that you wish to change.
  */
 
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 			}
 
 			/* copy out the Counters */
<span class="p_del">-			if (copy_to_user((void __user *)arg, raddr, </span>
<span class="p_add">+			if (copy_to_user((void __user *)arg, raddr,</span>
 					sizeof (raddr)) != 0) {
 				error =  -EFAULT;
 				break;
<span class="p_chunk">@@ -488,7 +488,7 @@</span> <span class="p_context"> static const struct file_operations perf_fops = {</span>
 	.open = perf_open,
 	.release = perf_release
 };
<span class="p_del">-	</span>
<span class="p_add">+</span>
 static struct miscdevice perf_dev = {
 	MISC_DYNAMIC_MINOR,
 	PA_PERF_DEV,
<span class="p_chunk">@@ -596,7 +596,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		/* OR sticky2 (bit 1496) to counter2 bit 32 */
 		tmp64 |= (userbuf[23] &gt;&gt; 8) &amp; 0x0000000080000000;
 		raddr[2] = (uint32_t)tmp64;
<span class="p_del">-		</span>
<span class="p_add">+</span>
 		/* Counter3 is bits 1497 to 1528 */
 		tmp64 =  (userbuf[23] &gt;&gt; 7) &amp; 0x00000000ffffffff;
 		/* OR sticky3 (bit 1529) to counter3 bit 32 */
<span class="p_chunk">@@ -618,7 +618,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		userbuf[22] = 0;
 		userbuf[23] = 0;
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Write back the zeroed bytes + the image given
 		 * the read was destructive.
 		 */
<span class="p_chunk">@@ -626,13 +626,13 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 	} else {
 
 		/*
<span class="p_del">-		 * Read RDR-15 which contains the counters and sticky bits </span>
<span class="p_add">+		 * Read RDR-15 which contains the counters and sticky bits</span>
 		 */
 		if (!perf_rdr_read_ubuf(15, userbuf)) {
 			return -13;
 		}
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Clear out the counters
 		 */
 		perf_rdr_clear(15);
<span class="p_chunk">@@ -645,7 +645,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		raddr[2] = (uint32_t)((userbuf[1] &gt;&gt; 32) &amp; 0x00000000ffffffffUL);
 		raddr[3] = (uint32_t)(userbuf[1] &amp; 0x00000000ffffffffUL);
 	}
<span class="p_del">- </span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> static int perf_rdr_read_ubuf(uint32_t	rdr_num, uint64_t *buffer)</span>
 	i = tentry-&gt;num_words;
 	while (i--) {
 		buffer[i] = 0;
<span class="p_del">-	}	</span>
<span class="p_add">+	}</span>
 
 	/* Check for bits an even number of 64 */
 	if ((xbits = width &amp; 0x03f) != 0) {
<span class="p_chunk">@@ -809,18 +809,22 @@</span> <span class="p_context"> static int perf_write_image(uint64_t *memaddr)</span>
 	}
 
 	runway = ioremap_nocache(cpu_device-&gt;hpa.start, 4096);
<span class="p_add">+	if (!runway) {</span>
<span class="p_add">+		pr_err(&quot;perf_write_image: ioremap failed!\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
 	/* Merge intrigue bits into Runway STATUS 0 */
 	tmp64 = __raw_readq(runway + RUNWAY_STATUS) &amp; 0xffecfffffffffffful;
<span class="p_del">-	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul), </span>
<span class="p_add">+	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul),</span>
 		     runway + RUNWAY_STATUS);
<span class="p_del">-	</span>
<span class="p_add">+</span>
 	/* Write RUNWAY DEBUG registers */
 	for (i = 0; i &lt; 8; i++) {
 		__raw_writeq(*memaddr++, runway + RUNWAY_DEBUG);
 	}
 
<span class="p_del">-	return 0; </span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -844,7 +848,7 @@</span> <span class="p_context"> printk(&quot;perf_rdr_write\n&quot;);</span>
 			perf_rdr_shift_out_U(rdr_num, buffer[i]);
 		} else {
 			perf_rdr_shift_out_W(rdr_num, buffer[i]);
<span class="p_del">-		}	</span>
<span class="p_add">+		}</span>
 	}
 printk(&quot;perf_rdr_write done\n&quot;);
 }
<span class="p_header">diff --git a/arch/s390/include/asm/pgtable.h b/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">index d33f245af5e9..db74d398a443 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -1359,7 +1359,9 @@</span> <span class="p_context"> static inline pmd_t pmdp_huge_clear_flush(struct vm_area_struct *vma,</span>
 static inline void pmdp_invalidate(struct vm_area_struct *vma,
 				   unsigned long addr, pmd_t *pmdp)
 {
<span class="p_del">-	pmdp_xchg_direct(vma-&gt;vm_mm, addr, pmdp, __pmd(_SEGMENT_ENTRY_INVALID));</span>
<span class="p_add">+	pmd_t pmd = __pmd(pmd_val(*pmdp) | _SEGMENT_ENTRY_INVALID);</span>
<span class="p_add">+</span>
<span class="p_add">+	pmdp_xchg_direct(vma-&gt;vm_mm, addr, pmdp, pmd);</span>
 }
 
 #define __HAVE_ARCH_PMDP_SET_WRPROTECT
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index d3e0d049a0c2..b89bef95f63b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -176,10 +176,15 @@</span> <span class="p_context"> static int acpi_register_lapic(int id, u32 acpiid, u8 enabled)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (!enabled) {</span>
<span class="p_add">+		++disabled_cpus;</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (boot_cpu_physical_apicid != -1U)
 		ver = boot_cpu_apic_version;
 
<span class="p_del">-	cpu = __generic_processor_info(id, ver, enabled);</span>
<span class="p_add">+	cpu = generic_processor_info(id, ver);</span>
 	if (cpu &gt;= 0)
 		early_per_cpu(x86_cpu_to_acpiid, cpu) = acpiid;
 
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index f2234918e494..e2ead34da465 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -2070,7 +2070,7 @@</span> <span class="p_context"> static int allocate_logical_cpuid(int apicid)</span>
 	return nr_logical_cpuids++;
 }
 
<span class="p_del">-int __generic_processor_info(int apicid, int version, bool enabled)</span>
<span class="p_add">+int generic_processor_info(int apicid, int version)</span>
 {
 	int cpu, max = nr_cpu_ids;
 	bool boot_cpu_detected = physid_isset(boot_cpu_physical_apicid,
<span class="p_chunk">@@ -2128,11 +2128,9 @@</span> <span class="p_context"> int __generic_processor_info(int apicid, int version, bool enabled)</span>
 	if (num_processors &gt;= nr_cpu_ids) {
 		int thiscpu = max + disabled_cpus;
 
<span class="p_del">-		if (enabled) {</span>
<span class="p_del">-			pr_warning(&quot;APIC: NR_CPUS/possible_cpus limit of %i &quot;</span>
<span class="p_del">-				   &quot;reached. Processor %d/0x%x ignored.\n&quot;,</span>
<span class="p_del">-				   max, thiscpu, apicid);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		pr_warning(&quot;APIC: NR_CPUS/possible_cpus limit of %i &quot;</span>
<span class="p_add">+			   &quot;reached. Processor %d/0x%x ignored.\n&quot;,</span>
<span class="p_add">+			   max, thiscpu, apicid);</span>
 
 		disabled_cpus++;
 		return -EINVAL;
<span class="p_chunk">@@ -2184,23 +2182,13 @@</span> <span class="p_context"> int __generic_processor_info(int apicid, int version, bool enabled)</span>
 		apic-&gt;x86_32_early_logical_apicid(cpu);
 #endif
 	set_cpu_possible(cpu, true);
<span class="p_del">-</span>
<span class="p_del">-	if (enabled) {</span>
<span class="p_del">-		num_processors++;</span>
<span class="p_del">-		physid_set(apicid, phys_cpu_present_map);</span>
<span class="p_del">-		set_cpu_present(cpu, true);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		disabled_cpus++;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	physid_set(apicid, phys_cpu_present_map);</span>
<span class="p_add">+	set_cpu_present(cpu, true);</span>
<span class="p_add">+	num_processors++;</span>
 
 	return cpu;
 }
 
<span class="p_del">-int generic_processor_info(int apicid, int version)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __generic_processor_info(apicid, version, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int hard_smp_processor_id(void)
 {
 	return read_apic_id();
<span class="p_header">diff --git a/arch/x86/purgatory/Makefile b/arch/x86/purgatory/Makefile</span>
<span class="p_header">index 555b9fa0ad43..7dbdb780264d 100644</span>
<span class="p_header">--- a/arch/x86/purgatory/Makefile</span>
<span class="p_header">+++ b/arch/x86/purgatory/Makefile</span>
<span class="p_chunk">@@ -8,6 +8,7 @@</span> <span class="p_context"> PURGATORY_OBJS = $(addprefix $(obj)/,$(purgatory-y))</span>
 LDFLAGS_purgatory.ro := -e purgatory_start -r --no-undefined -nostdlib -z nodefaultlib
 targets += purgatory.ro
 
<span class="p_add">+KASAN_SANITIZE	:= n</span>
 KCOV_INSTRUMENT := n
 
 # Default KBUILD_CFLAGS can have -pg option set when FTRACE is enabled. That
<span class="p_header">diff --git a/block/partitions/efi.c b/block/partitions/efi.c</span>
<span class="p_header">index bcd86e5cd546..39f70d968754 100644</span>
<span class="p_header">--- a/block/partitions/efi.c</span>
<span class="p_header">+++ b/block/partitions/efi.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static gpt_entry *alloc_read_gpt_entries(struct parsed_partitions *state,</span>
 	if (!gpt)
 		return NULL;
 
<span class="p_del">-	count = le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
<span class="p_add">+	count = (size_t)le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
                 le32_to_cpu(gpt-&gt;sizeof_partition_entry);
 	if (!count)
 		return NULL;
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 			gpt_header **gpt, gpt_entry **ptes)
 {
 	u32 crc, origcrc;
<span class="p_del">-	u64 lastlba;</span>
<span class="p_add">+	u64 lastlba, pt_size;</span>
 
 	if (!ptes)
 		return 0;
<span class="p_chunk">@@ -434,13 +434,20 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 		goto fail;
 	}
 
<span class="p_add">+	/* Sanity check partition table size */</span>
<span class="p_add">+	pt_size = (u64)le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_add">+		le32_to_cpu((*gpt)-&gt;sizeof_partition_entry);</span>
<span class="p_add">+	if (pt_size &gt; KMALLOC_MAX_SIZE) {</span>
<span class="p_add">+		pr_debug(&quot;GUID Partition Table is too large: %llu &gt; %lu bytes\n&quot;,</span>
<span class="p_add">+			 (unsigned long long)pt_size, KMALLOC_MAX_SIZE);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(*ptes = alloc_read_gpt_entries(state, *gpt)))
 		goto fail;
 
 	/* Check the GUID Partition Entry Array CRC */
<span class="p_del">-	crc = efi_crc32((const unsigned char *) (*ptes),</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;sizeof_partition_entry));</span>
<span class="p_add">+	crc = efi_crc32((const unsigned char *) (*ptes), pt_size);</span>
 
 	if (crc != le32_to_cpu((*gpt)-&gt;partition_entry_array_crc32)) {
 		pr_debug(&quot;GUID Partition Entry Array CRC check failed.\n&quot;);
<span class="p_header">diff --git a/drivers/ata/libata-transport.c b/drivers/ata/libata-transport.c</span>
<span class="p_header">index 7ef16c085058..20e2b7ad8925 100644</span>
<span class="p_header">--- a/drivers/ata/libata-transport.c</span>
<span class="p_header">+++ b/drivers/ata/libata-transport.c</span>
<span class="p_chunk">@@ -224,7 +224,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_port_class,</span>
 
 static void ata_tport_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -284,7 +283,7 @@</span> <span class="p_context"> int ata_tport_add(struct device *parent,</span>
 	device_initialize(dev);
 	dev-&gt;type = &amp;ata_port_type;
 
<span class="p_del">-	dev-&gt;parent = get_device(parent);</span>
<span class="p_add">+	dev-&gt;parent = parent;</span>
 	dev-&gt;release = ata_tport_release;
 	dev_set_name(dev, &quot;ata%d&quot;, ap-&gt;print_id);
 	transport_setup_device(dev);
<span class="p_chunk">@@ -348,7 +347,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_link_class,</span>
 
 static void ata_tlink_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -410,7 +408,7 @@</span> <span class="p_context"> int ata_tlink_add(struct ata_link *link)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;ap-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;ap-&gt;tdev;</span>
 	dev-&gt;release = ata_tlink_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;link%d&quot;, ap-&gt;print_id);
<span class="p_chunk">@@ -589,7 +587,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_dev_class,</span>
 
 static void ata_tdev_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -662,7 +659,7 @@</span> <span class="p_context"> static int ata_tdev_add(struct ata_device *ata_dev)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;link-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;link-&gt;tdev;</span>
 	dev-&gt;release = ata_tdev_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;dev%d.%d&quot;, ap-&gt;print_id,ata_dev-&gt;devno);
<span class="p_header">diff --git a/drivers/ata/sata_via.c b/drivers/ata/sata_via.c</span>
<span class="p_header">index 0636d84fbefe..f3f538eec7b3 100644</span>
<span class="p_header">--- a/drivers/ata/sata_via.c</span>
<span class="p_header">+++ b/drivers/ata/sata_via.c</span>
<span class="p_chunk">@@ -644,14 +644,16 @@</span> <span class="p_context"> static void svia_configure(struct pci_dev *pdev, int board_id,</span>
 		pci_write_config_byte(pdev, SATA_NATIVE_MODE, tmp8);
 	}
 
<span class="p_del">-	/* enable IRQ on hotplug */</span>
<span class="p_del">-	pci_read_config_byte(pdev, SVIA_MISC_3, &amp;tmp8);</span>
<span class="p_del">-	if ((tmp8 &amp; SATA_HOTPLUG) != SATA_HOTPLUG) {</span>
<span class="p_del">-		dev_dbg(&amp;pdev-&gt;dev,</span>
<span class="p_del">-			&quot;enabling SATA hotplug (0x%x)\n&quot;,</span>
<span class="p_del">-			(int) tmp8);</span>
<span class="p_del">-		tmp8 |= SATA_HOTPLUG;</span>
<span class="p_del">-		pci_write_config_byte(pdev, SVIA_MISC_3, tmp8);</span>
<span class="p_add">+	if (board_id == vt6421) {</span>
<span class="p_add">+		/* enable IRQ on hotplug */</span>
<span class="p_add">+		pci_read_config_byte(pdev, SVIA_MISC_3, &amp;tmp8);</span>
<span class="p_add">+		if ((tmp8 &amp; SATA_HOTPLUG) != SATA_HOTPLUG) {</span>
<span class="p_add">+			dev_dbg(&amp;pdev-&gt;dev,</span>
<span class="p_add">+				&quot;enabling SATA hotplug (0x%x)\n&quot;,</span>
<span class="p_add">+				(int) tmp8);</span>
<span class="p_add">+			tmp8 |= SATA_HOTPLUG;</span>
<span class="p_add">+			pci_write_config_byte(pdev, SVIA_MISC_3, tmp8);</span>
<span class="p_add">+		}</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/clk/axs10x/i2s_pll_clock.c b/drivers/clk/axs10x/i2s_pll_clock.c</span>
<span class="p_header">index 411310d29581..02d3bcd6216c 100644</span>
<span class="p_header">--- a/drivers/clk/axs10x/i2s_pll_clock.c</span>
<span class="p_header">+++ b/drivers/clk/axs10x/i2s_pll_clock.c</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> static int i2s_pll_clk_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(pll_clk-&gt;base))
 		return PTR_ERR(pll_clk-&gt;base);
 
<span class="p_add">+	memset(&amp;init, 0, sizeof(init));</span>
 	clk_name = node-&gt;name;
 	init.name = clk_name;
 	init.ops = &amp;i2s_pll_ops;
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_header">index 21c427d86f28..a26c8a19fe93 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-h3.c</span>
<span class="p_chunk">@@ -803,6 +803,13 @@</span> <span class="p_context"> static const struct sunxi_ccu_desc sun8i_h3_ccu_desc = {</span>
 	.num_resets	= ARRAY_SIZE(sun8i_h3_ccu_resets),
 };
 
<span class="p_add">+static struct ccu_mux_nb sun8i_h3_cpu_nb = {</span>
<span class="p_add">+	.common		= &amp;cpux_clk.common,</span>
<span class="p_add">+	.cm		= &amp;cpux_clk.mux,</span>
<span class="p_add">+	.delay_us	= 1, /* &gt; 8 clock cycles at 24 MHz */</span>
<span class="p_add">+	.bypass_index	= 1, /* index of 24 MHz oscillator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void __init sun8i_h3_ccu_setup(struct device_node *node)
 {
 	void __iomem *reg;
<span class="p_chunk">@@ -821,6 +828,9 @@</span> <span class="p_context"> static void __init sun8i_h3_ccu_setup(struct device_node *node)</span>
 	writel(val | (3 &lt;&lt; 16), reg + SUN8I_H3_PLL_AUDIO_REG);
 
 	sunxi_ccu_probe(node, reg, &amp;sun8i_h3_ccu_desc);
<span class="p_add">+</span>
<span class="p_add">+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,</span>
<span class="p_add">+				  &amp;sun8i_h3_cpu_nb);</span>
 }
 CLK_OF_DECLARE(sun8i_h3_ccu, &quot;allwinner,sun8i-h3-ccu&quot;,
 	       sun8i_h3_ccu_setup);
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 80fa656da5ab..a59ae8e24d3d 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -609,6 +609,7 @@</span> <span class="p_context"> static void intel_pstate_hwp_set_online_cpus(void)</span>
 static int pid_param_set(void *data, u64 val)
 {
 	*(u32 *)data = val;
<span class="p_add">+	pid_params.sample_rate_ns = pid_params.sample_rate_ms * NSEC_PER_MSEC;</span>
 	intel_pstate_reset_all_pid();
 	return 0;
 }
<span class="p_header">diff --git a/drivers/extcon/extcon-axp288.c b/drivers/extcon/extcon-axp288.c</span>
<span class="p_header">index 42f41e808292..27f67c28e700 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon-axp288.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon-axp288.c</span>
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)</span>
 		return ret;
 	}
 
<span class="p_del">-	vbus_attach = (pwr_stat &amp; PS_STAT_VBUS_PRESENT);</span>
<span class="p_add">+	vbus_attach = (pwr_stat &amp; PS_STAT_VBUS_VALID);</span>
 	if (!vbus_attach)
 		goto notify_otg;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_events.c b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">index a6a4b2b1c0d9..6a3470f84998 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_chunk">@@ -739,8 +739,10 @@</span> <span class="p_context"> int kfd_wait_on_events(struct kfd_process *p,</span>
 		struct kfd_event_data event_data;
 
 		if (copy_from_user(&amp;event_data, &amp;events[i],
<span class="p_del">-				sizeof(struct kfd_event_data)))</span>
<span class="p_add">+				sizeof(struct kfd_event_data))) {</span>
<span class="p_add">+			ret = -EFAULT;</span>
 			goto fail;
<span class="p_add">+		}</span>
 
 		ret = init_event_waiter(p, &amp;event_waiters[i],
 				event_data.event_id, i);
<span class="p_header">diff --git a/drivers/gpu/drm/arm/malidp_planes.c b/drivers/gpu/drm/arm/malidp_planes.c</span>
<span class="p_header">index 82c193e5e0d6..afe0480d95c9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/arm/malidp_planes.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/arm/malidp_planes.c</span>
<span class="p_chunk">@@ -150,13 +150,8 @@</span> <span class="p_context"> static void malidp_de_plane_update(struct drm_plane *plane,</span>
 	/* convert src values from Q16 fixed point to integer */
 	src_w = plane-&gt;state-&gt;src_w &gt;&gt; 16;
 	src_h = plane-&gt;state-&gt;src_h &gt;&gt; 16;
<span class="p_del">-	if (plane-&gt;state-&gt;rotation &amp; MALIDP_ROTATED_MASK) {</span>
<span class="p_del">-		dest_w = plane-&gt;state-&gt;crtc_h;</span>
<span class="p_del">-		dest_h = plane-&gt;state-&gt;crtc_w;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		dest_w = plane-&gt;state-&gt;crtc_w;</span>
<span class="p_del">-		dest_h = plane-&gt;state-&gt;crtc_h;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	dest_w = plane-&gt;state-&gt;crtc_w;</span>
<span class="p_add">+	dest_h = plane-&gt;state-&gt;crtc_h;</span>
 
 	malidp_hw_write(mp-&gt;hwdev, format_id, mp-&gt;layer-&gt;base);
 
<span class="p_chunk">@@ -189,9 +184,9 @@</span> <span class="p_context"> static void malidp_de_plane_update(struct drm_plane *plane,</span>
 	if (plane-&gt;state-&gt;rotation &amp; DRM_ROTATE_MASK)
 		val = ilog2(plane-&gt;state-&gt;rotation &amp; DRM_ROTATE_MASK) &lt;&lt; LAYER_ROT_OFFSET;
 	if (plane-&gt;state-&gt;rotation &amp; DRM_REFLECT_X)
<span class="p_del">-		val |= LAYER_V_FLIP;</span>
<span class="p_del">-	if (plane-&gt;state-&gt;rotation &amp; DRM_REFLECT_Y)</span>
 		val |= LAYER_H_FLIP;
<span class="p_add">+	if (plane-&gt;state-&gt;rotation &amp; DRM_REFLECT_Y)</span>
<span class="p_add">+		val |= LAYER_V_FLIP;</span>
 
 	/* set the &#39;enable layer&#39; bit */
 	val |= LAYER_ENABLE;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_overlay.c b/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_header">index a2655cd5a84e..8ab6f30dc23c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_overlay.c</span>
<span class="p_chunk">@@ -272,8 +272,30 @@</span> <span class="p_context"> static int intel_overlay_on(struct intel_overlay *overlay)</span>
 	return intel_overlay_do_wait_request(overlay, req, NULL);
 }
 
<span class="p_add">+static void intel_overlay_flip_prepare(struct intel_overlay *overlay,</span>
<span class="p_add">+				       struct i915_vma *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	enum pipe pipe = overlay-&gt;crtc-&gt;pipe;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(overlay-&gt;old_vma);</span>
<span class="p_add">+</span>
<span class="p_add">+	i915_gem_track_fb(overlay-&gt;vma ? overlay-&gt;vma-&gt;obj : NULL,</span>
<span class="p_add">+			  vma ? vma-&gt;obj : NULL,</span>
<span class="p_add">+			  INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_frontbuffer_flip_prepare(overlay-&gt;i915,</span>
<span class="p_add">+				       INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
<span class="p_add">+</span>
<span class="p_add">+	overlay-&gt;old_vma = overlay-&gt;vma;</span>
<span class="p_add">+	if (vma)</span>
<span class="p_add">+		overlay-&gt;vma = i915_vma_get(vma);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		overlay-&gt;vma = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* overlay needs to be enabled in OCMD reg */
 static int intel_overlay_continue(struct intel_overlay *overlay,
<span class="p_add">+				  struct i915_vma *vma,</span>
 				  bool load_polyphase_filter)
 {
 	struct drm_i915_private *dev_priv = overlay-&gt;i915;
<span class="p_chunk">@@ -308,43 +330,44 @@</span> <span class="p_context"> static int intel_overlay_continue(struct intel_overlay *overlay,</span>
 	intel_ring_emit(ring, flip_addr);
 	intel_ring_advance(ring);
 
<span class="p_add">+	intel_overlay_flip_prepare(overlay, vma);</span>
<span class="p_add">+</span>
 	intel_overlay_submit_request(overlay, req, NULL);
 
 	return 0;
 }
 
<span class="p_del">-static void intel_overlay_release_old_vid_tail(struct i915_gem_active *active,</span>
<span class="p_del">-					       struct drm_i915_gem_request *req)</span>
<span class="p_add">+static void intel_overlay_release_old_vma(struct intel_overlay *overlay)</span>
 {
<span class="p_del">-	struct intel_overlay *overlay =</span>
<span class="p_del">-		container_of(active, typeof(*overlay), last_flip);</span>
 	struct i915_vma *vma;
 
 	vma = fetch_and_zero(&amp;overlay-&gt;old_vma);
 	if (WARN_ON(!vma))
 		return;
 
<span class="p_del">-	i915_gem_track_fb(vma-&gt;obj, NULL,</span>
<span class="p_del">-			  INTEL_FRONTBUFFER_OVERLAY(overlay-&gt;crtc-&gt;pipe));</span>
<span class="p_add">+	intel_frontbuffer_flip_complete(overlay-&gt;i915,</span>
<span class="p_add">+					INTEL_FRONTBUFFER_OVERLAY(overlay-&gt;crtc-&gt;pipe));</span>
 
 	i915_gem_object_unpin_from_display_plane(vma);
 	i915_vma_put(vma);
 }
 
<span class="p_add">+static void intel_overlay_release_old_vid_tail(struct i915_gem_active *active,</span>
<span class="p_add">+					       struct drm_i915_gem_request *req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_overlay *overlay =</span>
<span class="p_add">+		container_of(active, typeof(*overlay), last_flip);</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_overlay_release_old_vma(overlay);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void intel_overlay_off_tail(struct i915_gem_active *active,
 				   struct drm_i915_gem_request *req)
 {
 	struct intel_overlay *overlay =
 		container_of(active, typeof(*overlay), last_flip);
<span class="p_del">-	struct i915_vma *vma;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* never have the overlay hw on without showing a frame */</span>
<span class="p_del">-	vma = fetch_and_zero(&amp;overlay-&gt;vma);</span>
<span class="p_del">-	if (WARN_ON(!vma))</span>
<span class="p_del">-		return;</span>
 
<span class="p_del">-	i915_gem_object_unpin_from_display_plane(vma);</span>
<span class="p_del">-	i915_vma_put(vma);</span>
<span class="p_add">+	intel_overlay_release_old_vma(overlay);</span>
 
 	overlay-&gt;crtc-&gt;overlay = NULL;
 	overlay-&gt;crtc = NULL;
<span class="p_chunk">@@ -398,6 +421,8 @@</span> <span class="p_context"> static int intel_overlay_off(struct intel_overlay *overlay)</span>
 	}
 	intel_ring_advance(ring);
 
<span class="p_add">+	intel_overlay_flip_prepare(overlay, NULL);</span>
<span class="p_add">+</span>
 	return intel_overlay_do_wait_request(overlay, req,
 					     intel_overlay_off_tail);
 }
<span class="p_chunk">@@ -836,18 +861,10 @@</span> <span class="p_context"> static int intel_overlay_do_put_image(struct intel_overlay *overlay,</span>
 
 	intel_overlay_unmap_regs(overlay, regs);
 
<span class="p_del">-	ret = intel_overlay_continue(overlay, scale_changed);</span>
<span class="p_add">+	ret = intel_overlay_continue(overlay, vma, scale_changed);</span>
 	if (ret)
 		goto out_unpin;
 
<span class="p_del">-	i915_gem_track_fb(overlay-&gt;vma ? overlay-&gt;vma-&gt;obj : NULL,</span>
<span class="p_del">-			  vma-&gt;obj, INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
<span class="p_del">-</span>
<span class="p_del">-	overlay-&gt;old_vma = overlay-&gt;vma;</span>
<span class="p_del">-	overlay-&gt;vma = vma;</span>
<span class="p_del">-</span>
<span class="p_del">-	intel_frontbuffer_flip(dev_priv, INTEL_FRONTBUFFER_OVERLAY(pipe));</span>
<span class="p_del">-</span>
 	return 0;
 
 out_unpin:
<span class="p_chunk">@@ -1215,6 +1232,7 @@</span> <span class="p_context"> int intel_overlay_put_image_ioctl(struct drm_device *dev, void *data,</span>
 
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
 	drm_modeset_unlock_all(dev);
<span class="p_add">+	i915_gem_object_put(new_bo);</span>
 
 	kfree(params);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_psr.c b/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_header">index 9b307cee3008..dff478498f05 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_psr.c</span>
<span class="p_chunk">@@ -387,6 +387,13 @@</span> <span class="p_context"> static bool intel_psr_match_conditions(struct intel_dp *intel_dp)</span>
 		return false;
 	}
 
<span class="p_add">+	/* PSR2 is restricted to work with panel resolutions upto 3200x2000 */</span>
<span class="p_add">+	if (intel_crtc-&gt;config-&gt;pipe_src_w &gt; 3200 ||</span>
<span class="p_add">+				intel_crtc-&gt;config-&gt;pipe_src_h &gt; 2000) {</span>
<span class="p_add">+		dev_priv-&gt;psr.psr2_support = false;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_priv-&gt;psr.source_ok = true;
 	return true;
 }
<span class="p_chunk">@@ -425,7 +432,6 @@</span> <span class="p_context"> void intel_psr_enable(struct intel_dp *intel_dp)</span>
 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
 	struct drm_device *dev = intel_dig_port-&gt;base.base.dev;
 	struct drm_i915_private *dev_priv = to_i915(dev);
<span class="p_del">-	struct intel_crtc *crtc = to_intel_crtc(intel_dig_port-&gt;base.base.crtc);</span>
 
 	if (!HAS_PSR(dev)) {
 		DRM_DEBUG_KMS(&quot;PSR not supported on this platform\n&quot;);
<span class="p_chunk">@@ -452,12 +458,7 @@</span> <span class="p_context"> void intel_psr_enable(struct intel_dp *intel_dp)</span>
 		hsw_psr_setup_vsc(intel_dp);
 
 		if (dev_priv-&gt;psr.psr2_support) {
<span class="p_del">-			/* PSR2 is restricted to work with panel resolutions upto 3200x2000 */</span>
<span class="p_del">-			if (crtc-&gt;config-&gt;pipe_src_w &gt; 3200 ||</span>
<span class="p_del">-				crtc-&gt;config-&gt;pipe_src_h &gt; 2000)</span>
<span class="p_del">-				dev_priv-&gt;psr.psr2_support = false;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				skl_psr_setup_su_vsc(intel_dp);</span>
<span class="p_add">+			skl_psr_setup_su_vsc(intel_dp);</span>
 		}
 
 		/*
<span class="p_header">diff --git a/drivers/hid/wacom_sys.c b/drivers/hid/wacom_sys.c</span>
<span class="p_header">index 0c535d0f3b95..53ac19b3727a 100644</span>
<span class="p_header">--- a/drivers/hid/wacom_sys.c</span>
<span class="p_header">+++ b/drivers/hid/wacom_sys.c</span>
<span class="p_chunk">@@ -2433,6 +2433,8 @@</span> <span class="p_context"> static void wacom_remove(struct hid_device *hdev)</span>
 	if (hdev-&gt;bus == BUS_BLUETOOTH)
 		device_remove_file(&amp;hdev-&gt;dev, &amp;dev_attr_speed);
 
<span class="p_add">+	wacom_release_resources(wacom);</span>
<span class="p_add">+</span>
 	hid_set_drvdata(hdev, NULL);
 }
 
<span class="p_header">diff --git a/drivers/hwmon/gl520sm.c b/drivers/hwmon/gl520sm.c</span>
<span class="p_header">index dee93ec87d02..84e0994aafdd 100644</span>
<span class="p_header">--- a/drivers/hwmon/gl520sm.c</span>
<span class="p_header">+++ b/drivers/hwmon/gl520sm.c</span>
<span class="p_chunk">@@ -208,11 +208,13 @@</span> <span class="p_context"> static ssize_t get_cpu_vid(struct device *dev, struct device_attribute *attr,</span>
 }
 static DEVICE_ATTR(cpu0_vid, S_IRUGO, get_cpu_vid, NULL);
 
<span class="p_del">-#define VDD_FROM_REG(val) (((val) * 95 + 2) / 4)</span>
<span class="p_del">-#define VDD_TO_REG(val) clamp_val((((val) * 4 + 47) / 95), 0, 255)</span>
<span class="p_add">+#define VDD_FROM_REG(val)	DIV_ROUND_CLOSEST((val) * 95, 4)</span>
<span class="p_add">+#define VDD_CLAMP(val)		clamp_val(val, 0, 255 * 95 / 4)</span>
<span class="p_add">+#define VDD_TO_REG(val)		DIV_ROUND_CLOSEST(VDD_CLAMP(val) * 4, 95)</span>
 
<span class="p_del">-#define IN_FROM_REG(val) ((val) * 19)</span>
<span class="p_del">-#define IN_TO_REG(val) clamp_val((((val) + 9) / 19), 0, 255)</span>
<span class="p_add">+#define IN_FROM_REG(val)	((val) * 19)</span>
<span class="p_add">+#define IN_CLAMP(val)		clamp_val(val, 0, 255 * 19)</span>
<span class="p_add">+#define IN_TO_REG(val)		DIV_ROUND_CLOSEST(IN_CLAMP(val), 19)</span>
 
 static ssize_t get_in_input(struct device *dev, struct device_attribute *attr,
 			    char *buf)
<span class="p_chunk">@@ -349,8 +351,13 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(in4_max, S_IRUGO | S_IWUSR,</span>
 
 #define DIV_FROM_REG(val) (1 &lt;&lt; (val))
 #define FAN_FROM_REG(val, div) ((val) == 0 ? 0 : (480000 / ((val) &lt;&lt; (div))))
<span class="p_del">-#define FAN_TO_REG(val, div) ((val) &lt;= 0 ? 0 : \</span>
<span class="p_del">-	clamp_val((480000 + ((val) &lt;&lt; ((div)-1))) / ((val) &lt;&lt; (div)), 1, 255))</span>
<span class="p_add">+</span>
<span class="p_add">+#define FAN_BASE(div)		(480000 &gt;&gt; (div))</span>
<span class="p_add">+#define FAN_CLAMP(val, div)	clamp_val(val, FAN_BASE(div) / 255, \</span>
<span class="p_add">+					  FAN_BASE(div))</span>
<span class="p_add">+#define FAN_TO_REG(val, div)	((val) == 0 ? 0 : \</span>
<span class="p_add">+				 DIV_ROUND_CLOSEST(480000, \</span>
<span class="p_add">+						FAN_CLAMP(val, div) &lt;&lt; (div)))</span>
 
 static ssize_t get_fan_input(struct device *dev, struct device_attribute *attr,
 			     char *buf)
<span class="p_chunk">@@ -513,9 +520,9 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR,</span>
 static DEVICE_ATTR(fan1_off, S_IRUGO | S_IWUSR,
 		get_fan_off, set_fan_off);
 
<span class="p_del">-#define TEMP_FROM_REG(val) (((val) - 130) * 1000)</span>
<span class="p_del">-#define TEMP_TO_REG(val) clamp_val(((((val) &lt; 0 ? \</span>
<span class="p_del">-			(val) - 500 : (val) + 500) / 1000) + 130), 0, 255)</span>
<span class="p_add">+#define TEMP_FROM_REG(val)	(((val) - 130) * 1000)</span>
<span class="p_add">+#define TEMP_CLAMP(val)		clamp_val(val, -130000, 125000)</span>
<span class="p_add">+#define TEMP_TO_REG(val)	(DIV_ROUND_CLOSEST(TEMP_CLAMP(val), 1000) + 130)</span>
 
 static ssize_t get_temp_input(struct device *dev, struct device_attribute *attr,
 			      char *buf)
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-meson.c b/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_header">index 2aa61bbbd307..73b97c71a484 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> static void meson_i2c_put_data(struct meson_i2c *i2c, char *buf, int len)</span>
 		wdata1 |= *buf++ &lt;&lt; ((i - 4) * 8);
 
 	writel(wdata0, i2c-&gt;regs + REG_TOK_WDATA0);
<span class="p_del">-	writel(wdata0, i2c-&gt;regs + REG_TOK_WDATA1);</span>
<span class="p_add">+	writel(wdata1, i2c-&gt;regs + REG_TOK_WDATA1);</span>
 
 	dev_dbg(i2c-&gt;dev, &quot;%s: data %08x %08x len %d\n&quot;, __func__,
 		wdata0, wdata1, len);
<span class="p_header">diff --git a/drivers/iio/adc/axp288_adc.c b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">index 7fd24949c0c1..64799ad7ebad 100644</span>
<span class="p_header">--- a/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_chunk">@@ -28,8 +28,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/driver.h&gt;
 
 #define AXP288_ADC_EN_MASK		0xF1
<span class="p_del">-#define AXP288_ADC_TS_PIN_GPADC		0xF2</span>
<span class="p_del">-#define AXP288_ADC_TS_PIN_ON		0xF3</span>
 
 enum axp288_adc_id {
 	AXP288_ADC_TS,
<span class="p_chunk">@@ -123,16 +121,6 @@</span> <span class="p_context"> static int axp288_adc_read_channel(int *val, unsigned long address,</span>
 	return IIO_VAL_INT;
 }
 
<span class="p_del">-static int axp288_adc_set_ts(struct regmap *regmap, unsigned int mode,</span>
<span class="p_del">-				unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* channels other than GPADC do not need to switch TS pin */</span>
<span class="p_del">-	if (address != AXP288_GP_ADC_H)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, mode);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int axp288_adc_read_raw(struct iio_dev *indio_dev,
 			struct iio_chan_spec const *chan,
 			int *val, int *val2, long mask)
<span class="p_chunk">@@ -143,16 +131,7 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 	mutex_lock(&amp;indio_dev-&gt;mlock);
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
<span class="p_del">-		if (axp288_adc_set_ts(info-&gt;regmap, AXP288_ADC_TS_PIN_GPADC,</span>
<span class="p_del">-					chan-&gt;address)) {</span>
<span class="p_del">-			dev_err(&amp;indio_dev-&gt;dev, &quot;GPADC mode\n&quot;);</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		ret = axp288_adc_read_channel(val, chan-&gt;address, info-&gt;regmap);
<span class="p_del">-		if (axp288_adc_set_ts(info-&gt;regmap, AXP288_ADC_TS_PIN_ON,</span>
<span class="p_del">-						chan-&gt;address))</span>
<span class="p_del">-			dev_err(&amp;indio_dev-&gt;dev, &quot;TS pin restore\n&quot;);</span>
 		break;
 	default:
 		ret = -EINVAL;
<span class="p_chunk">@@ -162,15 +141,6 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 	return ret;
 }
 
<span class="p_del">-static int axp288_adc_set_state(struct regmap *regmap)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* ADC should be always enabled for internal FG to function */</span>
<span class="p_del">-	if (regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, AXP288_ADC_TS_PIN_ON))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	return regmap_write(regmap, AXP20X_ADC_EN1, AXP288_ADC_EN_MASK);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const struct iio_info axp288_adc_iio_info = {
 	.read_raw = &amp;axp288_adc_read_raw,
 	.driver_module = THIS_MODULE,
<span class="p_chunk">@@ -199,7 +169,7 @@</span> <span class="p_context"> static int axp288_adc_probe(struct platform_device *pdev)</span>
 	 * Set ADC to enabled state at all time, including system suspend.
 	 * otherwise internal fuel gauge functionality may be affected.
 	 */
<span class="p_del">-	ret = axp288_adc_set_state(axp20x-&gt;regmap);</span>
<span class="p_add">+	ret = regmap_write(info-&gt;regmap, AXP20X_ADC_EN1, AXP288_ADC_EN_MASK);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;unable to enable ADC device\n&quot;);
 		return ret;
<span class="p_header">diff --git a/drivers/iio/adc/fsl-imx25-gcq.c b/drivers/iio/adc/fsl-imx25-gcq.c</span>
<span class="p_header">index 72b32c1ab257..ea264fa9e567 100644</span>
<span class="p_header">--- a/drivers/iio/adc/fsl-imx25-gcq.c</span>
<span class="p_header">+++ b/drivers/iio/adc/fsl-imx25-gcq.c</span>
<span class="p_chunk">@@ -401,6 +401,7 @@</span> <span class="p_context"> static const struct of_device_id mx25_gcq_ids[] = {</span>
 	{ .compatible = &quot;fsl,imx25-gcq&quot;, },
 	{ /* Sentinel */ }
 };
<span class="p_add">+MODULE_DEVICE_TABLE(of, mx25_gcq_ids);</span>
 
 static struct platform_driver mx25_gcq_driver = {
 	.driver		= {
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">index ded27172320e..cedb447d0162 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_chunk">@@ -7080,7 +7080,7 @@</span> <span class="p_context"> static void qib_7322_txchk_change(struct qib_devdata *dd, u32 start,</span>
 	unsigned long flags;
 
 	while (wait) {
<span class="p_del">-		unsigned long shadow;</span>
<span class="p_add">+		unsigned long shadow = 0;</span>
 		int cstart, previ = -1;
 
 		/*
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_pool.c b/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_header">index 6bac0717c540..ee26a1b1b4ed 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_chunk">@@ -274,6 +274,7 @@</span> <span class="p_context"> static u32 alloc_index(struct rxe_pool *pool)</span>
 	if (index &gt;= range)
 		index = find_first_zero_bit(pool-&gt;table, range);
 
<span class="p_add">+	WARN_ON_ONCE(index &gt;= range);</span>
 	set_bit(index, pool-&gt;table);
 	pool-&gt;last = index;
 	return index + pool-&gt;min_index;
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_resp.c b/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_header">index ccf624763565..69ed4e0d7a0d 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_chunk">@@ -418,7 +418,7 @@</span> <span class="p_context"> static enum resp_states check_length(struct rxe_qp *qp,</span>
 static enum resp_states check_rkey(struct rxe_qp *qp,
 				   struct rxe_pkt_info *pkt)
 {
<span class="p_del">-	struct rxe_mem *mem;</span>
<span class="p_add">+	struct rxe_mem *mem = NULL;</span>
 	u64 va;
 	u32 rkey;
 	u32 resid;
<span class="p_chunk">@@ -452,38 +452,38 @@</span> <span class="p_context"> static enum resp_states check_rkey(struct rxe_qp *qp,</span>
 	mem = lookup_mem(qp-&gt;pd, access, rkey, lookup_remote);
 	if (!mem) {
 		state = RESPST_ERR_RKEY_VIOLATION;
<span class="p_del">-		goto err1;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	if (unlikely(mem-&gt;state == RXE_MEM_STATE_FREE)) {
 		state = RESPST_ERR_RKEY_VIOLATION;
<span class="p_del">-		goto err1;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	if (mem_check_range(mem, va, resid)) {
 		state = RESPST_ERR_RKEY_VIOLATION;
<span class="p_del">-		goto err2;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	if (pkt-&gt;mask &amp; RXE_WRITE_MASK)	 {
 		if (resid &gt; mtu) {
 			if (pktlen != mtu || bth_pad(pkt)) {
 				state = RESPST_ERR_LENGTH;
<span class="p_del">-				goto err2;</span>
<span class="p_add">+				goto err;</span>
 			}
 
 			qp-&gt;resp.resid = mtu;
 		} else {
 			if (pktlen != resid) {
 				state = RESPST_ERR_LENGTH;
<span class="p_del">-				goto err2;</span>
<span class="p_add">+				goto err;</span>
 			}
 			if ((bth_pad(pkt) != (0x3 &amp; (-resid)))) {
 				/* This case may not be exactly that
 				 * but nothing else fits.
 				 */
 				state = RESPST_ERR_LENGTH;
<span class="p_del">-				goto err2;</span>
<span class="p_add">+				goto err;</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -493,9 +493,9 @@</span> <span class="p_context"> static enum resp_states check_rkey(struct rxe_qp *qp,</span>
 	qp-&gt;resp.mr = mem;
 	return RESPST_EXECUTE;
 
<span class="p_del">-err2:</span>
<span class="p_del">-	rxe_drop_ref(mem);</span>
<span class="p_del">-err1:</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (mem)</span>
<span class="p_add">+		rxe_drop_ref(mem);</span>
 	return state;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 08c4b0287304..183db0cd849e 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -1302,7 +1302,7 @@</span> <span class="p_context"> static void __ipoib_reap_neigh(struct ipoib_dev_priv *priv)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from path/mc list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1466,7 +1466,7 @@</span> <span class="p_context"> void ipoib_neigh_free(struct ipoib_neigh *neigh)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from parent list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			return;
 		} else {
<span class="p_chunk">@@ -1551,7 +1551,7 @@</span> <span class="p_context"> void ipoib_del_neighs_by_gid(struct net_device *dev, u8 *gid)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from parent list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1593,7 +1593,7 @@</span> <span class="p_context"> static void ipoib_flush_neighs(struct ipoib_dev_priv *priv)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from path/mc list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 		}
 	}
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">index 57eadd2b7a71..93b50be14438 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_chunk">@@ -165,11 +165,11 @@</span> <span class="p_context"> int ipoib_vlan_add(struct net_device *pdev, unsigned short pkey)</span>
 out:
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+</span>
 	if (result)
 		free_netdev(priv-&gt;dev);
 
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	return result;
 }
 
<span class="p_chunk">@@ -193,7 +193,6 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	list_for_each_entry_safe(priv, tpriv, &amp;ppriv-&gt;child_intfs, list) {
 		if (priv-&gt;pkey == pkey &amp;&amp;
 		    priv-&gt;child_type == IPOIB_LEGACY_CHILD) {
<span class="p_del">-			unregister_netdevice(priv-&gt;dev);</span>
 			list_del(&amp;priv-&gt;list);
 			dev = priv-&gt;dev;
 			break;
<span class="p_chunk">@@ -201,6 +200,11 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	}
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		ipoib_dbg(ppriv, &quot;delete child vlan %s\n&quot;, dev-&gt;name);</span>
<span class="p_add">+		unregister_netdevice(dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rtnl_unlock();
 
 	if (dev) {
<span class="p_header">diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="p_header">index 8f7281444551..5a9a4416f467 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu.c</span>
<span class="p_chunk">@@ -1211,7 +1211,7 @@</span> <span class="p_context"> static int arm_smmu_domain_add_master(struct arm_smmu_domain *smmu_domain,</span>
 			continue;
 
 		s2cr[idx].type = type;
<span class="p_del">-		s2cr[idx].privcfg = S2CR_PRIVCFG_UNPRIV;</span>
<span class="p_add">+		s2cr[idx].privcfg = S2CR_PRIVCFG_DEFAULT;</span>
 		s2cr[idx].cbndx = cbndx;
 		arm_smmu_write_s2cr(smmu, idx);
 	}
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 30808e91b775..c7820b3ea80e 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -542,7 +542,10 @@</span> <span class="p_context"> static void sysmmu_tlb_invalidate_flpdcache(struct sysmmu_drvdata *data,</span>
 	spin_lock_irqsave(&amp;data-&gt;lock, flags);
 	if (is_sysmmu_active(data) &amp;&amp; data-&gt;version &gt;= MAKE_MMU_VER(3, 3)) {
 		clk_enable(data-&gt;clk_master);
<span class="p_del">-		__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
<span class="p_add">+		if (sysmmu_block(data)) {</span>
<span class="p_add">+			__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
<span class="p_add">+			sysmmu_unblock(data);</span>
<span class="p_add">+		}</span>
 		clk_disable(data-&gt;clk_master);
 	}
 	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index f5c90e1366ce..7c9d632f1d09 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -335,8 +335,12 @@</span> <span class="p_context"> static int __arm_lpae_map(struct arm_lpae_io_pgtable *data, unsigned long iova,</span>
 		if (cfg-&gt;quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)
 			pte |= ARM_LPAE_PTE_NSTABLE;
 		__arm_lpae_set_pte(ptep, pte, cfg);
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else if (!iopte_leaf(pte, lvl)) {</span>
 		cptep = iopte_deref(pte, data);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* We require an unmap first */</span>
<span class="p_add">+		WARN_ON(!selftest_running);</span>
<span class="p_add">+		return -EEXIST;</span>
 	}
 
 	/* Rinse, repeat */
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 4c4aab02e311..b19b551bb34b 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1407,11 +1407,24 @@</span> <span class="p_context"> static void __make_request(struct mddev *mddev, struct bio *bio)</span>
 			mbio-&gt;bi_private = r10_bio;
 
 			atomic_inc(&amp;r10_bio-&gt;remaining);
<span class="p_add">+</span>
<span class="p_add">+			cb = blk_check_plugged(raid10_unplug, mddev,</span>
<span class="p_add">+					       sizeof(*plug));</span>
<span class="p_add">+			if (cb)</span>
<span class="p_add">+				plug = container_of(cb, struct raid10_plug_cb,</span>
<span class="p_add">+						    cb);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				plug = NULL;</span>
 			spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_del">-			conf-&gt;pending_count++;</span>
<span class="p_add">+			if (plug) {</span>
<span class="p_add">+				bio_list_add(&amp;plug-&gt;pending, mbio);</span>
<span class="p_add">+				plug-&gt;pending_cnt++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_add">+				conf-&gt;pending_count++;</span>
<span class="p_add">+			}</span>
 			spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			if (!mddev_check_plugged(mddev))</span>
<span class="p_add">+			if (!plug)</span>
 				md_wakeup_thread(mddev-&gt;thread);
 		}
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.c b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">index 0583d56ef5ef..41ba8489db34 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_chunk">@@ -56,11 +56,11 @@</span> <span class="p_context"></span>
    by Nathan Laredo &lt;laredo@gnu.org&gt; */
 
 int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-		     int addr, u32 val, int count)</span>
<span class="p_add">+		     int addr, u32 val, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 
<span class="p_del">-	if (count &lt;= 0 || count &gt; 32764) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return -1;
 	}
<span class="p_chunk">@@ -78,12 +78,12 @@</span> <span class="p_context"> int av7110_debiwrite(struct av7110 *av7110, u32 config,</span>
 	return 0;
 }
 
<span class="p_del">-u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, int count)</span>
<span class="p_add">+u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 	u32 result = 0;
 
<span class="p_del">-	if (count &gt; 32764 || count &lt;= 0) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.h b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">index 1634aba5cb84..ccb148059406 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_chunk">@@ -377,14 +377,14 @@</span> <span class="p_context"> extern int av7110_fw_request(struct av7110 *av7110, u16 *request_buf,</span>
 
 /* DEBI (saa7146 data extension bus interface) access */
 extern int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-			    int addr, u32 val, int count);</span>
<span class="p_add">+			    int addr, u32 val, unsigned int count);</span>
 extern u32 av7110_debiread(struct av7110 *av7110, u32 config,
<span class="p_del">-			   int addr, int count);</span>
<span class="p_add">+			   int addr, unsigned int count);</span>
 
 
 /* DEBI during interrupt */
 /* single word writes */
<span class="p_del">-static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	av7110_debiwrite(av7110, config, addr, val, count);
 }
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> static inline void mwdebi(struct av7110 *av7110, u32 config, int addr,</span>
 	av7110_debiwrite(av7110, config, addr, 0, count);
 }
 
<span class="p_del">-static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	u32 res;
 
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 }
 
 /* DEBI outside interrupts, only for count &lt;= 4! */
<span class="p_del">-static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 	spin_unlock_irqrestore(&amp;av7110-&gt;debilock, flags);
 }
 
<span class="p_del">-static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 	u32 res;
<span class="p_header">diff --git a/drivers/media/platform/exynos-gsc/gsc-core.c b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">index 787bd16c19e5..bbb5feef8308 100644</span>
<span class="p_header">--- a/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">+++ b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_chunk">@@ -849,9 +849,7 @@</span> <span class="p_context"> int gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,</span>
 
 	if ((frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_VYUY) ||
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVYU) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV61) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV21) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420M))
 		swap(addr-&gt;cb, addr-&gt;cr);
 
<span class="p_header">diff --git a/drivers/misc/lkdtm_core.c b/drivers/misc/lkdtm_core.c</span>
<span class="p_header">index f9154b8d67f6..b2989f2d3126 100644</span>
<span class="p_header">--- a/drivers/misc/lkdtm_core.c</span>
<span class="p_header">+++ b/drivers/misc/lkdtm_core.c</span>
<span class="p_chunk">@@ -533,7 +533,9 @@</span> <span class="p_context"> static void __exit lkdtm_module_exit(void)</span>
 	/* Handle test-specific clean-up. */
 	lkdtm_usercopy_exit();
 
<span class="p_del">-	unregister_jprobe(lkdtm_jprobe);</span>
<span class="p_add">+	if (lkdtm_jprobe != NULL)</span>
<span class="p_add">+		unregister_jprobe(lkdtm_jprobe);</span>
<span class="p_add">+</span>
 	pr_info(&quot;Crash point unregistered\n&quot;);
 }
 
<span class="p_header">diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">index 86f5b3223aae..d56a3b6c2fb9 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static void sdio_release_func(struct device *dev)</span>
 	sdio_free_func_cis(func);
 
 	kfree(func-&gt;info);
<span class="p_del">-</span>
<span class="p_add">+	kfree(func-&gt;tmpbuf);</span>
 	kfree(func);
 }
 
<span class="p_chunk">@@ -281,6 +281,16 @@</span> <span class="p_context"> struct sdio_func *sdio_alloc_func(struct mmc_card *card)</span>
 	if (!func)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * allocate buffer separately to make sure it&#39;s properly aligned for</span>
<span class="p_add">+	 * DMA usage (incl. 64 bit DMA)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	func-&gt;tmpbuf = kmalloc(4, GFP_KERNEL);</span>
<span class="p_add">+	if (!func-&gt;tmpbuf) {</span>
<span class="p_add">+		kfree(func);</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	func-&gt;card = card;
 
 	device_initialize(&amp;func-&gt;dev);
<span class="p_header">diff --git a/drivers/net/dsa/b53/b53_common.c b/drivers/net/dsa/b53/b53_common.c</span>
<span class="p_header">index 3ec573c13dac..c26debc531ee 100644</span>
<span class="p_header">--- a/drivers/net/dsa/b53/b53_common.c</span>
<span class="p_header">+++ b/drivers/net/dsa/b53/b53_common.c</span>
<span class="p_chunk">@@ -326,6 +326,7 @@</span> <span class="p_context"> static void b53_get_vlan_entry(struct b53_device *dev, u16 vid,</span>
 
 static void b53_set_forwarding(struct b53_device *dev, int enable)
 {
<span class="p_add">+	struct dsa_switch *ds = dev-&gt;ds;</span>
 	u8 mgmt;
 
 	b53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &amp;mgmt);
<span class="p_chunk">@@ -336,6 +337,15 @@</span> <span class="p_context"> static void b53_set_forwarding(struct b53_device *dev, int enable)</span>
 		mgmt &amp;= ~SM_SW_FWD_EN;
 
 	b53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);
<span class="p_add">+</span>
<span class="p_add">+	/* Include IMP port in dumb forwarding mode when no tagging protocol is</span>
<span class="p_add">+	 * set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ds-&gt;ops-&gt;get_tag_protocol(ds) == DSA_TAG_PROTO_NONE) {</span>
<span class="p_add">+		b53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, &amp;mgmt);</span>
<span class="p_add">+		mgmt |= B53_MII_DUMB_FWDG_EN;</span>
<span class="p_add">+		b53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, mgmt);</span>
<span class="p_add">+	}</span>
 }
 
 static void b53_enable_vlan(struct b53_device *dev, bool enable)
<span class="p_header">diff --git a/drivers/net/dsa/b53/b53_regs.h b/drivers/net/dsa/b53/b53_regs.h</span>
<span class="p_header">index dac0af4e2cd0..81044000ce75 100644</span>
<span class="p_header">--- a/drivers/net/dsa/b53/b53_regs.h</span>
<span class="p_header">+++ b/drivers/net/dsa/b53/b53_regs.h</span>
<span class="p_chunk">@@ -104,6 +104,10 @@</span> <span class="p_context"></span>
 #define  B53_UC_FWD_EN			BIT(6)
 #define  B53_MC_FWD_EN			BIT(7)
 
<span class="p_add">+/* Switch control (8 bit) */</span>
<span class="p_add">+#define B53_SWITCH_CTRL			0x22</span>
<span class="p_add">+#define  B53_MII_DUMB_FWDG_EN		BIT(6)</span>
<span class="p_add">+</span>
 /* (16 bit) */
 #define B53_UC_FLOOD_MASK		0x32
 #define B53_MC_FLOOD_MASK		0x34
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ibmvnic.c b/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_header">index 9f2184be55dc..b8778e7b1f79 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ibmvnic.c</span>
<span class="p_chunk">@@ -1253,6 +1253,7 @@</span> <span class="p_context"> static void release_sub_crqs(struct ibmvnic_adapter *adapter)</span>
 				release_sub_crq_queue(adapter,
 						      adapter-&gt;tx_scrq[i]);
 			}
<span class="p_add">+		kfree(adapter-&gt;tx_scrq);</span>
 		adapter-&gt;tx_scrq = NULL;
 	}
 
<span class="p_chunk">@@ -1265,6 +1266,7 @@</span> <span class="p_context"> static void release_sub_crqs(struct ibmvnic_adapter *adapter)</span>
 				release_sub_crq_queue(adapter,
 						      adapter-&gt;rx_scrq[i]);
 			}
<span class="p_add">+		kfree(adapter-&gt;rx_scrq);</span>
 		adapter-&gt;rx_scrq = NULL;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index 9affd7c198bd..6a62447fe377 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -7882,6 +7882,11 @@</span> <span class="p_context"> static pci_ers_result_t igb_io_slot_reset(struct pci_dev *pdev)</span>
 		pci_enable_wake(pdev, PCI_D3hot, 0);
 		pci_enable_wake(pdev, PCI_D3cold, 0);
 
<span class="p_add">+		/* In case of PCI error, adapter lose its HW address</span>
<span class="p_add">+		 * so we should re-assign it here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		hw-&gt;hw_addr = adapter-&gt;io_addr;</span>
<span class="p_add">+</span>
 		igb_reset(adapter);
 		wr32(E1000_WUS, ~0);
 		result = PCI_ERS_RESULT_RECOVERED;
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qed/qed_dcbx.c b/drivers/net/ethernet/qlogic/qed/qed_dcbx.c</span>
<span class="p_header">index a4789a93b692..9d59cb85c012 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qed/qed_dcbx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qed/qed_dcbx.c</span>
<span class="p_chunk">@@ -1222,7 +1222,7 @@</span> <span class="p_context"> static struct qed_dcbx_get *qed_dcbnl_get_dcbx(struct qed_hwfn *hwfn,</span>
 {
 	struct qed_dcbx_get *dcbx_info;
 
<span class="p_del">-	dcbx_info = kzalloc(sizeof(*dcbx_info), GFP_KERNEL);</span>
<span class="p_add">+	dcbx_info = kmalloc(sizeof(*dcbx_info), GFP_ATOMIC);</span>
 	if (!dcbx_info)
 		return NULL;
 
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.h b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">index d050f37f3e0f..5024280f5af2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> enum FELIC_MODE_BIT {</span>
 	ECMR_DPAD = 0x00200000, ECMR_RZPF = 0x00100000,
 	ECMR_ZPF = 0x00080000, ECMR_PFR = 0x00040000, ECMR_RXF = 0x00020000,
 	ECMR_TXF = 0x00010000, ECMR_MCT = 0x00002000, ECMR_PRCEF = 0x00001000,
<span class="p_del">-	ECMR_PMDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
<span class="p_add">+	ECMR_MPDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
 	ECMR_RTM = 0x00000010, ECMR_ILB = 0x00000008, ECMR_ELB = 0x00000004,
 	ECMR_DM = 0x00000002, ECMR_PRM = 0x00000001,
 };
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">index c4ada7227f40..1d85109cb8ed 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_chunk">@@ -197,11 +197,15 @@</span> <span class="p_context"> static int efx_ef10_init_datapath_caps(struct efx_nic *efx)</span>
 	nic_data-&gt;datapath_caps =
 		MCDI_DWORD(outbuf, GET_CAPABILITIES_OUT_FLAGS1);
 
<span class="p_del">-	if (outlen &gt;= MC_CMD_GET_CAPABILITIES_V2_OUT_LEN)</span>
<span class="p_add">+	if (outlen &gt;= MC_CMD_GET_CAPABILITIES_V2_OUT_LEN) {</span>
 		nic_data-&gt;datapath_caps2 = MCDI_DWORD(outbuf,
 				GET_CAPABILITIES_V2_OUT_FLAGS2);
<span class="p_del">-	else</span>
<span class="p_add">+		nic_data-&gt;piobuf_size = MCDI_WORD(outbuf,</span>
<span class="p_add">+				GET_CAPABILITIES_V2_OUT_SIZE_PIO_BUFF);</span>
<span class="p_add">+	} else {</span>
 		nic_data-&gt;datapath_caps2 = 0;
<span class="p_add">+		nic_data-&gt;piobuf_size = ER_DZ_TX_PIOBUF_SIZE;</span>
<span class="p_add">+	}</span>
 
 	/* record the DPCPU firmware IDs to determine VEB vswitching support.
 	 */
<span class="p_chunk">@@ -825,8 +829,8 @@</span> <span class="p_context"> static int efx_ef10_link_piobufs(struct efx_nic *efx)</span>
 			offset = ((efx-&gt;tx_channel_offset + efx-&gt;n_tx_channels -
 				   tx_queue-&gt;channel-&gt;channel - 1) *
 				  efx_piobuf_size);
<span class="p_del">-			index = offset / ER_DZ_TX_PIOBUF_SIZE;</span>
<span class="p_del">-			offset = offset % ER_DZ_TX_PIOBUF_SIZE;</span>
<span class="p_add">+			index = offset / nic_data-&gt;piobuf_size;</span>
<span class="p_add">+			offset = offset % nic_data-&gt;piobuf_size;</span>
 
 			/* When the host page size is 4K, the first
 			 * host page in the WC mapping may be within
<span class="p_chunk">@@ -1161,11 +1165,11 @@</span> <span class="p_context"> static int efx_ef10_dimension_resources(struct efx_nic *efx)</span>
 	 * functions of the controller.
 	 */
 	if (efx_piobuf_size != 0 &amp;&amp;
<span class="p_del">-	    ER_DZ_TX_PIOBUF_SIZE / efx_piobuf_size * EF10_TX_PIOBUF_COUNT &gt;=</span>
<span class="p_add">+	    nic_data-&gt;piobuf_size / efx_piobuf_size * EF10_TX_PIOBUF_COUNT &gt;=</span>
 	    efx-&gt;n_tx_channels) {
 		unsigned int n_piobufs =
 			DIV_ROUND_UP(efx-&gt;n_tx_channels,
<span class="p_del">-				     ER_DZ_TX_PIOBUF_SIZE / efx_piobuf_size);</span>
<span class="p_add">+				     nic_data-&gt;piobuf_size / efx_piobuf_size);</span>
 
 		rc = efx_ef10_alloc_piobufs(efx, n_piobufs);
 		if (rc)
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/nic.h b/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_header">index 73bee7ea332a..73028f21a2d7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/nic.h</span>
<span class="p_chunk">@@ -500,6 +500,7 @@</span> <span class="p_context"> enum {</span>
  * @pio_write_base: Base address for writing PIO buffers
  * @pio_write_vi_base: Relative VI number for @pio_write_base
  * @piobuf_handle: Handle of each PIO buffer allocated
<span class="p_add">+ * @piobuf_size: size of a single PIO buffer</span>
  * @must_restore_piobufs: Flag: PIO buffers have yet to be restored after MC
  *	reboot
  * @rx_rss_context: Firmware handle for our RSS context
<span class="p_chunk">@@ -537,6 +538,7 @@</span> <span class="p_context"> struct efx_ef10_nic_data {</span>
 	void __iomem *wc_membase, *pio_write_base;
 	unsigned int pio_write_vi_base;
 	unsigned int piobuf_handle[EF10_TX_PIOBUF_COUNT];
<span class="p_add">+	u16 piobuf_size;</span>
 	bool must_restore_piobufs;
 	u32 rx_rss_context;
 	bool rx_rss_context_exclusive;
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/tx.c b/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_header">index 233778911557..6f26acd0aa61 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/tx.c</span>
<span class="p_chunk">@@ -27,7 +27,6 @@</span> <span class="p_context"></span>
 
 #ifdef EFX_USE_PIO
 
<span class="p_del">-#define EFX_PIOBUF_SIZE_MAX ER_DZ_TX_PIOBUF_SIZE</span>
 #define EFX_PIOBUF_SIZE_DEF ALIGN(256, L1_CACHE_BYTES)
 unsigned int efx_piobuf_size __read_mostly = EFX_PIOBUF_SIZE_DEF;
 
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index a380649bf6b5..26681707fc7a 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -2366,8 +2366,10 @@</span> <span class="p_context"> static int team_nl_send_options_get(struct team *team, u32 portid, u32 seq,</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_OPTIONS_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_chunk">@@ -2639,8 +2641,10 @@</span> <span class="p_context"> static int team_nl_send_port_list_get(struct team *team, u32 portid, u32 seq,</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_PORT_LIST_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_header">diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig</span>
<span class="p_header">index cdde59089f72..3a7286256db0 100644</span>
<span class="p_header">--- a/drivers/net/usb/Kconfig</span>
<span class="p_header">+++ b/drivers/net/usb/Kconfig</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> config USB_NET_NET1080</span>
 	  optionally with LEDs that indicate traffic
 
 config USB_NET_PLUSB
<span class="p_del">-	tristate &quot;Prolific PL-2301/2302/25A1 based cables&quot;</span>
<span class="p_add">+	tristate &quot;Prolific PL-2301/2302/25A1/27A1 based cables&quot;</span>
 	# if the handshake/init/reset problems, from original &#39;plusb&#39;,
 	# are ever resolved ... then remove &quot;experimental&quot;
 	depends on USB_USBNET
<span class="p_header">diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c</span>
<span class="p_header">index 22e1a9a99a7d..6fe59373cba9 100644</span>
<span class="p_header">--- a/drivers/net/usb/plusb.c</span>
<span class="p_header">+++ b/drivers/net/usb/plusb.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pl_reset(struct usbnet *dev)</span>
 }
 
 static const struct driver_info	prolific_info = {
<span class="p_del">-	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1&quot;,</span>
<span class="p_add">+	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1/PL-27A1&quot;,</span>
 	.flags =	FLAG_POINTTOPOINT | FLAG_NO_SETINT,
 		/* some PL-2302 versions seem to fail usb_set_interface() */
 	.reset =	pl_reset,
<span class="p_chunk">@@ -139,6 +139,17 @@</span> <span class="p_context"> static const struct usb_device_id	products [] = {</span>
 					 * Host-to-Host Cable
 					 */
 	.driver_info =  (unsigned long) &amp;prolific_info,
<span class="p_add">+</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
<span class="p_add">+/* super speed cables */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x067b, 0x27a1),     /* PL-27A1, no eeprom</span>
<span class="p_add">+					 * also: goobay Active USB 3.0</span>
<span class="p_add">+					 * Data Link,</span>
<span class="p_add">+					 * Unitek Y-3501</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	.driver_info =  (unsigned long) &amp;prolific_info,</span>
 },
 
 	{ },		// END
<span class="p_chunk">@@ -158,5 +169,5 @@</span> <span class="p_context"> static struct usb_driver plusb_driver = {</span>
 module_usb_driver(plusb_driver);
 
 MODULE_AUTHOR(&quot;David Brownell&quot;);
<span class="p_del">-MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1 USB Host to Host Link Driver&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1/27A1 USB Host to Host Link Driver&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">index be5b527472f9..90c0c4a7175d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> struct ath10k_peer {</span>
 	struct ieee80211_vif *vif;
 	struct ieee80211_sta *sta;
 
<span class="p_add">+	bool removed;</span>
 	int vdev_id;
 	u8 addr[ETH_ALEN];
 	DECLARE_BITMAP(peer_ids, ATH10K_MAX_NUM_PEER_IDS);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index f2e85eb22afe..30e98afa2e68 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -3738,6 +3738,9 @@</span> <span class="p_context"> struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,</span>
 	if (!peer)
 		return NULL;
 
<span class="p_add">+	if (peer-&gt;removed)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	if (peer-&gt;sta)
 		return peer-&gt;sta-&gt;txq[tid];
 	else if (peer-&gt;vif)
<span class="p_chunk">@@ -7422,6 +7425,20 @@</span> <span class="p_context"> ath10k_mac_op_switch_vif_chanctx(struct ieee80211_hw *hw,</span>
 	return 0;
 }
 
<span class="p_add">+static void ath10k_mac_op_sta_pre_rcu_remove(struct ieee80211_hw *hw,</span>
<span class="p_add">+					     struct ieee80211_vif *vif,</span>
<span class="p_add">+					     struct ieee80211_sta *sta)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath10k *ar;</span>
<span class="p_add">+	struct ath10k_peer *peer;</span>
<span class="p_add">+</span>
<span class="p_add">+	ar = hw-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(peer, &amp;ar-&gt;peers, list)</span>
<span class="p_add">+		if (peer-&gt;sta == sta)</span>
<span class="p_add">+			peer-&gt;removed = true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct ieee80211_ops ath10k_ops = {
 	.tx				= ath10k_mac_op_tx,
 	.wake_tx_queue			= ath10k_mac_op_wake_tx_queue,
<span class="p_chunk">@@ -7462,6 +7479,7 @@</span> <span class="p_context"> static const struct ieee80211_ops ath10k_ops = {</span>
 	.assign_vif_chanctx		= ath10k_mac_op_assign_vif_chanctx,
 	.unassign_vif_chanctx		= ath10k_mac_op_unassign_vif_chanctx,
 	.switch_vif_chanctx		= ath10k_mac_op_switch_vif_chanctx,
<span class="p_add">+	.sta_pre_rcu_remove		= ath10k_mac_op_sta_pre_rcu_remove,</span>
 
 	CFG80211_TESTMODE_CMD(ath10k_tm_cmd)
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_header">index 82d949ede294..4e725d165aa6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_chunk">@@ -6316,6 +6316,13 @@</span> <span class="p_context"> static struct usb_device_id dev_table[] = {</span>
 	.driver_info = (unsigned long)&amp;rtl8192cu_fops},
 {USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7822, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&amp;rtl8192cu_fops},
<span class="p_add">+/* found in rtl8192eu vendor driver */</span>
<span class="p_add">+{USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0107, 0xff, 0xff, 0xff),</span>
<span class="p_add">+	.driver_info = (unsigned long)&amp;rtl8192eu_fops},</span>
<span class="p_add">+{USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab33, 0xff, 0xff, 0xff),</span>
<span class="p_add">+	.driver_info = (unsigned long)&amp;rtl8192eu_fops},</span>
<span class="p_add">+{USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818c, 0xff, 0xff, 0xff),</span>
<span class="p_add">+	.driver_info = (unsigned long)&amp;rtl8192eu_fops},</span>
 #endif
 { }
 };
<span class="p_header">diff --git a/drivers/nvme/host/rdma.c b/drivers/nvme/host/rdma.c</span>
<span class="p_header">index 286fda4ee100..ab4f8db2a8ca 100644</span>
<span class="p_header">--- a/drivers/nvme/host/rdma.c</span>
<span class="p_header">+++ b/drivers/nvme/host/rdma.c</span>
<span class="p_chunk">@@ -337,8 +337,6 @@</span> <span class="p_context"> static int __nvme_rdma_init_request(struct nvme_rdma_ctrl *ctrl,</span>
 	struct ib_device *ibdev = dev-&gt;dev;
 	int ret;
 
<span class="p_del">-	BUG_ON(queue_idx &gt;= ctrl-&gt;queue_count);</span>
<span class="p_del">-</span>
 	ret = nvme_rdma_alloc_qe(ibdev, &amp;req-&gt;sqe, sizeof(struct nvme_command),
 			DMA_TO_DEVICE);
 	if (ret)
<span class="p_chunk">@@ -643,8 +641,22 @@</span> <span class="p_context"> static int nvme_rdma_connect_io_queues(struct nvme_rdma_ctrl *ctrl)</span>
 
 static int nvme_rdma_init_io_queues(struct nvme_rdma_ctrl *ctrl)
 {
<span class="p_add">+	struct nvmf_ctrl_options *opts = ctrl-&gt;ctrl.opts;</span>
<span class="p_add">+	unsigned int nr_io_queues;</span>
 	int i, ret;
 
<span class="p_add">+	nr_io_queues = min(opts-&gt;nr_io_queues, num_online_cpus());</span>
<span class="p_add">+	ret = nvme_set_queue_count(&amp;ctrl-&gt;ctrl, &amp;nr_io_queues);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctrl-&gt;queue_count = nr_io_queues + 1;</span>
<span class="p_add">+	if (ctrl-&gt;queue_count &lt; 2)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(ctrl-&gt;ctrl.device,</span>
<span class="p_add">+		&quot;creating %d I/O queues.\n&quot;, nr_io_queues);</span>
<span class="p_add">+</span>
 	for (i = 1; i &lt; ctrl-&gt;queue_count; i++) {
 		ret = nvme_rdma_init_queue(ctrl, i,
 					   ctrl-&gt;ctrl.opts-&gt;queue_size);
<span class="p_chunk">@@ -1795,20 +1807,8 @@</span> <span class="p_context"> static const struct nvme_ctrl_ops nvme_rdma_ctrl_ops = {</span>
 
 static int nvme_rdma_create_io_queues(struct nvme_rdma_ctrl *ctrl)
 {
<span class="p_del">-	struct nvmf_ctrl_options *opts = ctrl-&gt;ctrl.opts;</span>
 	int ret;
 
<span class="p_del">-	ret = nvme_set_queue_count(&amp;ctrl-&gt;ctrl, &amp;opts-&gt;nr_io_queues);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ctrl-&gt;queue_count = opts-&gt;nr_io_queues + 1;</span>
<span class="p_del">-	if (ctrl-&gt;queue_count &lt; 2)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_info(ctrl-&gt;ctrl.device,</span>
<span class="p_del">-		&quot;creating %d I/O queues.\n&quot;, opts-&gt;nr_io_queues);</span>
<span class="p_del">-</span>
 	ret = nvme_rdma_init_io_queues(ctrl);
 	if (ret)
 		return ret;
<span class="p_header">diff --git a/drivers/power/supply/axp288_fuel_gauge.c b/drivers/power/supply/axp288_fuel_gauge.c</span>
<span class="p_header">index 5bdde692f724..f62f9dfea984 100644</span>
<span class="p_header">--- a/drivers/power/supply/axp288_fuel_gauge.c</span>
<span class="p_header">+++ b/drivers/power/supply/axp288_fuel_gauge.c</span>
<span class="p_chunk">@@ -169,8 +169,10 @@</span> <span class="p_context"> static int fuel_gauge_reg_readb(struct axp288_fg_info *info, int reg)</span>
 			break;
 	}
 
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		dev_err(&amp;info-&gt;pdev-&gt;dev, &quot;axp288 reg read err:%d\n&quot;, ret);
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	return val;
 }
<span class="p_header">diff --git a/drivers/rapidio/devices/tsi721.c b/drivers/rapidio/devices/tsi721.c</span>
<span class="p_header">index 9d19b9a62011..315a4be8dc1e 100644</span>
<span class="p_header">--- a/drivers/rapidio/devices/tsi721.c</span>
<span class="p_header">+++ b/drivers/rapidio/devices/tsi721.c</span>
<span class="p_chunk">@@ -37,8 +37,8 @@</span> <span class="p_context"></span>
 #include &quot;tsi721.h&quot;
 
 #ifdef DEBUG
<span class="p_del">-u32 dbg_level;</span>
<span class="p_del">-module_param(dbg_level, uint, S_IWUSR | S_IRUGO);</span>
<span class="p_add">+u32 tsi_dbg_level;</span>
<span class="p_add">+module_param_named(dbg_level, tsi_dbg_level, uint, S_IWUSR | S_IRUGO);</span>
 MODULE_PARM_DESC(dbg_level, &quot;Debugging output level (default 0 = none)&quot;);
 #endif
 
<span class="p_header">diff --git a/drivers/rapidio/devices/tsi721.h b/drivers/rapidio/devices/tsi721.h</span>
<span class="p_header">index 5941437cbdd1..957eadc58150 100644</span>
<span class="p_header">--- a/drivers/rapidio/devices/tsi721.h</span>
<span class="p_header">+++ b/drivers/rapidio/devices/tsi721.h</span>
<span class="p_chunk">@@ -40,11 +40,11 @@</span> <span class="p_context"> enum {</span>
 };
 
 #ifdef DEBUG
<span class="p_del">-extern u32 dbg_level;</span>
<span class="p_add">+extern u32 tsi_dbg_level;</span>
 
 #define tsi_debug(level, dev, fmt, arg...)				\
 	do {								\
<span class="p_del">-		if (DBG_##level &amp; dbg_level)				\</span>
<span class="p_add">+		if (DBG_##level &amp; tsi_dbg_level)				\</span>
 			dev_dbg(dev, &quot;%s: &quot; fmt &quot;\n&quot;, __func__, ##arg);	\
 	} while (0)
 #else
<span class="p_header">diff --git a/drivers/reset/reset-ti-syscon.c b/drivers/reset/reset-ti-syscon.c</span>
<span class="p_header">index 47f0ffd3b013..1799fd423901 100644</span>
<span class="p_header">--- a/drivers/reset/reset-ti-syscon.c</span>
<span class="p_header">+++ b/drivers/reset/reset-ti-syscon.c</span>
<span class="p_chunk">@@ -154,8 +154,8 @@</span> <span class="p_context"> static int ti_syscon_reset_status(struct reset_controller_dev *rcdev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	return (reset_state &amp; BIT(control-&gt;status_bit)) &amp;&amp;</span>
<span class="p_del">-			(control-&gt;flags &amp; STATUS_SET);</span>
<span class="p_add">+	return !(reset_state &amp; BIT(control-&gt;status_bit)) ==</span>
<span class="p_add">+		!(control-&gt;flags &amp; STATUS_SET);</span>
 }
 
 static struct reset_control_ops ti_syscon_reset_ops = {
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c</span>
<span class="p_header">index ba258217614e..963c732a3d24 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_iscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_iscsi.c</span>
<span class="p_chunk">@@ -165,33 +165,6 @@</span> <span class="p_context"> beiscsi_conn_create(struct iscsi_cls_session *cls_session, u32 cid)</span>
 	return cls_conn;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * beiscsi_bindconn_cid - Bind the beiscsi_conn with phba connection table</span>
<span class="p_del">- * @beiscsi_conn: The pointer to  beiscsi_conn structure</span>
<span class="p_del">- * @phba: The phba instance</span>
<span class="p_del">- * @cid: The cid to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static int beiscsi_bindconn_cid(struct beiscsi_hba *phba,</span>
<span class="p_del">-				struct beiscsi_conn *beiscsi_conn,</span>
<span class="p_del">-				unsigned int cid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	uint16_t cri_index = BE_GET_CRI_FROM_CID(cid);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (phba-&gt;conn_table[cri_index]) {</span>
<span class="p_del">-		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,</span>
<span class="p_del">-			    &quot;BS_%d : Connection table already occupied. Detected clash\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,</span>
<span class="p_del">-			    &quot;BS_%d : phba-&gt;conn_table[%d]=%p(beiscsi_conn)\n&quot;,</span>
<span class="p_del">-			    cri_index, beiscsi_conn);</span>
<span class="p_del">-</span>
<span class="p_del">-		phba-&gt;conn_table[cri_index] = beiscsi_conn;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * beiscsi_conn_bind - Binds iscsi session/connection with TCP connection
  * @cls_session: pointer to iscsi cls session
<span class="p_chunk">@@ -212,6 +185,7 @@</span> <span class="p_context"> int beiscsi_conn_bind(struct iscsi_cls_session *cls_session,</span>
 	struct hwi_wrb_context *pwrb_context;
 	struct beiscsi_endpoint *beiscsi_ep;
 	struct iscsi_endpoint *ep;
<span class="p_add">+	uint16_t cri_index;</span>
 
 	ep = iscsi_lookup_endpoint(transport_fd);
 	if (!ep)
<span class="p_chunk">@@ -229,20 +203,34 @@</span> <span class="p_context"> int beiscsi_conn_bind(struct iscsi_cls_session *cls_session,</span>
 
 		return -EEXIST;
 	}
<span class="p_del">-</span>
<span class="p_del">-	pwrb_context = &amp;phwi_ctrlr-&gt;wrb_context[BE_GET_CRI_FROM_CID(</span>
<span class="p_del">-						beiscsi_ep-&gt;ep_cid)];</span>
<span class="p_add">+	cri_index = BE_GET_CRI_FROM_CID(beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+	if (phba-&gt;conn_table[cri_index]) {</span>
<span class="p_add">+		if (beiscsi_conn != phba-&gt;conn_table[cri_index] ||</span>
<span class="p_add">+		    beiscsi_ep != phba-&gt;conn_table[cri_index]-&gt;ep) {</span>
<span class="p_add">+			__beiscsi_log(phba, KERN_ERR,</span>
<span class="p_add">+				      &quot;BS_%d : conn_table not empty at %u: cid %u conn %p:%p\n&quot;,</span>
<span class="p_add">+				      cri_index,</span>
<span class="p_add">+				      beiscsi_ep-&gt;ep_cid,</span>
<span class="p_add">+				      beiscsi_conn,</span>
<span class="p_add">+				      phba-&gt;conn_table[cri_index]);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	beiscsi_conn-&gt;beiscsi_conn_cid = beiscsi_ep-&gt;ep_cid;
 	beiscsi_conn-&gt;ep = beiscsi_ep;
 	beiscsi_ep-&gt;conn = beiscsi_conn;
<span class="p_add">+	/**</span>
<span class="p_add">+	 * Each connection is associated with a WRBQ kept in wrb_context.</span>
<span class="p_add">+	 * Store doorbell offset for transmit path.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pwrb_context = &amp;phwi_ctrlr-&gt;wrb_context[cri_index];</span>
 	beiscsi_conn-&gt;doorbell_offset = pwrb_context-&gt;doorbell_offset;
<span class="p_del">-</span>
 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
<span class="p_del">-		    &quot;BS_%d : beiscsi_conn=%p conn=%p ep_cid=%d\n&quot;,</span>
<span class="p_del">-		    beiscsi_conn, conn, beiscsi_ep-&gt;ep_cid);</span>
<span class="p_del">-</span>
<span class="p_del">-	return beiscsi_bindconn_cid(phba, beiscsi_conn, beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+		    &quot;BS_%d : cid %d phba-&gt;conn_table[%u]=%p\n&quot;,</span>
<span class="p_add">+		    beiscsi_ep-&gt;ep_cid, cri_index, beiscsi_conn);</span>
<span class="p_add">+	phba-&gt;conn_table[cri_index] = beiscsi_conn;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int beiscsi_iface_create_ipv4(struct beiscsi_hba *phba)
<span class="p_chunk">@@ -973,9 +961,9 @@</span> <span class="p_context"> int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn)</span>
  */
 static int beiscsi_get_cid(struct beiscsi_hba *phba)
 {
<span class="p_del">-	unsigned short cid = 0xFFFF, cid_from_ulp;</span>
<span class="p_del">-	struct ulp_cid_info *cid_info = NULL;</span>
 	uint16_t cid_avlbl_ulp0, cid_avlbl_ulp1;
<span class="p_add">+	unsigned short cid, cid_from_ulp;</span>
<span class="p_add">+	struct ulp_cid_info *cid_info;</span>
 
 	/* Find the ULP which has more CID available */
 	cid_avlbl_ulp0 = (phba-&gt;cid_array_info[BEISCSI_ULP0]) ?
<span class="p_chunk">@@ -984,20 +972,27 @@</span> <span class="p_context"> static int beiscsi_get_cid(struct beiscsi_hba *phba)</span>
 			  BEISCSI_ULP1_AVLBL_CID(phba) : 0;
 	cid_from_ulp = (cid_avlbl_ulp0 &gt; cid_avlbl_ulp1) ?
 			BEISCSI_ULP0 : BEISCSI_ULP1;
<span class="p_del">-</span>
<span class="p_del">-	if (test_bit(cid_from_ulp, (void *)&amp;phba-&gt;fw_config.ulp_supported)) {</span>
<span class="p_del">-		cid_info = phba-&gt;cid_array_info[cid_from_ulp];</span>
<span class="p_del">-		if (!cid_info-&gt;avlbl_cids)</span>
<span class="p_del">-			return cid;</span>
<span class="p_del">-</span>
<span class="p_del">-		cid = cid_info-&gt;cid_array[cid_info-&gt;cid_alloc++];</span>
<span class="p_del">-</span>
<span class="p_del">-		if (cid_info-&gt;cid_alloc == BEISCSI_GET_CID_COUNT(</span>
<span class="p_del">-					   phba, cid_from_ulp))</span>
<span class="p_del">-			cid_info-&gt;cid_alloc = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		cid_info-&gt;avlbl_cids--;</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * If iSCSI protocol is loaded only on ULP 0, and when cid_avlbl_ulp</span>
<span class="p_add">+	 * is ZERO for both, ULP 1 is returned.</span>
<span class="p_add">+	 * Check if ULP is loaded before getting new CID.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!test_bit(cid_from_ulp, (void *)&amp;phba-&gt;fw_config.ulp_supported))</span>
<span class="p_add">+		return BE_INVALID_CID;</span>
<span class="p_add">+</span>
<span class="p_add">+	cid_info = phba-&gt;cid_array_info[cid_from_ulp];</span>
<span class="p_add">+	cid = cid_info-&gt;cid_array[cid_info-&gt;cid_alloc];</span>
<span class="p_add">+	if (!cid_info-&gt;avlbl_cids || cid == BE_INVALID_CID) {</span>
<span class="p_add">+		__beiscsi_log(phba, KERN_ERR,</span>
<span class="p_add">+				&quot;BS_%d : failed to get cid: available %u:%u\n&quot;,</span>
<span class="p_add">+				cid_info-&gt;avlbl_cids, cid_info-&gt;cid_free);</span>
<span class="p_add">+		return BE_INVALID_CID;</span>
 	}
<span class="p_add">+	/* empty the slot */</span>
<span class="p_add">+	cid_info-&gt;cid_array[cid_info-&gt;cid_alloc++] = BE_INVALID_CID;</span>
<span class="p_add">+	if (cid_info-&gt;cid_alloc == BEISCSI_GET_CID_COUNT(phba, cid_from_ulp))</span>
<span class="p_add">+		cid_info-&gt;cid_alloc = 0;</span>
<span class="p_add">+	cid_info-&gt;avlbl_cids--;</span>
 	return cid;
 }
 
<span class="p_chunk">@@ -1008,22 +1003,28 @@</span> <span class="p_context"> static int beiscsi_get_cid(struct beiscsi_hba *phba)</span>
  */
 static void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)
 {
<span class="p_del">-	uint16_t cid_post_ulp;</span>
<span class="p_del">-	struct hwi_controller *phwi_ctrlr;</span>
<span class="p_del">-	struct hwi_wrb_context *pwrb_context;</span>
<span class="p_del">-	struct ulp_cid_info *cid_info = NULL;</span>
 	uint16_t cri_index = BE_GET_CRI_FROM_CID(cid);
<span class="p_add">+	struct hwi_wrb_context *pwrb_context;</span>
<span class="p_add">+	struct hwi_controller *phwi_ctrlr;</span>
<span class="p_add">+	struct ulp_cid_info *cid_info;</span>
<span class="p_add">+	uint16_t cid_post_ulp;</span>
 
 	phwi_ctrlr = phba-&gt;phwi_ctrlr;
 	pwrb_context = &amp;phwi_ctrlr-&gt;wrb_context[cri_index];
 	cid_post_ulp = pwrb_context-&gt;ulp_num;
 
 	cid_info = phba-&gt;cid_array_info[cid_post_ulp];
<span class="p_del">-	cid_info-&gt;avlbl_cids++;</span>
<span class="p_del">-</span>
<span class="p_add">+	/* fill only in empty slot */</span>
<span class="p_add">+	if (cid_info-&gt;cid_array[cid_info-&gt;cid_free] != BE_INVALID_CID) {</span>
<span class="p_add">+		__beiscsi_log(phba, KERN_ERR,</span>
<span class="p_add">+			      &quot;BS_%d : failed to put cid %u: available %u:%u\n&quot;,</span>
<span class="p_add">+			      cid, cid_info-&gt;avlbl_cids, cid_info-&gt;cid_free);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	cid_info-&gt;cid_array[cid_info-&gt;cid_free++] = cid;
 	if (cid_info-&gt;cid_free == BEISCSI_GET_CID_COUNT(phba, cid_post_ulp))
 		cid_info-&gt;cid_free = 0;
<span class="p_add">+	cid_info-&gt;avlbl_cids++;</span>
 }
 
 /**
<span class="p_chunk">@@ -1037,8 +1038,8 @@</span> <span class="p_context"> static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)</span>
 
 	beiscsi_put_cid(phba, beiscsi_ep-&gt;ep_cid);
 	beiscsi_ep-&gt;phba = NULL;
<span class="p_del">-	phba-&gt;ep_array[BE_GET_CRI_FROM_CID</span>
<span class="p_del">-		       (beiscsi_ep-&gt;ep_cid)] = NULL;</span>
<span class="p_add">+	/* clear this to track freeing in beiscsi_ep_disconnect */</span>
<span class="p_add">+	phba-&gt;ep_array[BE_GET_CRI_FROM_CID(beiscsi_ep-&gt;ep_cid)] = NULL;</span>
 
 	/**
 	 * Check if any connection resource allocated by driver
<span class="p_chunk">@@ -1049,6 +1050,11 @@</span> <span class="p_context"> static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)</span>
 		return;
 
 	beiscsi_conn = beiscsi_ep-&gt;conn;
<span class="p_add">+	/**</span>
<span class="p_add">+	 * Break ep-&gt;conn link here so that completions after</span>
<span class="p_add">+	 * this are ignored.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	beiscsi_ep-&gt;conn = NULL;</span>
 	if (beiscsi_conn-&gt;login_in_progress) {
 		beiscsi_free_mgmt_task_handles(beiscsi_conn,
 					       beiscsi_conn-&gt;task);
<span class="p_chunk">@@ -1079,7 +1085,7 @@</span> <span class="p_context"> static int beiscsi_open_conn(struct iscsi_endpoint *ep,</span>
 		    &quot;BS_%d : In beiscsi_open_conn\n&quot;);
 
 	beiscsi_ep-&gt;ep_cid = beiscsi_get_cid(phba);
<span class="p_del">-	if (beiscsi_ep-&gt;ep_cid == 0xFFFF) {</span>
<span class="p_add">+	if (beiscsi_ep-&gt;ep_cid == BE_INVALID_CID) {</span>
 		beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_CONFIG,
 			    &quot;BS_%d : No free cid available\n&quot;);
 		return ret;
<span class="p_chunk">@@ -1284,26 +1290,6 @@</span> <span class="p_context"> static int beiscsi_close_conn(struct  beiscsi_endpoint *beiscsi_ep, int flag)</span>
 	return ret;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * beiscsi_unbind_conn_to_cid - Unbind the beiscsi_conn from phba conn table</span>
<span class="p_del">- * @phba: The phba instance</span>
<span class="p_del">- * @cid: The cid to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba,</span>
<span class="p_del">-				      unsigned int cid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	uint16_t cri_index = BE_GET_CRI_FROM_CID(cid);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (phba-&gt;conn_table[cri_index])</span>
<span class="p_del">-		phba-&gt;conn_table[cri_index] = NULL;</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,</span>
<span class="p_del">-			    &quot;BS_%d : Connection table Not occupied.\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * beiscsi_ep_disconnect - Tears down the TCP connection
  * @ep:	endpoint to be used
<span class="p_chunk">@@ -1318,13 +1304,23 @@</span> <span class="p_context"> void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)</span>
 	unsigned int tag;
 	uint8_t mgmt_invalidate_flag, tcp_upload_flag;
 	unsigned short savecfg_flag = CMD_ISCSI_SESSION_SAVE_CFG_ON_FLASH;
<span class="p_add">+	uint16_t cri_index;</span>
 
 	beiscsi_ep = ep-&gt;dd_data;
 	phba = beiscsi_ep-&gt;phba;
 	beiscsi_log(phba, KERN_INFO, BEISCSI_LOG_CONFIG,
<span class="p_del">-		    &quot;BS_%d : In beiscsi_ep_disconnect for ep_cid = %d\n&quot;,</span>
<span class="p_add">+		    &quot;BS_%d : In beiscsi_ep_disconnect for ep_cid = %u\n&quot;,</span>
 		    beiscsi_ep-&gt;ep_cid);
 
<span class="p_add">+	cri_index = BE_GET_CRI_FROM_CID(beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+	if (!phba-&gt;ep_array[cri_index]) {</span>
<span class="p_add">+		__beiscsi_log(phba, KERN_ERR,</span>
<span class="p_add">+			      &quot;BS_%d : ep_array at %u cid %u empty\n&quot;,</span>
<span class="p_add">+			      cri_index,</span>
<span class="p_add">+			      beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (beiscsi_ep-&gt;conn) {
 		beiscsi_conn = beiscsi_ep-&gt;conn;
 		iscsi_suspend_queue(beiscsi_conn-&gt;conn);
<span class="p_chunk">@@ -1356,7 +1352,12 @@</span> <span class="p_context"> void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)</span>
 free_ep:
 	msleep(BEISCSI_LOGOUT_SYNC_DELAY);
 	beiscsi_free_ep(beiscsi_ep);
<span class="p_del">-	beiscsi_unbind_conn_to_cid(phba, beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+	if (!phba-&gt;conn_table[cri_index])</span>
<span class="p_add">+		__beiscsi_log(phba, KERN_ERR,</span>
<span class="p_add">+				&quot;BS_%d : conn_table empty at %u: cid %u\n&quot;,</span>
<span class="p_add">+				cri_index,</span>
<span class="p_add">+				beiscsi_ep-&gt;ep_cid);</span>
<span class="p_add">+	phba-&gt;conn_table[cri_index] = NULL;</span>
 	iscsi_destroy_endpoint(beiscsi_ep-&gt;openiscsi_ep);
 }
 
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index d9239c2d49b1..741cc96379cb 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -4085,9 +4085,10 @@</span> <span class="p_context"> static int hba_setup_cid_tbls(struct beiscsi_hba *phba)</span>
 			}
 
 			/* Allocate memory for CID array */
<span class="p_del">-			ptr_cid_info-&gt;cid_array = kzalloc(sizeof(void *) *</span>
<span class="p_del">-						  BEISCSI_GET_CID_COUNT(phba,</span>
<span class="p_del">-						  ulp_num), GFP_KERNEL);</span>
<span class="p_add">+			ptr_cid_info-&gt;cid_array =</span>
<span class="p_add">+				kcalloc(BEISCSI_GET_CID_COUNT(phba, ulp_num),</span>
<span class="p_add">+					sizeof(*ptr_cid_info-&gt;cid_array),</span>
<span class="p_add">+					GFP_KERNEL);</span>
 			if (!ptr_cid_info-&gt;cid_array) {
 				beiscsi_log(phba, KERN_ERR, BEISCSI_LOG_INIT,
 					    &quot;BM_%d : Failed to allocate memory&quot;
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.h b/drivers/scsi/be2iscsi/be_main.h</span>
<span class="p_header">index 6376657e45f7..02d00ab6d981 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.h</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.h</span>
<span class="p_chunk">@@ -358,6 +358,7 @@</span> <span class="p_context"> struct beiscsi_hba {</span>
 	unsigned int age;
 	struct list_head hba_queue;
 #define BE_MAX_SESSION 2048
<span class="p_add">+#define BE_INVALID_CID 0xffff</span>
 #define BE_SET_CID_TO_CRI(cri_index, cid) \
 			  (phba-&gt;cid_to_cri_map[cid] = cri_index)
 #define BE_GET_CRI_FROM_CID(cid) (phba-&gt;cid_to_cri_map[cid])
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index d6239fa718be..3f3751e2b521 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -1458,6 +1458,10 @@</span> <span class="p_context"> static const struct pci_device_id pxa2xx_spi_pci_compound_match[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1ac2), LPSS_BXT_SSP },
 	{ PCI_VDEVICE(INTEL, 0x1ac4), LPSS_BXT_SSP },
 	{ PCI_VDEVICE(INTEL, 0x1ac6), LPSS_BXT_SSP },
<span class="p_add">+	/* GLK */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x31c2), LPSS_BXT_SSP },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x31c4), LPSS_BXT_SSP },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x31c6), LPSS_BXT_SSP },</span>
 	/* APL */
 	{ PCI_VDEVICE(INTEL, 0x5ac2), LPSS_BXT_SSP },
 	{ PCI_VDEVICE(INTEL, 0x5ac4), LPSS_BXT_SSP },
<span class="p_header">diff --git a/drivers/tty/goldfish.c b/drivers/tty/goldfish.c</span>
<span class="p_header">index 3fc912373adf..996bd473dd03 100644</span>
<span class="p_header">--- a/drivers/tty/goldfish.c</span>
<span class="p_header">+++ b/drivers/tty/goldfish.c</span>
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static int goldfish_tty_probe(struct platform_device *pdev)</span>
 	return 0;
 
 err_tty_register_device_failed:
<span class="p_del">-	free_irq(irq, pdev);</span>
<span class="p_add">+	free_irq(irq, qtty);</span>
 err_request_irq_failed:
 	goldfish_tty_current_line_count--;
 	if (goldfish_tty_current_line_count == 0)
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_moxa.c b/drivers/tty/serial/8250/8250_moxa.c</span>
<span class="p_header">index 26eb5393a263..d5069b2d4d79 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_moxa.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_moxa.c</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> static int moxa8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 			   sizeof(unsigned int) * nr_ports, GFP_KERNEL);
 	if (!brd)
 		return -ENOMEM;
<span class="p_add">+	brd-&gt;num_ports = nr_ports;</span>
 
 	memset(&amp;uart, 0, sizeof(struct uart_8250_port));
 
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">index f24d3030b98c..1ef31e3ee4a1 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_chunk">@@ -1751,8 +1751,6 @@</span> <span class="p_context"> void serial8250_tx_chars(struct uart_8250_port *up)</span>
 	if (uart_circ_chars_pending(xmit) &lt; WAKEUP_CHARS)
 		uart_write_wakeup(port);
 
<span class="p_del">-	pr_debug(&quot;%s: THRE\n&quot;, __func__);</span>
<span class="p_del">-</span>
 	/*
 	 * With RPM enabled, we have to wait until the FIFO is empty before the
 	 * HW can go idle. So we get here once again with empty FIFO and disable
<span class="p_chunk">@@ -1817,8 +1815,6 @@</span> <span class="p_context"> int serial8250_handle_irq(struct uart_port *port, unsigned int iir)</span>
 
 	status = serial_port_in(port, UART_LSR);
 
<span class="p_del">-	pr_debug(&quot;%s: status = %x\n&quot;, __func__, status);</span>
<span class="p_del">-</span>
 	if (status &amp; (UART_LSR_DR | UART_LSR_BI)) {
 		if (!up-&gt;dma || handle_rx_dma(up, iir))
 			status = serial8250_rx_chars(up, status);
<span class="p_header">diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c</span>
<span class="p_header">index 0cf149edddd8..f36a1ac3bfbd 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/otg.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/otg.c</span>
<span class="p_chunk">@@ -134,9 +134,9 @@</span> <span class="p_context"> void ci_handle_vbus_change(struct ci_hdrc *ci)</span>
 	if (!ci-&gt;is_otg)
 		return;
 
<span class="p_del">-	if (hw_read_otgsc(ci, OTGSC_BSV))</span>
<span class="p_add">+	if (hw_read_otgsc(ci, OTGSC_BSV) &amp;&amp; !ci-&gt;vbus_active)</span>
 		usb_gadget_vbus_connect(&amp;ci-&gt;gadget);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (!hw_read_otgsc(ci, OTGSC_BSV) &amp;&amp; ci-&gt;vbus_active)</span>
 		usb_gadget_vbus_disconnect(&amp;ci-&gt;gadget);
 }
 
<span class="p_chunk">@@ -175,14 +175,21 @@</span> <span class="p_context"> static void ci_handle_id_switch(struct ci_hdrc *ci)</span>
 
 		ci_role_stop(ci);
 
<span class="p_del">-		if (role == CI_ROLE_GADGET)</span>
<span class="p_add">+		if (role == CI_ROLE_GADGET &amp;&amp;</span>
<span class="p_add">+				IS_ERR(ci-&gt;platdata-&gt;vbus_extcon.edev))</span>
 			/*
<span class="p_del">-			 * wait vbus lower than OTGSC_BSV before connecting</span>
<span class="p_del">-			 * to host</span>
<span class="p_add">+			 * Wait vbus lower than OTGSC_BSV before connecting</span>
<span class="p_add">+			 * to host. If connecting status is from an external</span>
<span class="p_add">+			 * connector instead of register, we don&#39;t need to</span>
<span class="p_add">+			 * care vbus on the board, since it will not affect</span>
<span class="p_add">+			 * external connector status.</span>
 			 */
 			hw_wait_vbus_lower_bsv(ci);
 
 		ci_role_start(ci, role);
<span class="p_add">+		/* vbus change may have already occurred */</span>
<span class="p_add">+		if (role == CI_ROLE_GADGET)</span>
<span class="p_add">+			ci_handle_vbus_change(ci);</span>
 	}
 }
 /**
<span class="p_header">diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig</span>
<span class="p_header">index 0b80cee30da4..eb121b2a55d4 100644</span>
<span class="p_header">--- a/drivers/usb/host/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/host/Kconfig</span>
<span class="p_chunk">@@ -45,9 +45,9 @@</span> <span class="p_context"> config USB_XHCI_PLATFORM</span>
 	  If unsure, say N.
 
 config USB_XHCI_MTK
<span class="p_del">-	tristate &quot;xHCI support for Mediatek MT65xx&quot;</span>
<span class="p_add">+	tristate &quot;xHCI support for Mediatek MT65xx/MT7621&quot;</span>
 	select MFD_SYSCON
<span class="p_del">-	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	depends on (MIPS &amp;&amp; SOC_MT7621) || ARCH_MEDIATEK || COMPILE_TEST</span>
 	---help---
 	  Say &#39;Y&#39; to enable the support for the xHCI host controller
 	  found in Mediatek MT65xx SoCs.
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index 136ff5e1b7c1..135eb04368f9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -234,11 +234,16 @@</span> <span class="p_context"> static int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,</span>
 
 	status = usb_control_msg(usbdev, pipe, request, requesttype, value,
 				     index, buf, 1, MOS_WDR_TIMEOUT);
<span class="p_del">-	if (status == 1)</span>
<span class="p_add">+	if (status == 1) {</span>
 		*data = *buf;
<span class="p_del">-	else if (status &lt; 0)</span>
<span class="p_add">+	} else {</span>
 		dev_err(&amp;usbdev-&gt;dev,
 			&quot;mos7720: usb_control_msg() failed: %d\n&quot;, status);
<span class="p_add">+		if (status &gt;= 0)</span>
<span class="p_add">+			status = -EIO;</span>
<span class="p_add">+		*data = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(buf);
 
 	return status;
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 5c4fc3abf6a7..6baacf64b21e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -285,9 +285,15 @@</span> <span class="p_context"> static int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*val = buf[0];
 	dev_dbg(&amp;port-&gt;dev, &quot;%s offset is %x, return val %x\n&quot;, __func__, reg, *val);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -353,8 +359,13 @@</span> <span class="p_context"> static int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	*val = buf[0];
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -1490,10 +1501,10 @@</span> <span class="p_context"> static int mos7840_tiocmget(struct tty_struct *tty)</span>
 		return -ENODEV;
 
 	status = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &amp;msr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	status = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &amp;mcr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	result = ((mcr &amp; MCR_DTR) ? TIOCM_DTR : 0)
 	    | ((mcr &amp; MCR_RTS) ? TIOCM_RTS : 0)
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 8a05fa7e2152..f089d7d8afe7 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -8050,8 +8050,10 @@</span> <span class="p_context"> static int __btrfs_correct_data_nocsum(struct inode *inode,</span>
 
 		start += sectorsize;
 
<span class="p_del">-		if (nr_sectors--) {</span>
<span class="p_add">+		nr_sectors--;</span>
<span class="p_add">+		if (nr_sectors) {</span>
 			pgoff += sectorsize;
<span class="p_add">+			ASSERT(pgoff &lt; PAGE_SIZE);</span>
 			goto next_block_or_try_again;
 		}
 	}
<span class="p_chunk">@@ -8157,8 +8159,10 @@</span> <span class="p_context"> static int __btrfs_subio_endio_read(struct inode *inode,</span>
 
 		ASSERT(nr_sectors);
 
<span class="p_del">-		if (--nr_sectors) {</span>
<span class="p_add">+		nr_sectors--;</span>
<span class="p_add">+		if (nr_sectors) {</span>
 			pgoff += sectorsize;
<span class="p_add">+			ASSERT(pgoff &lt; PAGE_SIZE);</span>
 			goto next_block;
 		}
 	}
<span class="p_header">diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c</span>
<span class="p_header">index 71a60cc01451..06a77e47957d 100644</span>
<span class="p_header">--- a/fs/btrfs/volumes.c</span>
<span class="p_header">+++ b/fs/btrfs/volumes.c</span>
<span class="p_chunk">@@ -6226,7 +6226,7 @@</span> <span class="p_context"> int btrfs_map_bio(struct btrfs_root *root, struct bio *bio,</span>
 	for (dev_nr = 0; dev_nr &lt; total_devs; dev_nr++) {
 		dev = bbio-&gt;stripes[dev_nr].dev;
 		if (!dev || !dev-&gt;bdev ||
<span class="p_del">-		    (bio_op(bio) == REQ_OP_WRITE &amp;&amp; !dev-&gt;writeable)) {</span>
<span class="p_add">+		    (bio_op(first_bio) == REQ_OP_WRITE &amp;&amp; !dev-&gt;writeable)) {</span>
 			bbio_error(bbio, first_bio, logical);
 			continue;
 		}
<span class="p_header">diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c</span>
<span class="p_header">index f7cae1629c6c..7a8b1d72e3d9 100644</span>
<span class="p_header">--- a/fs/gfs2/glock.c</span>
<span class="p_header">+++ b/fs/gfs2/glock.c</span>
<span class="p_chunk">@@ -1820,16 +1820,18 @@</span> <span class="p_context"> void gfs2_glock_exit(void)</span>
 
 static void gfs2_glock_iter_next(struct gfs2_glock_iter *gi)
 {
<span class="p_del">-	do {</span>
<span class="p_del">-		gi-&gt;gl = rhashtable_walk_next(&amp;gi-&gt;hti);</span>
<span class="p_add">+	while ((gi-&gt;gl = rhashtable_walk_next(&amp;gi-&gt;hti))) {</span>
 		if (IS_ERR(gi-&gt;gl)) {
 			if (PTR_ERR(gi-&gt;gl) == -EAGAIN)
 				continue;
 			gi-&gt;gl = NULL;
<span class="p_add">+			return;</span>
 		}
<span class="p_del">-	/* Skip entries for other sb and dead entries */</span>
<span class="p_del">-	} while ((gi-&gt;gl) &amp;&amp; ((gi-&gt;sdp != gi-&gt;gl-&gt;gl_name.ln_sbd) ||</span>
<span class="p_del">-			      __lockref_is_dead(&amp;gi-&gt;gl-&gt;gl_lockref)));</span>
<span class="p_add">+		/* Skip entries for other sb and dead entries */</span>
<span class="p_add">+		if (gi-&gt;sdp == gi-&gt;gl-&gt;gl_name.ln_sbd &amp;&amp;</span>
<span class="p_add">+		    !__lockref_is_dead(&amp;gi-&gt;gl-&gt;gl_lockref))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 }
 
 static void *gfs2_glock_seq_start(struct seq_file *seq, loff_t *pos)
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 704fa0b17309..2c2f182cde03 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -695,14 +695,11 @@</span> <span class="p_context"> static struct inode *hugetlbfs_get_root(struct super_block *sb,</span>
 
 	inode = new_inode(sb);
 	if (inode) {
<span class="p_del">-		struct hugetlbfs_inode_info *info;</span>
 		inode-&gt;i_ino = get_next_ino();
 		inode-&gt;i_mode = S_IFDIR | config-&gt;mode;
 		inode-&gt;i_uid = config-&gt;uid;
 		inode-&gt;i_gid = config-&gt;gid;
 		inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);
<span class="p_del">-		info = HUGETLBFS_I(inode);</span>
<span class="p_del">-		mpol_shared_policy_init(&amp;info-&gt;policy, NULL);</span>
 		inode-&gt;i_op = &amp;hugetlbfs_dir_inode_operations;
 		inode-&gt;i_fop = &amp;simple_dir_operations;
 		/* directory inodes start off with i_nlink == 2 (for &quot;.&quot; entry) */
<span class="p_chunk">@@ -733,7 +730,6 @@</span> <span class="p_context"> static struct inode *hugetlbfs_get_inode(struct super_block *sb,</span>
 
 	inode = new_inode(sb);
 	if (inode) {
<span class="p_del">-		struct hugetlbfs_inode_info *info;</span>
 		inode-&gt;i_ino = get_next_ino();
 		inode_init_owner(inode, dir, mode);
 		lockdep_set_class(&amp;inode-&gt;i_mapping-&gt;i_mmap_rwsem,
<span class="p_chunk">@@ -741,15 +737,6 @@</span> <span class="p_context"> static struct inode *hugetlbfs_get_inode(struct super_block *sb,</span>
 		inode-&gt;i_mapping-&gt;a_ops = &amp;hugetlbfs_aops;
 		inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);
 		inode-&gt;i_mapping-&gt;private_data = resv_map;
<span class="p_del">-		info = HUGETLBFS_I(inode);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The policy is initialized here even if we are creating a</span>
<span class="p_del">-		 * private inode because initialization simply creates an</span>
<span class="p_del">-		 * an empty rb tree and calls rwlock_init(), later when we</span>
<span class="p_del">-		 * call mpol_free_shared_policy() it will just return because</span>
<span class="p_del">-		 * the rb tree will still be empty.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mpol_shared_policy_init(&amp;info-&gt;policy, NULL);</span>
 		switch (mode &amp; S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
<span class="p_chunk">@@ -937,6 +924,18 @@</span> <span class="p_context"> static struct inode *hugetlbfs_alloc_inode(struct super_block *sb)</span>
 		hugetlbfs_inc_free_inodes(sbinfo);
 		return NULL;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Any time after allocation, hugetlbfs_destroy_inode can be called</span>
<span class="p_add">+	 * for the inode.  mpol_free_shared_policy is unconditionally called</span>
<span class="p_add">+	 * as part of hugetlbfs_destroy_inode.  So, initialize policy here</span>
<span class="p_add">+	 * in case of a quick call to destroy.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that the policy is initialized even if we are creating a</span>
<span class="p_add">+	 * private inode.  This simplifies hugetlbfs_destroy_inode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mpol_shared_policy_init(&amp;p-&gt;policy, NULL);</span>
<span class="p_add">+</span>
 	return &amp;p-&gt;vfs_inode;
 }
 
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 582bfee40345..af84a92cb142 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -239,12 +239,12 @@</span> <span class="p_context"> static struct svc_serv_ops nfs41_cb_sv_ops = {</span>
 	.svo_module		= THIS_MODULE,
 };
 
<span class="p_del">-struct svc_serv_ops *nfs4_cb_sv_ops[] = {</span>
<span class="p_add">+static struct svc_serv_ops *nfs4_cb_sv_ops[] = {</span>
 	[0] = &amp;nfs40_cb_sv_ops,
 	[1] = &amp;nfs41_cb_sv_ops,
 };
 #else
<span class="p_del">-struct svc_serv_ops *nfs4_cb_sv_ops[] = {</span>
<span class="p_add">+static struct svc_serv_ops *nfs4_cb_sv_ops[] = {</span>
 	[0] = &amp;nfs40_cb_sv_ops,
 	[1] = NULL,
 };
<span class="p_header">diff --git a/fs/xfs/kmem.c b/fs/xfs/kmem.c</span>
<span class="p_header">index 339c696bbc01..bb2beaef531a 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.c</span>
<span class="p_header">+++ b/fs/xfs/kmem.c</span>
<span class="p_chunk">@@ -24,24 +24,6 @@</span> <span class="p_context"></span>
 #include &quot;kmem.h&quot;
 #include &quot;xfs_message.h&quot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * Greedy allocation.  May fail and may return vmalloced memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-void *</span>
<span class="p_del">-kmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void		*ptr;</span>
<span class="p_del">-	size_t		kmsize = maxsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (!(ptr = vzalloc(kmsize))) {</span>
<span class="p_del">-		if ((kmsize &gt;&gt;= 1) &lt;= minsize)</span>
<span class="p_del">-			kmsize = minsize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ptr)</span>
<span class="p_del">-		*size = kmsize;</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void *
 kmem_alloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/kmem.h b/fs/xfs/kmem.h</span>
<span class="p_header">index 689f746224e7..f0fc84fcaac2 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.h</span>
<span class="p_header">+++ b/fs/xfs/kmem.h</span>
<span class="p_chunk">@@ -69,8 +69,6 @@</span> <span class="p_context"> static inline void  kmem_free(const void *ptr)</span>
 }
 
 
<span class="p_del">-extern void *kmem_zalloc_greedy(size_t *, size_t, size_t);</span>
<span class="p_del">-</span>
 static inline void *
 kmem_zalloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c</span>
<span class="p_header">index d8a77dbf4e3a..26d67ce3c18d 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_itable.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_itable.c</span>
<span class="p_chunk">@@ -361,7 +361,6 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	xfs_agino_t		agino;	/* inode # in allocation group */
 	xfs_agnumber_t		agno;	/* allocation group number */
 	xfs_btree_cur_t		*cur;	/* btree cursor for ialloc btree */
<span class="p_del">-	size_t			irbsize; /* size of irec buffer in bytes */</span>
 	xfs_inobt_rec_incore_t	*irbuf;	/* start of irec buffer */
 	int			nirbuf;	/* size of irbuf */
 	int			ubcount; /* size of user&#39;s buffer */
<span class="p_chunk">@@ -388,11 +387,10 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	*ubcountp = 0;
 	*done = 0;
 
<span class="p_del">-	irbuf = kmem_zalloc_greedy(&amp;irbsize, PAGE_SIZE, PAGE_SIZE * 4);</span>
<span class="p_add">+	irbuf = kmem_zalloc_large(PAGE_SIZE * 4, KM_SLEEP);</span>
 	if (!irbuf)
 		return -ENOMEM;
<span class="p_del">-</span>
<span class="p_del">-	nirbuf = irbsize / sizeof(*irbuf);</span>
<span class="p_add">+	nirbuf = (PAGE_SIZE * 4) / sizeof(*irbuf);</span>
 
 	/*
 	 * Loop over the allocation groups, starting from the last
<span class="p_header">diff --git a/include/linux/audit.h b/include/linux/audit.h</span>
<span class="p_header">index 9d4443f93db6..2be99b276d29 100644</span>
<span class="p_header">--- a/include/linux/audit.h</span>
<span class="p_header">+++ b/include/linux/audit.h</span>
<span class="p_chunk">@@ -387,6 +387,20 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 		return __audit_socketcall(nargs, args);
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long a[AUDITSC_ARGS];</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (audit_dummy_context())</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nargs; i++)</span>
<span class="p_add">+		a[i] = (unsigned long)args[i];</span>
<span class="p_add">+	return __audit_socketcall(nargs, a);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int audit_sockaddr(int len, void *addr)
 {
 	if (unlikely(!audit_dummy_context()))
<span class="p_chunk">@@ -513,6 +527,12 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 {
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void audit_fd_pair(int fd1, int fd2)
 { }
 static inline int audit_sockaddr(int len, void *addr)
<span class="p_header">diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h</span>
<span class="p_header">index aab032a6ae61..97ca105347a6 100644</span>
<span class="p_header">--- a/include/linux/mmc/sdio_func.h</span>
<span class="p_header">+++ b/include/linux/mmc/sdio_func.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> struct sdio_func {</span>
 	unsigned int		state;		/* function state */
 #define SDIO_STATE_PRESENT	(1&lt;&lt;0)		/* present in sysfs */
 
<span class="p_del">-	u8			tmpbuf[4];	/* DMA:able scratch buffer */</span>
<span class="p_add">+	u8			*tmpbuf;	/* DMA:able scratch buffer */</span>
 
 	unsigned		num_info;	/* number of info strings */
 	const char		**info;		/* info strings */
<span class="p_header">diff --git a/include/net/netfilter/nf_tables_ipv6.h b/include/net/netfilter/nf_tables_ipv6.h</span>
<span class="p_header">index d150b5066201..97983d1c05e4 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_tables_ipv6.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_tables_ipv6.h</span>
<span class="p_chunk">@@ -9,12 +9,13 @@</span> <span class="p_context"> nft_set_pktinfo_ipv6(struct nft_pktinfo *pkt,</span>
 		     struct sk_buff *skb,
 		     const struct nf_hook_state *state)
 {
<span class="p_add">+	unsigned int flags = IP6_FH_F_AUTH;</span>
 	int protohdr, thoff = 0;
 	unsigned short frag_off;
 
 	nft_set_pktinfo(pkt, skb, state);
 
<span class="p_del">-	protohdr = ipv6_find_hdr(pkt-&gt;skb, &amp;thoff, -1, &amp;frag_off, NULL);</span>
<span class="p_add">+	protohdr = ipv6_find_hdr(pkt-&gt;skb, &amp;thoff, -1, &amp;frag_off, &amp;flags);</span>
 	if (protohdr &lt; 0) {
 		nft_set_pktinfo_proto_unspec(pkt, skb);
 		return;
<span class="p_chunk">@@ -32,6 +33,7 @@</span> <span class="p_context"> __nft_set_pktinfo_ipv6_validate(struct nft_pktinfo *pkt,</span>
 				const struct nf_hook_state *state)
 {
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_add">+	unsigned int flags = IP6_FH_F_AUTH;</span>
 	struct ipv6hdr *ip6h, _ip6h;
 	unsigned int thoff = 0;
 	unsigned short frag_off;
<span class="p_chunk">@@ -50,7 +52,7 @@</span> <span class="p_context"> __nft_set_pktinfo_ipv6_validate(struct nft_pktinfo *pkt,</span>
 	if (pkt_len + sizeof(*ip6h) &gt; skb-&gt;len)
 		return -1;
 
<span class="p_del">-	protohdr = ipv6_find_hdr(pkt-&gt;skb, &amp;thoff, -1, &amp;frag_off, NULL);</span>
<span class="p_add">+	protohdr = ipv6_find_hdr(pkt-&gt;skb, &amp;thoff, -1, &amp;frag_off, &amp;flags);</span>
 	if (protohdr &lt; 0)
 		return -1;
 
<span class="p_header">diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h</span>
<span class="p_header">index a5890bf44c0a..d1601a621929 100644</span>
<span class="p_header">--- a/include/uapi/drm/drm_fourcc.h</span>
<span class="p_header">+++ b/include/uapi/drm/drm_fourcc.h</span>
<span class="p_chunk">@@ -154,6 +154,7 @@</span> <span class="p_context"> extern &quot;C&quot; {</span>
 
 /* Vendor Ids: */
 #define DRM_FORMAT_MOD_NONE           0
<span class="p_add">+#define DRM_FORMAT_MOD_VENDOR_NONE    0</span>
 #define DRM_FORMAT_MOD_VENDOR_INTEL   0x01
 #define DRM_FORMAT_MOD_VENDOR_AMD     0x02
 #define DRM_FORMAT_MOD_VENDOR_NV      0x03
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 47559cc0cdcc..2a800c4a39bd 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -462,6 +462,8 @@</span> <span class="p_context"> static void mem_cgroup_update_tree(struct mem_cgroup *memcg, struct page *page)</span>
 	struct mem_cgroup_tree_per_node *mctz;
 
 	mctz = soft_limit_tree_from_page(page);
<span class="p_add">+	if (!mctz)</span>
<span class="p_add">+		return;</span>
 	/*
 	 * Necessary to update all ancestors when hierarchy is used.
 	 * because their event counter is not touched.
<span class="p_chunk">@@ -499,7 +501,8 @@</span> <span class="p_context"> static void mem_cgroup_remove_from_trees(struct mem_cgroup *memcg)</span>
 	for_each_node(nid) {
 		mz = mem_cgroup_nodeinfo(memcg, nid);
 		mctz = soft_limit_tree_node(nid);
<span class="p_del">-		mem_cgroup_remove_exceeded(mz, mctz);</span>
<span class="p_add">+		if (mctz)</span>
<span class="p_add">+			mem_cgroup_remove_exceeded(mz, mctz);</span>
 	}
 }
 
<span class="p_chunk">@@ -2565,7 +2568,7 @@</span> <span class="p_context"> unsigned long mem_cgroup_soft_limit_reclaim(pg_data_t *pgdat, int order,</span>
 	 * is empty. Do it lockless to prevent lock bouncing. Races
 	 * are acceptable as soft limit is best effort anyway.
 	 */
<span class="p_del">-	if (RB_EMPTY_ROOT(&amp;mctz-&gt;rb_root))</span>
<span class="p_add">+	if (!mctz || RB_EMPTY_ROOT(&amp;mctz-&gt;rb_root))</span>
 		return 0;
 
 	/*
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index 7625ec8458de..5d4006e589cb 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -1098,11 +1098,14 @@</span> <span class="p_context"> static int br_dev_newlink(struct net *src_net, struct net_device *dev,</span>
 		spin_unlock_bh(&amp;br-&gt;lock);
 	}
 
<span class="p_del">-	err = br_changelink(dev, tb, data);</span>
<span class="p_add">+	err = register_netdevice(dev);</span>
 	if (err)
 		return err;
 
<span class="p_del">-	return register_netdevice(dev);</span>
<span class="p_add">+	err = br_changelink(dev, tb, data);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		unregister_netdevice(dev);</span>
<span class="p_add">+	return err;</span>
 }
 
 static size_t br_get_size(const struct net_device *brdev)
<span class="p_header">diff --git a/net/compat.c b/net/compat.c</span>
<span class="p_header">index 1cd2ec046164..a96fd2f3507b 100644</span>
<span class="p_header">--- a/net/compat.c</span>
<span class="p_header">+++ b/net/compat.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/filter.h&gt;
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/security.h&gt;
<span class="p_add">+#include &lt;linux/audit.h&gt;</span>
 #include &lt;linux/export.h&gt;
 
 #include &lt;net/scm.h&gt;
<span class="p_chunk">@@ -781,14 +782,24 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE5(recvmmsg, int, fd, struct compat_mmsghdr __user *, mmsg,</span>
 
 COMPAT_SYSCALL_DEFINE2(socketcall, int, call, u32 __user *, args)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-	u32 a[6];</span>
<span class="p_add">+	u32 a[AUDITSC_ARGS];</span>
<span class="p_add">+	unsigned int len;</span>
 	u32 a0, a1;
<span class="p_add">+	int ret;</span>
 
 	if (call &lt; SYS_SOCKET || call &gt; SYS_SENDMMSG)
 		return -EINVAL;
<span class="p_del">-	if (copy_from_user(a, args, nas[call]))</span>
<span class="p_add">+	len = nas[call];</span>
<span class="p_add">+	if (len &gt; sizeof(a))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(a, args, len))</span>
 		return -EFAULT;
<span class="p_add">+</span>
<span class="p_add">+	ret = audit_socketcall_compat(len / sizeof(a[0]), a);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	a0 = a[0];
 	a1 = a[1];
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index ba7b8121a414..7f2caad46a3d 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2355,6 +2355,9 @@</span> <span class="p_context"> void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (unlikely(!skb))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (likely(atomic_read(&amp;skb-&gt;users) == 1)) {
 		smp_rmb();
 		atomic_set(&amp;skb-&gt;users, 0);
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">index c9b52c361da2..5a8f7c360887 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_chunk">@@ -1304,6 +1304,7 @@</span> <span class="p_context"> static int __init nf_nat_snmp_basic_init(void)</span>
 static void __exit nf_nat_snmp_basic_fini(void)
 {
 	RCU_INIT_POINTER(nf_nat_snmp_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 	nf_conntrack_helper_unregister(&amp;snmp_trap_helper);
 }
 
<span class="p_header">diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c</span>
<span class="p_header">index 6de016f80f17..0932c85b42af 100644</span>
<span class="p_header">--- a/net/ipv4/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/udp_offload.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"> static struct sk_buff *__skb_udp_tunnel_segment(struct sk_buff *skb,</span>
 	u16 mac_len = skb-&gt;mac_len;
 	int udp_offset, outer_hlen;
 	__wsum partial;
<span class="p_add">+	bool need_ipsec;</span>
 
 	if (unlikely(!pskb_may_pull(skb, tnl_hlen)))
 		goto out;
<span class="p_chunk">@@ -62,8 +63,10 @@</span> <span class="p_context"> static struct sk_buff *__skb_udp_tunnel_segment(struct sk_buff *skb,</span>
 
 	ufo = !!(skb_shinfo(skb)-&gt;gso_type &amp; SKB_GSO_UDP);
 
<span class="p_add">+	need_ipsec = skb_dst(skb) &amp;&amp; dst_xfrm(skb_dst(skb));</span>
 	/* Try to offload checksum if possible */
 	offload_csum = !!(need_csum &amp;&amp;
<span class="p_add">+			  !need_ipsec &amp;&amp;</span>
 			  (skb-&gt;dev-&gt;features &amp;
 			   (is_ipv6 ? (NETIF_F_HW_CSUM | NETIF_F_IPV6_CSUM) :
 				      (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM))));
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">index da9df2d56e66..22fc32143e9c 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> void nf_conntrack_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_conntrack_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
 
<span class="p_chunk">@@ -326,6 +327,7 @@</span> <span class="p_context"> void nf_ct_expect_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_expect_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_ct_expect_unregister_notifier);
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 04111c1c3988..d5caed5bcfb1 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -3413,6 +3413,7 @@</span> <span class="p_context"> static void __exit ctnetlink_exit(void)</span>
 #ifdef CONFIG_NETFILTER_NETLINK_GLUE_CT
 	RCU_INIT_POINTER(nfnl_ct_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
 }
 
 module_init(ctnetlink_init);
<span class="p_header">diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c</span>
<span class="p_header">index dde64c4565d2..2916f4815c9c 100644</span>
<span class="p_header">--- a/net/netfilter/nf_nat_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_nat_core.c</span>
<span class="p_chunk">@@ -892,6 +892,8 @@</span> <span class="p_context"> static void __exit nf_nat_cleanup(void)</span>
 #ifdef CONFIG_XFRM
 	RCU_INIT_POINTER(nf_nat_decode_session_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; NFPROTO_NUMPROTO; i++)
 		kfree(nf_nat_l4protos[i]);
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 3b79f34b5095..b1fcfa08f0b4 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -161,6 +161,7 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	int i, ret;
 	struct nf_conntrack_expect_policy *expect_policy;
 	struct nlattr *tb[NFCTH_POLICY_SET_MAX+1];
<span class="p_add">+	unsigned int class_max;</span>
 
 	ret = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,
 			       nfnl_cthelper_expect_policy_set);
<span class="p_chunk">@@ -170,19 +171,18 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	if (!tb[NFCTH_POLICY_SET_NUM])
 		return -EINVAL;
 
<span class="p_del">-	helper-&gt;expect_class_max =</span>
<span class="p_del">-		ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (helper-&gt;expect_class_max != 0 &amp;&amp;</span>
<span class="p_del">-	    helper-&gt;expect_class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
<span class="p_add">+	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_add">+	if (class_max == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
 		return -EOVERFLOW;
 
 	expect_policy = kzalloc(sizeof(struct nf_conntrack_expect_policy) *
<span class="p_del">-				helper-&gt;expect_class_max, GFP_KERNEL);</span>
<span class="p_add">+				class_max, GFP_KERNEL);</span>
 	if (expect_policy == NULL)
 		return -ENOMEM;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; class_max; i++) {</span>
 		if (!tb[NFCTH_POLICY_SET+i])
 			goto err;
 
<span class="p_chunk">@@ -191,6 +191,8 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 		if (ret &lt; 0)
 			goto err;
 	}
<span class="p_add">+</span>
<span class="p_add">+	helper-&gt;expect_class_max = class_max - 1;</span>
 	helper-&gt;expect_policy = expect_policy;
 	return 0;
 err:
<span class="p_chunk">@@ -377,10 +379,10 @@</span> <span class="p_context"> nfnl_cthelper_dump_policy(struct sk_buff *skb,</span>
 		goto nla_put_failure;
 
 	if (nla_put_be32(skb, NFCTH_POLICY_SET_NUM,
<span class="p_del">-			 htonl(helper-&gt;expect_class_max)))</span>
<span class="p_add">+			 htonl(helper-&gt;expect_class_max + 1)))</span>
 		goto nla_put_failure;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
 		nest_parms2 = nla_nest_start(skb,
 				(NFCTH_POLICY_SET+i) | NLA_F_NESTED);
 		if (nest_parms2 == NULL)
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cttimeout.c b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">index 139e0867e56e..47d6656c9119 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_chunk">@@ -646,8 +646,8 @@</span> <span class="p_context"> static void __exit cttimeout_exit(void)</span>
 #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 	RCU_INIT_POINTER(nf_ct_timeout_find_get_hook, NULL);
 	RCU_INIT_POINTER(nf_ct_timeout_put_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
<span class="p_del">-	rcu_barrier();</span>
 }
 
 module_init(cttimeout_init);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 35ba4b60d927..9c92c6cb6a4f 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -3884,6 +3884,8 @@</span> <span class="p_context"> static int packet_getsockopt(struct socket *sock, int level, int optname,</span>
 	case PACKET_HDRLEN:
 		if (len &gt; sizeof(int))
 			len = sizeof(int);
<span class="p_add">+		if (len &lt; sizeof(int))</span>
<span class="p_add">+			return -EINVAL;</span>
 		if (copy_from_user(&amp;val, optval, len))
 			return -EFAULT;
 		switch (val) {
<span class="p_header">diff --git a/net/rds/ib_cm.c b/net/rds/ib_cm.c</span>
<span class="p_header">index 5b2ab95afa07..169156cfd4c8 100644</span>
<span class="p_header">--- a/net/rds/ib_cm.c</span>
<span class="p_header">+++ b/net/rds/ib_cm.c</span>
<span class="p_chunk">@@ -405,7 +405,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_send_cq);
 		ic-&gt;i_send_cq = NULL;
 		rdsdebug(&quot;ib_create_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto rds_ibdev_out;</span>
 	}
 
 	cq_attr.cqe = ic-&gt;i_recv_ring.w_nr;
<span class="p_chunk">@@ -416,19 +416,19 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_recv_cq);
 		ic-&gt;i_recv_cq = NULL;
 		rdsdebug(&quot;ib_create_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_send_cq, IB_CQ_NEXT_COMP);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_recv_cq, IB_CQ_SOLICITED);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	/* XXX negotiate max send/recv with remote? */
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	ret = rdma_create_qp(ic-&gt;i_cm_id, ic-&gt;i_pd, &amp;attr);
 	if (ret) {
 		rdsdebug(&quot;rdma_create_qp failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ic-&gt;i_send_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_send_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent send failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto qp_out;</span>
 	}
 
 	ic-&gt;i_recv_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -473,7 +473,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recv_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent recv failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_ack = ib_dma_alloc_coherent(dev, sizeof(struct rds_header),
<span class="p_chunk">@@ -481,7 +481,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_ack) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent ack failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_sends = vzalloc_node(ic-&gt;i_send_ring.w_nr * sizeof(struct rds_ib_send_work),
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_sends) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;send allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto ack_dma_out;</span>
 	}
 
 	ic-&gt;i_recvs = vzalloc_node(ic-&gt;i_recv_ring.w_nr * sizeof(struct rds_ib_recv_work),
<span class="p_chunk">@@ -497,7 +497,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recvs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;recv allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto sends_out;</span>
 	}
 
 	rds_ib_recv_init_ack(ic);
<span class="p_chunk">@@ -505,8 +505,33 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	rdsdebug(&quot;conn %p pd %p cq %p %p\n&quot;, conn, ic-&gt;i_pd,
 		 ic-&gt;i_send_cq, ic-&gt;i_recv_cq);
 
<span class="p_del">-out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+sends_out:</span>
<span class="p_add">+	vfree(ic-&gt;i_sends);</span>
<span class="p_add">+ack_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, sizeof(struct rds_header),</span>
<span class="p_add">+			     ic-&gt;i_ack, ic-&gt;i_ack_dma);</span>
<span class="p_add">+recv_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_recv_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_recv_hdrs, ic-&gt;i_recv_hdrs_dma);</span>
<span class="p_add">+send_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_send_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_send_hdrs, ic-&gt;i_send_hdrs_dma);</span>
<span class="p_add">+qp_out:</span>
<span class="p_add">+	rdma_destroy_qp(ic-&gt;i_cm_id);</span>
<span class="p_add">+recv_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_recv_cq))</span>
<span class="p_add">+		ic-&gt;i_recv_cq = NULL;</span>
<span class="p_add">+send_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_send_cq))</span>
<span class="p_add">+		ic-&gt;i_send_cq = NULL;</span>
<span class="p_add">+rds_ibdev_out:</span>
<span class="p_add">+	rds_ib_remove_conn(rds_ibdev, conn);</span>
 	rds_ib_dev_put(rds_ibdev);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/net/rds/ib_send.c b/net/rds/ib_send.c</span>
<span class="p_header">index 84d90c97332f..191098173018 100644</span>
<span class="p_header">--- a/net/rds/ib_send.c</span>
<span class="p_header">+++ b/net/rds/ib_send.c</span>
<span class="p_chunk">@@ -69,16 +69,6 @@</span> <span class="p_context"> static void rds_ib_send_complete(struct rds_message *rm,</span>
 	complete(rm, notify_status);
 }
 
<span class="p_del">-static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_del">-				   struct rm_data_op *op,</span>
<span class="p_del">-				   int wc_status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (op-&gt;op_nents)</span>
<span class="p_del">-		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_del">-				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_del">-				DMA_TO_DEVICE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rds_ib_send_unmap_rdma(struct rds_ib_connection *ic,
 				   struct rm_rdma_op *op,
 				   int wc_status)
<span class="p_chunk">@@ -139,6 +129,21 @@</span> <span class="p_context"> static void rds_ib_send_unmap_atomic(struct rds_ib_connection *ic,</span>
 		rds_ib_stats_inc(s_ib_atomic_fadd);
 }
 
<span class="p_add">+static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_add">+				   struct rm_data_op *op,</span>
<span class="p_add">+				   int wc_status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rds_message *rm = container_of(op, struct rds_message, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op-&gt;op_nents)</span>
<span class="p_add">+		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_add">+				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_add">+				DMA_TO_DEVICE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rm-&gt;rdma.op_active &amp;&amp; rm-&gt;data.op_notify)</span>
<span class="p_add">+		rds_ib_send_unmap_rdma(ic, &amp;rm-&gt;rdma, wc_status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Unmap the resources associated with a struct send_work.
  *
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 4c93badeabf2..8d3a851a3476 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -626,6 +626,16 @@</span> <span class="p_context"> int rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,</span>
 		}
 		op-&gt;op_notifier-&gt;n_user_token = args-&gt;user_token;
 		op-&gt;op_notifier-&gt;n_status = RDS_RDMA_SUCCESS;
<span class="p_add">+</span>
<span class="p_add">+		/* Enable rmda notification on data operation for composite</span>
<span class="p_add">+		 * rds messages and make sure notification is enabled only</span>
<span class="p_add">+		 * for the data operation which follows it so that application</span>
<span class="p_add">+		 * gets notified only after full message gets delivered.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rm-&gt;data.op_sg) {</span>
<span class="p_add">+			rm-&gt;rdma.op_notify = 0;</span>
<span class="p_add">+			rm-&gt;data.op_notify = !!(args-&gt;flags &amp; RDS_RDMA_NOTIFY_ME);</span>
<span class="p_add">+		}</span>
 	}
 
 	/* The cookie contains the R_Key of the remote memory region, and
<span class="p_header">diff --git a/net/rds/rds.h b/net/rds/rds.h</span>
<span class="p_header">index 67ba67c058b1..f107a968ddff 100644</span>
<span class="p_header">--- a/net/rds/rds.h</span>
<span class="p_header">+++ b/net/rds/rds.h</span>
<span class="p_chunk">@@ -414,6 +414,7 @@</span> <span class="p_context"> struct rds_message {</span>
 		} rdma;
 		struct rm_data_op {
 			unsigned int		op_active:1;
<span class="p_add">+			unsigned int		op_notify:1;</span>
 			unsigned int		op_nents;
 			unsigned int		op_count;
 			unsigned int		op_dmasg;
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index 896626b9a0ef..f28651b6ae83 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -475,12 +475,14 @@</span> <span class="p_context"> void rds_rdma_send_complete(struct rds_message *rm, int status)</span>
 	struct rm_rdma_op *ro;
 	struct rds_notifier *notifier;
 	unsigned long flags;
<span class="p_add">+	unsigned int notify = 0;</span>
 
 	spin_lock_irqsave(&amp;rm-&gt;m_rs_lock, flags);
 
<span class="p_add">+	notify =  rm-&gt;rdma.op_notify | rm-&gt;data.op_notify;</span>
 	ro = &amp;rm-&gt;rdma;
 	if (test_bit(RDS_MSG_ON_SOCK, &amp;rm-&gt;m_flags) &amp;&amp;
<span class="p_del">-	    ro-&gt;op_active &amp;&amp; ro-&gt;op_notify &amp;&amp; ro-&gt;op_notifier) {</span>
<span class="p_add">+	    ro-&gt;op_active &amp;&amp; notify &amp;&amp; ro-&gt;op_notifier) {</span>
 		notifier = ro-&gt;op_notifier;
 		rs = rm-&gt;m_rs;
 		sock_hold(rds_rs_to_sk(rs));
<span class="p_header">diff --git a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">index e1af24f87566..c308a4f70550 100644</span>
<span class="p_header">--- a/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">+++ b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_chunk">@@ -2279,6 +2279,9 @@</span> <span class="p_context"> vortex_adb_allocroute(vortex_t *vortex, int dma, int nr_ch, int dir,</span>
 	} else {
 		int src[2], mix[2];
 
<span class="p_add">+		if (nr_ch &lt; 1)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		/* Get SRC and MIXER hardware resources. */
 		for (i = 0; i &lt; nr_ch; i++) {
 			if ((mix[i] =
<span class="p_header">diff --git a/sound/soc/codecs/rt5514.c b/sound/soc/codecs/rt5514.c</span>
<span class="p_header">index f24b7cfd3a89..e024800213f5 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5514.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5514.c</span>
<span class="p_chunk">@@ -395,14 +395,14 @@</span> <span class="p_context"> static const char * const rt5514_dmic_src[] = {</span>
 	&quot;DMIC1&quot;, &quot;DMIC2&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5514_stereo1_dmic_enum, RT5514_DIG_SOURCE_CTRL,
 	RT5514_AD0_DMIC_INPUT_SEL_SFT, rt5514_dmic_src);
 
 static const struct snd_kcontrol_new rt5514_sto1_dmic_mux =
 	SOC_DAPM_ENUM(&quot;Stereo1 DMIC Source&quot;, rt5514_stereo1_dmic_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5514_stereo2_dmic_enum, RT5514_DIG_SOURCE_CTRL,
 	RT5514_AD1_DMIC_INPUT_SEL_SFT, rt5514_dmic_src);
 
<span class="p_header">diff --git a/sound/soc/codecs/rt5659.c b/sound/soc/codecs/rt5659.c</span>
<span class="p_header">index db54550aed60..635818fcda00 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5659.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5659.c</span>
<span class="p_chunk">@@ -1150,28 +1150,28 @@</span> <span class="p_context"> static const char * const rt5659_data_select[] = {</span>
 	&quot;L/R&quot;, &quot;R/L&quot;, &quot;L/L&quot;, &quot;R/R&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if1_01_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if1_01_adc_enum,</span>
 	RT5659_TDM_CTRL_2, RT5659_DS_ADC_SLOT01_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if1_23_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if1_23_adc_enum,</span>
 	RT5659_TDM_CTRL_2, RT5659_DS_ADC_SLOT23_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if1_45_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if1_45_adc_enum,</span>
 	RT5659_TDM_CTRL_2, RT5659_DS_ADC_SLOT45_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if1_67_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if1_67_adc_enum,</span>
 	RT5659_TDM_CTRL_2, RT5659_DS_ADC_SLOT67_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if2_dac_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if2_dac_enum,</span>
 	RT5659_DIG_INF23_DATA, RT5659_IF2_DAC_SEL_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if2_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if2_adc_enum,</span>
 	RT5659_DIG_INF23_DATA, RT5659_IF2_ADC_SEL_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if3_dac_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if3_dac_enum,</span>
 	RT5659_DIG_INF23_DATA, RT5659_IF3_DAC_SEL_SFT, rt5659_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5659_if3_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5659_if3_adc_enum,</span>
 	RT5659_DIG_INF23_DATA, RT5659_IF3_ADC_SEL_SFT, rt5659_data_select);
 
 static const struct snd_kcontrol_new rt5659_if1_01_adc_swap_mux =
<span class="p_chunk">@@ -1207,31 +1207,31 @@</span> <span class="p_context"> static unsigned int rt5659_asrc_clk_map_values[] = {</span>
 	0, 1, 2, 3, 5, 6,
 };
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_da_sto_asrc_enum, RT5659_ASRC_2, RT5659_DA_STO_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_da_monol_asrc_enum, RT5659_ASRC_2, RT5659_DA_MONO_L_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_da_monor_asrc_enum, RT5659_ASRC_2, RT5659_DA_MONO_R_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_ad_sto1_asrc_enum, RT5659_ASRC_2, RT5659_AD_STO1_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_ad_sto2_asrc_enum, RT5659_ASRC_3, RT5659_AD_STO2_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_ad_monol_asrc_enum, RT5659_ASRC_3, RT5659_AD_MONO_L_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_del">-static const SOC_VALUE_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_VALUE_ENUM_SINGLE_DECL(</span>
 	rt5659_ad_monor_asrc_enum, RT5659_ASRC_3, RT5659_AD_MONO_R_T_SFT, 0x7,
 	rt5659_asrc_clk_src, rt5659_asrc_clk_map_values);
 
<span class="p_chunk">@@ -1930,14 +1930,14 @@</span> <span class="p_context"> static const char * const rt5659_dac2_src[] = {</span>
 	&quot;IF1 DAC2&quot;, &quot;IF2 DAC&quot;, &quot;IF3 DAC&quot;, &quot;Mono ADC MIX&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dac_l2_enum, RT5659_DAC_CTRL,
 	RT5659_DAC_L2_SEL_SFT, rt5659_dac2_src);
 
 static const struct snd_kcontrol_new rt5659_dac_l2_mux =
 	SOC_DAPM_ENUM(&quot;DAC L2 Source&quot;, rt5659_dac_l2_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dac_r2_enum, RT5659_DAC_CTRL,
 	RT5659_DAC_R2_SEL_SFT, rt5659_dac2_src);
 
<span class="p_chunk">@@ -1951,7 +1951,7 @@</span> <span class="p_context"> static const char * const rt5659_sto1_adc1_src[] = {</span>
 	&quot;DAC MIX&quot;, &quot;ADC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_sto1_adc1_enum, RT5659_STO1_ADC_MIXER,
 	RT5659_STO1_ADC1_SRC_SFT, rt5659_sto1_adc1_src);
 
<span class="p_chunk">@@ -1964,7 +1964,7 @@</span> <span class="p_context"> static const char * const rt5659_sto1_adc_src[] = {</span>
 	&quot;ADC1&quot;, &quot;ADC2&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_sto1_adc_enum, RT5659_STO1_ADC_MIXER,
 	RT5659_STO1_ADC_SRC_SFT, rt5659_sto1_adc_src);
 
<span class="p_chunk">@@ -1977,7 +1977,7 @@</span> <span class="p_context"> static const char * const rt5659_sto1_adc2_src[] = {</span>
 	&quot;DAC MIX&quot;, &quot;DMIC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_sto1_adc2_enum, RT5659_STO1_ADC_MIXER,
 	RT5659_STO1_ADC2_SRC_SFT, rt5659_sto1_adc2_src);
 
<span class="p_chunk">@@ -1990,7 +1990,7 @@</span> <span class="p_context"> static const char * const rt5659_sto1_dmic_src[] = {</span>
 	&quot;DMIC1&quot;, &quot;DMIC2&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_sto1_dmic_enum, RT5659_STO1_ADC_MIXER,
 	RT5659_STO1_DMIC_SRC_SFT, rt5659_sto1_dmic_src);
 
<span class="p_chunk">@@ -2004,7 +2004,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_adc_l2_src[] = {</span>
 	&quot;Mono DAC MIXL&quot;, &quot;DMIC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adc_l2_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_L2_SRC_SFT, rt5659_mono_adc_l2_src);
 
<span class="p_chunk">@@ -2018,7 +2018,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_adc_l1_src[] = {</span>
 	&quot;Mono DAC MIXL&quot;, &quot;ADC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adc_l1_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_L1_SRC_SFT, rt5659_mono_adc_l1_src);
 
<span class="p_chunk">@@ -2031,14 +2031,14 @@</span> <span class="p_context"> static const char * const rt5659_mono_adc_src[] = {</span>
 	&quot;ADC1 L&quot;, &quot;ADC1 R&quot;, &quot;ADC2 L&quot;, &quot;ADC2 R&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adc_l_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_L_SRC_SFT, rt5659_mono_adc_src);
 
 static const struct snd_kcontrol_new rt5659_mono_adc_l_mux =
 	SOC_DAPM_ENUM(&quot;Mono ADC L Source&quot;, rt5659_mono_adc_l_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adcr_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_R_SRC_SFT, rt5659_mono_adc_src);
 
<span class="p_chunk">@@ -2051,7 +2051,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_dmic_l_src[] = {</span>
 	&quot;DMIC1 L&quot;, &quot;DMIC2 L&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_dmic_l_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_DMIC_L_SRC_SFT, rt5659_mono_dmic_l_src);
 
<span class="p_chunk">@@ -2064,7 +2064,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_adc_r2_src[] = {</span>
 	&quot;Mono DAC MIXR&quot;, &quot;DMIC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adc_r2_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_R2_SRC_SFT, rt5659_mono_adc_r2_src);
 
<span class="p_chunk">@@ -2077,7 +2077,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_adc_r1_src[] = {</span>
 	&quot;Mono DAC MIXR&quot;, &quot;ADC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_adc_r1_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_ADC_R1_SRC_SFT, rt5659_mono_adc_r1_src);
 
<span class="p_chunk">@@ -2090,7 +2090,7 @@</span> <span class="p_context"> static const char * const rt5659_mono_dmic_r_src[] = {</span>
 	&quot;DMIC1 R&quot;, &quot;DMIC2 R&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_mono_dmic_r_enum, RT5659_MONO_ADC_MIXER,
 	RT5659_MONO_DMIC_R_SRC_SFT, rt5659_mono_dmic_r_src);
 
<span class="p_chunk">@@ -2104,14 +2104,14 @@</span> <span class="p_context"> static const char * const rt5659_dac1_src[] = {</span>
 	&quot;IF1 DAC1&quot;, &quot;IF2 DAC&quot;, &quot;IF3 DAC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dac_r1_enum, RT5659_AD_DA_MIXER,
 	RT5659_DAC1_R_SEL_SFT, rt5659_dac1_src);
 
 static const struct snd_kcontrol_new rt5659_dac_r1_mux =
 	SOC_DAPM_ENUM(&quot;DAC R1 Source&quot;, rt5659_dac_r1_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dac_l1_enum, RT5659_AD_DA_MIXER,
 	RT5659_DAC1_L_SEL_SFT, rt5659_dac1_src);
 
<span class="p_chunk">@@ -2124,14 +2124,14 @@</span> <span class="p_context"> static const char * const rt5659_dig_dac_mix_src[] = {</span>
 	&quot;Stereo DAC Mixer&quot;, &quot;Mono DAC Mixer&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dig_dac_mixl_enum, RT5659_DIG_MIXER,
 	RT5659_DAC_MIX_L_SFT, rt5659_dig_dac_mix_src);
 
 static const struct snd_kcontrol_new rt5659_dig_dac_mixl_mux =
 	SOC_DAPM_ENUM(&quot;DAC Digital Mixer L Source&quot;, rt5659_dig_dac_mixl_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_dig_dac_mixr_enum, RT5659_DIG_MIXER,
 	RT5659_DAC_MIX_R_SFT, rt5659_dig_dac_mix_src);
 
<span class="p_chunk">@@ -2144,14 +2144,14 @@</span> <span class="p_context"> static const char * const rt5659_alg_dac1_src[] = {</span>
 	&quot;DAC&quot;, &quot;Stereo DAC Mixer&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_alg_dac_l1_enum, RT5659_A_DAC_MUX,
 	RT5659_A_DACL1_SFT, rt5659_alg_dac1_src);
 
 static const struct snd_kcontrol_new rt5659_alg_dac_l1_mux =
 	SOC_DAPM_ENUM(&quot;Analog DACL1 Source&quot;, rt5659_alg_dac_l1_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_alg_dac_r1_enum, RT5659_A_DAC_MUX,
 	RT5659_A_DACR1_SFT, rt5659_alg_dac1_src);
 
<span class="p_chunk">@@ -2164,14 +2164,14 @@</span> <span class="p_context"> static const char * const rt5659_alg_dac2_src[] = {</span>
 	&quot;Stereo DAC Mixer&quot;, &quot;Mono DAC Mixer&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_alg_dac_l2_enum, RT5659_A_DAC_MUX,
 	RT5659_A_DACL2_SFT, rt5659_alg_dac2_src);
 
 static const struct snd_kcontrol_new rt5659_alg_dac_l2_mux =
 	SOC_DAPM_ENUM(&quot;Analog DAC L2 Source&quot;, rt5659_alg_dac_l2_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_alg_dac_r2_enum, RT5659_A_DAC_MUX,
 	RT5659_A_DACR2_SFT, rt5659_alg_dac2_src);
 
<span class="p_chunk">@@ -2184,7 +2184,7 @@</span> <span class="p_context"> static const char * const rt5659_if2_adc_in_src[] = {</span>
 	&quot;IF_ADC1&quot;, &quot;IF_ADC2&quot;, &quot;DAC_REF&quot;, &quot;IF_ADC3&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_if2_adc_in_enum, RT5659_DIG_INF23_DATA,
 	RT5659_IF2_ADC_IN_SFT, rt5659_if2_adc_in_src);
 
<span class="p_chunk">@@ -2197,7 +2197,7 @@</span> <span class="p_context"> static const char * const rt5659_if3_adc_in_src[] = {</span>
 	&quot;IF_ADC1&quot;, &quot;IF_ADC2&quot;, &quot;DAC_REF&quot;, &quot;Stereo2_ADC_L/R&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_if3_adc_in_enum, RT5659_DIG_INF23_DATA,
 	RT5659_IF3_ADC_IN_SFT, rt5659_if3_adc_in_src);
 
<span class="p_chunk">@@ -2210,14 +2210,14 @@</span> <span class="p_context"> static const char * const rt5659_pdm_src[] = {</span>
 	&quot;Mono DAC&quot;, &quot;Stereo DAC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_pdm_l_enum, RT5659_PDM_OUT_CTRL,
 	RT5659_PDM1_L_SFT, rt5659_pdm_src);
 
 static const struct snd_kcontrol_new rt5659_pdm_l_mux =
 	SOC_DAPM_ENUM(&quot;PDM L Source&quot;, rt5659_pdm_l_enum);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_pdm_r_enum, RT5659_PDM_OUT_CTRL,
 	RT5659_PDM1_R_SFT, rt5659_pdm_src);
 
<span class="p_chunk">@@ -2230,7 +2230,7 @@</span> <span class="p_context"> static const char * const rt5659_spdif_src[] = {</span>
 	&quot;IF1_DAC1&quot;, &quot;IF1_DAC2&quot;, &quot;IF2_DAC&quot;, &quot;IF3_DAC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_spdif_enum, RT5659_SPDIF_CTRL,
 	RT5659_SPDIF_SEL_SFT, rt5659_spdif_src);
 
<span class="p_chunk">@@ -2250,7 +2250,7 @@</span> <span class="p_context"> static const char * const rt5659_rx_adc_data_src[] = {</span>
 	&quot;NUL:AD2:DAC:AD1&quot;, &quot;NUL:DAC:DAC:AD2&quot;, &quot;NUL:DAC:AD2:DAC&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(</span>
 	rt5659_rx_adc_data_enum, RT5659_TDM_CTRL_2,
 	RT5659_ADCDAT_SRC_SFT, rt5659_rx_adc_data_src);
 
<span class="p_header">diff --git a/sound/soc/codecs/rt5660.c b/sound/soc/codecs/rt5660.c</span>
<span class="p_header">index 9f0933ced804..e396b7680fa1 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5660.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5660.c</span>
<span class="p_chunk">@@ -526,10 +526,10 @@</span> <span class="p_context"> static const char * const rt5660_data_select[] = {</span>
 	&quot;L/R&quot;, &quot;R/L&quot;, &quot;L/L&quot;, &quot;R/R&quot;
 };
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5660_if1_dac_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5660_if1_dac_enum,</span>
 	RT5660_DIG_INF1_DATA, RT5660_IF1_DAC_IN_SFT, rt5660_data_select);
 
<span class="p_del">-static const SOC_ENUM_SINGLE_DECL(rt5660_if1_adc_enum,</span>
<span class="p_add">+static SOC_ENUM_SINGLE_DECL(rt5660_if1_adc_enum,</span>
 	RT5660_DIG_INF1_DATA, RT5660_IF1_ADC_IN_SFT, rt5660_data_select);
 
 static const struct snd_kcontrol_new rt5660_if1_dac_swap_mux =
<span class="p_header">diff --git a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">index b943dde8dbe5..3bdd81930486 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_chunk">@@ -789,7 +789,10 @@</span> <span class="p_context"> static int wm_coeff_put(struct snd_kcontrol *kctl,</span>
 
 	mutex_lock(&amp;ctl-&gt;dsp-&gt;pwr_lock);
 
<span class="p_del">-	memcpy(ctl-&gt;cache, p, ctl-&gt;len);</span>
<span class="p_add">+	if (ctl-&gt;flags &amp; WMFW_CTL_FLAG_VOLATILE)</span>
<span class="p_add">+		ret = -EPERM;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		memcpy(ctl-&gt;cache, p, ctl-&gt;len);</span>
 
 	ctl-&gt;set = 1;
 	if (ctl-&gt;enabled &amp;&amp; ctl-&gt;dsp-&gt;running)
<span class="p_chunk">@@ -816,6 +819,8 @@</span> <span class="p_context"> static int wm_coeff_tlv_put(struct snd_kcontrol *kctl,</span>
 		ctl-&gt;set = 1;
 		if (ctl-&gt;enabled &amp;&amp; ctl-&gt;dsp-&gt;running)
 			ret = wm_coeff_write_control(ctl, ctl-&gt;cache, size);
<span class="p_add">+		else if (ctl-&gt;flags &amp; WMFW_CTL_FLAG_VOLATILE)</span>
<span class="p_add">+			ret = -EPERM;</span>
 	}
 
 	mutex_unlock(&amp;ctl-&gt;dsp-&gt;pwr_lock);
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 3bbe32ee4630..6780eba55ec2 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -358,6 +358,10 @@</span> <span class="p_context"> static int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,</span>
 				snd_soc_dapm_new_control_unlocked(widget-&gt;dapm,
 				&amp;template);
 			kfree(name);
<span class="p_add">+			if (IS_ERR(data-&gt;widget)) {</span>
<span class="p_add">+				ret = PTR_ERR(data-&gt;widget);</span>
<span class="p_add">+				goto err_data;</span>
<span class="p_add">+			}</span>
 			if (!data-&gt;widget) {
 				ret = -ENOMEM;
 				goto err_data;
<span class="p_chunk">@@ -392,6 +396,10 @@</span> <span class="p_context"> static int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,</span>
 			data-&gt;widget = snd_soc_dapm_new_control_unlocked(
 						widget-&gt;dapm, &amp;template);
 			kfree(name);
<span class="p_add">+			if (IS_ERR(data-&gt;widget)) {</span>
<span class="p_add">+				ret = PTR_ERR(data-&gt;widget);</span>
<span class="p_add">+				goto err_data;</span>
<span class="p_add">+			}</span>
 			if (!data-&gt;widget) {
 				ret = -ENOMEM;
 				goto err_data;
<span class="p_chunk">@@ -3311,11 +3319,22 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 
 	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
 	w = snd_soc_dapm_new_control_unlocked(dapm, widget);
<span class="p_add">+	/* Do not nag about probe deferrals */</span>
<span class="p_add">+	if (IS_ERR(w)) {</span>
<span class="p_add">+		int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create DAPM control %s (%d)\n&quot;,</span>
<span class="p_add">+				widget-&gt;name, ret);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 	if (!w)
 		dev_err(dapm-&gt;dev,
 			&quot;ASoC: Failed to create DAPM control %s\n&quot;,
 			widget-&gt;name);
 
<span class="p_add">+out_unlock:</span>
 	mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);
 	return w;
 }
<span class="p_chunk">@@ -3338,6 +3357,8 @@</span> <span class="p_context"> snd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,</span>
 		w-&gt;regulator = devm_regulator_get(dapm-&gt;dev, w-&gt;name);
 		if (IS_ERR(w-&gt;regulator)) {
 			ret = PTR_ERR(w-&gt;regulator);
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				return ERR_PTR(ret);</span>
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to request %s: %d\n&quot;,
 				w-&gt;name, ret);
 			return NULL;
<span class="p_chunk">@@ -3356,6 +3377,8 @@</span> <span class="p_context"> snd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,</span>
 		w-&gt;clk = devm_clk_get(dapm-&gt;dev, w-&gt;name);
 		if (IS_ERR(w-&gt;clk)) {
 			ret = PTR_ERR(w-&gt;clk);
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				return ERR_PTR(ret);</span>
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to request %s: %d\n&quot;,
 				w-&gt;name, ret);
 			return NULL;
<span class="p_chunk">@@ -3474,6 +3497,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm,</span>
 	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
 	for (i = 0; i &lt; num; i++) {
 		w = snd_soc_dapm_new_control_unlocked(dapm, widget);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			ret = PTR_ERR(w);</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create DAPM control %s (%d)\n&quot;,</span>
<span class="p_add">+				widget-&gt;name, ret);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev,
 				&quot;ASoC: Failed to create DAPM control %s\n&quot;,
<span class="p_chunk">@@ -3750,6 +3783,15 @@</span> <span class="p_context"> int snd_soc_dapm_new_pcm(struct snd_soc_card *card,</span>
 	dev_dbg(card-&gt;dev, &quot;ASoC: adding %s widget\n&quot;, link_name);
 
 	w = snd_soc_dapm_new_control_unlocked(&amp;card-&gt;dapm, &amp;template);
<span class="p_add">+	if (IS_ERR(w)) {</span>
<span class="p_add">+		ret = PTR_ERR(w);</span>
<span class="p_add">+		/* Do not nag about probe deferrals */</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(card-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				link_name, ret);</span>
<span class="p_add">+		goto outfree_kcontrol_news;</span>
<span class="p_add">+	}</span>
 	if (!w) {
 		dev_err(card-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 			link_name);
<span class="p_chunk">@@ -3801,6 +3843,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,</span>
 			template.name);
 
 		w = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+				dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				dai-&gt;driver-&gt;playback.stream_name, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 				dai-&gt;driver-&gt;playback.stream_name);
<span class="p_chunk">@@ -3820,6 +3872,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,</span>
 			template.name);
 
 		w = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+				dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				dai-&gt;driver-&gt;playback.stream_name, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 				dai-&gt;driver-&gt;capture.stream_name);
<span class="p_header">diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c</span>
<span class="p_header">index 6b05047a4134..8a758c994506 100644</span>
<span class="p_header">--- a/sound/soc/soc-topology.c</span>
<span class="p_header">+++ b/sound/soc/soc-topology.c</span>
<span class="p_chunk">@@ -1473,6 +1473,15 @@</span> <span class="p_context"> static int soc_tplg_dapm_widget_create(struct soc_tplg *tplg,</span>
 		widget = snd_soc_dapm_new_control(dapm, &amp;template);
 	else
 		widget = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+	if (IS_ERR(widget)) {</span>
<span class="p_add">+		ret = PTR_ERR(widget);</span>
<span class="p_add">+		/* Do not nag about probe deferrals */</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(tplg-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: failed to create widget %s controls (%d)\n&quot;,</span>
<span class="p_add">+				w-&gt;name, ret);</span>
<span class="p_add">+		goto hdr_err;</span>
<span class="p_add">+	}</span>
 	if (widget == NULL) {
 		dev_err(tplg-&gt;dev, &quot;ASoC: failed to create widget %s controls\n&quot;,
 			w-&gt;name);
<span class="p_header">diff --git a/tools/power/x86/turbostat/turbostat.c b/tools/power/x86/turbostat/turbostat.c</span>
<span class="p_header">index 3e199b508a96..9664b1ff4285 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/turbostat.c</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/turbostat.c</span>
<span class="p_chunk">@@ -2003,8 +2003,10 @@</span> <span class="p_context"> int snapshot_gfx_mhz(void)</span>
 
 	if (fp == NULL)
 		fp = fopen_or_die(&quot;/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz&quot;, &quot;r&quot;);
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
 		rewind(fp);
<span class="p_add">+		fflush(fp);</span>
<span class="p_add">+	}</span>
 
 	retval = fscanf(fp, &quot;%d&quot;, &amp;gfx_cur_mhz);
 	if (retval != 1)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



