
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] perf fixes and updates - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] perf fixes and updates</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 24, 2016, 8:10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160324081026.GA7182@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8658751/mbox/"
   >mbox</a>
|
   <a href="/patch/8658751/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8658751/">/patch/8658751/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 7386CC0553
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Mar 2016 08:11:19 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D285220397
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Mar 2016 08:11:11 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E0F4520390
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Mar 2016 08:11:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756785AbcCXIK6 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 24 Mar 2016 04:10:58 -0400
Received: from mail-wm0-f65.google.com ([74.125.82.65]:35639 &quot;EHLO
	mail-wm0-f65.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751933AbcCXIKd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 24 Mar 2016 04:10:33 -0400
Received: by mail-wm0-f65.google.com with SMTP id s187so532305wme.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Thu, 24 Mar 2016 01:10:31 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=WOCqHqYLOny9Tm8XRAKqNDOZFX44iBi2Y3Gp8ya2PYs=;
	b=hXGE15wipYLm0lSuPmETG9EO3wT30STCmkEo5GTzN/OGLjpe/LoPI+r7/QopfYL+X0
	1vbZUL59rdNEgYDCb5ndU3TPWobX3gSARhoDIZH8BmiCEGTdVRadlZEceSnuyS85lBNU
	3R0cg7VQarHBj1L6WIxC3iH30GqOdOwwKxlCpjhPfLaZEZMbcFUZz/59QANqmCRDhMAf
	KGGPb1iN8R7nTjk1LXWHTTVDiFfxpOPRN5KclK5yab4XiHr9N4/y/rZEEh545DQmHEOU
	kiFqwgq60hgwBKLL6GiMMvNOP2nIWXkWCkgqRd3LKf8JOuKaxh21sC7jglThL8FXKZoa
	zMzg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=WOCqHqYLOny9Tm8XRAKqNDOZFX44iBi2Y3Gp8ya2PYs=;
	b=P7pS+ibZGR5w1TAKX82EoHPb4rIKxinJGALTHJ6aSa6etGRo6G6tiTNRdk4+U1dagt
	1UhacLl5JcZN3oqDWvuvJoAegdIKLwon7BKI0uWQTc/G5qFQqwZYGJh9tRD+UTYaPvD2
	1JdVrCG0gc5jr8rYyWV1ynkXDB2Wrps8ngaLhYKbnW/fEa1HjT+MKtlONcxY/OZwna7C
	2L0Er0Kqj6d41bE47A6l503g/iDnYcfX+64fWfGOvm86wDERga/lbxE2AeQtv6UuWnyq
	LCiXYrOV1RY4pzrwoJt4ca8UGobE/e/VPWwfv9hevBAsuu5aCp5kIXwj1O9PXLK8sk3G
	jVbQ==
X-Gm-Message-State: AD7BkJIqACKvwtEzFZExVHYbk+qCGDSguZWhA0tqyTqzys1FSaGwnwR3YImKnr/Xb29Kmg==
X-Received: by 10.195.12.113 with SMTP id ep17mr7982455wjd.102.1458807030340;
	Thu, 24 Mar 2016 01:10:30 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	y62sm6534085wmg.12.2016.03.24.01.10.28
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Thu, 24 Mar 2016 01:10:29 -0700 (PDT)
Date: Thu, 24 Mar 2016 09:10:26 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Arnaldo Carvalho de Melo &lt;acme@infradead.org&gt;,
	Jiri Olsa &lt;jolsa@redhat.com&gt;, Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] perf fixes and updates
Message-ID: &lt;20160324081026.GA7182@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.2 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, T_DKIM_INVALID, T_RP_MATCHES_RCVD, UNPARSEABLE_RELAY,
	URG_BIZ autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - March 24, 2016, 8:10 a.m.</div>
<pre class="content">
Linus,

Please pull the latest perf-urgent-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git perf-urgent-for-linus

   # HEAD: 05f5ece76a88a2cd4859bc93f90379733dd8b4a3 Merge tag &#39;perf-core-for-mingo-20160323&#39; of git://git.kernel.org/pub/scm/linux/kernel/git/acme/linux into perf/urgent

[ Note: this pull request depends on the previous x86/urgent pull request I just
        sent - if you have not pulled x86/urgent then please disregard this one. ]

This tree contains various perf fixes on the kernel side, plus 3 
hw/event-enablement late additions:

 - Intel Memory Bandwidth Monitoring events and handling
 - the AMD Accumulated Power Mechanism reporting facility
 - more IOMMU events

... and a final round of perf tooling updates/fixes.

 Thanks,

	Ingo

------------------&gt;
Andi Kleen (1):
      perf list: Fix documentation of :ppp

Arnaldo Carvalho de Melo (18):
      tools: Move utilities.mak from perf to tools/scripts/
      perf tools: Remove misplaced __maybe_unused
      perf tests: Forward the perf_sample in the dwarf unwind test
      perf tools: Add cpumode to struct perf_sample
      perf machine: Rename perf_event__preprocess_sample to machine__resolve
      perf thread: Rename perf_event__preprocess_sample_addr to thread__resolve
      perf script: Remove lots of unused arguments
      perf tools: Remove unused DIE_IF macro
      perf tools: Simplify die() mechanism
      perf tools: Remove needless &#39;extern&#39; from function prototypes
      tools include: Copy linux/stringify.h from the kernel
      perf tools: Do not include stringify.h from the kernel sources
      perf tools: Remove unused perf_pathdup, xstrdup functions
      perf help: Use asprintf instead of adhoc equivalents
      perf probe: No need to use formatting strbuf method
      perf tools: Unexport some methods unused outside strbuf.c
      perf llvm: Use realpath to canonicalize paths
      perf llvm: Use strerror_r instead of the thread unsafe strerror one

Huang Rui (3):
      perf/x86/amd: Move nodes_per_socket into bsp_init_amd()
      x86/cpufeature, perf/x86: Add AMD Accumulated Power Mechanism feature flag
      perf/x86/amd/power: Add AMD accumulated power reporting mechanism

Jakub Jelen (1):
      perf bench numa: Fix assertion for nodes bitfield

Kan Liang (1):
      perf/x86/intel/uncore: Remove ev_sel_ext bit support for PCU

Peter Zijlstra (9):
      perf/core: Fix the unthrottle logic
      perf/x86/ibs: Fix IBS throttle
      perf/x86/ibs: Fix race with IBS_STARTING state
      perf/x86/ibs: Add IBS interrupt to the dynamic throttle
      perf/core: Fix dynamic interrupt throttle
      perf/x86/BTS: Fix RCU usage
      perf/core: Fix Undefined behaviour in rb_alloc()
      perf/x86/cqm: Factor out some common code
      perf/core: Document some hotplug bits

Srinivas Pandruvada (1):
      perf/x86/intel/rapl: Add missing Broadwell models

Steven Rostedt (1):
      tools lib traceevent: Remove redundant CPU output

Sukadev Bhattiprolu (1):
      perf test: Remove &#39;core_id&#39; check in topo test

Suravee Suthikulpanit (1):
      perf/x86/amd: Add support for new IOMMU performance events

Tony Luck (1):
      perf/x86/mbm: Add memory bandwidth monitoring event management

Vikas Shivappa (5):
      perf/x86/cqm: Fix CQM handling of grouping events into a cache_group
      perf/x86/cqm: Fix CQM memory leak and notifier leak
      perf/x86/mbm: Add Intel Memory B/W Monitoring enumeration and init
      perf/x86/mbm: Implement RMID recycling
      perf/x86/mbm: Add support for MBM counter overflow handling

Wang Nan (1):
      perf symbols: Record text offset in dso to calculate objdump address


 arch/x86/Kconfig                             |   9 +
 arch/x86/events/Makefile                     |   1 +
 arch/x86/events/amd/ibs.c                    |  37 ++-
 arch/x86/events/amd/iommu.c                  |   5 +
 arch/x86/events/amd/power.c                  | 353 +++++++++++++++++++++
 arch/x86/events/core.c                       |   4 +-
 arch/x86/events/intel/cqm.c                  | 454 +++++++++++++++++++++++++--
 arch/x86/events/intel/ds.c                   |   5 +-
 arch/x86/events/intel/rapl.c                 |   2 +
 arch/x86/events/intel/uncore_snbep.c         |   7 +-
 arch/x86/include/asm/cpufeatures.h           |   4 +-
 arch/x86/kernel/cpu/amd.c                    |  18 +-
 arch/x86/kernel/cpu/common.c                 |   4 +-
 include/linux/perf_event.h                   |   5 +
 kernel/events/core.c                         | 114 ++++---
 kernel/events/ring_buffer.c                  |   6 +-
 tools/include/linux/stringify.h              |  12 +
 tools/lib/api/Makefile                       |   2 +-
 tools/lib/subcmd/Makefile                    |   2 +-
 tools/lib/traceevent/event-parse.c           |   4 +-
 tools/perf/Documentation/Makefile            |   2 +-
 tools/perf/Documentation/perf-list.txt       |   6 +-
 tools/perf/Makefile.perf                     |   2 +-
 tools/perf/arch/powerpc/util/header.c        |   4 +-
 tools/perf/bench/bench.h                     |  22 +-
 tools/perf/bench/mem-memcpy-arch.h           |   2 +-
 tools/perf/bench/mem-memset-arch.h           |   2 +-
 tools/perf/bench/numa.c                      |   2 +-
 tools/perf/builtin-annotate.c                |   2 +-
 tools/perf/builtin-diff.c                    |   2 +-
 tools/perf/builtin-help.c                    |  69 ++--
 tools/perf/builtin-inject.c                  |   8 +-
 tools/perf/builtin-mem.c                     |   2 +-
 tools/perf/builtin-report.c                  |   3 +-
 tools/perf/builtin-script.c                  |  46 ++-
 tools/perf/builtin-timechart.c               |   2 +-
 tools/perf/builtin-top.c                     |   8 +-
 tools/perf/builtin-trace.c                   |   9 +-
 tools/perf/builtin.h                         |  64 ++--
 tools/perf/config/Makefile                   |   2 +-
 tools/perf/tests/code-reading.c              |   5 +-
 tools/perf/tests/dwarf-unwind.c              |   4 +-
 tools/perf/tests/hists_common.c              |   6 +-
 tools/perf/tests/hists_cumulate.c            |   9 +-
 tools/perf/tests/hists_filter.c              |   9 +-
 tools/perf/tests/hists_link.c                |  20 +-
 tools/perf/tests/hists_output.c              |   9 +-
 tools/perf/ui/gtk/hists.c                    |   2 +-
 tools/perf/util/Build                        |   1 -
 tools/perf/util/abspath.c                    |  37 ---
 tools/perf/util/annotate.h                   |   2 +-
 tools/perf/util/auxtrace.h                   |   2 +-
 tools/perf/util/build-id.c                   |   3 +-
 tools/perf/util/cache.h                      |  24 +-
 tools/perf/util/callchain.h                  |   4 +-
 tools/perf/util/cgroup.h                     |   4 +-
 tools/perf/util/cloexec.h                    |   2 +-
 tools/perf/util/data-convert-bt.c            |   2 +-
 tools/perf/util/db-export.c                  |   2 +-
 tools/perf/util/dso.h                        |   3 +-
 tools/perf/util/dwarf-aux.c                  |  10 +-
 tools/perf/util/dwarf-aux.h                  |  72 +++--
 tools/perf/util/event.c                      |  23 +-
 tools/perf/util/event.h                      |  13 +-
 tools/perf/util/evsel.c                      |   1 +
 tools/perf/util/genelf.h                     |   8 +-
 tools/perf/util/header.c                     |   5 -
 tools/perf/util/header.h                     |   2 +-
 tools/perf/util/hist.c                       |   2 +-
 tools/perf/util/hist.h                       |   3 +-
 tools/perf/util/intel-bts.c                  |   2 +-
 tools/perf/util/jit.h                        |  12 +-
 tools/perf/util/llvm-utils.c                 |  24 +-
 tools/perf/util/llvm-utils.h                 |   7 +-
 tools/perf/util/machine.c                    |  14 +-
 tools/perf/util/machine.h                    |   2 +-
 tools/perf/util/parse-events.h               |  21 +-
 tools/perf/util/path.c                       |  30 --
 tools/perf/util/probe-event.c                |   2 +-
 tools/perf/util/probe-event.h                |  57 ++--
 tools/perf/util/probe-finder.c               |   8 +-
 tools/perf/util/probe-finder.h               |  24 +-
 tools/perf/util/quote.h                      |   2 +-
 tools/perf/util/session.c                    |   5 +-
 tools/perf/util/sort.c                       |   2 +-
 tools/perf/util/stat-shadow.c                |  18 +-
 tools/perf/util/strbuf.c                     |   9 +-
 tools/perf/util/strbuf.h                     |  21 +-
 tools/perf/util/svghelper.h                  |  51 ++-
 tools/perf/util/symbol-elf.c                 |  12 +-
 tools/perf/util/symbol.h                     |   4 +-
 tools/perf/util/usage.c                      |   8 +-
 tools/perf/util/util.h                       |  27 +-
 tools/perf/util/wrapper.c                    |  12 -
 tools/{perf/config =&gt; scripts}/utilities.mak |   0
 95 files changed, 1336 insertions(+), 634 deletions(-)
 create mode 100644 arch/x86/events/amd/power.c
 create mode 100644 tools/include/linux/stringify.h
 delete mode 100644 tools/perf/util/abspath.c
 rename tools/{perf/config =&gt; scripts}/utilities.mak (100%)

diff --git a/tools/perf/config/utilities.mak b/tools/scripts/utilities.mak
similarity index 100%
rename from tools/perf/config/utilities.mak
rename to tools/scripts/utilities.mak
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 8f2e6659281b..a313c0e7e165 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -1206,6 +1206,15 @@</span> <span class="p_context"> config MICROCODE_OLD_INTERFACE</span>
 	def_bool y
 	depends on MICROCODE
 
<span class="p_add">+config PERF_EVENTS_AMD_POWER</span>
<span class="p_add">+	depends on PERF_EVENTS &amp;&amp; CPU_SUP_AMD</span>
<span class="p_add">+	tristate &quot;AMD Processor Power Reporting Mechanism&quot;</span>
<span class="p_add">+	---help---</span>
<span class="p_add">+	  Provide power reporting mechanism support for AMD processors.</span>
<span class="p_add">+	  Currently, it leverages X86_FEATURE_ACC_POWER</span>
<span class="p_add">+	  (CPUID Fn8000_0007_EDX[12]) interface to calculate the</span>
<span class="p_add">+	  average power consumption on Family 15h processors.</span>
<span class="p_add">+</span>
 config X86_MSR
 	tristate &quot;/dev/cpu/*/msr - Model-specific register support&quot;
 	---help---
<span class="p_header">diff --git a/arch/x86/events/Makefile b/arch/x86/events/Makefile</span>
<span class="p_header">index fdfea1511cc0..f59618a39990 100644</span>
<span class="p_header">--- a/arch/x86/events/Makefile</span>
<span class="p_header">+++ b/arch/x86/events/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 obj-y			+= core.o
 
 obj-$(CONFIG_CPU_SUP_AMD)               += amd/core.o amd/uncore.o
<span class="p_add">+obj-$(CONFIG_PERF_EVENTS_AMD_POWER)	+= amd/power.o</span>
 obj-$(CONFIG_X86_LOCAL_APIC)            += amd/ibs.o msr.o
 ifdef CONFIG_AMD_IOMMU
 obj-$(CONFIG_CPU_SUP_AMD)               += amd/iommu.o
<span class="p_header">diff --git a/arch/x86/events/amd/ibs.c b/arch/x86/events/amd/ibs.c</span>
<span class="p_header">index 51087c29b2c2..3ea25c3917c0 100644</span>
<span class="p_header">--- a/arch/x86/events/amd/ibs.c</span>
<span class="p_header">+++ b/arch/x86/events/amd/ibs.c</span>
<span class="p_chunk">@@ -376,7 +376,13 @@</span> <span class="p_context"> static void perf_ibs_start(struct perf_event *event, int flags)</span>
 	hwc-&gt;state = 0;
 
 	perf_ibs_set_period(perf_ibs, hwc, &amp;period);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set STARTED before enabling the hardware, such that</span>
<span class="p_add">+	 * a subsequent NMI must observe it. Then clear STOPPING</span>
<span class="p_add">+	 * such that we don&#39;t consume NMIs by accident.</span>
<span class="p_add">+	 */</span>
 	set_bit(IBS_STARTED, pcpu-&gt;state);
<span class="p_add">+	clear_bit(IBS_STOPPING, pcpu-&gt;state);</span>
 	perf_ibs_enable_event(perf_ibs, hwc, period &gt;&gt; 4);
 
 	perf_event_update_userpage(event);
<span class="p_chunk">@@ -390,7 +396,7 @@</span> <span class="p_context"> static void perf_ibs_stop(struct perf_event *event, int flags)</span>
 	u64 config;
 	int stopping;
 
<span class="p_del">-	stopping = test_and_clear_bit(IBS_STARTED, pcpu-&gt;state);</span>
<span class="p_add">+	stopping = test_bit(IBS_STARTED, pcpu-&gt;state);</span>
 
 	if (!stopping &amp;&amp; (hwc-&gt;state &amp; PERF_HES_UPTODATE))
 		return;
<span class="p_chunk">@@ -398,8 +404,24 @@</span> <span class="p_context"> static void perf_ibs_stop(struct perf_event *event, int flags)</span>
 	rdmsrl(hwc-&gt;config_base, config);
 
 	if (stopping) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Set STOPPING before disabling the hardware, such that it</span>
<span class="p_add">+		 * must be visible to NMIs the moment we clear the EN bit,</span>
<span class="p_add">+		 * at which point we can generate an !VALID sample which</span>
<span class="p_add">+		 * we need to consume.</span>
<span class="p_add">+		 */</span>
 		set_bit(IBS_STOPPING, pcpu-&gt;state);
 		perf_ibs_disable_event(perf_ibs, hwc, config);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Clear STARTED after disabling the hardware; if it were</span>
<span class="p_add">+		 * cleared before an NMI hitting after the clear but before</span>
<span class="p_add">+		 * clearing the EN bit might think it a spurious NMI and not</span>
<span class="p_add">+		 * handle it.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Clearing it after, however, creates the problem of the NMI</span>
<span class="p_add">+		 * handler seeing STARTED but not having a valid sample.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		clear_bit(IBS_STARTED, pcpu-&gt;state);</span>
 		WARN_ON_ONCE(hwc-&gt;state &amp; PERF_HES_STOPPED);
 		hwc-&gt;state |= PERF_HES_STOPPED;
 	}
<span class="p_chunk">@@ -527,20 +549,24 @@</span> <span class="p_context"> static int perf_ibs_handle_irq(struct perf_ibs *perf_ibs, struct pt_regs *iregs)</span>
 	u64 *buf, *config, period;
 
 	if (!test_bit(IBS_STARTED, pcpu-&gt;state)) {
<span class="p_add">+fail:</span>
 		/*
 		 * Catch spurious interrupts after stopping IBS: After
 		 * disabling IBS there could be still incoming NMIs
 		 * with samples that even have the valid bit cleared.
 		 * Mark all this NMIs as handled.
 		 */
<span class="p_del">-		return test_and_clear_bit(IBS_STOPPING, pcpu-&gt;state) ? 1 : 0;</span>
<span class="p_add">+		if (test_and_clear_bit(IBS_STOPPING, pcpu-&gt;state))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	msr = hwc-&gt;config_base;
 	buf = ibs_data.regs;
 	rdmsrl(msr, *buf);
 	if (!(*buf++ &amp; perf_ibs-&gt;valid_mask))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto fail;</span>
 
 	config = &amp;ibs_data.regs[0];
 	perf_ibs_event_update(perf_ibs, event, config);
<span class="p_chunk">@@ -599,7 +625,7 @@</span> <span class="p_context"> static int perf_ibs_handle_irq(struct perf_ibs *perf_ibs, struct pt_regs *iregs)</span>
 	throttle = perf_event_overflow(event, &amp;data, &amp;regs);
 out:
 	if (throttle)
<span class="p_del">-		perf_ibs_disable_event(perf_ibs, hwc, *config);</span>
<span class="p_add">+		perf_ibs_stop(event, 0);</span>
 	else
 		perf_ibs_enable_event(perf_ibs, hwc, period &gt;&gt; 4);
 
<span class="p_chunk">@@ -611,6 +637,7 @@</span> <span class="p_context"> static int perf_ibs_handle_irq(struct perf_ibs *perf_ibs, struct pt_regs *iregs)</span>
 static int
 perf_ibs_nmi_handler(unsigned int cmd, struct pt_regs *regs)
 {
<span class="p_add">+	u64 stamp = sched_clock();</span>
 	int handled = 0;
 
 	handled += perf_ibs_handle_irq(&amp;perf_ibs_fetch, regs);
<span class="p_chunk">@@ -619,6 +646,8 @@</span> <span class="p_context"> perf_ibs_nmi_handler(unsigned int cmd, struct pt_regs *regs)</span>
 	if (handled)
 		inc_irq_stat(apic_perf_irqs);
 
<span class="p_add">+	perf_sample_event_took(sched_clock() - stamp);</span>
<span class="p_add">+</span>
 	return handled;
 }
 NOKPROBE_SYMBOL(perf_ibs_nmi_handler);
<span class="p_header">diff --git a/arch/x86/events/amd/iommu.c b/arch/x86/events/amd/iommu.c</span>
<span class="p_header">index 635e5eba0caf..40625ca7a190 100644</span>
<span class="p_header">--- a/arch/x86/events/amd/iommu.c</span>
<span class="p_header">+++ b/arch/x86/events/amd/iommu.c</span>
<span class="p_chunk">@@ -118,6 +118,11 @@</span> <span class="p_context"> static struct amd_iommu_event_desc amd_iommu_v2_event_descs[] = {</span>
 	AMD_IOMMU_EVENT_DESC(cmd_processed,           &quot;csource=0x11&quot;),
 	AMD_IOMMU_EVENT_DESC(cmd_processed_inv,       &quot;csource=0x12&quot;),
 	AMD_IOMMU_EVENT_DESC(tlb_inv,                 &quot;csource=0x13&quot;),
<span class="p_add">+	AMD_IOMMU_EVENT_DESC(ign_rd_wr_mmio_1ff8h,    &quot;csource=0x14&quot;),</span>
<span class="p_add">+	AMD_IOMMU_EVENT_DESC(vapic_int_non_guest,     &quot;csource=0x15&quot;),</span>
<span class="p_add">+	AMD_IOMMU_EVENT_DESC(vapic_int_guest,         &quot;csource=0x16&quot;),</span>
<span class="p_add">+	AMD_IOMMU_EVENT_DESC(smi_recv,                &quot;csource=0x17&quot;),</span>
<span class="p_add">+	AMD_IOMMU_EVENT_DESC(smi_blk,                 &quot;csource=0x18&quot;),</span>
 	{ /* end: all zeroes */ },
 };
 
<span class="p_header">diff --git a/arch/x86/events/amd/power.c b/arch/x86/events/amd/power.c</span>
new file mode 100644
<span class="p_header">index 000000000000..55a3529dbf12</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/events/amd/power.c</span>
<span class="p_chunk">@@ -0,0 +1,353 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Performance events - AMD Processor Power Reporting Mechanism</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Huang Rui &lt;ray.huang@amd.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/perf_event.h&gt;</span>
<span class="p_add">+#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="p_add">+#include &quot;../perf_event.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MSR_F15H_CU_PWR_ACCUMULATOR     0xc001007a</span>
<span class="p_add">+#define MSR_F15H_CU_MAX_PWR_ACCUMULATOR 0xc001007b</span>
<span class="p_add">+#define MSR_F15H_PTSC			0xc0010280</span>
<span class="p_add">+</span>
<span class="p_add">+/* Event code: LSB 8 bits, passed in attr-&gt;config any other bit is reserved. */</span>
<span class="p_add">+#define AMD_POWER_EVENT_MASK		0xFFULL</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Accumulated power status counters.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define AMD_POWER_EVENTSEL_PKG		1</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The ratio of compute unit power accumulator sample period to the</span>
<span class="p_add">+ * PTSC period.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int cpu_pwr_sample_ratio;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Maximum accumulated power of a compute unit. */</span>
<span class="p_add">+static u64 max_cu_acc_power;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pmu pmu_class;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Accumulated power represents the sum of each compute unit&#39;s (CU) power</span>
<span class="p_add">+ * consumption. On any core of each CU we read the total accumulated power from</span>
<span class="p_add">+ * MSR_F15H_CU_PWR_ACCUMULATOR. cpu_mask represents CPU bit map of all cores</span>
<span class="p_add">+ * which are picked to measure the power for the CUs they belong to.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static cpumask_t cpu_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+static void event_update(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hw_perf_event *hwc = &amp;event-&gt;hw;</span>
<span class="p_add">+	u64 prev_pwr_acc, new_pwr_acc, prev_ptsc, new_ptsc;</span>
<span class="p_add">+	u64 delta, tdelta;</span>
<span class="p_add">+</span>
<span class="p_add">+	prev_pwr_acc = hwc-&gt;pwr_acc;</span>
<span class="p_add">+	prev_ptsc = hwc-&gt;ptsc;</span>
<span class="p_add">+	rdmsrl(MSR_F15H_CU_PWR_ACCUMULATOR, new_pwr_acc);</span>
<span class="p_add">+	rdmsrl(MSR_F15H_PTSC, new_ptsc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Calculate the CU power consumption over a time period, the unit of</span>
<span class="p_add">+	 * final value (delta) is micro-Watts. Then add it to the event count.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (new_pwr_acc &lt; prev_pwr_acc) {</span>
<span class="p_add">+		delta = max_cu_acc_power + new_pwr_acc;</span>
<span class="p_add">+		delta -= prev_pwr_acc;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		delta = new_pwr_acc - prev_pwr_acc;</span>
<span class="p_add">+</span>
<span class="p_add">+	delta *= cpu_pwr_sample_ratio * 1000;</span>
<span class="p_add">+	tdelta = new_ptsc - prev_ptsc;</span>
<span class="p_add">+</span>
<span class="p_add">+	do_div(delta, tdelta);</span>
<span class="p_add">+	local64_add(delta, &amp;event-&gt;count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __pmu_event_start(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (WARN_ON_ONCE(!(event-&gt;hw.state &amp; PERF_HES_STOPPED)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	event-&gt;hw.state = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	rdmsrl(MSR_F15H_PTSC, event-&gt;hw.ptsc);</span>
<span class="p_add">+	rdmsrl(MSR_F15H_CU_PWR_ACCUMULATOR, event-&gt;hw.pwr_acc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmu_event_start(struct perf_event *event, int mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__pmu_event_start(event);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmu_event_stop(struct perf_event *event, int mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hw_perf_event *hwc = &amp;event-&gt;hw;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Mark event as deactivated and stopped. */</span>
<span class="p_add">+	if (!(hwc-&gt;state &amp; PERF_HES_STOPPED))</span>
<span class="p_add">+		hwc-&gt;state |= PERF_HES_STOPPED;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if software counter update is necessary. */</span>
<span class="p_add">+	if ((mode &amp; PERF_EF_UPDATE) &amp;&amp; !(hwc-&gt;state &amp; PERF_HES_UPTODATE)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Drain the remaining delta count out of an event</span>
<span class="p_add">+		 * that we are disabling:</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		event_update(event);</span>
<span class="p_add">+		hwc-&gt;state |= PERF_HES_UPTODATE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int pmu_event_add(struct perf_event *event, int mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hw_perf_event *hwc = &amp;event-&gt;hw;</span>
<span class="p_add">+</span>
<span class="p_add">+	hwc-&gt;state = PERF_HES_UPTODATE | PERF_HES_STOPPED;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mode &amp; PERF_EF_START)</span>
<span class="p_add">+		__pmu_event_start(event);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmu_event_del(struct perf_event *event, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmu_event_stop(event, PERF_EF_UPDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int pmu_event_init(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 cfg = event-&gt;attr.config &amp; AMD_POWER_EVENT_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only look at AMD power events. */</span>
<span class="p_add">+	if (event-&gt;attr.type != pmu_class.type)</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unsupported modes and filters. */</span>
<span class="p_add">+	if (event-&gt;attr.exclude_user   ||</span>
<span class="p_add">+	    event-&gt;attr.exclude_kernel ||</span>
<span class="p_add">+	    event-&gt;attr.exclude_hv     ||</span>
<span class="p_add">+	    event-&gt;attr.exclude_idle   ||</span>
<span class="p_add">+	    event-&gt;attr.exclude_host   ||</span>
<span class="p_add">+	    event-&gt;attr.exclude_guest  ||</span>
<span class="p_add">+	    /* no sampling */</span>
<span class="p_add">+	    event-&gt;attr.sample_period)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cfg != AMD_POWER_EVENTSEL_PKG)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmu_event_read(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	event_update(event);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t</span>
<span class="p_add">+get_attr_cpumask(struct device *dev, struct device_attribute *attr, char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cpumap_print_to_pagebuf(true, buf, &amp;cpu_mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static DEVICE_ATTR(cpumask, S_IRUGO, get_attr_cpumask, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *pmu_attrs[] = {</span>
<span class="p_add">+	&amp;dev_attr_cpumask.attr,</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group pmu_attr_group = {</span>
<span class="p_add">+	.attrs = pmu_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Currently it only supports to report the power of each</span>
<span class="p_add">+ * processor/package.</span>
<span class="p_add">+ */</span>
<span class="p_add">+EVENT_ATTR_STR(power-pkg, power_pkg, &quot;event=0x01&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+EVENT_ATTR_STR(power-pkg.unit, power_pkg_unit, &quot;mWatts&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Convert the count from micro-Watts to milli-Watts. */</span>
<span class="p_add">+EVENT_ATTR_STR(power-pkg.scale, power_pkg_scale, &quot;1.000000e-3&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *events_attr[] = {</span>
<span class="p_add">+	EVENT_PTR(power_pkg),</span>
<span class="p_add">+	EVENT_PTR(power_pkg_unit),</span>
<span class="p_add">+	EVENT_PTR(power_pkg_scale),</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group pmu_events_group = {</span>
<span class="p_add">+	.name	= &quot;events&quot;,</span>
<span class="p_add">+	.attrs	= events_attr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+PMU_FORMAT_ATTR(event, &quot;config:0-7&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *formats_attr[] = {</span>
<span class="p_add">+	&amp;format_attr_event.attr,</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group pmu_format_group = {</span>
<span class="p_add">+	.name	= &quot;format&quot;,</span>
<span class="p_add">+	.attrs	= formats_attr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *attr_groups[] = {</span>
<span class="p_add">+	&amp;pmu_attr_group,</span>
<span class="p_add">+	&amp;pmu_format_group,</span>
<span class="p_add">+	&amp;pmu_events_group,</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pmu pmu_class = {</span>
<span class="p_add">+	.attr_groups	= attr_groups,</span>
<span class="p_add">+	/* system-wide only */</span>
<span class="p_add">+	.task_ctx_nr	= perf_invalid_context,</span>
<span class="p_add">+	.event_init	= pmu_event_init,</span>
<span class="p_add">+	.add		= pmu_event_add,</span>
<span class="p_add">+	.del		= pmu_event_del,</span>
<span class="p_add">+	.start		= pmu_event_start,</span>
<span class="p_add">+	.stop		= pmu_event_stop,</span>
<span class="p_add">+	.read		= pmu_event_read,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void power_cpu_exit(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int target;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpumask_test_and_clear_cpu(cpu, &amp;cpu_mask))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find a new CPU on the same compute unit, if was set in cpumask</span>
<span class="p_add">+	 * and still some CPUs on compute unit. Then migrate event and</span>
<span class="p_add">+	 * context to new CPU.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	target = cpumask_any_but(topology_sibling_cpumask(cpu), cpu);</span>
<span class="p_add">+	if (target &lt; nr_cpumask_bits) {</span>
<span class="p_add">+		cpumask_set_cpu(target, &amp;cpu_mask);</span>
<span class="p_add">+		perf_pmu_migrate_context(&amp;pmu_class, cpu, target);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void power_cpu_init(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int target;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 1) If any CPU is set at cpu_mask in the same compute unit, do</span>
<span class="p_add">+	 * nothing.</span>
<span class="p_add">+	 * 2) If no CPU is set at cpu_mask in the same compute unit,</span>
<span class="p_add">+	 * set current STARTING CPU.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: if there is a CPU aside of the new one already in the</span>
<span class="p_add">+	 * sibling mask, then it is also in cpu_mask.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	target = cpumask_any_but(topology_sibling_cpumask(cpu), cpu);</span>
<span class="p_add">+	if (target &gt;= nr_cpumask_bits)</span>
<span class="p_add">+		cpumask_set_cpu(cpu, &amp;cpu_mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+power_cpu_notifier(struct notifier_block *self, unsigned long action, void *hcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = (long)hcpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (action &amp; ~CPU_TASKS_FROZEN) {</span>
<span class="p_add">+	case CPU_DOWN_FAILED:</span>
<span class="p_add">+	case CPU_STARTING:</span>
<span class="p_add">+		power_cpu_init(cpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case CPU_DOWN_PREPARE:</span>
<span class="p_add">+		power_cpu_exit(cpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_OK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block power_cpu_notifier_nb = {</span>
<span class="p_add">+	.notifier_call = power_cpu_notifier,</span>
<span class="p_add">+	.priority = CPU_PRI_PERF,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct x86_cpu_id cpu_match[] = {</span>
<span class="p_add">+	{ .vendor = X86_VENDOR_AMD, .family = 0x15 },</span>
<span class="p_add">+	{},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init amd_power_pmu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, target, ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!x86_match_cpu(cpu_match))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_ACC_POWER))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu_pwr_sample_ratio = cpuid_ecx(0x80000007);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rdmsrl_safe(MSR_F15H_CU_MAX_PWR_ACCUMULATOR, &amp;max_cu_acc_power)) {</span>
<span class="p_add">+		pr_err(&quot;Failed to read max compute unit power accumulator MSR\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu_notifier_register_begin();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Choose one online core of each compute unit. */</span>
<span class="p_add">+	for_each_online_cpu(cpu) {</span>
<span class="p_add">+		target = cpumask_first(topology_sibling_cpumask(cpu));</span>
<span class="p_add">+		if (!cpumask_test_cpu(target, &amp;cpu_mask))</span>
<span class="p_add">+			cpumask_set_cpu(target, &amp;cpu_mask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = perf_pmu_register(&amp;pmu_class, &quot;power&quot;, -1);</span>
<span class="p_add">+	if (WARN_ON(ret)) {</span>
<span class="p_add">+		pr_warn(&quot;AMD Power PMU registration failed\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__register_cpu_notifier(&amp;power_cpu_notifier_nb);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD Power PMU detected\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	cpu_notifier_register_done();</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(amd_power_pmu_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit amd_power_pmu_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cpu_notifier_register_begin();</span>
<span class="p_add">+	__unregister_cpu_notifier(&amp;power_cpu_notifier_nb);</span>
<span class="p_add">+	cpu_notifier_register_done();</span>
<span class="p_add">+</span>
<span class="p_add">+	perf_pmu_unregister(&amp;pmu_class);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(amd_power_pmu_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Huang Rui &lt;ray.huang@amd.com&gt;&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;AMD Processor Power Reporting Mechanism&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_header">diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c</span>
<span class="p_header">index 5e830d0c95c9..002b2eadd600 100644</span>
<span class="p_header">--- a/arch/x86/events/core.c</span>
<span class="p_header">+++ b/arch/x86/events/core.c</span>
<span class="p_chunk">@@ -1602,8 +1602,7 @@</span> <span class="p_context"> __init struct attribute **merge_attr(struct attribute **a, struct attribute **b)</span>
 	return new;
 }
 
<span class="p_del">-ssize_t events_sysfs_show(struct device *dev, struct device_attribute *attr,</span>
<span class="p_del">-			  char *page)</span>
<span class="p_add">+ssize_t events_sysfs_show(struct device *dev, struct device_attribute *attr, char *page)</span>
 {
 	struct perf_pmu_events_attr *pmu_attr = \
 		container_of(attr, struct perf_pmu_events_attr, attr);
<span class="p_chunk">@@ -1615,6 +1614,7 @@</span> <span class="p_context"> ssize_t events_sysfs_show(struct device *dev, struct device_attribute *attr,</span>
 
 	return x86_pmu.events_sysfs_show(page, config);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(events_sysfs_show);</span>
 
 EVENT_ATTR(cpu-cycles,			CPU_CYCLES		);
 EVENT_ATTR(instructions,		INSTRUCTIONS		);
<span class="p_header">diff --git a/arch/x86/events/intel/cqm.c b/arch/x86/events/intel/cqm.c</span>
<span class="p_header">index 93cb412a5579..7b5fd811ef45 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/cqm.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/cqm.c</span>
<span class="p_chunk">@@ -13,8 +13,16 @@</span> <span class="p_context"></span>
 #define MSR_IA32_QM_CTR		0x0c8e
 #define MSR_IA32_QM_EVTSEL	0x0c8d
 
<span class="p_add">+#define MBM_CNTR_WIDTH		24</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Guaranteed time in ms as per SDM where MBM counters will not overflow.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MBM_CTR_OVERFLOW_TIME	1000</span>
<span class="p_add">+</span>
 static u32 cqm_max_rmid = -1;
 static unsigned int cqm_l3_scale; /* supposedly cacheline size */
<span class="p_add">+static bool cqm_enabled, mbm_enabled;</span>
<span class="p_add">+unsigned int mbm_socket_max;</span>
 
 /**
  * struct intel_pqr_state - State cache for the PQR MSR
<span class="p_chunk">@@ -42,8 +50,37 @@</span> <span class="p_context"> struct intel_pqr_state {</span>
  * interrupts disabled, which is sufficient for the protection.
  */
 static DEFINE_PER_CPU(struct intel_pqr_state, pqr_state);
<span class="p_add">+static struct hrtimer *mbm_timers;</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * struct sample - mbm event&#39;s (local or total) data</span>
<span class="p_add">+ * @total_bytes    #bytes since we began monitoring</span>
<span class="p_add">+ * @prev_msr       previous value of MSR</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct sample {</span>
<span class="p_add">+	u64	total_bytes;</span>
<span class="p_add">+	u64	prev_msr;</span>
<span class="p_add">+};</span>
 
 /*
<span class="p_add">+ * samples profiled for total memory bandwidth type events</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sample *mbm_total;</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * samples profiled for local memory bandwidth type events</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sample *mbm_local;</span>
<span class="p_add">+</span>
<span class="p_add">+#define pkg_id	topology_physical_package_id(smp_processor_id())</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * rmid_2_index returns the index for the rmid in mbm_local/mbm_total array.</span>
<span class="p_add">+ * mbm_total[] and mbm_local[] are linearly indexed by socket# * max number of</span>
<span class="p_add">+ * rmids per socket, an example is given below</span>
<span class="p_add">+ * RMID1 of Socket0:  vrmid =  1</span>
<span class="p_add">+ * RMID1 of Socket1:  vrmid =  1 * (cqm_max_rmid + 1) + 1</span>
<span class="p_add">+ * RMID1 of Socket2:  vrmid =  2 * (cqm_max_rmid + 1) + 1</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define rmid_2_index(rmid)  ((pkg_id * (cqm_max_rmid + 1)) + rmid)</span>
<span class="p_add">+/*</span>
  * Protects cache_cgroups and cqm_rmid_free_lru and cqm_rmid_limbo_lru.
  * Also protects event-&gt;hw.cqm_rmid
  *
<span class="p_chunk">@@ -65,9 +102,13 @@</span> <span class="p_context"> static cpumask_t cqm_cpumask;</span>
 #define RMID_VAL_ERROR		(1ULL &lt;&lt; 63)
 #define RMID_VAL_UNAVAIL	(1ULL &lt;&lt; 62)
 
<span class="p_del">-#define QOS_L3_OCCUP_EVENT_ID	(1 &lt;&lt; 0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define QOS_EVENT_MASK	QOS_L3_OCCUP_EVENT_ID</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Event IDs are used to program IA32_QM_EVTSEL before reading event</span>
<span class="p_add">+ * counter from IA32_QM_CTR</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define QOS_L3_OCCUP_EVENT_ID	0x01</span>
<span class="p_add">+#define QOS_MBM_TOTAL_EVENT_ID	0x02</span>
<span class="p_add">+#define QOS_MBM_LOCAL_EVENT_ID	0x03</span>
 
 /*
  * This is central to the rotation algorithm in __intel_cqm_rmid_rotate().
<span class="p_chunk">@@ -211,6 +252,21 @@</span> <span class="p_context"> static void __put_rmid(u32 rmid)</span>
 	list_add_tail(&amp;entry-&gt;list, &amp;cqm_rmid_limbo_lru);
 }
 
<span class="p_add">+static void cqm_cleanup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cqm_rmid_ptrs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; cqm_max_rmid; i++)</span>
<span class="p_add">+		kfree(cqm_rmid_ptrs[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(cqm_rmid_ptrs);</span>
<span class="p_add">+	cqm_rmid_ptrs = NULL;</span>
<span class="p_add">+	cqm_enabled = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int intel_cqm_setup_rmid_cache(void)
 {
 	struct cqm_rmid_entry *entry;
<span class="p_chunk">@@ -218,7 +274,7 @@</span> <span class="p_context"> static int intel_cqm_setup_rmid_cache(void)</span>
 	int r = 0;
 
 	nr_rmids = cqm_max_rmid + 1;
<span class="p_del">-	cqm_rmid_ptrs = kmalloc(sizeof(struct cqm_rmid_entry *) *</span>
<span class="p_add">+	cqm_rmid_ptrs = kzalloc(sizeof(struct cqm_rmid_entry *) *</span>
 				nr_rmids, GFP_KERNEL);
 	if (!cqm_rmid_ptrs)
 		return -ENOMEM;
<span class="p_chunk">@@ -249,11 +305,9 @@</span> <span class="p_context"> static int intel_cqm_setup_rmid_cache(void)</span>
 	mutex_unlock(&amp;cache_mutex);
 
 	return 0;
<span class="p_del">-fail:</span>
<span class="p_del">-	while (r--)</span>
<span class="p_del">-		kfree(cqm_rmid_ptrs[r]);</span>
 
<span class="p_del">-	kfree(cqm_rmid_ptrs);</span>
<span class="p_add">+fail:</span>
<span class="p_add">+	cqm_cleanup();</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -281,9 +335,13 @@</span> <span class="p_context"> static bool __match_event(struct perf_event *a, struct perf_event *b)</span>
 
 	/*
 	 * Events that target same task are placed into the same cache group.
<span class="p_add">+	 * Mark it as a multi event group, so that we update -&gt;count</span>
<span class="p_add">+	 * for every event rather than just the group leader later.</span>
 	 */
<span class="p_del">-	if (a-&gt;hw.target == b-&gt;hw.target)</span>
<span class="p_add">+	if (a-&gt;hw.target == b-&gt;hw.target) {</span>
<span class="p_add">+		b-&gt;hw.is_group_event = true;</span>
 		return true;
<span class="p_add">+	}</span>
 
 	/*
 	 * Are we an inherited event?
<span class="p_chunk">@@ -392,10 +450,26 @@</span> <span class="p_context"> static bool __conflict_event(struct perf_event *a, struct perf_event *b)</span>
 
 struct rmid_read {
 	u32 rmid;
<span class="p_add">+	u32 evt_type;</span>
 	atomic64_t value;
 };
 
 static void __intel_cqm_event_count(void *info);
<span class="p_add">+static void init_mbm_sample(u32 rmid, u32 evt_type);</span>
<span class="p_add">+static void __intel_mbm_event_count(void *info);</span>
<span class="p_add">+</span>
<span class="p_add">+static bool is_mbm_event(int e)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (e &gt;= QOS_MBM_TOTAL_EVENT_ID &amp;&amp; e &lt;= QOS_MBM_LOCAL_EVENT_ID);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cqm_mask_call(struct rmid_read *rr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_mbm_event(rr-&gt;evt_type))</span>
<span class="p_add">+		on_each_cpu_mask(&amp;cqm_cpumask, __intel_mbm_event_count, rr, 1);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		on_each_cpu_mask(&amp;cqm_cpumask, __intel_cqm_event_count, rr, 1);</span>
<span class="p_add">+}</span>
 
 /*
  * Exchange the RMID of a group of events.
<span class="p_chunk">@@ -413,12 +487,12 @@</span> <span class="p_context"> static u32 intel_cqm_xchg_rmid(struct perf_event *group, u32 rmid)</span>
 	 */
 	if (__rmid_valid(old_rmid) &amp;&amp; !__rmid_valid(rmid)) {
 		struct rmid_read rr = {
<span class="p_del">-			.value = ATOMIC64_INIT(0),</span>
 			.rmid = old_rmid,
<span class="p_add">+			.evt_type = group-&gt;attr.config,</span>
<span class="p_add">+			.value = ATOMIC64_INIT(0),</span>
 		};
 
<span class="p_del">-		on_each_cpu_mask(&amp;cqm_cpumask, __intel_cqm_event_count,</span>
<span class="p_del">-				 &amp;rr, 1);</span>
<span class="p_add">+		cqm_mask_call(&amp;rr);</span>
 		local64_set(&amp;group-&gt;count, atomic64_read(&amp;rr.value));
 	}
 
<span class="p_chunk">@@ -430,6 +504,22 @@</span> <span class="p_context"> static u32 intel_cqm_xchg_rmid(struct perf_event *group, u32 rmid)</span>
 
 	raw_spin_unlock_irq(&amp;cache_lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the allocation is for mbm, init the mbm stats.</span>
<span class="p_add">+	 * Need to check if each event in the group is mbm event</span>
<span class="p_add">+	 * because there could be multiple type of events in the same group.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__rmid_valid(rmid)) {</span>
<span class="p_add">+		event = group;</span>
<span class="p_add">+		if (is_mbm_event(event-&gt;attr.config))</span>
<span class="p_add">+			init_mbm_sample(rmid, event-&gt;attr.config);</span>
<span class="p_add">+</span>
<span class="p_add">+		list_for_each_entry(event, head, hw.cqm_group_entry) {</span>
<span class="p_add">+			if (is_mbm_event(event-&gt;attr.config))</span>
<span class="p_add">+				init_mbm_sample(rmid, event-&gt;attr.config);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return old_rmid;
 }
 
<span class="p_chunk">@@ -837,6 +927,72 @@</span> <span class="p_context"> static void intel_cqm_rmid_rotate(struct work_struct *work)</span>
 	schedule_delayed_work(&amp;intel_cqm_rmid_work, delay);
 }
 
<span class="p_add">+static u64 update_sample(unsigned int rmid, u32 evt_type, int first)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sample *mbm_current;</span>
<span class="p_add">+	u32 vrmid = rmid_2_index(rmid);</span>
<span class="p_add">+	u64 val, bytes, shift;</span>
<span class="p_add">+	u32 eventid;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (evt_type == QOS_MBM_LOCAL_EVENT_ID) {</span>
<span class="p_add">+		mbm_current = &amp;mbm_local[vrmid];</span>
<span class="p_add">+		eventid     = QOS_MBM_LOCAL_EVENT_ID;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mbm_current = &amp;mbm_total[vrmid];</span>
<span class="p_add">+		eventid     = QOS_MBM_TOTAL_EVENT_ID;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	wrmsr(MSR_IA32_QM_EVTSEL, eventid, rmid);</span>
<span class="p_add">+	rdmsrl(MSR_IA32_QM_CTR, val);</span>
<span class="p_add">+	if (val &amp; (RMID_VAL_ERROR | RMID_VAL_UNAVAIL))</span>
<span class="p_add">+		return mbm_current-&gt;total_bytes;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (first) {</span>
<span class="p_add">+		mbm_current-&gt;prev_msr = val;</span>
<span class="p_add">+		mbm_current-&gt;total_bytes = 0;</span>
<span class="p_add">+		return mbm_current-&gt;total_bytes;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The h/w guarantees that counters will not overflow</span>
<span class="p_add">+	 * so long as we poll them at least once per second.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	shift = 64 - MBM_CNTR_WIDTH;</span>
<span class="p_add">+	bytes = (val &lt;&lt; shift) - (mbm_current-&gt;prev_msr &lt;&lt; shift);</span>
<span class="p_add">+	bytes &gt;&gt;= shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	bytes *= cqm_l3_scale;</span>
<span class="p_add">+</span>
<span class="p_add">+	mbm_current-&gt;total_bytes += bytes;</span>
<span class="p_add">+	mbm_current-&gt;prev_msr = val;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mbm_current-&gt;total_bytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u64 rmid_read_mbm(unsigned int rmid, u32 evt_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return update_sample(rmid, evt_type, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __intel_mbm_event_init(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rmid_read *rr = info;</span>
<span class="p_add">+</span>
<span class="p_add">+	update_sample(rr-&gt;rmid, rr-&gt;evt_type, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void init_mbm_sample(u32 rmid, u32 evt_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rmid_read rr = {</span>
<span class="p_add">+		.rmid = rmid,</span>
<span class="p_add">+		.evt_type = evt_type,</span>
<span class="p_add">+		.value = ATOMIC64_INIT(0),</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	/* on each socket, init sample */</span>
<span class="p_add">+	on_each_cpu_mask(&amp;cqm_cpumask, __intel_mbm_event_init, &amp;rr, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Find a group and setup RMID.
  *
<span class="p_chunk">@@ -849,6 +1005,7 @@</span> <span class="p_context"> static void intel_cqm_setup_event(struct perf_event *event,</span>
 	bool conflict = false;
 	u32 rmid;
 
<span class="p_add">+	event-&gt;hw.is_group_event = false;</span>
 	list_for_each_entry(iter, &amp;cache_groups, hw.cqm_groups_entry) {
 		rmid = iter-&gt;hw.cqm_rmid;
 
<span class="p_chunk">@@ -856,6 +1013,8 @@</span> <span class="p_context"> static void intel_cqm_setup_event(struct perf_event *event,</span>
 			/* All tasks in a group share an RMID */
 			event-&gt;hw.cqm_rmid = rmid;
 			*group = iter;
<span class="p_add">+			if (is_mbm_event(event-&gt;attr.config) &amp;&amp; __rmid_valid(rmid))</span>
<span class="p_add">+				init_mbm_sample(rmid, event-&gt;attr.config);</span>
 			return;
 		}
 
<span class="p_chunk">@@ -872,6 +1031,9 @@</span> <span class="p_context"> static void intel_cqm_setup_event(struct perf_event *event,</span>
 	else
 		rmid = __get_rmid();
 
<span class="p_add">+	if (is_mbm_event(event-&gt;attr.config) &amp;&amp; __rmid_valid(rmid))</span>
<span class="p_add">+		init_mbm_sample(rmid, event-&gt;attr.config);</span>
<span class="p_add">+</span>
 	event-&gt;hw.cqm_rmid = rmid;
 }
 
<span class="p_chunk">@@ -893,7 +1055,10 @@</span> <span class="p_context"> static void intel_cqm_event_read(struct perf_event *event)</span>
 	if (!__rmid_valid(rmid))
 		goto out;
 
<span class="p_del">-	val = __rmid_read(rmid);</span>
<span class="p_add">+	if (is_mbm_event(event-&gt;attr.config))</span>
<span class="p_add">+		val = rmid_read_mbm(rmid, event-&gt;attr.config);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		val = __rmid_read(rmid);</span>
 
 	/*
 	 * Ignore this reading on error states and do not update the value.
<span class="p_chunk">@@ -924,10 +1089,100 @@</span> <span class="p_context"> static inline bool cqm_group_leader(struct perf_event *event)</span>
 	return !list_empty(&amp;event-&gt;hw.cqm_groups_entry);
 }
 
<span class="p_add">+static void __intel_mbm_event_count(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rmid_read *rr = info;</span>
<span class="p_add">+	u64 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = rmid_read_mbm(rr-&gt;rmid, rr-&gt;evt_type);</span>
<span class="p_add">+	if (val &amp; (RMID_VAL_ERROR | RMID_VAL_UNAVAIL))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	atomic64_add(val, &amp;rr-&gt;value);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static enum hrtimer_restart mbm_hrtimer_handle(struct hrtimer *hrtimer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event *iter, *iter1;</span>
<span class="p_add">+	int ret = HRTIMER_RESTART;</span>
<span class="p_add">+	struct list_head *head;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 grp_rmid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Need to cache_lock as the timer Event Select MSR reads</span>
<span class="p_add">+	 * can race with the mbm/cqm count() and mbm_init() reads.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;cache_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (list_empty(&amp;cache_groups)) {</span>
<span class="p_add">+		ret = HRTIMER_NORESTART;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(iter, &amp;cache_groups, hw.cqm_groups_entry) {</span>
<span class="p_add">+		grp_rmid = iter-&gt;hw.cqm_rmid;</span>
<span class="p_add">+		if (!__rmid_valid(grp_rmid))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (is_mbm_event(iter-&gt;attr.config))</span>
<span class="p_add">+			update_sample(grp_rmid, iter-&gt;attr.config, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		head = &amp;iter-&gt;hw.cqm_group_entry;</span>
<span class="p_add">+		if (list_empty(head))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		list_for_each_entry(iter1, head, hw.cqm_group_entry) {</span>
<span class="p_add">+			if (!iter1-&gt;hw.is_group_event)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if (is_mbm_event(iter1-&gt;attr.config))</span>
<span class="p_add">+				update_sample(iter1-&gt;hw.cqm_rmid,</span>
<span class="p_add">+					      iter1-&gt;attr.config, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hrtimer_forward_now(hrtimer, ms_to_ktime(MBM_CTR_OVERFLOW_TIME));</span>
<span class="p_add">+out:</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;cache_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __mbm_start_timer(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	hrtimer_start(&amp;mbm_timers[pkg_id], ms_to_ktime(MBM_CTR_OVERFLOW_TIME),</span>
<span class="p_add">+			     HRTIMER_MODE_REL_PINNED);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __mbm_stop_timer(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	hrtimer_cancel(&amp;mbm_timers[pkg_id]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mbm_start_timers(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu_mask(&amp;cqm_cpumask, __mbm_start_timer, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mbm_stop_timers(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu_mask(&amp;cqm_cpumask, __mbm_stop_timer, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mbm_hrtimer_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hrtimer *hr;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mbm_socket_max; i++) {</span>
<span class="p_add">+		hr = &amp;mbm_timers[i];</span>
<span class="p_add">+		hrtimer_init(hr, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span>
<span class="p_add">+		hr-&gt;function = mbm_hrtimer_handle;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u64 intel_cqm_event_count(struct perf_event *event)
 {
 	unsigned long flags;
 	struct rmid_read rr = {
<span class="p_add">+		.evt_type = event-&gt;attr.config,</span>
 		.value = ATOMIC64_INIT(0),
 	};
 
<span class="p_chunk">@@ -940,7 +1195,9 @@</span> <span class="p_context"> static u64 intel_cqm_event_count(struct perf_event *event)</span>
 		return __perf_event_count(event);
 
 	/*
<span class="p_del">-	 * Only the group leader gets to report values. This stops us</span>
<span class="p_add">+	 * Only the group leader gets to report values except in case of</span>
<span class="p_add">+	 * multiple events in the same group, we still need to read the</span>
<span class="p_add">+	 * other events.This stops us</span>
 	 * reporting duplicate values to userspace, and gives us a clear
 	 * rule for which task gets to report the values.
 	 *
<span class="p_chunk">@@ -948,7 +1205,7 @@</span> <span class="p_context"> static u64 intel_cqm_event_count(struct perf_event *event)</span>
 	 * specific packages - we forfeit that ability when we create
 	 * task events.
 	 */
<span class="p_del">-	if (!cqm_group_leader(event))</span>
<span class="p_add">+	if (!cqm_group_leader(event) &amp;&amp; !event-&gt;hw.is_group_event)</span>
 		return 0;
 
 	/*
<span class="p_chunk">@@ -975,7 +1232,7 @@</span> <span class="p_context"> static u64 intel_cqm_event_count(struct perf_event *event)</span>
 	if (!__rmid_valid(rr.rmid))
 		goto out;
 
<span class="p_del">-	on_each_cpu_mask(&amp;cqm_cpumask, __intel_cqm_event_count, &amp;rr, 1);</span>
<span class="p_add">+	cqm_mask_call(&amp;rr);</span>
 
 	raw_spin_lock_irqsave(&amp;cache_lock, flags);
 	if (event-&gt;hw.cqm_rmid == rr.rmid)
<span class="p_chunk">@@ -1046,8 +1303,14 @@</span> <span class="p_context"> static int intel_cqm_event_add(struct perf_event *event, int mode)</span>
 static void intel_cqm_event_destroy(struct perf_event *event)
 {
 	struct perf_event *group_other = NULL;
<span class="p_add">+	unsigned long flags;</span>
 
 	mutex_lock(&amp;cache_mutex);
<span class="p_add">+	/*</span>
<span class="p_add">+	* Hold the cache_lock as mbm timer handlers could be</span>
<span class="p_add">+	* scanning the list of events.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;cache_lock, flags);</span>
 
 	/*
 	 * If there&#39;s another event in this group...
<span class="p_chunk">@@ -1079,6 +1342,14 @@</span> <span class="p_context"> static void intel_cqm_event_destroy(struct perf_event *event)</span>
 		}
 	}
 
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;cache_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Stop the mbm overflow timers when the last event is destroyed.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if (mbm_enabled &amp;&amp; list_empty(&amp;cache_groups))</span>
<span class="p_add">+		mbm_stop_timers();</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;cache_mutex);
 }
 
<span class="p_chunk">@@ -1086,11 +1357,13 @@</span> <span class="p_context"> static int intel_cqm_event_init(struct perf_event *event)</span>
 {
 	struct perf_event *group = NULL;
 	bool rotate = false;
<span class="p_add">+	unsigned long flags;</span>
 
 	if (event-&gt;attr.type != intel_cqm_pmu.type)
 		return -ENOENT;
 
<span class="p_del">-	if (event-&gt;attr.config &amp; ~QOS_EVENT_MASK)</span>
<span class="p_add">+	if ((event-&gt;attr.config &lt; QOS_L3_OCCUP_EVENT_ID) ||</span>
<span class="p_add">+	     (event-&gt;attr.config &gt; QOS_MBM_LOCAL_EVENT_ID))</span>
 		return -EINVAL;
 
 	/* unsupported modes and filters */
<span class="p_chunk">@@ -1110,9 +1383,21 @@</span> <span class="p_context"> static int intel_cqm_event_init(struct perf_event *event)</span>
 
 	mutex_lock(&amp;cache_mutex);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Start the mbm overflow timers when the first event is created.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if (mbm_enabled &amp;&amp; list_empty(&amp;cache_groups))</span>
<span class="p_add">+		mbm_start_timers();</span>
<span class="p_add">+</span>
 	/* Will also set rmid */
 	intel_cqm_setup_event(event, &amp;group);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	* Hold the cache_lock as mbm timer handlers be</span>
<span class="p_add">+	* scanning the list of events.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;cache_lock, flags);</span>
<span class="p_add">+</span>
 	if (group) {
 		list_add_tail(&amp;event-&gt;hw.cqm_group_entry,
 			      &amp;group-&gt;hw.cqm_group_entry);
<span class="p_chunk">@@ -1131,6 +1416,7 @@</span> <span class="p_context"> static int intel_cqm_event_init(struct perf_event *event)</span>
 			rotate = true;
 	}
 
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;cache_lock, flags);</span>
 	mutex_unlock(&amp;cache_mutex);
 
 	if (rotate)
<span class="p_chunk">@@ -1145,6 +1431,16 @@</span> <span class="p_context"> EVENT_ATTR_STR(llc_occupancy.unit, intel_cqm_llc_unit, &quot;Bytes&quot;);</span>
 EVENT_ATTR_STR(llc_occupancy.scale, intel_cqm_llc_scale, NULL);
 EVENT_ATTR_STR(llc_occupancy.snapshot, intel_cqm_llc_snapshot, &quot;1&quot;);
 
<span class="p_add">+EVENT_ATTR_STR(total_bytes, intel_cqm_total_bytes, &quot;event=0x02&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(total_bytes.per-pkg, intel_cqm_total_bytes_pkg, &quot;1&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(total_bytes.unit, intel_cqm_total_bytes_unit, &quot;MB&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(total_bytes.scale, intel_cqm_total_bytes_scale, &quot;1e-6&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+EVENT_ATTR_STR(local_bytes, intel_cqm_local_bytes, &quot;event=0x03&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(local_bytes.per-pkg, intel_cqm_local_bytes_pkg, &quot;1&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(local_bytes.unit, intel_cqm_local_bytes_unit, &quot;MB&quot;);</span>
<span class="p_add">+EVENT_ATTR_STR(local_bytes.scale, intel_cqm_local_bytes_scale, &quot;1e-6&quot;);</span>
<span class="p_add">+</span>
 static struct attribute *intel_cqm_events_attr[] = {
 	EVENT_PTR(intel_cqm_llc),
 	EVENT_PTR(intel_cqm_llc_pkg),
<span class="p_chunk">@@ -1154,9 +1450,38 @@</span> <span class="p_context"> static struct attribute *intel_cqm_events_attr[] = {</span>
 	NULL,
 };
 
<span class="p_add">+static struct attribute *intel_mbm_events_attr[] = {</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_pkg),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_pkg),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_unit),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_unit),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_scale),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_scale),</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *intel_cmt_mbm_events_attr[] = {</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_llc),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_llc_pkg),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_pkg),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_pkg),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_llc_unit),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_unit),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_unit),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_llc_scale),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_total_bytes_scale),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_local_bytes_scale),</span>
<span class="p_add">+	EVENT_PTR(intel_cqm_llc_snapshot),</span>
<span class="p_add">+	NULL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct attribute_group intel_cqm_events_group = {
 	.name = &quot;events&quot;,
<span class="p_del">-	.attrs = intel_cqm_events_attr,</span>
<span class="p_add">+	.attrs = NULL,</span>
 };
 
 PMU_FORMAT_ATTR(event, &quot;config:0-7&quot;);
<span class="p_chunk">@@ -1303,12 +1628,70 @@</span> <span class="p_context"> static const struct x86_cpu_id intel_cqm_match[] = {</span>
 	{}
 };
 
<span class="p_add">+static void mbm_cleanup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!mbm_enabled)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(mbm_local);</span>
<span class="p_add">+	kfree(mbm_total);</span>
<span class="p_add">+	mbm_enabled = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct x86_cpu_id intel_mbm_local_match[] = {</span>
<span class="p_add">+	{ .vendor = X86_VENDOR_INTEL, .feature = X86_FEATURE_CQM_MBM_LOCAL },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct x86_cpu_id intel_mbm_total_match[] = {</span>
<span class="p_add">+	{ .vendor = X86_VENDOR_INTEL, .feature = X86_FEATURE_CQM_MBM_TOTAL },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int intel_mbm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0, array_size, maxid = cqm_max_rmid + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	mbm_socket_max = topology_max_packages();</span>
<span class="p_add">+	array_size = sizeof(struct sample) * maxid * mbm_socket_max;</span>
<span class="p_add">+	mbm_local = kmalloc(array_size, GFP_KERNEL);</span>
<span class="p_add">+	if (!mbm_local)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	mbm_total = kmalloc(array_size, GFP_KERNEL);</span>
<span class="p_add">+	if (!mbm_total) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	array_size = sizeof(struct hrtimer) * mbm_socket_max;</span>
<span class="p_add">+	mbm_timers = kmalloc(array_size, GFP_KERNEL);</span>
<span class="p_add">+	if (!mbm_timers) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mbm_hrtimer_init();</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		mbm_cleanup();</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init intel_cqm_init(void)
 {
<span class="p_del">-	char *str, scale[20];</span>
<span class="p_add">+	char *str = NULL, scale[20];</span>
 	int i, cpu, ret;
 
<span class="p_del">-	if (!x86_match_cpu(intel_cqm_match))</span>
<span class="p_add">+	if (x86_match_cpu(intel_cqm_match))</span>
<span class="p_add">+		cqm_enabled = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (x86_match_cpu(intel_mbm_local_match) &amp;&amp;</span>
<span class="p_add">+	     x86_match_cpu(intel_mbm_total_match))</span>
<span class="p_add">+		mbm_enabled = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cqm_enabled &amp;&amp; !mbm_enabled)</span>
 		return -ENODEV;
 
 	cqm_l3_scale = boot_cpu_data.x86_cache_occ_scale;
<span class="p_chunk">@@ -1365,16 +1748,41 @@</span> <span class="p_context"> static int __init intel_cqm_init(void)</span>
 		cqm_pick_event_reader(i);
 	}
 
<span class="p_del">-	__perf_cpu_notifier(intel_cqm_cpu_notifier);</span>
<span class="p_add">+	if (mbm_enabled)</span>
<span class="p_add">+		ret = intel_mbm_init();</span>
<span class="p_add">+	if (ret &amp;&amp; !cqm_enabled)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cqm_enabled &amp;&amp; mbm_enabled)</span>
<span class="p_add">+		intel_cqm_events_group.attrs = intel_cmt_mbm_events_attr;</span>
<span class="p_add">+	else if (!cqm_enabled &amp;&amp; mbm_enabled)</span>
<span class="p_add">+		intel_cqm_events_group.attrs = intel_mbm_events_attr;</span>
<span class="p_add">+	else if (cqm_enabled &amp;&amp; !mbm_enabled)</span>
<span class="p_add">+		intel_cqm_events_group.attrs = intel_cqm_events_attr;</span>
 
 	ret = perf_pmu_register(&amp;intel_cqm_pmu, &quot;intel_cqm&quot;, -1);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
 		pr_err(&quot;Intel CQM perf registration failed: %d\n&quot;, ret);
<span class="p_del">-	else</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cqm_enabled)</span>
 		pr_info(&quot;Intel CQM monitoring enabled\n&quot;);
<span class="p_add">+	if (mbm_enabled)</span>
<span class="p_add">+		pr_info(&quot;Intel MBM enabled\n&quot;);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Register the hot cpu notifier once we are sure cqm</span>
<span class="p_add">+	 * is enabled to avoid notifier leak.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__perf_cpu_notifier(intel_cqm_cpu_notifier);</span>
 out:
 	cpu_notifier_register_done();
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		kfree(str);</span>
<span class="p_add">+		cqm_cleanup();</span>
<span class="p_add">+		mbm_cleanup();</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/arch/x86/events/intel/ds.c b/arch/x86/events/intel/ds.c</span>
<span class="p_header">index ce7211a07c0b..8584b90d8e0b 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/ds.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/ds.c</span>
<span class="p_chunk">@@ -570,11 +570,12 @@</span> <span class="p_context"> int intel_pmu_drain_bts_buffer(void)</span>
 	 * We will overwrite the from and to address before we output
 	 * the sample.
 	 */
<span class="p_add">+	rcu_read_lock();</span>
 	perf_prepare_sample(&amp;header, &amp;data, event, &amp;regs);
 
 	if (perf_output_begin(&amp;handle, event, header.size *
 			      (top - base - skip)))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		goto unlock;</span>
 
 	for (at = base; at &lt; top; at++) {
 		/* Filter out any records that contain kernel addresses. */
<span class="p_chunk">@@ -593,6 +594,8 @@</span> <span class="p_context"> int intel_pmu_drain_bts_buffer(void)</span>
 	/* There&#39;s new data available. */
 	event-&gt;hw.interrupts++;
 	event-&gt;pending_kill = POLL_IN;
<span class="p_add">+unlock:</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/arch/x86/events/intel/rapl.c b/arch/x86/events/intel/rapl.c</span>
<span class="p_header">index b834a3f55a01..70c93f9b03ac 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/rapl.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/rapl.c</span>
<span class="p_chunk">@@ -711,6 +711,7 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 		rapl_pmu_events_group.attrs = rapl_events_cln_attr;
 		break;
 	case 63: /* Haswell-Server */
<span class="p_add">+	case 79: /* Broadwell-Server */</span>
 		apply_quirk = true;
 		rapl_cntr_mask = RAPL_IDX_SRV;
 		rapl_pmu_events_group.attrs = rapl_events_srv_attr;
<span class="p_chunk">@@ -718,6 +719,7 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 	case 60: /* Haswell */
 	case 69: /* Haswell-Celeron */
 	case 61: /* Broadwell */
<span class="p_add">+	case 71: /* Broadwell-H */</span>
 		rapl_cntr_mask = RAPL_IDX_HSW;
 		rapl_pmu_events_group.attrs = rapl_events_hsw_attr;
 		break;
<span class="p_header">diff --git a/arch/x86/events/intel/uncore_snbep.c b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">index 93f6bd9bf761..ab2bcaaebe38 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_chunk">@@ -46,7 +46,6 @@</span> <span class="p_context"></span>
 				(SNBEP_PMON_CTL_EV_SEL_MASK | \
 				 SNBEP_PCU_MSR_PMON_CTL_OCC_SEL_MASK | \
 				 SNBEP_PMON_CTL_EDGE_DET | \
<span class="p_del">-				 SNBEP_PMON_CTL_EV_SEL_EXT | \</span>
 				 SNBEP_PMON_CTL_INVERT | \
 				 SNBEP_PCU_MSR_PMON_CTL_TRESH_MASK | \
 				 SNBEP_PCU_MSR_PMON_CTL_OCC_INVERT | \
<span class="p_chunk">@@ -148,7 +147,6 @@</span> <span class="p_context"></span>
 /* IVBEP PCU */
 #define IVBEP_PCU_MSR_PMON_RAW_EVENT_MASK	\
 				(SNBEP_PMON_CTL_EV_SEL_MASK | \
<span class="p_del">-				 SNBEP_PMON_CTL_EV_SEL_EXT | \</span>
 				 SNBEP_PCU_MSR_PMON_CTL_OCC_SEL_MASK | \
 				 SNBEP_PMON_CTL_EDGE_DET | \
 				 SNBEP_PCU_MSR_PMON_CTL_TRESH_MASK | \
<span class="p_chunk">@@ -258,7 +256,6 @@</span> <span class="p_context"></span>
 				 SNBEP_PCU_MSR_PMON_CTL_OCC_SEL_MASK | \
 				 SNBEP_PMON_CTL_EDGE_DET | \
 				 SNBEP_CBO_PMON_CTL_TID_EN | \
<span class="p_del">-				 SNBEP_PMON_CTL_EV_SEL_EXT | \</span>
 				 SNBEP_PMON_CTL_INVERT | \
 				 KNL_PCU_MSR_PMON_CTL_TRESH_MASK | \
 				 SNBEP_PCU_MSR_PMON_CTL_OCC_INVERT | \
<span class="p_chunk">@@ -472,7 +469,7 @@</span> <span class="p_context"> static struct attribute *snbep_uncore_cbox_formats_attr[] = {</span>
 };
 
 static struct attribute *snbep_uncore_pcu_formats_attr[] = {
<span class="p_del">-	&amp;format_attr_event_ext.attr,</span>
<span class="p_add">+	&amp;format_attr_event.attr,</span>
 	&amp;format_attr_occ_sel.attr,
 	&amp;format_attr_edge.attr,
 	&amp;format_attr_inv.attr,
<span class="p_chunk">@@ -1313,7 +1310,7 @@</span> <span class="p_context"> static struct attribute *ivbep_uncore_cbox_formats_attr[] = {</span>
 };
 
 static struct attribute *ivbep_uncore_pcu_formats_attr[] = {
<span class="p_del">-	&amp;format_attr_event_ext.attr,</span>
<span class="p_add">+	&amp;format_attr_event.attr,</span>
 	&amp;format_attr_occ_sel.attr,
 	&amp;format_attr_edge.attr,
 	&amp;format_attr_thresh5.attr,
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">index 074b7604bd51..44ebd04878eb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"></span>
 #define X86_FEATURE_REP_GOOD	( 3*32+16) /* rep microcode works well */
 #define X86_FEATURE_MFENCE_RDTSC ( 3*32+17) /* &quot;&quot; Mfence synchronizes RDTSC */
 #define X86_FEATURE_LFENCE_RDTSC ( 3*32+18) /* &quot;&quot; Lfence synchronizes RDTSC */
<span class="p_del">-/* free, was #define X86_FEATURE_11AP	( 3*32+19) * &quot;&quot; Bad local APIC aka 11AP */</span>
<span class="p_add">+#define X86_FEATURE_ACC_POWER	( 3*32+19) /* AMD Accumulated Power Mechanism */</span>
 #define X86_FEATURE_NOPL	( 3*32+20) /* The NOPL (0F 1F) instructions */
 #define X86_FEATURE_ALWAYS	( 3*32+21) /* &quot;&quot; Always-present feature */
 #define X86_FEATURE_XTOPOLOGY	( 3*32+22) /* cpu topology enum extensions */
<span class="p_chunk">@@ -245,6 +245,8 @@</span> <span class="p_context"></span>
 
 /* Intel-defined CPU QoS Sub-leaf, CPUID level 0x0000000F:1 (edx), word 12 */
 #define X86_FEATURE_CQM_OCCUP_LLC (12*32+ 0) /* LLC occupancy monitoring if 1 */
<span class="p_add">+#define X86_FEATURE_CQM_MBM_TOTAL (12*32+ 1) /* LLC Total MBM monitoring */</span>
<span class="p_add">+#define X86_FEATURE_CQM_MBM_LOCAL (12*32+ 2) /* LLC Local MBM monitoring */</span>
 
 /* AMD-defined CPU features, CPUID level 0x80000008 (ebx), word 13 */
 #define X86_FEATURE_CLZERO	(13*32+0) /* CLZERO instruction */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">index b39338c4b260..68fe8d3bed56 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_chunk">@@ -306,7 +306,6 @@</span> <span class="p_context"> static void amd_get_topology(struct cpuinfo_x86 *c)</span>
 		u32 eax, ebx, ecx, edx;
 
 		cpuid(0x8000001e, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
<span class="p_del">-		nodes_per_socket = ((ecx &gt;&gt; 8) &amp; 7) + 1;</span>
 		node_id = ecx &amp; 7;
 
 		/* get compute unit information */
<span class="p_chunk">@@ -317,7 +316,6 @@</span> <span class="p_context"> static void amd_get_topology(struct cpuinfo_x86 *c)</span>
 		u64 value;
 
 		rdmsrl(MSR_FAM10H_NODE_ID, value);
<span class="p_del">-		nodes_per_socket = ((value &gt;&gt; 3) &amp; 7) + 1;</span>
 		node_id = value &amp; 7;
 	} else
 		return;
<span class="p_chunk">@@ -519,6 +517,18 @@</span> <span class="p_context"> static void bsp_init_amd(struct cpuinfo_x86 *c)</span>
 
 	if (cpu_has(c, X86_FEATURE_MWAITX))
 		use_mwaitx_delay();
<span class="p_add">+</span>
<span class="p_add">+	if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {</span>
<span class="p_add">+		u32 ecx;</span>
<span class="p_add">+</span>
<span class="p_add">+		ecx = cpuid_ecx(0x8000001e);</span>
<span class="p_add">+		nodes_per_socket = ((ecx &gt;&gt; 8) &amp; 7) + 1;</span>
<span class="p_add">+	} else if (boot_cpu_has(X86_FEATURE_NODEID_MSR)) {</span>
<span class="p_add">+		u64 value;</span>
<span class="p_add">+</span>
<span class="p_add">+		rdmsrl(MSR_FAM10H_NODE_ID, value);</span>
<span class="p_add">+		nodes_per_socket = ((value &gt;&gt; 3) &amp; 7) + 1;</span>
<span class="p_add">+	}</span>
 }
 
 static void early_init_amd(struct cpuinfo_x86 *c)
<span class="p_chunk">@@ -536,6 +546,10 @@</span> <span class="p_context"> static void early_init_amd(struct cpuinfo_x86 *c)</span>
 			set_sched_clock_stable();
 	}
 
<span class="p_add">+	/* Bit 12 of 8000_0007 edx is accumulated power mechanism. */</span>
<span class="p_add">+	if (c-&gt;x86_power &amp; BIT(12))</span>
<span class="p_add">+		set_cpu_cap(c, X86_FEATURE_ACC_POWER);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_64
 	set_cpu_cap(c, X86_FEATURE_SYSCALL32);
 #else
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 62590aa064c8..e601c1286e29 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -649,7 +649,9 @@</span> <span class="p_context"> void get_cpu_cap(struct cpuinfo_x86 *c)</span>
 			cpuid_count(0x0000000F, 1, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
 			c-&gt;x86_capability[CPUID_F_1_EDX] = edx;
 
<span class="p_del">-			if (cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) {</span>
<span class="p_add">+			if ((cpu_has(c, X86_FEATURE_CQM_OCCUP_LLC)) ||</span>
<span class="p_add">+			      ((cpu_has(c, X86_FEATURE_CQM_MBM_TOTAL)) ||</span>
<span class="p_add">+			       (cpu_has(c, X86_FEATURE_CQM_MBM_LOCAL)))) {</span>
 				c-&gt;x86_cache_max_rmid = ecx;
 				c-&gt;x86_cache_occ_scale = ebx;
 			}
<span class="p_header">diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h</span>
<span class="p_header">index 79ec7bbf0155..15588d4c581d 100644</span>
<span class="p_header">--- a/include/linux/perf_event.h</span>
<span class="p_header">+++ b/include/linux/perf_event.h</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> struct hw_perf_event {</span>
 		struct { /* intel_cqm */
 			int			cqm_state;
 			u32			cqm_rmid;
<span class="p_add">+			int			is_group_event;</span>
 			struct list_head	cqm_events_entry;
 			struct list_head	cqm_groups_entry;
 			struct list_head	cqm_group_entry;
<span class="p_chunk">@@ -128,6 +129,10 @@</span> <span class="p_context"> struct hw_perf_event {</span>
 		struct { /* itrace */
 			int			itrace_started;
 		};
<span class="p_add">+		struct { /* amd_power */</span>
<span class="p_add">+			u64	pwr_acc;</span>
<span class="p_add">+			u64	ptsc;</span>
<span class="p_add">+		};</span>
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
 		struct { /* breakpoint */
 			/*
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 712570dddacd..de24fbce5277 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -376,8 +376,11 @@</span> <span class="p_context"> static void update_perf_cpu_limits(void)</span>
 	u64 tmp = perf_sample_period_ns;
 
 	tmp *= sysctl_perf_cpu_time_max_percent;
<span class="p_del">-	do_div(tmp, 100);</span>
<span class="p_del">-	ACCESS_ONCE(perf_sample_allowed_ns) = tmp;</span>
<span class="p_add">+	tmp = div_u64(tmp, 100);</span>
<span class="p_add">+	if (!tmp)</span>
<span class="p_add">+		tmp = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	WRITE_ONCE(perf_sample_allowed_ns, tmp);</span>
 }
 
 static int perf_rotate_context(struct perf_cpu_context *cpuctx);
<span class="p_chunk">@@ -409,7 +412,13 @@</span> <span class="p_context"> int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,</span>
 	if (ret || !write)
 		return ret;
 
<span class="p_del">-	update_perf_cpu_limits();</span>
<span class="p_add">+	if (sysctl_perf_cpu_time_max_percent == 100) {</span>
<span class="p_add">+		printk(KERN_WARNING</span>
<span class="p_add">+		       &quot;perf: Dynamic interrupt throttling disabled, can hang your system!\n&quot;);</span>
<span class="p_add">+		WRITE_ONCE(perf_sample_allowed_ns, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		update_perf_cpu_limits();</span>
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -423,62 +432,68 @@</span> <span class="p_context"> int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,</span>
 #define NR_ACCUMULATED_SAMPLES 128
 static DEFINE_PER_CPU(u64, running_sample_length);
 
<span class="p_add">+static u64 __report_avg;</span>
<span class="p_add">+static u64 __report_allowed;</span>
<span class="p_add">+</span>
 static void perf_duration_warn(struct irq_work *w)
 {
<span class="p_del">-	u64 allowed_ns = ACCESS_ONCE(perf_sample_allowed_ns);</span>
<span class="p_del">-	u64 avg_local_sample_len;</span>
<span class="p_del">-	u64 local_samples_len;</span>
<span class="p_del">-</span>
<span class="p_del">-	local_samples_len = __this_cpu_read(running_sample_length);</span>
<span class="p_del">-	avg_local_sample_len = local_samples_len/NR_ACCUMULATED_SAMPLES;</span>
<span class="p_del">-</span>
 	printk_ratelimited(KERN_WARNING
<span class="p_del">-			&quot;perf interrupt took too long (%lld &gt; %lld), lowering &quot;</span>
<span class="p_del">-			&quot;kernel.perf_event_max_sample_rate to %d\n&quot;,</span>
<span class="p_del">-			avg_local_sample_len, allowed_ns &gt;&gt; 1,</span>
<span class="p_del">-			sysctl_perf_event_sample_rate);</span>
<span class="p_add">+		&quot;perf: interrupt took too long (%lld &gt; %lld), lowering &quot;</span>
<span class="p_add">+		&quot;kernel.perf_event_max_sample_rate to %d\n&quot;,</span>
<span class="p_add">+		__report_avg, __report_allowed,</span>
<span class="p_add">+		sysctl_perf_event_sample_rate);</span>
 }
 
 static DEFINE_IRQ_WORK(perf_duration_work, perf_duration_warn);
 
 void perf_sample_event_took(u64 sample_len_ns)
 {
<span class="p_del">-	u64 allowed_ns = ACCESS_ONCE(perf_sample_allowed_ns);</span>
<span class="p_del">-	u64 avg_local_sample_len;</span>
<span class="p_del">-	u64 local_samples_len;</span>
<span class="p_add">+	u64 max_len = READ_ONCE(perf_sample_allowed_ns);</span>
<span class="p_add">+	u64 running_len;</span>
<span class="p_add">+	u64 avg_len;</span>
<span class="p_add">+	u32 max;</span>
 
<span class="p_del">-	if (allowed_ns == 0)</span>
<span class="p_add">+	if (max_len == 0)</span>
 		return;
 
<span class="p_del">-	/* decay the counter by 1 average sample */</span>
<span class="p_del">-	local_samples_len = __this_cpu_read(running_sample_length);</span>
<span class="p_del">-	local_samples_len -= local_samples_len/NR_ACCUMULATED_SAMPLES;</span>
<span class="p_del">-	local_samples_len += sample_len_ns;</span>
<span class="p_del">-	__this_cpu_write(running_sample_length, local_samples_len);</span>
<span class="p_add">+	/* Decay the counter by 1 average sample. */</span>
<span class="p_add">+	running_len = __this_cpu_read(running_sample_length);</span>
<span class="p_add">+	running_len -= running_len/NR_ACCUMULATED_SAMPLES;</span>
<span class="p_add">+	running_len += sample_len_ns;</span>
<span class="p_add">+	__this_cpu_write(running_sample_length, running_len);</span>
 
 	/*
<span class="p_del">-	 * note: this will be biased artifically low until we have</span>
<span class="p_del">-	 * seen NR_ACCUMULATED_SAMPLES.  Doing it this way keeps us</span>
<span class="p_add">+	 * Note: this will be biased artifically low until we have</span>
<span class="p_add">+	 * seen NR_ACCUMULATED_SAMPLES. Doing it this way keeps us</span>
 	 * from having to maintain a count.
 	 */
<span class="p_del">-	avg_local_sample_len = local_samples_len/NR_ACCUMULATED_SAMPLES;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (avg_local_sample_len &lt;= allowed_ns)</span>
<span class="p_add">+	avg_len = running_len/NR_ACCUMULATED_SAMPLES;</span>
<span class="p_add">+	if (avg_len &lt;= max_len)</span>
 		return;
 
<span class="p_del">-	if (max_samples_per_tick &lt;= 1)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	__report_avg = avg_len;</span>
<span class="p_add">+	__report_allowed = max_len;</span>
 
<span class="p_del">-	max_samples_per_tick = DIV_ROUND_UP(max_samples_per_tick, 2);</span>
<span class="p_del">-	sysctl_perf_event_sample_rate = max_samples_per_tick * HZ;</span>
<span class="p_del">-	perf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Compute a throttle threshold 25% below the current duration.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	avg_len += avg_len / 4;</span>
<span class="p_add">+	max = (TICK_NSEC / 100) * sysctl_perf_cpu_time_max_percent;</span>
<span class="p_add">+	if (avg_len &lt; max)</span>
<span class="p_add">+		max /= (u32)avg_len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		max = 1;</span>
 
<span class="p_del">-	update_perf_cpu_limits();</span>
<span class="p_add">+	WRITE_ONCE(perf_sample_allowed_ns, avg_len);</span>
<span class="p_add">+	WRITE_ONCE(max_samples_per_tick, max);</span>
<span class="p_add">+</span>
<span class="p_add">+	sysctl_perf_event_sample_rate = max * HZ;</span>
<span class="p_add">+	perf_sample_period_ns = NSEC_PER_SEC / sysctl_perf_event_sample_rate;</span>
 
 	if (!irq_work_queue(&amp;perf_duration_work)) {
<span class="p_del">-		early_printk(&quot;perf interrupt took too long (%lld &gt; %lld), lowering &quot;</span>
<span class="p_add">+		early_printk(&quot;perf: interrupt took too long (%lld &gt; %lld), lowering &quot;</span>
 			     &quot;kernel.perf_event_max_sample_rate to %d\n&quot;,
<span class="p_del">-			     avg_local_sample_len, allowed_ns &gt;&gt; 1,</span>
<span class="p_add">+			     __report_avg, __report_allowed,</span>
 			     sysctl_perf_event_sample_rate);
 	}
 }
<span class="p_chunk">@@ -4210,6 +4225,14 @@</span> <span class="p_context"> static void __perf_event_period(struct perf_event *event,</span>
 	active = (event-&gt;state == PERF_EVENT_STATE_ACTIVE);
 	if (active) {
 		perf_pmu_disable(ctx-&gt;pmu);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We could be throttled; unthrottle now to avoid the tick</span>
<span class="p_add">+		 * trying to unthrottle while we already re-started the event.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (event-&gt;hw.interrupts == MAX_INTERRUPTS) {</span>
<span class="p_add">+			event-&gt;hw.interrupts = 0;</span>
<span class="p_add">+			perf_log_throttle(event, 1);</span>
<span class="p_add">+		}</span>
 		event-&gt;pmu-&gt;stop(event, PERF_EF_UPDATE);
 	}
 
<span class="p_chunk">@@ -9426,10 +9449,29 @@</span> <span class="p_context"> perf_cpu_notify(struct notifier_block *self, unsigned long action, void *hcpu)</span>
 	switch (action &amp; ~CPU_TASKS_FROZEN) {
 
 	case CPU_UP_PREPARE:
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This must be done before the CPU comes alive, because the</span>
<span class="p_add">+		 * moment we can run tasks we can encounter (software) events.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Specifically, someone can have inherited events on kthreadd</span>
<span class="p_add">+		 * or a pre-existing worker thread that gets re-bound.</span>
<span class="p_add">+		 */</span>
 		perf_event_init_cpu(cpu);
 		break;
 
 	case CPU_DOWN_PREPARE:
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This must be done before the CPU dies because after that an</span>
<span class="p_add">+		 * active event might want to IPI the CPU and that&#39;ll not work</span>
<span class="p_add">+		 * so great for dead CPUs.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * XXX smp_call_function_single() return -ENXIO without a warn</span>
<span class="p_add">+		 * so we could possibly deal with this.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This is safe against new events arriving because</span>
<span class="p_add">+		 * sys_perf_event_open() serializes against hotplug using</span>
<span class="p_add">+		 * get_online_cpus().</span>
<span class="p_add">+		 */</span>
 		perf_event_exit_cpu(cpu);
 		break;
 	default:
<span class="p_header">diff --git a/kernel/events/ring_buffer.c b/kernel/events/ring_buffer.c</span>
<span class="p_header">index 1faad2cfdb9e..c61f0cbd308b 100644</span>
<span class="p_header">--- a/kernel/events/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/events/ring_buffer.c</span>
<span class="p_chunk">@@ -746,8 +746,10 @@</span> <span class="p_context"> struct ring_buffer *rb_alloc(int nr_pages, long watermark, int cpu, int flags)</span>
 
 	rb-&gt;user_page = all_buf;
 	rb-&gt;data_pages[0] = all_buf + PAGE_SIZE;
<span class="p_del">-	rb-&gt;page_order = ilog2(nr_pages);</span>
<span class="p_del">-	rb-&gt;nr_pages = !!nr_pages;</span>
<span class="p_add">+	if (nr_pages) {</span>
<span class="p_add">+		rb-&gt;nr_pages = 1;</span>
<span class="p_add">+		rb-&gt;page_order = ilog2(nr_pages);</span>
<span class="p_add">+	}</span>
 
 	ring_buffer_init(rb, watermark, flags);
 
<span class="p_header">diff --git a/tools/include/linux/stringify.h b/tools/include/linux/stringify.h</span>
new file mode 100644
<span class="p_header">index 000000000000..841cec8ed525</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/include/linux/stringify.h</span>
<span class="p_chunk">@@ -0,0 +1,12 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __LINUX_STRINGIFY_H</span>
<span class="p_add">+#define __LINUX_STRINGIFY_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* Indirect stringification.  Doing two levels allows the parameter to be a</span>
<span class="p_add">+ * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)</span>
<span class="p_add">+ * converts to &quot;bar&quot;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define __stringify_1(x...)	#x</span>
<span class="p_add">+#define __stringify(x...)	__stringify_1(x)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* !__LINUX_STRINGIFY_H */</span>
<span class="p_header">diff --git a/tools/lib/api/Makefile b/tools/lib/api/Makefile</span>
<span class="p_header">index bbc82c614bee..316f308a63ea 100644</span>
<span class="p_header">--- a/tools/lib/api/Makefile</span>
<span class="p_header">+++ b/tools/lib/api/Makefile</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 include ../../scripts/Makefile.include
<span class="p_del">-include ../../perf/config/utilities.mak		# QUIET_CLEAN</span>
<span class="p_add">+include ../../scripts/utilities.mak		# QUIET_CLEAN</span>
 
 ifeq ($(srctree),)
 srctree := $(patsubst %/,%,$(dir $(shell pwd)))
<span class="p_header">diff --git a/tools/lib/subcmd/Makefile b/tools/lib/subcmd/Makefile</span>
<span class="p_header">index 629cf8c14e68..25b3f69f4364 100644</span>
<span class="p_header">--- a/tools/lib/subcmd/Makefile</span>
<span class="p_header">+++ b/tools/lib/subcmd/Makefile</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 include ../../scripts/Makefile.include
<span class="p_del">-include ../../perf/config/utilities.mak		# QUIET_CLEAN</span>
<span class="p_add">+include ../../scripts/utilities.mak		# QUIET_CLEAN</span>
 
 ifeq ($(srctree),)
 srctree := $(patsubst %/,%,$(dir $(shell pwd)))
<span class="p_header">diff --git a/tools/lib/traceevent/event-parse.c b/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">index 190cc886ab91..a8b6357d1ffe 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/event-parse.c</span>
<span class="p_chunk">@@ -5427,10 +5427,8 @@</span> <span class="p_context"> void pevent_print_event_time(struct pevent *pevent, struct trace_seq *s,</span>
 	}
 
 	if (pevent-&gt;latency_format) {
<span class="p_del">-		trace_seq_printf(s, &quot; %3d&quot;, record-&gt;cpu);</span>
 		pevent_data_lat_fmt(pevent, s, record);
<span class="p_del">-	} else</span>
<span class="p_del">-		trace_seq_printf(s, &quot; [%03d]&quot;, record-&gt;cpu);</span>
<span class="p_add">+	}</span>
 
 	if (use_usec_format) {
 		if (pevent-&gt;flags &amp; PEVENT_NSEC_OUTPUT) {
<span class="p_header">diff --git a/tools/perf/Documentation/Makefile b/tools/perf/Documentation/Makefile</span>
<span class="p_header">index 3ba1c0b09908..098cfb9ca8f0 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/Makefile</span>
<span class="p_header">+++ b/tools/perf/Documentation/Makefile</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 include ../../scripts/Makefile.include
<span class="p_del">-include ../config/utilities.mak</span>
<span class="p_add">+include ../../scripts/utilities.mak</span>
 
 MAN1_TXT= \
 	$(filter-out $(addsuffix .txt, $(ARTICLES) $(SP_ARTICLES)), \
<span class="p_header">diff --git a/tools/perf/Documentation/perf-list.txt b/tools/perf/Documentation/perf-list.txt</span>
<span class="p_header">index 79483f40e991..ec723d0a5bb3 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/perf-list.txt</span>
<span class="p_header">+++ b/tools/perf/Documentation/perf-list.txt</span>
<span class="p_chunk">@@ -40,10 +40,12 @@</span> <span class="p_context"> The &#39;p&#39; modifier can be used for specifying how precise the instruction</span>
  0 - SAMPLE_IP can have arbitrary skid
  1 - SAMPLE_IP must have constant skid
  2 - SAMPLE_IP requested to have 0 skid
<span class="p_del">- 3 - SAMPLE_IP must have 0 skid</span>
<span class="p_add">+ 3 - SAMPLE_IP must have 0 skid, or uses randomization to avoid</span>
<span class="p_add">+     sample shadowing effects.</span>
 
 For Intel systems precise event sampling is implemented with PEBS
<span class="p_del">-which supports up to precise-level 2.</span>
<span class="p_add">+which supports up to precise-level 2, and precise level 3 for</span>
<span class="p_add">+some special cases</span>
 
 On AMD systems it is implemented using IBS (up to precise-level 2).
 The precise modifier works with event types 0x76 (cpu-cycles, CPU
<span class="p_header">diff --git a/tools/perf/Makefile.perf b/tools/perf/Makefile.perf</span>
<span class="p_header">index 4a4fad4182f5..000ea210389d 100644</span>
<span class="p_header">--- a/tools/perf/Makefile.perf</span>
<span class="p_header">+++ b/tools/perf/Makefile.perf</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"> include ../scripts/Makefile.include</span>
 # The default target of this Makefile is...
 all:
 
<span class="p_del">-include config/utilities.mak</span>
<span class="p_add">+include ../scripts/utilities.mak</span>
 
 # Define V to have a more verbose compile.
 #
<span class="p_header">diff --git a/tools/perf/arch/powerpc/util/header.c b/tools/perf/arch/powerpc/util/header.c</span>
<span class="p_header">index 6c1b8a75db09..6138bdef6e63 100644</span>
<span class="p_header">--- a/tools/perf/arch/powerpc/util/header.c</span>
<span class="p_header">+++ b/tools/perf/arch/powerpc/util/header.c</span>
<span class="p_chunk">@@ -3,9 +3,7 @@</span> <span class="p_context"></span>
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
<span class="p_del">-</span>
<span class="p_del">-#include &quot;../../util/header.h&quot;</span>
<span class="p_del">-#include &quot;../../util/util.h&quot;</span>
<span class="p_add">+#include &lt;linux/stringify.h&gt;</span>
 
 #define mfspr(rn)       ({unsigned long rval; \
 			 asm volatile(&quot;mfspr %0,&quot; __stringify(rn) \
<span class="p_header">diff --git a/tools/perf/bench/bench.h b/tools/perf/bench/bench.h</span>
<span class="p_header">index a50df86f2b9b..579a592990dd 100644</span>
<span class="p_header">--- a/tools/perf/bench/bench.h</span>
<span class="p_header">+++ b/tools/perf/bench/bench.h</span>
<span class="p_chunk">@@ -25,19 +25,17 @@</span> <span class="p_context"></span>
 # endif
 #endif
 
<span class="p_del">-extern int bench_numa(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_sched_messaging(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_sched_pipe(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_mem_memcpy(int argc, const char **argv,</span>
<span class="p_del">-			    const char *prefix __maybe_unused);</span>
<span class="p_del">-extern int bench_mem_memset(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_futex_hash(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_futex_wake(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int bench_futex_wake_parallel(int argc, const char **argv,</span>
<span class="p_del">-				     const char *prefix);</span>
<span class="p_del">-extern int bench_futex_requeue(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_numa(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_sched_messaging(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_sched_pipe(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_mem_memcpy(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_mem_memset(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_futex_hash(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_futex_wake(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_futex_wake_parallel(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_futex_requeue(int argc, const char **argv, const char *prefix);</span>
 /* pi futexes */
<span class="p_del">-extern int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int bench_futex_lock_pi(int argc, const char **argv, const char *prefix);</span>
 
 #define BENCH_FORMAT_DEFAULT_STR	&quot;default&quot;
 #define BENCH_FORMAT_DEFAULT		0
<span class="p_header">diff --git a/tools/perf/bench/mem-memcpy-arch.h b/tools/perf/bench/mem-memcpy-arch.h</span>
<span class="p_header">index 57b4ed871459..5aad2a9408b0 100644</span>
<span class="p_header">--- a/tools/perf/bench/mem-memcpy-arch.h</span>
<span class="p_header">+++ b/tools/perf/bench/mem-memcpy-arch.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 #ifdef HAVE_ARCH_X86_64_SUPPORT
 
 #define MEMCPY_FN(fn, name, desc)		\
<span class="p_del">-	extern void *fn(void *, const void *, size_t);</span>
<span class="p_add">+	void *fn(void *, const void *, size_t);</span>
 
 #include &quot;mem-memcpy-x86-64-asm-def.h&quot;
 
<span class="p_header">diff --git a/tools/perf/bench/mem-memset-arch.h b/tools/perf/bench/mem-memset-arch.h</span>
<span class="p_header">index 633800cb0dcb..0d15786d9ae3 100644</span>
<span class="p_header">--- a/tools/perf/bench/mem-memset-arch.h</span>
<span class="p_header">+++ b/tools/perf/bench/mem-memset-arch.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 #ifdef HAVE_ARCH_X86_64_SUPPORT
 
 #define MEMSET_FN(fn, name, desc)		\
<span class="p_del">-	extern void *fn(void *, int, size_t);</span>
<span class="p_add">+	void *fn(void *, int, size_t);</span>
 
 #include &quot;mem-memset-x86-64-asm-def.h&quot;
 
<span class="p_header">diff --git a/tools/perf/bench/numa.c b/tools/perf/bench/numa.c</span>
<span class="p_header">index 5049d6357a46..7500d959d7eb 100644</span>
<span class="p_header">--- a/tools/perf/bench/numa.c</span>
<span class="p_header">+++ b/tools/perf/bench/numa.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static void bind_to_memnode(int node)</span>
 	if (node == -1)
 		return;
 
<span class="p_del">-	BUG_ON(g-&gt;p.nr_nodes &gt; (int)sizeof(nodemask));</span>
<span class="p_add">+	BUG_ON(g-&gt;p.nr_nodes &gt; (int)sizeof(nodemask)*8);</span>
 	nodemask = 1L &lt;&lt; node;
 
 	ret = set_mempolicy(MPOL_BIND, &amp;nodemask, sizeof(nodemask)*8);
<span class="p_header">diff --git a/tools/perf/builtin-annotate.c b/tools/perf/builtin-annotate.c</span>
<span class="p_header">index cfe366375c4b..814158393656 100644</span>
<span class="p_header">--- a/tools/perf/builtin-annotate.c</span>
<span class="p_header">+++ b/tools/perf/builtin-annotate.c</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> static int process_sample_event(struct perf_tool *tool,</span>
 	struct addr_location al;
 	int ret = 0;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		pr_warning(&quot;problem processing %d event, skipping it.\n&quot;,
 			   event-&gt;header.type);
 		return -1;
<span class="p_header">diff --git a/tools/perf/builtin-diff.c b/tools/perf/builtin-diff.c</span>
<span class="p_header">index 4d72359fd15a..8053a8ceefda 100644</span>
<span class="p_header">--- a/tools/perf/builtin-diff.c</span>
<span class="p_header">+++ b/tools/perf/builtin-diff.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> static int diff__process_sample_event(struct perf_tool *tool __maybe_unused,</span>
 	struct hists *hists = evsel__hists(evsel);
 	int ret = -1;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		pr_warning(&quot;problem processing %d event, skipping it.\n&quot;,
 			   event-&gt;header.type);
 		return -1;
<span class="p_header">diff --git a/tools/perf/builtin-help.c b/tools/perf/builtin-help.c</span>
<span class="p_header">index 49d55e21b1b0..bc1de9b8fd67 100644</span>
<span class="p_header">--- a/tools/perf/builtin-help.c</span>
<span class="p_header">+++ b/tools/perf/builtin-help.c</span>
<span class="p_chunk">@@ -106,12 +106,14 @@</span> <span class="p_context"> static void exec_woman_emacs(const char *path, const char *page)</span>
 
 	if (!check_emacsclient_version()) {
 		/* This works only with emacsclient version &gt;= 22. */
<span class="p_del">-		struct strbuf man_page = STRBUF_INIT;</span>
<span class="p_add">+		char *man_page;</span>
 
 		if (!path)
 			path = &quot;emacsclient&quot;;
<span class="p_del">-		strbuf_addf(&amp;man_page, &quot;(woman \&quot;%s\&quot;)&quot;, page);</span>
<span class="p_del">-		execlp(path, &quot;emacsclient&quot;, &quot;-e&quot;, man_page.buf, NULL);</span>
<span class="p_add">+		if (asprintf(&amp;man_page, &quot;(woman \&quot;%s\&quot;)&quot;, page) &gt; 0) {</span>
<span class="p_add">+			execlp(path, &quot;emacsclient&quot;, &quot;-e&quot;, man_page, NULL);</span>
<span class="p_add">+			free(man_page);</span>
<span class="p_add">+		}</span>
 		warning(&quot;failed to exec &#39;%s&#39;: %s&quot;, path,
 			strerror_r(errno, sbuf, sizeof(sbuf)));
 	}
<span class="p_chunk">@@ -122,7 +124,7 @@</span> <span class="p_context"> static void exec_man_konqueror(const char *path, const char *page)</span>
 	const char *display = getenv(&quot;DISPLAY&quot;);
 
 	if (display &amp;&amp; *display) {
<span class="p_del">-		struct strbuf man_page = STRBUF_INIT;</span>
<span class="p_add">+		char *man_page;</span>
 		const char *filename = &quot;kfmclient&quot;;
 		char sbuf[STRERR_BUFSIZE];
 
<span class="p_chunk">@@ -141,8 +143,10 @@</span> <span class="p_context"> static void exec_man_konqueror(const char *path, const char *page)</span>
 				filename = file;
 		} else
 			path = &quot;kfmclient&quot;;
<span class="p_del">-		strbuf_addf(&amp;man_page, &quot;man:%s(1)&quot;, page);</span>
<span class="p_del">-		execlp(path, filename, &quot;newTab&quot;, man_page.buf, NULL);</span>
<span class="p_add">+		if (asprintf(&amp;man_page, &quot;man:%s(1)&quot;, page) &gt; 0) {</span>
<span class="p_add">+			execlp(path, filename, &quot;newTab&quot;, man_page, NULL);</span>
<span class="p_add">+			free(man_page);</span>
<span class="p_add">+		}</span>
 		warning(&quot;failed to exec &#39;%s&#39;: %s&quot;, path,
 			strerror_r(errno, sbuf, sizeof(sbuf)));
 	}
<span class="p_chunk">@@ -161,11 +165,13 @@</span> <span class="p_context"> static void exec_man_man(const char *path, const char *page)</span>
 
 static void exec_man_cmd(const char *cmd, const char *page)
 {
<span class="p_del">-	struct strbuf shell_cmd = STRBUF_INIT;</span>
 	char sbuf[STRERR_BUFSIZE];
<span class="p_add">+	char *shell_cmd;</span>
 
<span class="p_del">-	strbuf_addf(&amp;shell_cmd, &quot;%s %s&quot;, cmd, page);</span>
<span class="p_del">-	execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, shell_cmd.buf, NULL);</span>
<span class="p_add">+	if (asprintf(&amp;shell_cmd, &quot;%s %s&quot;, cmd, page) &gt; 0) {</span>
<span class="p_add">+		execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, shell_cmd, NULL);</span>
<span class="p_add">+		free(shell_cmd);</span>
<span class="p_add">+	}</span>
 	warning(&quot;failed to exec &#39;%s&#39;: %s&quot;, cmd,
 		strerror_r(errno, sbuf, sizeof(sbuf)));
 }
<span class="p_chunk">@@ -299,43 +305,33 @@</span> <span class="p_context"> static int is_perf_command(const char *s)</span>
 		is_in_cmdlist(&amp;other_cmds, s);
 }
 
<span class="p_del">-static const char *prepend(const char *prefix, const char *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t pre_len = strlen(prefix);</span>
<span class="p_del">-	size_t cmd_len = strlen(cmd);</span>
<span class="p_del">-	char *p = malloc(pre_len + cmd_len + 1);</span>
<span class="p_del">-	memcpy(p, prefix, pre_len);</span>
<span class="p_del">-	strcpy(p + pre_len, cmd);</span>
<span class="p_del">-	return p;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const char *cmd_to_page(const char *perf_cmd)
 {
<span class="p_add">+	char *s;</span>
<span class="p_add">+</span>
 	if (!perf_cmd)
 		return &quot;perf&quot;;
 	else if (!prefixcmp(perf_cmd, &quot;perf&quot;))
 		return perf_cmd;
<span class="p_del">-	else</span>
<span class="p_del">-		return prepend(&quot;perf-&quot;, perf_cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return asprintf(&amp;s, &quot;perf-%s&quot;, perf_cmd) &lt; 0 ? NULL : s;</span>
 }
 
 static void setup_man_path(void)
 {
<span class="p_del">-	struct strbuf new_path = STRBUF_INIT;</span>
<span class="p_add">+	char *new_path;</span>
 	const char *old_path = getenv(&quot;MANPATH&quot;);
 
 	/* We should always put &#39;:&#39; after our path. If there is no
 	 * old_path, the &#39;:&#39; at the end will let &#39;man&#39; to try
 	 * system-wide paths after ours to find the manual page. If
 	 * there is old_path, we need &#39;:&#39; as delimiter. */
<span class="p_del">-	strbuf_addstr(&amp;new_path, system_path(PERF_MAN_PATH));</span>
<span class="p_del">-	strbuf_addch(&amp;new_path, &#39;:&#39;);</span>
<span class="p_del">-	if (old_path)</span>
<span class="p_del">-		strbuf_addstr(&amp;new_path, old_path);</span>
<span class="p_del">-</span>
<span class="p_del">-	setenv(&quot;MANPATH&quot;, new_path.buf, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	strbuf_release(&amp;new_path);</span>
<span class="p_add">+	if (asprintf(&amp;new_path, &quot;%s:%s&quot;, system_path(PERF_MAN_PATH), old_path ?: &quot;&quot;) &gt; 0) {</span>
<span class="p_add">+		setenv(&quot;MANPATH&quot;, new_path, 1);</span>
<span class="p_add">+		free(new_path);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		error(&quot;Unable to setup man path&quot;);</span>
<span class="p_add">+	}</span>
 }
 
 static void exec_viewer(const char *name, const char *page)
<span class="p_chunk">@@ -380,7 +376,7 @@</span> <span class="p_context"> static int show_info_page(const char *perf_cmd)</span>
 	return -1;
 }
 
<span class="p_del">-static int get_html_page_path(struct strbuf *page_path, const char *page)</span>
<span class="p_add">+static int get_html_page_path(char **page_path, const char *page)</span>
 {
 	struct stat st;
 	const char *html_path = system_path(PERF_HTML_PATH);
<span class="p_chunk">@@ -392,10 +388,7 @@</span> <span class="p_context"> static int get_html_page_path(struct strbuf *page_path, const char *page)</span>
 		return -1;
 	}
 
<span class="p_del">-	strbuf_init(page_path, 0);</span>
<span class="p_del">-	strbuf_addf(page_path, &quot;%s/%s.html&quot;, html_path, page);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return asprintf(page_path, &quot;%s/%s.html&quot;, html_path, page);</span>
 }
 
 /*
<span class="p_chunk">@@ -413,12 +406,12 @@</span> <span class="p_context"> static void open_html(const char *path)</span>
 static int show_html_page(const char *perf_cmd)
 {
 	const char *page = cmd_to_page(perf_cmd);
<span class="p_del">-	struct strbuf page_path; /* it leaks but we exec bellow */</span>
<span class="p_add">+	char *page_path; /* it leaks but we exec bellow */</span>
 
<span class="p_del">-	if (get_html_page_path(&amp;page_path, page) != 0)</span>
<span class="p_add">+	if (get_html_page_path(&amp;page_path, page) &lt; 0)</span>
 		return -1;
 
<span class="p_del">-	open_html(page_path.buf);</span>
<span class="p_add">+	open_html(page_path);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/tools/perf/builtin-inject.c b/tools/perf/builtin-inject.c</span>
<span class="p_header">index 7fa68663ed72..d1a2d104f2bc 100644</span>
<span class="p_header">--- a/tools/perf/builtin-inject.c</span>
<span class="p_header">+++ b/tools/perf/builtin-inject.c</span>
<span class="p_chunk">@@ -131,8 +131,7 @@</span> <span class="p_context"> static int copy_bytes(struct perf_inject *inject, int fd, off_t size)</span>
 
 static s64 perf_event__repipe_auxtrace(struct perf_tool *tool,
 				       union perf_event *event,
<span class="p_del">-				       struct perf_session *session</span>
<span class="p_del">-				       __maybe_unused)</span>
<span class="p_add">+				       struct perf_session *session)</span>
 {
 	struct perf_inject *inject = container_of(tool, struct perf_inject,
 						  tool);
<span class="p_chunk">@@ -417,9 +416,6 @@</span> <span class="p_context"> static int perf_event__inject_buildid(struct perf_tool *tool,</span>
 {
 	struct addr_location al;
 	struct thread *thread;
<span class="p_del">-	u8 cpumode;</span>
<span class="p_del">-</span>
<span class="p_del">-	cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 
 	thread = machine__findnew_thread(machine, sample-&gt;pid, sample-&gt;tid);
 	if (thread == NULL) {
<span class="p_chunk">@@ -428,7 +424,7 @@</span> <span class="p_context"> static int perf_event__inject_buildid(struct perf_tool *tool,</span>
 		goto repipe;
 	}
 
<span class="p_del">-	thread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample-&gt;ip, &amp;al);</span>
<span class="p_add">+	thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, sample-&gt;ip, &amp;al);</span>
 
 	if (al.map != NULL) {
 		if (!al.map-&gt;dso-&gt;hit) {
<span class="p_header">diff --git a/tools/perf/builtin-mem.c b/tools/perf/builtin-mem.c</span>
<span class="p_header">index 88aeac9aa1da..85db3be4b3cb 100644</span>
<span class="p_header">--- a/tools/perf/builtin-mem.c</span>
<span class="p_header">+++ b/tools/perf/builtin-mem.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> dump_raw_samples(struct perf_tool *tool,</span>
 	struct addr_location al;
 	const char *fmt;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		fprintf(stderr, &quot;problem processing %d event, skipping it.\n&quot;,
 				event-&gt;header.type);
 		return -1;
<span class="p_header">diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c</span>
<span class="p_header">index 7eea49f9ed46..160ea23b45aa 100644</span>
<span class="p_header">--- a/tools/perf/builtin-report.c</span>
<span class="p_header">+++ b/tools/perf/builtin-report.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 
 #include &lt;dlfcn.h&gt;
 #include &lt;linux/bitmap.h&gt;
<span class="p_add">+#include &lt;linux/stringify.h&gt;</span>
 
 struct report {
 	struct perf_tool	tool;
<span class="p_chunk">@@ -154,7 +155,7 @@</span> <span class="p_context"> static int process_sample_event(struct perf_tool *tool,</span>
 	};
 	int ret = 0;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		pr_debug(&quot;problem processing %d event, skipping it.\n&quot;,
 			 event-&gt;header.type);
 		return -1;
<span class="p_header">diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c</span>
<span class="p_header">index 57f9a7e7f7d3..3770c3dffe5e 100644</span>
<span class="p_header">--- a/tools/perf/builtin-script.c</span>
<span class="p_header">+++ b/tools/perf/builtin-script.c</span>
<span class="p_chunk">@@ -405,9 +405,7 @@</span> <span class="p_context"> static int perf_session__check_output_opt(struct perf_session *session)</span>
 	return 0;
 }
 
<span class="p_del">-static void print_sample_iregs(union perf_event *event __maybe_unused,</span>
<span class="p_del">-			  struct perf_sample *sample,</span>
<span class="p_del">-			  struct thread *thread __maybe_unused,</span>
<span class="p_add">+static void print_sample_iregs(struct perf_sample *sample,</span>
 			  struct perf_event_attr *attr)
 {
 	struct regs_dump *regs = &amp;sample-&gt;intr_regs;
<span class="p_chunk">@@ -476,10 +474,7 @@</span> <span class="p_context"> mispred_str(struct branch_entry *br)</span>
 	return br-&gt;flags.predicted ? &#39;P&#39; : &#39;M&#39;;
 }
 
<span class="p_del">-static void print_sample_brstack(union perf_event *event __maybe_unused,</span>
<span class="p_del">-			  struct perf_sample *sample,</span>
<span class="p_del">-			  struct thread *thread __maybe_unused,</span>
<span class="p_del">-			  struct perf_event_attr *attr __maybe_unused)</span>
<span class="p_add">+static void print_sample_brstack(struct perf_sample *sample)</span>
 {
 	struct branch_stack *br = sample-&gt;branch_stack;
 	u64 i;
<span class="p_chunk">@@ -498,14 +493,11 @@</span> <span class="p_context"> static void print_sample_brstack(union perf_event *event __maybe_unused,</span>
 	}
 }
 
<span class="p_del">-static void print_sample_brstacksym(union perf_event *event __maybe_unused,</span>
<span class="p_del">-			  struct perf_sample *sample,</span>
<span class="p_del">-			  struct thread *thread __maybe_unused,</span>
<span class="p_del">-			  struct perf_event_attr *attr __maybe_unused)</span>
<span class="p_add">+static void print_sample_brstacksym(struct perf_sample *sample,</span>
<span class="p_add">+				    struct thread *thread)</span>
 {
 	struct branch_stack *br = sample-&gt;branch_stack;
 	struct addr_location alf, alt;
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	u64 i, from, to;
 
 	if (!(br &amp;&amp; br-&gt;nr))
<span class="p_chunk">@@ -518,11 +510,11 @@</span> <span class="p_context"> static void print_sample_brstacksym(union perf_event *event __maybe_unused,</span>
 		from = br-&gt;entries[i].from;
 		to   = br-&gt;entries[i].to;
 
<span class="p_del">-		thread__find_addr_map(thread, cpumode, MAP__FUNCTION, from, &amp;alf);</span>
<span class="p_add">+		thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, from, &amp;alf);</span>
 		if (alf.map)
 			alf.sym = map__find_symbol(alf.map, alf.addr, NULL);
 
<span class="p_del">-		thread__find_addr_map(thread, cpumode, MAP__FUNCTION, to, &amp;alt);</span>
<span class="p_add">+		thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, to, &amp;alt);</span>
 		if (alt.map)
 			alt.sym = map__find_symbol(alt.map, alt.addr, NULL);
 
<span class="p_chunk">@@ -538,8 +530,7 @@</span> <span class="p_context"> static void print_sample_brstacksym(union perf_event *event __maybe_unused,</span>
 }
 
 
<span class="p_del">-static void print_sample_addr(union perf_event *event,</span>
<span class="p_del">-			  struct perf_sample *sample,</span>
<span class="p_add">+static void print_sample_addr(struct perf_sample *sample,</span>
 			  struct thread *thread,
 			  struct perf_event_attr *attr)
 {
<span class="p_chunk">@@ -550,7 +541,7 @@</span> <span class="p_context"> static void print_sample_addr(union perf_event *event,</span>
 	if (!sample_addr_correlates_sym(attr))
 		return;
 
<span class="p_del">-	perf_event__preprocess_sample_addr(event, sample, thread, &amp;al);</span>
<span class="p_add">+	thread__resolve(thread, &amp;al, sample);</span>
 
 	if (PRINT_FIELD(SYM)) {
 		printf(&quot; &quot;);
<span class="p_chunk">@@ -567,8 +558,7 @@</span> <span class="p_context"> static void print_sample_addr(union perf_event *event,</span>
 	}
 }
 
<span class="p_del">-static void print_sample_bts(union perf_event *event,</span>
<span class="p_del">-			     struct perf_sample *sample,</span>
<span class="p_add">+static void print_sample_bts(struct perf_sample *sample,</span>
 			     struct perf_evsel *evsel,
 			     struct thread *thread,
 			     struct addr_location *al)
<span class="p_chunk">@@ -598,7 +588,7 @@</span> <span class="p_context"> static void print_sample_bts(union perf_event *event,</span>
 	    ((evsel-&gt;attr.sample_type &amp; PERF_SAMPLE_ADDR) &amp;&amp;
 	     !output[attr-&gt;type].user_set)) {
 		printf(&quot; =&gt; &quot;);
<span class="p_del">-		print_sample_addr(event, sample, thread, attr);</span>
<span class="p_add">+		print_sample_addr(sample, thread, attr);</span>
 	}
 
 	if (print_srcline_last)
<span class="p_chunk">@@ -747,7 +737,7 @@</span> <span class="p_context"> static size_t data_src__printf(u64 data_src)</span>
 	return printf(&quot;%-*s&quot;, maxlen, out);
 }
 
<span class="p_del">-static void process_event(struct perf_script *script, union perf_event *event,</span>
<span class="p_add">+static void process_event(struct perf_script *script,</span>
 			  struct perf_sample *sample, struct perf_evsel *evsel,
 			  struct addr_location *al)
 {
<span class="p_chunk">@@ -776,7 +766,7 @@</span> <span class="p_context"> static void process_event(struct perf_script *script, union perf_event *event,</span>
 		print_sample_flags(sample-&gt;flags);
 
 	if (is_bts_event(attr)) {
<span class="p_del">-		print_sample_bts(event, sample, evsel, thread, al);</span>
<span class="p_add">+		print_sample_bts(sample, evsel, thread, al);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -784,7 +774,7 @@</span> <span class="p_context"> static void process_event(struct perf_script *script, union perf_event *event,</span>
 		event_format__print(evsel-&gt;tp_format, sample-&gt;cpu,
 				    sample-&gt;raw_data, sample-&gt;raw_size);
 	if (PRINT_FIELD(ADDR))
<span class="p_del">-		print_sample_addr(event, sample, thread, attr);</span>
<span class="p_add">+		print_sample_addr(sample, thread, attr);</span>
 
 	if (PRINT_FIELD(DATA_SRC))
 		data_src__printf(sample-&gt;data_src);
<span class="p_chunk">@@ -804,12 +794,12 @@</span> <span class="p_context"> static void process_event(struct perf_script *script, union perf_event *event,</span>
 	}
 
 	if (PRINT_FIELD(IREGS))
<span class="p_del">-		print_sample_iregs(event, sample, thread, attr);</span>
<span class="p_add">+		print_sample_iregs(sample, attr);</span>
 
 	if (PRINT_FIELD(BRSTACK))
<span class="p_del">-		print_sample_brstack(event, sample, thread, attr);</span>
<span class="p_add">+		print_sample_brstack(sample);</span>
 	else if (PRINT_FIELD(BRSTACKSYM))
<span class="p_del">-		print_sample_brstacksym(event, sample, thread, attr);</span>
<span class="p_add">+		print_sample_brstacksym(sample, thread);</span>
 
 	if (perf_evsel__is_bpf_output(evsel) &amp;&amp; PRINT_FIELD(BPF_OUTPUT))
 		print_sample_bpf_output(sample);
<span class="p_chunk">@@ -905,7 +895,7 @@</span> <span class="p_context"> static int process_sample_event(struct perf_tool *tool,</span>
 		return 0;
 	}
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		pr_err(&quot;problem processing %d event, skipping it.\n&quot;,
 		       event-&gt;header.type);
 		return -1;
<span class="p_chunk">@@ -920,7 +910,7 @@</span> <span class="p_context"> static int process_sample_event(struct perf_tool *tool,</span>
 	if (scripting_ops)
 		scripting_ops-&gt;process_event(event, sample, evsel, &amp;al);
 	else
<span class="p_del">-		process_event(scr, event, sample, evsel, &amp;al);</span>
<span class="p_add">+		process_event(scr, sample, evsel, &amp;al);</span>
 
 out_put:
 	addr_location__put(&amp;al);
<span class="p_header">diff --git a/tools/perf/builtin-timechart.c b/tools/perf/builtin-timechart.c</span>
<span class="p_header">index bd7a7757176f..40cc9bb3506c 100644</span>
<span class="p_header">--- a/tools/perf/builtin-timechart.c</span>
<span class="p_header">+++ b/tools/perf/builtin-timechart.c</span>
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> static const char *cat_backtrace(union perf_event *event,</span>
 	if (!chain)
 		goto exit;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0) {</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0) {</span>
 		fprintf(stderr, &quot;problem processing %d event, skipping it.\n&quot;,
 			event-&gt;header.type);
 		goto exit;
<span class="p_header">diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c</span>
<span class="p_header">index 94af190f6843..833214979c4f 100644</span>
<span class="p_header">--- a/tools/perf/builtin-top.c</span>
<span class="p_header">+++ b/tools/perf/builtin-top.c</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"></span>
 #include &lt;sys/utsname.h&gt;
 #include &lt;sys/mman.h&gt;
 
<span class="p_add">+#include &lt;linux/stringify.h&gt;</span>
 #include &lt;linux/types.h&gt;
 
 static volatile int done;
<span class="p_chunk">@@ -728,7 +729,7 @@</span> <span class="p_context"> static void perf_event__process_sample(struct perf_tool *tool,</span>
 	if (event-&gt;header.misc &amp; PERF_RECORD_MISC_EXACT_IP)
 		top-&gt;exact_samples++;
 
<span class="p_del">-	if (perf_event__preprocess_sample(event, machine, &amp;al, sample) &lt; 0)</span>
<span class="p_add">+	if (machine__resolve(machine, &amp;al, sample) &lt; 0)</span>
 		return;
 
 	if (!top-&gt;kptr_restrict_warned &amp;&amp;
<span class="p_chunk">@@ -809,7 +810,6 @@</span> <span class="p_context"> static void perf_top__mmap_read_idx(struct perf_top *top, int idx)</span>
 	struct perf_session *session = top-&gt;session;
 	union perf_event *event;
 	struct machine *machine;
<span class="p_del">-	u8 origin;</span>
 	int ret;
 
 	while ((event = perf_evlist__mmap_read(top-&gt;evlist, idx)) != NULL) {
<span class="p_chunk">@@ -822,12 +822,10 @@</span> <span class="p_context"> static void perf_top__mmap_read_idx(struct perf_top *top, int idx)</span>
 		evsel = perf_evlist__id2evsel(session-&gt;evlist, sample.id);
 		assert(evsel != NULL);
 
<span class="p_del">-		origin = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
<span class="p_del">-</span>
 		if (event-&gt;header.type == PERF_RECORD_SAMPLE)
 			++top-&gt;samples;
 
<span class="p_del">-		switch (origin) {</span>
<span class="p_add">+		switch (sample.cpumode) {</span>
 		case PERF_RECORD_MISC_USER:
 			++top-&gt;us_samples;
 			if (top-&gt;hide_user_symbols)
<span class="p_header">diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c</span>
<span class="p_header">index 8dc98c598b1a..93ac724fb635 100644</span>
<span class="p_header">--- a/tools/perf/builtin-trace.c</span>
<span class="p_header">+++ b/tools/perf/builtin-trace.c</span>
<span class="p_chunk">@@ -2256,11 +2256,10 @@</span> <span class="p_context"> static void print_location(FILE *f, struct perf_sample *sample,</span>
 
 static int trace__pgfault(struct trace *trace,
 			  struct perf_evsel *evsel,
<span class="p_del">-			  union perf_event *event,</span>
<span class="p_add">+			  union perf_event *event __maybe_unused,</span>
 			  struct perf_sample *sample)
 {
 	struct thread *thread;
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct addr_location al;
 	char map_type = &#39;d&#39;;
 	struct thread_trace *ttrace;
<span class="p_chunk">@@ -2279,7 +2278,7 @@</span> <span class="p_context"> static int trace__pgfault(struct trace *trace,</span>
 	if (trace-&gt;summary_only)
 		goto out;
 
<span class="p_del">-	thread__find_addr_location(thread, cpumode, MAP__FUNCTION,</span>
<span class="p_add">+	thread__find_addr_location(thread, sample-&gt;cpumode, MAP__FUNCTION,</span>
 			      sample-&gt;ip, &amp;al);
 
 	trace__fprintf_entry_head(trace, thread, 0, sample-&gt;time, trace-&gt;output);
<span class="p_chunk">@@ -2292,11 +2291,11 @@</span> <span class="p_context"> static int trace__pgfault(struct trace *trace,</span>
 
 	fprintf(trace-&gt;output, &quot;] =&gt; &quot;);
 
<span class="p_del">-	thread__find_addr_location(thread, cpumode, MAP__VARIABLE,</span>
<span class="p_add">+	thread__find_addr_location(thread, sample-&gt;cpumode, MAP__VARIABLE,</span>
 				   sample-&gt;addr, &amp;al);
 
 	if (!al.map) {
<span class="p_del">-		thread__find_addr_location(thread, cpumode,</span>
<span class="p_add">+		thread__find_addr_location(thread, sample-&gt;cpumode,</span>
 					   MAP__FUNCTION, sample-&gt;addr, &amp;al);
 
 		if (al.map)
<span class="p_header">diff --git a/tools/perf/builtin.h b/tools/perf/builtin.h</span>
<span class="p_header">index 3f871b54e261..41c24010ab43 100644</span>
<span class="p_header">--- a/tools/perf/builtin.h</span>
<span class="p_header">+++ b/tools/perf/builtin.h</span>
<span class="p_chunk">@@ -7,38 +7,38 @@</span> <span class="p_context"></span>
 extern const char perf_usage_string[];
 extern const char perf_more_info_string[];
 
<span class="p_del">-extern void list_common_cmds_help(void);</span>
<span class="p_del">-extern const char *help_unknown_cmd(const char *cmd);</span>
<span class="p_del">-extern void prune_packed_objects(int);</span>
<span class="p_del">-extern int read_line_with_nul(char *buf, int size, FILE *file);</span>
<span class="p_del">-extern int check_pager_config(const char *cmd);</span>
<span class="p_add">+void list_common_cmds_help(void);</span>
<span class="p_add">+const char *help_unknown_cmd(const char *cmd);</span>
<span class="p_add">+void prune_packed_objects(int);</span>
<span class="p_add">+int read_line_with_nul(char *buf, int size, FILE *file);</span>
<span class="p_add">+int check_pager_config(const char *cmd);</span>
 
<span class="p_del">-extern int cmd_annotate(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_bench(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_buildid_cache(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_buildid_list(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_config(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_diff(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_evlist(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_help(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_sched(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_list(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_record(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_report(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_stat(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_timechart(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_top(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_script(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_version(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_probe(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_kmem(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_lock(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_kvm(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_test(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_trace(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_inject(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_mem(int argc, const char **argv, const char *prefix);</span>
<span class="p_del">-extern int cmd_data(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_annotate(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_bench(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_buildid_cache(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_buildid_list(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_config(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_diff(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_evlist(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_help(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_sched(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_list(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_record(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_report(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_stat(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_timechart(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_top(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_script(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_version(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_probe(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_kmem(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_lock(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_kvm(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_test(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_trace(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_inject(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_mem(int argc, const char **argv, const char *prefix);</span>
<span class="p_add">+int cmd_data(int argc, const char **argv, const char *prefix);</span>
 
<span class="p_del">-extern int find_scripts(char **scripts_array, char **scripts_path_array);</span>
<span class="p_add">+int find_scripts(char **scripts_array, char **scripts_path_array);</span>
 #endif
<span class="p_header">diff --git a/tools/perf/config/Makefile b/tools/perf/config/Makefile</span>
<span class="p_header">index eca6a912e8c2..f7d7f5a1cad5 100644</span>
<span class="p_header">--- a/tools/perf/config/Makefile</span>
<span class="p_header">+++ b/tools/perf/config/Makefile</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> ifdef PERF_HAVE_ARCH_REGS_QUERY_REGISTER_OFFSET</span>
   CFLAGS += -DHAVE_ARCH_REGS_QUERY_REGISTER_OFFSET
 endif
 
<span class="p_del">-include $(src-perf)/config/utilities.mak</span>
<span class="p_add">+include $(srctree)/tools/scripts/utilities.mak</span>
 
 ifeq ($(call get-executable,$(FLEX)),)
   dummy := $(error Error: $(FLEX) is missing on this system, please install it)
<span class="p_header">diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c</span>
<span class="p_header">index afc9ad0a0515..abd3f0ec0c0b 100644</span>
<span class="p_header">--- a/tools/perf/tests/code-reading.c</span>
<span class="p_header">+++ b/tools/perf/tests/code-reading.c</span>
<span class="p_chunk">@@ -293,7 +293,6 @@</span> <span class="p_context"> static int process_sample_event(struct machine *machine,</span>
 {
 	struct perf_sample sample;
 	struct thread *thread;
<span class="p_del">-	u8 cpumode;</span>
 	int ret;
 
 	if (perf_evlist__parse_sample(evlist, event, &amp;sample)) {
<span class="p_chunk">@@ -307,9 +306,7 @@</span> <span class="p_context"> static int process_sample_event(struct machine *machine,</span>
 		return -1;
 	}
 
<span class="p_del">-	cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = read_object_code(sample.ip, READLEN, cpumode, thread, state);</span>
<span class="p_add">+	ret = read_object_code(sample.ip, READLEN, sample.cpumode, thread, state);</span>
 	thread__put(thread);
 	return ret;
 }
<span class="p_header">diff --git a/tools/perf/tests/dwarf-unwind.c b/tools/perf/tests/dwarf-unwind.c</span>
<span class="p_header">index 1c5c0221cea2..8f6eb853aaf7 100644</span>
<span class="p_header">--- a/tools/perf/tests/dwarf-unwind.c</span>
<span class="p_header">+++ b/tools/perf/tests/dwarf-unwind.c</span>
<span class="p_chunk">@@ -20,10 +20,10 @@</span> <span class="p_context"></span>
 
 static int mmap_handler(struct perf_tool *tool __maybe_unused,
 			union perf_event *event,
<span class="p_del">-			struct perf_sample *sample __maybe_unused,</span>
<span class="p_add">+			struct perf_sample *sample,</span>
 			struct machine *machine)
 {
<span class="p_del">-	return machine__process_mmap2_event(machine, event, NULL);</span>
<span class="p_add">+	return machine__process_mmap2_event(machine, event, sample);</span>
 }
 
 static int init_live_machine(struct machine *machine)
<span class="p_header">diff --git a/tools/perf/tests/hists_common.c b/tools/perf/tests/hists_common.c</span>
<span class="p_header">index 071a8b5f5232..f55f4bd47932 100644</span>
<span class="p_header">--- a/tools/perf/tests/hists_common.c</span>
<span class="p_header">+++ b/tools/perf/tests/hists_common.c</span>
<span class="p_chunk">@@ -100,9 +100,11 @@</span> <span class="p_context"> struct machine *setup_fake_machine(struct machines *machines)</span>
 	}
 
 	for (i = 0; i &lt; ARRAY_SIZE(fake_mmap_info); i++) {
<span class="p_add">+		struct perf_sample sample = {</span>
<span class="p_add">+			.cpumode = PERF_RECORD_MISC_USER,</span>
<span class="p_add">+		};</span>
 		union perf_event fake_mmap_event = {
 			.mmap = {
<span class="p_del">-				.header = { .misc = PERF_RECORD_MISC_USER, },</span>
 				.pid = fake_mmap_info[i].pid,
 				.tid = fake_mmap_info[i].pid,
 				.start = fake_mmap_info[i].start,
<span class="p_chunk">@@ -114,7 +116,7 @@</span> <span class="p_context"> struct machine *setup_fake_machine(struct machines *machines)</span>
 		strcpy(fake_mmap_event.mmap.filename,
 		       fake_mmap_info[i].filename);
 
<span class="p_del">-		machine__process_mmap_event(machine, &amp;fake_mmap_event, NULL);</span>
<span class="p_add">+		machine__process_mmap_event(machine, &amp;fake_mmap_event, &amp;sample);</span>
 	}
 
 	for (i = 0; i &lt; ARRAY_SIZE(fake_symbols); i++) {
<span class="p_header">diff --git a/tools/perf/tests/hists_cumulate.c b/tools/perf/tests/hists_cumulate.c</span>
<span class="p_header">index ecf136c385d5..ed5aa9eaeb6c 100644</span>
<span class="p_header">--- a/tools/perf/tests/hists_cumulate.c</span>
<span class="p_header">+++ b/tools/perf/tests/hists_cumulate.c</span>
<span class="p_chunk">@@ -81,11 +81,6 @@</span> <span class="p_context"> static int add_hist_entries(struct hists *hists, struct machine *machine)</span>
 	size_t i;
 
 	for (i = 0; i &lt; ARRAY_SIZE(fake_samples); i++) {
<span class="p_del">-		const union perf_event event = {</span>
<span class="p_del">-			.header = {</span>
<span class="p_del">-				.misc = PERF_RECORD_MISC_USER,</span>
<span class="p_del">-			},</span>
<span class="p_del">-		};</span>
 		struct hist_entry_iter iter = {
 			.evsel = evsel,
 			.sample	= &amp;sample,
<span class="p_chunk">@@ -97,13 +92,13 @@</span> <span class="p_context"> static int add_hist_entries(struct hists *hists, struct machine *machine)</span>
 		else
 			iter.ops = &amp;hist_iter_normal;
 
<span class="p_add">+		sample.cpumode = PERF_RECORD_MISC_USER;</span>
 		sample.pid = fake_samples[i].pid;
 		sample.tid = fake_samples[i].pid;
 		sample.ip = fake_samples[i].ip;
 		sample.callchain = (struct ip_callchain *)fake_callchains[i];
 
<span class="p_del">-		if (perf_event__preprocess_sample(&amp;event, machine, &amp;al,</span>
<span class="p_del">-						  &amp;sample) &lt; 0)</span>
<span class="p_add">+		if (machine__resolve(machine, &amp;al, &amp;sample) &lt; 0)</span>
 			goto out;
 
 		if (hist_entry_iter__add(&amp;iter, &amp;al, PERF_MAX_STACK_DEPTH,
<span class="p_header">diff --git a/tools/perf/tests/hists_filter.c b/tools/perf/tests/hists_filter.c</span>
<span class="p_header">index 34b945a55d4d..b825d24f8186 100644</span>
<span class="p_header">--- a/tools/perf/tests/hists_filter.c</span>
<span class="p_header">+++ b/tools/perf/tests/hists_filter.c</span>
<span class="p_chunk">@@ -58,11 +58,6 @@</span> <span class="p_context"> static int add_hist_entries(struct perf_evlist *evlist,</span>
 	 */
 	evlist__for_each(evlist, evsel) {
 		for (i = 0; i &lt; ARRAY_SIZE(fake_samples); i++) {
<span class="p_del">-			const union perf_event event = {</span>
<span class="p_del">-				.header = {</span>
<span class="p_del">-					.misc = PERF_RECORD_MISC_USER,</span>
<span class="p_del">-				},</span>
<span class="p_del">-			};</span>
 			struct hist_entry_iter iter = {
 				.evsel = evsel,
 				.sample = &amp;sample,
<span class="p_chunk">@@ -76,12 +71,12 @@</span> <span class="p_context"> static int add_hist_entries(struct perf_evlist *evlist,</span>
 			hists-&gt;dso_filter = NULL;
 			hists-&gt;symbol_filter_str = NULL;
 
<span class="p_add">+			sample.cpumode = PERF_RECORD_MISC_USER;</span>
 			sample.pid = fake_samples[i].pid;
 			sample.tid = fake_samples[i].pid;
 			sample.ip = fake_samples[i].ip;
 
<span class="p_del">-			if (perf_event__preprocess_sample(&amp;event, machine, &amp;al,</span>
<span class="p_del">-							  &amp;sample) &lt; 0)</span>
<span class="p_add">+			if (machine__resolve(machine, &amp;al, &amp;sample) &lt; 0)</span>
 				goto out;
 
 			al.socket = fake_samples[i].socket;
<span class="p_header">diff --git a/tools/perf/tests/hists_link.c b/tools/perf/tests/hists_link.c</span>
<span class="p_header">index 64b257d8d557..358324e47805 100644</span>
<span class="p_header">--- a/tools/perf/tests/hists_link.c</span>
<span class="p_header">+++ b/tools/perf/tests/hists_link.c</span>
<span class="p_chunk">@@ -76,17 +76,12 @@</span> <span class="p_context"> static int add_hist_entries(struct perf_evlist *evlist, struct machine *machine)</span>
 		struct hists *hists = evsel__hists(evsel);
 
 		for (k = 0; k &lt; ARRAY_SIZE(fake_common_samples); k++) {
<span class="p_del">-			const union perf_event event = {</span>
<span class="p_del">-				.header = {</span>
<span class="p_del">-					.misc = PERF_RECORD_MISC_USER,</span>
<span class="p_del">-				},</span>
<span class="p_del">-			};</span>
<span class="p_del">-</span>
<span class="p_add">+			sample.cpumode = PERF_RECORD_MISC_USER;</span>
 			sample.pid = fake_common_samples[k].pid;
 			sample.tid = fake_common_samples[k].pid;
 			sample.ip = fake_common_samples[k].ip;
<span class="p_del">-			if (perf_event__preprocess_sample(&amp;event, machine, &amp;al,</span>
<span class="p_del">-							  &amp;sample) &lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+			if (machine__resolve(machine, &amp;al, &amp;sample) &lt; 0)</span>
 				goto out;
 
 			he = __hists__add_entry(hists, &amp;al, NULL,
<span class="p_chunk">@@ -102,17 +97,10 @@</span> <span class="p_context"> static int add_hist_entries(struct perf_evlist *evlist, struct machine *machine)</span>
 		}
 
 		for (k = 0; k &lt; ARRAY_SIZE(fake_samples[i]); k++) {
<span class="p_del">-			const union perf_event event = {</span>
<span class="p_del">-				.header = {</span>
<span class="p_del">-					.misc = PERF_RECORD_MISC_USER,</span>
<span class="p_del">-				},</span>
<span class="p_del">-			};</span>
<span class="p_del">-</span>
 			sample.pid = fake_samples[i][k].pid;
 			sample.tid = fake_samples[i][k].pid;
 			sample.ip = fake_samples[i][k].ip;
<span class="p_del">-			if (perf_event__preprocess_sample(&amp;event, machine, &amp;al,</span>
<span class="p_del">-							  &amp;sample) &lt; 0)</span>
<span class="p_add">+			if (machine__resolve(machine, &amp;al, &amp;sample) &lt; 0)</span>
 				goto out;
 
 			he = __hists__add_entry(hists, &amp;al, NULL,
<span class="p_header">diff --git a/tools/perf/tests/hists_output.c b/tools/perf/tests/hists_output.c</span>
<span class="p_header">index 23cce67c7e48..d3556fbe8c5c 100644</span>
<span class="p_header">--- a/tools/perf/tests/hists_output.c</span>
<span class="p_header">+++ b/tools/perf/tests/hists_output.c</span>
<span class="p_chunk">@@ -51,11 +51,6 @@</span> <span class="p_context"> static int add_hist_entries(struct hists *hists, struct machine *machine)</span>
 	size_t i;
 
 	for (i = 0; i &lt; ARRAY_SIZE(fake_samples); i++) {
<span class="p_del">-		const union perf_event event = {</span>
<span class="p_del">-			.header = {</span>
<span class="p_del">-				.misc = PERF_RECORD_MISC_USER,</span>
<span class="p_del">-			},</span>
<span class="p_del">-		};</span>
 		struct hist_entry_iter iter = {
 			.evsel = evsel,
 			.sample = &amp;sample,
<span class="p_chunk">@@ -63,13 +58,13 @@</span> <span class="p_context"> static int add_hist_entries(struct hists *hists, struct machine *machine)</span>
 			.hide_unresolved = false,
 		};
 
<span class="p_add">+		sample.cpumode = PERF_RECORD_MISC_USER;</span>
 		sample.cpu = fake_samples[i].cpu;
 		sample.pid = fake_samples[i].pid;
 		sample.tid = fake_samples[i].pid;
 		sample.ip = fake_samples[i].ip;
 
<span class="p_del">-		if (perf_event__preprocess_sample(&amp;event, machine, &amp;al,</span>
<span class="p_del">-						  &amp;sample) &lt; 0)</span>
<span class="p_add">+		if (machine__resolve(machine, &amp;al, &amp;sample) &lt; 0)</span>
 			goto out;
 
 		if (hist_entry_iter__add(&amp;iter, &amp;al, PERF_MAX_STACK_DEPTH,
<span class="p_header">diff --git a/tools/perf/ui/gtk/hists.c b/tools/perf/ui/gtk/hists.c</span>
<span class="p_header">index bd9bf7e343b1..2aa45b606fa4 100644</span>
<span class="p_header">--- a/tools/perf/ui/gtk/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/gtk/hists.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> static u64 he_get_acc_##_field(struct hist_entry *he)				\</span>
 	return he-&gt;stat_acc-&gt;_field;						\
 }										\
 										\
<span class="p_del">-static int perf_gtk__hpp_color_##_type(struct perf_hpp_fmt *fmt __maybe_unused,	\</span>
<span class="p_add">+static int perf_gtk__hpp_color_##_type(struct perf_hpp_fmt *fmt,		\</span>
 				       struct perf_hpp *hpp,			\
 				       struct hist_entry *he)			\
 {										\
<span class="p_header">diff --git a/tools/perf/util/Build b/tools/perf/util/Build</span>
<span class="p_header">index eea25e2424e9..da48fd843438 100644</span>
<span class="p_header">--- a/tools/perf/util/Build</span>
<span class="p_header">+++ b/tools/perf/util/Build</span>
<span class="p_chunk">@@ -1,4 +1,3 @@</span> <span class="p_context"></span>
<span class="p_del">-libperf-y += abspath.o</span>
 libperf-y += alias.o
 libperf-y += annotate.o
 libperf-y += build-id.o
<span class="p_header">diff --git a/tools/perf/util/abspath.c b/tools/perf/util/abspath.c</span>
deleted file mode 100644
<span class="p_header">index 0e76affe9c36..000000000000</span>
<span class="p_header">--- a/tools/perf/util/abspath.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,37 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#include &quot;cache.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-static const char *get_pwd_cwd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	static char cwd[PATH_MAX + 1];</span>
<span class="p_del">-	char *pwd;</span>
<span class="p_del">-	struct stat cwd_stat, pwd_stat;</span>
<span class="p_del">-	if (getcwd(cwd, PATH_MAX) == NULL)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	pwd = getenv(&quot;PWD&quot;);</span>
<span class="p_del">-	if (pwd &amp;&amp; strcmp(pwd, cwd)) {</span>
<span class="p_del">-		stat(cwd, &amp;cwd_stat);</span>
<span class="p_del">-		if (!stat(pwd, &amp;pwd_stat) &amp;&amp;</span>
<span class="p_del">-		    pwd_stat.st_dev == cwd_stat.st_dev &amp;&amp;</span>
<span class="p_del">-		    pwd_stat.st_ino == cwd_stat.st_ino) {</span>
<span class="p_del">-			strlcpy(cwd, pwd, PATH_MAX);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return cwd;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-const char *make_nonrelative_path(const char *path)</span>
<span class="p_del">-{</span>
<span class="p_del">-	static char buf[PATH_MAX + 1];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (is_absolute_path(path)) {</span>
<span class="p_del">-		if (strlcpy(buf, path, PATH_MAX) &gt;= PATH_MAX)</span>
<span class="p_del">-			die(&quot;Too long path: %.*s&quot;, 60, path);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		const char *cwd = get_pwd_cwd();</span>
<span class="p_del">-		if (!cwd)</span>
<span class="p_del">-			die(&quot;Cannot determine the current working directory&quot;);</span>
<span class="p_del">-		if (snprintf(buf, PATH_MAX, &quot;%s/%s&quot;, cwd, path) &gt;= PATH_MAX)</span>
<span class="p_del">-			die(&quot;Too long path: %.*s&quot;, 60, path);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return buf;</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/tools/perf/util/annotate.h b/tools/perf/util/annotate.h</span>
<span class="p_header">index cea323d9ee7e..9241f8c2b7e1 100644</span>
<span class="p_header">--- a/tools/perf/util/annotate.h</span>
<span class="p_header">+++ b/tools/perf/util/annotate.h</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> int symbol__annotate(struct symbol *sym, struct map *map, size_t privsize);</span>
 
 int hist_entry__annotate(struct hist_entry *he, size_t privsize);
 
<span class="p_del">-int symbol__annotate_init(struct map *map __maybe_unused, struct symbol *sym);</span>
<span class="p_add">+int symbol__annotate_init(struct map *map, struct symbol *sym);</span>
 int symbol__annotate_printf(struct symbol *sym, struct map *map,
 			    struct perf_evsel *evsel, bool full_paths,
 			    int min_pcnt, int max_lines, int context);
<span class="p_header">diff --git a/tools/perf/util/auxtrace.h b/tools/perf/util/auxtrace.h</span>
<span class="p_header">index e5a8e2d4f2af..57ff31ecb8e4 100644</span>
<span class="p_header">--- a/tools/perf/util/auxtrace.h</span>
<span class="p_header">+++ b/tools/perf/util/auxtrace.h</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"> static inline void auxtrace__free(struct perf_session *session)</span>
 
 static inline struct auxtrace_record *
 auxtrace_record__init(struct perf_evlist *evlist __maybe_unused,
<span class="p_del">-		      int *err __maybe_unused)</span>
<span class="p_add">+		      int *err)</span>
 {
 	*err = 0;
 	return NULL;
<span class="p_header">diff --git a/tools/perf/util/build-id.c b/tools/perf/util/build-id.c</span>
<span class="p_header">index f1479eeef7da..0573c2ec861d 100644</span>
<span class="p_header">--- a/tools/perf/util/build-id.c</span>
<span class="p_header">+++ b/tools/perf/util/build-id.c</span>
<span class="p_chunk">@@ -28,7 +28,6 @@</span> <span class="p_context"> int build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,</span>
 			   struct machine *machine)
 {
 	struct addr_location al;
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct thread *thread = machine__findnew_thread(machine, sample-&gt;pid,
 							sample-&gt;tid);
 
<span class="p_chunk">@@ -38,7 +37,7 @@</span> <span class="p_context"> int build_id__mark_dso_hit(struct perf_tool *tool __maybe_unused,</span>
 		return -1;
 	}
 
<span class="p_del">-	thread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample-&gt;ip, &amp;al);</span>
<span class="p_add">+	thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, sample-&gt;ip, &amp;al);</span>
 
 	if (al.map != NULL)
 		al.map-&gt;dso-&gt;hit = 1;
<span class="p_header">diff --git a/tools/perf/util/cache.h b/tools/perf/util/cache.h</span>
<span class="p_header">index 3ca453f0c51f..1f5a93c2c9a2 100644</span>
<span class="p_header">--- a/tools/perf/util/cache.h</span>
<span class="p_header">+++ b/tools/perf/util/cache.h</span>
<span class="p_chunk">@@ -26,14 +26,14 @@</span> <span class="p_context"></span>
 extern const char *config_exclusive_filename;
 
 typedef int (*config_fn_t)(const char *, const char *, void *);
<span class="p_del">-extern int perf_default_config(const char *, const char *, void *);</span>
<span class="p_del">-extern int perf_config(config_fn_t fn, void *);</span>
<span class="p_del">-extern int perf_config_int(const char *, const char *);</span>
<span class="p_del">-extern u64 perf_config_u64(const char *, const char *);</span>
<span class="p_del">-extern int perf_config_bool(const char *, const char *);</span>
<span class="p_del">-extern int config_error_nonbool(const char *);</span>
<span class="p_del">-extern const char *perf_config_dirname(const char *, const char *);</span>
<span class="p_del">-extern const char *perf_etc_perfconfig(void);</span>
<span class="p_add">+int perf_default_config(const char *, const char *, void *);</span>
<span class="p_add">+int perf_config(config_fn_t fn, void *);</span>
<span class="p_add">+int perf_config_int(const char *, const char *);</span>
<span class="p_add">+u64 perf_config_u64(const char *, const char *);</span>
<span class="p_add">+int perf_config_bool(const char *, const char *);</span>
<span class="p_add">+int config_error_nonbool(const char *);</span>
<span class="p_add">+const char *perf_config_dirname(const char *, const char *);</span>
<span class="p_add">+const char *perf_etc_perfconfig(void);</span>
 
 char *alias_lookup(const char *alias);
 int split_cmdline(char *cmdline, const char ***argv);
<span class="p_chunk">@@ -64,13 +64,9 @@</span> <span class="p_context"> static inline int is_absolute_path(const char *path)</span>
 	return path[0] == &#39;/&#39;;
 }
 
<span class="p_del">-const char *make_nonrelative_path(const char *path);</span>
 char *strip_path_suffix(const char *path, const char *suffix);
 
<span class="p_del">-extern char *mkpath(const char *fmt, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_del">-extern char *perf_path(const char *fmt, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_del">-</span>
<span class="p_del">-extern char *perf_pathdup(const char *fmt, ...)</span>
<span class="p_del">-	__attribute__((format (printf, 1, 2)));</span>
<span class="p_add">+char *mkpath(const char *fmt, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_add">+char *perf_path(const char *fmt, ...) __attribute__((format (printf, 1, 2)));</span>
 
 #endif /* __PERF_CACHE_H */
<span class="p_header">diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h</span>
<span class="p_header">index 18dd22269764..d2a9e694810c 100644</span>
<span class="p_header">--- a/tools/perf/util/callchain.h</span>
<span class="p_header">+++ b/tools/perf/util/callchain.h</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> int fill_callchain_info(struct addr_location *al, struct callchain_cursor_node *</span>
 			bool hide_unresolved);
 
 extern const char record_callchain_help[];
<span class="p_del">-extern int parse_callchain_record(const char *arg, struct callchain_param *param);</span>
<span class="p_add">+int parse_callchain_record(const char *arg, struct callchain_param *param);</span>
 int parse_callchain_record_opt(const char *arg, struct callchain_param *param);
 int parse_callchain_report_opt(const char *arg);
 int parse_callchain_top_opt(const char *arg);
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> static inline void callchain_cursor_snapshot(struct callchain_cursor *dest,</span>
 }
 
 #ifdef HAVE_SKIP_CALLCHAIN_IDX
<span class="p_del">-extern int arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain);</span>
<span class="p_add">+int arch_skip_callchain_idx(struct thread *thread, struct ip_callchain *chain);</span>
 #else
 static inline int arch_skip_callchain_idx(struct thread *thread __maybe_unused,
 			struct ip_callchain *chain __maybe_unused)
<span class="p_header">diff --git a/tools/perf/util/cgroup.h b/tools/perf/util/cgroup.h</span>
<span class="p_header">index b4b8cb42fe5e..31f8dcdbd7ef 100644</span>
<span class="p_header">--- a/tools/perf/util/cgroup.h</span>
<span class="p_header">+++ b/tools/perf/util/cgroup.h</span>
<span class="p_chunk">@@ -13,7 +13,7 @@</span> <span class="p_context"> struct cgroup_sel {</span>
 
 
 extern int nr_cgroups; /* number of explicit cgroups defined */
<span class="p_del">-extern void close_cgroup(struct cgroup_sel *cgrp);</span>
<span class="p_del">-extern int parse_cgroups(const struct option *opt, const char *str, int unset);</span>
<span class="p_add">+void close_cgroup(struct cgroup_sel *cgrp);</span>
<span class="p_add">+int parse_cgroups(const struct option *opt, const char *str, int unset);</span>
 
 #endif /* __CGROUP_H__ */
<span class="p_header">diff --git a/tools/perf/util/cloexec.h b/tools/perf/util/cloexec.h</span>
<span class="p_header">index 3bee6773ddb0..d0d465953d36 100644</span>
<span class="p_header">--- a/tools/perf/util/cloexec.h</span>
<span class="p_header">+++ b/tools/perf/util/cloexec.h</span>
<span class="p_chunk">@@ -5,7 +5,7 @@</span> <span class="p_context"> unsigned long perf_event_open_cloexec_flag(void);</span>
 
 #ifdef __GLIBC_PREREQ
 #if !__GLIBC_PREREQ(2, 6) &amp;&amp; !defined(__UCLIBC__)
<span class="p_del">-extern int sched_getcpu(void) __THROW;</span>
<span class="p_add">+int sched_getcpu(void) __THROW;</span>
 #endif
 #endif
 
<span class="p_header">diff --git a/tools/perf/util/data-convert-bt.c b/tools/perf/util/data-convert-bt.c</span>
<span class="p_header">index 811af89ce0bb..bbf69d248ec5 100644</span>
<span class="p_header">--- a/tools/perf/util/data-convert-bt.c</span>
<span class="p_header">+++ b/tools/perf/util/data-convert-bt.c</span>
<span class="p_chunk">@@ -632,7 +632,7 @@</span> <span class="p_context"> static bool is_flush_needed(struct ctf_stream *cs)</span>
 }
 
 static int process_sample_event(struct perf_tool *tool,
<span class="p_del">-				union perf_event *_event __maybe_unused,</span>
<span class="p_add">+				union perf_event *_event,</span>
 				struct perf_sample *sample,
 				struct perf_evsel *evsel,
 				struct machine *machine __maybe_unused)
<span class="p_header">diff --git a/tools/perf/util/db-export.c b/tools/perf/util/db-export.c</span>
<span class="p_header">index 1c9689e4cc17..049438d51b9a 100644</span>
<span class="p_header">--- a/tools/perf/util/db-export.c</span>
<span class="p_header">+++ b/tools/perf/util/db-export.c</span>
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> int db_export__sample(struct db_export *dbe, union perf_event *event,</span>
 	    sample_addr_correlates_sym(&amp;evsel-&gt;attr)) {
 		struct addr_location addr_al;
 
<span class="p_del">-		perf_event__preprocess_sample_addr(event, sample, thread, &amp;addr_al);</span>
<span class="p_add">+		thread__resolve(thread, &amp;addr_al, sample);</span>
 		err = db_ids_from_al(dbe, &amp;addr_al, &amp;es.addr_dso_db_id,
 				     &amp;es.addr_sym_db_id, &amp;es.addr_offset);
 		if (err)
<span class="p_header">diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h</span>
<span class="p_header">index 45ec4d0a50ed..0953280629cf 100644</span>
<span class="p_header">--- a/tools/perf/util/dso.h</span>
<span class="p_header">+++ b/tools/perf/util/dso.h</span>
<span class="p_chunk">@@ -162,6 +162,7 @@</span> <span class="p_context"> struct dso {</span>
 	u8		 loaded;
 	u8		 rel;
 	u8		 build_id[BUILD_ID_SIZE];
<span class="p_add">+	u64		 text_offset;</span>
 	const char	 *short_name;
 	const char	 *long_name;
 	u16		 long_name_len;
<span class="p_chunk">@@ -301,7 +302,7 @@</span> <span class="p_context"> int __kmod_path__parse(struct kmod_path *m, const char *path,</span>
  * TODO
 */
 int dso__data_get_fd(struct dso *dso, struct machine *machine);
<span class="p_del">-void dso__data_put_fd(struct dso *dso __maybe_unused);</span>
<span class="p_add">+void dso__data_put_fd(struct dso *dso);</span>
 void dso__data_close(struct dso *dso);
 
 off_t dso__data_size(struct dso *dso, struct machine *machine);
<span class="p_header">diff --git a/tools/perf/util/dwarf-aux.c b/tools/perf/util/dwarf-aux.c</span>
<span class="p_header">index a509aa8433a1..577e600c8eb1 100644</span>
<span class="p_header">--- a/tools/perf/util/dwarf-aux.c</span>
<span class="p_header">+++ b/tools/perf/util/dwarf-aux.c</span>
<span class="p_chunk">@@ -915,7 +915,7 @@</span> <span class="p_context"> int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf)</span>
 		tmp = &quot;*&quot;;
 	else if (tag == DW_TAG_subroutine_type) {
 		/* Function pointer */
<span class="p_del">-		strbuf_addf(buf, &quot;(function_type)&quot;);</span>
<span class="p_add">+		strbuf_add(buf, &quot;(function_type)&quot;, 15);</span>
 		return 0;
 	} else {
 		if (!dwarf_diename(&amp;type))
<span class="p_chunk">@@ -932,7 +932,7 @@</span> <span class="p_context"> int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf)</span>
 	}
 	ret = die_get_typename(&amp;type, buf);
 	if (ret == 0)
<span class="p_del">-		strbuf_addf(buf, &quot;%s&quot;, tmp);</span>
<span class="p_add">+		strbuf_addstr(buf, tmp);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -951,7 +951,7 @@</span> <span class="p_context"> int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf)</span>
 	ret = die_get_typename(vr_die, buf);
 	if (ret &lt; 0) {
 		pr_debug(&quot;Failed to get type, make it unknown.\n&quot;);
<span class="p_del">-		strbuf_addf(buf, &quot;(unknown_type)&quot;);</span>
<span class="p_add">+		strbuf_add(buf, &quot; (unknown_type)&quot;, 14);</span>
 	}
 
 	strbuf_addf(buf, &quot;\t%s&quot;, dwarf_diename(vr_die));
<span class="p_chunk">@@ -1013,7 +1013,7 @@</span> <span class="p_context"> static int die_get_var_innermost_scope(Dwarf_Die *sp_die, Dwarf_Die *vr_die,</span>
 	}
 
 	if (!first)
<span class="p_del">-		strbuf_addf(buf, &quot;]&gt;&quot;);</span>
<span class="p_add">+		strbuf_add(buf, &quot;]&gt;&quot;, 2);</span>
 
 out:
 	free(scopes);
<span class="p_chunk">@@ -1076,7 +1076,7 @@</span> <span class="p_context"> int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die, struct strbuf *buf)</span>
 	}
 
 	if (!first)
<span class="p_del">-		strbuf_addf(buf, &quot;]&gt;&quot;);</span>
<span class="p_add">+		strbuf_add(buf, &quot;]&gt;&quot;, 2);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/tools/perf/util/dwarf-aux.h b/tools/perf/util/dwarf-aux.h</span>
<span class="p_header">index c42ec366f2a7..dc0ce1adb075 100644</span>
<span class="p_header">--- a/tools/perf/util/dwarf-aux.h</span>
<span class="p_header">+++ b/tools/perf/util/dwarf-aux.h</span>
<span class="p_chunk">@@ -25,48 +25,48 @@</span> <span class="p_context"></span>
 #include &lt;elfutils/version.h&gt;
 
 /* Find the realpath of the target file */
<span class="p_del">-extern const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);</span>
<span class="p_add">+const char *cu_find_realpath(Dwarf_Die *cu_die, const char *fname);</span>
 
 /* Get DW_AT_comp_dir (should be NULL with older gcc) */
<span class="p_del">-extern const char *cu_get_comp_dir(Dwarf_Die *cu_die);</span>
<span class="p_add">+const char *cu_get_comp_dir(Dwarf_Die *cu_die);</span>
 
 /* Get a line number and file name for given address */
<span class="p_del">-extern int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,</span>
<span class="p_del">-			    const char **fname, int *lineno);</span>
<span class="p_add">+int cu_find_lineinfo(Dwarf_Die *cudie, unsigned long addr,</span>
<span class="p_add">+		     const char **fname, int *lineno);</span>
 
 /* Walk on funcitons at given address */
<span class="p_del">-extern int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,</span>
<span class="p_del">-			int (*callback)(Dwarf_Die *, void *), void *data);</span>
<span class="p_add">+int cu_walk_functions_at(Dwarf_Die *cu_die, Dwarf_Addr addr,</span>
<span class="p_add">+			 int (*callback)(Dwarf_Die *, void *), void *data);</span>
 
 /* Ensure that this DIE is a subprogram and definition (not declaration) */
<span class="p_del">-extern bool die_is_func_def(Dwarf_Die *dw_die);</span>
<span class="p_add">+bool die_is_func_def(Dwarf_Die *dw_die);</span>
 
 /* Ensure that this DIE is an instance of a subprogram */
<span class="p_del">-extern bool die_is_func_instance(Dwarf_Die *dw_die);</span>
<span class="p_add">+bool die_is_func_instance(Dwarf_Die *dw_die);</span>
 
 /* Compare diename and tname */
<span class="p_del">-extern bool die_compare_name(Dwarf_Die *dw_die, const char *tname);</span>
<span class="p_add">+bool die_compare_name(Dwarf_Die *dw_die, const char *tname);</span>
 
 /* Matching diename with glob pattern */
<span class="p_del">-extern bool die_match_name(Dwarf_Die *dw_die, const char *glob);</span>
<span class="p_add">+bool die_match_name(Dwarf_Die *dw_die, const char *glob);</span>
 
 /* Get callsite line number of inline-function instance */
<span class="p_del">-extern int die_get_call_lineno(Dwarf_Die *in_die);</span>
<span class="p_add">+int die_get_call_lineno(Dwarf_Die *in_die);</span>
 
 /* Get callsite file name of inlined function instance */
<span class="p_del">-extern const char *die_get_call_file(Dwarf_Die *in_die);</span>
<span class="p_add">+const char *die_get_call_file(Dwarf_Die *in_die);</span>
 
 /* Get type die */
<span class="p_del">-extern Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_get_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);</span>
 
 /* Get a type die, but skip qualifiers and typedef */
<span class="p_del">-extern Dwarf_Die *die_get_real_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_get_real_type(Dwarf_Die *vr_die, Dwarf_Die *die_mem);</span>
 
 /* Check whether the DIE is signed or not */
<span class="p_del">-extern bool die_is_signed_type(Dwarf_Die *tp_die);</span>
<span class="p_add">+bool die_is_signed_type(Dwarf_Die *tp_die);</span>
 
 /* Get data_member_location offset */
<span class="p_del">-extern int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs);</span>
<span class="p_add">+int die_get_data_member_location(Dwarf_Die *mb_die, Dwarf_Word *offs);</span>
 
 /* Return values for die_find_child() callbacks */
 enum {
<span class="p_chunk">@@ -77,29 +77,29 @@</span> <span class="p_context"> enum {</span>
 };
 
 /* Search child DIEs */
<span class="p_del">-extern Dwarf_Die *die_find_child(Dwarf_Die *rt_die,</span>
<span class="p_del">-				 int (*callback)(Dwarf_Die *, void *),</span>
<span class="p_del">-				 void *data, Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_child(Dwarf_Die *rt_die,</span>
<span class="p_add">+			 int (*callback)(Dwarf_Die *, void *),</span>
<span class="p_add">+			 void *data, Dwarf_Die *die_mem);</span>
 
 /* Search a non-inlined function including given address */
<span class="p_del">-extern Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,</span>
<span class="p_del">-				    Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_realfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,</span>
<span class="p_add">+			     Dwarf_Die *die_mem);</span>
 
 /* Search a non-inlined function with tail call at given address */
 Dwarf_Die *die_find_tailfunc(Dwarf_Die *cu_die, Dwarf_Addr addr,
 				    Dwarf_Die *die_mem);
 
 /* Search the top inlined function including given address */
<span class="p_del">-extern Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,</span>
<span class="p_del">-					  Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_top_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,</span>
<span class="p_add">+				   Dwarf_Die *die_mem);</span>
 
 /* Search the deepest inlined function including given address */
<span class="p_del">-extern Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,</span>
<span class="p_del">-				      Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_inlinefunc(Dwarf_Die *sp_die, Dwarf_Addr addr,</span>
<span class="p_add">+			       Dwarf_Die *die_mem);</span>
 
 /* Walk on the instances of given DIE */
<span class="p_del">-extern int die_walk_instances(Dwarf_Die *in_die,</span>
<span class="p_del">-			      int (*callback)(Dwarf_Die *, void *), void *data);</span>
<span class="p_add">+int die_walk_instances(Dwarf_Die *in_die,</span>
<span class="p_add">+		       int (*callback)(Dwarf_Die *, void *), void *data);</span>
 
 /* Walker on lines (Note: line number will not be sorted) */
 typedef int (* line_walk_callback_t) (const char *fname, int lineno,
<span class="p_chunk">@@ -109,22 +109,20 @@</span> <span class="p_context"> typedef int (* line_walk_callback_t) (const char *fname, int lineno,</span>
  * Walk on lines inside given DIE. If the DIE is a subprogram, walk only on
  * the lines inside the subprogram, otherwise the DIE must be a CU DIE.
  */
<span class="p_del">-extern int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback,</span>
<span class="p_del">-			  void *data);</span>
<span class="p_add">+int die_walk_lines(Dwarf_Die *rt_die, line_walk_callback_t callback, void *data);</span>
 
 /* Find a variable called &#39;name&#39; at given address */
<span class="p_del">-extern Dwarf_Die *die_find_variable_at(Dwarf_Die *sp_die, const char *name,</span>
<span class="p_del">-				       Dwarf_Addr addr, Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_variable_at(Dwarf_Die *sp_die, const char *name,</span>
<span class="p_add">+				Dwarf_Addr addr, Dwarf_Die *die_mem);</span>
 
 /* Find a member called &#39;name&#39; */
<span class="p_del">-extern Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,</span>
<span class="p_del">-				  Dwarf_Die *die_mem);</span>
<span class="p_add">+Dwarf_Die *die_find_member(Dwarf_Die *st_die, const char *name,</span>
<span class="p_add">+			   Dwarf_Die *die_mem);</span>
 
 /* Get the name of given variable DIE */
<span class="p_del">-extern int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);</span>
<span class="p_add">+int die_get_typename(Dwarf_Die *vr_die, struct strbuf *buf);</span>
 
 /* Get the name and type of given variable DIE, stored as &quot;type\tname&quot; */
<span class="p_del">-extern int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);</span>
<span class="p_del">-extern int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die,</span>
<span class="p_del">-			struct strbuf *buf);</span>
<span class="p_add">+int die_get_varname(Dwarf_Die *vr_die, struct strbuf *buf);</span>
<span class="p_add">+int die_get_var_range(Dwarf_Die *sp_die, Dwarf_Die *vr_die, struct strbuf *buf);</span>
 #endif
<span class="p_header">diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c</span>
<span class="p_header">index 7bad5c3fa7b7..52cf479bc593 100644</span>
<span class="p_header">--- a/tools/perf/util/event.c</span>
<span class="p_header">+++ b/tools/perf/util/event.c</span>
<span class="p_chunk">@@ -1295,12 +1295,9 @@</span> <span class="p_context"> void thread__find_addr_location(struct thread *thread,</span>
  * Callers need to drop the reference to al-&gt;thread, obtained in
  * machine__findnew_thread()
  */
<span class="p_del">-int perf_event__preprocess_sample(const union perf_event *event,</span>
<span class="p_del">-				  struct machine *machine,</span>
<span class="p_del">-				  struct addr_location *al,</span>
<span class="p_del">-				  struct perf_sample *sample)</span>
<span class="p_add">+int machine__resolve(struct machine *machine, struct addr_location *al,</span>
<span class="p_add">+		     struct perf_sample *sample)</span>
 {
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct thread *thread = machine__findnew_thread(machine, sample-&gt;pid,
 							sample-&gt;tid);
 
<span class="p_chunk">@@ -1315,11 +1312,11 @@</span> <span class="p_context"> int perf_event__preprocess_sample(const union perf_event *event,</span>
 	 * events, but for older perf.data files there was no such thing, so do
 	 * it now.
 	 */
<span class="p_del">-	if (cpumode == PERF_RECORD_MISC_KERNEL &amp;&amp;</span>
<span class="p_add">+	if (sample-&gt;cpumode == PERF_RECORD_MISC_KERNEL &amp;&amp;</span>
 	    machine__kernel_map(machine) == NULL)
 		machine__create_kernel_maps(machine);
 
<span class="p_del">-	thread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample-&gt;ip, al);</span>
<span class="p_add">+	thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, sample-&gt;ip, al);</span>
 	dump_printf(&quot; ...... dso: %s\n&quot;,
 		    al-&gt;map ? al-&gt;map-&gt;dso-&gt;long_name :
 			al-&gt;level == &#39;H&#39; ? &quot;[hypervisor]&quot; : &quot;&lt;not found&gt;&quot;);
<span class="p_chunk">@@ -1395,16 +1392,12 @@</span> <span class="p_context"> bool sample_addr_correlates_sym(struct perf_event_attr *attr)</span>
 	return false;
 }
 
<span class="p_del">-void perf_event__preprocess_sample_addr(union perf_event *event,</span>
<span class="p_del">-					struct perf_sample *sample,</span>
<span class="p_del">-					struct thread *thread,</span>
<span class="p_del">-					struct addr_location *al)</span>
<span class="p_add">+void thread__resolve(struct thread *thread, struct addr_location *al,</span>
<span class="p_add">+		     struct perf_sample *sample)</span>
 {
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
<span class="p_del">-</span>
<span class="p_del">-	thread__find_addr_map(thread, cpumode, MAP__FUNCTION, sample-&gt;addr, al);</span>
<span class="p_add">+	thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, sample-&gt;addr, al);</span>
 	if (!al-&gt;map)
<span class="p_del">-		thread__find_addr_map(thread, cpumode, MAP__VARIABLE,</span>
<span class="p_add">+		thread__find_addr_map(thread, sample-&gt;cpumode, MAP__VARIABLE,</span>
 				      sample-&gt;addr, al);
 
 	al-&gt;cpu = sample-&gt;cpu;
<span class="p_header">diff --git a/tools/perf/util/event.h b/tools/perf/util/event.h</span>
<span class="p_header">index b7ffb7ee9971..6bb1c928350d 100644</span>
<span class="p_header">--- a/tools/perf/util/event.h</span>
<span class="p_header">+++ b/tools/perf/util/event.h</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> struct perf_sample {</span>
 	u64 data_src;
 	u32 flags;
 	u16 insn_len;
<span class="p_add">+	u8  cpumode;</span>
 	void *raw_data;
 	struct ip_callchain *callchain;
 	struct branch_stack *branch_stack;
<span class="p_chunk">@@ -597,10 +598,8 @@</span> <span class="p_context"> int perf_event__process(struct perf_tool *tool,</span>
 
 struct addr_location;
 
<span class="p_del">-int perf_event__preprocess_sample(const union perf_event *event,</span>
<span class="p_del">-				  struct machine *machine,</span>
<span class="p_del">-				  struct addr_location *al,</span>
<span class="p_del">-				  struct perf_sample *sample);</span>
<span class="p_add">+int machine__resolve(struct machine *machine, struct addr_location *al,</span>
<span class="p_add">+		     struct perf_sample *sample);</span>
 
 void addr_location__put(struct addr_location *al);
 
<span class="p_chunk">@@ -608,10 +607,8 @@</span> <span class="p_context"> struct thread;</span>
 
 bool is_bts_event(struct perf_event_attr *attr);
 bool sample_addr_correlates_sym(struct perf_event_attr *attr);
<span class="p_del">-void perf_event__preprocess_sample_addr(union perf_event *event,</span>
<span class="p_del">-					struct perf_sample *sample,</span>
<span class="p_del">-					struct thread *thread,</span>
<span class="p_del">-					struct addr_location *al);</span>
<span class="p_add">+void thread__resolve(struct thread *thread, struct addr_location *al,</span>
<span class="p_add">+		     struct perf_sample *sample);</span>
 
 const char *perf_event__name(unsigned int id);
 
<span class="p_header">diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c</span>
<span class="p_header">index 0902fe418754..738ce226002b 100644</span>
<span class="p_header">--- a/tools/perf/util/evsel.c</span>
<span class="p_header">+++ b/tools/perf/util/evsel.c</span>
<span class="p_chunk">@@ -1643,6 +1643,7 @@</span> <span class="p_context"> int perf_evsel__parse_sample(struct perf_evsel *evsel, union perf_event *event,</span>
 	data-&gt;stream_id = data-&gt;id = data-&gt;time = -1ULL;
 	data-&gt;period = evsel-&gt;attr.sample_period;
 	data-&gt;weight = 0;
<span class="p_add">+	data-&gt;cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 
 	if (event-&gt;header.type != PERF_RECORD_SAMPLE) {
 		if (!evsel-&gt;attr.sample_id_all)
<span class="p_header">diff --git a/tools/perf/util/genelf.h b/tools/perf/util/genelf.h</span>
<span class="p_header">index 45bf9c6d3257..cd67e64a0494 100644</span>
<span class="p_header">--- a/tools/perf/util/genelf.h</span>
<span class="p_header">+++ b/tools/perf/util/genelf.h</span>
<span class="p_chunk">@@ -2,12 +2,10 @@</span> <span class="p_context"></span>
 #define __GENELF_H__
 
 /* genelf.c */
<span class="p_del">-extern int jit_write_elf(int fd, uint64_t code_addr, const char *sym,</span>
<span class="p_del">-			 const void *code, int csize,</span>
<span class="p_del">-			 void *debug, int nr_debug_entries);</span>
<span class="p_add">+int jit_write_elf(int fd, uint64_t code_addr, const char *sym,</span>
<span class="p_add">+		  const void *code, int csize, void *debug, int nr_debug_entries);</span>
 /* genelf_debug.c */
<span class="p_del">-extern int jit_add_debug_info(Elf *e, uint64_t code_addr,</span>
<span class="p_del">-			      void *debug, int nr_debug_entries);</span>
<span class="p_add">+int jit_add_debug_info(Elf *e, uint64_t code_addr, void *debug, int nr_debug_entries);</span>
 
 #if   defined(__arm__)
 #define GEN_ELF_ARCH	EM_ARM
<span class="p_header">diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c</span>
<span class="p_header">index 73e38e472ecd..90680ec9f8b8 100644</span>
<span class="p_header">--- a/tools/perf/util/header.c</span>
<span class="p_header">+++ b/tools/perf/util/header.c</span>
<span class="p_chunk">@@ -1872,11 +1872,6 @@</span> <span class="p_context"> static int process_cpu_topology(struct perf_file_section *section,</span>
 		if (ph-&gt;needs_swap)
 			nr = bswap_32(nr);
 
<span class="p_del">-		if (nr &gt; (u32)cpu_nr) {</span>
<span class="p_del">-			pr_debug(&quot;core_id number is too big.&quot;</span>
<span class="p_del">-				 &quot;You may need to upgrade the perf tool.\n&quot;);</span>
<span class="p_del">-			goto free_cpu;</span>
<span class="p_del">-		}</span>
 		ph-&gt;env.cpu[i].core_id = nr;
 
 		ret = readn(fd, &amp;nr, sizeof(nr));
<span class="p_header">diff --git a/tools/perf/util/header.h b/tools/perf/util/header.h</span>
<span class="p_header">index 3d87ca823c0a..d306ca118449 100644</span>
<span class="p_header">--- a/tools/perf/util/header.h</span>
<span class="p_header">+++ b/tools/perf/util/header.h</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> int perf_event__synthesize_event_update_cpus(struct perf_tool *tool,</span>
 					     perf_event__handler_t process);
 int perf_event__process_attr(struct perf_tool *tool, union perf_event *event,
 			     struct perf_evlist **pevlist);
<span class="p_del">-int perf_event__process_event_update(struct perf_tool *tool __maybe_unused,</span>
<span class="p_add">+int perf_event__process_event_update(struct perf_tool *tool,</span>
 				     union perf_event *event,
 				     struct perf_evlist **pevlist);
 size_t perf_event__fprintf_event_update(union perf_event *event, FILE *fp);
<span class="p_header">diff --git a/tools/perf/util/hist.c b/tools/perf/util/hist.c</span>
<span class="p_header">index 290b3cbf6877..31c4641fe5ff 100644</span>
<span class="p_header">--- a/tools/perf/util/hist.c</span>
<span class="p_header">+++ b/tools/perf/util/hist.c</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> iter_prepare_branch_entry(struct hist_entry_iter *iter, struct addr_location *al</span>
 }
 
 static int
<span class="p_del">-iter_add_single_branch_entry(struct hist_entry_iter *iter __maybe_unused,</span>
<span class="p_add">+iter_add_single_branch_entry(struct hist_entry_iter *iter,</span>
 			     struct addr_location *al __maybe_unused)
 {
 	/* to avoid calling callback function */
<span class="p_header">diff --git a/tools/perf/util/hist.h b/tools/perf/util/hist.h</span>
<span class="p_header">index ead18c82294f..bec0cd660fbd 100644</span>
<span class="p_header">--- a/tools/perf/util/hist.h</span>
<span class="p_header">+++ b/tools/perf/util/hist.h</span>
<span class="p_chunk">@@ -433,8 +433,7 @@</span> <span class="p_context"> void hist__account_cycles(struct branch_stack *bs, struct addr_location *al,</span>
 			  struct perf_sample *sample, bool nonany_branch_mode);
 
 struct option;
<span class="p_del">-int parse_filter_percentage(const struct option *opt __maybe_unused,</span>
<span class="p_del">-			    const char *arg, int unset __maybe_unused);</span>
<span class="p_add">+int parse_filter_percentage(const struct option *opt, const char *arg, int unset);</span>
 int perf_hist_config(const char *var, const char *value);
 
 void perf_hpp_list__init(struct perf_hpp_list *list);
<span class="p_header">diff --git a/tools/perf/util/intel-bts.c b/tools/perf/util/intel-bts.c</span>
<span class="p_header">index eb0e7f8bf515..6bc3ecd2e7ca 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-bts.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-bts.c</span>
<span class="p_chunk">@@ -678,7 +678,7 @@</span> <span class="p_context"> static int intel_bts_process_auxtrace_event(struct perf_session *session,</span>
 	return 0;
 }
 
<span class="p_del">-static int intel_bts_flush(struct perf_session *session __maybe_unused,</span>
<span class="p_add">+static int intel_bts_flush(struct perf_session *session,</span>
 			   struct perf_tool *tool __maybe_unused)
 {
 	struct intel_bts *bts = container_of(session-&gt;auxtrace, struct intel_bts,
<span class="p_header">diff --git a/tools/perf/util/jit.h b/tools/perf/util/jit.h</span>
<span class="p_header">index a1e99da0715a..3f42ee4d2a0b 100644</span>
<span class="p_header">--- a/tools/perf/util/jit.h</span>
<span class="p_header">+++ b/tools/perf/util/jit.h</span>
<span class="p_chunk">@@ -3,13 +3,9 @@</span> <span class="p_context"></span>
 
 #include &lt;data.h&gt;
 
<span class="p_del">-extern int jit_process(struct perf_session *session,</span>
<span class="p_del">-		       struct perf_data_file *output,</span>
<span class="p_del">-		       struct machine *machine,</span>
<span class="p_del">-		       char *filename,</span>
<span class="p_del">-		       pid_t pid,</span>
<span class="p_del">-		       u64 *nbytes);</span>
<span class="p_del">-</span>
<span class="p_del">-extern int jit_inject_record(const char *filename);</span>
<span class="p_add">+int jit_process(struct perf_session *session, struct perf_data_file *output,</span>
<span class="p_add">+		struct machine *machine, char *filename, pid_t pid, u64 *nbytes);</span>
<span class="p_add">+</span>
<span class="p_add">+int jit_inject_record(const char *filename);</span>
 
 #endif /* __JIT_H__ */
<span class="p_header">diff --git a/tools/perf/util/llvm-utils.c b/tools/perf/util/llvm-utils.c</span>
<span class="p_header">index 00724d496d38..33071d6159bc 100644</span>
<span class="p_header">--- a/tools/perf/util/llvm-utils.c</span>
<span class="p_header">+++ b/tools/perf/util/llvm-utils.c</span>
<span class="p_chunk">@@ -3,11 +3,11 @@</span> <span class="p_context"></span>
  * Copyright (C) 2015, Huawei Inc.
  */
 
<span class="p_add">+#include &lt;limits.h&gt;</span>
 #include &lt;stdio.h&gt;
<span class="p_del">-#include &quot;util.h&quot;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
 #include &quot;debug.h&quot;
 #include &quot;llvm-utils.h&quot;
<span class="p_del">-#include &quot;cache.h&quot;</span>
 
 #define CLANG_BPF_CMD_DEFAULT_TEMPLATE				\
 		&quot;$CLANG_EXEC -D__KERNEL__ -D__NR_CPUS__=$NR_CPUS &quot;\
<span class="p_chunk">@@ -98,11 +98,12 @@</span> <span class="p_context"> read_from_pipe(const char *cmd, void **p_buf, size_t *p_read_sz)</span>
 	void *buf = NULL;
 	FILE *file = NULL;
 	size_t read_sz = 0, buf_sz = 0;
<span class="p_add">+	char serr[STRERR_BUFSIZE];</span>
 
 	file = popen(cmd, &quot;r&quot;);
 	if (!file) {
 		pr_err(&quot;ERROR: unable to popen cmd: %s\n&quot;,
<span class="p_del">-		       strerror(errno));</span>
<span class="p_add">+		       strerror_r(errno, serr, sizeof(serr)));</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -136,7 +137,7 @@</span> <span class="p_context"> read_from_pipe(const char *cmd, void **p_buf, size_t *p_read_sz)</span>
 
 	if (ferror(file)) {
 		pr_err(&quot;ERROR: error occurred when reading from pipe: %s\n&quot;,
<span class="p_del">-		       strerror(errno));</span>
<span class="p_add">+		       strerror_r(errno, serr, sizeof(serr)));</span>
 		err = -EIO;
 		goto errout;
 	}
<span class="p_chunk">@@ -334,10 +335,18 @@</span> <span class="p_context"> int llvm__compile_bpf(const char *path, void **p_obj_buf,</span>
 	unsigned int kernel_version;
 	char linux_version_code_str[64];
 	const char *clang_opt = llvm_param.clang_opt;
<span class="p_del">-	char clang_path[PATH_MAX], nr_cpus_avail_str[64];</span>
<span class="p_add">+	char clang_path[PATH_MAX], abspath[PATH_MAX], nr_cpus_avail_str[64];</span>
<span class="p_add">+	char serr[STRERR_BUFSIZE];</span>
 	char *kbuild_dir = NULL, *kbuild_include_opts = NULL;
 	const char *template = llvm_param.clang_bpf_cmd_template;
 
<span class="p_add">+	if (path[0] != &#39;-&#39; &amp;&amp; realpath(path, abspath) == NULL) {</span>
<span class="p_add">+		err = errno;</span>
<span class="p_add">+		pr_err(&quot;ERROR: problems with path %s: %s\n&quot;,</span>
<span class="p_add">+		       path, strerror_r(err, serr, sizeof(serr)));</span>
<span class="p_add">+		return -err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!template)
 		template = CLANG_BPF_CMD_DEFAULT_TEMPLATE;
 
<span class="p_chunk">@@ -362,7 +371,7 @@</span> <span class="p_context"> int llvm__compile_bpf(const char *path, void **p_obj_buf,</span>
 	if (nr_cpus_avail &lt;= 0) {
 		pr_err(
 &quot;WARNING:\tunable to get available CPUs in this system: %s\n&quot;
<span class="p_del">-&quot;        \tUse 128 instead.\n&quot;, strerror(errno));</span>
<span class="p_add">+&quot;        \tUse 128 instead.\n&quot;, strerror_r(errno, serr, sizeof(serr)));</span>
 		nr_cpus_avail = 128;
 	}
 	snprintf(nr_cpus_avail_str, sizeof(nr_cpus_avail_str), &quot;%d&quot;,
<span class="p_chunk">@@ -387,8 +396,7 @@</span> <span class="p_context"> int llvm__compile_bpf(const char *path, void **p_obj_buf,</span>
 	 * stdin to be source file (testing).
 	 */
 	force_set_env(&quot;CLANG_SOURCE&quot;,
<span class="p_del">-		      (path[0] == &#39;-&#39;) ? path :</span>
<span class="p_del">-		      make_nonrelative_path(path));</span>
<span class="p_add">+		      (path[0] == &#39;-&#39;) ? path : abspath);</span>
 
 	pr_debug(&quot;llvm compiling command template: %s\n&quot;, template);
 	err = read_from_pipe(template, &amp;obj_buf, &amp;obj_buf_sz);
<span class="p_header">diff --git a/tools/perf/util/llvm-utils.h b/tools/perf/util/llvm-utils.h</span>
<span class="p_header">index 5b3cf1c229e2..23b9a743fe72 100644</span>
<span class="p_header">--- a/tools/perf/util/llvm-utils.h</span>
<span class="p_header">+++ b/tools/perf/util/llvm-utils.h</span>
<span class="p_chunk">@@ -39,11 +39,10 @@</span> <span class="p_context"> struct llvm_param {</span>
 };
 
 extern struct llvm_param llvm_param;
<span class="p_del">-extern int perf_llvm_config(const char *var, const char *value);</span>
<span class="p_add">+int perf_llvm_config(const char *var, const char *value);</span>
 
<span class="p_del">-extern int llvm__compile_bpf(const char *path, void **p_obj_buf,</span>
<span class="p_del">-			     size_t *p_obj_buf_sz);</span>
<span class="p_add">+int llvm__compile_bpf(const char *path, void **p_obj_buf, size_t *p_obj_buf_sz);</span>
 
 /* This function is for test__llvm() use only */
<span class="p_del">-extern int llvm__search_clang(void);</span>
<span class="p_add">+int llvm__search_clang(void);</span>
 #endif
<span class="p_header">diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c</span>
<span class="p_header">index ad79297c76c8..80b9b6a87990 100644</span>
<span class="p_header">--- a/tools/perf/util/machine.c</span>
<span class="p_header">+++ b/tools/perf/util/machine.c</span>
<span class="p_chunk">@@ -1301,9 +1301,8 @@</span> <span class="p_context"> static int machine__process_kernel_mmap_event(struct machine *machine,</span>
 
 int machine__process_mmap2_event(struct machine *machine,
 				 union perf_event *event,
<span class="p_del">-				 struct perf_sample *sample __maybe_unused)</span>
<span class="p_add">+				 struct perf_sample *sample)</span>
 {
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct thread *thread;
 	struct map *map;
 	enum map_type type;
<span class="p_chunk">@@ -1312,8 +1311,8 @@</span> <span class="p_context"> int machine__process_mmap2_event(struct machine *machine,</span>
 	if (dump_trace)
 		perf_event__fprintf_mmap2(event, stdout);
 
<span class="p_del">-	if (cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||</span>
<span class="p_del">-	    cpumode == PERF_RECORD_MISC_KERNEL) {</span>
<span class="p_add">+	if (sample-&gt;cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||</span>
<span class="p_add">+	    sample-&gt;cpumode == PERF_RECORD_MISC_KERNEL) {</span>
 		ret = machine__process_kernel_mmap_event(machine, event);
 		if (ret &lt; 0)
 			goto out_problem;
<span class="p_chunk">@@ -1355,9 +1354,8 @@</span> <span class="p_context"> int machine__process_mmap2_event(struct machine *machine,</span>
 }
 
 int machine__process_mmap_event(struct machine *machine, union perf_event *event,
<span class="p_del">-				struct perf_sample *sample __maybe_unused)</span>
<span class="p_add">+				struct perf_sample *sample)</span>
 {
<span class="p_del">-	u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct thread *thread;
 	struct map *map;
 	enum map_type type;
<span class="p_chunk">@@ -1366,8 +1364,8 @@</span> <span class="p_context"> int machine__process_mmap_event(struct machine *machine, union perf_event *event</span>
 	if (dump_trace)
 		perf_event__fprintf_mmap(event, stdout);
 
<span class="p_del">-	if (cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||</span>
<span class="p_del">-	    cpumode == PERF_RECORD_MISC_KERNEL) {</span>
<span class="p_add">+	if (sample-&gt;cpumode == PERF_RECORD_MISC_GUEST_KERNEL ||</span>
<span class="p_add">+	    sample-&gt;cpumode == PERF_RECORD_MISC_KERNEL) {</span>
 		ret = machine__process_kernel_mmap_event(machine, event);
 		if (ret &lt; 0)
 			goto out_problem;
<span class="p_header">diff --git a/tools/perf/util/machine.h b/tools/perf/util/machine.h</span>
<span class="p_header">index 1a3e45baf97f..8499db281158 100644</span>
<span class="p_header">--- a/tools/perf/util/machine.h</span>
<span class="p_header">+++ b/tools/perf/util/machine.h</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> int machine__process_aux_event(struct machine *machine,</span>
 			       union perf_event *event);
 int machine__process_itrace_start_event(struct machine *machine,
 					union perf_event *event);
<span class="p_del">-int machine__process_switch_event(struct machine *machine __maybe_unused,</span>
<span class="p_add">+int machine__process_switch_event(struct machine *machine,</span>
 				  union perf_event *event);
 int machine__process_mmap_event(struct machine *machine, union perf_event *event,
 				struct perf_sample *sample);
<span class="p_header">diff --git a/tools/perf/util/parse-events.h b/tools/perf/util/parse-events.h</span>
<span class="p_header">index 67e493088e81..d740c3ca9a1d 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.h</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.h</span>
<span class="p_chunk">@@ -22,19 +22,18 @@</span> <span class="p_context"> struct tracepoint_path {</span>
 	struct tracepoint_path *next;
 };
 
<span class="p_del">-extern struct tracepoint_path *tracepoint_id_to_path(u64 config);</span>
<span class="p_del">-extern struct tracepoint_path *tracepoint_name_to_path(const char *name);</span>
<span class="p_del">-extern bool have_tracepoints(struct list_head *evlist);</span>
<span class="p_add">+struct tracepoint_path *tracepoint_id_to_path(u64 config);</span>
<span class="p_add">+struct tracepoint_path *tracepoint_name_to_path(const char *name);</span>
<span class="p_add">+bool have_tracepoints(struct list_head *evlist);</span>
 
 const char *event_type(int type);
 
<span class="p_del">-extern int parse_events_option(const struct option *opt, const char *str,</span>
<span class="p_del">-			       int unset);</span>
<span class="p_del">-extern int parse_events(struct perf_evlist *evlist, const char *str,</span>
<span class="p_del">-			struct parse_events_error *error);</span>
<span class="p_del">-extern int parse_events_terms(struct list_head *terms, const char *str);</span>
<span class="p_del">-extern int parse_filter(const struct option *opt, const char *str, int unset);</span>
<span class="p_del">-extern int exclude_perf(const struct option *opt, const char *arg, int unset);</span>
<span class="p_add">+int parse_events_option(const struct option *opt, const char *str, int unset);</span>
<span class="p_add">+int parse_events(struct perf_evlist *evlist, const char *str,</span>
<span class="p_add">+		 struct parse_events_error *error);</span>
<span class="p_add">+int parse_events_terms(struct list_head *terms, const char *str);</span>
<span class="p_add">+int parse_filter(const struct option *opt, const char *str, int unset);</span>
<span class="p_add">+int exclude_perf(const struct option *opt, const char *arg, int unset);</span>
 
 #define EVENTS_HELP_MAX (128*1024)
 
<span class="p_chunk">@@ -183,7 +182,7 @@</span> <span class="p_context"> void print_symbol_events(const char *event_glob, unsigned type,</span>
 void print_tracepoint_events(const char *subsys_glob, const char *event_glob,
 			     bool name_only);
 int print_hwcache_events(const char *event_glob, bool name_only);
<span class="p_del">-extern int is_valid_tracepoint(const char *event_string);</span>
<span class="p_add">+int is_valid_tracepoint(const char *event_string);</span>
 
 int valid_event_mount(const char *eventfs);
 char *parse_events_formats_error_string(char *additional_terms);
<span class="p_header">diff --git a/tools/perf/util/path.c b/tools/perf/util/path.c</span>
<span class="p_header">index 3654d964e49d..3bf6bf82ff2d 100644</span>
<span class="p_header">--- a/tools/perf/util/path.c</span>
<span class="p_header">+++ b/tools/perf/util/path.c</span>
<span class="p_chunk">@@ -41,36 +41,6 @@</span> <span class="p_context"> static char *cleanup_path(char *path)</span>
 	return path;
 }
 
<span class="p_del">-static char *perf_vsnpath(char *buf, size_t n, const char *fmt, va_list args)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const char *perf_dir = get_perf_dir();</span>
<span class="p_del">-	size_t len;</span>
<span class="p_del">-</span>
<span class="p_del">-	len = strlen(perf_dir);</span>
<span class="p_del">-	if (n &lt; len + 1)</span>
<span class="p_del">-		goto bad;</span>
<span class="p_del">-	memcpy(buf, perf_dir, len);</span>
<span class="p_del">-	if (len &amp;&amp; !is_dir_sep(perf_dir[len-1]))</span>
<span class="p_del">-		buf[len++] = &#39;/&#39;;</span>
<span class="p_del">-	len += vsnprintf(buf + len, n - len, fmt, args);</span>
<span class="p_del">-	if (len &gt;= n)</span>
<span class="p_del">-		goto bad;</span>
<span class="p_del">-	return cleanup_path(buf);</span>
<span class="p_del">-bad:</span>
<span class="p_del">-	strlcpy(buf, bad_path, n);</span>
<span class="p_del">-	return buf;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-char *perf_pathdup(const char *fmt, ...)</span>
<span class="p_del">-{</span>
<span class="p_del">-	char path[PATH_MAX];</span>
<span class="p_del">-	va_list args;</span>
<span class="p_del">-	va_start(args, fmt);</span>
<span class="p_del">-	(void)perf_vsnpath(path, sizeof(path), fmt, args);</span>
<span class="p_del">-	va_end(args);</span>
<span class="p_del">-	return xstrdup(path);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 char *mkpath(const char *fmt, ...)
 {
 	va_list args;
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index 93996ec4bbe3..8319fbb08636 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -2179,7 +2179,7 @@</span> <span class="p_context"> static int perf_probe_event__sprintf(const char *group, const char *event,</span>
 		strbuf_addf(result, &quot; in %s&quot;, module);
 
 	if (pev-&gt;nargs &gt; 0) {
<span class="p_del">-		strbuf_addstr(result, &quot; with&quot;);</span>
<span class="p_add">+		strbuf_add(result, &quot; with&quot;, 5);</span>
 		for (i = 0; i &lt; pev-&gt;nargs; i++) {
 			ret = synthesize_perf_probe_arg(&amp;pev-&gt;args[i],
 							buf, 128);
<span class="p_header">diff --git a/tools/perf/util/probe-event.h b/tools/perf/util/probe-event.h</span>
<span class="p_header">index ba926c30f8cd..e54e7b011577 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.h</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.h</span>
<span class="p_chunk">@@ -114,49 +114,44 @@</span> <span class="p_context"> int init_probe_symbol_maps(bool user_only);</span>
 void exit_probe_symbol_maps(void);
 
 /* Command string to events */
<span class="p_del">-extern int parse_perf_probe_command(const char *cmd,</span>
<span class="p_del">-				    struct perf_probe_event *pev);</span>
<span class="p_del">-extern int parse_probe_trace_command(const char *cmd,</span>
<span class="p_del">-				     struct probe_trace_event *tev);</span>
<span class="p_add">+int parse_perf_probe_command(const char *cmd, struct perf_probe_event *pev);</span>
<span class="p_add">+int parse_probe_trace_command(const char *cmd, struct probe_trace_event *tev);</span>
 
 /* Events to command string */
<span class="p_del">-extern char *synthesize_perf_probe_command(struct perf_probe_event *pev);</span>
<span class="p_del">-extern char *synthesize_probe_trace_command(struct probe_trace_event *tev);</span>
<span class="p_del">-extern int synthesize_perf_probe_arg(struct perf_probe_arg *pa, char *buf,</span>
<span class="p_del">-				     size_t len);</span>
<span class="p_add">+char *synthesize_perf_probe_command(struct perf_probe_event *pev);</span>
<span class="p_add">+char *synthesize_probe_trace_command(struct probe_trace_event *tev);</span>
<span class="p_add">+int synthesize_perf_probe_arg(struct perf_probe_arg *pa, char *buf, size_t len);</span>
 
 /* Check the perf_probe_event needs debuginfo */
<span class="p_del">-extern bool perf_probe_event_need_dwarf(struct perf_probe_event *pev);</span>
<span class="p_add">+bool perf_probe_event_need_dwarf(struct perf_probe_event *pev);</span>
 
 /* Release event contents */
<span class="p_del">-extern void clear_perf_probe_event(struct perf_probe_event *pev);</span>
<span class="p_del">-extern void clear_probe_trace_event(struct probe_trace_event *tev);</span>
<span class="p_add">+void clear_perf_probe_event(struct perf_probe_event *pev);</span>
<span class="p_add">+void clear_probe_trace_event(struct probe_trace_event *tev);</span>
 
 /* Command string to line-range */
<span class="p_del">-extern int parse_line_range_desc(const char *cmd, struct line_range *lr);</span>
<span class="p_add">+int parse_line_range_desc(const char *cmd, struct line_range *lr);</span>
 
 /* Release line range members */
<span class="p_del">-extern void line_range__clear(struct line_range *lr);</span>
<span class="p_add">+void line_range__clear(struct line_range *lr);</span>
 
 /* Initialize line range */
<span class="p_del">-extern int line_range__init(struct line_range *lr);</span>
<span class="p_del">-</span>
<span class="p_del">-extern int add_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_del">-extern int convert_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_del">-extern int apply_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_del">-extern void cleanup_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_del">-extern int del_perf_probe_events(struct strfilter *filter);</span>
<span class="p_del">-</span>
<span class="p_del">-extern int show_perf_probe_event(const char *group, const char *event,</span>
<span class="p_del">-				 struct perf_probe_event *pev,</span>
<span class="p_del">-				 const char *module, bool use_stdout);</span>
<span class="p_del">-extern int show_perf_probe_events(struct strfilter *filter);</span>
<span class="p_del">-extern int show_line_range(struct line_range *lr, const char *module,</span>
<span class="p_del">-			   bool user);</span>
<span class="p_del">-extern int show_available_vars(struct perf_probe_event *pevs, int npevs,</span>
<span class="p_del">-			       struct strfilter *filter);</span>
<span class="p_del">-extern int show_available_funcs(const char *module, struct strfilter *filter,</span>
<span class="p_del">-				bool user);</span>
<span class="p_add">+int line_range__init(struct line_range *lr);</span>
<span class="p_add">+</span>
<span class="p_add">+int add_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_add">+int convert_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_add">+int apply_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_add">+void cleanup_perf_probe_events(struct perf_probe_event *pevs, int npevs);</span>
<span class="p_add">+int del_perf_probe_events(struct strfilter *filter);</span>
<span class="p_add">+</span>
<span class="p_add">+int show_perf_probe_event(const char *group, const char *event,</span>
<span class="p_add">+			  struct perf_probe_event *pev,</span>
<span class="p_add">+			  const char *module, bool use_stdout);</span>
<span class="p_add">+int show_perf_probe_events(struct strfilter *filter);</span>
<span class="p_add">+int show_line_range(struct line_range *lr, const char *module, bool user);</span>
<span class="p_add">+int show_available_vars(struct perf_probe_event *pevs, int npevs,</span>
<span class="p_add">+			struct strfilter *filter);</span>
<span class="p_add">+int show_available_funcs(const char *module, struct strfilter *filter, bool user);</span>
 bool arch__prefers_symtab(void);
 void arch__fix_tev_from_maps(struct perf_probe_event *pev,
 			     struct probe_trace_event *tev, struct map *map);
<span class="p_header">diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c</span>
<span class="p_header">index 4ce5c5e18f48..b3bd0fba0237 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-finder.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-finder.c</span>
<span class="p_chunk">@@ -1314,18 +1314,18 @@</span> <span class="p_context"> static int collect_variables_cb(Dwarf_Die *die_mem, void *data)</span>
 			if (probe_conf.show_location_range) {
 				if (!externs) {
 					if (ret)
<span class="p_del">-						strbuf_addf(&amp;buf, &quot;[INV]\t&quot;);</span>
<span class="p_add">+						strbuf_add(&amp;buf, &quot;[INV]\t&quot;, 6);</span>
 					else
<span class="p_del">-						strbuf_addf(&amp;buf, &quot;[VAL]\t&quot;);</span>
<span class="p_add">+						strbuf_add(&amp;buf, &quot;[VAL]\t&quot;, 6);</span>
 				} else
<span class="p_del">-					strbuf_addf(&amp;buf, &quot;[EXT]\t&quot;);</span>
<span class="p_add">+					strbuf_add(&amp;buf, &quot;[EXT]\t&quot;, 6);</span>
 			}
 
 			ret2 = die_get_varname(die_mem, &amp;buf);
 
 			if (!ret2 &amp;&amp; probe_conf.show_location_range &amp;&amp;
 				!externs) {
<span class="p_del">-				strbuf_addf(&amp;buf, &quot;\t&quot;);</span>
<span class="p_add">+				strbuf_addch(&amp;buf, &#39;\t&#39;);</span>
 				ret2 = die_get_var_range(&amp;af-&gt;pf.sp_die,
 							die_mem, &amp;buf);
 			}
<span class="p_header">diff --git a/tools/perf/util/probe-finder.h b/tools/perf/util/probe-finder.h</span>
<span class="p_header">index 0aec7704e395..51137fccb9c8 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-finder.h</span>
<span class="p_header">+++ b/tools/perf/util/probe-finder.h</span>
<span class="p_chunk">@@ -34,27 +34,25 @@</span> <span class="p_context"> struct debuginfo {</span>
 };
 
 /* This also tries to open distro debuginfo */
<span class="p_del">-extern struct debuginfo *debuginfo__new(const char *path);</span>
<span class="p_del">-extern void debuginfo__delete(struct debuginfo *dbg);</span>
<span class="p_add">+struct debuginfo *debuginfo__new(const char *path);</span>
<span class="p_add">+void debuginfo__delete(struct debuginfo *dbg);</span>
 
 /* Find probe_trace_events specified by perf_probe_event from debuginfo */
<span class="p_del">-extern int debuginfo__find_trace_events(struct debuginfo *dbg,</span>
<span class="p_del">-					struct perf_probe_event *pev,</span>
<span class="p_del">-					struct probe_trace_event **tevs);</span>
<span class="p_add">+int debuginfo__find_trace_events(struct debuginfo *dbg,</span>
<span class="p_add">+				 struct perf_probe_event *pev,</span>
<span class="p_add">+				 struct probe_trace_event **tevs);</span>
 
 /* Find a perf_probe_point from debuginfo */
<span class="p_del">-extern int debuginfo__find_probe_point(struct debuginfo *dbg,</span>
<span class="p_del">-				       unsigned long addr,</span>
<span class="p_del">-				       struct perf_probe_point *ppt);</span>
<span class="p_add">+int debuginfo__find_probe_point(struct debuginfo *dbg, unsigned long addr,</span>
<span class="p_add">+				struct perf_probe_point *ppt);</span>
 
 /* Find a line range */
<span class="p_del">-extern int debuginfo__find_line_range(struct debuginfo *dbg,</span>
<span class="p_del">-				      struct line_range *lr);</span>
<span class="p_add">+int debuginfo__find_line_range(struct debuginfo *dbg, struct line_range *lr);</span>
 
 /* Find available variables */
<span class="p_del">-extern int debuginfo__find_available_vars_at(struct debuginfo *dbg,</span>
<span class="p_del">-					     struct perf_probe_event *pev,</span>
<span class="p_del">-					     struct variable_list **vls);</span>
<span class="p_add">+int debuginfo__find_available_vars_at(struct debuginfo *dbg,</span>
<span class="p_add">+				      struct perf_probe_event *pev,</span>
<span class="p_add">+				      struct variable_list **vls);</span>
 
 /* Find a src file from a DWARF tag path */
 int get_real_path(const char *raw_path, const char *comp_dir,
<span class="p_header">diff --git a/tools/perf/util/quote.h b/tools/perf/util/quote.h</span>
<span class="p_header">index 172889ea234f..3340c9c4a6ca 100644</span>
<span class="p_header">--- a/tools/perf/util/quote.h</span>
<span class="p_header">+++ b/tools/perf/util/quote.h</span>
<span class="p_chunk">@@ -24,6 +24,6 @@</span> <span class="p_context"></span>
  * sq_quote() in a real application.
  */
 
<span class="p_del">-extern void sq_quote_argv(struct strbuf *, const char **argv, size_t maxlen);</span>
<span class="p_add">+void sq_quote_argv(struct strbuf *, const char **argv, size_t maxlen);</span>
 
 #endif /* __PERF_QUOTE_H */
<span class="p_header">diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c</span>
<span class="p_header">index 60b3593d210d..4abd85c6346d 100644</span>
<span class="p_header">--- a/tools/perf/util/session.c</span>
<span class="p_header">+++ b/tools/perf/util/session.c</span>
<span class="p_chunk">@@ -1107,12 +1107,11 @@</span> <span class="p_context"> static struct machine *machines__find_for_cpumode(struct machines *machines,</span>
 					       union perf_event *event,
 					       struct perf_sample *sample)
 {
<span class="p_del">-	const u8 cpumode = event-&gt;header.misc &amp; PERF_RECORD_MISC_CPUMODE_MASK;</span>
 	struct machine *machine;
 
 	if (perf_guest &amp;&amp;
<span class="p_del">-	    ((cpumode == PERF_RECORD_MISC_GUEST_KERNEL) ||</span>
<span class="p_del">-	     (cpumode == PERF_RECORD_MISC_GUEST_USER))) {</span>
<span class="p_add">+	    ((sample-&gt;cpumode == PERF_RECORD_MISC_GUEST_KERNEL) ||</span>
<span class="p_add">+	     (sample-&gt;cpumode == PERF_RECORD_MISC_GUEST_USER))) {</span>
 		u32 pid;
 
 		if (event-&gt;header.type == PERF_RECORD_MMAP
<span class="p_header">diff --git a/tools/perf/util/sort.c b/tools/perf/util/sort.c</span>
<span class="p_header">index 93fa136b0025..47966a1618c7 100644</span>
<span class="p_header">--- a/tools/perf/util/sort.c</span>
<span class="p_header">+++ b/tools/perf/util/sort.c</span>
<span class="p_chunk">@@ -2225,7 +2225,7 @@</span> <span class="p_context"> int hpp_dimension__add_output(unsigned col)</span>
 }
 
 static int sort_dimension__add(struct perf_hpp_list *list, const char *tok,
<span class="p_del">-			       struct perf_evlist *evlist __maybe_unused,</span>
<span class="p_add">+			       struct perf_evlist *evlist,</span>
 			       int level)
 {
 	unsigned int i;
<span class="p_header">diff --git a/tools/perf/util/stat-shadow.c b/tools/perf/util/stat-shadow.c</span>
<span class="p_header">index b33ffb2af2cf..fdb71961143e 100644</span>
<span class="p_header">--- a/tools/perf/util/stat-shadow.c</span>
<span class="p_header">+++ b/tools/perf/util/stat-shadow.c</span>
<span class="p_chunk">@@ -152,8 +152,7 @@</span> <span class="p_context"> static const char *get_ratio_color(enum grc_type type, double ratio)</span>
 }
 
 static void print_stalled_cycles_frontend(int cpu,
<span class="p_del">-					  struct perf_evsel *evsel</span>
<span class="p_del">-					  __maybe_unused, double avg,</span>
<span class="p_add">+					  struct perf_evsel *evsel, double avg,</span>
 					  struct perf_stat_output_ctx *out)
 {
 	double total, ratio = 0.0;
<span class="p_chunk">@@ -175,8 +174,7 @@</span> <span class="p_context"> static void print_stalled_cycles_frontend(int cpu,</span>
 }
 
 static void print_stalled_cycles_backend(int cpu,
<span class="p_del">-					 struct perf_evsel *evsel</span>
<span class="p_del">-					 __maybe_unused, double avg,</span>
<span class="p_add">+					 struct perf_evsel *evsel, double avg,</span>
 					 struct perf_stat_output_ctx *out)
 {
 	double total, ratio = 0.0;
<span class="p_chunk">@@ -194,7 +192,7 @@</span> <span class="p_context"> static void print_stalled_cycles_backend(int cpu,</span>
 }
 
 static void print_branch_misses(int cpu,
<span class="p_del">-				struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				struct perf_evsel *evsel,</span>
 				double avg,
 				struct perf_stat_output_ctx *out)
 {
<span class="p_chunk">@@ -213,7 +211,7 @@</span> <span class="p_context"> static void print_branch_misses(int cpu,</span>
 }
 
 static void print_l1_dcache_misses(int cpu,
<span class="p_del">-				   struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				   struct perf_evsel *evsel,</span>
 				   double avg,
 				   struct perf_stat_output_ctx *out)
 {
<span class="p_chunk">@@ -232,7 +230,7 @@</span> <span class="p_context"> static void print_l1_dcache_misses(int cpu,</span>
 }
 
 static void print_l1_icache_misses(int cpu,
<span class="p_del">-				   struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				   struct perf_evsel *evsel,</span>
 				   double avg,
 				   struct perf_stat_output_ctx *out)
 {
<span class="p_chunk">@@ -250,7 +248,7 @@</span> <span class="p_context"> static void print_l1_icache_misses(int cpu,</span>
 }
 
 static void print_dtlb_cache_misses(int cpu,
<span class="p_del">-				    struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				    struct perf_evsel *evsel,</span>
 				    double avg,
 				    struct perf_stat_output_ctx *out)
 {
<span class="p_chunk">@@ -268,7 +266,7 @@</span> <span class="p_context"> static void print_dtlb_cache_misses(int cpu,</span>
 }
 
 static void print_itlb_cache_misses(int cpu,
<span class="p_del">-				    struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				    struct perf_evsel *evsel,</span>
 				    double avg,
 				    struct perf_stat_output_ctx *out)
 {
<span class="p_chunk">@@ -286,7 +284,7 @@</span> <span class="p_context"> static void print_itlb_cache_misses(int cpu,</span>
 }
 
 static void print_ll_cache_misses(int cpu,
<span class="p_del">-				  struct perf_evsel *evsel __maybe_unused,</span>
<span class="p_add">+				  struct perf_evsel *evsel,</span>
 				  double avg,
 				  struct perf_stat_output_ctx *out)
 {
<span class="p_header">diff --git a/tools/perf/util/strbuf.c b/tools/perf/util/strbuf.c</span>
<span class="p_header">index d3d279275432..8fb73295ec34 100644</span>
<span class="p_header">--- a/tools/perf/util/strbuf.c</span>
<span class="p_header">+++ b/tools/perf/util/strbuf.c</span>
<span class="p_chunk">@@ -51,6 +51,13 @@</span> <span class="p_context"> void strbuf_grow(struct strbuf *sb, size_t extra)</span>
 	ALLOC_GROW(sb-&gt;buf, sb-&gt;len + extra + 1, sb-&gt;alloc);
 }
 
<span class="p_add">+void strbuf_addch(struct strbuf *sb, int c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	strbuf_grow(sb, 1);</span>
<span class="p_add">+	sb-&gt;buf[sb-&gt;len++] = c;</span>
<span class="p_add">+	sb-&gt;buf[sb-&gt;len] = &#39;\0&#39;;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void strbuf_add(struct strbuf *sb, const void *data, size_t len)
 {
 	strbuf_grow(sb, len);
<span class="p_chunk">@@ -58,7 +65,7 @@</span> <span class="p_context"> void strbuf_add(struct strbuf *sb, const void *data, size_t len)</span>
 	strbuf_setlen(sb, sb-&gt;len + len);
 }
 
<span class="p_del">-void strbuf_addv(struct strbuf *sb, const char *fmt, va_list ap)</span>
<span class="p_add">+static void strbuf_addv(struct strbuf *sb, const char *fmt, va_list ap)</span>
 {
 	int len;
 	va_list ap_saved;
<span class="p_header">diff --git a/tools/perf/util/strbuf.h b/tools/perf/util/strbuf.h</span>
<span class="p_header">index 7a32c838884d..ab9be0fbbd40 100644</span>
<span class="p_header">--- a/tools/perf/util/strbuf.h</span>
<span class="p_header">+++ b/tools/perf/util/strbuf.h</span>
<span class="p_chunk">@@ -51,16 +51,16 @@</span> <span class="p_context"> struct strbuf {</span>
 #define STRBUF_INIT  { 0, 0, strbuf_slopbuf }
 
 /*----- strbuf life cycle -----*/
<span class="p_del">-extern void strbuf_init(struct strbuf *buf, ssize_t hint);</span>
<span class="p_del">-extern void strbuf_release(struct strbuf *);</span>
<span class="p_del">-extern char *strbuf_detach(struct strbuf *, size_t *);</span>
<span class="p_add">+void strbuf_init(struct strbuf *buf, ssize_t hint);</span>
<span class="p_add">+void strbuf_release(struct strbuf *buf);</span>
<span class="p_add">+char *strbuf_detach(struct strbuf *buf, size_t *);</span>
 
 /*----- strbuf size related -----*/
 static inline ssize_t strbuf_avail(const struct strbuf *sb) {
 	return sb-&gt;alloc ? sb-&gt;alloc - sb-&gt;len - 1 : 0;
 }
 
<span class="p_del">-extern void strbuf_grow(struct strbuf *, size_t);</span>
<span class="p_add">+void strbuf_grow(struct strbuf *buf, size_t);</span>
 
 static inline void strbuf_setlen(struct strbuf *sb, size_t len) {
 	if (!sb-&gt;alloc)
<span class="p_chunk">@@ -71,22 +71,17 @@</span> <span class="p_context"> static inline void strbuf_setlen(struct strbuf *sb, size_t len) {</span>
 }
 
 /*----- add data in your buffer -----*/
<span class="p_del">-static inline void strbuf_addch(struct strbuf *sb, int c) {</span>
<span class="p_del">-	strbuf_grow(sb, 1);</span>
<span class="p_del">-	sb-&gt;buf[sb-&gt;len++] = c;</span>
<span class="p_del">-	sb-&gt;buf[sb-&gt;len] = &#39;\0&#39;;</span>
<span class="p_del">-}</span>
<span class="p_add">+void strbuf_addch(struct strbuf *sb, int c);</span>
 
<span class="p_del">-extern void strbuf_add(struct strbuf *, const void *, size_t);</span>
<span class="p_add">+void strbuf_add(struct strbuf *buf, const void *, size_t);</span>
 static inline void strbuf_addstr(struct strbuf *sb, const char *s) {
 	strbuf_add(sb, s, strlen(s));
 }
 
 __attribute__((format(printf,2,3)))
<span class="p_del">-extern void strbuf_addf(struct strbuf *sb, const char *fmt, ...);</span>
<span class="p_del">-extern void strbuf_addv(struct strbuf *sb, const char *fmt, va_list ap);</span>
<span class="p_add">+void strbuf_addf(struct strbuf *sb, const char *fmt, ...);</span>
 
 /* XXX: if read fails, any partial read is undone */
<span class="p_del">-extern ssize_t strbuf_read(struct strbuf *, int fd, ssize_t hint);</span>
<span class="p_add">+ssize_t strbuf_read(struct strbuf *, int fd, ssize_t hint);</span>
 
 #endif /* __PERF_STRBUF_H */
<span class="p_header">diff --git a/tools/perf/util/svghelper.h b/tools/perf/util/svghelper.h</span>
<span class="p_header">index 9292a5291445..946fdf2db97c 100644</span>
<span class="p_header">--- a/tools/perf/util/svghelper.h</span>
<span class="p_header">+++ b/tools/perf/util/svghelper.h</span>
<span class="p_chunk">@@ -3,32 +3,31 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 
<span class="p_del">-extern void open_svg(const char *filename, int cpus, int rows, u64 start, u64 end);</span>
<span class="p_del">-extern void svg_ubox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_del">-extern void svg_lbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_del">-extern void svg_fbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_del">-extern void svg_box(int Yslot, u64 start, u64 end, const char *type);</span>
<span class="p_del">-extern void svg_blocked(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_del">-extern void svg_running(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_del">-extern void svg_waiting(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_del">-extern void svg_cpu_box(int cpu, u64 max_frequency, u64 turbo_frequency);</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-extern void svg_process(int cpu, u64 start, u64 end, int pid, const char *name, const char *backtrace);</span>
<span class="p_del">-extern void svg_cstate(int cpu, u64 start, u64 end, int type);</span>
<span class="p_del">-extern void svg_pstate(int cpu, u64 start, u64 end, u64 freq);</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-extern void svg_time_grid(double min_thickness);</span>
<span class="p_del">-extern void svg_io_legenda(void);</span>
<span class="p_del">-extern void svg_legenda(void);</span>
<span class="p_del">-extern void svg_wakeline(u64 start, int row1, int row2, const char *backtrace);</span>
<span class="p_del">-extern void svg_partial_wakeline(u64 start, int row1, char *desc1, int row2, char *desc2, const char *backtrace);</span>
<span class="p_del">-extern void svg_interrupt(u64 start, int row, const char *backtrace);</span>
<span class="p_del">-extern void svg_text(int Yslot, u64 start, const char *text);</span>
<span class="p_del">-extern void svg_close(void);</span>
<span class="p_del">-extern int svg_build_topology_map(char *sib_core, int sib_core_nr,</span>
<span class="p_del">-				  char *sib_thr, int sib_thr_nr);</span>
<span class="p_add">+void open_svg(const char *filename, int cpus, int rows, u64 start, u64 end);</span>
<span class="p_add">+void svg_ubox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_add">+void svg_lbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_add">+void svg_fbox(int Yslot, u64 start, u64 end, double height, const char *type, int fd, int err, int merges);</span>
<span class="p_add">+void svg_box(int Yslot, u64 start, u64 end, const char *type);</span>
<span class="p_add">+void svg_blocked(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_add">+void svg_running(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_add">+void svg_waiting(int Yslot, int cpu, u64 start, u64 end, const char *backtrace);</span>
<span class="p_add">+void svg_cpu_box(int cpu, u64 max_frequency, u64 turbo_frequency);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void svg_process(int cpu, u64 start, u64 end, int pid, const char *name, const char *backtrace);</span>
<span class="p_add">+void svg_cstate(int cpu, u64 start, u64 end, int type);</span>
<span class="p_add">+void svg_pstate(int cpu, u64 start, u64 end, u64 freq);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void svg_time_grid(double min_thickness);</span>
<span class="p_add">+void svg_io_legenda(void);</span>
<span class="p_add">+void svg_legenda(void);</span>
<span class="p_add">+void svg_wakeline(u64 start, int row1, int row2, const char *backtrace);</span>
<span class="p_add">+void svg_partial_wakeline(u64 start, int row1, char *desc1, int row2, char *desc2, const char *backtrace);</span>
<span class="p_add">+void svg_interrupt(u64 start, int row, const char *backtrace);</span>
<span class="p_add">+void svg_text(int Yslot, u64 start, const char *text);</span>
<span class="p_add">+void svg_close(void);</span>
<span class="p_add">+int svg_build_topology_map(char *sib_core, int sib_core_nr, char *sib_thr, int sib_thr_nr);</span>
 
 extern int svg_page_width;
 extern u64 svg_highlight;
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index b1dd68f358fc..bc229a74c6a9 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -793,6 +793,7 @@</span> <span class="p_context"> int dso__load_sym(struct dso *dso, struct map *map,</span>
 	uint32_t idx;
 	GElf_Ehdr ehdr;
 	GElf_Shdr shdr;
<span class="p_add">+	GElf_Shdr tshdr;</span>
 	Elf_Data *syms, *opddata = NULL;
 	GElf_Sym sym;
 	Elf_Scn *sec, *sec_strndx;
<span class="p_chunk">@@ -832,6 +833,9 @@</span> <span class="p_context"> int dso__load_sym(struct dso *dso, struct map *map,</span>
 	sec = syms_ss-&gt;symtab;
 	shdr = syms_ss-&gt;symshdr;
 
<span class="p_add">+	if (elf_section_by_name(elf, &amp;ehdr, &amp;tshdr, &quot;.text&quot;, NULL))</span>
<span class="p_add">+		dso-&gt;text_offset = tshdr.sh_addr - tshdr.sh_offset;</span>
<span class="p_add">+</span>
 	if (runtime_ss-&gt;opdsec)
 		opddata = elf_rawdata(runtime_ss-&gt;opdsec, NULL);
 
<span class="p_chunk">@@ -880,12 +884,8 @@</span> <span class="p_context"> int dso__load_sym(struct dso *dso, struct map *map,</span>
 	 * Handle any relocation of vdso necessary because older kernels
 	 * attempted to prelink vdso to its virtual address.
 	 */
<span class="p_del">-	if (dso__is_vdso(dso)) {</span>
<span class="p_del">-		GElf_Shdr tshdr;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (elf_section_by_name(elf, &amp;ehdr, &amp;tshdr, &quot;.text&quot;, NULL))</span>
<span class="p_del">-			map-&gt;reloc = map-&gt;start - tshdr.sh_addr + tshdr.sh_offset;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (dso__is_vdso(dso))</span>
<span class="p_add">+		map-&gt;reloc = map-&gt;start - dso-&gt;text_offset;</span>
 
 	dso-&gt;adjust_symbols = runtime_ss-&gt;adjust_symbols || ref_reloc(kmap);
 	/*
<span class="p_header">diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h</span>
<span class="p_header">index a937053a0ae0..c8b7544d9267 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.h</span>
<span class="p_header">+++ b/tools/perf/util/symbol.h</span>
<span class="p_chunk">@@ -34,8 +34,8 @@</span> <span class="p_context"></span>
 #endif
 
 #ifdef HAVE_LIBELF_SUPPORT
<span class="p_del">-extern Elf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,</span>
<span class="p_del">-				GElf_Shdr *shp, const char *name, size_t *idx);</span>
<span class="p_add">+Elf_Scn *elf_section_by_name(Elf *elf, GElf_Ehdr *ep,</span>
<span class="p_add">+			     GElf_Shdr *shp, const char *name, size_t *idx);</span>
 #endif
 
 #ifndef DMGL_PARAMS
<span class="p_header">diff --git a/tools/perf/util/usage.c b/tools/perf/util/usage.c</span>
<span class="p_header">index 6adfa18cdd4e..996046a66fe5 100644</span>
<span class="p_header">--- a/tools/perf/util/usage.c</span>
<span class="p_header">+++ b/tools/perf/util/usage.c</span>
<span class="p_chunk">@@ -41,15 +41,9 @@</span> <span class="p_context"> static void warn_builtin(const char *warn, va_list params)</span>
 /* If we are in a dlopen()ed .so write to a global variable would segfault
  * (ugh), so keep things static. */
 static void (*usage_routine)(const char *err) NORETURN = usage_builtin;
<span class="p_del">-static void (*die_routine)(const char *err, va_list params) NORETURN = die_builtin;</span>
 static void (*error_routine)(const char *err, va_list params) = error_builtin;
 static void (*warn_routine)(const char *err, va_list params) = warn_builtin;
 
<span class="p_del">-void set_die_routine(void (*routine)(const char *err, va_list params) NORETURN)</span>
<span class="p_del">-{</span>
<span class="p_del">-	die_routine = routine;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void set_warning_routine(void (*routine)(const char *err, va_list params))
 {
 	warn_routine = routine;
<span class="p_chunk">@@ -65,7 +59,7 @@</span> <span class="p_context"> void die(const char *err, ...)</span>
 	va_list params;
 
 	va_start(params, err);
<span class="p_del">-	die_routine(err, params);</span>
<span class="p_add">+	die_builtin(err, params);</span>
 	va_end(params);
 }
 
<span class="p_header">diff --git a/tools/perf/util/util.h b/tools/perf/util/util.h</span>
<span class="p_header">index d0d50cef8b2a..8298d607c738 100644</span>
<span class="p_header">--- a/tools/perf/util/util.h</span>
<span class="p_header">+++ b/tools/perf/util/util.h</span>
<span class="p_chunk">@@ -133,25 +133,15 @@</span> <span class="p_context"> extern char buildid_dir[];</span>
 #define PERF_GTK_DSO  &quot;libperf-gtk.so&quot;
 
 /* General helper functions */
<span class="p_del">-extern void usage(const char *err) NORETURN;</span>
<span class="p_del">-extern void die(const char *err, ...) NORETURN __attribute__((format (printf, 1, 2)));</span>
<span class="p_del">-extern int error(const char *err, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_del">-extern void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_add">+void usage(const char *err) NORETURN;</span>
<span class="p_add">+void die(const char *err, ...) NORETURN __attribute__((format (printf, 1, 2)));</span>
<span class="p_add">+int error(const char *err, ...) __attribute__((format (printf, 1, 2)));</span>
<span class="p_add">+void warning(const char *err, ...) __attribute__((format (printf, 1, 2)));</span>
 
<span class="p_del">-#include &quot;../../../include/linux/stringify.h&quot;</span>
<span class="p_add">+void set_warning_routine(void (*routine)(const char *err, va_list params));</span>
 
<span class="p_del">-#define DIE_IF(cnd)	\</span>
<span class="p_del">-	do { if (cnd)	\</span>
<span class="p_del">-		die(&quot; at (&quot; __FILE__ &quot;:&quot; __stringify(__LINE__) &quot;): &quot;	\</span>
<span class="p_del">-		    __stringify(cnd) &quot;\n&quot;);				\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-extern void set_die_routine(void (*routine)(const char *err, va_list params) NORETURN);</span>
<span class="p_del">-extern void set_warning_routine(void (*routine)(const char *err, va_list params));</span>
<span class="p_del">-</span>
<span class="p_del">-extern int prefixcmp(const char *str, const char *prefix);</span>
<span class="p_del">-extern void set_buildid_dir(const char *dir);</span>
<span class="p_add">+int prefixcmp(const char *str, const char *prefix);</span>
<span class="p_add">+void set_buildid_dir(const char *dir);</span>
 
 #ifdef __GLIBC_PREREQ
 #if __GLIBC_PREREQ(2, 1)
<span class="p_chunk">@@ -172,8 +162,7 @@</span> <span class="p_context"> static inline char *gitstrchrnul(const char *s, int c)</span>
 /*
  * Wrappers:
  */
<span class="p_del">-extern char *xstrdup(const char *str);</span>
<span class="p_del">-extern void *xrealloc(void *ptr, size_t size) __attribute__((weak));</span>
<span class="p_add">+void *xrealloc(void *ptr, size_t size) __attribute__((weak));</span>
 
 
 static inline void *zalloc(size_t size)
<span class="p_header">diff --git a/tools/perf/util/wrapper.c b/tools/perf/util/wrapper.c</span>
<span class="p_header">index 19f15b650703..5f1a07c4b87b 100644</span>
<span class="p_header">--- a/tools/perf/util/wrapper.c</span>
<span class="p_header">+++ b/tools/perf/util/wrapper.c</span>
<span class="p_chunk">@@ -12,18 +12,6 @@</span> <span class="p_context"> static inline void release_pack_memory(size_t size __maybe_unused,</span>
 {
 }
 
<span class="p_del">-char *xstrdup(const char *str)</span>
<span class="p_del">-{</span>
<span class="p_del">-	char *ret = strdup(str);</span>
<span class="p_del">-	if (!ret) {</span>
<span class="p_del">-		release_pack_memory(strlen(str) + 1, -1);</span>
<span class="p_del">-		ret = strdup(str);</span>
<span class="p_del">-		if (!ret)</span>
<span class="p_del">-			die(&quot;Out of memory, strdup failed&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void *xrealloc(void *ptr, size_t size)
 {
 	void *ret = realloc(ptr, size);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



