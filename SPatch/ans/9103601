
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] EFI changes for v4.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] EFI changes for v4.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 16, 2016, 2:43 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160516144311.GA22487@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9103601/mbox/"
   >mbox</a>
|
   <a href="/patch/9103601/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9103601/">/patch/9103601/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 167189F1D3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 May 2016 14:43:48 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 9F865202A1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 May 2016 14:43:41 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 6584C2026C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 May 2016 14:43:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753871AbcEPOn1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 16 May 2016 10:43:27 -0400
Received: from mail-wm0-f67.google.com ([74.125.82.67]:33927 &quot;EHLO
	mail-wm0-f67.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752812AbcEPOnX (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 16 May 2016 10:43:23 -0400
Received: by mail-wm0-f67.google.com with SMTP id n129so18573199wmn.1
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 16 May 2016 07:43:22 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=N4FSqPpZ1aIZmeaI1oCIZTsXbULWHO8It4gcQElGszk=;
	b=ZDVmwE5HQdXKyN2yoQz+sroChvRHkTs7OCLB+znU5GlQtb0yF3dfWx/DQoWrFrTdrd
	DHN8XMBS+fQXFyWFd13trdFwdAhTxStdau8R3zPNt/rcia5gZZHqsxO4wsbdhsmaJ3Sv
	vTLO2703eM1jwGU1fXsnpLeofjD01x/yYARukc+rhhOP7KzDE1s9+sG4mj5ziUMvJtfu
	hYOwK/c1j+ApAtPvGp9mOr1gaKLNb7cqOqP4wPR9AyfftRvK23NK7OtYrOy56YgdcyhQ
	n9pzibuasmC4ybLoaOwEwUtGegLsnSNAbjkU/bCRCcO+jWaHd2hobJItxqW4Licpniwo
	ndLw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=N4FSqPpZ1aIZmeaI1oCIZTsXbULWHO8It4gcQElGszk=;
	b=PAtWv8fHQ8xbDq1JZhIW3hUCoyNHtz2rqxM1Gaw8fv1drQzyIgUb6QE3B2vxExyxPb
	Tkc2G+kocMKjUxf/ZH3sBdhQQ7go3o7i83s5cEpACoopz6h/6vvCj0XnFr1Fs8fyo/+z
	ZxE2fBat7kRojXHubsxLntQ25rM10Gk06AXevf/H/udnNobFicps3Zws4chldJbxu//G
	/n778FLPWhvTpsKdeJ3XgWWcImpVzpZgIBAxp7z9QYog5FT/RckWoKHHkxkE5khPv8XR
	Ce3/fV9Kl9rcFIw5iz19t9dYgziXN+fNqqrHZC6PaEynrk0dvlOZdEd8jeNoq8BwyVaJ
	FDNQ==
X-Gm-Message-State: AOPr4FWu3PWpf0YvExem9VVlz3c6/vSvAQptcoZzQxm53SmWERm7b1K6g0ot1g64YZnG4A==
X-Received: by 10.28.11.82 with SMTP id 79mr17994303wml.33.1463409796366;
	Mon, 16 May 2016 07:43:16 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	i3sm34104252wjx.30.2016.05.16.07.43.14
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 16 May 2016 07:43:15 -0700 (PDT)
Date: Mon, 16 May 2016 16:43:11 +0200
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Borislav Petkov &lt;bp@alien8.de&gt;
Subject: [GIT PULL] EFI changes for v4.7
Message-ID: &lt;20160516144311.GA22487@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.2 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,RP_MATCHES_RCVD,T_DKIM_INVALID,UNPARSEABLE_RELAY
	autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - May 16, 2016, 2:43 p.m.</div>
<pre class="content">
Linus,

Please pull the latest efi-core-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git efi-core-for-linus

   # HEAD: 6c5450ef66816216e574885cf8d3ddb31ef77428 efivarfs: Make efivarfs_file_ioctl() static

The main changes in this cycle were:

 * Drop the unused EFI_SYSTEM_TABLES efi.flags bit and ensure the
   ARM/arm64 EFI System Table mapping is read-only (Ard Biesheuvel)

 * Add a comment to explain that one of the code paths in the x86/pat
   code is only executed for EFI boot (Matt Fleming)

 * Improve Secure Boot status checks on arm64 and handle unexpected
   errors (Linn Crosetto)

 * Remove the global EFI memory map variable &#39;memmap&#39; as the same
   information is already available in efi::memmap (Matt Fleming)

 * Add EFI Memory Attribute table support for ARM/arm64 (Ard Biesheuvel)

 * Add EFI GOP framebuffer support for ARM/arm64 (Ard Biesheuvel)

 * Add EFI Bootloader Control driver for storing reboot(2) data in EFI
   variables for consumption by bootloaders (Jeremy Compostella)

 * Add Core EFI capsule support (Matt Fleming)

 * Add EFI capsule char driver (Kweh, Hock Leong)

 * Unify EFI memory map code for ARM and arm64 (Ard Biesheuvel)

 * Add generic EFI support for detecting when firmware corrupts CPU
   status register bits (like IRQ flags) when performing EFI runtime
   service calls (Mark Rutland)

 * ... other misc cleanups.

 Thanks,

	Ingo

------------------&gt;
Ard Biesheuvel (19):
      efi: Get rid of the EFI_SYSTEM_TABLES status bit
      efi/arm*: Drop writable mapping of the UEFI System table
      efi: Check EFI_MEMORY_DESCRIPTOR version explicitly
      efi/arm*: Use memremap() to create the persistent memmap mapping
      ARM/efi: Apply strict permissions for UEFI Runtime Services regions
      arm64/efi: Apply strict permissions to UEFI Runtime Services regions
      efi: Add support for the EFI_MEMORY_ATTRIBUTES_TABLE config table
      efi: Implement generic support for the Memory Attributes table
      efi/arm*: Take the Memory Attributes table into account
      x86/efi: Prepare GOP handling code for reuse as generic code
      efi/libstub: Move Graphics Output Protocol handling to generic code
      x86/efi/efifb: Move DMI based quirks handling out of generic code
      efifb: Use builtin_platform_driver and drop unused includes
      arm64/efi/libstub: Make screen_info accessible to the UEFI stub
      efi/arm/libstub: Make screen_info accessible to the UEFI stub
      efi/arm*/libstub: Wire up GOP protocol to &#39;struct screen_info&#39;
      efi/arm*: Wire up &#39;struct screen_info&#39; to efi-framebuffer platform device
      efifb: Enable the efi-framebuffer platform driver for ARM and arm64
      efi/arm-init: Reserve rather than unmap the memory map for ARM as well

Compostella, Jeremy (1):
      efibc: Add EFI Bootloader Control module

Ingo Molnar (1):
      efi: Remove unnecessary (and buggy) .memmap initialization from the Xen EFI driver

Jeremy Compostella (1):
      efibc: Fix excessive stack footprint warning

Julia Lawall (1):
      efi: Merge boolean flag arguments

Kweh, Hock Leong (1):
      efi: Add misc char driver interface to update EFI firmware

Linn Crosetto (2):
      efi/arm64: Report unexpected errors when determining Secure Boot status
      efi/arm64: Check SetupMode when determining Secure Boot status

Mark Rutland (10):
      efi/runtime-wrappers: Add {__,}efi_call_virt() templates
      arm64/efi: Move to generic {__,}efi_call_virt()
      arm/efi: Move to generic {__,}efi_call_virt()
      x86/efi: Move to generic {__,}efi_call_virt()
      efi/runtime-wrappers: Remove redundant #ifdefs
      efi/runtime-wrappers: Detect firmware IRQ flag corruption
      arm64/efi: Enable runtime call flag checking
      arm/efi: Enable runtime call flag checking
      x86/efi: Enable runtime call flag checking
      efi/runtime-wrappers: Remove ARCH_EFI_IRQ_FLAGS_MASK #ifdef

Matt Fleming (9):
      x86/mm/pat: Document the (currently) EFI-only code path
      efi: Iterate over efi.memmap in for_each_efi_memory_desc()
      efi: Remove global &#39;memmap&#39; EFI memory map
      x86/efi: Remove the always true EFI_DEBUG symbol
      efi: Move efi_status_to_err() to drivers/firmware/efi/
      efi: Add &#39;capsule&#39; update support
      x86/efi: Force EFI reboot to process pending capsules
      efi/capsule: Make efi_capsule_pending() lockless
      efi/capsule: Move &#39;capsule&#39; to the stack in efi_capsule_supported()

Peter Jones (1):
      efivarfs: Make efivarfs_file_ioctl() static


 arch/arm/include/asm/efi.h                     |  37 +--
 arch/arm/kernel/efi.c                          |  41 +++
 arch/arm/kernel/setup.c                        |   3 +-
 arch/arm64/include/asm/efi.h                   |  37 +--
 arch/arm64/kernel/efi.c                        |  57 +++-
 arch/arm64/kernel/image.h                      |   1 +
 arch/ia64/kernel/efi.c                         |   2 -
 arch/x86/boot/compressed/eboot.c               | 308 +--------------------
 arch/x86/boot/compressed/eboot.h               |  74 ------
 arch/x86/include/asm/efi.h                     |  52 ++--
 arch/x86/kernel/reboot.c                       |   9 +
 arch/x86/kernel/sysfb_efi.c                    |  15 ++
 arch/x86/mm/pageattr.c                         |   8 +-
 arch/x86/platform/efi/efi.c                    | 133 +++++-----
 arch/x86/platform/efi/efi_64.c                 |  10 +-
 arch/x86/platform/efi/quirks.c                 |  10 +-
 drivers/firmware/efi/Kconfig                   |  25 ++
 drivers/firmware/efi/Makefile                  |   5 +-
 drivers/firmware/efi/arm-init.c                |  96 +++++--
 drivers/firmware/efi/arm-runtime.c             |  45 ++--
 drivers/firmware/efi/capsule-loader.c          | 343 ++++++++++++++++++++++++
 drivers/firmware/efi/capsule.c                 | 308 +++++++++++++++++++++
 drivers/firmware/efi/efi.c                     |  48 +++-
 drivers/firmware/efi/efibc.c                   | 113 ++++++++
 drivers/firmware/efi/efivars.c                 |   5 +-
 drivers/firmware/efi/fake_mem.c                |  43 ++-
 drivers/firmware/efi/libstub/Makefile          |   2 +-
 drivers/firmware/efi/libstub/arm-stub.c        |  77 +++++-
 drivers/firmware/efi/libstub/arm32-stub.c      |  37 +++
 drivers/firmware/efi/libstub/efi-stub-helper.c |   6 +-
 drivers/firmware/efi/libstub/gop.c             | 354 +++++++++++++++++++++++++
 drivers/firmware/efi/memattr.c                 | 182 +++++++++++++
 drivers/firmware/efi/reboot.c                  |  12 +-
 drivers/firmware/efi/runtime-wrappers.c        |  60 +++++
 drivers/firmware/efi/vars.c                    |  56 +---
 drivers/video/fbdev/Kconfig                    |   2 +-
 drivers/video/fbdev/efifb.c                    |  21 +-
 drivers/xen/efi.c                              |   1 -
 fs/efivarfs/file.c                             |   2 +-
 fs/efivarfs/super.c                            |   3 +-
 include/linux/efi.h                            | 167 +++++++++++-
 41 files changed, 2097 insertions(+), 713 deletions(-)
 create mode 100644 drivers/firmware/efi/capsule-loader.c
 create mode 100644 drivers/firmware/efi/capsule.c
 create mode 100644 drivers/firmware/efi/efibc.c
 create mode 100644 drivers/firmware/efi/libstub/gop.c
 create mode 100644 drivers/firmware/efi/memattr.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/include/asm/efi.h b/arch/arm/include/asm/efi.h</span>
<span class="p_header">index e0eea72deb87..a708fa1f0905 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/efi.h</span>
<span class="p_chunk">@@ -17,34 +17,28 @@</span> <span class="p_context"></span>
 #include &lt;asm/mach/map.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
 
 #ifdef CONFIG_EFI
 void efi_init(void);
 
 int efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md);
<span class="p_add">+int efi_set_mapping_permissions(struct mm_struct *mm, efi_memory_desc_t *md);</span>
 
<span class="p_del">-#define efi_call_virt(f, ...)						\</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	efi_##f##_t *__f;						\</span>
<span class="p_del">-	efi_status_t __s;						\</span>
<span class="p_del">-									\</span>
<span class="p_del">-	efi_virtmap_load();						\</span>
<span class="p_del">-	__f = efi.systab-&gt;runtime-&gt;f;					\</span>
<span class="p_del">-	__s = __f(__VA_ARGS__);						\</span>
<span class="p_del">-	efi_virtmap_unload();						\</span>
<span class="p_del">-	__s;								\</span>
<span class="p_del">-})</span>
<span class="p_add">+#define arch_efi_call_virt_setup()	efi_virtmap_load()</span>
<span class="p_add">+#define arch_efi_call_virt_teardown()	efi_virtmap_unload()</span>
 
<span class="p_del">-#define __efi_call_virt(f, ...)						\</span>
<span class="p_add">+#define arch_efi_call_virt(f, args...)					\</span>
 ({									\
 	efi_##f##_t *__f;						\
<span class="p_del">-									\</span>
<span class="p_del">-	efi_virtmap_load();						\</span>
 	__f = efi.systab-&gt;runtime-&gt;f;					\
<span class="p_del">-	__f(__VA_ARGS__);						\</span>
<span class="p_del">-	efi_virtmap_unload();						\</span>
<span class="p_add">+	__f(args);							\</span>
 })
 
<span class="p_add">+#define ARCH_EFI_IRQ_FLAGS_MASK \</span>
<span class="p_add">+	(PSR_J_BIT | PSR_E_BIT | PSR_A_BIT | PSR_I_BIT | PSR_F_BIT | \</span>
<span class="p_add">+	 PSR_T_BIT | MODE_MASK)</span>
<span class="p_add">+</span>
 static inline void efi_set_pgd(struct mm_struct *mm)
 {
 	check_and_switch_context(mm, NULL);
<span class="p_chunk">@@ -59,7 +53,16 @@</span> <span class="p_context"> void efi_virtmap_unload(void);</span>
 
 /* arch specific definitions used by the stub code */
 
<span class="p_del">-#define efi_call_early(f, ...) sys_table_arg-&gt;boottime-&gt;f(__VA_ARGS__)</span>
<span class="p_add">+#define efi_call_early(f, ...)		sys_table_arg-&gt;boottime-&gt;f(__VA_ARGS__)</span>
<span class="p_add">+#define __efi_call_early(f, ...)	f(__VA_ARGS__)</span>
<span class="p_add">+#define efi_is_64bit()			(false)</span>
<span class="p_add">+</span>
<span class="p_add">+struct screen_info *alloc_screen_info(efi_system_table_t *sys_table_arg);</span>
<span class="p_add">+void free_screen_info(efi_system_table_t *sys_table, struct screen_info *si);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void efifb_setup_from_dmi(struct screen_info *si, const char *opt)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 
 /*
  * A reasonable upper bound for the uncompressed kernel size is 32 MBytes,
<span class="p_header">diff --git a/arch/arm/kernel/efi.c b/arch/arm/kernel/efi.c</span>
<span class="p_header">index ff8a9d8acfac..9f43ba012d10 100644</span>
<span class="p_header">--- a/arch/arm/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm/kernel/efi.c</span>
<span class="p_chunk">@@ -11,6 +11,41 @@</span> <span class="p_context"></span>
 #include &lt;asm/mach/map.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 
<span class="p_add">+static int __init set_permissions(pte_t *ptep, pgtable_t token,</span>
<span class="p_add">+				  unsigned long addr, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_memory_desc_t *md = data;</span>
<span class="p_add">+	pte_t pte = *ptep;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (md-&gt;attribute &amp; EFI_MEMORY_RO)</span>
<span class="p_add">+		pte = set_pte_bit(pte, __pgprot(L_PTE_RDONLY));</span>
<span class="p_add">+	if (md-&gt;attribute &amp; EFI_MEMORY_XP)</span>
<span class="p_add">+		pte = set_pte_bit(pte, __pgprot(L_PTE_XN));</span>
<span class="p_add">+	set_pte_ext(ptep, pte, PTE_EXT_NG);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __init efi_set_mapping_permissions(struct mm_struct *mm,</span>
<span class="p_add">+				       efi_memory_desc_t *md)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long base, size;</span>
<span class="p_add">+</span>
<span class="p_add">+	base = md-&gt;virt_addr;</span>
<span class="p_add">+	size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can only use apply_to_page_range() if we can guarantee that the</span>
<span class="p_add">+	 * entire region was mapped using pages. This should be the case if the</span>
<span class="p_add">+	 * region does not cover any naturally aligned SECTION_SIZE sized</span>
<span class="p_add">+	 * blocks.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (round_down(base + size, SECTION_SIZE) &lt;</span>
<span class="p_add">+	    round_up(base, SECTION_SIZE) + SECTION_SIZE)</span>
<span class="p_add">+		return apply_to_page_range(mm, base, size, set_permissions, md);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __init efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md)
 {
 	struct map_desc desc = {
<span class="p_chunk">@@ -34,5 +69,11 @@</span> <span class="p_context"> int __init efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md)</span>
 		desc.type = MT_DEVICE;
 
 	create_mapping_late(mm, &amp;desc, true);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If stricter permissions were specified, apply them now.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (md-&gt;attribute &amp; (EFI_MEMORY_RO | EFI_MEMORY_XP))</span>
<span class="p_add">+		return efi_set_mapping_permissions(mm, md);</span>
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</span>
<span class="p_header">index 2c4bea39cf22..7d4e2850910c 100644</span>
<span class="p_header">--- a/arch/arm/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm/kernel/setup.c</span>
<span class="p_chunk">@@ -883,7 +883,8 @@</span> <span class="p_context"> static void __init request_standard_resources(const struct machine_desc *mdesc)</span>
 		request_resource(&amp;ioport_resource, &amp;lp2);
 }
 
<span class="p_del">-#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE)</span>
<span class="p_add">+#if defined(CONFIG_VGA_CONSOLE) || defined(CONFIG_DUMMY_CONSOLE) || \</span>
<span class="p_add">+    defined(CONFIG_EFI)</span>
 struct screen_info screen_info = {
  .orig_video_lines	= 30,
  .orig_video_cols	= 80,
<span class="p_header">diff --git a/arch/arm64/include/asm/efi.h b/arch/arm64/include/asm/efi.h</span>
<span class="p_header">index 8e88a696c9cb..622db3c6474e 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/efi.h</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/io.h&gt;
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/neon.h&gt;
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
 #include &lt;asm/tlbflush.h&gt;
 
 #ifdef CONFIG_EFI
<span class="p_chunk">@@ -14,32 +15,29 @@</span> <span class="p_context"> extern void efi_init(void);</span>
 
 int efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md);
 
<span class="p_del">-#define efi_call_virt(f, ...)						\</span>
<span class="p_add">+#define efi_set_mapping_permissions	efi_create_mapping</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_efi_call_virt_setup()					\</span>
 ({									\
<span class="p_del">-	efi_##f##_t *__f;						\</span>
<span class="p_del">-	efi_status_t __s;						\</span>
<span class="p_del">-									\</span>
 	kernel_neon_begin();						\
 	efi_virtmap_load();						\
<span class="p_del">-	__f = efi.systab-&gt;runtime-&gt;f;					\</span>
<span class="p_del">-	__s = __f(__VA_ARGS__);						\</span>
<span class="p_del">-	efi_virtmap_unload();						\</span>
<span class="p_del">-	kernel_neon_end();						\</span>
<span class="p_del">-	__s;								\</span>
 })
 
<span class="p_del">-#define __efi_call_virt(f, ...)						\</span>
<span class="p_add">+#define arch_efi_call_virt(f, args...)					\</span>
 ({									\
 	efi_##f##_t *__f;						\
<span class="p_del">-									\</span>
<span class="p_del">-	kernel_neon_begin();						\</span>
<span class="p_del">-	efi_virtmap_load();						\</span>
 	__f = efi.systab-&gt;runtime-&gt;f;					\
<span class="p_del">-	__f(__VA_ARGS__);						\</span>
<span class="p_add">+	__f(args);							\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_efi_call_virt_teardown()					\</span>
<span class="p_add">+({									\</span>
 	efi_virtmap_unload();						\
 	kernel_neon_end();						\
 })
 
<span class="p_add">+#define ARCH_EFI_IRQ_FLAGS_MASK (PSR_D_BIT | PSR_A_BIT | PSR_I_BIT | PSR_F_BIT)</span>
<span class="p_add">+</span>
 /* arch specific definitions used by the stub code */
 
 /*
<span class="p_chunk">@@ -50,7 +48,16 @@</span> <span class="p_context"> int efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md);</span>
 #define EFI_FDT_ALIGN	SZ_2M   /* used by allocate_new_fdt_and_exit_boot() */
 #define MAX_FDT_OFFSET	SZ_512M
 
<span class="p_del">-#define efi_call_early(f, ...) sys_table_arg-&gt;boottime-&gt;f(__VA_ARGS__)</span>
<span class="p_add">+#define efi_call_early(f, ...)		sys_table_arg-&gt;boottime-&gt;f(__VA_ARGS__)</span>
<span class="p_add">+#define __efi_call_early(f, ...)	f(__VA_ARGS__)</span>
<span class="p_add">+#define efi_is_64bit()			(true)</span>
<span class="p_add">+</span>
<span class="p_add">+#define alloc_screen_info(x...)		&amp;screen_info</span>
<span class="p_add">+#define free_screen_info(x...)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void efifb_setup_from_dmi(struct screen_info *si, const char *opt)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 
 #define EFI_ALLOC_ALIGN		SZ_64K
 
<span class="p_header">diff --git a/arch/arm64/kernel/efi.c b/arch/arm64/kernel/efi.c</span>
<span class="p_header">index b6abc852f2a1..78f52488f9ff 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi.c</span>
<span class="p_chunk">@@ -17,22 +17,51 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/efi.h&gt;
 
<span class="p_del">-int __init efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Only regions of type EFI_RUNTIME_SERVICES_CODE need to be</span>
<span class="p_add">+ * executable, everything else can be mapped with the XN bits</span>
<span class="p_add">+ * set. Also take the new (optional) RO/XP bits into account.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __init pteval_t create_mapping_protection(efi_memory_desc_t *md)</span>
 {
<span class="p_del">-	pteval_t prot_val;</span>
<span class="p_add">+	u64 attr = md-&gt;attribute;</span>
<span class="p_add">+	u32 type = md-&gt;type;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Only regions of type EFI_RUNTIME_SERVICES_CODE need to be</span>
<span class="p_del">-	 * executable, everything else can be mapped with the XN bits</span>
<span class="p_del">-	 * set.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((md-&gt;attribute &amp; EFI_MEMORY_WB) == 0)</span>
<span class="p_del">-		prot_val = PROT_DEVICE_nGnRE;</span>
<span class="p_del">-	else if (md-&gt;type == EFI_RUNTIME_SERVICES_CODE ||</span>
<span class="p_del">-		 !PAGE_ALIGNED(md-&gt;phys_addr))</span>
<span class="p_del">-		prot_val = pgprot_val(PAGE_KERNEL_EXEC);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		prot_val = pgprot_val(PAGE_KERNEL);</span>
<span class="p_add">+	if (type == EFI_MEMORY_MAPPED_IO)</span>
<span class="p_add">+		return PROT_DEVICE_nGnRE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ONCE(!PAGE_ALIGNED(md-&gt;phys_addr),</span>
<span class="p_add">+		      &quot;UEFI Runtime regions are not aligned to 64 KB -- buggy firmware?&quot;))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the region is not aligned to the page size of the OS, we</span>
<span class="p_add">+		 * can not use strict permissions, since that would also affect</span>
<span class="p_add">+		 * the mapping attributes of the adjacent regions.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return pgprot_val(PAGE_KERNEL_EXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* R-- */</span>
<span class="p_add">+	if ((attr &amp; (EFI_MEMORY_XP | EFI_MEMORY_RO)) ==</span>
<span class="p_add">+	    (EFI_MEMORY_XP | EFI_MEMORY_RO))</span>
<span class="p_add">+		return pgprot_val(PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* R-X */</span>
<span class="p_add">+	if (attr &amp; EFI_MEMORY_RO)</span>
<span class="p_add">+		return pgprot_val(PAGE_KERNEL_ROX);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* RW- */</span>
<span class="p_add">+	if (attr &amp; EFI_MEMORY_XP || type != EFI_RUNTIME_SERVICES_CODE)</span>
<span class="p_add">+		return pgprot_val(PAGE_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* RWX */</span>
<span class="p_add">+	return pgprot_val(PAGE_KERNEL_EXEC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* we will fill this structure from the stub, so don&#39;t put it in .bss */</span>
<span class="p_add">+struct screen_info screen_info __section(.data);</span>
<span class="p_add">+</span>
<span class="p_add">+int __init efi_create_mapping(struct mm_struct *mm, efi_memory_desc_t *md)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pteval_t prot_val = create_mapping_protection(md);</span>
 
 	create_pgd_mapping(mm, md-&gt;phys_addr, md-&gt;virt_addr,
 			   md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT,
<span class="p_header">diff --git a/arch/arm64/kernel/image.h b/arch/arm64/kernel/image.h</span>
<span class="p_header">index 5e360ce88f10..1428849aece8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/image.h</span>
<span class="p_header">+++ b/arch/arm64/kernel/image.h</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> __efistub___memset		= KALLSYMS_HIDE(__pi_memset);</span>
 __efistub__text			= KALLSYMS_HIDE(_text);
 __efistub__end			= KALLSYMS_HIDE(_end);
 __efistub__edata		= KALLSYMS_HIDE(_edata);
<span class="p_add">+__efistub_screen_info		= KALLSYMS_HIDE(screen_info);</span>
 
 #endif
 
<span class="p_header">diff --git a/arch/ia64/kernel/efi.c b/arch/ia64/kernel/efi.c</span>
<span class="p_header">index 300dac3702f1..bf0865cd438a 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/efi.c</span>
<span class="p_chunk">@@ -531,8 +531,6 @@</span> <span class="p_context"> efi_init (void)</span>
 	       efi.systab-&gt;hdr.revision &gt;&gt; 16,
 	       efi.systab-&gt;hdr.revision &amp; 0xffff, vendor);
 
<span class="p_del">-	set_bit(EFI_SYSTEM_TABLES, &amp;efi.flags);</span>
<span class="p_del">-</span>
 	palo_phys      = EFI_INVALID_TABLE_ADDR;
 
 	if (efi_config_init(arch_tables) != 0)
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 583d539a4197..52fef606bc54 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -571,312 +571,6 @@</span> <span class="p_context"> static void setup_efi_pci(struct boot_params *params)</span>
 	efi_call_early(free_pool, pci_handle);
 }
 
<span class="p_del">-static void</span>
<span class="p_del">-setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,</span>
<span class="p_del">-		 struct efi_pixel_bitmask pixel_info, int pixel_format)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {</span>
<span class="p_del">-		si-&gt;lfb_depth = 32;</span>
<span class="p_del">-		si-&gt;lfb_linelength = pixels_per_scan_line * 4;</span>
<span class="p_del">-		si-&gt;red_size = 8;</span>
<span class="p_del">-		si-&gt;red_pos = 0;</span>
<span class="p_del">-		si-&gt;green_size = 8;</span>
<span class="p_del">-		si-&gt;green_pos = 8;</span>
<span class="p_del">-		si-&gt;blue_size = 8;</span>
<span class="p_del">-		si-&gt;blue_pos = 16;</span>
<span class="p_del">-		si-&gt;rsvd_size = 8;</span>
<span class="p_del">-		si-&gt;rsvd_pos = 24;</span>
<span class="p_del">-	} else if (pixel_format == PIXEL_BGR_RESERVED_8BIT_PER_COLOR) {</span>
<span class="p_del">-		si-&gt;lfb_depth = 32;</span>
<span class="p_del">-		si-&gt;lfb_linelength = pixels_per_scan_line * 4;</span>
<span class="p_del">-		si-&gt;red_size = 8;</span>
<span class="p_del">-		si-&gt;red_pos = 16;</span>
<span class="p_del">-		si-&gt;green_size = 8;</span>
<span class="p_del">-		si-&gt;green_pos = 8;</span>
<span class="p_del">-		si-&gt;blue_size = 8;</span>
<span class="p_del">-		si-&gt;blue_pos = 0;</span>
<span class="p_del">-		si-&gt;rsvd_size = 8;</span>
<span class="p_del">-		si-&gt;rsvd_pos = 24;</span>
<span class="p_del">-	} else if (pixel_format == PIXEL_BIT_MASK) {</span>
<span class="p_del">-		find_bits(pixel_info.red_mask, &amp;si-&gt;red_pos, &amp;si-&gt;red_size);</span>
<span class="p_del">-		find_bits(pixel_info.green_mask, &amp;si-&gt;green_pos,</span>
<span class="p_del">-			  &amp;si-&gt;green_size);</span>
<span class="p_del">-		find_bits(pixel_info.blue_mask, &amp;si-&gt;blue_pos, &amp;si-&gt;blue_size);</span>
<span class="p_del">-		find_bits(pixel_info.reserved_mask, &amp;si-&gt;rsvd_pos,</span>
<span class="p_del">-			  &amp;si-&gt;rsvd_size);</span>
<span class="p_del">-		si-&gt;lfb_depth = si-&gt;red_size + si-&gt;green_size +</span>
<span class="p_del">-			si-&gt;blue_size + si-&gt;rsvd_size;</span>
<span class="p_del">-		si-&gt;lfb_linelength = (pixels_per_scan_line * si-&gt;lfb_depth) / 8;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		si-&gt;lfb_depth = 4;</span>
<span class="p_del">-		si-&gt;lfb_linelength = si-&gt;lfb_width / 2;</span>
<span class="p_del">-		si-&gt;red_size = 0;</span>
<span class="p_del">-		si-&gt;red_pos = 0;</span>
<span class="p_del">-		si-&gt;green_size = 0;</span>
<span class="p_del">-		si-&gt;green_pos = 0;</span>
<span class="p_del">-		si-&gt;blue_size = 0;</span>
<span class="p_del">-		si-&gt;blue_pos = 0;</span>
<span class="p_del">-		si-&gt;rsvd_size = 0;</span>
<span class="p_del">-		si-&gt;rsvd_pos = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static efi_status_t</span>
<span class="p_del">-__gop_query32(struct efi_graphics_output_protocol_32 *gop32,</span>
<span class="p_del">-	      struct efi_graphics_output_mode_info **info,</span>
<span class="p_del">-	      unsigned long *size, u64 *fb_base)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_graphics_output_protocol_mode_32 *mode;</span>
<span class="p_del">-	efi_status_t status;</span>
<span class="p_del">-	unsigned long m;</span>
<span class="p_del">-</span>
<span class="p_del">-	m = gop32-&gt;mode;</span>
<span class="p_del">-	mode = (struct efi_graphics_output_protocol_mode_32 *)m;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = efi_early-&gt;call(gop32-&gt;query_mode, gop32,</span>
<span class="p_del">-				 mode-&gt;mode, size, info);</span>
<span class="p_del">-	if (status != EFI_SUCCESS)</span>
<span class="p_del">-		return status;</span>
<span class="p_del">-</span>
<span class="p_del">-	*fb_base = mode-&gt;frame_buffer_base;</span>
<span class="p_del">-	return status;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static efi_status_t</span>
<span class="p_del">-setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
<span class="p_del">-	    unsigned long size, void **gop_handle)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_graphics_output_protocol_32 *gop32, *first_gop;</span>
<span class="p_del">-	unsigned long nr_gops;</span>
<span class="p_del">-	u16 width, height;</span>
<span class="p_del">-	u32 pixels_per_scan_line;</span>
<span class="p_del">-	u32 ext_lfb_base;</span>
<span class="p_del">-	u64 fb_base;</span>
<span class="p_del">-	struct efi_pixel_bitmask pixel_info;</span>
<span class="p_del">-	int pixel_format;</span>
<span class="p_del">-	efi_status_t status;</span>
<span class="p_del">-	u32 *handles = (u32 *)(unsigned long)gop_handle;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	first_gop = NULL;</span>
<span class="p_del">-	gop32 = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	nr_gops = size / sizeof(u32);</span>
<span class="p_del">-	for (i = 0; i &lt; nr_gops; i++) {</span>
<span class="p_del">-		struct efi_graphics_output_mode_info *info = NULL;</span>
<span class="p_del">-		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;</span>
<span class="p_del">-		bool conout_found = false;</span>
<span class="p_del">-		void *dummy = NULL;</span>
<span class="p_del">-		u32 h = handles[i];</span>
<span class="p_del">-		u64 current_fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = efi_call_early(handle_protocol, h,</span>
<span class="p_del">-					proto, (void **)&amp;gop32);</span>
<span class="p_del">-		if (status != EFI_SUCCESS)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = efi_call_early(handle_protocol, h,</span>
<span class="p_del">-					&amp;conout_proto, &amp;dummy);</span>
<span class="p_del">-		if (status == EFI_SUCCESS)</span>
<span class="p_del">-			conout_found = true;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = __gop_query32(gop32, &amp;info, &amp;size, &amp;current_fb_base);</span>
<span class="p_del">-		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Systems that use the UEFI Console Splitter may</span>
<span class="p_del">-			 * provide multiple GOP devices, not all of which are</span>
<span class="p_del">-			 * backed by real hardware. The workaround is to search</span>
<span class="p_del">-			 * for a GOP implementing the ConOut protocol, and if</span>
<span class="p_del">-			 * one isn&#39;t found, to just fall back to the first GOP.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			width = info-&gt;horizontal_resolution;</span>
<span class="p_del">-			height = info-&gt;vertical_resolution;</span>
<span class="p_del">-			pixel_format = info-&gt;pixel_format;</span>
<span class="p_del">-			pixel_info = info-&gt;pixel_information;</span>
<span class="p_del">-			pixels_per_scan_line = info-&gt;pixels_per_scan_line;</span>
<span class="p_del">-			fb_base = current_fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Once we&#39;ve found a GOP supporting ConOut,</span>
<span class="p_del">-			 * don&#39;t bother looking any further.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			first_gop = gop32;</span>
<span class="p_del">-			if (conout_found)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Did we find any GOPs? */</span>
<span class="p_del">-	if (!first_gop)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* EFI framebuffer */</span>
<span class="p_del">-	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;lfb_width = width;</span>
<span class="p_del">-	si-&gt;lfb_height = height;</span>
<span class="p_del">-	si-&gt;lfb_base = fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-	ext_lfb_base = (u64)(unsigned long)fb_base &gt;&gt; 32;</span>
<span class="p_del">-	if (ext_lfb_base) {</span>
<span class="p_del">-		si-&gt;capabilities |= VIDEO_CAPABILITY_64BIT_BASE;</span>
<span class="p_del">-		si-&gt;ext_lfb_base = ext_lfb_base;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;pages = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return status;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static efi_status_t</span>
<span class="p_del">-__gop_query64(struct efi_graphics_output_protocol_64 *gop64,</span>
<span class="p_del">-	      struct efi_graphics_output_mode_info **info,</span>
<span class="p_del">-	      unsigned long *size, u64 *fb_base)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_graphics_output_protocol_mode_64 *mode;</span>
<span class="p_del">-	efi_status_t status;</span>
<span class="p_del">-	unsigned long m;</span>
<span class="p_del">-</span>
<span class="p_del">-	m = gop64-&gt;mode;</span>
<span class="p_del">-	mode = (struct efi_graphics_output_protocol_mode_64 *)m;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = efi_early-&gt;call(gop64-&gt;query_mode, gop64,</span>
<span class="p_del">-				 mode-&gt;mode, size, info);</span>
<span class="p_del">-	if (status != EFI_SUCCESS)</span>
<span class="p_del">-		return status;</span>
<span class="p_del">-</span>
<span class="p_del">-	*fb_base = mode-&gt;frame_buffer_base;</span>
<span class="p_del">-	return status;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static efi_status_t</span>
<span class="p_del">-setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
<span class="p_del">-	    unsigned long size, void **gop_handle)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_graphics_output_protocol_64 *gop64, *first_gop;</span>
<span class="p_del">-	unsigned long nr_gops;</span>
<span class="p_del">-	u16 width, height;</span>
<span class="p_del">-	u32 pixels_per_scan_line;</span>
<span class="p_del">-	u32 ext_lfb_base;</span>
<span class="p_del">-	u64 fb_base;</span>
<span class="p_del">-	struct efi_pixel_bitmask pixel_info;</span>
<span class="p_del">-	int pixel_format;</span>
<span class="p_del">-	efi_status_t status;</span>
<span class="p_del">-	u64 *handles = (u64 *)(unsigned long)gop_handle;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	first_gop = NULL;</span>
<span class="p_del">-	gop64 = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	nr_gops = size / sizeof(u64);</span>
<span class="p_del">-	for (i = 0; i &lt; nr_gops; i++) {</span>
<span class="p_del">-		struct efi_graphics_output_mode_info *info = NULL;</span>
<span class="p_del">-		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;</span>
<span class="p_del">-		bool conout_found = false;</span>
<span class="p_del">-		void *dummy = NULL;</span>
<span class="p_del">-		u64 h = handles[i];</span>
<span class="p_del">-		u64 current_fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = efi_call_early(handle_protocol, h,</span>
<span class="p_del">-					proto, (void **)&amp;gop64);</span>
<span class="p_del">-		if (status != EFI_SUCCESS)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = efi_call_early(handle_protocol, h,</span>
<span class="p_del">-					&amp;conout_proto, &amp;dummy);</span>
<span class="p_del">-		if (status == EFI_SUCCESS)</span>
<span class="p_del">-			conout_found = true;</span>
<span class="p_del">-</span>
<span class="p_del">-		status = __gop_query64(gop64, &amp;info, &amp;size, &amp;current_fb_base);</span>
<span class="p_del">-		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Systems that use the UEFI Console Splitter may</span>
<span class="p_del">-			 * provide multiple GOP devices, not all of which are</span>
<span class="p_del">-			 * backed by real hardware. The workaround is to search</span>
<span class="p_del">-			 * for a GOP implementing the ConOut protocol, and if</span>
<span class="p_del">-			 * one isn&#39;t found, to just fall back to the first GOP.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			width = info-&gt;horizontal_resolution;</span>
<span class="p_del">-			height = info-&gt;vertical_resolution;</span>
<span class="p_del">-			pixel_format = info-&gt;pixel_format;</span>
<span class="p_del">-			pixel_info = info-&gt;pixel_information;</span>
<span class="p_del">-			pixels_per_scan_line = info-&gt;pixels_per_scan_line;</span>
<span class="p_del">-			fb_base = current_fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Once we&#39;ve found a GOP supporting ConOut,</span>
<span class="p_del">-			 * don&#39;t bother looking any further.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			first_gop = gop64;</span>
<span class="p_del">-			if (conout_found)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Did we find any GOPs? */</span>
<span class="p_del">-	if (!first_gop)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* EFI framebuffer */</span>
<span class="p_del">-	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;lfb_width = width;</span>
<span class="p_del">-	si-&gt;lfb_height = height;</span>
<span class="p_del">-	si-&gt;lfb_base = fb_base;</span>
<span class="p_del">-</span>
<span class="p_del">-	ext_lfb_base = (u64)(unsigned long)fb_base &gt;&gt; 32;</span>
<span class="p_del">-	if (ext_lfb_base) {</span>
<span class="p_del">-		si-&gt;capabilities |= VIDEO_CAPABILITY_64BIT_BASE;</span>
<span class="p_del">-		si-&gt;ext_lfb_base = ext_lfb_base;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;pages = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;</span>
<span class="p_del">-</span>
<span class="p_del">-	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return status;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * See if we have Graphics Output Protocol</span>
<span class="p_del">- */</span>
<span class="p_del">-static efi_status_t setup_gop(struct screen_info *si, efi_guid_t *proto,</span>
<span class="p_del">-			      unsigned long size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	efi_status_t status;</span>
<span class="p_del">-	void **gop_handle = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,</span>
<span class="p_del">-				size, (void **)&amp;gop_handle);</span>
<span class="p_del">-	if (status != EFI_SUCCESS)</span>
<span class="p_del">-		return status;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = efi_call_early(locate_handle,</span>
<span class="p_del">-				EFI_LOCATE_BY_PROTOCOL,</span>
<span class="p_del">-				proto, NULL, &amp;size, gop_handle);</span>
<span class="p_del">-	if (status != EFI_SUCCESS)</span>
<span class="p_del">-		goto free_handle;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (efi_early-&gt;is64)</span>
<span class="p_del">-		status = setup_gop64(si, proto, size, gop_handle);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		status = setup_gop32(si, proto, size, gop_handle);</span>
<span class="p_del">-</span>
<span class="p_del">-free_handle:</span>
<span class="p_del">-	efi_call_early(free_pool, gop_handle);</span>
<span class="p_del">-	return status;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static efi_status_t
 setup_uga32(void **uga_handle, unsigned long size, u32 *width, u32 *height)
 {
<span class="p_chunk">@@ -1038,7 +732,7 @@</span> <span class="p_context"> void setup_graphics(struct boot_params *boot_params)</span>
 				EFI_LOCATE_BY_PROTOCOL,
 				&amp;graphics_proto, NULL, &amp;size, gop_handle);
 	if (status == EFI_BUFFER_TOO_SMALL)
<span class="p_del">-		status = setup_gop(si, &amp;graphics_proto, size);</span>
<span class="p_add">+		status = efi_setup_gop(NULL, si, &amp;graphics_proto, size);</span>
 
 	if (status != EFI_SUCCESS) {
 		size = 0;
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.h b/arch/x86/boot/compressed/eboot.h</span>
<span class="p_header">index d487e727f1ec..c0223f1a89d7 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.h</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.h</span>
<span class="p_chunk">@@ -11,80 +11,6 @@</span> <span class="p_context"></span>
 
 #define DESC_TYPE_CODE_DATA	(1 &lt;&lt; 0)
 
<span class="p_del">-#define EFI_CONSOLE_OUT_DEVICE_GUID    \</span>
<span class="p_del">-	EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, 0x9a, 0x46, 0x0, 0x90, 0x27, \</span>
<span class="p_del">-		  0x3f, 0xc1, 0x4d)</span>
<span class="p_del">-</span>
<span class="p_del">-#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0</span>
<span class="p_del">-#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1</span>
<span class="p_del">-#define PIXEL_BIT_MASK					2</span>
<span class="p_del">-#define PIXEL_BLT_ONLY					3</span>
<span class="p_del">-#define PIXEL_FORMAT_MAX				4</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_pixel_bitmask {</span>
<span class="p_del">-	u32 red_mask;</span>
<span class="p_del">-	u32 green_mask;</span>
<span class="p_del">-	u32 blue_mask;</span>
<span class="p_del">-	u32 reserved_mask;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_mode_info {</span>
<span class="p_del">-	u32 version;</span>
<span class="p_del">-	u32 horizontal_resolution;</span>
<span class="p_del">-	u32 vertical_resolution;</span>
<span class="p_del">-	int pixel_format;</span>
<span class="p_del">-	struct efi_pixel_bitmask pixel_information;</span>
<span class="p_del">-	u32 pixels_per_scan_line;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol_mode_32 {</span>
<span class="p_del">-	u32 max_mode;</span>
<span class="p_del">-	u32 mode;</span>
<span class="p_del">-	u32 info;</span>
<span class="p_del">-	u32 size_of_info;</span>
<span class="p_del">-	u64 frame_buffer_base;</span>
<span class="p_del">-	u32 frame_buffer_size;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol_mode_64 {</span>
<span class="p_del">-	u32 max_mode;</span>
<span class="p_del">-	u32 mode;</span>
<span class="p_del">-	u64 info;</span>
<span class="p_del">-	u64 size_of_info;</span>
<span class="p_del">-	u64 frame_buffer_base;</span>
<span class="p_del">-	u64 frame_buffer_size;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol_mode {</span>
<span class="p_del">-	u32 max_mode;</span>
<span class="p_del">-	u32 mode;</span>
<span class="p_del">-	unsigned long info;</span>
<span class="p_del">-	unsigned long size_of_info;</span>
<span class="p_del">-	u64 frame_buffer_base;</span>
<span class="p_del">-	unsigned long frame_buffer_size;</span>
<span class="p_del">-} __packed;</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol_32 {</span>
<span class="p_del">-	u32 query_mode;</span>
<span class="p_del">-	u32 set_mode;</span>
<span class="p_del">-	u32 blt;</span>
<span class="p_del">-	u32 mode;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol_64 {</span>
<span class="p_del">-	u64 query_mode;</span>
<span class="p_del">-	u64 set_mode;</span>
<span class="p_del">-	u64 blt;</span>
<span class="p_del">-	u64 mode;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_graphics_output_protocol {</span>
<span class="p_del">-	void *query_mode;</span>
<span class="p_del">-	unsigned long set_mode;</span>
<span class="p_del">-	unsigned long blt;</span>
<span class="p_del">-	struct efi_graphics_output_protocol_mode *mode;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct efi_uga_draw_protocol_32 {
 	u32 get_mode;
 	u32 set_mode;
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 53748c45e488..78d1e7467eae 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/fpu/api.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
 #include &lt;asm/tlb.h&gt;
 
 /*
<span class="p_chunk">@@ -28,33 +29,22 @@</span> <span class="p_context"></span>
 
 #define MAX_CMDLINE_ADDRESS	UINT_MAX
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_add">+#define ARCH_EFI_IRQ_FLAGS_MASK	X86_EFLAGS_IF</span>
 
<span class="p_add">+#ifdef CONFIG_X86_32</span>
 
 extern unsigned long asmlinkage efi_call_phys(void *, ...);
 
<span class="p_add">+#define arch_efi_call_virt_setup()	kernel_fpu_begin()</span>
<span class="p_add">+#define arch_efi_call_virt_teardown()	kernel_fpu_end()</span>
<span class="p_add">+</span>
 /*
  * Wrap all the virtual calls in a way that forces the parameters on the stack.
  */
<span class="p_del">-</span>
<span class="p_del">-/* Use this macro if your virtual returns a non-void value */</span>
<span class="p_del">-#define efi_call_virt(f, args...) \</span>
<span class="p_add">+#define arch_efi_call_virt(f, args...)					\</span>
 ({									\
<span class="p_del">-	efi_status_t __s;						\</span>
<span class="p_del">-	kernel_fpu_begin();						\</span>
<span class="p_del">-	__s = ((efi_##f##_t __attribute__((regparm(0)))*)		\</span>
<span class="p_del">-		efi.systab-&gt;runtime-&gt;f)(args);				\</span>
<span class="p_del">-	kernel_fpu_end();						\</span>
<span class="p_del">-	__s;								\</span>
<span class="p_del">-})</span>
<span class="p_del">-</span>
<span class="p_del">-/* Use this macro if your virtual call does not return any value */</span>
<span class="p_del">-#define __efi_call_virt(f, args...) \</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	kernel_fpu_begin();						\</span>
 	((efi_##f##_t __attribute__((regparm(0)))*)			\
 		efi.systab-&gt;runtime-&gt;f)(args);				\
<span class="p_del">-	kernel_fpu_end();						\</span>
 })
 
 #define efi_ioremap(addr, size, type, attr)	ioremap_cache(addr, size)
<span class="p_chunk">@@ -78,10 +68,8 @@</span> <span class="p_context"> struct efi_scratch {</span>
 	u64	phys_stack;
 } __packed;
 
<span class="p_del">-#define efi_call_virt(f, ...)						\</span>
<span class="p_add">+#define arch_efi_call_virt_setup()					\</span>
 ({									\
<span class="p_del">-	efi_status_t __s;						\</span>
<span class="p_del">-									\</span>
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
<span class="p_chunk">@@ -91,9 +79,13 @@</span> <span class="p_context"> struct efi_scratch {</span>
 		write_cr3((unsigned long)efi_scratch.efi_pgt);		\
 		__flush_tlb_all();					\
 	}								\
<span class="p_del">-									\</span>
<span class="p_del">-	__s = efi_call((void *)efi.systab-&gt;runtime-&gt;f, __VA_ARGS__);	\</span>
<span class="p_del">-									\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_efi_call_virt(f, args...)					\</span>
<span class="p_add">+	efi_call((void *)efi.systab-&gt;runtime-&gt;f, args)			\</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_efi_call_virt_teardown()					\</span>
<span class="p_add">+({									\</span>
 	if (efi_scratch.use_pgd) {					\
 		write_cr3(efi_scratch.prev_cr3);			\
 		__flush_tlb_all();					\
<span class="p_chunk">@@ -101,15 +93,8 @@</span> <span class="p_context"> struct efi_scratch {</span>
 									\
 	__kernel_fpu_end();						\
 	preempt_enable();						\
<span class="p_del">-	__s;								\</span>
 })
 
<span class="p_del">-/*</span>
<span class="p_del">- * All X86_64 virt calls return non-void values. Thus, use non-void call for</span>
<span class="p_del">- * virt calls that would be void on X86_32.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define __efi_call_virt(f, args...) efi_call_virt(f, args)</span>
<span class="p_del">-</span>
 extern void __iomem *__init efi_ioremap(unsigned long addr, unsigned long size,
 					u32 type, u64 attribute);
 
<span class="p_chunk">@@ -180,6 +165,8 @@</span> <span class="p_context"> static inline bool efi_runtime_supported(void)</span>
 extern struct console early_efi_console;
 extern void parse_efi_setup(u64 phys_addr, u32 data_len);
 
<span class="p_add">+extern void efifb_setup_from_dmi(struct screen_info *si, const char *opt);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_EFI_MIXED
 extern void efi_thunk_runtime_setup(void);
 extern efi_status_t efi_thunk_set_virtual_address_map(
<span class="p_chunk">@@ -225,6 +212,11 @@</span> <span class="p_context"> __pure const struct efi_config *__efi_early(void);</span>
 #define efi_call_early(f, ...)						\
 	__efi_early()-&gt;call(__efi_early()-&gt;f, __VA_ARGS__);
 
<span class="p_add">+#define __efi_call_early(f, ...)					\</span>
<span class="p_add">+	__efi_early()-&gt;call((unsigned long)f, __VA_ARGS__);</span>
<span class="p_add">+</span>
<span class="p_add">+#define efi_is_64bit()		__efi_early()-&gt;is64</span>
<span class="p_add">+</span>
 extern bool efi_reboot_required(void);
 
 #else
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index ab0adc0fa5db..a9b31eb815f2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -535,6 +535,15 @@</span> <span class="p_context"> static void native_machine_emergency_restart(void)</span>
 	mode = reboot_mode == REBOOT_WARM ? 0x1234 : 0;
 	*((unsigned short *)__va(0x472)) = mode;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If an EFI capsule has been registered with the firmware then</span>
<span class="p_add">+	 * override the reboot= parameter.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (efi_capsule_pending(NULL)) {</span>
<span class="p_add">+		pr_info(&quot;EFI capsule is pending, forcing EFI reboot.\n&quot;);</span>
<span class="p_add">+		reboot_type = BOOT_EFI;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	for (;;) {
 		/* Could also try the reset bit in the Hammer NB */
 		switch (reboot_type) {
<span class="p_header">diff --git a/arch/x86/kernel/sysfb_efi.c b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">index 5da924bbf0a0..623965e86b65 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sysfb_efi.c</span>
<span class="p_chunk">@@ -68,6 +68,21 @@</span> <span class="p_context"> struct efifb_dmi_info efifb_dmi_list[] = {</span>
 	[M_UNKNOWN] = { NULL, 0, 0, 0, 0, OVERRIDE_NONE }
 };
 
<span class="p_add">+void efifb_setup_from_dmi(struct screen_info *si, const char *opt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; M_UNKNOWN; i++) {</span>
<span class="p_add">+		if (efifb_dmi_list[i].base != 0 &amp;&amp;</span>
<span class="p_add">+		    !strcmp(opt, efifb_dmi_list[i].optname)) {</span>
<span class="p_add">+			si-&gt;lfb_base = efifb_dmi_list[i].base;</span>
<span class="p_add">+			si-&gt;lfb_linelength = efifb_dmi_list[i].stride;</span>
<span class="p_add">+			si-&gt;lfb_width = efifb_dmi_list[i].width;</span>
<span class="p_add">+			si-&gt;lfb_height = efifb_dmi_list[i].height;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define choose_value(dmivalue, fwvalue, field, flags) ({	\
 		typeof(fwvalue) _ret_ = fwvalue;		\
 		if ((flags) &amp; (field))				\
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index 01be9ec3bf79..a1f0e1d0ddc2 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -1125,8 +1125,14 @@</span> <span class="p_context"> static int populate_pgd(struct cpa_data *cpa, unsigned long addr)</span>
 static int __cpa_process_fault(struct cpa_data *cpa, unsigned long vaddr,
 			       int primary)
 {
<span class="p_del">-	if (cpa-&gt;pgd)</span>
<span class="p_add">+	if (cpa-&gt;pgd) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right now, we only execute this code path when mapping</span>
<span class="p_add">+		 * the EFI virtual memory map regions, no other users</span>
<span class="p_add">+		 * provide a -&gt;pgd value. This may change in the future.</span>
<span class="p_add">+		 */</span>
 		return populate_pgd(cpa, vaddr);
<span class="p_add">+	}</span>
 
 	/*
 	 * Ignore all non primary paths.
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 994a7df84a7b..f93545e7dc54 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -54,10 +54,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/rtc.h&gt;
 #include &lt;asm/uv/uv.h&gt;
 
<span class="p_del">-#define EFI_DEBUG</span>
<span class="p_del">-</span>
<span class="p_del">-struct efi_memory_map memmap;</span>
<span class="p_del">-</span>
 static struct efi efi_phys __initdata;
 static efi_system_table_t efi_systab __initdata;
 
<span class="p_chunk">@@ -119,11 +115,10 @@</span> <span class="p_context"> void efi_get_time(struct timespec *now)</span>
 
 void __init efi_find_mirror(void)
 {
<span class="p_del">-	void *p;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
 	u64 mirror_size = 0, total_size = 0;
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		unsigned long long start = md-&gt;phys_addr;
 		unsigned long long size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;
 
<span class="p_chunk">@@ -146,10 +141,9 @@</span> <span class="p_context"> void __init efi_find_mirror(void)</span>
 
 static void __init do_add_efi_memmap(void)
 {
<span class="p_del">-	void *p;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		unsigned long long start = md-&gt;phys_addr;
 		unsigned long long size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;
 		int e820_type;
<span class="p_chunk">@@ -209,47 +203,47 @@</span> <span class="p_context"> int __init efi_memblock_x86_reserve_range(void)</span>
 #else
 	pmap = (e-&gt;efi_memmap |	((__u64)e-&gt;efi_memmap_hi &lt;&lt; 32));
 #endif
<span class="p_del">-	memmap.phys_map		= pmap;</span>
<span class="p_del">-	memmap.nr_map		= e-&gt;efi_memmap_size /</span>
<span class="p_add">+	efi.memmap.phys_map	= pmap;</span>
<span class="p_add">+	efi.memmap.nr_map	= e-&gt;efi_memmap_size /</span>
 				  e-&gt;efi_memdesc_size;
<span class="p_del">-	memmap.desc_size	= e-&gt;efi_memdesc_size;</span>
<span class="p_del">-	memmap.desc_version	= e-&gt;efi_memdesc_version;</span>
<span class="p_add">+	efi.memmap.desc_size	= e-&gt;efi_memdesc_size;</span>
<span class="p_add">+	efi.memmap.desc_version	= e-&gt;efi_memdesc_version;</span>
 
<span class="p_del">-	memblock_reserve(pmap, memmap.nr_map * memmap.desc_size);</span>
<span class="p_add">+	WARN(efi.memmap.desc_version != 1,</span>
<span class="p_add">+	     &quot;Unexpected EFI_MEMORY_DESCRIPTOR version %ld&quot;,</span>
<span class="p_add">+	     efi.memmap.desc_version);</span>
 
<span class="p_del">-	efi.memmap = &amp;memmap;</span>
<span class="p_add">+	memblock_reserve(pmap, efi.memmap.nr_map * efi.memmap.desc_size);</span>
 
 	return 0;
 }
 
 void __init efi_print_memmap(void)
 {
<span class="p_del">-#ifdef EFI_DEBUG</span>
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	int i = 0;</span>
 
<span class="p_del">-	for (p = memmap.map, i = 0;</span>
<span class="p_del">-	     p &lt; memmap.map_end;</span>
<span class="p_del">-	     p += memmap.desc_size, i++) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		char buf[64];
 
<span class="p_del">-		md = p;</span>
 		pr_info(&quot;mem%02u: %s range=[0x%016llx-0x%016llx] (%lluMB)\n&quot;,
<span class="p_del">-			i, efi_md_typeattr_format(buf, sizeof(buf), md),</span>
<span class="p_add">+			i++, efi_md_typeattr_format(buf, sizeof(buf), md),</span>
 			md-&gt;phys_addr,
 			md-&gt;phys_addr + (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT) - 1,
 			(md-&gt;num_pages &gt;&gt; (20 - EFI_PAGE_SHIFT)));
 	}
<span class="p_del">-#endif  /*  EFI_DEBUG  */</span>
 }
 
 void __init efi_unmap_memmap(void)
 {
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+</span>
 	clear_bit(EFI_MEMMAP, &amp;efi.flags);
<span class="p_del">-	if (memmap.map) {</span>
<span class="p_del">-		early_memunmap(memmap.map, memmap.nr_map * memmap.desc_size);</span>
<span class="p_del">-		memmap.map = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = efi.memmap.nr_map * efi.memmap.desc_size;</span>
<span class="p_add">+	if (efi.memmap.map) {</span>
<span class="p_add">+		early_memunmap(efi.memmap.map, size);</span>
<span class="p_add">+		efi.memmap.map = NULL;</span>
 	}
 }
 
<span class="p_chunk">@@ -352,8 +346,6 @@</span> <span class="p_context"> static int __init efi_systab_init(void *phys)</span>
 		       efi.systab-&gt;hdr.revision &gt;&gt; 16,
 		       efi.systab-&gt;hdr.revision &amp; 0xffff);
 
<span class="p_del">-	set_bit(EFI_SYSTEM_TABLES, &amp;efi.flags);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -440,17 +432,22 @@</span> <span class="p_context"> static int __init efi_runtime_init(void)</span>
 
 static int __init efi_memmap_init(void)
 {
<span class="p_add">+	unsigned long addr, size;</span>
<span class="p_add">+</span>
 	if (efi_enabled(EFI_PARAVIRT))
 		return 0;
 
 	/* Map the EFI memory map */
<span class="p_del">-	memmap.map = early_memremap((unsigned long)memmap.phys_map,</span>
<span class="p_del">-				   memmap.nr_map * memmap.desc_size);</span>
<span class="p_del">-	if (memmap.map == NULL) {</span>
<span class="p_add">+	size = efi.memmap.nr_map * efi.memmap.desc_size;</span>
<span class="p_add">+	addr = (unsigned long)efi.memmap.phys_map;</span>
<span class="p_add">+</span>
<span class="p_add">+	efi.memmap.map = early_memremap(addr, size);</span>
<span class="p_add">+	if (efi.memmap.map == NULL) {</span>
 		pr_err(&quot;Could not map the memory map!\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	memmap.map_end = memmap.map + (memmap.nr_map * memmap.desc_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	efi.memmap.map_end = efi.memmap.map + size;</span>
 
 	if (add_efi_memmap)
 		do_add_efi_memmap();
<span class="p_chunk">@@ -552,12 +549,9 @@</span> <span class="p_context"> void __init efi_set_executable(efi_memory_desc_t *md, bool executable)</span>
 void __init runtime_code_page_mkexec(void)
 {
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
 
 	/* Make EFI runtime service code area executable */
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_del">-</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if (md-&gt;type != EFI_RUNTIME_SERVICES_CODE)
 			continue;
 
<span class="p_chunk">@@ -604,12 +598,10 @@</span> <span class="p_context"> void __init old_map_region(efi_memory_desc_t *md)</span>
 /* Merge contiguous regions of the same type and attribute */
 static void __init efi_merge_regions(void)
 {
<span class="p_del">-	void *p;</span>
 	efi_memory_desc_t *md, *prev_md = NULL;
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		u64 prev_size;
<span class="p_del">-		md = p;</span>
 
 		if (!prev_md) {
 			prev_md = md;
<span class="p_chunk">@@ -651,30 +643,31 @@</span> <span class="p_context"> static void __init get_systab_virt_addr(efi_memory_desc_t *md)</span>
 static void __init save_runtime_map(void)
 {
 #ifdef CONFIG_KEXEC_CORE
<span class="p_add">+	unsigned long desc_size;</span>
 	efi_memory_desc_t *md;
<span class="p_del">-	void *tmp, *p, *q = NULL;</span>
<span class="p_add">+	void *tmp, *q = NULL;</span>
 	int count = 0;
 
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return;
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_add">+	desc_size = efi.memmap.desc_size;</span>
 
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME) ||
 		    (md-&gt;type == EFI_BOOT_SERVICES_CODE) ||
 		    (md-&gt;type == EFI_BOOT_SERVICES_DATA))
 			continue;
<span class="p_del">-		tmp = krealloc(q, (count + 1) * memmap.desc_size, GFP_KERNEL);</span>
<span class="p_add">+		tmp = krealloc(q, (count + 1) * desc_size, GFP_KERNEL);</span>
 		if (!tmp)
 			goto out;
 		q = tmp;
 
<span class="p_del">-		memcpy(q + count * memmap.desc_size, md, memmap.desc_size);</span>
<span class="p_add">+		memcpy(q + count * desc_size, md, desc_size);</span>
 		count++;
 	}
 
<span class="p_del">-	efi_runtime_map_setup(q, count, memmap.desc_size);</span>
<span class="p_add">+	efi_runtime_map_setup(q, count, desc_size);</span>
 	return;
 
 out:
<span class="p_chunk">@@ -714,10 +707,10 @@</span> <span class="p_context"> static inline void *efi_map_next_entry_reverse(void *entry)</span>
 {
 	/* Initial call */
 	if (!entry)
<span class="p_del">-		return memmap.map_end - memmap.desc_size;</span>
<span class="p_add">+		return efi.memmap.map_end - efi.memmap.desc_size;</span>
 
<span class="p_del">-	entry -= memmap.desc_size;</span>
<span class="p_del">-	if (entry &lt; memmap.map)</span>
<span class="p_add">+	entry -= efi.memmap.desc_size;</span>
<span class="p_add">+	if (entry &lt; efi.memmap.map)</span>
 		return NULL;
 
 	return entry;
<span class="p_chunk">@@ -759,10 +752,10 @@</span> <span class="p_context"> static void *efi_map_next_entry(void *entry)</span>
 
 	/* Initial call */
 	if (!entry)
<span class="p_del">-		return memmap.map;</span>
<span class="p_add">+		return efi.memmap.map;</span>
 
<span class="p_del">-	entry += memmap.desc_size;</span>
<span class="p_del">-	if (entry &gt;= memmap.map_end)</span>
<span class="p_add">+	entry += efi.memmap.desc_size;</span>
<span class="p_add">+	if (entry &gt;= efi.memmap.map_end)</span>
 		return NULL;
 
 	return entry;
<span class="p_chunk">@@ -776,8 +769,11 @@</span> <span class="p_context"> static void * __init efi_map_regions(int *count, int *pg_shift)</span>
 {
 	void *p, *new_memmap = NULL;
 	unsigned long left = 0;
<span class="p_add">+	unsigned long desc_size;</span>
 	efi_memory_desc_t *md;
 
<span class="p_add">+	desc_size = efi.memmap.desc_size;</span>
<span class="p_add">+</span>
 	p = NULL;
 	while ((p = efi_map_next_entry(p))) {
 		md = p;
<span class="p_chunk">@@ -792,7 +788,7 @@</span> <span class="p_context"> static void * __init efi_map_regions(int *count, int *pg_shift)</span>
 		efi_map_region(md);
 		get_systab_virt_addr(md);
 
<span class="p_del">-		if (left &lt; memmap.desc_size) {</span>
<span class="p_add">+		if (left &lt; desc_size) {</span>
 			new_memmap = realloc_pages(new_memmap, *pg_shift);
 			if (!new_memmap)
 				return NULL;
<span class="p_chunk">@@ -801,10 +797,9 @@</span> <span class="p_context"> static void * __init efi_map_regions(int *count, int *pg_shift)</span>
 			(*pg_shift)++;
 		}
 
<span class="p_del">-		memcpy(new_memmap + (*count * memmap.desc_size), md,</span>
<span class="p_del">-		       memmap.desc_size);</span>
<span class="p_add">+		memcpy(new_memmap + (*count * desc_size), md, desc_size);</span>
 
<span class="p_del">-		left -= memmap.desc_size;</span>
<span class="p_add">+		left -= desc_size;</span>
 		(*count)++;
 	}
 
<span class="p_chunk">@@ -816,7 +811,6 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 #ifdef CONFIG_KEXEC_CORE
 	efi_memory_desc_t *md;
 	unsigned int num_pages;
<span class="p_del">-	void *p;</span>
 
 	efi.systab = NULL;
 
<span class="p_chunk">@@ -840,8 +834,7 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 	* Map efi regions which were passed via setup_data. The virt_addr is a
 	* fixed addr which was used in first kernel of a kexec boot.
 	*/
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		efi_map_region_fixed(md); /* FIXME: add error handling */
 		get_systab_virt_addr(md);
 	}
<span class="p_chunk">@@ -850,10 +843,10 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 
 	BUG_ON(!efi.systab);
 
<span class="p_del">-	num_pages = ALIGN(memmap.nr_map * memmap.desc_size, PAGE_SIZE);</span>
<span class="p_add">+	num_pages = ALIGN(efi.memmap.nr_map * efi.memmap.desc_size, PAGE_SIZE);</span>
 	num_pages &gt;&gt;= PAGE_SHIFT;
 
<span class="p_del">-	if (efi_setup_page_tables(memmap.phys_map, num_pages)) {</span>
<span class="p_add">+	if (efi_setup_page_tables(efi.memmap.phys_map, num_pages)) {</span>
 		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);
 		return;
 	}
<span class="p_chunk">@@ -937,16 +930,16 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 
 	if (efi_is_native()) {
 		status = phys_efi_set_virtual_address_map(
<span class="p_del">-				memmap.desc_size * count,</span>
<span class="p_del">-				memmap.desc_size,</span>
<span class="p_del">-				memmap.desc_version,</span>
<span class="p_add">+				efi.memmap.desc_size * count,</span>
<span class="p_add">+				efi.memmap.desc_size,</span>
<span class="p_add">+				efi.memmap.desc_version,</span>
 				(efi_memory_desc_t *)__pa(new_memmap));
 	} else {
 		status = efi_thunk_set_virtual_address_map(
 				efi_phys.set_virtual_address_map,
<span class="p_del">-				memmap.desc_size * count,</span>
<span class="p_del">-				memmap.desc_size,</span>
<span class="p_del">-				memmap.desc_version,</span>
<span class="p_add">+				efi.memmap.desc_size * count,</span>
<span class="p_add">+				efi.memmap.desc_size,</span>
<span class="p_add">+				efi.memmap.desc_version,</span>
 				(efi_memory_desc_t *)__pa(new_memmap));
 	}
 
<span class="p_chunk">@@ -1011,13 +1004,11 @@</span> <span class="p_context"> void __init efi_enter_virtual_mode(void)</span>
 u32 efi_mem_type(unsigned long phys_addr)
 {
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
 
 	if (!efi_enabled(EFI_MEMMAP))
 		return 0;
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if ((md-&gt;phys_addr &lt;= phys_addr) &amp;&amp;
 		    (phys_addr &lt; (md-&gt;phys_addr +
 				  (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT))))
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 49e4dd4a1f58..6e7242be1c87 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -55,14 +55,12 @@</span> <span class="p_context"> struct efi_scratch efi_scratch;</span>
 static void __init early_code_mapping_set_exec(int executable)
 {
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
 
 	if (!(__supported_pte_mask &amp; _PAGE_NX))
 		return;
 
 	/* Make EFI service code area executable */
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if (md-&gt;type == EFI_RUNTIME_SERVICES_CODE ||
 		    md-&gt;type == EFI_BOOT_SERVICES_CODE)
 			efi_set_executable(md, executable);
<span class="p_chunk">@@ -253,7 +251,7 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	 * Map all of RAM so that we can access arguments in the 1:1
 	 * mapping when making EFI runtime calls.
 	 */
<span class="p_del">-	for_each_efi_memory_desc(&amp;memmap, md) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if (md-&gt;type != EFI_CONVENTIONAL_MEMORY &amp;&amp;
 		    md-&gt;type != EFI_LOADER_DATA &amp;&amp;
 		    md-&gt;type != EFI_LOADER_CODE)
<span class="p_chunk">@@ -398,7 +396,6 @@</span> <span class="p_context"> void __init efi_runtime_update_mappings(void)</span>
 	unsigned long pfn;
 	pgd_t *pgd = efi_pgd;
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
 
 	if (efi_enabled(EFI_OLD_MEMMAP)) {
 		if (__supported_pte_mask &amp; _PAGE_NX)
<span class="p_chunk">@@ -409,9 +406,8 @@</span> <span class="p_context"> void __init efi_runtime_update_mappings(void)</span>
 	if (!efi_enabled(EFI_NX_PE_DATA))
 		return;
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		unsigned long pf = 0;
<span class="p_del">-		md = p;</span>
 
 		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME))
 			continue;
<span class="p_header">diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">index ab50ada1d56e..097cb09d917b 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/quirks.c</span>
<span class="p_chunk">@@ -195,10 +195,9 @@</span> <span class="p_context"> static bool can_free_region(u64 start, u64 size)</span>
 */
 void __init efi_reserve_boot_services(void)
 {
<span class="p_del">-	void *p;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		u64 start = md-&gt;phys_addr;
 		u64 size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;
 		bool already_reserved;
<span class="p_chunk">@@ -250,10 +249,9 @@</span> <span class="p_context"> void __init efi_reserve_boot_services(void)</span>
 
 void __init efi_free_boot_services(void)
 {
<span class="p_del">-	void *p;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
 
<span class="p_del">-	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		unsigned long long start = md-&gt;phys_addr;
 		unsigned long long size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;
 
<span class="p_header">diff --git a/drivers/firmware/efi/Kconfig b/drivers/firmware/efi/Kconfig</span>
<span class="p_header">index e1670d533f97..6394152f648f 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/Kconfig</span>
<span class="p_header">+++ b/drivers/firmware/efi/Kconfig</span>
<span class="p_chunk">@@ -87,6 +87,31 @@</span> <span class="p_context"> config EFI_RUNTIME_WRAPPERS</span>
 config EFI_ARMSTUB
 	bool
 
<span class="p_add">+config EFI_BOOTLOADER_CONTROL</span>
<span class="p_add">+	tristate &quot;EFI Bootloader Control&quot;</span>
<span class="p_add">+	depends on EFI_VARS</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	---help---</span>
<span class="p_add">+	  This module installs a reboot hook, such that if reboot() is</span>
<span class="p_add">+	  invoked with a string argument NNN, &quot;NNN&quot; is copied to the</span>
<span class="p_add">+	  &quot;LoaderEntryOneShot&quot; EFI variable, to be read by the</span>
<span class="p_add">+	  bootloader. If the string matches one of the boot labels</span>
<span class="p_add">+	  defined in its configuration, the bootloader will boot once</span>
<span class="p_add">+	  to that label. The &quot;LoaderEntryRebootReason&quot; EFI variable is</span>
<span class="p_add">+	  set with the reboot reason: &quot;reboot&quot; or &quot;shutdown&quot;. The</span>
<span class="p_add">+	  bootloader reads this reboot reason and takes particular</span>
<span class="p_add">+	  action according to its policy.</span>
<span class="p_add">+</span>
<span class="p_add">+config EFI_CAPSULE_LOADER</span>
<span class="p_add">+	tristate &quot;EFI capsule loader&quot;</span>
<span class="p_add">+	depends on EFI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This option exposes a loader interface &quot;/dev/efi_capsule_loader&quot; for</span>
<span class="p_add">+	  users to load EFI capsules. This driver requires working runtime</span>
<span class="p_add">+	  capsule support in the firmware, which many OEMs do not provide.</span>
<span class="p_add">+</span>
<span class="p_add">+	  Most users should say N.</span>
<span class="p_add">+</span>
 endmenu
 
 config UEFI_CPER
<span class="p_header">diff --git a/drivers/firmware/efi/Makefile b/drivers/firmware/efi/Makefile</span>
<span class="p_header">index 62e654f255f4..a219640f881f 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/Makefile</span>
<span class="p_header">+++ b/drivers/firmware/efi/Makefile</span>
<span class="p_chunk">@@ -9,7 +9,8 @@</span> <span class="p_context"></span>
 #
 KASAN_SANITIZE_runtime-wrappers.o	:= n
 
<span class="p_del">-obj-$(CONFIG_EFI)			+= efi.o vars.o reboot.o</span>
<span class="p_add">+obj-$(CONFIG_EFI)			+= efi.o vars.o reboot.o memattr.o</span>
<span class="p_add">+obj-$(CONFIG_EFI)			+= capsule.o</span>
 obj-$(CONFIG_EFI_VARS)			+= efivars.o
 obj-$(CONFIG_EFI_ESRT)			+= esrt.o
 obj-$(CONFIG_EFI_VARS_PSTORE)		+= efi-pstore.o
<span class="p_chunk">@@ -18,7 +19,9 @@</span> <span class="p_context"> obj-$(CONFIG_EFI_RUNTIME_MAP)		+= runtime-map.o</span>
 obj-$(CONFIG_EFI_RUNTIME_WRAPPERS)	+= runtime-wrappers.o
 obj-$(CONFIG_EFI_STUB)			+= libstub/
 obj-$(CONFIG_EFI_FAKE_MEMMAP)		+= fake_mem.o
<span class="p_add">+obj-$(CONFIG_EFI_BOOTLOADER_CONTROL)	+= efibc.o</span>
 
 arm-obj-$(CONFIG_EFI)			:= arm-init.o arm-runtime.o
 obj-$(CONFIG_ARM)			+= $(arm-obj-y)
 obj-$(CONFIG_ARM64)			+= $(arm-obj-y)
<span class="p_add">+obj-$(CONFIG_EFI_CAPSULE_LOADER)	+= capsule-loader.o</span>
<span class="p_header">diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">index 8714f8c271ba..ef90f0c4b70a 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/arm-init.c</span>
<span class="p_chunk">@@ -11,17 +11,19 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#define pr_fmt(fmt)	&quot;efi: &quot; fmt</span>
<span class="p_add">+</span>
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/memblock.h&gt;
 #include &lt;linux/mm_types.h&gt;
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_fdt.h&gt;
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
 
 #include &lt;asm/efi.h&gt;
 
<span class="p_del">-struct efi_memory_map memmap;</span>
<span class="p_del">-</span>
 u64 efi_system_table;
 
 static int __init is_normal_ram(efi_memory_desc_t *md)
<span class="p_chunk">@@ -40,7 +42,7 @@</span> <span class="p_context"> static phys_addr_t efi_to_phys(unsigned long addr)</span>
 {
 	efi_memory_desc_t *md;
 
<span class="p_del">-	for_each_efi_memory_desc(&amp;memmap, md) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME))
 			continue;
 		if (md-&gt;virt_addr == 0)
<span class="p_chunk">@@ -53,6 +55,36 @@</span> <span class="p_context"> static phys_addr_t efi_to_phys(unsigned long addr)</span>
 	return addr;
 }
 
<span class="p_add">+static __initdata unsigned long screen_info_table = EFI_INVALID_TABLE_ADDR;</span>
<span class="p_add">+</span>
<span class="p_add">+static __initdata efi_config_table_type_t arch_tables[] = {</span>
<span class="p_add">+	{LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID, NULL, &amp;screen_info_table},</span>
<span class="p_add">+	{NULL_GUID, NULL, NULL}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init init_screen_info(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct screen_info *si;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (screen_info_table != EFI_INVALID_TABLE_ADDR) {</span>
<span class="p_add">+		si = early_memremap_ro(screen_info_table, sizeof(*si));</span>
<span class="p_add">+		if (!si) {</span>
<span class="p_add">+			pr_err(&quot;Could not map screen_info config table\n&quot;);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		screen_info = *si;</span>
<span class="p_add">+		early_memunmap(si, sizeof(*si));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* dummycon on ARM needs non-zero values for columns/lines */</span>
<span class="p_add">+		screen_info.orig_video_cols = 80;</span>
<span class="p_add">+		screen_info.orig_video_lines = 25;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (screen_info.orig_video_isVGA == VIDEO_TYPE_EFI &amp;&amp;</span>
<span class="p_add">+	    memblock_is_map_memory(screen_info.lfb_base))</span>
<span class="p_add">+		memblock_mark_nomap(screen_info.lfb_base, screen_info.lfb_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init uefi_init(void)
 {
 	efi_char16_t *c16;
<span class="p_chunk">@@ -85,6 +117,8 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 			efi.systab-&gt;hdr.revision &gt;&gt; 16,
 			efi.systab-&gt;hdr.revision &amp; 0xffff);
 
<span class="p_add">+	efi.runtime_version = efi.systab-&gt;hdr.revision;</span>
<span class="p_add">+</span>
 	/* Show what we know for posterity */
 	c16 = early_memremap_ro(efi_to_phys(efi.systab-&gt;fw_vendor),
 				sizeof(vendor) * sizeof(efi_char16_t));
<span class="p_chunk">@@ -108,7 +142,8 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 		goto out;
 	}
 	retval = efi_config_parse_tables(config_tables, efi.systab-&gt;nr_tables,
<span class="p_del">-					 sizeof(efi_config_table_t), NULL);</span>
<span class="p_add">+					 sizeof(efi_config_table_t),</span>
<span class="p_add">+					 arch_tables);</span>
 
 	early_memunmap(config_tables, table_size);
 out:
<span class="p_chunk">@@ -143,7 +178,7 @@</span> <span class="p_context"> static __init void reserve_regions(void)</span>
 	if (efi_enabled(EFI_DBG))
 		pr_info(&quot;Processing EFI memory map:\n&quot;);
 
<span class="p_del">-	for_each_efi_memory_desc(&amp;memmap, md) {</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		paddr = md-&gt;phys_addr;
 		npages = md-&gt;num_pages;
 
<span class="p_chunk">@@ -184,9 +219,9 @@</span> <span class="p_context"> void __init efi_init(void)</span>
 
 	efi_system_table = params.system_table;
 
<span class="p_del">-	memmap.phys_map = params.mmap;</span>
<span class="p_del">-	memmap.map = early_memremap_ro(params.mmap, params.mmap_size);</span>
<span class="p_del">-	if (memmap.map == NULL) {</span>
<span class="p_add">+	efi.memmap.phys_map = params.mmap;</span>
<span class="p_add">+	efi.memmap.map = early_memremap_ro(params.mmap, params.mmap_size);</span>
<span class="p_add">+	if (efi.memmap.map == NULL) {</span>
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only
 		* description of memory we have, so there is little point in
<span class="p_chunk">@@ -194,28 +229,37 @@</span> <span class="p_context"> void __init efi_init(void)</span>
 		*/
 		panic(&quot;Unable to map EFI memory map.\n&quot;);
 	}
<span class="p_del">-	memmap.map_end = memmap.map + params.mmap_size;</span>
<span class="p_del">-	memmap.desc_size = params.desc_size;</span>
<span class="p_del">-	memmap.desc_version = params.desc_ver;</span>
<span class="p_add">+	efi.memmap.map_end = efi.memmap.map + params.mmap_size;</span>
<span class="p_add">+	efi.memmap.desc_size = params.desc_size;</span>
<span class="p_add">+	efi.memmap.desc_version = params.desc_ver;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN(efi.memmap.desc_version != 1,</span>
<span class="p_add">+	     &quot;Unexpected EFI_MEMORY_DESCRIPTOR version %ld&quot;,</span>
<span class="p_add">+	      efi.memmap.desc_version);</span>
 
 	if (uefi_init() &lt; 0)
 		return;
 
 	reserve_regions();
<span class="p_del">-	early_memunmap(memmap.map, params.mmap_size);</span>
<span class="p_add">+	efi_memattr_init();</span>
<span class="p_add">+	early_memunmap(efi.memmap.map, params.mmap_size);</span>
 
<span class="p_del">-	if (IS_ENABLED(CONFIG_ARM)) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * ARM currently does not allow ioremap_cache() to be called on</span>
<span class="p_del">-		 * memory regions that are covered by struct page. So remove the</span>
<span class="p_del">-		 * UEFI memory map from the linear mapping.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		memblock_mark_nomap(params.mmap &amp; PAGE_MASK,</span>
<span class="p_del">-				    PAGE_ALIGN(params.mmap_size +</span>
<span class="p_del">-					       (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		memblock_reserve(params.mmap &amp; PAGE_MASK,</span>
<span class="p_del">-				 PAGE_ALIGN(params.mmap_size +</span>
<span class="p_del">-					    (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	memblock_reserve(params.mmap &amp; PAGE_MASK,</span>
<span class="p_add">+			 PAGE_ALIGN(params.mmap_size +</span>
<span class="p_add">+				    (params.mmap &amp; ~PAGE_MASK)));</span>
<span class="p_add">+</span>
<span class="p_add">+	init_screen_info();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init register_gop_device(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *pd;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (screen_info.orig_video_isVGA != VIDEO_TYPE_EFI)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pd = platform_device_register_data(NULL, &quot;efi-framebuffer&quot;, 0,</span>
<span class="p_add">+					   &amp;screen_info, sizeof(screen_info));</span>
<span class="p_add">+	return PTR_ERR_OR_ZERO(pd);</span>
 }
<span class="p_add">+subsys_initcall(register_gop_device);</span>
<span class="p_header">diff --git a/drivers/firmware/efi/arm-runtime.c b/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_header">index 6ae21e41a429..17ccf0a8787a 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_chunk">@@ -42,11 +42,13 @@</span> <span class="p_context"> static struct mm_struct efi_mm = {</span>
 static bool __init efi_virtmap_init(void)
 {
 	efi_memory_desc_t *md;
<span class="p_add">+	bool systab_found;</span>
 
 	efi_mm.pgd = pgd_alloc(&amp;efi_mm);
 	init_new_context(NULL, &amp;efi_mm);
 
<span class="p_del">-	for_each_efi_memory_desc(&amp;memmap, md) {</span>
<span class="p_add">+	systab_found = false;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		phys_addr_t phys = md-&gt;phys_addr;
 		int ret;
 
<span class="p_chunk">@@ -64,7 +66,25 @@</span> <span class="p_context"> static bool __init efi_virtmap_init(void)</span>
 				&amp;phys, ret);
 			return false;
 		}
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If this entry covers the address of the UEFI system table,</span>
<span class="p_add">+		 * calculate and record its virtual address.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (efi_system_table &gt;= phys &amp;&amp;</span>
<span class="p_add">+		    efi_system_table &lt; phys + (md-&gt;num_pages * EFI_PAGE_SIZE)) {</span>
<span class="p_add">+			efi.systab = (void *)(unsigned long)(efi_system_table -</span>
<span class="p_add">+							     phys + md-&gt;virt_addr);</span>
<span class="p_add">+			systab_found = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!systab_found) {</span>
<span class="p_add">+		pr_err(&quot;No virtual mapping found for the UEFI System Table\n&quot;);</span>
<span class="p_add">+		return false;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (efi_memattr_apply_permissions(&amp;efi_mm, efi_set_mapping_permissions))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	return true;
 }
 
<span class="p_chunk">@@ -89,26 +109,17 @@</span> <span class="p_context"> static int __init arm_enable_runtime_services(void)</span>
 
 	pr_info(&quot;Remapping and enabling EFI services.\n&quot;);
 
<span class="p_del">-	mapsize = memmap.map_end - memmap.map;</span>
<span class="p_del">-	memmap.map = (__force void *)ioremap_cache(memmap.phys_map,</span>
<span class="p_del">-						   mapsize);</span>
<span class="p_del">-	if (!memmap.map) {</span>
<span class="p_del">-		pr_err(&quot;Failed to remap EFI memory map\n&quot;);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	memmap.map_end = memmap.map + mapsize;</span>
<span class="p_del">-	efi.memmap = &amp;memmap;</span>
<span class="p_add">+	mapsize = efi.memmap.map_end - efi.memmap.map;</span>
 
<span class="p_del">-	efi.systab = (__force void *)ioremap_cache(efi_system_table,</span>
<span class="p_del">-						   sizeof(efi_system_table_t));</span>
<span class="p_del">-	if (!efi.systab) {</span>
<span class="p_del">-		pr_err(&quot;Failed to remap EFI System Table\n&quot;);</span>
<span class="p_add">+	efi.memmap.map = memremap(efi.memmap.phys_map, mapsize, MEMREMAP_WB);</span>
<span class="p_add">+	if (!efi.memmap.map) {</span>
<span class="p_add">+		pr_err(&quot;Failed to remap EFI memory map\n&quot;);</span>
 		return -ENOMEM;
 	}
<span class="p_del">-	set_bit(EFI_SYSTEM_TABLES, &amp;efi.flags);</span>
<span class="p_add">+	efi.memmap.map_end = efi.memmap.map + mapsize;</span>
 
 	if (!efi_virtmap_init()) {
<span class="p_del">-		pr_err(&quot;No UEFI virtual mapping was installed -- runtime services will not be available\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;UEFI virtual mapping missing or invalid -- runtime services will not be available\n&quot;);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -116,8 +127,6 @@</span> <span class="p_context"> static int __init arm_enable_runtime_services(void)</span>
 	efi_native_runtime_setup();
 	set_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);
 
<span class="p_del">-	efi.runtime_version = efi.systab-&gt;hdr.revision;</span>
<span class="p_del">-</span>
 	return 0;
 }
 early_initcall(arm_enable_runtime_services);
<span class="p_header">diff --git a/drivers/firmware/efi/capsule-loader.c b/drivers/firmware/efi/capsule-loader.c</span>
new file mode 100644
<span class="p_header">index 000000000000..c99c24bc79b0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_chunk">@@ -0,0 +1,343 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * EFI capsule loader driver.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2015 Intel Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is part of the Linux kernel, and is made available under</span>
<span class="p_add">+ * the terms of the GNU General Public License version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;efi: &quot; fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/miscdevice.h&gt;</span>
<span class="p_add">+#include &lt;linux/highmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/mutex.h&gt;</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define NO_FURTHER_WRITE_ACTION -1</span>
<span class="p_add">+</span>
<span class="p_add">+struct capsule_info {</span>
<span class="p_add">+	bool		header_obtained;</span>
<span class="p_add">+	int		reset_type;</span>
<span class="p_add">+	long		index;</span>
<span class="p_add">+	size_t		count;</span>
<span class="p_add">+	size_t		total_size;</span>
<span class="p_add">+	struct page	**pages;</span>
<span class="p_add">+	size_t		page_bytes_remain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_free_all_buff_pages - free all previous allocated buffer pages</span>
<span class="p_add">+ * @cap_info: pointer to current instance of capsule_info structure</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	In addition to freeing buffer pages, it flags NO_FURTHER_WRITE_ACTION</span>
<span class="p_add">+ *	to cease processing data in subsequent write(2) calls until close(2)</span>
<span class="p_add">+ *	is called.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static void efi_free_all_buff_pages(struct capsule_info *cap_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (cap_info-&gt;index &gt; 0)</span>
<span class="p_add">+		__free_page(cap_info-&gt;pages[--cap_info-&gt;index]);</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info-&gt;index = NO_FURTHER_WRITE_ACTION;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_setup_info - obtain the efi capsule header in the binary and</span>
<span class="p_add">+ *			    setup capsule_info structure</span>
<span class="p_add">+ * @cap_info: pointer to current instance of capsule_info structure</span>
<span class="p_add">+ * @kbuff: a mapped first page buffer pointer</span>
<span class="p_add">+ * @hdr_bytes: the total received number of bytes for efi header</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static ssize_t efi_capsule_setup_info(struct capsule_info *cap_info,</span>
<span class="p_add">+				      void *kbuff, size_t hdr_bytes)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_capsule_header_t *cap_hdr;</span>
<span class="p_add">+	size_t pages_needed;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	void *temp_page;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only process data block that is larger than efi header size */</span>
<span class="p_add">+	if (hdr_bytes &lt; sizeof(efi_capsule_header_t))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reset back to the correct offset of header */</span>
<span class="p_add">+	cap_hdr = kbuff - cap_info-&gt;count;</span>
<span class="p_add">+	pages_needed = ALIGN(cap_hdr-&gt;imagesize, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pages_needed == 0) {</span>
<span class="p_add">+		pr_err(&quot;%s: pages count invalid\n&quot;, __func__);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if the capsule binary supported */</span>
<span class="p_add">+	ret = efi_capsule_supported(cap_hdr-&gt;guid, cap_hdr-&gt;flags,</span>
<span class="p_add">+				    cap_hdr-&gt;imagesize,</span>
<span class="p_add">+				    &amp;cap_info-&gt;reset_type);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: efi_capsule_supported() failed\n&quot;,</span>
<span class="p_add">+		       __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info-&gt;total_size = cap_hdr-&gt;imagesize;</span>
<span class="p_add">+	temp_page = krealloc(cap_info-&gt;pages,</span>
<span class="p_add">+			     pages_needed * sizeof(void *),</span>
<span class="p_add">+			     GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+	if (!temp_page) {</span>
<span class="p_add">+		pr_debug(&quot;%s: krealloc() failed\n&quot;, __func__);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info-&gt;pages = temp_page;</span>
<span class="p_add">+	cap_info-&gt;header_obtained = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_submit_update - invoke the efi_capsule_update API once binary</span>
<span class="p_add">+ *			       upload done</span>
<span class="p_add">+ * @cap_info: pointer to current instance of capsule_info structure</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	void *cap_hdr_temp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_hdr_temp = kmap(cap_info-&gt;pages[0]);</span>
<span class="p_add">+	if (!cap_hdr_temp) {</span>
<span class="p_add">+		pr_debug(&quot;%s: kmap() failed\n&quot;, __func__);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = efi_capsule_update(cap_hdr_temp, cap_info-&gt;pages);</span>
<span class="p_add">+	kunmap(cap_info-&gt;pages[0]);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: efi_capsule_update() failed\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Indicate capsule binary uploading is done */</span>
<span class="p_add">+	cap_info-&gt;index = NO_FURTHER_WRITE_ACTION;</span>
<span class="p_add">+	pr_info(&quot;%s: Successfully upload capsule file with reboot type &#39;%s&#39;\n&quot;,</span>
<span class="p_add">+		__func__, !cap_info-&gt;reset_type ? &quot;RESET_COLD&quot; :</span>
<span class="p_add">+		cap_info-&gt;reset_type == 1 ? &quot;RESET_WARM&quot; :</span>
<span class="p_add">+		&quot;RESET_SHUTDOWN&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_write - store the capsule binary and pass it to</span>
<span class="p_add">+ *		       efi_capsule_update() API</span>
<span class="p_add">+ * @file: file pointer</span>
<span class="p_add">+ * @buff: buffer pointer</span>
<span class="p_add">+ * @count: number of bytes in @buff</span>
<span class="p_add">+ * @offp: not used</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Expectation:</span>
<span class="p_add">+ *	- A user space tool should start at the beginning of capsule binary and</span>
<span class="p_add">+ *	  pass data in sequentially.</span>
<span class="p_add">+ *	- Users should close and re-open this file note in order to upload more</span>
<span class="p_add">+ *	  capsules.</span>
<span class="p_add">+ *	- After an error returned, user should close the file and restart the</span>
<span class="p_add">+ *	  operation for the next try otherwise -EIO will be returned until the</span>
<span class="p_add">+ *	  file is closed.</span>
<span class="p_add">+ *	- An EFI capsule header must be located at the beginning of capsule</span>
<span class="p_add">+ *	  binary file and passed in as first block data of write operation.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static ssize_t efi_capsule_write(struct file *file, const char __user *buff,</span>
<span class="p_add">+				 size_t count, loff_t *offp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	struct capsule_info *cap_info = file-&gt;private_data;</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+	void *kbuff = NULL;</span>
<span class="p_add">+	size_t write_byte;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Return error while NO_FURTHER_WRITE_ACTION is flagged */</span>
<span class="p_add">+	if (cap_info-&gt;index &lt; 0)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only alloc a new page when previous page is full */</span>
<span class="p_add">+	if (!cap_info-&gt;page_bytes_remain) {</span>
<span class="p_add">+		page = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+		if (!page) {</span>
<span class="p_add">+			pr_debug(&quot;%s: alloc_page() failed\n&quot;, __func__);</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto failed;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		cap_info-&gt;pages[cap_info-&gt;index++] = page;</span>
<span class="p_add">+		cap_info-&gt;page_bytes_remain = PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	page = cap_info-&gt;pages[cap_info-&gt;index - 1];</span>
<span class="p_add">+</span>
<span class="p_add">+	kbuff = kmap(page);</span>
<span class="p_add">+	if (!kbuff) {</span>
<span class="p_add">+		pr_debug(&quot;%s: kmap() failed\n&quot;, __func__);</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+		goto failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kbuff += PAGE_SIZE - cap_info-&gt;page_bytes_remain;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy capsule binary data from user space to kernel space buffer */</span>
<span class="p_add">+	write_byte = min_t(size_t, count, cap_info-&gt;page_bytes_remain);</span>
<span class="p_add">+	if (copy_from_user(kbuff, buff, write_byte)) {</span>
<span class="p_add">+		pr_debug(&quot;%s: copy_from_user() failed\n&quot;, __func__);</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+		goto fail_unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cap_info-&gt;page_bytes_remain -= write_byte;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Setup capsule binary info structure */</span>
<span class="p_add">+	if (!cap_info-&gt;header_obtained) {</span>
<span class="p_add">+		ret = efi_capsule_setup_info(cap_info, kbuff,</span>
<span class="p_add">+					     cap_info-&gt;count + write_byte);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto fail_unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info-&gt;count += write_byte;</span>
<span class="p_add">+	kunmap(page);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Submit the full binary to efi_capsule_update() API */</span>
<span class="p_add">+	if (cap_info-&gt;header_obtained &amp;&amp;</span>
<span class="p_add">+	    cap_info-&gt;count &gt;= cap_info-&gt;total_size) {</span>
<span class="p_add">+		if (cap_info-&gt;count &gt; cap_info-&gt;total_size) {</span>
<span class="p_add">+			pr_err(&quot;%s: upload size exceeded header defined size\n&quot;,</span>
<span class="p_add">+			       __func__);</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto failed;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = efi_capsule_submit_update(cap_info);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return write_byte;</span>
<span class="p_add">+</span>
<span class="p_add">+fail_unmap:</span>
<span class="p_add">+	kunmap(page);</span>
<span class="p_add">+failed:</span>
<span class="p_add">+	efi_free_all_buff_pages(cap_info);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_flush - called by file close or file flush</span>
<span class="p_add">+ * @file: file pointer</span>
<span class="p_add">+ * @id: not used</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	If a capsule is being partially uploaded then calling this function</span>
<span class="p_add">+ *	will be treated as upload termination and will free those completed</span>
<span class="p_add">+ *	buffer pages and -ECANCELED will be returned.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static int efi_capsule_flush(struct file *file, fl_owner_t id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	struct capsule_info *cap_info = file-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cap_info-&gt;index &gt; 0) {</span>
<span class="p_add">+		pr_err(&quot;%s: capsule upload not complete\n&quot;, __func__);</span>
<span class="p_add">+		efi_free_all_buff_pages(cap_info);</span>
<span class="p_add">+		ret = -ECANCELED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_release - called by file close</span>
<span class="p_add">+ * @inode: not used</span>
<span class="p_add">+ * @file: file pointer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	We will not free successfully submitted pages since efi update</span>
<span class="p_add">+ *	requires data to be maintained across system reboot.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static int efi_capsule_release(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct capsule_info *cap_info = file-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(cap_info-&gt;pages);</span>
<span class="p_add">+	kfree(file-&gt;private_data);</span>
<span class="p_add">+	file-&gt;private_data = NULL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_open - called by file open</span>
<span class="p_add">+ * @inode: not used</span>
<span class="p_add">+ * @file: file pointer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Will allocate each capsule_info memory for each file open call.</span>
<span class="p_add">+ *	This provided the capability to support multiple file open feature</span>
<span class="p_add">+ *	where user is not needed to wait for others to finish in order to</span>
<span class="p_add">+ *	upload their capsule binary.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static int efi_capsule_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct capsule_info *cap_info;</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info = kzalloc(sizeof(*cap_info), GFP_KERNEL);</span>
<span class="p_add">+	if (!cap_info)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	cap_info-&gt;pages = kzalloc(sizeof(void *), GFP_KERNEL);</span>
<span class="p_add">+	if (!cap_info-&gt;pages) {</span>
<span class="p_add">+		kfree(cap_info);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	file-&gt;private_data = cap_info;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct file_operations efi_capsule_fops = {</span>
<span class="p_add">+	.owner = THIS_MODULE,</span>
<span class="p_add">+	.open = efi_capsule_open,</span>
<span class="p_add">+	.write = efi_capsule_write,</span>
<span class="p_add">+	.flush = efi_capsule_flush,</span>
<span class="p_add">+	.release = efi_capsule_release,</span>
<span class="p_add">+	.llseek = no_llseek,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct miscdevice efi_capsule_misc = {</span>
<span class="p_add">+	.minor = MISC_DYNAMIC_MINOR,</span>
<span class="p_add">+	.name = &quot;efi_capsule_loader&quot;,</span>
<span class="p_add">+	.fops = &amp;efi_capsule_fops,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init efi_capsule_loader_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!efi_enabled(EFI_RUNTIME_SERVICES))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = misc_register(&amp;efi_capsule_misc);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pr_err(&quot;%s: Failed to register misc char file note\n&quot;,</span>
<span class="p_add">+		       __func__);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(efi_capsule_loader_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit efi_capsule_loader_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	misc_deregister(&amp;efi_capsule_misc);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(efi_capsule_loader_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;EFI capsule firmware binary loader&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_header">diff --git a/drivers/firmware/efi/capsule.c b/drivers/firmware/efi/capsule.c</span>
new file mode 100644
<span class="p_header">index 000000000000..53b9fd2293ee</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/capsule.c</span>
<span class="p_chunk">@@ -0,0 +1,308 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * EFI capsule support.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2013 Intel Corporation; author Matt Fleming</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is part of the Linux kernel, and is made available under</span>
<span class="p_add">+ * the terms of the GNU General Public License version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;efi: &quot; fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/mutex.h&gt;</span>
<span class="p_add">+#include &lt;linux/highmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+typedef struct {</span>
<span class="p_add">+	u64 length;</span>
<span class="p_add">+	u64 data;</span>
<span class="p_add">+} efi_capsule_block_desc_t;</span>
<span class="p_add">+</span>
<span class="p_add">+static bool capsule_pending;</span>
<span class="p_add">+static bool stop_capsules;</span>
<span class="p_add">+static int efi_reset_type = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * capsule_mutex serialises access to both capsule_pending and</span>
<span class="p_add">+ * efi_reset_type and stop_capsules.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static DEFINE_MUTEX(capsule_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_pending - has a capsule been passed to the firmware?</span>
<span class="p_add">+ * @reset_type: store the type of EFI reset if capsule is pending</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To ensure that the registered capsule is processed correctly by the</span>
<span class="p_add">+ * firmware we need to perform a specific type of reset. If a capsule is</span>
<span class="p_add">+ * pending return the reset type in @reset_type.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function will race with callers of efi_capsule_update(), for</span>
<span class="p_add">+ * example, calling this function while somebody else is in</span>
<span class="p_add">+ * efi_capsule_update() but hasn&#39;t reached efi_capsue_update_locked()</span>
<span class="p_add">+ * will miss the updates to capsule_pending and efi_reset_type after</span>
<span class="p_add">+ * efi_capsule_update_locked() completes.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A non-racy use is from platform reboot code because we use</span>
<span class="p_add">+ * system_state to ensure no capsules can be sent to the firmware once</span>
<span class="p_add">+ * we&#39;re at SYSTEM_RESTART. See efi_capsule_update_locked().</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool efi_capsule_pending(int *reset_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!capsule_pending)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (reset_type)</span>
<span class="p_add">+		*reset_type = efi_reset_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Whitelist of EFI capsule flags that we support.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We do not handle EFI_CAPSULE_INITIATE_RESET because that would</span>
<span class="p_add">+ * require us to prepare the kernel for reboot. Refuse to load any</span>
<span class="p_add">+ * capsules with that flag and any other flags that we do not know how</span>
<span class="p_add">+ * to handle.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define EFI_CAPSULE_SUPPORTED_FLAG_MASK			\</span>
<span class="p_add">+	(EFI_CAPSULE_PERSIST_ACROSS_RESET | EFI_CAPSULE_POPULATE_SYSTEM_TABLE)</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_supported - does the firmware support the capsule?</span>
<span class="p_add">+ * @guid: vendor guid of capsule</span>
<span class="p_add">+ * @flags: capsule flags</span>
<span class="p_add">+ * @size: size of capsule data</span>
<span class="p_add">+ * @reset: the reset type required for this capsule</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Check whether a capsule with @flags is supported by the firmware</span>
<span class="p_add">+ * and that @size doesn&#39;t exceed the maximum size for a capsule.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * No attempt is made to check @reset against the reset type required</span>
<span class="p_add">+ * by any pending capsules because of the races involved.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int efi_capsule_supported(efi_guid_t guid, u32 flags, size_t size, int *reset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_capsule_header_t capsule;</span>
<span class="p_add">+	efi_capsule_header_t *cap_list[] = { &amp;capsule };</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	u64 max_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (flags &amp; ~EFI_CAPSULE_SUPPORTED_FLAG_MASK)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	capsule.headersize = capsule.imagesize = sizeof(capsule);</span>
<span class="p_add">+	memcpy(&amp;capsule.guid, &amp;guid, sizeof(efi_guid_t));</span>
<span class="p_add">+	capsule.flags = flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi.query_capsule_caps(cap_list, 1, &amp;max_size, reset);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return efi_status_to_err(status);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &gt; max_size)</span>
<span class="p_add">+		return -ENOSPC;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(efi_capsule_supported);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Every scatter gather list (block descriptor) page must end with a</span>
<span class="p_add">+ * continuation pointer. The last continuation pointer of the last</span>
<span class="p_add">+ * page must be zero to mark the end of the chain.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SGLIST_PER_PAGE	((PAGE_SIZE / sizeof(efi_capsule_block_desc_t)) - 1)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * How many scatter gather list (block descriptor) pages do we need</span>
<span class="p_add">+ * to map @count pages?</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline unsigned int sg_pages_num(unsigned int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return DIV_ROUND_UP(count, SGLIST_PER_PAGE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_update_locked - pass a single capsule to the firmware</span>
<span class="p_add">+ * @capsule: capsule to send to the firmware</span>
<span class="p_add">+ * @sg_pages: array of scatter gather (block descriptor) pages</span>
<span class="p_add">+ * @reset: the reset type required for @capsule</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Since this function must be called under capsule_mutex check</span>
<span class="p_add">+ * whether efi_reset_type will conflict with @reset, and atomically</span>
<span class="p_add">+ * set it and capsule_pending if a capsule was successfully sent to</span>
<span class="p_add">+ * the firmware.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We also check to see if the system is about to restart, and if so,</span>
<span class="p_add">+ * abort. This avoids races between efi_capsule_update() and</span>
<span class="p_add">+ * efi_capsule_pending().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int</span>
<span class="p_add">+efi_capsule_update_locked(efi_capsule_header_t *capsule,</span>
<span class="p_add">+			  struct page **sg_pages, int reset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_physical_addr_t sglist_phys;</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;capsule_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If someone has already registered a capsule that requires a</span>
<span class="p_add">+	 * different reset type, we&#39;re out of luck and must abort.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (efi_reset_type &gt;= 0 &amp;&amp; efi_reset_type != reset) {</span>
<span class="p_add">+		pr_err(&quot;Conflicting capsule reset type %d (%d).\n&quot;,</span>
<span class="p_add">+		       reset, efi_reset_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the system is getting ready to restart it may have</span>
<span class="p_add">+	 * called efi_capsule_pending() to make decisions (such as</span>
<span class="p_add">+	 * whether to force an EFI reboot), and we&#39;re racing against</span>
<span class="p_add">+	 * that call. Abort in that case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(stop_capsules)) {</span>
<span class="p_add">+		pr_warn(&quot;Capsule update raced with reboot, aborting.\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sglist_phys = page_to_phys(sg_pages[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi.update_capsule(&amp;capsule, 1, sglist_phys);</span>
<span class="p_add">+	if (status == EFI_SUCCESS) {</span>
<span class="p_add">+		capsule_pending = true;</span>
<span class="p_add">+		efi_reset_type = reset;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return efi_status_to_err(status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * efi_capsule_update - send a capsule to the firmware</span>
<span class="p_add">+ * @capsule: capsule to send to firmware</span>
<span class="p_add">+ * @pages: an array of capsule data pages</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Build a scatter gather list with EFI capsule block descriptors to</span>
<span class="p_add">+ * map the capsule described by @capsule with its data in @pages and</span>
<span class="p_add">+ * send it to the firmware via the UpdateCapsule() runtime service.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @capsule must be a virtual mapping of the first page in @pages</span>
<span class="p_add">+ * (@pages[0]) in the kernel address space. That is, a</span>
<span class="p_add">+ * capsule_header_t that describes the entire contents of the capsule</span>
<span class="p_add">+ * must be at the start of the first data page.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Even though this function will validate that the firmware supports</span>
<span class="p_add">+ * the capsule guid, users will likely want to check that</span>
<span class="p_add">+ * efi_capsule_supported() returns true before calling this function</span>
<span class="p_add">+ * because it makes it easier to print helpful error messages.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If the capsule is successfully submitted to the firmware, any</span>
<span class="p_add">+ * subsequent calls to efi_capsule_pending() will return true. @pages</span>
<span class="p_add">+ * must not be released or modified if this function returns</span>
<span class="p_add">+ * successfully.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Callers must be prepared for this function to fail, which can</span>
<span class="p_add">+ * happen if we raced with system reboot or if there is already a</span>
<span class="p_add">+ * pending capsule that has a reset type that conflicts with the one</span>
<span class="p_add">+ * required by @capsule. Do NOT use efi_capsule_pending() to detect</span>
<span class="p_add">+ * this conflict since that would be racy. Instead, submit the capsule</span>
<span class="p_add">+ * to efi_capsule_update() and check the return value.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return 0 on success, a converted EFI status code on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int efi_capsule_update(efi_capsule_header_t *capsule, struct page **pages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 imagesize = capsule-&gt;imagesize;</span>
<span class="p_add">+	efi_guid_t guid = capsule-&gt;guid;</span>
<span class="p_add">+	unsigned int count, sg_count;</span>
<span class="p_add">+	u32 flags = capsule-&gt;flags;</span>
<span class="p_add">+	struct page **sg_pages;</span>
<span class="p_add">+	int rv, reset_type;</span>
<span class="p_add">+	int i, j;</span>
<span class="p_add">+</span>
<span class="p_add">+	rv = efi_capsule_supported(guid, flags, imagesize, &amp;reset_type);</span>
<span class="p_add">+	if (rv)</span>
<span class="p_add">+		return rv;</span>
<span class="p_add">+</span>
<span class="p_add">+	count = DIV_ROUND_UP(imagesize, PAGE_SIZE);</span>
<span class="p_add">+	sg_count = sg_pages_num(count);</span>
<span class="p_add">+</span>
<span class="p_add">+	sg_pages = kzalloc(sg_count * sizeof(*sg_pages), GFP_KERNEL);</span>
<span class="p_add">+	if (!sg_pages)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; sg_count; i++) {</span>
<span class="p_add">+		sg_pages[i] = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+		if (!sg_pages[i]) {</span>
<span class="p_add">+			rv = -ENOMEM;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; sg_count; i++) {</span>
<span class="p_add">+		efi_capsule_block_desc_t *sglist;</span>
<span class="p_add">+</span>
<span class="p_add">+		sglist = kmap(sg_pages[i]);</span>
<span class="p_add">+		if (!sglist) {</span>
<span class="p_add">+			rv = -ENOMEM;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (j = 0; j &lt; SGLIST_PER_PAGE &amp;&amp; count &gt; 0; j++) {</span>
<span class="p_add">+			u64 sz = min_t(u64, imagesize, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+			sglist[j].length = sz;</span>
<span class="p_add">+			sglist[j].data = page_to_phys(*pages++);</span>
<span class="p_add">+</span>
<span class="p_add">+			imagesize -= sz;</span>
<span class="p_add">+			count--;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Continuation pointer */</span>
<span class="p_add">+		sglist[j].length = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (i + 1 == sg_count)</span>
<span class="p_add">+			sglist[j].data = 0;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			sglist[j].data = page_to_phys(sg_pages[i + 1]);</span>
<span class="p_add">+</span>
<span class="p_add">+		kunmap(sg_pages[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;capsule_mutex);</span>
<span class="p_add">+	rv = efi_capsule_update_locked(capsule, sg_pages, reset_type);</span>
<span class="p_add">+	mutex_unlock(&amp;capsule_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	for (i = 0; rv &amp;&amp; i &lt; sg_count; i++) {</span>
<span class="p_add">+		if (sg_pages[i])</span>
<span class="p_add">+			__free_page(sg_pages[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(sg_pages);</span>
<span class="p_add">+	return rv;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(efi_capsule_update);</span>
<span class="p_add">+</span>
<span class="p_add">+static int capsule_reboot_notify(struct notifier_block *nb, unsigned long event, void *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;capsule_mutex);</span>
<span class="p_add">+	stop_capsules = true;</span>
<span class="p_add">+	mutex_unlock(&amp;capsule_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block capsule_reboot_nb = {</span>
<span class="p_add">+	.notifier_call = capsule_reboot_notify,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init capsule_reboot_register(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return register_reboot_notifier(&amp;capsule_reboot_nb);</span>
<span class="p_add">+}</span>
<span class="p_add">+core_initcall(capsule_reboot_register);</span>
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 3a69ed5ecfcb..05509f3aaee8 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"> struct efi __read_mostly efi = {</span>
 	.config_table		= EFI_INVALID_TABLE_ADDR,
 	.esrt			= EFI_INVALID_TABLE_ADDR,
 	.properties_table	= EFI_INVALID_TABLE_ADDR,
<span class="p_add">+	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,</span>
 };
 EXPORT_SYMBOL(efi);
 
<span class="p_chunk">@@ -256,7 +257,7 @@</span> <span class="p_context"> subsys_initcall(efisubsys_init);</span>
  */
 int __init efi_mem_desc_lookup(u64 phys_addr, efi_memory_desc_t *out_md)
 {
<span class="p_del">-	struct efi_memory_map *map = efi.memmap;</span>
<span class="p_add">+	struct efi_memory_map *map = &amp;efi.memmap;</span>
 	phys_addr_t p, e;
 
 	if (!efi_enabled(EFI_MEMMAP)) {
<span class="p_chunk">@@ -338,6 +339,7 @@</span> <span class="p_context"> static __initdata efi_config_table_type_t common_tables[] = {</span>
 	{UGA_IO_PROTOCOL_GUID, &quot;UGA&quot;, &amp;efi.uga},
 	{EFI_SYSTEM_RESOURCE_TABLE_GUID, &quot;ESRT&quot;, &amp;efi.esrt},
 	{EFI_PROPERTIES_TABLE_GUID, &quot;PROP&quot;, &amp;efi.properties_table},
<span class="p_add">+	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, &quot;MEMATTR&quot;, &amp;efi.mem_attr_table},</span>
 	{NULL_GUID, NULL, NULL},
 };
 
<span class="p_chunk">@@ -351,8 +353,9 @@</span> <span class="p_context"> static __init int match_config_table(efi_guid_t *guid,</span>
 		for (i = 0; efi_guidcmp(table_types[i].guid, NULL_GUID); i++) {
 			if (!efi_guidcmp(*guid, table_types[i].guid)) {
 				*(table_types[i].ptr) = table;
<span class="p_del">-				pr_cont(&quot; %s=0x%lx &quot;,</span>
<span class="p_del">-					table_types[i].name, table);</span>
<span class="p_add">+				if (table_types[i].name)</span>
<span class="p_add">+					pr_cont(&quot; %s=0x%lx &quot;,</span>
<span class="p_add">+						table_types[i].name, table);</span>
 				return 1;
 			}
 		}
<span class="p_chunk">@@ -620,16 +623,12 @@</span> <span class="p_context"> char * __init efi_md_typeattr_format(char *buf, size_t size,</span>
  */
 u64 __weak efi_mem_attributes(unsigned long phys_addr)
 {
<span class="p_del">-	struct efi_memory_map *map;</span>
 	efi_memory_desc_t *md;
<span class="p_del">-	void *p;</span>
 
 	if (!efi_enabled(EFI_MEMMAP))
 		return 0;
 
<span class="p_del">-	map = efi.memmap;</span>
<span class="p_del">-	for (p = map-&gt;map; p &lt; map-&gt;map_end; p += map-&gt;desc_size) {</span>
<span class="p_del">-		md = p;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		if ((md-&gt;phys_addr &lt;= phys_addr) &amp;&amp;
 		    (phys_addr &lt; (md-&gt;phys_addr +
 		    (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT))))
<span class="p_chunk">@@ -637,3 +636,36 @@</span> <span class="p_context"> u64 __weak efi_mem_attributes(unsigned long phys_addr)</span>
 	}
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+int efi_status_to_err(efi_status_t status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (status) {</span>
<span class="p_add">+	case EFI_SUCCESS:</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_INVALID_PARAMETER:</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_OUT_OF_RESOURCES:</span>
<span class="p_add">+		err = -ENOSPC;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_DEVICE_ERROR:</span>
<span class="p_add">+		err = -EIO;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_WRITE_PROTECTED:</span>
<span class="p_add">+		err = -EROFS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_SECURITY_VIOLATION:</span>
<span class="p_add">+		err = -EACCES;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case EFI_NOT_FOUND:</span>
<span class="p_add">+		err = -ENOENT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/firmware/efi/efibc.c b/drivers/firmware/efi/efibc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..8dd0c7085e59</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/efibc.c</span>
<span class="p_chunk">@@ -0,0 +1,113 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * efibc: control EFI bootloaders which obey LoaderEntryOneShot var</span>
<span class="p_add">+ * Copyright (c) 2013-2016, Intel Corporation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms and conditions of the GNU General Public License,</span>
<span class="p_add">+ * version 2, as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="p_add">+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="p_add">+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="p_add">+ * more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;efibc: &quot; fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void efibc_str_to_str16(const char *str, efi_char16_t *str16)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; strlen(str); i++)</span>
<span class="p_add">+		str16[i] = str[i];</span>
<span class="p_add">+</span>
<span class="p_add">+	str16[i] = &#39;\0&#39;;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int efibc_set_variable(const char *name, const char *value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	efi_guid_t guid = LINUX_EFI_LOADER_ENTRY_GUID;</span>
<span class="p_add">+	struct efivar_entry *entry;</span>
<span class="p_add">+	size_t size = (strlen(value) + 1) * sizeof(efi_char16_t);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &gt; sizeof(entry-&gt;var.Data)) {</span>
<span class="p_add">+		pr_err(&quot;value is too large&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);</span>
<span class="p_add">+	if (!entry) {</span>
<span class="p_add">+		pr_err(&quot;failed to allocate efivar entry&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	efibc_str_to_str16(name, entry-&gt;var.VariableName);</span>
<span class="p_add">+	efibc_str_to_str16(value, (efi_char16_t *)entry-&gt;var.Data);</span>
<span class="p_add">+	memcpy(&amp;entry-&gt;var.VendorGuid, &amp;guid, sizeof(guid));</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = efivar_entry_set(entry,</span>
<span class="p_add">+			       EFI_VARIABLE_NON_VOLATILE</span>
<span class="p_add">+			       | EFI_VARIABLE_BOOTSERVICE_ACCESS</span>
<span class="p_add">+			       | EFI_VARIABLE_RUNTIME_ACCESS,</span>
<span class="p_add">+			       size, entry-&gt;var.Data, NULL);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pr_err(&quot;failed to set %s EFI variable: 0x%x\n&quot;,</span>
<span class="p_add">+		       name, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(entry);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int efibc_reboot_notifier_call(struct notifier_block *notifier,</span>
<span class="p_add">+				      unsigned long event, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *reason = &quot;shutdown&quot;;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (event == SYS_RESTART)</span>
<span class="p_add">+		reason = &quot;reboot&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = efibc_set_variable(&quot;LoaderEntryRebootReason&quot;, reason);</span>
<span class="p_add">+	if (ret || !data)</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	efibc_set_variable(&quot;LoaderEntryOneShot&quot;, (char *)data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block efibc_reboot_notifier = {</span>
<span class="p_add">+	.notifier_call = efibc_reboot_notifier_call,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init efibc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!efi_enabled(EFI_RUNTIME_SERVICES))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_reboot_notifier(&amp;efibc_reboot_notifier);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pr_err(&quot;unable to register reboot notifier\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+module_init(efibc_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit efibc_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unregister_reboot_notifier(&amp;efibc_reboot_notifier);</span>
<span class="p_add">+}</span>
<span class="p_add">+module_exit(efibc_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Jeremy Compostella &lt;jeremy.compostella@intel.com&gt;&quot;);</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Matt Gumbel &lt;matthew.k.gumbel@intel.com&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;EFI Bootloader Control&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_header">diff --git a/drivers/firmware/efi/efivars.c b/drivers/firmware/efi/efivars.c</span>
<span class="p_header">index 096adcbcb5a9..116b244dee68 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efivars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efivars.c</span>
<span class="p_chunk">@@ -661,7 +661,7 @@</span> <span class="p_context"> static void efivar_update_sysfs_entries(struct work_struct *work)</span>
 			return;
 
 		err = efivar_init(efivar_update_sysfs_entry, entry,
<span class="p_del">-				  true, false, &amp;efivar_sysfs_list);</span>
<span class="p_add">+				  false, &amp;efivar_sysfs_list);</span>
 		if (!err)
 			break;
 
<span class="p_chunk">@@ -730,8 +730,7 @@</span> <span class="p_context"> int efivars_sysfs_init(void)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	efivar_init(efivars_sysfs_callback, NULL, false,</span>
<span class="p_del">-		    true, &amp;efivar_sysfs_list);</span>
<span class="p_add">+	efivar_init(efivars_sysfs_callback, NULL, true, &amp;efivar_sysfs_list);</span>
 
 	error = create_efivars_bin_attributes();
 	if (error) {
<span class="p_header">diff --git a/drivers/firmware/efi/fake_mem.c b/drivers/firmware/efi/fake_mem.c</span>
<span class="p_header">index ed3a854950cc..48430aba13c1 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/fake_mem.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/fake_mem.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static int __init cmp_fake_mem(const void *x1, const void *x2)</span>
 void __init efi_fake_memmap(void)
 {
 	u64 start, end, m_start, m_end, m_attr;
<span class="p_del">-	int new_nr_map = memmap.nr_map;</span>
<span class="p_add">+	int new_nr_map = efi.memmap.nr_map;</span>
 	efi_memory_desc_t *md;
 	phys_addr_t new_memmap_phy;
 	void *new_memmap;
<span class="p_chunk">@@ -68,8 +68,7 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 		return;
 
 	/* count up the number of EFI memory descriptor */
<span class="p_del">-	for (old = memmap.map; old &lt; memmap.map_end; old += memmap.desc_size) {</span>
<span class="p_del">-		md = old;</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
 		start = md-&gt;phys_addr;
 		end = start + (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT) - 1;
 
<span class="p_chunk">@@ -95,25 +94,25 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 	}
 
 	/* allocate memory for new EFI memmap */
<span class="p_del">-	new_memmap_phy = memblock_alloc(memmap.desc_size * new_nr_map,</span>
<span class="p_add">+	new_memmap_phy = memblock_alloc(efi.memmap.desc_size * new_nr_map,</span>
 					PAGE_SIZE);
 	if (!new_memmap_phy)
 		return;
 
 	/* create new EFI memmap */
 	new_memmap = early_memremap(new_memmap_phy,
<span class="p_del">-				    memmap.desc_size * new_nr_map);</span>
<span class="p_add">+				    efi.memmap.desc_size * new_nr_map);</span>
 	if (!new_memmap) {
<span class="p_del">-		memblock_free(new_memmap_phy, memmap.desc_size * new_nr_map);</span>
<span class="p_add">+		memblock_free(new_memmap_phy, efi.memmap.desc_size * new_nr_map);</span>
 		return;
 	}
 
<span class="p_del">-	for (old = memmap.map, new = new_memmap;</span>
<span class="p_del">-	     old &lt; memmap.map_end;</span>
<span class="p_del">-	     old += memmap.desc_size, new += memmap.desc_size) {</span>
<span class="p_add">+	for (old = efi.memmap.map, new = new_memmap;</span>
<span class="p_add">+	     old &lt; efi.memmap.map_end;</span>
<span class="p_add">+	     old += efi.memmap.desc_size, new += efi.memmap.desc_size) {</span>
 
 		/* copy original EFI memory descriptor */
<span class="p_del">-		memcpy(new, old, memmap.desc_size);</span>
<span class="p_add">+		memcpy(new, old, efi.memmap.desc_size);</span>
 		md = new;
 		start = md-&gt;phys_addr;
 		end = md-&gt;phys_addr + (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT) - 1;
<span class="p_chunk">@@ -134,8 +133,8 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 				md-&gt;num_pages = (m_end - md-&gt;phys_addr + 1) &gt;&gt;
 					EFI_PAGE_SHIFT;
 				/* latter part */
<span class="p_del">-				new += memmap.desc_size;</span>
<span class="p_del">-				memcpy(new, old, memmap.desc_size);</span>
<span class="p_add">+				new += efi.memmap.desc_size;</span>
<span class="p_add">+				memcpy(new, old, efi.memmap.desc_size);</span>
 				md = new;
 				md-&gt;phys_addr = m_end + 1;
 				md-&gt;num_pages = (end - md-&gt;phys_addr + 1) &gt;&gt;
<span class="p_chunk">@@ -147,16 +146,16 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 				md-&gt;num_pages = (m_start - md-&gt;phys_addr) &gt;&gt;
 					EFI_PAGE_SHIFT;
 				/* middle part */
<span class="p_del">-				new += memmap.desc_size;</span>
<span class="p_del">-				memcpy(new, old, memmap.desc_size);</span>
<span class="p_add">+				new += efi.memmap.desc_size;</span>
<span class="p_add">+				memcpy(new, old, efi.memmap.desc_size);</span>
 				md = new;
 				md-&gt;attribute |= m_attr;
 				md-&gt;phys_addr = m_start;
 				md-&gt;num_pages = (m_end - m_start + 1) &gt;&gt;
 					EFI_PAGE_SHIFT;
 				/* last part */
<span class="p_del">-				new += memmap.desc_size;</span>
<span class="p_del">-				memcpy(new, old, memmap.desc_size);</span>
<span class="p_add">+				new += efi.memmap.desc_size;</span>
<span class="p_add">+				memcpy(new, old, efi.memmap.desc_size);</span>
 				md = new;
 				md-&gt;phys_addr = m_end + 1;
 				md-&gt;num_pages = (end - m_end) &gt;&gt;
<span class="p_chunk">@@ -169,8 +168,8 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 				md-&gt;num_pages = (m_start - md-&gt;phys_addr) &gt;&gt;
 					EFI_PAGE_SHIFT;
 				/* latter part */
<span class="p_del">-				new += memmap.desc_size;</span>
<span class="p_del">-				memcpy(new, old, memmap.desc_size);</span>
<span class="p_add">+				new += efi.memmap.desc_size;</span>
<span class="p_add">+				memcpy(new, old, efi.memmap.desc_size);</span>
 				md = new;
 				md-&gt;phys_addr = m_start;
 				md-&gt;num_pages = (end - md-&gt;phys_addr + 1) &gt;&gt;
<span class="p_chunk">@@ -182,10 +181,10 @@</span> <span class="p_context"> void __init efi_fake_memmap(void)</span>
 
 	/* swap into new EFI memmap */
 	efi_unmap_memmap();
<span class="p_del">-	memmap.map = new_memmap;</span>
<span class="p_del">-	memmap.phys_map = new_memmap_phy;</span>
<span class="p_del">-	memmap.nr_map = new_nr_map;</span>
<span class="p_del">-	memmap.map_end = memmap.map + memmap.nr_map * memmap.desc_size;</span>
<span class="p_add">+	efi.memmap.map = new_memmap;</span>
<span class="p_add">+	efi.memmap.phys_map = new_memmap_phy;</span>
<span class="p_add">+	efi.memmap.nr_map = new_nr_map;</span>
<span class="p_add">+	efi.memmap.map_end = efi.memmap.map + efi.memmap.nr_map * efi.memmap.desc_size;</span>
 	set_bit(EFI_MEMMAP, &amp;efi.flags);
 
 	/* print new EFI memmap */
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile</span>
<span class="p_header">index da99bbb74aeb..c06945160a41 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/Makefile</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/Makefile</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"> OBJECT_FILES_NON_STANDARD	:= y</span>
 # Prevents link failures: __sanitizer_cov_trace_pc() is not linked in.
 KCOV_INSTRUMENT			:= n
 
<span class="p_del">-lib-y				:= efi-stub-helper.o</span>
<span class="p_add">+lib-y				:= efi-stub-helper.o gop.o</span>
 
 # include the stub&#39;s generic dependencies from lib/ when building for ARM/arm64
 arm-deps := fdt_rw.c fdt_ro.c fdt_wip.c fdt.c fdt_empty_tree.c fdt_sw.c sort.c
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/arm-stub.c b/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_header">index 414deb85c2e5..993aa56755f6 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_chunk">@@ -20,27 +20,49 @@</span> <span class="p_context"></span>
 
 bool __nokaslr;
 
<span class="p_del">-static int efi_secureboot_enabled(efi_system_table_t *sys_table_arg)</span>
<span class="p_add">+static int efi_get_secureboot(efi_system_table_t *sys_table_arg)</span>
 {
<span class="p_del">-	static efi_guid_t const var_guid = EFI_GLOBAL_VARIABLE_GUID;</span>
<span class="p_del">-	static efi_char16_t const var_name[] = {</span>
<span class="p_add">+	static efi_char16_t const sb_var_name[] = {</span>
 		&#39;S&#39;, &#39;e&#39;, &#39;c&#39;, &#39;u&#39;, &#39;r&#39;, &#39;e&#39;, &#39;B&#39;, &#39;o&#39;, &#39;o&#39;, &#39;t&#39;, 0 };
<span class="p_add">+	static efi_char16_t const sm_var_name[] = {</span>
<span class="p_add">+		&#39;S&#39;, &#39;e&#39;, &#39;t&#39;, &#39;u&#39;, &#39;p&#39;, &#39;M&#39;, &#39;o&#39;, &#39;d&#39;, &#39;e&#39;, 0 };</span>
 
<span class="p_add">+	efi_guid_t var_guid = EFI_GLOBAL_VARIABLE_GUID;</span>
 	efi_get_variable_t *f_getvar = sys_table_arg-&gt;runtime-&gt;get_variable;
<span class="p_del">-	unsigned long size = sizeof(u8);</span>
<span class="p_del">-	efi_status_t status;</span>
 	u8 val;
<span class="p_add">+	unsigned long size = sizeof(val);</span>
<span class="p_add">+	efi_status_t status;</span>
 
<span class="p_del">-	status = f_getvar((efi_char16_t *)var_name, (efi_guid_t *)&amp;var_guid,</span>
<span class="p_add">+	status = f_getvar((efi_char16_t *)sb_var_name, (efi_guid_t *)&amp;var_guid,</span>
 			  NULL, &amp;size, &amp;val);
 
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		goto out_efi_err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = f_getvar((efi_char16_t *)sm_var_name, (efi_guid_t *)&amp;var_guid,</span>
<span class="p_add">+			  NULL, &amp;size, &amp;val);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		goto out_efi_err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val == 1)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+out_efi_err:</span>
 	switch (status) {
<span class="p_del">-	case EFI_SUCCESS:</span>
<span class="p_del">-		return val;</span>
 	case EFI_NOT_FOUND:
 		return 0;
<span class="p_add">+	case EFI_DEVICE_ERROR:</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	case EFI_SECURITY_VIOLATION:</span>
<span class="p_add">+		return -EACCES;</span>
 	default:
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 }
 
<span class="p_chunk">@@ -147,6 +169,25 @@</span> <span class="p_context"> void efi_char16_printk(efi_system_table_t *sys_table_arg,</span>
 	out-&gt;output_string(out, str);
 }
 
<span class="p_add">+static struct screen_info *setup_graphics(efi_system_table_t *sys_table_arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_guid_t gop_proto = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+	void **gop_handle = NULL;</span>
<span class="p_add">+	struct screen_info *si = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = 0;</span>
<span class="p_add">+	status = efi_call_early(locate_handle, EFI_LOCATE_BY_PROTOCOL,</span>
<span class="p_add">+				&amp;gop_proto, NULL, &amp;size, gop_handle);</span>
<span class="p_add">+	if (status == EFI_BUFFER_TOO_SMALL) {</span>
<span class="p_add">+		si = alloc_screen_info(sys_table_arg);</span>
<span class="p_add">+		if (!si)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		efi_setup_gop(sys_table_arg, si, &amp;gop_proto, size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return si;</span>
<span class="p_add">+}</span>
 
 /*
  * This function handles the architcture specific differences between arm and
<span class="p_chunk">@@ -185,6 +226,8 @@</span> <span class="p_context"> unsigned long efi_entry(void *handle, efi_system_table_t *sys_table,</span>
 	efi_guid_t loaded_image_proto = LOADED_IMAGE_PROTOCOL_GUID;
 	unsigned long reserve_addr = 0;
 	unsigned long reserve_size = 0;
<span class="p_add">+	int secure_boot = 0;</span>
<span class="p_add">+	struct screen_info *si;</span>
 
 	/* Check if we were booted by the EFI firmware */
 	if (sys_table-&gt;hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
<span class="p_chunk">@@ -237,6 +280,8 @@</span> <span class="p_context"> unsigned long efi_entry(void *handle, efi_system_table_t *sys_table,</span>
 			__nokaslr = true;
 	}
 
<span class="p_add">+	si = setup_graphics(sys_table);</span>
<span class="p_add">+</span>
 	status = handle_kernel_image(sys_table, image_addr, &amp;image_size,
 				     &amp;reserve_addr,
 				     &amp;reserve_size,
<span class="p_chunk">@@ -250,12 +295,21 @@</span> <span class="p_context"> unsigned long efi_entry(void *handle, efi_system_table_t *sys_table,</span>
 	if (status != EFI_SUCCESS)
 		pr_efi_err(sys_table, &quot;Failed to parse EFI cmdline options\n&quot;);
 
<span class="p_add">+	secure_boot = efi_get_secureboot(sys_table);</span>
<span class="p_add">+	if (secure_boot &gt; 0)</span>
<span class="p_add">+		pr_efi(sys_table, &quot;UEFI Secure Boot is enabled.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (secure_boot &lt; 0) {</span>
<span class="p_add">+		pr_efi_err(sys_table,</span>
<span class="p_add">+			&quot;could not determine UEFI Secure Boot status.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Unauthenticated device tree data is a security hazard, so
 	 * ignore &#39;dtb=&#39; unless UEFI Secure Boot is disabled.
 	 */
<span class="p_del">-	if (efi_secureboot_enabled(sys_table)) {</span>
<span class="p_del">-		pr_efi(sys_table, &quot;UEFI Secure Boot is enabled.\n&quot;);</span>
<span class="p_add">+	if (secure_boot != 0 &amp;&amp; strstr(cmdline_ptr, &quot;dtb=&quot;)) {</span>
<span class="p_add">+		pr_efi(sys_table, &quot;Ignoring DTB from command line.\n&quot;);</span>
 	} else {
 		status = handle_cmdline_files(sys_table, image, cmdline_ptr,
 					      &quot;dtb=&quot;,
<span class="p_chunk">@@ -309,6 +363,7 @@</span> <span class="p_context"> unsigned long efi_entry(void *handle, efi_system_table_t *sys_table,</span>
 	efi_free(sys_table, image_size, *image_addr);
 	efi_free(sys_table, reserve_size, reserve_addr);
 fail_free_cmdline:
<span class="p_add">+	free_screen_info(sys_table, si);</span>
 	efi_free(sys_table, cmdline_size, (unsigned long)cmdline_ptr);
 fail:
 	return EFI_ERROR;
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/arm32-stub.c b/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_header">index 6f42be4d0084..e1f0b28e1dcb 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_chunk">@@ -26,6 +26,43 @@</span> <span class="p_context"> efi_status_t check_platform_features(efi_system_table_t *sys_table_arg)</span>
 	return EFI_SUCCESS;
 }
 
<span class="p_add">+static efi_guid_t screen_info_guid = LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID;</span>
<span class="p_add">+</span>
<span class="p_add">+struct screen_info *alloc_screen_info(efi_system_table_t *sys_table_arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct screen_info *si;</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Unlike on arm64, where we can directly fill out the screen_info</span>
<span class="p_add">+	 * structure from the stub, we need to allocate a buffer to hold</span>
<span class="p_add">+	 * its contents while we hand over to the kernel proper from the</span>
<span class="p_add">+	 * decompressor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	status = efi_call_early(allocate_pool, EFI_RUNTIME_SERVICES_DATA,</span>
<span class="p_add">+				sizeof(*si), (void **)&amp;si);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi_call_early(install_configuration_table,</span>
<span class="p_add">+				&amp;screen_info_guid, si);</span>
<span class="p_add">+	if (status == EFI_SUCCESS)</span>
<span class="p_add">+		return si;</span>
<span class="p_add">+</span>
<span class="p_add">+	efi_call_early(free_pool, si);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void free_screen_info(efi_system_table_t *sys_table_arg, struct screen_info *si)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!si)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	efi_call_early(install_configuration_table, &amp;screen_info_guid, NULL);</span>
<span class="p_add">+	efi_call_early(free_pool, si);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 efi_status_t handle_kernel_image(efi_system_table_t *sys_table,
 				 unsigned long *image_addr,
 				 unsigned long *image_size,
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c</span>
<span class="p_header">index 29ed2f9b218c..3bd127f95315 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/efi-stub-helper.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c</span>
<span class="p_chunk">@@ -125,10 +125,12 @@</span> <span class="p_context"> unsigned long get_dram_base(efi_system_table_t *sys_table_arg)</span>
 
 	map.map_end = map.map + map_size;
 
<span class="p_del">-	for_each_efi_memory_desc(&amp;map, md)</span>
<span class="p_del">-		if (md-&gt;attribute &amp; EFI_MEMORY_WB)</span>
<span class="p_add">+	for_each_efi_memory_desc_in_map(&amp;map, md) {</span>
<span class="p_add">+		if (md-&gt;attribute &amp; EFI_MEMORY_WB) {</span>
 			if (membase &gt; md-&gt;phys_addr)
 				membase = md-&gt;phys_addr;
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	efi_call_early(free_pool, map.map);
 
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/gop.c b/drivers/firmware/efi/libstub/gop.c</span>
new file mode 100644
<span class="p_header">index 000000000000..932742e4cf23</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/gop.c</span>
<span class="p_chunk">@@ -0,0 +1,354 @@</span> <span class="p_context"></span>
<span class="p_add">+/* -----------------------------------------------------------------------</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   Copyright 2011 Intel Corporation; author Matt Fleming</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This file is part of the Linux kernel, and is made available under</span>
<span class="p_add">+ *   the terms of the GNU General Public License version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ----------------------------------------------------------------------- */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/efi.h&gt;</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void find_bits(unsigned long mask, u8 *pos, u8 *size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 first, len;</span>
<span class="p_add">+</span>
<span class="p_add">+	first = 0;</span>
<span class="p_add">+	len = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mask) {</span>
<span class="p_add">+		while (!(mask &amp; 0x1)) {</span>
<span class="p_add">+			mask = mask &gt;&gt; 1;</span>
<span class="p_add">+			first++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		while (mask &amp; 0x1) {</span>
<span class="p_add">+			mask = mask &gt;&gt; 1;</span>
<span class="p_add">+			len++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*pos = first;</span>
<span class="p_add">+	*size = len;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,</span>
<span class="p_add">+		 struct efi_pixel_bitmask pixel_info, int pixel_format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pixel_format == PIXEL_RGB_RESERVED_8BIT_PER_COLOR) {</span>
<span class="p_add">+		si-&gt;lfb_depth = 32;</span>
<span class="p_add">+		si-&gt;lfb_linelength = pixels_per_scan_line * 4;</span>
<span class="p_add">+		si-&gt;red_size = 8;</span>
<span class="p_add">+		si-&gt;red_pos = 0;</span>
<span class="p_add">+		si-&gt;green_size = 8;</span>
<span class="p_add">+		si-&gt;green_pos = 8;</span>
<span class="p_add">+		si-&gt;blue_size = 8;</span>
<span class="p_add">+		si-&gt;blue_pos = 16;</span>
<span class="p_add">+		si-&gt;rsvd_size = 8;</span>
<span class="p_add">+		si-&gt;rsvd_pos = 24;</span>
<span class="p_add">+	} else if (pixel_format == PIXEL_BGR_RESERVED_8BIT_PER_COLOR) {</span>
<span class="p_add">+		si-&gt;lfb_depth = 32;</span>
<span class="p_add">+		si-&gt;lfb_linelength = pixels_per_scan_line * 4;</span>
<span class="p_add">+		si-&gt;red_size = 8;</span>
<span class="p_add">+		si-&gt;red_pos = 16;</span>
<span class="p_add">+		si-&gt;green_size = 8;</span>
<span class="p_add">+		si-&gt;green_pos = 8;</span>
<span class="p_add">+		si-&gt;blue_size = 8;</span>
<span class="p_add">+		si-&gt;blue_pos = 0;</span>
<span class="p_add">+		si-&gt;rsvd_size = 8;</span>
<span class="p_add">+		si-&gt;rsvd_pos = 24;</span>
<span class="p_add">+	} else if (pixel_format == PIXEL_BIT_MASK) {</span>
<span class="p_add">+		find_bits(pixel_info.red_mask, &amp;si-&gt;red_pos, &amp;si-&gt;red_size);</span>
<span class="p_add">+		find_bits(pixel_info.green_mask, &amp;si-&gt;green_pos,</span>
<span class="p_add">+			  &amp;si-&gt;green_size);</span>
<span class="p_add">+		find_bits(pixel_info.blue_mask, &amp;si-&gt;blue_pos, &amp;si-&gt;blue_size);</span>
<span class="p_add">+		find_bits(pixel_info.reserved_mask, &amp;si-&gt;rsvd_pos,</span>
<span class="p_add">+			  &amp;si-&gt;rsvd_size);</span>
<span class="p_add">+		si-&gt;lfb_depth = si-&gt;red_size + si-&gt;green_size +</span>
<span class="p_add">+			si-&gt;blue_size + si-&gt;rsvd_size;</span>
<span class="p_add">+		si-&gt;lfb_linelength = (pixels_per_scan_line * si-&gt;lfb_depth) / 8;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		si-&gt;lfb_depth = 4;</span>
<span class="p_add">+		si-&gt;lfb_linelength = si-&gt;lfb_width / 2;</span>
<span class="p_add">+		si-&gt;red_size = 0;</span>
<span class="p_add">+		si-&gt;red_pos = 0;</span>
<span class="p_add">+		si-&gt;green_size = 0;</span>
<span class="p_add">+		si-&gt;green_pos = 0;</span>
<span class="p_add">+		si-&gt;blue_size = 0;</span>
<span class="p_add">+		si-&gt;blue_pos = 0;</span>
<span class="p_add">+		si-&gt;rsvd_size = 0;</span>
<span class="p_add">+		si-&gt;rsvd_pos = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+__gop_query32(efi_system_table_t *sys_table_arg,</span>
<span class="p_add">+	      struct efi_graphics_output_protocol_32 *gop32,</span>
<span class="p_add">+	      struct efi_graphics_output_mode_info **info,</span>
<span class="p_add">+	      unsigned long *size, u64 *fb_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efi_graphics_output_protocol_mode_32 *mode;</span>
<span class="p_add">+	efi_graphics_output_protocol_query_mode query_mode;</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	unsigned long m;</span>
<span class="p_add">+</span>
<span class="p_add">+	m = gop32-&gt;mode;</span>
<span class="p_add">+	mode = (struct efi_graphics_output_protocol_mode_32 *)m;</span>
<span class="p_add">+	query_mode = (void *)(unsigned long)gop32-&gt;query_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = __efi_call_early(query_mode, (void *)gop32, mode-&gt;mode, size,</span>
<span class="p_add">+				  info);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	*fb_base = mode-&gt;frame_buffer_base;</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,</span>
<span class="p_add">+            efi_guid_t *proto, unsigned long size, void **gop_handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efi_graphics_output_protocol_32 *gop32, *first_gop;</span>
<span class="p_add">+	unsigned long nr_gops;</span>
<span class="p_add">+	u16 width, height;</span>
<span class="p_add">+	u32 pixels_per_scan_line;</span>
<span class="p_add">+	u32 ext_lfb_base;</span>
<span class="p_add">+	u64 fb_base;</span>
<span class="p_add">+	struct efi_pixel_bitmask pixel_info;</span>
<span class="p_add">+	int pixel_format;</span>
<span class="p_add">+	efi_status_t status = EFI_NOT_FOUND;</span>
<span class="p_add">+	u32 *handles = (u32 *)(unsigned long)gop_handle;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	first_gop = NULL;</span>
<span class="p_add">+	gop32 = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	nr_gops = size / sizeof(u32);</span>
<span class="p_add">+	for (i = 0; i &lt; nr_gops; i++) {</span>
<span class="p_add">+		struct efi_graphics_output_mode_info *info = NULL;</span>
<span class="p_add">+		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;</span>
<span class="p_add">+		bool conout_found = false;</span>
<span class="p_add">+		void *dummy = NULL;</span>
<span class="p_add">+		efi_handle_t h = (efi_handle_t)(unsigned long)handles[i];</span>
<span class="p_add">+		u64 current_fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = efi_call_early(handle_protocol, h,</span>
<span class="p_add">+					proto, (void **)&amp;gop32);</span>
<span class="p_add">+		if (status != EFI_SUCCESS)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = efi_call_early(handle_protocol, h,</span>
<span class="p_add">+					&amp;conout_proto, &amp;dummy);</span>
<span class="p_add">+		if (status == EFI_SUCCESS)</span>
<span class="p_add">+			conout_found = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = __gop_query32(sys_table_arg, gop32, &amp;info, &amp;size,</span>
<span class="p_add">+				       &amp;current_fb_base);</span>
<span class="p_add">+		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Systems that use the UEFI Console Splitter may</span>
<span class="p_add">+			 * provide multiple GOP devices, not all of which are</span>
<span class="p_add">+			 * backed by real hardware. The workaround is to search</span>
<span class="p_add">+			 * for a GOP implementing the ConOut protocol, and if</span>
<span class="p_add">+			 * one isn&#39;t found, to just fall back to the first GOP.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			width = info-&gt;horizontal_resolution;</span>
<span class="p_add">+			height = info-&gt;vertical_resolution;</span>
<span class="p_add">+			pixel_format = info-&gt;pixel_format;</span>
<span class="p_add">+			pixel_info = info-&gt;pixel_information;</span>
<span class="p_add">+			pixels_per_scan_line = info-&gt;pixels_per_scan_line;</span>
<span class="p_add">+			fb_base = current_fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Once we&#39;ve found a GOP supporting ConOut,</span>
<span class="p_add">+			 * don&#39;t bother looking any further.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			first_gop = gop32;</span>
<span class="p_add">+			if (conout_found)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Did we find any GOPs? */</span>
<span class="p_add">+	if (!first_gop)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* EFI framebuffer */</span>
<span class="p_add">+	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;lfb_width = width;</span>
<span class="p_add">+	si-&gt;lfb_height = height;</span>
<span class="p_add">+	si-&gt;lfb_base = fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ext_lfb_base = (u64)(unsigned long)fb_base &gt;&gt; 32;</span>
<span class="p_add">+	if (ext_lfb_base) {</span>
<span class="p_add">+		si-&gt;capabilities |= VIDEO_CAPABILITY_64BIT_BASE;</span>
<span class="p_add">+		si-&gt;ext_lfb_base = ext_lfb_base;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;pages = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+__gop_query64(efi_system_table_t *sys_table_arg,</span>
<span class="p_add">+	      struct efi_graphics_output_protocol_64 *gop64,</span>
<span class="p_add">+	      struct efi_graphics_output_mode_info **info,</span>
<span class="p_add">+	      unsigned long *size, u64 *fb_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efi_graphics_output_protocol_mode_64 *mode;</span>
<span class="p_add">+	efi_graphics_output_protocol_query_mode query_mode;</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	unsigned long m;</span>
<span class="p_add">+</span>
<span class="p_add">+	m = gop64-&gt;mode;</span>
<span class="p_add">+	mode = (struct efi_graphics_output_protocol_mode_64 *)m;</span>
<span class="p_add">+	query_mode = (void *)(unsigned long)gop64-&gt;query_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = __efi_call_early(query_mode, (void *)gop64, mode-&gt;mode, size,</span>
<span class="p_add">+				  info);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	*fb_base = mode-&gt;frame_buffer_base;</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,</span>
<span class="p_add">+	    efi_guid_t *proto, unsigned long size, void **gop_handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efi_graphics_output_protocol_64 *gop64, *first_gop;</span>
<span class="p_add">+	unsigned long nr_gops;</span>
<span class="p_add">+	u16 width, height;</span>
<span class="p_add">+	u32 pixels_per_scan_line;</span>
<span class="p_add">+	u32 ext_lfb_base;</span>
<span class="p_add">+	u64 fb_base;</span>
<span class="p_add">+	struct efi_pixel_bitmask pixel_info;</span>
<span class="p_add">+	int pixel_format;</span>
<span class="p_add">+	efi_status_t status = EFI_NOT_FOUND;</span>
<span class="p_add">+	u64 *handles = (u64 *)(unsigned long)gop_handle;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	first_gop = NULL;</span>
<span class="p_add">+	gop64 = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	nr_gops = size / sizeof(u64);</span>
<span class="p_add">+	for (i = 0; i &lt; nr_gops; i++) {</span>
<span class="p_add">+		struct efi_graphics_output_mode_info *info = NULL;</span>
<span class="p_add">+		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;</span>
<span class="p_add">+		bool conout_found = false;</span>
<span class="p_add">+		void *dummy = NULL;</span>
<span class="p_add">+		efi_handle_t h = (efi_handle_t)(unsigned long)handles[i];</span>
<span class="p_add">+		u64 current_fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = efi_call_early(handle_protocol, h,</span>
<span class="p_add">+					proto, (void **)&amp;gop64);</span>
<span class="p_add">+		if (status != EFI_SUCCESS)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = efi_call_early(handle_protocol, h,</span>
<span class="p_add">+					&amp;conout_proto, &amp;dummy);</span>
<span class="p_add">+		if (status == EFI_SUCCESS)</span>
<span class="p_add">+			conout_found = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = __gop_query64(sys_table_arg, gop64, &amp;info, &amp;size,</span>
<span class="p_add">+				       &amp;current_fb_base);</span>
<span class="p_add">+		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Systems that use the UEFI Console Splitter may</span>
<span class="p_add">+			 * provide multiple GOP devices, not all of which are</span>
<span class="p_add">+			 * backed by real hardware. The workaround is to search</span>
<span class="p_add">+			 * for a GOP implementing the ConOut protocol, and if</span>
<span class="p_add">+			 * one isn&#39;t found, to just fall back to the first GOP.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			width = info-&gt;horizontal_resolution;</span>
<span class="p_add">+			height = info-&gt;vertical_resolution;</span>
<span class="p_add">+			pixel_format = info-&gt;pixel_format;</span>
<span class="p_add">+			pixel_info = info-&gt;pixel_information;</span>
<span class="p_add">+			pixels_per_scan_line = info-&gt;pixels_per_scan_line;</span>
<span class="p_add">+			fb_base = current_fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Once we&#39;ve found a GOP supporting ConOut,</span>
<span class="p_add">+			 * don&#39;t bother looking any further.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			first_gop = gop64;</span>
<span class="p_add">+			if (conout_found)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Did we find any GOPs? */</span>
<span class="p_add">+	if (!first_gop)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* EFI framebuffer */</span>
<span class="p_add">+	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;lfb_width = width;</span>
<span class="p_add">+	si-&gt;lfb_height = height;</span>
<span class="p_add">+	si-&gt;lfb_base = fb_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ext_lfb_base = (u64)(unsigned long)fb_base &gt;&gt; 32;</span>
<span class="p_add">+	if (ext_lfb_base) {</span>
<span class="p_add">+		si-&gt;capabilities |= VIDEO_CAPABILITY_64BIT_BASE;</span>
<span class="p_add">+		si-&gt;ext_lfb_base = ext_lfb_base;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;pages = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_pixel_info(si, pixels_per_scan_line, pixel_info, pixel_format);</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;</span>
<span class="p_add">+</span>
<span class="p_add">+	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * See if we have Graphics Output Protocol</span>
<span class="p_add">+ */</span>
<span class="p_add">+efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,</span>
<span class="p_add">+			   struct screen_info *si, efi_guid_t *proto,</span>
<span class="p_add">+			   unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	void **gop_handle = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi_call_early(allocate_pool, EFI_LOADER_DATA,</span>
<span class="p_add">+				size, (void **)&amp;gop_handle);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi_call_early(locate_handle,</span>
<span class="p_add">+				EFI_LOCATE_BY_PROTOCOL,</span>
<span class="p_add">+				proto, NULL, &amp;size, gop_handle);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		goto free_handle;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_is_64bit()) {</span>
<span class="p_add">+		status = setup_gop64(sys_table_arg, si, proto, size,</span>
<span class="p_add">+				     gop_handle);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		status = setup_gop32(sys_table_arg, si, proto, size,</span>
<span class="p_add">+				     gop_handle);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+free_handle:</span>
<span class="p_add">+	efi_call_early(free_pool, gop_handle);</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/firmware/efi/memattr.c b/drivers/firmware/efi/memattr.c</span>
new file mode 100644
<span class="p_header">index 000000000000..236004b9a50d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/memattr.c</span>
<span class="p_chunk">@@ -0,0 +1,182 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2016 Linaro Ltd. &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt)	&quot;efi: memattr: &quot; fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/early_ioremap.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __initdata tbl_size;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Reserve the memory associated with the Memory Attributes configuration</span>
<span class="p_add">+ * table, if it exists.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init efi_memattr_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_memory_attributes_table_t *tbl;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi.mem_attr_table == EFI_INVALID_TABLE_ADDR)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	tbl = early_memremap(efi.mem_attr_table, sizeof(*tbl));</span>
<span class="p_add">+	if (!tbl) {</span>
<span class="p_add">+		pr_err(&quot;Failed to map EFI Memory Attributes table @ 0x%lx\n&quot;,</span>
<span class="p_add">+		       efi.mem_attr_table);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tbl-&gt;version &gt; 1) {</span>
<span class="p_add">+		pr_warn(&quot;Unexpected EFI Memory Attributes table version %d\n&quot;,</span>
<span class="p_add">+			tbl-&gt;version);</span>
<span class="p_add">+		goto unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tbl_size = sizeof(*tbl) + tbl-&gt;num_entries * tbl-&gt;desc_size;</span>
<span class="p_add">+	memblock_reserve(efi.mem_attr_table, tbl_size);</span>
<span class="p_add">+</span>
<span class="p_add">+unmap:</span>
<span class="p_add">+	early_memunmap(tbl, sizeof(*tbl));</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns a copy @out of the UEFI memory descriptor @in if it is covered</span>
<span class="p_add">+ * entirely by a UEFI memory map entry with matching attributes. The virtual</span>
<span class="p_add">+ * address of @out is set according to the matching entry that was found.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool entry_is_valid(const efi_memory_desc_t *in, efi_memory_desc_t *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 in_paddr = in-&gt;phys_addr;</span>
<span class="p_add">+	u64 in_size = in-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
<span class="p_add">+</span>
<span class="p_add">+	*out = *in;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in-&gt;type != EFI_RUNTIME_SERVICES_CODE &amp;&amp;</span>
<span class="p_add">+	    in-&gt;type != EFI_RUNTIME_SERVICES_DATA) {</span>
<span class="p_add">+		pr_warn(&quot;Entry type should be RuntimeServiceCode/Data\n&quot;);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(in-&gt;attribute &amp; (EFI_MEMORY_RO | EFI_MEMORY_XP))) {</span>
<span class="p_add">+		pr_warn(&quot;Entry attributes invalid: RO and XP bits both cleared\n&quot;);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PAGE_SIZE &gt; EFI_PAGE_SIZE &amp;&amp;</span>
<span class="p_add">+	    (!PAGE_ALIGNED(in-&gt;phys_addr) ||</span>
<span class="p_add">+	     !PAGE_ALIGNED(in-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT))) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since arm64 may execute with page sizes of up to 64 KB, the</span>
<span class="p_add">+		 * UEFI spec mandates that RuntimeServices memory regions must</span>
<span class="p_add">+		 * be 64 KB aligned. We need to validate this here since we will</span>
<span class="p_add">+		 * not be able to tighten permissions on such regions without</span>
<span class="p_add">+		 * affecting adjacent regions.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pr_warn(&quot;Entry address region misaligned\n&quot;);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_efi_memory_desc(md) {</span>
<span class="p_add">+		u64 md_paddr = md-&gt;phys_addr;</span>
<span class="p_add">+		u64 md_size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (md-&gt;virt_addr == 0) {</span>
<span class="p_add">+			/* no virtual mapping has been installed by the stub */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (md_paddr &gt; in_paddr || (in_paddr - md_paddr) &gt;= md_size)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This entry covers the start of @in, check whether</span>
<span class="p_add">+		 * it covers the end as well.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (md_paddr + md_size &lt; in_paddr + in_size) {</span>
<span class="p_add">+			pr_warn(&quot;Entry covers multiple EFI memory map regions\n&quot;);</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (md-&gt;type != in-&gt;type) {</span>
<span class="p_add">+			pr_warn(&quot;Entry type deviates from EFI memory map region type\n&quot;);</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		out-&gt;virt_addr = in_paddr + (md-&gt;virt_addr - md_paddr);</span>
<span class="p_add">+</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn(&quot;No matching entry found in the EFI memory map\n&quot;);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * To be called after the EFI page tables have been populated. If a memory</span>
<span class="p_add">+ * attributes table is available, its contents will be used to update the</span>
<span class="p_add">+ * mappings with tightened permissions as described by the table.</span>
<span class="p_add">+ * This requires the UEFI memory map to have already been populated with</span>
<span class="p_add">+ * virtual addresses.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init efi_memattr_apply_permissions(struct mm_struct *mm,</span>
<span class="p_add">+					 efi_memattr_perm_setter fn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_memory_attributes_table_t *tbl;</span>
<span class="p_add">+	int i, ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tbl_size &lt;= sizeof(*tbl))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need the EFI memory map to be setup so we can use it to</span>
<span class="p_add">+	 * lookup the virtual addresses of all entries in the  of EFI</span>
<span class="p_add">+	 * Memory Attributes table. If it isn&#39;t available, this</span>
<span class="p_add">+	 * function should not be called.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (WARN_ON(!efi_enabled(EFI_MEMMAP)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	tbl = memremap(efi.mem_attr_table, tbl_size, MEMREMAP_WB);</span>
<span class="p_add">+	if (!tbl) {</span>
<span class="p_add">+		pr_err(&quot;Failed to map EFI Memory Attributes table @ 0x%lx\n&quot;,</span>
<span class="p_add">+		       efi.mem_attr_table);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_enabled(EFI_DBG))</span>
<span class="p_add">+		pr_info(&quot;Processing EFI Memory Attributes table:\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = ret = 0; ret == 0 &amp;&amp; i &lt; tbl-&gt;num_entries; i++) {</span>
<span class="p_add">+		efi_memory_desc_t md;</span>
<span class="p_add">+		unsigned long size;</span>
<span class="p_add">+		bool valid;</span>
<span class="p_add">+		char buf[64];</span>
<span class="p_add">+</span>
<span class="p_add">+		valid = entry_is_valid((void *)tbl-&gt;entry + i * tbl-&gt;desc_size,</span>
<span class="p_add">+				       &amp;md);</span>
<span class="p_add">+		size = md.num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_add">+		if (efi_enabled(EFI_DBG) || !valid)</span>
<span class="p_add">+			pr_info(&quot;%s 0x%012llx-0x%012llx %s\n&quot;,</span>
<span class="p_add">+				valid ? &quot;&quot; : &quot;!&quot;, md.phys_addr,</span>
<span class="p_add">+				md.phys_addr + size - 1,</span>
<span class="p_add">+				efi_md_typeattr_format(buf, sizeof(buf), &amp;md));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (valid)</span>
<span class="p_add">+			ret = fn(mm, &amp;md);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memunmap(tbl);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/firmware/efi/reboot.c b/drivers/firmware/efi/reboot.c</span>
<span class="p_header">index 9c59d1c795d1..62ead9b9d871 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/reboot.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/reboot.c</span>
<span class="p_chunk">@@ -9,7 +9,8 @@</span> <span class="p_context"> int efi_reboot_quirk_mode = -1;</span>
 
 void efi_reboot(enum reboot_mode reboot_mode, const char *__unused)
 {
<span class="p_del">-	int efi_mode;</span>
<span class="p_add">+	const char *str[] = { &quot;cold&quot;, &quot;warm&quot;, &quot;shutdown&quot;, &quot;platform&quot; };</span>
<span class="p_add">+	int efi_mode, cap_reset_mode;</span>
 
 	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 		return;
<span class="p_chunk">@@ -30,6 +31,15 @@</span> <span class="p_context"> void efi_reboot(enum reboot_mode reboot_mode, const char *__unused)</span>
 	if (efi_reboot_quirk_mode != -1)
 		efi_mode = efi_reboot_quirk_mode;
 
<span class="p_add">+	if (efi_capsule_pending(&amp;cap_reset_mode)) {</span>
<span class="p_add">+		if (efi_mode != cap_reset_mode)</span>
<span class="p_add">+			printk(KERN_CRIT &quot;efi: %s reset requested but pending &quot;</span>
<span class="p_add">+			       &quot;capsule update requires %s reset... Performing &quot;</span>
<span class="p_add">+			       &quot;%s reset.\n&quot;, str[efi_mode], str[cap_reset_mode],</span>
<span class="p_add">+			       str[cap_reset_mode]);</span>
<span class="p_add">+		efi_mode = cap_reset_mode;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	efi.reset_system(efi_mode, EFI_SUCCESS, 0, NULL);
 }
 
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-wrappers.c b/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_header">index de6953039af6..23bef6bb73ee 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_chunk">@@ -16,10 +16,70 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/bug.h&gt;
 #include &lt;linux/efi.h&gt;
<span class="p_add">+#include &lt;linux/irqflags.h&gt;</span>
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/spinlock.h&gt;
<span class="p_add">+#include &lt;linux/stringify.h&gt;</span>
 #include &lt;asm/efi.h&gt;
 
<span class="p_add">+static void efi_call_virt_check_flags(unsigned long flags, const char *call)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long cur_flags, mismatch;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_save_flags(cur_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	mismatch = flags ^ cur_flags;</span>
<span class="p_add">+	if (!WARN_ON_ONCE(mismatch &amp; ARCH_EFI_IRQ_FLAGS_MASK))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_NOW_UNRELIABLE);</span>
<span class="p_add">+	pr_err_ratelimited(FW_BUG &quot;IRQ flags corrupted (0x%08lx=&gt;0x%08lx) by EFI %s\n&quot;,</span>
<span class="p_add">+			   flags, cur_flags, call);</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Arch code can implement the following three template macros, avoiding</span>
<span class="p_add">+ * reptition for the void/non-void return cases of {__,}efi_call_virt:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  * arch_efi_call_virt_setup</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    Sets up the environment for the call (e.g. switching page tables,</span>
<span class="p_add">+ *    allowing kernel-mode use of floating point, if required).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  * arch_efi_call_virt</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    Performs the call. The last expression in the macro must be the call</span>
<span class="p_add">+ *    itself, allowing the logic to be shared by the void and non-void</span>
<span class="p_add">+ *    cases.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  * arch_efi_call_virt_teardown</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    Restores the usual kernel environment once the call has returned.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define efi_call_virt(f, args...)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	efi_status_t __s;						\</span>
<span class="p_add">+	unsigned long flags;						\</span>
<span class="p_add">+	arch_efi_call_virt_setup();					\</span>
<span class="p_add">+	local_save_flags(flags);					\</span>
<span class="p_add">+	__s = arch_efi_call_virt(f, args);				\</span>
<span class="p_add">+	efi_call_virt_check_flags(flags, __stringify(f));		\</span>
<span class="p_add">+	arch_efi_call_virt_teardown();					\</span>
<span class="p_add">+	__s;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define __efi_call_virt(f, args...)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	unsigned long flags;						\</span>
<span class="p_add">+	arch_efi_call_virt_setup();					\</span>
<span class="p_add">+	local_save_flags(flags);					\</span>
<span class="p_add">+	arch_efi_call_virt(f, args);					\</span>
<span class="p_add">+	efi_call_virt_check_flags(flags, __stringify(f));		\</span>
<span class="p_add">+	arch_efi_call_virt_teardown();					\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 /*
  * According to section 7.1 of the UEFI spec, Runtime Services are not fully
  * reentrant, and there are particular combinations of calls that need to be
<span class="p_header">diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c</span>
<span class="p_header">index 34b741940494..d3b751383286 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/vars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/vars.c</span>
<span class="p_chunk">@@ -329,39 +329,6 @@</span> <span class="p_context"> check_var_size_nonblocking(u32 attributes, unsigned long size)</span>
 	return fops-&gt;query_variable_store(attributes, size, true);
 }
 
<span class="p_del">-static int efi_status_to_err(efi_status_t status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (status) {</span>
<span class="p_del">-	case EFI_SUCCESS:</span>
<span class="p_del">-		err = 0;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_INVALID_PARAMETER:</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_OUT_OF_RESOURCES:</span>
<span class="p_del">-		err = -ENOSPC;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_DEVICE_ERROR:</span>
<span class="p_del">-		err = -EIO;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_WRITE_PROTECTED:</span>
<span class="p_del">-		err = -EROFS;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_SECURITY_VIOLATION:</span>
<span class="p_del">-		err = -EACCES;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case EFI_NOT_FOUND:</span>
<span class="p_del">-		err = -ENOENT;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static bool variable_is_present(efi_char16_t *variable_name, efi_guid_t *vendor,
 				struct list_head *head)
 {
<span class="p_chunk">@@ -452,8 +419,7 @@</span> <span class="p_context"> static void dup_variable_bug(efi_char16_t *str16, efi_guid_t *vendor_guid,</span>
  * Returns 0 on success, or a kernel error code on failure.
  */
 int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
<span class="p_del">-		void *data, bool atomic, bool duplicates,</span>
<span class="p_del">-		struct list_head *head)</span>
<span class="p_add">+		void *data, bool duplicates, struct list_head *head)</span>
 {
 	const struct efivar_operations *ops = __efivars-&gt;ops;
 	unsigned long variable_name_size = 1024;
<span class="p_chunk">@@ -483,7 +449,7 @@</span> <span class="p_context"> int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),</span>
 						&amp;vendor_guid);
 		switch (status) {
 		case EFI_SUCCESS:
<span class="p_del">-			if (!atomic)</span>
<span class="p_add">+			if (duplicates)</span>
 				spin_unlock_irq(&amp;__efivars-&gt;lock);
 
 			variable_name_size = var_name_strnsize(variable_name,
<span class="p_chunk">@@ -498,21 +464,19 @@</span> <span class="p_context"> int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),</span>
 			 * and may end up looping here forever.
 			 */
 			if (duplicates &amp;&amp;
<span class="p_del">-			    variable_is_present(variable_name, &amp;vendor_guid, head)) {</span>
<span class="p_add">+			    variable_is_present(variable_name, &amp;vendor_guid,</span>
<span class="p_add">+						head)) {</span>
 				dup_variable_bug(variable_name, &amp;vendor_guid,
 						 variable_name_size);
<span class="p_del">-				if (!atomic)</span>
<span class="p_del">-					spin_lock_irq(&amp;__efivars-&gt;lock);</span>
<span class="p_del">-</span>
 				status = EFI_NOT_FOUND;
<span class="p_del">-				break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				err = func(variable_name, vendor_guid,</span>
<span class="p_add">+					   variable_name_size, data);</span>
<span class="p_add">+				if (err)</span>
<span class="p_add">+					status = EFI_NOT_FOUND;</span>
 			}
 
<span class="p_del">-			err = func(variable_name, vendor_guid, variable_name_size, data);</span>
<span class="p_del">-			if (err)</span>
<span class="p_del">-				status = EFI_NOT_FOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!atomic)</span>
<span class="p_add">+			if (duplicates)</span>
 				spin_lock_irq(&amp;__efivars-&gt;lock);
 
 			break;
<span class="p_header">diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig</span>
<span class="p_header">index 983280e8d93f..e5a391aecde1 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/Kconfig</span>
<span class="p_header">+++ b/drivers/video/fbdev/Kconfig</span>
<span class="p_chunk">@@ -761,7 +761,7 @@</span> <span class="p_context"> config FB_VESA</span>
 
 config FB_EFI
 	bool &quot;EFI-based Framebuffer Support&quot;
<span class="p_del">-	depends on (FB = y) &amp;&amp; X86 &amp;&amp; EFI</span>
<span class="p_add">+	depends on (FB = y) &amp;&amp; !IA64 &amp;&amp; EFI</span>
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
<span class="p_header">diff --git a/drivers/video/fbdev/efifb.c b/drivers/video/fbdev/efifb.c</span>
<span class="p_header">index 95d293b7445a..f4c045c0051c 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/efifb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/efifb.c</span>
<span class="p_chunk">@@ -6,16 +6,14 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/fb.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/screen_info.h&gt;
<span class="p_del">-#include &lt;linux/dmi.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci.h&gt;</span>
 #include &lt;video/vga.h&gt;
<span class="p_del">-#include &lt;asm/sysfb.h&gt;</span>
<span class="p_add">+#include &lt;asm/efi.h&gt;</span>
 
 static bool request_mem_succeeded = false;
 
<span class="p_chunk">@@ -85,21 +83,13 @@</span> <span class="p_context"> static struct fb_ops efifb_ops = {</span>
 static int efifb_setup(char *options)
 {
 	char *this_opt;
<span class="p_del">-	int i;</span>
 
 	if (options &amp;&amp; *options) {
 		while ((this_opt = strsep(&amp;options, &quot;,&quot;)) != NULL) {
 			if (!*this_opt) continue;
 
<span class="p_del">-			for (i = 0; i &lt; M_UNKNOWN; i++) {</span>
<span class="p_del">-				if (efifb_dmi_list[i].base != 0 &amp;&amp;</span>
<span class="p_del">-				    !strcmp(this_opt, efifb_dmi_list[i].optname)) {</span>
<span class="p_del">-					screen_info.lfb_base = efifb_dmi_list[i].base;</span>
<span class="p_del">-					screen_info.lfb_linelength = efifb_dmi_list[i].stride;</span>
<span class="p_del">-					screen_info.lfb_width = efifb_dmi_list[i].width;</span>
<span class="p_del">-					screen_info.lfb_height = efifb_dmi_list[i].height;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_add">+			efifb_setup_from_dmi(&amp;screen_info, this_opt);</span>
<span class="p_add">+</span>
 			if (!strncmp(this_opt, &quot;base:&quot;, 5))
 				screen_info.lfb_base = simple_strtoul(this_opt+5, NULL, 0);
 			else if (!strncmp(this_opt, &quot;stride:&quot;, 7))
<span class="p_chunk">@@ -338,5 +328,4 @@</span> <span class="p_context"> static struct platform_driver efifb_driver = {</span>
 	.remove = efifb_remove,
 };
 
<span class="p_del">-module_platform_driver(efifb_driver);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+builtin_platform_driver(efifb_driver);</span>
<span class="p_header">diff --git a/drivers/xen/efi.c b/drivers/xen/efi.c</span>
<span class="p_header">index be7e56a338e8..e9d2135445c1 100644</span>
<span class="p_header">--- a/drivers/xen/efi.c</span>
<span class="p_header">+++ b/drivers/xen/efi.c</span>
<span class="p_chunk">@@ -316,7 +316,6 @@</span> <span class="p_context"> static const struct efi efi_xen __initconst = {</span>
 	.get_next_high_mono_count = xen_efi_get_next_high_mono_count,
 	.reset_system             = NULL, /* Functionality provided by Xen. */
 	.set_virtual_address_map  = NULL, /* Not used under Xen. */
<span class="p_del">-	.memmap                   = NULL, /* Not used under Xen. */</span>
 	.flags			  = 0     /* Initialized later. */
 };
 
<span class="p_header">diff --git a/fs/efivarfs/file.c b/fs/efivarfs/file.c</span>
<span class="p_header">index d48e0d261d78..5f22e74bbade 100644</span>
<span class="p_header">--- a/fs/efivarfs/file.c</span>
<span class="p_header">+++ b/fs/efivarfs/file.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> efivarfs_ioc_setxflags(struct file *file, void __user *arg)</span>
 	return 0;
 }
 
<span class="p_del">-long</span>
<span class="p_add">+static long</span>
 efivarfs_file_ioctl(struct file *file, unsigned int cmd, unsigned long p)
 {
 	void __user *arg = (void __user *)p;
<span class="p_header">diff --git a/fs/efivarfs/super.c b/fs/efivarfs/super.c</span>
<span class="p_header">index 553c5d2db4a4..9cb54a38832d 100644</span>
<span class="p_header">--- a/fs/efivarfs/super.c</span>
<span class="p_header">+++ b/fs/efivarfs/super.c</span>
<span class="p_chunk">@@ -216,8 +216,7 @@</span> <span class="p_context"> static int efivarfs_fill_super(struct super_block *sb, void *data, int silent)</span>
 
 	INIT_LIST_HEAD(&amp;efivarfs_list);
 
<span class="p_del">-	err = efivar_init(efivarfs_callback, (void *)sb, false,</span>
<span class="p_del">-			  true, &amp;efivarfs_list);</span>
<span class="p_add">+	err = efivar_init(efivarfs_callback, (void *)sb, true, &amp;efivarfs_list);</span>
 	if (err)
 		__efivar_entry_iter(efivarfs_destroy, &amp;efivarfs_list, NULL, NULL);
 
<span class="p_header">diff --git a/include/linux/efi.h b/include/linux/efi.h</span>
<span class="p_header">index 1626474567ac..df7acb51f3cc 100644</span>
<span class="p_header">--- a/include/linux/efi.h</span>
<span class="p_header">+++ b/include/linux/efi.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pfn.h&gt;
 #include &lt;linux/pstore.h&gt;
 #include &lt;linux/reboot.h&gt;
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
 
 #include &lt;asm/page.h&gt;
 
<span class="p_chunk">@@ -124,6 +125,13 @@</span> <span class="p_context"> typedef struct {</span>
 } efi_capsule_header_t;
 
 /*
<span class="p_add">+ * EFI capsule flags</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define EFI_CAPSULE_PERSIST_ACROSS_RESET	0x00010000</span>
<span class="p_add">+#define EFI_CAPSULE_POPULATE_SYSTEM_TABLE	0x00020000</span>
<span class="p_add">+#define EFI_CAPSULE_INITIATE_RESET		0x00040000</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Allocation types for calls to boottime-&gt;allocate_pages.
  */
 #define EFI_ALLOCATE_ANY_PAGES		0
<span class="p_chunk">@@ -282,9 +290,10 @@</span> <span class="p_context"> typedef struct {</span>
 	efi_status_t (*handle_protocol)(efi_handle_t, efi_guid_t *, void **);
 	void *__reserved;
 	void *register_protocol_notify;
<span class="p_del">-	void *locate_handle;</span>
<span class="p_add">+	efi_status_t (*locate_handle)(int, efi_guid_t *, void *,</span>
<span class="p_add">+				      unsigned long *, efi_handle_t *);</span>
 	void *locate_device_path;
<span class="p_del">-	void *install_configuration_table;</span>
<span class="p_add">+	efi_status_t (*install_configuration_table)(efi_guid_t *, void *);</span>
 	void *load_image;
 	void *start_image;
 	void *exit;
<span class="p_chunk">@@ -623,6 +632,27 @@</span> <span class="p_context"> void efi_native_runtime_setup(void);</span>
 	EFI_GUID(0x3152bca5, 0xeade, 0x433d, \
 		 0x86, 0x2e, 0xc0, 0x1c, 0xdc, 0x29, 0x1f, 0x44)
 
<span class="p_add">+#define EFI_MEMORY_ATTRIBUTES_TABLE_GUID \</span>
<span class="p_add">+	EFI_GUID(0xdcfa911d, 0x26eb, 0x469f, \</span>
<span class="p_add">+		 0xa2, 0x20, 0x38, 0xb7, 0xdc, 0x46, 0x12, 0x20)</span>
<span class="p_add">+</span>
<span class="p_add">+#define EFI_CONSOLE_OUT_DEVICE_GUID \</span>
<span class="p_add">+	EFI_GUID(0xd3b36f2c, 0xd551, 0x11d4, \</span>
<span class="p_add">+		 0x9a, 0x46, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This GUID is used to pass to the kernel proper the struct screen_info</span>
<span class="p_add">+ * structure that was populated by the stub based on the GOP protocol instance</span>
<span class="p_add">+ * associated with ConOut</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define LINUX_EFI_ARM_SCREEN_INFO_TABLE_GUID \</span>
<span class="p_add">+	EFI_GUID(0xe03fc20a, 0x85dc, 0x406e, \</span>
<span class="p_add">+		 0xb9, 0xe, 0x4a, 0xb5, 0x02, 0x37, 0x1d, 0x95)</span>
<span class="p_add">+</span>
<span class="p_add">+#define LINUX_EFI_LOADER_ENTRY_GUID \</span>
<span class="p_add">+	EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf, \</span>
<span class="p_add">+		 0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)</span>
<span class="p_add">+</span>
 typedef struct {
 	efi_guid_t guid;
 	u64 table;
<span class="p_chunk">@@ -847,6 +877,14 @@</span> <span class="p_context"> typedef struct {</span>
 
 #define EFI_INVALID_TABLE_ADDR		(~0UL)
 
<span class="p_add">+typedef struct {</span>
<span class="p_add">+	u32 version;</span>
<span class="p_add">+	u32 num_entries;</span>
<span class="p_add">+	u32 desc_size;</span>
<span class="p_add">+	u32 reserved;</span>
<span class="p_add">+	efi_memory_desc_t entry[0];</span>
<span class="p_add">+} efi_memory_attributes_table_t;</span>
<span class="p_add">+</span>
 /*
  * All runtime access to EFI goes through this structure:
  */
<span class="p_chunk">@@ -868,6 +906,7 @@</span> <span class="p_context"> extern struct efi {</span>
 	unsigned long config_table;	/* config tables */
 	unsigned long esrt;		/* ESRT table */
 	unsigned long properties_table;	/* properties table */
<span class="p_add">+	unsigned long mem_attr_table;	/* memory attributes table */</span>
 	efi_get_time_t *get_time;
 	efi_set_time_t *set_time;
 	efi_get_wakeup_time_t *get_wakeup_time;
<span class="p_chunk">@@ -883,7 +922,7 @@</span> <span class="p_context"> extern struct efi {</span>
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 	efi_reset_system_t *reset_system;
 	efi_set_virtual_address_map_t *set_virtual_address_map;
<span class="p_del">-	struct efi_memory_map *memmap;</span>
<span class="p_add">+	struct efi_memory_map memmap;</span>
 	unsigned long flags;
 } efi;
 
<span class="p_chunk">@@ -945,7 +984,6 @@</span> <span class="p_context"> extern void efi_initialize_iomem_resources(struct resource *code_resource,</span>
 extern void efi_get_time(struct timespec *now);
 extern void efi_reserve_boot_services(void);
 extern int efi_get_fdt_params(struct efi_fdt_params *params);
<span class="p_del">-extern struct efi_memory_map memmap;</span>
 extern struct kobject *efi_kobj;
 
 extern int efi_reboot_quirk_mode;
<span class="p_chunk">@@ -957,12 +995,34 @@</span> <span class="p_context"> extern void __init efi_fake_memmap(void);</span>
 static inline void efi_fake_memmap(void) { }
 #endif
 
<span class="p_add">+/*</span>
<span class="p_add">+ * efi_memattr_perm_setter - arch specific callback function passed into</span>
<span class="p_add">+ *                           efi_memattr_apply_permissions() that updates the</span>
<span class="p_add">+ *                           mapping permissions described by the second</span>
<span class="p_add">+ *                           argument in the page tables referred to by the</span>
<span class="p_add">+ *                           first argument.</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef int (*efi_memattr_perm_setter)(struct mm_struct *, efi_memory_desc_t *);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int efi_memattr_init(void);</span>
<span class="p_add">+extern int efi_memattr_apply_permissions(struct mm_struct *mm,</span>
<span class="p_add">+					 efi_memattr_perm_setter fn);</span>
<span class="p_add">+</span>
 /* Iterate through an efi_memory_map */
<span class="p_del">-#define for_each_efi_memory_desc(m, md)					   \</span>
<span class="p_add">+#define for_each_efi_memory_desc_in_map(m, md)				   \</span>
 	for ((md) = (m)-&gt;map;						   \
 	     (md) &lt;= (efi_memory_desc_t *)((m)-&gt;map_end - (m)-&gt;desc_size); \
 	     (md) = (void *)(md) + (m)-&gt;desc_size)
 
<span class="p_add">+/**</span>
<span class="p_add">+ * for_each_efi_memory_desc - iterate over descriptors in efi.memmap</span>
<span class="p_add">+ * @md: the efi_memory_desc_t * iterator</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Once the loop finishes @md must not be accessed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define for_each_efi_memory_desc(md) \</span>
<span class="p_add">+	for_each_efi_memory_desc_in_map(&amp;efi.memmap, md)</span>
<span class="p_add">+</span>
 /*
  * Format an EFI memory descriptor&#39;s type and attributes to a user-provided
  * character buffer, as per snprintf(), and return the buffer.
<span class="p_chunk">@@ -1000,7 +1060,6 @@</span> <span class="p_context"> extern int __init efi_setup_pcdp_console(char *);</span>
  * possible, remove EFI-related code altogether.
  */
 #define EFI_BOOT		0	/* Were we booted from EFI? */
<span class="p_del">-#define EFI_SYSTEM_TABLES	1	/* Can we use EFI system tables? */</span>
 #define EFI_CONFIG_TABLES	2	/* Can we use EFI config tables? */
 #define EFI_RUNTIME_SERVICES	3	/* Can we use runtime services? */
 #define EFI_MEMMAP		4	/* Can we use EFI memory map? */
<span class="p_chunk">@@ -1026,8 +1085,16 @@</span> <span class="p_context"> static inline bool efi_enabled(int feature)</span>
 }
 static inline void
 efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}
<span class="p_add">+</span>
<span class="p_add">+static inline bool</span>
<span class="p_add">+efi_capsule_pending(int *reset_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
 #endif
 
<span class="p_add">+extern int efi_status_to_err(efi_status_t status);</span>
<span class="p_add">+</span>
 /*
  * Variable Attributes
  */
<span class="p_chunk">@@ -1180,6 +1247,80 @@</span> <span class="p_context"> struct efi_simple_text_output_protocol {</span>
 	void *test_string;
 };
 
<span class="p_add">+#define PIXEL_RGB_RESERVED_8BIT_PER_COLOR		0</span>
<span class="p_add">+#define PIXEL_BGR_RESERVED_8BIT_PER_COLOR		1</span>
<span class="p_add">+#define PIXEL_BIT_MASK					2</span>
<span class="p_add">+#define PIXEL_BLT_ONLY					3</span>
<span class="p_add">+#define PIXEL_FORMAT_MAX				4</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_pixel_bitmask {</span>
<span class="p_add">+	u32 red_mask;</span>
<span class="p_add">+	u32 green_mask;</span>
<span class="p_add">+	u32 blue_mask;</span>
<span class="p_add">+	u32 reserved_mask;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_mode_info {</span>
<span class="p_add">+	u32 version;</span>
<span class="p_add">+	u32 horizontal_resolution;</span>
<span class="p_add">+	u32 vertical_resolution;</span>
<span class="p_add">+	int pixel_format;</span>
<span class="p_add">+	struct efi_pixel_bitmask pixel_information;</span>
<span class="p_add">+	u32 pixels_per_scan_line;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol_mode_32 {</span>
<span class="p_add">+	u32 max_mode;</span>
<span class="p_add">+	u32 mode;</span>
<span class="p_add">+	u32 info;</span>
<span class="p_add">+	u32 size_of_info;</span>
<span class="p_add">+	u64 frame_buffer_base;</span>
<span class="p_add">+	u32 frame_buffer_size;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol_mode_64 {</span>
<span class="p_add">+	u32 max_mode;</span>
<span class="p_add">+	u32 mode;</span>
<span class="p_add">+	u64 info;</span>
<span class="p_add">+	u64 size_of_info;</span>
<span class="p_add">+	u64 frame_buffer_base;</span>
<span class="p_add">+	u64 frame_buffer_size;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol_mode {</span>
<span class="p_add">+	u32 max_mode;</span>
<span class="p_add">+	u32 mode;</span>
<span class="p_add">+	unsigned long info;</span>
<span class="p_add">+	unsigned long size_of_info;</span>
<span class="p_add">+	u64 frame_buffer_base;</span>
<span class="p_add">+	unsigned long frame_buffer_size;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol_32 {</span>
<span class="p_add">+	u32 query_mode;</span>
<span class="p_add">+	u32 set_mode;</span>
<span class="p_add">+	u32 blt;</span>
<span class="p_add">+	u32 mode;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol_64 {</span>
<span class="p_add">+	u64 query_mode;</span>
<span class="p_add">+	u64 set_mode;</span>
<span class="p_add">+	u64 blt;</span>
<span class="p_add">+	u64 mode;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct efi_graphics_output_protocol {</span>
<span class="p_add">+	unsigned long query_mode;</span>
<span class="p_add">+	unsigned long set_mode;</span>
<span class="p_add">+	unsigned long blt;</span>
<span class="p_add">+	struct efi_graphics_output_protocol_mode *mode;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+typedef efi_status_t (*efi_graphics_output_protocol_query_mode)(</span>
<span class="p_add">+	struct efi_graphics_output_protocol *, u32, unsigned long *,</span>
<span class="p_add">+	struct efi_graphics_output_mode_info **);</span>
<span class="p_add">+</span>
 extern struct list_head efivar_sysfs_list;
 
 static inline void
<span class="p_chunk">@@ -1195,8 +1336,7 @@</span> <span class="p_context"> int efivars_unregister(struct efivars *efivars);</span>
 struct kobject *efivars_kobject(void);
 
 int efivar_init(int (*func)(efi_char16_t *, efi_guid_t, unsigned long, void *),
<span class="p_del">-		void *data, bool atomic, bool duplicates,</span>
<span class="p_del">-		struct list_head *head);</span>
<span class="p_add">+		void *data, bool duplicates, struct list_head *head);</span>
 
 void efivar_entry_add(struct efivar_entry *entry, struct list_head *head);
 void efivar_entry_remove(struct efivar_entry *entry);
<span class="p_chunk">@@ -1242,6 +1382,13 @@</span> <span class="p_context"> int efivars_sysfs_init(void);</span>
 #define EFIVARS_DATA_SIZE_MAX 1024
 
 #endif /* CONFIG_EFI_VARS */
<span class="p_add">+extern bool efi_capsule_pending(int *reset_type);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int efi_capsule_supported(efi_guid_t guid, u32 flags,</span>
<span class="p_add">+				 size_t size, int *reset);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int efi_capsule_update(efi_capsule_header_t *capsule,</span>
<span class="p_add">+			      struct page **pages);</span>
 
 #ifdef CONFIG_EFI_RUNTIME_MAP
 int efi_runtime_map_init(struct kobject *);
<span class="p_chunk">@@ -1319,5 +1466,9 @@</span> <span class="p_context"> efi_status_t handle_cmdline_files(efi_system_table_t *sys_table_arg,</span>
 
 efi_status_t efi_parse_options(char *cmdline);
 
<span class="p_add">+efi_status_t efi_setup_gop(efi_system_table_t *sys_table_arg,</span>
<span class="p_add">+			   struct screen_info *si, efi_guid_t *proto,</span>
<span class="p_add">+			   unsigned long size);</span>
<span class="p_add">+</span>
 bool efi_runtime_disabled(void);
 #endif /* _LINUX_EFI_H */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



