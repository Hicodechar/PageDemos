
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v9,04/12] RISC-V: Init and Halt Code - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v9,04/12] RISC-V: Init and Halt Code</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 27, 2017, 1:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170927015638.19443-5-palmer@dabbelt.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9972953/mbox/"
   >mbox</a>
|
   <a href="/patch/9972953/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9972953/">/patch/9972953/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A32196037E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 27 Sep 2017 01:59:35 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 925DE29048
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 27 Sep 2017 01:59:35 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 86C1C2904A; Wed, 27 Sep 2017 01:59:35 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.4 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, RCVD_IN_DNSWL_HI,
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E155229048
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 27 Sep 2017 01:59:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1031527AbdI0B7b (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 26 Sep 2017 21:59:31 -0400
Received: from mail-pg0-f65.google.com ([74.125.83.65]:36930 &quot;EHLO
	mail-pg0-f65.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1031305AbdI0B5D (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 26 Sep 2017 21:57:03 -0400
Received: by mail-pg0-f65.google.com with SMTP id v5so7786070pgn.4
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 26 Sep 2017 18:57:03 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=dabbelt-com.20150623.gappssmtp.com; s=20150623;
	h=subject:date:message-id:in-reply-to:references:cc:from:to;
	bh=03x6+lcz24VJSiq1+hK2AfXuKowTvWyWLxMnMpLKdBE=;
	b=FZnFk7nyoJSzqD/VzQQy6P7mtuAlYRYU1B2Clb9cO6ZUtaCHds9w/Zw7u4O0kAdZm/
	lHzrllv9/ShD//6XPUiHaxr+LQPqMaryZWUnPKIbEQpXsVn0z0D75Q1sOJZON0tR3+cz
	u56ceuQmKUSSEV6v3FreaXdHtWk9JZkS16H8S3ePI0fxNWV9G7yxc+ajzeok1TvkcjSc
	vBxEm7tCFdQvAjPH/mhYEm/HiGTlzpvDIh4icOz8tXx2DobVGNPXOy8xRJK1aD1K4lM2
	la/AtR/BpzORjkudChRWdsQp4lko4LxUeWG4rIlZ5v1y64WFTzxFZdIsxh9rIySBy1W0
	jNDA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:subject:date:message-id:in-reply-to:references
	:cc:from:to;
	bh=03x6+lcz24VJSiq1+hK2AfXuKowTvWyWLxMnMpLKdBE=;
	b=ukHXI+pAG7kF/RFAa5bxjMkG0+8aFnulskpNRLpNA+584SXdoeJq6yyOy46EgbQnYT
	2mZ06R41/vw2i8eaUfEd0KuUi+QtlCY/sXEGkkPcyvCqnwr0oXkr8b3pNA4dTKGkmax/
	qylma5r0T6CamG2aEsyfmZC+Ud0cRRehqGn+RrpafunUfH6KpqtN/2ntegbYZUBhO8uJ
	oDZbZPLyo9tCGUZKrs/XWxBVubWr3Tkp2QAiMVX14x5M3hzkO0dzDTbUqFt5D32CuKWL
	p3n3wptenkdlzch/Tb+ZQW25GCaYwhyhdSH7/5J82Duj7EHoGQ7TC07md+EC+K9GP/SG
	O4Ng==
X-Gm-Message-State: AHPjjUiVagBvl6PEECowXvoIN+fq4AgxrHW/qu+kYX4Pe/4jY6TGdYAp
	kid24ZXam8LiXdXPpUxRb5c+E9Vqqfo=
X-Google-Smtp-Source: AOwi7QADhXzCY7OmXLxinO1CP6ZNdaEF/AwjC4uffAVW7CXTl6rp+o+3cTZ4JAKlNRoPgS8sMd0tYw==
X-Received: by 10.84.172.131 with SMTP id n3mr12507476plb.408.1506477422483; 
	Tue, 26 Sep 2017 18:57:02 -0700 (PDT)
Received: from localhost ([12.206.222.5]) by smtp.gmail.com with ESMTPSA id
	g68sm17195157pfk.136.2017.09.26.18.57.01
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 26 Sep 2017 18:57:01 -0700 (PDT)
Subject: [PATCH v9 04/12] RISC-V: Init and Halt Code
Date: Tue, 26 Sep 2017 18:56:30 -0700
Message-Id: &lt;20170927015638.19443-5-palmer@dabbelt.com&gt;
X-Mailer: git-send-email 2.13.5
In-Reply-To: &lt;20170927015638.19443-1-palmer@dabbelt.com&gt;
References: &lt;20170927015638.19443-1-palmer@dabbelt.com&gt;
Cc: linux-kernel@vger.kernel.org, patches@groups.riscv.org,
	robh+dt@kernel.org, mark.rutland@arm.com, albert@sifive.com,
	yamada.masahiro@socionext.com, mmarek@suse.com,
	will.deacon@arm.com, peterz@infradead.org, boqun.feng@gmail.com,
	oleg@redhat.com, mingo@redhat.com, devicetree@vger.kernel.org,
	Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
From: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
To: Arnd Bergmann &lt;arnd@arndb.de&gt;, sfr@canb.auug.org.au,
	Olof Johansson &lt;olof@lixom.net&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - Sept. 27, 2017, 1:56 a.m.</div>
<pre class="content">
This contains the various __init C functions, the initial assembly
kernel entry point, and the code to reset the system.  When a file was
init-related this patch contains the entire file.
<span class="signed-off-by">
Signed-off-by: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;</span>
---
 arch/riscv/include/asm/bug.h   |  88 ++++++++++++++
 arch/riscv/include/asm/cache.h |  22 ++++
 arch/riscv/include/asm/smp.h   |  52 +++++++++
 arch/riscv/kernel/cacheinfo.c  | 105 +++++++++++++++++
 arch/riscv/kernel/cpu.c        | 108 +++++++++++++++++
 arch/riscv/kernel/head.S       | 157 +++++++++++++++++++++++++
 arch/riscv/kernel/irq.c        |  39 +++++++
 arch/riscv/kernel/reset.c      |  36 ++++++
 arch/riscv/kernel/setup.c      | 257 +++++++++++++++++++++++++++++++++++++++++
 arch/riscv/kernel/smp.c        | 110 ++++++++++++++++++
 arch/riscv/kernel/smpboot.c    | 114 ++++++++++++++++++
 arch/riscv/kernel/time.c       |  61 ++++++++++
 arch/riscv/kernel/traps.c      | 180 +++++++++++++++++++++++++++++
 arch/riscv/kernel/vdso.c       | 125 ++++++++++++++++++++
 arch/riscv/mm/init.c           |  70 +++++++++++
 15 files changed, 1524 insertions(+)
 create mode 100644 arch/riscv/include/asm/bug.h
 create mode 100644 arch/riscv/include/asm/cache.h
 create mode 100644 arch/riscv/include/asm/smp.h
 create mode 100644 arch/riscv/kernel/cacheinfo.c
 create mode 100644 arch/riscv/kernel/cpu.c
 create mode 100644 arch/riscv/kernel/head.S
 create mode 100644 arch/riscv/kernel/irq.c
 create mode 100644 arch/riscv/kernel/reset.c
 create mode 100644 arch/riscv/kernel/setup.c
 create mode 100644 arch/riscv/kernel/smp.c
 create mode 100644 arch/riscv/kernel/smpboot.c
 create mode 100644 arch/riscv/kernel/time.c
 create mode 100644 arch/riscv/kernel/traps.c
 create mode 100644 arch/riscv/kernel/vdso.c
 create mode 100644 arch/riscv/mm/init.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Oct. 5, 2017, 11:01 a.m.</div>
<pre class="content">
On Tue, Sep 26, 2017 at 06:56:30PM -0700, Palmer Dabbelt wrote:
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * This is particularly ugly: it appears we can&#39;t actually get the definition</span>
<span class="quote">&gt; + * of task_struct here, but we need access to the CPU this task is running on.</span>
<span class="quote">&gt; + * Instead of using C we&#39;re using asm-offsets.h to get the current processor</span>
<span class="quote">&gt; + * ID.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))</span>

Are you using CONFIG_THREAD_INFO_IN_TASK?

I assume so, becauase &#39;TI&#39; usually stands for thread_info.

So if you can include your &lt;asm/thread_info.h&gt; here, I think you can do
something like:

#define get_ti()		((struct thread_info *)get_current())
#define raw_smp_processor_id()	(get_ti()-&gt;cpu)

[...]
<span class="quote">
&gt; +static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="quote">&gt; +			 struct device_node *node,</span>
<span class="quote">&gt; +			 enum cache_type type, unsigned int level)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	this_leaf-&gt;of_node = node;</span>
<span class="quote">&gt; +	this_leaf-&gt;level = level;</span>
<span class="quote">&gt; +	this_leaf-&gt;type = type;</span>
<span class="quote">&gt; +	/* not a sector cache */</span>
<span class="quote">&gt; +	this_leaf-&gt;physical_line_partition = 1;</span>
<span class="quote">&gt; +	/* TODO: Add to DTS */</span>
<span class="quote">&gt; +	this_leaf-&gt;attributes =</span>
<span class="quote">&gt; +		CACHE_WRITE_BACK</span>
<span class="quote">&gt; +		| CACHE_READ_ALLOCATE</span>
<span class="quote">&gt; +		| CACHE_WRITE_ALLOCATE;</span>
<span class="quote">&gt; +}</span>

In practice, it&#39;s very hard to remove implicit assumptions later down
the line, so I&#39;d recommend you add this to your DT from the outset.

[...]
<span class="quote">
&gt; +/* Return -1 if not a valid hart */</span>
<span class="quote">&gt; +int riscv_of_processor_hart(struct device_node *node)</span>

Perhaps s/hart/hart_id/ for the function name? Otherwise, it&#39;s not
immediately obvious what it is doing.
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +	const char *isa, *status;</span>
<span class="quote">&gt; +	u32 hart;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!of_device_is_compatible(node, &quot;riscv&quot;)) {</span>
<span class="quote">&gt; +		pr_warn(&quot;Found incompatible CPU\n&quot;);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart)) {</span>
<span class="quote">&gt; +		pr_warn(&quot;Found CPU without hart ID\n&quot;);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	if (hart &gt;= NR_CPUS) {</span>
<span class="quote">&gt; +		pr_info(&quot;Found hart ID %d, which is above NR_CPUs.  Disabling this hart\n&quot;, hart);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>

Here you assume that the hard ID is equalt to the Linux logical ID.

I&#39;d recommend that (as other architectures do), you decouple the two.

That&#39;s going to be necessary for things like kdump to work, as the kdump
kernel will run on (Linux logical) CPU0, but may have been executed from
any secondary CPU.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	if (of_property_read_string(node, &quot;status&quot;, &amp;status)) {</span>
<span class="quote">&gt; +		pr_warn(&quot;CPU with hartid=%d has no \&quot;status\&quot; property\n&quot;, hart);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	if (strcmp(status, &quot;okay&quot;)) {</span>
<span class="quote">&gt; +		pr_info(&quot;CPU with hartid=%d has a non-okay status of \&quot;%s\&quot;\n&quot;, hart, status);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>

Please use of_device_is_available().
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)) {</span>
<span class="quote">&gt; +		pr_warn(&quot;CPU with hartid=%d has no \&quot;riscv,isa\&quot; property\n&quot;, hart);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	if (isa[0] != &#39;r&#39; || isa[1] != &#39;v&#39;) {</span>
<span class="quote">&gt; +		pr_warn(&quot;CPU with hartid=%d has an invalid ISA of \&quot;%s\&quot;\n&quot;, hart, isa);</span>
<span class="quote">&gt; +		return -(ENODEV);</span>
<span class="quote">&gt; +	}</span>

As mentioned on the binding patch, I&#39;d recommend that you use a set of
discrete flags.

[...]
<span class="quote">
&gt; +static int c_show(struct seq_file *m, void *v)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long hart_id = (unsigned long)v - 1;</span>
<span class="quote">&gt; +	struct device_node *node = of_get_cpu_node(hart_id, NULL);</span>
<span class="quote">&gt; +	const char *compat, *isa, *mmu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	seq_printf(m, &quot;hart\t: %lu\n&quot;, hart_id);</span>
<span class="quote">&gt; +	if (!of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="quote">&gt; +	    &amp;&amp; isa[0] == &#39;r&#39;</span>
<span class="quote">&gt; +	    &amp;&amp; isa[1] == &#39;v&#39;)</span>
<span class="quote">&gt; +		seq_printf(m, &quot;isa\t: %s\n&quot;, isa);</span>
<span class="quote">&gt; +	if (!of_property_read_string(node, &quot;mmu-type&quot;, &amp;mmu)</span>
<span class="quote">&gt; +	    &amp;&amp; !strncmp(mmu, &quot;riscv,&quot;, 6))</span>
<span class="quote">&gt; +		seq_printf(m, &quot;mmu\t: %s\n&quot;, mmu+6);</span>
<span class="quote">&gt; +	if (!of_property_read_string(node, &quot;compatible&quot;, &amp;compat)</span>
<span class="quote">&gt; +	    &amp;&amp; strcmp(compat, &quot;riscv&quot;))</span>
<span class="quote">&gt; +		seq_printf(m, &quot;uarch\t: %s\n&quot;, compat);</span>
<span class="quote">&gt; +	seq_puts(m, &quot;\n&quot;);</span>

I&#39;d *very strongly* recommend that you don&#39;t pass the DT values straight
through to userspace.

Otherwise, things like riscv,isa = &quot;rvtypo&#39;d\nsomething&quot; get exposed,
and inevitably, some subset of userspace ends up relying upon it, while
others break based upon it.

Further, specifically for the ISA parts, this is a very bad idea. If
some ISA extensions require kernel support (e.g. to context switch
state, or disable some configurable traps), they cannot work without
kernel support. Generally, the wayt to handle this is for the kernel to
detect the features at boot time, and save these in hwcaps.

Later, the hwcaps can be used to generate /proc/cpunifo output, and are
also exposed via auxv, which avoids applications and libraries having to
parse /proc/cpuinfo just to determine whether they have a particular
feature, which doesn&#39;t work in many situations (e.g. early boot where
/proc may not be mounted).

Take a look at arm64&#39;s hwcaps for an example of how to use hwcaps.

[...]

I deleted the context from my draft, but I didn&#39;t spot a header sta the
start of your head.S. I would very strongly recommend that you have a
header with magic, image size (including unpopulated BSS), and other
room for expansion, so that bootloaders can figure out how to load your
kernel correctly.

[...]
<span class="quote">
&gt; +ENTRY(_start)</span>
<span class="quote">&gt; +	/* Mask all interrupts */</span>
<span class="quote">&gt; +	csrw sie, zero</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Load the global pointer */</span>
<span class="quote">&gt; +.option push</span>
<span class="quote">&gt; +.option norelax</span>
<span class="quote">&gt; +	la gp, __global_pointer$</span>
<span class="quote">&gt; +.option pop</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Disable FPU to detect illegal usage of</span>
<span class="quote">&gt; +	 * floating point in kernel space</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	li t0, SR_FS</span>
<span class="quote">&gt; +	csrc sstatus, t0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Pick one hart to run the main boot sequence */</span>
<span class="quote">&gt; +	la a3, hart_lottery</span>
<span class="quote">&gt; +	li a2, 1</span>
<span class="quote">&gt; +	amoadd.w a3, a2, (a3)</span>
<span class="quote">&gt; +	bnez a3, .Lsecondary_start</span>

I would *very strongly* recommend that you do not throw all CPUs into
the kernel at the start of time, and instead have a mechanism where you
can bring CPUs into the kernel individually.

While it&#39;s simple, it comes with a number of long term problems (e.g.
for kexec/kdump), some of which are unsolvable (e.g. as you cannot know
how many CPUs are stuck in the kernel text, which haven&#39;t been brought
online).

If you want a simple SMP bringup mechanism, ePAPR&#39;s spin-table (and
arm64&#39;s different-but-identically-named spin-table) are good starting
points. Just make sure you require each CPU is brought online
individually. We didn&#39;t do that for arm64 from day one, and it still
prevents us from making improvements that we&#39;d like to, years later.

Doing that will also simplify decoupling the HART IDs from linux logical
IDs, necessary for kdump/kexec, etc.

[...]
<span class="quote">
&gt; +/*</span>
<span class="quote">&gt; + * Allow the user to manually add a memory region (in case DTS is broken);</span>
<span class="quote">&gt; + * &quot;mem_end=nn[KkMmGg]&quot;</span>
<span class="quote">&gt; + */</span>

This doesn&#39;t have a start, so it can&#39;t work for discontiguous memory
blocks (e.g. if FW has reserved/carved-out a chunk in the middle).

Other architectures have &quot;mem=&quot; which would allow you to specify a
region. I&#39;d generally recommend you provide an incentive to fix dts,
however.
<span class="quote">
&gt; +void __init setup_arch(char **cmdline_p)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +#if defined(CONFIG_HVC_RISCV_SBI)</span>
<span class="quote">&gt; +	if (likely(early_console == NULL)) {</span>
<span class="quote">&gt; +		early_console = &amp;riscv_sbi_early_console_dev;</span>
<span class="quote">&gt; +		register_console(early_console);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +#endif</span>

This would be better driven by the DT or command line. Otherwise, this
may come back to bite you in future, as you have to come up with a new
mechanism to describe absence of the console, rather than using an
exsiting mechanism to describe its presence.

[...]
<span class="quote">
&gt; +void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init setup_smp(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *dn = NULL;</span>
<span class="quote">&gt; +	int hart, im_okay_therefore_i_am = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;))) {</span>
<span class="quote">&gt; +		hart = riscv_of_processor_hart(dn);</span>
<span class="quote">&gt; +		if (hart &gt;= 0) {</span>
<span class="quote">&gt; +			set_cpu_possible(hart, true);</span>
<span class="quote">&gt; +			set_cpu_present(hart, true);</span>
<span class="quote">&gt; +			if (hart == smp_processor_id()) {</span>
<span class="quote">&gt; +				BUG_ON(im_okay_therefore_i_am);</span>
<span class="quote">&gt; +				im_okay_therefore_i_am = 1;</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	BUG_ON(!im_okay_therefore_i_am);</span>
<span class="quote">&gt; +}</span>

That name is somewhat opaque. Perhaps bool found_boot_cpu?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +int __cpu_up(unsigned int cpu, struct task_struct *tidle)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	tidle-&gt;thread_info.cpu = cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * On RISC-V systems, all harts boot on their own accord.  Our _start</span>
<span class="quote">&gt; +	 * selects the first hart to boot the kernel and causes the remainder</span>
<span class="quote">&gt; +	 * of the harts to spin in a loop waiting for their stack pointer to be</span>
<span class="quote">&gt; +	 * setup by that main hart.  Writing __cpu_up_stack_pointer signals to</span>
<span class="quote">&gt; +	 * the spinning harts that they can continue the boot process.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	smp_mb();</span>
<span class="quote">&gt; +	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;</span>
<span class="quote">&gt; +	__cpu_up_task_pointer[cpu] = tidle;</span>

Shouldn&#39;t these be WRITE_ONCE() (or some atomic) to avoid tearing?

How are the secondaries reading these? Is there any requirement on the
order these become visible?

[...]
<span class="quote">
&gt; +/*</span>
<span class="quote">&gt; + * C entry point for a secondary processor.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +asmlinkage void __init smp_callin(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mm_struct *mm = &amp;init_mm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* All kernel threads share the same mm context.  */</span>
<span class="quote">&gt; +	atomic_inc(&amp;mm-&gt;mm_count);</span>

I beleive this should be:

	mmgrab(mm);

See commit f1f1007644ffc805 (&quot;mm: add new mmgrab() helper&quot;)
<span class="quote">
&gt; +	current-&gt;active_mm = mm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	trap_init();</span>
<span class="quote">&gt; +	init_clockevent();</span>
<span class="quote">&gt; +	notify_cpu_starting(smp_processor_id());</span>
<span class="quote">&gt; +	set_cpu_online(smp_processor_id(), 1);</span>
<span class="quote">&gt; +	local_flush_tlb_all();</span>

Why do you need a TLB flush here?
<span class="quote">
&gt; +	local_irq_enable();</span>
<span class="quote">&gt; +	preempt_disable();</span>

I believe these two should be the other way around, if the
preempt_disable() is necessary.

Thanks,
Mark.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/riscv/include/asm/bug.h b/arch/riscv/include/asm/bug.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c3e13764a943</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/bug.h</span>
<span class="p_chunk">@@ -0,0 +1,88 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_BUG_H</span>
<span class="p_add">+#define _ASM_RISCV_BUG_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+#include &lt;linux/const.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+#define __BUG_INSN	_AC(0x00100073, UL) /* ebreak */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+typedef u32 bug_insn_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG_RELATIVE_POINTERS</span>
<span class="p_add">+#define __BUG_ENTRY_ADDR	INT &quot; 1b - 2b&quot;</span>
<span class="p_add">+#define __BUG_ENTRY_FILE	INT &quot; %0 - 2b&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define __BUG_ENTRY_ADDR	RISCV_PTR &quot; 1b&quot;</span>
<span class="p_add">+#define __BUG_ENTRY_FILE	RISCV_PTR &quot; %0&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_BUGVERBOSE</span>
<span class="p_add">+#define __BUG_ENTRY			\</span>
<span class="p_add">+	__BUG_ENTRY_ADDR &quot;\n\t&quot;		\</span>
<span class="p_add">+	__BUG_ENTRY_FILE &quot;\n\t&quot;		\</span>
<span class="p_add">+	SHORT &quot; %1&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define __BUG_ENTRY			\</span>
<span class="p_add">+	__BUG_ENTRY_ADDR</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUG()							\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	__asm__ __volatile__ (					\</span>
<span class="p_add">+		&quot;1:\n\t&quot;					\</span>
<span class="p_add">+			&quot;ebreak\n&quot;				\</span>
<span class="p_add">+			&quot;.pushsection __bug_table,\&quot;a\&quot;\n\t&quot;	\</span>
<span class="p_add">+		&quot;2:\n\t&quot;					\</span>
<span class="p_add">+			__BUG_ENTRY &quot;\n\t&quot;			\</span>
<span class="p_add">+			&quot;.org 2b + %2\n\t&quot;			\</span>
<span class="p_add">+			&quot;.popsection&quot;				\</span>
<span class="p_add">+		:						\</span>
<span class="p_add">+		: &quot;i&quot; (__FILE__), &quot;i&quot; (__LINE__),		\</span>
<span class="p_add">+		  &quot;i&quot; (sizeof(struct bug_entry)));		\</span>
<span class="p_add">+	unreachable();						\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+#else /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define BUG()							\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	__asm__ __volatile__ (&quot;ebreak\n&quot;);			\</span>
<span class="p_add">+	unreachable();						\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+#define HAVE_ARCH_BUG</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bug.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+struct pt_regs;</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void die(struct pt_regs *regs, const char *str);</span>
<span class="p_add">+extern void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_BUG_H */</span>
<span class="p_header">diff --git a/arch/riscv/include/asm/cache.h b/arch/riscv/include/asm/cache.h</span>
new file mode 100644
<span class="p_header">index 000000000000..e8f0d1110d74</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/cache.h</span>
<span class="p_chunk">@@ -0,0 +1,22 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_CACHE_H</span>
<span class="p_add">+#define _ASM_RISCV_CACHE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#define L1_CACHE_SHIFT		6</span>
<span class="p_add">+</span>
<span class="p_add">+#define L1_CACHE_BYTES		(1 &lt;&lt; L1_CACHE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_CACHE_H */</span>
<span class="p_header">diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h</span>
new file mode 100644
<span class="p_header">index 000000000000..85e4220839b0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/smp.h</span>
<span class="p_chunk">@@ -0,0 +1,52 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_SMP_H</span>
<span class="p_add">+#define _ASM_RISCV_SMP_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* This both needs asm-offsets.h and is used when generating it. */</span>
<span class="p_add">+#ifndef GENERATING_ASM_OFFSETS</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpumask.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqreturn.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+</span>
<span class="p_add">+/* SMP initialization hook for setup_arch */</span>
<span class="p_add">+void __init init_clockevent(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/* SMP initialization hook for setup_arch */</span>
<span class="p_add">+void __init setup_smp(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Hook for the generic smp_call_function_many() routine. */</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Hook for the generic smp_call_function_single() routine. */</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is particularly ugly: it appears we can&#39;t actually get the definition</span>
<span class="p_add">+ * of task_struct here, but we need access to the CPU this task is running on.</span>
<span class="p_add">+ * Instead of using C we&#39;re using asm-offsets.h to get the current processor</span>
<span class="p_add">+ * ID.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_TI_CPU)))</span>
<span class="p_add">+</span>
<span class="p_add">+/* Interprocessor interrupt handler */</span>
<span class="p_add">+irqreturn_t handle_ipi(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_SMP */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_SMP_H */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cacheinfo.c b/arch/riscv/kernel/cacheinfo.c</span>
new file mode 100644
<span class="p_header">index 000000000000..10ed2749e246</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -0,0 +1,105 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cacheinfo.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="p_add">+			 struct device_node *node,</span>
<span class="p_add">+			 enum cache_type type, unsigned int level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	this_leaf-&gt;of_node = node;</span>
<span class="p_add">+	this_leaf-&gt;level = level;</span>
<span class="p_add">+	this_leaf-&gt;type = type;</span>
<span class="p_add">+	/* not a sector cache */</span>
<span class="p_add">+	this_leaf-&gt;physical_line_partition = 1;</span>
<span class="p_add">+	/* TODO: Add to DTS */</span>
<span class="p_add">+	this_leaf-&gt;attributes =</span>
<span class="p_add">+		CACHE_WRITE_BACK</span>
<span class="p_add">+		| CACHE_READ_ALLOCATE</span>
<span class="p_add">+		| CACHE_WRITE_ALLOCATE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init_cache_level(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 0, leaves = 0, level;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (leaves &gt; 0)</span>
<span class="p_add">+		levels = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	this_cpu_ci-&gt;num_levels = levels;</span>
<span class="p_add">+	this_cpu_ci-&gt;num_leaves = leaves;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 1, level = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ca6c81e54e37</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cpu.c</span>
<span class="p_chunk">@@ -0,0 +1,108 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Return -1 if not a valid hart */</span>
<span class="p_add">+int riscv_of_processor_hart(struct device_node *node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *isa, *status;</span>
<span class="p_add">+	u32 hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!of_device_is_compatible(node, &quot;riscv&quot;)) {</span>
<span class="p_add">+		pr_warn(&quot;Found incompatible CPU\n&quot;);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart)) {</span>
<span class="p_add">+		pr_warn(&quot;Found CPU without hart ID\n&quot;);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (hart &gt;= NR_CPUS) {</span>
<span class="p_add">+		pr_info(&quot;Found hart ID %d, which is above NR_CPUs.  Disabling this hart\n&quot;, hart);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;status&quot;, &amp;status)) {</span>
<span class="p_add">+		pr_warn(&quot;CPU with hartid=%d has no \&quot;status\&quot; property\n&quot;, hart);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (strcmp(status, &quot;okay&quot;)) {</span>
<span class="p_add">+		pr_info(&quot;CPU with hartid=%d has a non-okay status of \&quot;%s\&quot;\n&quot;, hart, status);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)) {</span>
<span class="p_add">+		pr_warn(&quot;CPU with hartid=%d has no \&quot;riscv,isa\&quot; property\n&quot;, hart);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (isa[0] != &#39;r&#39; || isa[1] != &#39;v&#39;) {</span>
<span class="p_add">+		pr_warn(&quot;CPU with hartid=%d has an invalid ISA of \&quot;%s\&quot;\n&quot;, hart, isa);</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return hart;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_start(struct seq_file *m, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*pos = cpumask_next(*pos - 1, cpu_online_mask);</span>
<span class="p_add">+	if ((*pos) &lt; nr_cpu_ids)</span>
<span class="p_add">+		return (void *)(uintptr_t)(1 + *pos);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_next(struct seq_file *m, void *v, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	(*pos)++;</span>
<span class="p_add">+	return c_start(m, pos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void c_stop(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int c_show(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long hart_id = (unsigned long)v - 1;</span>
<span class="p_add">+	struct device_node *node = of_get_cpu_node(hart_id, NULL);</span>
<span class="p_add">+	const char *compat, *isa, *mmu;</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(m, &quot;hart\t: %lu\n&quot;, hart_id);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="p_add">+	    &amp;&amp; isa[0] == &#39;r&#39;</span>
<span class="p_add">+	    &amp;&amp; isa[1] == &#39;v&#39;)</span>
<span class="p_add">+		seq_printf(m, &quot;isa\t: %s\n&quot;, isa);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;mmu-type&quot;, &amp;mmu)</span>
<span class="p_add">+	    &amp;&amp; !strncmp(mmu, &quot;riscv,&quot;, 6))</span>
<span class="p_add">+		seq_printf(m, &quot;mmu\t: %s\n&quot;, mmu+6);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;compatible&quot;, &amp;compat)</span>
<span class="p_add">+	    &amp;&amp; strcmp(compat, &quot;riscv&quot;))</span>
<span class="p_add">+		seq_printf(m, &quot;uarch\t: %s\n&quot;, compat);</span>
<span class="p_add">+	seq_puts(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct seq_operations cpuinfo_op = {</span>
<span class="p_add">+	.start	= c_start,</span>
<span class="p_add">+	.next	= c_next,</span>
<span class="p_add">+	.stop	= c_stop,</span>
<span class="p_add">+	.show	= c_show</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S</span>
new file mode 100644
<span class="p_header">index 000000000000..76af908f87c1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/head.S</span>
<span class="p_chunk">@@ -0,0 +1,157 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+__INIT</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+	/* Mask all interrupts */</span>
<span class="p_add">+	csrw sie, zero</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load the global pointer */</span>
<span class="p_add">+.option push</span>
<span class="p_add">+.option norelax</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+.option pop</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable FPU to detect illegal usage of</span>
<span class="p_add">+	 * floating point in kernel space</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+	csrc sstatus, t0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Pick one hart to run the main boot sequence */</span>
<span class="p_add">+	la a3, hart_lottery</span>
<span class="p_add">+	li a2, 1</span>
<span class="p_add">+	amoadd.w a3, a2, (a3)</span>
<span class="p_add">+	bnez a3, .Lsecondary_start</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save hart ID and DTB physical address */</span>
<span class="p_add">+	mv s0, a0</span>
<span class="p_add">+	mv s1, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize page tables and relocate to virtual addresses */</span>
<span class="p_add">+	la sp, init_thread_union + THREAD_SIZE</span>
<span class="p_add">+	call setup_vm</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore C environment */</span>
<span class="p_add">+	la tp, init_task</span>
<span class="p_add">+	sw s0, TASK_TI_CPU(tp)</span>
<span class="p_add">+</span>
<span class="p_add">+	la sp, init_thread_union</span>
<span class="p_add">+	li a0, ASM_THREAD_SIZE</span>
<span class="p_add">+	add sp, sp, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start the kernel */</span>
<span class="p_add">+	mv a0, s0</span>
<span class="p_add">+	mv a1, s1</span>
<span class="p_add">+	call sbi_save</span>
<span class="p_add">+	tail start_kernel</span>
<span class="p_add">+</span>
<span class="p_add">+relocate:</span>
<span class="p_add">+	/* Relocate return address */</span>
<span class="p_add">+	li a1, PAGE_OFFSET</span>
<span class="p_add">+	la a0, _start</span>
<span class="p_add">+	sub a1, a1, a0</span>
<span class="p_add">+	add ra, ra, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point stvec to virtual address of intruction after sptbr write */</span>
<span class="p_add">+	la a0, 1f</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute sptbr for kernel page tables, but don&#39;t load it yet */</span>
<span class="p_add">+	la a2, swapper_pg_dir</span>
<span class="p_add">+	srl a2, a2, PAGE_SHIFT</span>
<span class="p_add">+	li a1, SPTBR_MODE</span>
<span class="p_add">+	or a2, a2, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load trampoline page directory, which will cause us to trap to</span>
<span class="p_add">+	 * stvec if VA != PA, or simply fall through if VA == PA</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	la a0, trampoline_pg_dir</span>
<span class="p_add">+	srl a0, a0, PAGE_SHIFT</span>
<span class="p_add">+	or a0, a0, a1</span>
<span class="p_add">+	sfence.vma</span>
<span class="p_add">+	csrw sptbr, a0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Set trap vector to spin forever to help debug */</span>
<span class="p_add">+	la a0, .Lsecondary_park</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload the global pointer */</span>
<span class="p_add">+.option push</span>
<span class="p_add">+.option norelax</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+.option pop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch to kernel page tables */</span>
<span class="p_add">+	csrw sptbr, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_start:</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	li a1, CONFIG_NR_CPUS</span>
<span class="p_add">+	bgeu a0, a1, .Lsecondary_park</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set trap vector to spin forever to help debug */</span>
<span class="p_add">+	la a3, .Lsecondary_park</span>
<span class="p_add">+	csrw stvec, a3</span>
<span class="p_add">+</span>
<span class="p_add">+	slli a3, a0, LGREG</span>
<span class="p_add">+	la a1, __cpu_up_stack_pointer</span>
<span class="p_add">+	la a2, __cpu_up_task_pointer</span>
<span class="p_add">+	add a1, a3, a1</span>
<span class="p_add">+	add a2, a3, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This hart didn&#39;t win the lottery, so we wait for the winning hart to</span>
<span class="p_add">+	 * get far enough along the boot process that it should continue.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+.Lwait_for_cpu_up:</span>
<span class="p_add">+	/* FIXME: We should WFI to save some energy here. */</span>
<span class="p_add">+	REG_L sp, (a1)</span>
<span class="p_add">+	REG_L tp, (a2)</span>
<span class="p_add">+	beqz sp, .Lwait_for_cpu_up</span>
<span class="p_add">+	beqz tp, .Lwait_for_cpu_up</span>
<span class="p_add">+	fence</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable virtual memory and relocate to virtual address */</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	tail smp_callin</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_park:</span>
<span class="p_add">+	/* We lack SMP support or have too many harts, so park this hart */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	j .Lsecondary_park</span>
<span class="p_add">+END(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+__PAGE_ALIGNED_BSS</span>
<span class="p_add">+	/* Empty zero page */</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+ENTRY(empty_zero_page)</span>
<span class="p_add">+	.fill (empty_zero_page + PAGE_SIZE) - ., 1, 0x00</span>
<span class="p_add">+END(empty_zero_page)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c</span>
new file mode 100644
<span class="p_header">index 000000000000..328718e8026e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/irq.c</span>
<span class="p_chunk">@@ -0,0 +1,39 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqdomain.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_RISCV_INTC</span>
<span class="p_add">+#include &lt;linux/irqchip/irq-riscv-intc.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_IRQ(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	irqchip_init();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_RISCV_INTC</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * FIXME: We don&#39;t want a direct call to riscv_intc_irq here.  The plan</span>
<span class="p_add">+	 * is to put an IRQ domain here and let the interrupt controller</span>
<span class="p_add">+	 * register with that, but I poked around the arm64 code a bit and</span>
<span class="p_add">+	 * there might be a better way to do it (ie, something fully generic).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	riscv_intc_irq(cause, regs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2a53d26ffdd6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/reset.c</span>
<span class="p_chunk">@@ -0,0 +1,36 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void (*pm_power_off)(void) = machine_power_off;</span>
<span class="p_add">+EXPORT_SYMBOL(pm_power_off);</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_restart(char *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	do_kernel_restart(cmd);</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_halt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	machine_power_off();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sbi_shutdown();</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c</span>
new file mode 100644
<span class="p_header">index 000000000000..de7db114c315</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/setup.c</span>
<span class="p_chunk">@@ -0,0 +1,257 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_fdt.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HVC_RISCV_SBI</span>
<span class="p_add">+#include &lt;asm/hvc_riscv_sbi.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+struct screen_info screen_info = {</span>
<span class="p_add">+	.orig_video_lines	= 30,</span>
<span class="p_add">+	.orig_video_cols	= 80,</span>
<span class="p_add">+	.orig_video_mode	= 0,</span>
<span class="p_add">+	.orig_video_ega_bx	= 0,</span>
<span class="p_add">+	.orig_video_isVGA	= 1,</span>
<span class="p_add">+	.orig_video_points	= 8</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long va_pa_offset;</span>
<span class="p_add">+unsigned long pfn_base;</span>
<span class="p_add">+</span>
<span class="p_add">+/* The lucky hart to first increment this variable will boot the other cores */</span>
<span class="p_add">+atomic_t hart_lottery;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+static void __init setup_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char __initramfs_start[];</span>
<span class="p_add">+	extern unsigned long __initramfs_size;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__initramfs_size &gt; 0) {</span>
<span class="p_add">+		initrd_start = (unsigned long)(&amp;__initramfs_start);</span>
<span class="p_add">+		initrd_end = initrd_start + __initramfs_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (initrd_start &gt;= initrd_end) {</span>
<span class="p_add">+		printk(KERN_INFO &quot;initrd not found or empty&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__pa(initrd_end) &gt; PFN_PHYS(max_low_pfn)) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;initrd extends beyond end of memory&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size =  initrd_end - initrd_start;</span>
<span class="p_add">+	memblock_reserve(__pa(initrd_start), size);</span>
<span class="p_add">+	initrd_below_start_ok = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;Initial ramdisk at: 0x%p (%lu bytes)\n&quot;,</span>
<span class="p_add">+		(void *)(initrd_start), size);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+disable:</span>
<span class="p_add">+	pr_cont(&quot; - disabling initrd\n&quot;);</span>
<span class="p_add">+	initrd_start = 0;</span>
<span class="p_add">+	initrd_end = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+pgd_t swapper_pg_dir[PTRS_PER_PGD] __page_aligned_bss;</span>
<span class="p_add">+pgd_t trampoline_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+#define NUM_SWAPPER_PMDS ((uintptr_t)-PAGE_OFFSET &gt;&gt; PGDIR_SHIFT)</span>
<span class="p_add">+pmd_t swapper_pmd[PTRS_PER_PMD*((-PAGE_OFFSET)/PGDIR_SIZE)] __page_aligned_bss;</span>
<span class="p_add">+pmd_t trampoline_pmd[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __init setup_vm(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char _start;</span>
<span class="p_add">+	uintptr_t i;</span>
<span class="p_add">+	uintptr_t pa = (uintptr_t) &amp;_start;</span>
<span class="p_add">+	pgprot_t prot = __pgprot(pgprot_val(PAGE_KERNEL) | _PAGE_EXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	va_pa_offset = PAGE_OFFSET - pa;</span>
<span class="p_add">+	pfn_base = PFN_DOWN(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Sanity check alignment and size */</span>
<span class="p_add">+	BUG_ON((PAGE_OFFSET % PGDIR_SIZE) != 0);</span>
<span class="p_add">+	BUG_ON((pa % (PAGE_SIZE * PTRS_PER_PTE)) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN((uintptr_t)trampoline_pmd),</span>
<span class="p_add">+			__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	trampoline_pmd[0] = pfn_pmd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN((uintptr_t)swapper_pmd) + i,</span>
<span class="p_add">+				__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(swapper_pmd); i++)</span>
<span class="p_add">+		swapper_pmd[i] = pfn_pmd(PFN_DOWN(pa + i * PMD_SIZE), prot);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN(pa + i * PGDIR_SIZE), prot);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sbi_save(unsigned int hartid, void *dtb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	early_init_dt_scan(__va(dtb));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Allow the user to manually add a memory region (in case DTS is broken);</span>
<span class="p_add">+ * &quot;mem_end=nn[KkMmGg]&quot;</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init mem_end_override(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	resource_size_t base, end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!p)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	base = (uintptr_t) __pa(PAGE_OFFSET);</span>
<span class="p_add">+	end = memparse(p, &amp;p) &amp; PMD_MASK;</span>
<span class="p_add">+	if (end == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	memblock_add(base, end - base);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+early_param(&quot;mem_end&quot;, mem_end_override);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init setup_bootmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct memblock_region *reg;</span>
<span class="p_add">+	phys_addr_t mem_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the memory region containing the kernel */</span>
<span class="p_add">+	for_each_memblock(memory, reg) {</span>
<span class="p_add">+		phys_addr_t vmlinux_end = __pa(_end);</span>
<span class="p_add">+		phys_addr_t end = reg-&gt;base + reg-&gt;size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (reg-&gt;base &lt;= vmlinux_end &amp;&amp; vmlinux_end &lt;= end) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Reserve from the start of the region to the end of</span>
<span class="p_add">+			 * the kernel</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			memblock_reserve(reg-&gt;base, vmlinux_end - reg-&gt;base);</span>
<span class="p_add">+			mem_size = min(reg-&gt;size, (phys_addr_t)-PAGE_OFFSET);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	BUG_ON(mem_size == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_max_mapnr(PFN_DOWN(mem_size));</span>
<span class="p_add">+	max_low_pfn = pfn_base + PFN_DOWN(mem_size);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	setup_initrd();</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+	early_init_fdt_reserve_self();</span>
<span class="p_add">+	early_init_fdt_scan_reserved_mem();</span>
<span class="p_add">+	memblock_allow_resize();</span>
<span class="p_add">+	memblock_dump_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_arch(char **cmdline_p)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_HVC_RISCV_SBI)</span>
<span class="p_add">+	if (likely(early_console == NULL)) {</span>
<span class="p_add">+		early_console = &amp;riscv_sbi_early_console_dev;</span>
<span class="p_add">+		register_console(early_console);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_OVERRIDE</span>
<span class="p_add">+	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	if (builtin_cmdline[0] != &#39;\0&#39;) {</span>
<span class="p_add">+		/* Append bootloader command line to built-in */</span>
<span class="p_add">+		strlcat(builtin_cmdline, &quot; &quot;, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcat(builtin_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_OVERRIDE */</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+	*cmdline_p = boot_command_line;</span>
<span class="p_add">+</span>
<span class="p_add">+	parse_early_param();</span>
<span class="p_add">+</span>
<span class="p_add">+	init_mm.start_code = (unsigned long) _stext;</span>
<span class="p_add">+	init_mm.end_code   = (unsigned long) _etext;</span>
<span class="p_add">+	init_mm.end_data   = (unsigned long) _edata;</span>
<span class="p_add">+	init_mm.brk        = (unsigned long) _end;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_bootmem();</span>
<span class="p_add">+	paging_init();</span>
<span class="p_add">+	unflatten_device_tree();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	setup_smp();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+	conswitchp = &amp;dummy_con;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	riscv_fill_hwcap();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init riscv_device_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall_sync(riscv_device_init);</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smp.c b/arch/riscv/kernel/smp.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b4a71ec5906f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smp.c</span>
<span class="p_chunk">@@ -0,0 +1,110 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* A collection of single bit ipi messages.  */</span>
<span class="p_add">+static struct {</span>
<span class="p_add">+	unsigned long bits ____cacheline_aligned;</span>
<span class="p_add">+} ipi_data[NR_CPUS] __cacheline_aligned;</span>
<span class="p_add">+</span>
<span class="p_add">+enum ipi_message_type {</span>
<span class="p_add">+	IPI_RESCHEDULE,</span>
<span class="p_add">+	IPI_CALL_FUNC,</span>
<span class="p_add">+	IPI_MAX</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+irqreturn_t handle_ipi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *pending_ipis = &amp;ipi_data[smp_processor_id()].bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear pending IPI */</span>
<span class="p_add">+	csr_clear(sip, SIE_SSIE);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (true) {</span>
<span class="p_add">+		unsigned long ops;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order bit clearing and data access. */</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+</span>
<span class="p_add">+		ops = xchg(pending_ipis, 0);</span>
<span class="p_add">+		if (ops == 0)</span>
<span class="p_add">+			return IRQ_HANDLED;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_RESCHEDULE))</span>
<span class="p_add">+			scheduler_ipi();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_CALL_FUNC))</span>
<span class="p_add">+			generic_smp_call_function_interrupt();</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON((ops &gt;&gt; IPI_MAX) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order data access and bit testing. */</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+send_ipi_message(const struct cpumask *to_whom, enum ipi_message_type operation)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	for_each_cpu(i, to_whom)</span>
<span class="p_add">+		set_bit(operation, &amp;ipi_data[i].bits);</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	sbi_send_ipi(cpumask_bits(to_whom));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(mask, IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ipi_stop(void *unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (1)</span>
<span class="p_add">+		wait_for_interrupt();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_stop, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_reschedule(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c</span>
new file mode 100644
<span class="p_header">index 000000000000..f741458c5a3f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smpboot.c</span>
<span class="p_chunk">@@ -0,0 +1,114 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel_stat.h&gt;</span>
<span class="p_add">+#include &lt;linux/notifier.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;asm/irq.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void *__cpu_up_stack_pointer[NR_CPUS];</span>
<span class="p_add">+void *__cpu_up_task_pointer[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_boot_cpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_smp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn = NULL;</span>
<span class="p_add">+	int hart, im_okay_therefore_i_am = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;))) {</span>
<span class="p_add">+		hart = riscv_of_processor_hart(dn);</span>
<span class="p_add">+		if (hart &gt;= 0) {</span>
<span class="p_add">+			set_cpu_possible(hart, true);</span>
<span class="p_add">+			set_cpu_present(hart, true);</span>
<span class="p_add">+			if (hart == smp_processor_id()) {</span>
<span class="p_add">+				BUG_ON(im_okay_therefore_i_am);</span>
<span class="p_add">+				im_okay_therefore_i_am = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!im_okay_therefore_i_am);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __cpu_up(unsigned int cpu, struct task_struct *tidle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	tidle-&gt;thread_info.cpu = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On RISC-V systems, all harts boot on their own accord.  Our _start</span>
<span class="p_add">+	 * selects the first hart to boot the kernel and causes the remainder</span>
<span class="p_add">+	 * of the harts to spin in a loop waiting for their stack pointer to be</span>
<span class="p_add">+	 * setup by that main hart.  Writing __cpu_up_stack_pointer signals to</span>
<span class="p_add">+	 * the spinning harts that they can continue the boot process.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;</span>
<span class="p_add">+	__cpu_up_task_pointer[cpu] = tidle;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!cpu_online(cpu))</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_cpus_done(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * C entry point for a secondary processor.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void __init smp_callin(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = &amp;init_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All kernel threads share the same mm context.  */</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+	current-&gt;active_mm = mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	trap_init();</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+	notify_cpu_starting(smp_processor_id());</span>
<span class="p_add">+	set_cpu_online(smp_processor_id(), 1);</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2463fcca719e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/time.c</span>
<span class="p_chunk">@@ -0,0 +1,61 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/clocksource.h&gt;</span>
<span class="p_add">+#include &lt;linux/clockchips.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_RISCV_TIMER</span>
<span class="p_add">+#include &lt;linux/timer_riscv.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long riscv_timebase;</span>
<span class="p_add">+</span>
<span class="p_add">+DECLARE_PER_CPU(struct clock_event_device, riscv_clock_event);</span>
<span class="p_add">+</span>
<span class="p_add">+void riscv_timer_interrupt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_RISCV_TIMER</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * FIXME: This needs to be cleaned up along with the rest of the IRQ</span>
<span class="p_add">+	 * handling cleanup.  See irq.c for more details.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct clock_event_device *evdev = this_cpu_ptr(&amp;riscv_clock_event);</span>
<span class="p_add">+</span>
<span class="p_add">+	evdev-&gt;event_handler(evdev);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_clockevent(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	timer_probe();</span>
<span class="p_add">+	csr_set(sie, SIE_STIE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init time_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *cpu;</span>
<span class="p_add">+	u32 prop;</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu = of_find_node_by_path(&quot;/cpus&quot;);</span>
<span class="p_add">+	if (!cpu || of_property_read_u32(cpu, &quot;timebase-frequency&quot;, &amp;prop))</span>
<span class="p_add">+		panic(KERN_WARNING &quot;RISC-V system with no &#39;timebase-frequency&#39; in DTS\n&quot;);</span>
<span class="p_add">+	riscv_timebase = prop;</span>
<span class="p_add">+</span>
<span class="p_add">+	lpj_fine = riscv_timebase / HZ;</span>
<span class="p_add">+</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 000000000000..93132cb59184</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,180 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+int show_unhandled_signals = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void handle_exception(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+void die(struct pt_regs *regs, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	oops_enter();</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s [#%d]\n&quot;, str, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = notify_die(DIE_OOPS, str, regs, 0, regs-&gt;scause, SIGSEGV);</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	oops_exit();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_interrupt())</span>
<span class="p_add">+		panic(&quot;Fatal exception in interrupt&quot;);</span>
<span class="p_add">+	if (panic_on_oops)</span>
<span class="p_add">+		panic(&quot;Fatal exception&quot;);</span>
<span class="p_add">+	if (ret != NOTIFY_STOP)</span>
<span class="p_add">+		do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void do_trap_siginfo(int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = signo;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = code;</span>
<span class="p_add">+	info.si_addr = (void __user *)addr;</span>
<span class="p_add">+	force_sig_info(signo, &amp;info, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, signo)</span>
<span class="p_add">+	    &amp;&amp; printk_ratelimit()) {</span>
<span class="p_add">+		pr_info(&quot;%s[%d]: unhandled signal %d code 0x%x at 0x&quot; REG_FMT,</span>
<span class="p_add">+			tsk-&gt;comm, task_pid_nr(tsk), signo, code, addr);</span>
<span class="p_add">+		print_vma_addr(KERN_CONT &quot; in &quot;, GET_IP(regs));</span>
<span class="p_add">+		pr_cont(&quot;\n&quot;);</span>
<span class="p_add">+		show_regs(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(signo, code, addr, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_trap_error(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		do_trap(regs, signo, code, addr, current);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(regs, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define DO_ERROR_INFO(name, signo, code, str)				\</span>
<span class="p_add">+asmlinkage void name(struct pt_regs *regs)				\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	do_trap_error(regs, signo, code, regs-&gt;sepc, &quot;Oops - &quot; str);	\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_unknown,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;unknown exception&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;instruction address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;instruction access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_illegal,</span>
<span class="p_add">+	SIGILL, ILL_ILLOPC, &quot;illegal instruction&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;load address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;load access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;store (or AMO) address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;store (or AMO) access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_u,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from U-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_s,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from S-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_m,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from M-mode&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void do_trap_break(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		enum bug_trap_type type;</span>
<span class="p_add">+</span>
<span class="p_add">+		type = report_bug(regs-&gt;sepc, regs);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case BUG_TRAP_TYPE_NONE:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_WARN:</span>
<span class="p_add">+			regs-&gt;sepc += sizeof(bug_insn_t);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_BUG:</span>
<span class="p_add">+			die(regs, &quot;Kernel BUG&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(SIGTRAP, TRAP_BRKPT, regs-&gt;sepc, current);</span>
<span class="p_add">+	regs-&gt;sepc += 0x4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+int is_valid_bugaddr(unsigned long pc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bug_insn_t insn;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pc &lt; PAGE_OFFSET)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (probe_kernel_address((bug_insn_t __user *)pc, insn))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return (insn == __BUG_INSN);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set sup0 scratch register to 0, indicating to exception vector</span>
<span class="p_add">+	 * that we are presently executing in the kernel</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	csr_write(sscratch, 0);</span>
<span class="p_add">+	/* Set the exception vector address */</span>
<span class="p_add">+	csr_write(stvec, &amp;handle_exception);</span>
<span class="p_add">+	/* Enable all interrupts */</span>
<span class="p_add">+	csr_write(sie, -1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso.c b/arch/riscv/kernel/vdso.c</span>
new file mode 100644
<span class="p_header">index 000000000000..e8a178df8144</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso.c</span>
<span class="p_chunk">@@ -0,0 +1,125 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2004 Benjamin Herrenschmidt, IBM Corp.</span>
<span class="p_add">+ *                    &lt;benh@kernel.crashing.org&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/binfmts.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern char vdso_start[], vdso_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vdso_pages;</span>
<span class="p_add">+static struct page **vdso_pagelist;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The vDSO data page.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static union {</span>
<span class="p_add">+	struct vdso_data	data;</span>
<span class="p_add">+	u8			page[PAGE_SIZE];</span>
<span class="p_add">+} vdso_data_store __page_aligned_data;</span>
<span class="p_add">+struct vdso_data *vdso_data = &amp;vdso_data_store.data;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init vdso_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_pages = (vdso_end - vdso_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	vdso_pagelist =</span>
<span class="p_add">+		kcalloc(vdso_pages + 1, sizeof(struct page *), GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(vdso_pagelist == NULL)) {</span>
<span class="p_add">+		pr_err(&quot;vdso: pagelist allocation failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; vdso_pages; i++) {</span>
<span class="p_add">+		struct page *pg;</span>
<span class="p_add">+</span>
<span class="p_add">+		pg = virt_to_page(vdso_start + (i &lt;&lt; PAGE_SHIFT));</span>
<span class="p_add">+		ClearPageReserved(pg);</span>
<span class="p_add">+		vdso_pagelist[i] = pg;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	vdso_pagelist[i] = virt_to_page(vdso_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(vdso_init);</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_setup_additional_pages(struct linux_binprm *bprm,</span>
<span class="p_add">+	int uses_interp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_add">+	unsigned long vdso_base, vdso_len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_len = (vdso_pages + 1) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	vdso_base = get_unmapped_area(NULL, 0, vdso_len, 0, 0);</span>
<span class="p_add">+	if (unlikely(IS_ERR_VALUE(vdso_base))) {</span>
<span class="p_add">+		ret = vdso_base;</span>
<span class="p_add">+		goto end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Put vDSO base into mm struct. We need to do this before calling</span>
<span class="p_add">+	 * install_special_mapping or the perf counter mmap tracking code</span>
<span class="p_add">+	 * will fail to recognise it as a vDSO (since arch_vma_name fails).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mm-&gt;context.vdso = (void *)vdso_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = install_special_mapping(mm, vdso_base, vdso_len,</span>
<span class="p_add">+		(VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC),</span>
<span class="p_add">+		vdso_pagelist);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		mm-&gt;context.vdso = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+end:</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_mm &amp;&amp; (vma-&gt;vm_start == (long)vma-&gt;vm_mm-&gt;context.vdso))</span>
<span class="p_add">+		return &quot;[vdso]&quot;;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function stubs to prevent linker errors when AT_SYSINFO_EHDR is defined</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area_no_mm(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9f4bee5e51fd</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/mm/init.c</span>
<span class="p_chunk">@@ -0,0 +1,70 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/bootmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/swap.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init zone_sizes_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long zones_size[MAX_NR_ZONES];</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(zones_size, 0, sizeof(zones_size));</span>
<span class="p_add">+	zones_size[ZONE_NORMAL] = max_mapnr;</span>
<span class="p_add">+	free_area_init_node(0, zones_size, pfn_base, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void setup_zero_page(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset((void *)empty_zero_page, 0, PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init paging_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	init_mm.pgd = (pgd_t *)pfn_to_virt(csr_read(sptbr));</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_zero_page();</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	zone_sizes_init();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init mem_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FLATMEM</span>
<span class="p_add">+	BUG_ON(!mem_map);</span>
<span class="p_add">+#endif /* CONFIG_FLATMEM */</span>
<span class="p_add">+</span>
<span class="p_add">+	high_memory = (void *)(__va(PFN_PHYS(max_low_pfn)));</span>
<span class="p_add">+	free_all_bootmem();</span>
<span class="p_add">+</span>
<span class="p_add">+	mem_init_print_info(NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void free_initmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	free_initmem_default(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+void free_initrd_mem(unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



