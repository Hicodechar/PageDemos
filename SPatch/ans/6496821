
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt12 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt12</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 28, 2015, 9:03 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1432803804-13400-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6496821/mbox/"
   >mbox</a>
|
   <a href="/patch/6496821/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6496821/">/patch/6496821/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 18BC79F443
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 May 2015 09:04:48 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id B6F2A206B8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 May 2015 09:04:38 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id DE3ED206A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 May 2015 09:04:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753876AbbE1JEO (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 28 May 2015 05:04:14 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:46300 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753839AbbE1JD2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 28 May 2015 05:03:28 -0400
Received: from av-217-129-142-138.netvisao.pt ([217.129.142.138]
	helo=localhost) by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1Yxtio-0007pL-4C; Thu, 28 May 2015 09:03:26 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt12
Date: Thu, 28 May 2015 10:03:24 +0100
Message-Id: &lt;1432803804-13400-2-git-send-email-luis.henriques@canonical.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1432803804-13400-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1432803804-13400-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - May 28, 2015, 9:03 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">index a4873e5e3e36..e30e184f50c7 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> dma_apbx: dma-apbx@80024000 {</span>
 		      80 81 68 69
 		      70 71 72 73
 		      74 75 76 77&gt;;
<span class="p_del">-	interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+	interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 			  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 			  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 			  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index c85942532dd5..f6ca2e530727 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3462,6 +3462,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 					READ_CAPACITY_16 command);
 				f = NO_REPORT_OPCODES (don&#39;t use report opcodes
 					command, uas only);
<span class="p_add">+				g = MAX_SECTORS_240 (don&#39;t transfer more than</span>
<span class="p_add">+					240 sectors at a time, uas only);</span>
 				h = CAPACITY_HEURISTICS (decrease the
 					reported device capacity by one
 					sector if the number is odd);
<span class="p_header">diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt</span>
<span class="p_header">index 612e6e99d1e5..769c2cb7f9b3 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/api.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/api.txt</span>
<span class="p_chunk">@@ -2382,7 +2382,8 @@</span> <span class="p_context"> should be created before this ioctl is invoked.</span>
 
 Possible features:
 	- KVM_ARM_VCPU_POWER_OFF: Starts the CPU in a power-off state.
<span class="p_del">-	  Depends on KVM_CAP_ARM_PSCI.</span>
<span class="p_add">+	  Depends on KVM_CAP_ARM_PSCI.  If not set, the CPU will be powered on</span>
<span class="p_add">+	  and execute guest code when KVM_RUN is called.</span>
 	- KVM_ARM_VCPU_EL1_32BIT: Starts the CPU in a 32bit mode.
 	  Depends on KVM_CAP_ARM_EL1_32BIT (arm64 only).
 	- KVM_ARM_VCPU_PSCI_0_2: Emulate PSCI v0.2 for the CPU.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index d5de7dccbe7a..c2c3ab88cea7 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt11</span>
<span class="p_add">+EXTRAVERSION =-ckt12</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c</span>
<span class="p_header">index d68b410595c8..a0c63fc48457 100644</span>
<span class="p_header">--- a/arch/arc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arc/kernel/signal.c</span>
<span class="p_chunk">@@ -131,6 +131,15 @@</span> <span class="p_context"> SYSCALL_DEFINE0(rt_sigreturn)</span>
 	/* Don&#39;t restart from sigreturn */
 	syscall_wont_restart(regs);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure that sigreturn always returns to user mode (in case the</span>
<span class="p_add">+	 * regs saved on user stack got fudged between save and sigreturn)</span>
<span class="p_add">+	 * Otherwise it is easy to panic the kernel with a custom</span>
<span class="p_add">+	 * signal handler and/or restorer which clobberes the status32/ret</span>
<span class="p_add">+	 * to return to a bogus location in kernel mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;status32 |= STATUS_U_MASK;</span>
<span class="p_add">+</span>
 	return regs-&gt;r0;
 
 badframe:
<span class="p_chunk">@@ -234,8 +243,11 @@</span> <span class="p_context"> setup_rt_frame(int signo, struct k_sigaction *ka, siginfo_t *info,</span>
 
 	/*
 	 * handler returns using sigreturn stub provided already by userpsace
<span class="p_add">+	 * If not, nuke the process right away</span>
 	 */
<span class="p_del">-	BUG_ON(!(ka-&gt;sa.sa_flags &amp; SA_RESTORER));</span>
<span class="p_add">+	if(!(ka-&gt;sa.sa_flags &amp; SA_RESTORER))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
 	regs-&gt;blink = (unsigned long)ka-&gt;sa.sa_restorer;
 
 	/* User Stack for signal handler will be above the frame just carved */
<span class="p_chunk">@@ -302,12 +314,12 @@</span> <span class="p_context"> handle_signal(unsigned long sig, struct k_sigaction *ka, siginfo_t *info,</span>
 	      struct pt_regs *regs)
 {
 	sigset_t *oldset = sigmask_to_save();
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int failed;</span>
 
 	/* Set up the stack frame */
<span class="p_del">-	ret = setup_rt_frame(sig, ka, info, oldset, regs);</span>
<span class="p_add">+	failed = setup_rt_frame(sig, ka, info, oldset, regs);</span>
 
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (failed)</span>
 		force_sigsegv(sig, current);
 	else
 		signal_delivered(sig, info, ka, regs, 0);
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">index 4e5a59ee1501..db06fa397f79 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_chunk">@@ -71,6 +71,10 @@</span> <span class="p_context"></span>
 		};
 
 		internal-regs {
<span class="p_add">+			rtc@10300 {</span>
<span class="p_add">+				/* No crystal connected to the internal RTC */</span>
<span class="p_add">+				status = &quot;disabled&quot;;</span>
<span class="p_add">+			};</span>
 			serial@12000 {
 				status = &quot;okay&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/boot/dts/imx23-olinuxino.dts b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">index 7e6eef2488e8..82045398bf1f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
  */
 
 /dts-v1/;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 #include &quot;imx23.dtsi&quot;
 
 / {
<span class="p_chunk">@@ -93,6 +94,7 @@</span> <span class="p_context"></span>
 
 	ahb@80080000 {
 		usb0: usb@80080000 {
<span class="p_add">+			dr_mode = &quot;host&quot;;</span>
 			vbus-supply = &lt;&amp;reg_usb0_vbus&gt;;
 			status = &quot;okay&quot;;
 		};
<span class="p_chunk">@@ -122,7 +124,7 @@</span> <span class="p_context"></span>
 
 		user {
 			label = &quot;green&quot;;
<span class="p_del">-			gpios = &lt;&amp;gpio2 1 1&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;</span>
 		};
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">index 3073469cf808..ce2f47c25efe 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_chunk">@@ -426,6 +426,7 @@</span> <span class="p_context"></span>
 
 			pwm4: pwm@53fc8000 {
 				compatible = &quot;fsl,imx25-pwm&quot;, &quot;fsl,imx27-pwm&quot;;
<span class="p_add">+				#pwm-cells = &lt;2&gt;;</span>
 				reg = &lt;0x53fc8000 0x4000&gt;;
 				clocks = &lt;&amp;clks 108&gt;, &lt;&amp;clks 52&gt;;
 				clock-names = &quot;ipg&quot;, &quot;per&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx28.dtsi b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">index a95cc5358ff4..e40f3ea23507 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_chunk">@@ -857,7 +857,7 @@</span> <span class="p_context"></span>
 					      80 81 68 69
 					      70 71 72 73
 					      74 75 76 77&gt;;
<span class="p_del">-				interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+				interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 						  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 						  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 						  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">index faa3494a69d4..50c7718cb84e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 			regulator-min-microvolt = &lt;5000000&gt;;
 			regulator-max-microvolt = &lt;5000000&gt;;
 			gpio = &lt;&amp;gpio4 15 0&gt;;
<span class="p_add">+			enable-active-high;</span>
 		};
 
 		reg_usb_h1_vbus: regulator@1 {
<span class="p_chunk">@@ -40,6 +41,7 @@</span> <span class="p_context"></span>
 			regulator-min-microvolt = &lt;5000000&gt;;
 			regulator-max-microvolt = &lt;5000000&gt;;
 			gpio = &lt;&amp;gpio1 0 0&gt;;
<span class="p_add">+			enable-active-high;</span>
 		};
 	};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/omap3-n900.dts b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">index 1fe45d1f75ec..2b061fee8a20 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_chunk">@@ -437,6 +437,8 @@</span> <span class="p_context"></span>
 		DRVDD-supply = &lt;&amp;vmmc2&gt;;
 		IOVDD-supply = &lt;&amp;vio&gt;;
 		DVDD-supply = &lt;&amp;vio&gt;;
<span class="p_add">+</span>
<span class="p_add">+		ai3x-micbias-vg = &lt;1&gt;;</span>
 	};
 
 	tlv320aic3x_aux: tlv320aic3x@19 {
<span class="p_chunk">@@ -448,6 +450,8 @@</span> <span class="p_context"></span>
 		DRVDD-supply = &lt;&amp;vmmc2&gt;;
 		IOVDD-supply = &lt;&amp;vio&gt;;
 		DVDD-supply = &lt;&amp;vio&gt;;
<span class="p_add">+</span>
<span class="p_add">+		ai3x-micbias-vg = &lt;2&gt;;</span>
 	};
 
 	tsl2563: tsl2563@29 {
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-dbx5x0.dtsi b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">index e41eedca3ce3..55e4f2d30f8f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_chunk">@@ -985,23 +985,6 @@</span> <span class="p_context"></span>
 			status = &quot;disabled&quot;;
 		};
 
<span class="p_del">-		vmmci: regulator-gpio {</span>
<span class="p_del">-			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_del">-			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_del">-			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_del">-			regulator-type = &quot;voltage&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			startup-delay-us = &lt;100&gt;;</span>
<span class="p_del">-			enable-active-high;</span>
<span class="p_del">-</span>
<span class="p_del">-			states = &lt;1800000 0x1</span>
<span class="p_del">-				  2900000 0x0&gt;;</span>
<span class="p_del">-</span>
<span class="p_del">-			status = &quot;disabled&quot;;</span>
<span class="p_del">-		};</span>
<span class="p_del">-</span>
 		mcde@a0350000 {
 			compatible = &quot;stericsson,mcde&quot;;
 			reg = &lt;0xa0350000 0x1000&gt;, /* MCDE */
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-href.dtsi b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">index bf8f0eddc2c0..744c1e3a744d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_chunk">@@ -111,6 +111,21 @@</span> <span class="p_context"></span>
 			pinctrl-1 = &lt;&amp;i2c3_sleep_mode&gt;;
 		};
 
<span class="p_add">+		vmmci: regulator-gpio {</span>
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		// External Micro SD slot
 		sdi0_per1@80126000 {
 			arm,primecell-periphid = &lt;0x10480180&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-snowball.dts b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">index 474ef83229cd..ae435e94ef9b 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_chunk">@@ -147,8 +147,21 @@</span> <span class="p_context"></span>
 		};
 
 		vmmci: regulator-gpio {
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
 			gpios = &lt;&amp;gpio7 4 0x4&gt;;
 			enable-gpio = &lt;&amp;gpio6 25 0x4&gt;;
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
 		};
 
 		// External Micro SD slot
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_emulate.h b/arch/arm/include/asm/kvm_emulate.h</span>
<span class="p_header">index 0fa90c962ac8..853e2becad18 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -33,6 +33,11 @@</span> <span class="p_context"> void kvm_inject_undefined(struct kvm_vcpu *vcpu);</span>
 void kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr);
 void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr);
 
<span class="p_add">+static inline void vcpu_reset_hcr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu-&gt;arch.hcr = HCR_GUEST_MASK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool vcpu_mode_is_32bit(struct kvm_vcpu *vcpu)
 {
 	return 1;
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_host.h b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">index 193ceaf01bfd..f10a24e77134 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"></span>
 
 struct kvm_vcpu;
 u32 *kvm_vcpu_reg(struct kvm_vcpu *vcpu, u8 reg_num, u32 mode);
<span class="p_del">-int kvm_target_cpu(void);</span>
<span class="p_add">+int __attribute_const__ kvm_target_cpu(void);</span>
 int kvm_reset_vcpu(struct kvm_vcpu *vcpu);
 void kvm_reset_coprocs(struct kvm_vcpu *vcpu);
 
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 5c7aa3c1519f..8618badbbbbe 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -47,6 +47,7 @@</span> <span class="p_context"> int create_hyp_io_mappings(void *from, void *to, phys_addr_t);</span>
 void free_boot_hyp_pgd(void);
 void free_hyp_pgds(void);
 
<span class="p_add">+void stage2_unmap_vm(struct kvm *kvm);</span>
 int kvm_alloc_stage2_pgd(struct kvm *kvm);
 void kvm_free_stage2_pgd(struct kvm *kvm);
 int kvm_phys_addr_ioremap(struct kvm *kvm, phys_addr_t guest_ipa,
<span class="p_chunk">@@ -78,17 +79,6 @@</span> <span class="p_context"> static inline void kvm_set_pte(pte_t *pte, pte_t new_pte)</span>
 	flush_pmd_entry(pte);
 }
 
<span class="p_del">-static inline bool kvm_is_write_fault(unsigned long hsr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long hsr_ec = hsr &gt;&gt; HSR_EC_SHIFT;</span>
<span class="p_del">-	if (hsr_ec == HSR_EC_IABT)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	else if ((hsr &amp; HSR_ISV) &amp;&amp; !(hsr &amp; HSR_WNR))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void kvm_clean_pgd(pgd_t *pgd)
 {
 	clean_dcache_area(pgd, PTRS_PER_S2_PGD * sizeof(pgd_t));
<span class="p_chunk">@@ -127,6 +117,19 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\
 })
 
<span class="p_add">+#define kvm_pgd_index(addr)			pgd_index(addr)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool kvm_page_empty(void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *ptr_page = virt_to_page(ptr);</span>
<span class="p_add">+	return page_count(ptr_page) == 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define kvm_pte_table_empty(ptep) kvm_page_empty(ptep)</span>
<span class="p_add">+#define kvm_pmd_table_empty(pmdp) kvm_page_empty(pmdp)</span>
<span class="p_add">+#define kvm_pud_table_empty(pudp) (0)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 struct kvm;
 
 #define kvm_flush_dcache_to_poc(a,l)	__cpuc_flush_dcache_area((a), (l))
<span class="p_header">diff --git a/arch/arm/kernel/hyp-stub.S b/arch/arm/kernel/hyp-stub.S</span>
<span class="p_header">index 797b1a6a4906..7e666cfda634 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hyp-stub.S</span>
<span class="p_header">+++ b/arch/arm/kernel/hyp-stub.S</span>
<span class="p_chunk">@@ -134,9 +134,7 @@</span> <span class="p_context"> ENTRY(__hyp_stub_install_secondary)</span>
 	mcr	p15, 4, r7, c1, c1, 3	@ HSTR
 
 THUMB(	orr	r7, #(1 &lt;&lt; 30)	)	@ HSCTLR.TE
<span class="p_del">-#ifdef CONFIG_CPU_BIG_ENDIAN</span>
<span class="p_del">-	orr	r7, #(1 &lt;&lt; 9)		@ HSCTLR.EE</span>
<span class="p_del">-#endif</span>
<span class="p_add">+ARM_BE8(orr	r7, r7, #(1 &lt;&lt; 25))     @ HSCTLR.EE</span>
 	mcr	p15, 4, r7, c1, c0, 0	@ HSCTLR
 
 	mrc	p15, 4, r7, c1, c1, 1	@ HDCR
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index 3c82b37c0f9e..17c7ac58f887 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arm_get_running_vcpu(void)</span>
 /**
  * kvm_arm_get_running_vcpus - get the per-CPU array of currently running vcpus.
  */
<span class="p_del">-struct kvm_vcpu __percpu **kvm_get_running_vcpus(void)</span>
<span class="p_add">+struct kvm_vcpu * __percpu *kvm_get_running_vcpus(void)</span>
 {
 	return &amp;kvm_arm_running_vcpu;
 }
<span class="p_chunk">@@ -155,16 +155,6 @@</span> <span class="p_context"> int kvm_arch_vcpu_fault(struct kvm_vcpu *vcpu, struct vm_fault *vmf)</span>
 	return VM_FAULT_SIGBUS;
 }
 
<span class="p_del">-void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,</span>
<span class="p_del">-			   struct kvm_memory_slot *dont)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,</span>
<span class="p_del">-			    unsigned long npages)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
 
 /**
  * kvm_arch_destroy_vm - destroy the VM data structure
<span class="p_chunk">@@ -225,39 +215,17 @@</span> <span class="p_context"> long kvm_arch_dev_ioctl(struct file *filp,</span>
 	return -EINVAL;
 }
 
<span class="p_del">-void kvm_arch_memslots_updated(struct kvm *kvm)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
<span class="p_del">-				   struct kvm_memory_slot *memslot,</span>
<span class="p_del">-				   struct kvm_userspace_memory_region *mem,</span>
<span class="p_del">-				   enum kvm_mr_change change)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void kvm_arch_commit_memory_region(struct kvm *kvm,</span>
<span class="p_del">-				   struct kvm_userspace_memory_region *mem,</span>
<span class="p_del">-				   const struct kvm_memory_slot *old,</span>
<span class="p_del">-				   enum kvm_mr_change change)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void kvm_arch_flush_shadow_all(struct kvm *kvm)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void kvm_arch_flush_shadow_memslot(struct kvm *kvm,</span>
<span class="p_del">-				   struct kvm_memory_slot *slot)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
 
 struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)
 {
 	int err;
 	struct kvm_vcpu *vcpu;
 
<span class="p_add">+	if (irqchip_in_kernel(kvm) &amp;&amp; vgic_initialized(kvm)) {</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	vcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);
 	if (!vcpu) {
 		err = -ENOMEM;
<span class="p_chunk">@@ -465,15 +433,16 @@</span> <span class="p_context"> static void update_vttbr(struct kvm *kvm)</span>
 
 	/* update vttbr to be used with the new vmid */
 	pgd_phys = virt_to_phys(kvm-&gt;arch.pgd);
<span class="p_add">+	BUG_ON(pgd_phys &amp; ~VTTBR_BADDR_MASK);</span>
 	vmid = ((u64)(kvm-&gt;arch.vmid) &lt;&lt; VTTBR_VMID_SHIFT) &amp; VTTBR_VMID_MASK;
<span class="p_del">-	kvm-&gt;arch.vttbr = pgd_phys &amp; VTTBR_BADDR_MASK;</span>
<span class="p_del">-	kvm-&gt;arch.vttbr |= vmid;</span>
<span class="p_add">+	kvm-&gt;arch.vttbr = pgd_phys | vmid;</span>
 
 	spin_unlock(&amp;kvm_vmid_lock);
 }
 
 static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	struct kvm *kvm = vcpu-&gt;kvm;</span>
 	int ret;
 
 	if (likely(vcpu-&gt;arch.has_run_once))
<span class="p_chunk">@@ -485,12 +454,20 @@</span> <span class="p_context"> static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)</span>
 	 * Initialize the VGIC before running a vcpu the first time on
 	 * this VM.
 	 */
<span class="p_del">-	if (unlikely(!vgic_initialized(vcpu-&gt;kvm))) {</span>
<span class="p_del">-		ret = kvm_vgic_init(vcpu-&gt;kvm);</span>
<span class="p_add">+	if (unlikely(!vgic_initialized(kvm))) {</span>
<span class="p_add">+		ret = kvm_vgic_init(kvm);</span>
 		if (ret)
 			return ret;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Enable the arch timers only if we have an in-kernel VGIC</span>
<span class="p_add">+	 * and it has been properly initialized, since we cannot handle</span>
<span class="p_add">+	 * interrupts from the virtual timer with a userspace gic.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (irqchip_in_kernel(kvm) &amp;&amp; vgic_initialized(kvm))</span>
<span class="p_add">+		kvm_timer_enable(kvm);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -714,10 +691,21 @@</span> <span class="p_context"> static int kvm_arch_vcpu_ioctl_vcpu_init(struct kvm_vcpu *vcpu,</span>
 		return ret;
 
 	/*
<span class="p_add">+	 * Ensure a rebooted VM will fault in RAM pages and detect if the</span>
<span class="p_add">+	 * guest MMU is turned off and flush the caches as needed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vcpu-&gt;arch.has_run_once)</span>
<span class="p_add">+		stage2_unmap_vm(vcpu-&gt;kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	vcpu_reset_hcr(vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Handle the &quot;start in power-off&quot; case by marking the VCPU as paused.
 	 */
<span class="p_del">-	if (__test_and_clear_bit(KVM_ARM_VCPU_POWER_OFF, vcpu-&gt;arch.features))</span>
<span class="p_add">+	if (test_bit(KVM_ARM_VCPU_POWER_OFF, vcpu-&gt;arch.features))</span>
 		vcpu-&gt;arch.pause = true;
<span class="p_add">+	else</span>
<span class="p_add">+		vcpu-&gt;arch.pause = false;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -863,7 +851,8 @@</span> <span class="p_context"> static int hyp_init_cpu_notify(struct notifier_block *self,</span>
 	switch (action) {
 	case CPU_STARTING:
 	case CPU_STARTING_FROZEN:
<span class="p_del">-		cpu_init_hyp_mode(NULL);</span>
<span class="p_add">+		if (__hyp_get_vectors() == hyp_default_vectors)</span>
<span class="p_add">+			cpu_init_hyp_mode(NULL);</span>
 		break;
 	}
 
<span class="p_header">diff --git a/arch/arm/kvm/coproc.c b/arch/arm/kvm/coproc.c</span>
<span class="p_header">index c58a35116f63..7c732908f1df 100644</span>
<span class="p_header">--- a/arch/arm/kvm/coproc.c</span>
<span class="p_header">+++ b/arch/arm/kvm/coproc.c</span>
<span class="p_chunk">@@ -742,7 +742,7 @@</span> <span class="p_context"> static bool is_valid_cache(u32 val)</span>
 	u32 level, ctype;
 
 	if (val &gt;= CSSELR_MAX)
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+		return false;</span>
 
 	/* Bottom bit is Instruction or Data bit.  Next 3 bits are level. */
         level = (val &gt;&gt; 1);
<span class="p_header">diff --git a/arch/arm/kvm/guest.c b/arch/arm/kvm/guest.c</span>
<span class="p_header">index b23a59c1c522..2786eae10c0d 100644</span>
<span class="p_header">--- a/arch/arm/kvm/guest.c</span>
<span class="p_header">+++ b/arch/arm/kvm/guest.c</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> struct kvm_stats_debugfs_item debugfs_entries[] = {</span>
 
 int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	vcpu-&gt;arch.hcr = HCR_GUEST_MASK;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 16f804938b8f..c65db5d7ea92 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -90,104 +90,116 @@</span> <span class="p_context"> static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)</span>
 	return p;
 }
 
<span class="p_del">-static bool page_empty(void *ptr)</span>
<span class="p_add">+static void clear_pgd_entry(struct kvm *kvm, pgd_t *pgd, phys_addr_t addr)</span>
 {
<span class="p_del">-	struct page *ptr_page = virt_to_page(ptr);</span>
<span class="p_del">-	return page_count(ptr_page) == 1;</span>
<span class="p_add">+	pud_t *pud_table __maybe_unused = pud_offset(pgd, 0);</span>
<span class="p_add">+	pgd_clear(pgd);</span>
<span class="p_add">+	kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+	pud_free(NULL, pud_table);</span>
<span class="p_add">+	put_page(virt_to_page(pgd));</span>
 }
 
 static void clear_pud_entry(struct kvm *kvm, pud_t *pud, phys_addr_t addr)
 {
<span class="p_del">-	if (pud_huge(*pud)) {</span>
<span class="p_del">-		pud_clear(pud);</span>
<span class="p_del">-		kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pmd_t *pmd_table = pmd_offset(pud, 0);</span>
<span class="p_del">-		pud_clear(pud);</span>
<span class="p_del">-		kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_del">-		pmd_free(NULL, pmd_table);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	pmd_t *pmd_table = pmd_offset(pud, 0);</span>
<span class="p_add">+	VM_BUG_ON(pud_huge(*pud));</span>
<span class="p_add">+	pud_clear(pud);</span>
<span class="p_add">+	kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+	pmd_free(NULL, pmd_table);</span>
 	put_page(virt_to_page(pud));
 }
 
 static void clear_pmd_entry(struct kvm *kvm, pmd_t *pmd, phys_addr_t addr)
 {
<span class="p_del">-	if (kvm_pmd_huge(*pmd)) {</span>
<span class="p_del">-		pmd_clear(pmd);</span>
<span class="p_del">-		kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pte_t *pte_table = pte_offset_kernel(pmd, 0);</span>
<span class="p_del">-		pmd_clear(pmd);</span>
<span class="p_del">-		kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_del">-		pte_free_kernel(NULL, pte_table);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	pte_t *pte_table = pte_offset_kernel(pmd, 0);</span>
<span class="p_add">+	VM_BUG_ON(kvm_pmd_huge(*pmd));</span>
<span class="p_add">+	pmd_clear(pmd);</span>
<span class="p_add">+	kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+	pte_free_kernel(NULL, pte_table);</span>
 	put_page(virt_to_page(pmd));
 }
 
<span class="p_del">-static void clear_pte_entry(struct kvm *kvm, pte_t *pte, phys_addr_t addr)</span>
<span class="p_add">+static void unmap_ptes(struct kvm *kvm, pmd_t *pmd,</span>
<span class="p_add">+		       phys_addr_t addr, phys_addr_t end)</span>
 {
<span class="p_del">-	if (pte_present(*pte)) {</span>
<span class="p_del">-		kvm_set_pte(pte, __pte(0));</span>
<span class="p_del">-		put_page(virt_to_page(pte));</span>
<span class="p_del">-		kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	phys_addr_t start_addr = addr;</span>
<span class="p_add">+	pte_t *pte, *start_pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	start_pte = pte = pte_offset_kernel(pmd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (!pte_none(*pte)) {</span>
<span class="p_add">+			kvm_set_pte(pte, __pte(0));</span>
<span class="p_add">+			put_page(virt_to_page(pte));</span>
<span class="p_add">+			kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pte++, addr += PAGE_SIZE, addr != end);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kvm_pte_table_empty(start_pte))</span>
<span class="p_add">+		clear_pmd_entry(kvm, pmd, start_addr);</span>
 }
 
<span class="p_del">-static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
<span class="p_del">-			unsigned long long start, u64 size)</span>
<span class="p_add">+static void unmap_pmds(struct kvm *kvm, pud_t *pud,</span>
<span class="p_add">+		       phys_addr_t addr, phys_addr_t end)</span>
 {
<span class="p_del">-	pgd_t *pgd;</span>
<span class="p_del">-	pud_t *pud;</span>
<span class="p_del">-	pmd_t *pmd;</span>
<span class="p_del">-	pte_t *pte;</span>
<span class="p_del">-	unsigned long long addr = start, end = start + size;</span>
<span class="p_del">-	u64 next;</span>
<span class="p_add">+	phys_addr_t next, start_addr = addr;</span>
<span class="p_add">+	pmd_t *pmd, *start_pmd;</span>
 
<span class="p_del">-	while (addr &lt; end) {</span>
<span class="p_del">-		pgd = pgdp + pgd_index(addr);</span>
<span class="p_del">-		pud = pud_offset(pgd, addr);</span>
<span class="p_del">-		pte = NULL;</span>
<span class="p_del">-		if (pud_none(*pud)) {</span>
<span class="p_del">-			addr = kvm_pud_addr_end(addr, end);</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		if (pud_huge(*pud)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If we are dealing with a huge pud, just clear it and</span>
<span class="p_del">-			 * move on.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			clear_pud_entry(kvm, pud, addr);</span>
<span class="p_del">-			addr = kvm_pud_addr_end(addr, end);</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+	start_pmd = pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pmd_addr_end(addr, end);</span>
<span class="p_add">+		if (!pmd_none(*pmd)) {</span>
<span class="p_add">+			if (kvm_pmd_huge(*pmd)) {</span>
<span class="p_add">+				pmd_clear(pmd);</span>
<span class="p_add">+				kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+				put_page(virt_to_page(pmd));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				unmap_ptes(kvm, pmd, addr, next);</span>
<span class="p_add">+			}</span>
 		}
<span class="p_add">+	} while (pmd++, addr = next, addr != end);</span>
 
<span class="p_del">-		pmd = pmd_offset(pud, addr);</span>
<span class="p_del">-		if (pmd_none(*pmd)) {</span>
<span class="p_del">-			addr = kvm_pmd_addr_end(addr, end);</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (kvm_pmd_table_empty(start_pmd))</span>
<span class="p_add">+		clear_pud_entry(kvm, pud, start_addr);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-		if (!kvm_pmd_huge(*pmd)) {</span>
<span class="p_del">-			pte = pte_offset_kernel(pmd, addr);</span>
<span class="p_del">-			clear_pte_entry(kvm, pte, addr);</span>
<span class="p_del">-			next = addr + PAGE_SIZE;</span>
<span class="p_del">-		}</span>
<span class="p_add">+static void unmap_puds(struct kvm *kvm, pgd_t *pgd,</span>
<span class="p_add">+		       phys_addr_t addr, phys_addr_t end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t next, start_addr = addr;</span>
<span class="p_add">+	pud_t *pud, *start_pud;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If the pmd entry is to be cleared, walk back up the ladder</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (kvm_pmd_huge(*pmd) || (pte &amp;&amp; page_empty(pte))) {</span>
<span class="p_del">-			clear_pmd_entry(kvm, pmd, addr);</span>
<span class="p_del">-			next = kvm_pmd_addr_end(addr, end);</span>
<span class="p_del">-			if (page_empty(pmd) &amp;&amp; !page_empty(pud)) {</span>
<span class="p_del">-				clear_pud_entry(kvm, pud, addr);</span>
<span class="p_del">-				next = kvm_pud_addr_end(addr, end);</span>
<span class="p_add">+	start_pud = pud = pud_offset(pgd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pud_addr_end(addr, end);</span>
<span class="p_add">+		if (!pud_none(*pud)) {</span>
<span class="p_add">+			if (pud_huge(*pud)) {</span>
<span class="p_add">+				pud_clear(pud);</span>
<span class="p_add">+				kvm_tlb_flush_vmid_ipa(kvm, addr);</span>
<span class="p_add">+				put_page(virt_to_page(pud));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				unmap_pmds(kvm, pud, addr, next);</span>
 			}
 		}
<span class="p_add">+	} while (pud++, addr = next, addr != end);</span>
 
<span class="p_del">-		addr = next;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (kvm_pud_table_empty(start_pud))</span>
<span class="p_add">+		clear_pgd_entry(kvm, pgd, start_addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
<span class="p_add">+			phys_addr_t start, u64 size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	phys_addr_t addr = start, end = start + size;</span>
<span class="p_add">+	phys_addr_t next;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = pgdp + kvm_pgd_index(addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = kvm_pgd_addr_end(addr, end);</span>
<span class="p_add">+		if (!pgd_none(*pgd))</span>
<span class="p_add">+			unmap_puds(kvm, pgd, addr, next);</span>
<span class="p_add">+	} while (pgd++, addr = next, addr != end);</span>
 }
 
 static void stage2_flush_ptes(struct kvm *kvm, pmd_t *pmd,
<span class="p_chunk">@@ -252,7 +264,7 @@</span> <span class="p_context"> static void stage2_flush_memslot(struct kvm *kvm,</span>
 	phys_addr_t next;
 	pgd_t *pgd;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	do {
 		next = kvm_pgd_addr_end(addr, end);
 		stage2_flush_puds(kvm, pgd, addr, next);
<span class="p_chunk">@@ -544,6 +556,71 @@</span> <span class="p_context"> static void unmap_stage2_range(struct kvm *kvm, phys_addr_t start, u64 size)</span>
 	unmap_range(kvm, kvm-&gt;arch.pgd, start, size);
 }
 
<span class="p_add">+static void stage2_unmap_memslot(struct kvm *kvm,</span>
<span class="p_add">+				 struct kvm_memory_slot *memslot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	hva_t hva = memslot-&gt;userspace_addr;</span>
<span class="p_add">+	phys_addr_t addr = memslot-&gt;base_gfn &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	phys_addr_t size = PAGE_SIZE * memslot-&gt;npages;</span>
<span class="p_add">+	hva_t reg_end = hva + size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A memory region could potentially cover multiple VMAs, and any holes</span>
<span class="p_add">+	 * between them, so iterate over all of them to find out if we should</span>
<span class="p_add">+	 * unmap any of them.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *     +--------------------------------------------+</span>
<span class="p_add">+	 * +---------------+----------------+   +----------------+</span>
<span class="p_add">+	 * |   : VMA 1     |      VMA 2     |   |    VMA 3  :    |</span>
<span class="p_add">+	 * +---------------+----------------+   +----------------+</span>
<span class="p_add">+	 *     |               memory region                |</span>
<span class="p_add">+	 *     +--------------------------------------------+</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		struct vm_area_struct *vma = find_vma(current-&gt;mm, hva);</span>
<span class="p_add">+		hva_t vm_start, vm_end;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!vma || vma-&gt;vm_start &gt;= reg_end)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Take the intersection of this VMA with the memory region</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		vm_start = max(hva, vma-&gt;vm_start);</span>
<span class="p_add">+		vm_end = min(reg_end, vma-&gt;vm_end);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(vma-&gt;vm_flags &amp; VM_PFNMAP)) {</span>
<span class="p_add">+			gpa_t gpa = addr + (vm_start - memslot-&gt;userspace_addr);</span>
<span class="p_add">+			unmap_stage2_range(kvm, gpa, vm_end - vm_start);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		hva = vm_end;</span>
<span class="p_add">+	} while (hva &lt; reg_end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * stage2_unmap_vm - Unmap Stage-2 RAM mappings</span>
<span class="p_add">+ * @kvm: The struct kvm pointer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Go through the memregions and unmap any reguler RAM</span>
<span class="p_add">+ * backing memory already mapped to the VM.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void stage2_unmap_vm(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_memslots *slots;</span>
<span class="p_add">+	struct kvm_memory_slot *memslot;</span>
<span class="p_add">+	int idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	idx = srcu_read_lock(&amp;kvm-&gt;srcu);</span>
<span class="p_add">+	spin_lock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	slots = kvm_memslots(kvm);</span>
<span class="p_add">+	kvm_for_each_memslot(memslot, slots)</span>
<span class="p_add">+		stage2_unmap_memslot(kvm, memslot);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+	srcu_read_unlock(&amp;kvm-&gt;srcu, idx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * kvm_free_stage2_pgd - free all stage-2 tables
  * @kvm:	The KVM struct pointer for the VM.
<span class="p_chunk">@@ -572,7 +649,7 @@</span> <span class="p_context"> static pmd_t *stage2_get_pmd(struct kvm *kvm, struct kvm_mmu_memory_cache *cache</span>
 	pud_t *pud;
 	pmd_t *pmd;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	pud = pud_offset(pgd, addr);
 	if (pud_none(*pud)) {
 		if (!cache)
<span class="p_chunk">@@ -735,6 +812,19 @@</span> <span class="p_context"> static bool transparent_hugepage_adjust(pfn_t *pfnp, phys_addr_t *ipap)</span>
 	return false;
 }
 
<span class="p_add">+static bool kvm_is_write_fault(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (kvm_vcpu_trap_is_iabt(vcpu))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return kvm_vcpu_dabt_iswrite(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !pfn_valid(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,
 			  struct kvm_memory_slot *memslot,
 			  unsigned long fault_status)
<span class="p_chunk">@@ -748,8 +838,9 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 	struct kvm_mmu_memory_cache *memcache = &amp;vcpu-&gt;arch.mmu_page_cache;
 	struct vm_area_struct *vma;
 	pfn_t pfn;
<span class="p_add">+	pgprot_t mem_type = PAGE_S2;</span>
 
<span class="p_del">-	write_fault = kvm_is_write_fault(kvm_vcpu_get_hsr(vcpu));</span>
<span class="p_add">+	write_fault = kvm_is_write_fault(vcpu);</span>
 	if (fault_status == FSC_PERM &amp;&amp; !write_fault) {
 		kvm_err(&quot;Unexpected L2 read permission error\n&quot;);
 		return -EFAULT;
<span class="p_chunk">@@ -758,6 +849,12 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 	/* Let&#39;s check if we will get back a huge page backed by hugetlbfs */
 	down_read(&amp;current-&gt;mm-&gt;mmap_sem);
 	vma = find_vma_intersection(current-&gt;mm, hva, hva + 1);
<span class="p_add">+	if (unlikely(!vma)) {</span>
<span class="p_add">+		kvm_err(&quot;Failed to find VMA for hva 0x%lx\n&quot;, hva);</span>
<span class="p_add">+		up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (is_vm_hugetlb_page(vma)) {
 		hugetlb = true;
 		gfn = (fault_ipa &amp; PMD_MASK) &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -798,6 +895,9 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 	if (is_error_pfn(pfn))
 		return -EFAULT;
 
<span class="p_add">+	if (kvm_is_device_pfn(pfn))</span>
<span class="p_add">+		mem_type = PAGE_S2_DEVICE;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;kvm-&gt;mmu_lock);
 	if (mmu_notifier_retry(kvm, mmu_seq))
 		goto out_unlock;
<span class="p_chunk">@@ -805,7 +905,7 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 		hugetlb = transparent_hugepage_adjust(&amp;pfn, &amp;fault_ipa);
 
 	if (hugetlb) {
<span class="p_del">-		pmd_t new_pmd = pfn_pmd(pfn, PAGE_S2);</span>
<span class="p_add">+		pmd_t new_pmd = pfn_pmd(pfn, mem_type);</span>
 		new_pmd = pmd_mkhuge(new_pmd);
 		if (writable) {
 			kvm_set_s2pmd_writable(&amp;new_pmd);
<span class="p_chunk">@@ -814,13 +914,14 @@</span> <span class="p_context"> static int user_mem_abort(struct kvm_vcpu *vcpu, phys_addr_t fault_ipa,</span>
 		coherent_cache_guest_page(vcpu, hva &amp; PMD_MASK, PMD_SIZE);
 		ret = stage2_set_pmd_huge(kvm, memcache, fault_ipa, &amp;new_pmd);
 	} else {
<span class="p_del">-		pte_t new_pte = pfn_pte(pfn, PAGE_S2);</span>
<span class="p_add">+		pte_t new_pte = pfn_pte(pfn, mem_type);</span>
 		if (writable) {
 			kvm_set_s2pte_writable(&amp;new_pte);
 			kvm_set_pfn_dirty(pfn);
 		}
 		coherent_cache_guest_page(vcpu, hva, PAGE_SIZE);
<span class="p_del">-		ret = stage2_set_pte(kvm, memcache, fault_ipa, &amp;new_pte, false);</span>
<span class="p_add">+		ret = stage2_set_pte(kvm, memcache, fault_ipa, &amp;new_pte,</span>
<span class="p_add">+			pgprot_val(mem_type) == pgprot_val(PAGE_S2_DEVICE));</span>
 	}
 
 
<span class="p_chunk">@@ -896,6 +997,9 @@</span> <span class="p_context"> int kvm_handle_guest_abort(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 
 	memslot = gfn_to_memslot(vcpu-&gt;kvm, gfn);
 
<span class="p_add">+	/* Userspace should not be able to register out-of-bounds IPAs */</span>
<span class="p_add">+	VM_BUG_ON(fault_ipa &gt;= KVM_PHYS_SIZE);</span>
<span class="p_add">+</span>
 	ret = user_mem_abort(vcpu, fault_ipa, memslot, fault_status);
 	if (ret == 0)
 		ret = 1;
<span class="p_chunk">@@ -1100,3 +1204,57 @@</span> <span class="p_context"> out:</span>
 	free_hyp_pgds();
 	return err;
 }
<span class="p_add">+</span>
<span class="p_add">+void kvm_arch_commit_memory_region(struct kvm *kvm,</span>
<span class="p_add">+				   struct kvm_userspace_memory_region *mem,</span>
<span class="p_add">+				   const struct kvm_memory_slot *old,</span>
<span class="p_add">+				   enum kvm_mr_change change)</span>
<span class="p_add">+{</span>
<span class="p_add">+	gpa_t gpa = old-&gt;base_gfn &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	phys_addr_t size = old-&gt;npages &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	if (change == KVM_MR_DELETE || change == KVM_MR_MOVE) {</span>
<span class="p_add">+		spin_lock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+		unmap_stage2_range(kvm, gpa, size);</span>
<span class="p_add">+		spin_unlock(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
<span class="p_add">+				   struct kvm_memory_slot *memslot,</span>
<span class="p_add">+				   struct kvm_userspace_memory_region *mem,</span>
<span class="p_add">+				   enum kvm_mr_change change)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent userspace from creating a memory region outside of the IPA</span>
<span class="p_add">+	 * space addressable by the KVM guest IPA space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (memslot-&gt;base_gfn + memslot-&gt;npages &gt;=</span>
<span class="p_add">+	    (KVM_PHYS_SIZE &gt;&gt; PAGE_SHIFT))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void kvm_arch_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,</span>
<span class="p_add">+			   struct kvm_memory_slot *dont)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int kvm_arch_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,</span>
<span class="p_add">+			    unsigned long npages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void kvm_arch_memslots_updated(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void kvm_arch_flush_shadow_all(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void kvm_arch_flush_shadow_memslot(struct kvm *kvm,</span>
<span class="p_add">+				   struct kvm_memory_slot *slot)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm-regbits-34xx.h b/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_header">index cbefbd7cfdb5..661d753df584 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"></span>
 #define OMAP3430_VC_CMD_ONLP_SHIFT			16
 #define OMAP3430_VC_CMD_RET_SHIFT			8
 #define OMAP3430_VC_CMD_OFF_SHIFT			0
<span class="p_add">+#define OMAP3430_SREN_MASK				(1 &lt;&lt; 4)</span>
 #define OMAP3430_HSEN_MASK				(1 &lt;&lt; 3)
 #define OMAP3430_MCODE_MASK				(0x7 &lt;&lt; 0)
 #define OMAP3430_VALID_MASK				(1 &lt;&lt; 24)
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm-regbits-44xx.h b/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_header">index b1c7a33e00e7..e794828dee55 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #define OMAP4430_GLOBAL_WARM_SW_RST_SHIFT				1
 #define OMAP4430_GLOBAL_WUEN_MASK					(1 &lt;&lt; 16)
 #define OMAP4430_HSMCODE_MASK						(0x7 &lt;&lt; 0)
<span class="p_add">+#define OMAP4430_SRMODEEN_MASK						(1 &lt;&lt; 4)</span>
 #define OMAP4430_HSMODEEN_MASK						(1 &lt;&lt; 3)
 #define OMAP4430_HSSCLL_SHIFT						24
 #define OMAP4430_ICEPICK_RST_SHIFT					9
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">index a4628a9e760c..b36db175d4a5 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.c</span>
<span class="p_chunk">@@ -316,7 +316,8 @@</span> <span class="p_context"> static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)</span>
 	 * idle. And we can also scale voltages to zero for off-idle.
 	 * Note that no actual voltage scaling during off-idle will
 	 * happen unless the board specific twl4030 PMIC scripts are
<span class="p_del">-	 * loaded.</span>
<span class="p_add">+	 * loaded. See also omap_vc_i2c_init for comments regarding</span>
<span class="p_add">+	 * erratum i531.</span>
 	 */
 	val = voltdm-&gt;read(OMAP3_PRM_VOLTCTRL_OFFSET);
 	if (!(val &amp; OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
<span class="p_chunk">@@ -704,9 +705,16 @@</span> <span class="p_context"> static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that for omap3 OMAP3430_SREN_MASK clears SREN to work around</span>
<span class="p_add">+	 * erratum i531 &quot;Extra Power Consumed When Repeated Start Operation</span>
<span class="p_add">+	 * Mode Is Enabled on I2C Interface Dedicated for Smart Reflex (I2C4)&quot;.</span>
<span class="p_add">+	 * Otherwise I2C4 eventually leads into about 23mW extra power being</span>
<span class="p_add">+	 * consumed even during off idle using VMODE.</span>
<span class="p_add">+	 */</span>
 	i2c_high_speed = voltdm-&gt;pmic-&gt;i2c_high_speed;
 	if (i2c_high_speed)
<span class="p_del">-		voltdm-&gt;rmw(vc-&gt;common-&gt;i2c_cfg_hsen_mask,</span>
<span class="p_add">+		voltdm-&gt;rmw(vc-&gt;common-&gt;i2c_cfg_clear_mask,</span>
 			    vc-&gt;common-&gt;i2c_cfg_hsen_mask,
 			    vc-&gt;common-&gt;i2c_cfg_reg);
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.h b/arch/arm/mach-omap2/vc.h</span>
<span class="p_header">index cdbdd78e755e..89b83b7ff3ec 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.h</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"> struct voltagedomain;</span>
  * @cmd_ret_shift: RET field shift in PRM_VC_CMD_VAL_* register
  * @cmd_off_shift: OFF field shift in PRM_VC_CMD_VAL_* register
  * @i2c_cfg_reg: I2C configuration register offset
<span class="p_add">+ * @i2c_cfg_clear_mask: high-speed mode bit clear mask in I2C config register</span>
  * @i2c_cfg_hsen_mask: high-speed mode bit field mask in I2C config register
  * @i2c_mcode_mask: MCODE field mask for I2C config register
  *
<span class="p_chunk">@@ -52,6 +53,7 @@</span> <span class="p_context"> struct omap_vc_common {</span>
 	u8 cmd_ret_shift;
 	u8 cmd_off_shift;
 	u8 i2c_cfg_reg;
<span class="p_add">+	u8 i2c_cfg_clear_mask;</span>
 	u8 i2c_cfg_hsen_mask;
 	u8 i2c_mcode_mask;
 };
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc3xxx_data.c b/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_header">index 75bc4aa22b3a..71d74c9172c1 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"> static struct omap_vc_common omap3_vc_common = {</span>
 	.cmd_onlp_shift	 = OMAP3430_VC_CMD_ONLP_SHIFT,
 	.cmd_ret_shift	 = OMAP3430_VC_CMD_RET_SHIFT,
 	.cmd_off_shift	 = OMAP3430_VC_CMD_OFF_SHIFT,
<span class="p_add">+	.i2c_cfg_clear_mask = OMAP3430_SREN_MASK | OMAP3430_HSEN_MASK,</span>
 	.i2c_cfg_hsen_mask = OMAP3430_HSEN_MASK,
 	.i2c_cfg_reg	 = OMAP3_PRM_VC_I2C_CFG_OFFSET,
 	.i2c_mcode_mask	 = OMAP3430_MCODE_MASK,
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc44xx_data.c b/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_header">index 085e5d6a04fd..2abd5fa8a697 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> static const struct omap_vc_common omap4_vc_common = {</span>
 	.cmd_ret_shift = OMAP4430_RET_SHIFT,
 	.cmd_off_shift = OMAP4430_OFF_SHIFT,
 	.i2c_cfg_reg = OMAP4_PRM_VC_CFG_I2C_MODE_OFFSET,
<span class="p_add">+	.i2c_cfg_clear_mask = OMAP4430_SRMODEEN_MASK | OMAP4430_HSMODEEN_MASK,</span>
 	.i2c_cfg_hsen_mask = OMAP4430_HSMODEEN_MASK,
 	.i2c_mcode_mask	 = OMAP4430_HSMCODE_MASK,
 };
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_arm.h b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">index 3d6903006a8a..c33a96bac824 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_arm.h</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #ifndef __ARM64_KVM_ARM_H__
 #define __ARM64_KVM_ARM_H__
 
<span class="p_add">+#include &lt;asm/memory.h&gt;</span>
 #include &lt;asm/types.h&gt;
 
 /* Hyp Configuration Register (HCR) bits */
<span class="p_chunk">@@ -121,6 +122,17 @@</span> <span class="p_context"></span>
 #define VTCR_EL2_T0SZ_MASK	0x3f
 #define VTCR_EL2_T0SZ_40B	24
 
<span class="p_add">+/*</span>
<span class="p_add">+ * We configure the Stage-2 page tables to always restrict the IPA space to be</span>
<span class="p_add">+ * 40 bits wide (T0SZ = 24).  Systems with a PARange smaller than 40 bits are</span>
<span class="p_add">+ * not known to exist and will break with this configuration.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that when using 4K pages, we concatenate two first level page tables</span>
<span class="p_add">+ * together.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The magic numbers used for VTTBR_X in this patch can be found in Tables</span>
<span class="p_add">+ * D4-23 and D4-25 in ARM DDI 0487A.b.</span>
<span class="p_add">+ */</span>
 #ifdef CONFIG_ARM64_64K_PAGES
 /*
  * Stage2 translation configuration:
<span class="p_chunk">@@ -148,9 +160,9 @@</span> <span class="p_context"></span>
 #endif
 
 #define VTTBR_BADDR_SHIFT (VTTBR_X - 1)
<span class="p_del">-#define VTTBR_BADDR_MASK  (((1LLU &lt;&lt; (40 - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_del">-#define VTTBR_VMID_SHIFT  (48LLU)</span>
<span class="p_del">-#define VTTBR_VMID_MASK	  (0xffLLU &lt;&lt; VTTBR_VMID_SHIFT)</span>
<span class="p_add">+#define VTTBR_BADDR_MASK  (((UL(1) &lt;&lt; (PHYS_MASK_SHIFT - VTTBR_X)) - 1) &lt;&lt; VTTBR_BADDR_SHIFT)</span>
<span class="p_add">+#define VTTBR_VMID_SHIFT  (UL(48))</span>
<span class="p_add">+#define VTTBR_VMID_MASK	  (UL(0xFF) &lt;&lt; VTTBR_VMID_SHIFT)</span>
 
 /* Hyp System Trap Register */
 #define HSTR_EL2_TTEE	(1 &lt;&lt; 16)
<span class="p_chunk">@@ -173,13 +185,13 @@</span> <span class="p_context"></span>
 
 /* Exception Syndrome Register (ESR) bits */
 #define ESR_EL2_EC_SHIFT	(26)
<span class="p_del">-#define ESR_EL2_EC		(0x3fU &lt;&lt; ESR_EL2_EC_SHIFT)</span>
<span class="p_del">-#define ESR_EL2_IL		(1U &lt;&lt; 25)</span>
<span class="p_add">+#define ESR_EL2_EC		(UL(0x3f) &lt;&lt; ESR_EL2_EC_SHIFT)</span>
<span class="p_add">+#define ESR_EL2_IL		(UL(1) &lt;&lt; 25)</span>
 #define ESR_EL2_ISS		(ESR_EL2_IL - 1)
 #define ESR_EL2_ISV_SHIFT	(24)
<span class="p_del">-#define ESR_EL2_ISV		(1U &lt;&lt; ESR_EL2_ISV_SHIFT)</span>
<span class="p_add">+#define ESR_EL2_ISV		(UL(1) &lt;&lt; ESR_EL2_ISV_SHIFT)</span>
 #define ESR_EL2_SAS_SHIFT	(22)
<span class="p_del">-#define ESR_EL2_SAS		(3U &lt;&lt; ESR_EL2_SAS_SHIFT)</span>
<span class="p_add">+#define ESR_EL2_SAS		(UL(3) &lt;&lt; ESR_EL2_SAS_SHIFT)</span>
 #define ESR_EL2_SSE		(1 &lt;&lt; 21)
 #define ESR_EL2_SRT_SHIFT	(16)
 #define ESR_EL2_SRT_MASK	(0x1f &lt;&lt; ESR_EL2_SRT_SHIFT)
<span class="p_chunk">@@ -193,16 +205,16 @@</span> <span class="p_context"></span>
 #define ESR_EL2_FSC_TYPE	(0x3c)
 
 #define ESR_EL2_CV_SHIFT	(24)
<span class="p_del">-#define ESR_EL2_CV		(1U &lt;&lt; ESR_EL2_CV_SHIFT)</span>
<span class="p_add">+#define ESR_EL2_CV		(UL(1) &lt;&lt; ESR_EL2_CV_SHIFT)</span>
 #define ESR_EL2_COND_SHIFT	(20)
<span class="p_del">-#define ESR_EL2_COND		(0xfU &lt;&lt; ESR_EL2_COND_SHIFT)</span>
<span class="p_add">+#define ESR_EL2_COND		(UL(0xf) &lt;&lt; ESR_EL2_COND_SHIFT)</span>
 
 
 #define FSC_FAULT	(0x04)
 #define FSC_PERM	(0x0c)
 
 /* Hyp Prefetch Fault Address Register (HPFAR/HDFAR) */
<span class="p_del">-#define HPFAR_MASK	(~0xFUL)</span>
<span class="p_add">+#define HPFAR_MASK	(~UL(0xf))</span>
 
 #define ESR_EL2_EC_UNKNOWN	(0x00)
 #define ESR_EL2_EC_WFI		(0x01)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index dd8ecfc3f995..91f33c2051f2 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -38,6 +38,13 @@</span> <span class="p_context"> void kvm_inject_undefined(struct kvm_vcpu *vcpu);</span>
 void kvm_inject_dabt(struct kvm_vcpu *vcpu, unsigned long addr);
 void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr);
 
<span class="p_add">+static inline void vcpu_reset_hcr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu-&gt;arch.hcr_el2 = HCR_GUEST_FLAGS;</span>
<span class="p_add">+	if (test_bit(KVM_ARM_VCPU_EL1_32BIT, vcpu-&gt;arch.features))</span>
<span class="p_add">+		vcpu-&gt;arch.hcr_el2 &amp;= ~HCR_RW;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long *vcpu_pc(const struct kvm_vcpu *vcpu)
 {
 	return (unsigned long *)&amp;vcpu_gp_regs(vcpu)-&gt;regs.pc;
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_header">index 92242ce06309..fb6075dfac5b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"></span>
 #define KVM_VCPU_MAX_FEATURES 3
 
 struct kvm_vcpu;
<span class="p_del">-int kvm_target_cpu(void);</span>
<span class="p_add">+int __attribute_const__ kvm_target_cpu(void);</span>
 int kvm_reset_vcpu(struct kvm_vcpu *vcpu);
 int kvm_arch_dev_ioctl_check_extension(long ext);
 
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> static inline int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)</span>
 }
 
 struct kvm_vcpu *kvm_arm_get_running_vcpu(void);
<span class="p_del">-struct kvm_vcpu __percpu **kvm_get_running_vcpus(void);</span>
<span class="p_add">+struct kvm_vcpu * __percpu *kvm_get_running_vcpus(void);</span>
 
 u64 kvm_call_hyp(void *hypfn, ...);
 
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 7d29847a893b..2067f4b75d13 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -59,10 +59,9 @@</span> <span class="p_context"></span>
 #define KERN_TO_HYP(kva)	((unsigned long)kva - PAGE_OFFSET + HYP_PAGE_OFFSET)
 
 /*
<span class="p_del">- * Align KVM with the kernel&#39;s view of physical memory. Should be</span>
<span class="p_del">- * 40bit IPA, with PGD being 8kB aligned in the 4KB page configuration.</span>
<span class="p_add">+ * We currently only support a 40bit IPA.</span>
  */
<span class="p_del">-#define KVM_PHYS_SHIFT	PHYS_MASK_SHIFT</span>
<span class="p_add">+#define KVM_PHYS_SHIFT	(40)</span>
 #define KVM_PHYS_SIZE	(1UL &lt;&lt; KVM_PHYS_SHIFT)
 #define KVM_PHYS_MASK	(KVM_PHYS_SIZE - 1UL)
 
<span class="p_chunk">@@ -70,11 +69,14 @@</span> <span class="p_context"></span>
 #define PTRS_PER_S2_PGD (1 &lt;&lt; (KVM_PHYS_SHIFT - PGDIR_SHIFT))
 #define S2_PGD_ORDER	get_order(PTRS_PER_S2_PGD * sizeof(pgd_t))
 
<span class="p_add">+#define kvm_pgd_index(addr)	(((addr) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_S2_PGD - 1))</span>
<span class="p_add">+</span>
 int create_hyp_mappings(void *from, void *to);
 int create_hyp_io_mappings(void *from, void *to, phys_addr_t);
 void free_boot_hyp_pgd(void);
 void free_hyp_pgds(void);
 
<span class="p_add">+void stage2_unmap_vm(struct kvm *kvm);</span>
 int kvm_alloc_stage2_pgd(struct kvm *kvm);
 void kvm_free_stage2_pgd(struct kvm *kvm);
 int kvm_phys_addr_ioremap(struct kvm *kvm, phys_addr_t guest_ipa,
<span class="p_chunk">@@ -93,19 +95,6 @@</span> <span class="p_context"> void kvm_clear_hyp_idmap(void);</span>
 #define	kvm_set_pte(ptep, pte)		set_pte(ptep, pte)
 #define	kvm_set_pmd(pmdp, pmd)		set_pmd(pmdp, pmd)
 
<span class="p_del">-static inline bool kvm_is_write_fault(unsigned long esr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long esr_ec = esr &gt;&gt; ESR_EL2_EC_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (esr_ec == ESR_EL2_EC_IABT)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((esr &amp; ESR_EL2_ISV) &amp;&amp; !(esr &amp; ESR_EL2_WNR))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void kvm_clean_pgd(pgd_t *pgd) {}
 static inline void kvm_clean_pmd_entry(pmd_t *pmd) {}
 static inline void kvm_clean_pte(pte_t *pte) {}
<span class="p_chunk">@@ -125,6 +114,21 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 #define kvm_pud_addr_end(addr, end)	pud_addr_end(addr, end)
 #define kvm_pmd_addr_end(addr, end)	pmd_addr_end(addr, end)
 
<span class="p_add">+static inline bool kvm_page_empty(void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *ptr_page = virt_to_page(ptr);</span>
<span class="p_add">+	return page_count(ptr_page) == 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define kvm_pte_table_empty(ptep) kvm_page_empty(ptep)</span>
<span class="p_add">+#ifndef CONFIG_ARM64_64K_PAGES</span>
<span class="p_add">+#define kvm_pmd_table_empty(pmdp) kvm_page_empty(pmdp)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define kvm_pmd_table_empty(pmdp) (0)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#define kvm_pud_table_empty(pudp) (0)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 struct kvm;
 
 #define kvm_flush_dcache_to_poc(a,l)	__flush_dcache_area((a), (l))
<span class="p_header">diff --git a/arch/arm64/kvm/guest.c b/arch/arm64/kvm/guest.c</span>
<span class="p_header">index 60b5c31f3c10..3e610f60f031 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/guest.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/guest.c</span>
<span class="p_chunk">@@ -38,7 +38,6 @@</span> <span class="p_context"> struct kvm_stats_debugfs_item debugfs_entries[] = {</span>
 
 int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	vcpu-&gt;arch.hcr_el2 = HCR_GUEST_FLAGS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm64/kvm/hyp.S b/arch/arm64/kvm/hyp.S</span>
<span class="p_header">index b0d1512acf08..3aaf3bc4ad8a 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp.S</span>
<span class="p_chunk">@@ -629,6 +629,7 @@</span> <span class="p_context"> ENTRY(__kvm_tlb_flush_vmid_ipa)</span>
 	 * Instead, we invalidate Stage-2 for this IPA, and the
 	 * whole of Stage-1. Weep...
 	 */
<span class="p_add">+	lsr	x1, x1, #12</span>
 	tlbi	ipas2e1is, x1
 	/*
 	 * We have to ensure completion of the invalidation at Stage-2,
<span class="p_chunk">@@ -830,7 +831,7 @@</span> <span class="p_context"> el1_trap:</span>
 	mrs	x2, far_el2
 
 2:	mrs	x0, tpidr_el2
<span class="p_del">-	str	x1, [x0, #VCPU_ESR_EL2]</span>
<span class="p_add">+	str	w1, [x0, #VCPU_ESR_EL2]</span>
 	str	x2, [x0, #VCPU_FAR_EL2]
 	str	x3, [x0, #VCPU_HPFAR_EL2]
 
<span class="p_header">diff --git a/arch/arm64/kvm/reset.c b/arch/arm64/kvm/reset.c</span>
<span class="p_header">index 70a7816535cd..0b4326578985 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/reset.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/reset.c</span>
<span class="p_chunk">@@ -90,7 +90,6 @@</span> <span class="p_context"> int kvm_reset_vcpu(struct kvm_vcpu *vcpu)</span>
 			if (!cpu_has_32bit_el1())
 				return -EINVAL;
 			cpu_reset = &amp;default_regs_reset32;
<span class="p_del">-			vcpu-&gt;arch.hcr_el2 &amp;= ~HCR_RW;</span>
 		} else {
 			cpu_reset = &amp;default_regs_reset;
 		}
<span class="p_header">diff --git a/arch/arm64/kvm/sys_regs.c b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">index c59a1bdab5eb..444e8edd71b2 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_chunk">@@ -836,7 +836,7 @@</span> <span class="p_context"> static bool is_valid_cache(u32 val)</span>
 	u32 level, ctype;
 
 	if (val &gt;= CSSELR_MAX)
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+		return false;</span>
 
 	/* Bottom bit is Instruction or Data bit.  Next 3 bits are level. */
 	level = (val &gt;&gt; 1);
<span class="p_chunk">@@ -962,7 +962,7 @@</span> <span class="p_context"> static unsigned int num_demux_regs(void)</span>
 
 static int write_demux_regids(u64 __user *uindices)
 {
<span class="p_del">-	u64 val = KVM_REG_ARM | KVM_REG_SIZE_U32 | KVM_REG_ARM_DEMUX;</span>
<span class="p_add">+	u64 val = KVM_REG_ARM64 | KVM_REG_SIZE_U32 | KVM_REG_ARM_DEMUX;</span>
 	unsigned int i;
 
 	val |= KVM_REG_ARM_DEMUX_ID_CCSIDR;
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index de3abbe6c59f..893802645efe 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -65,8 +65,7 @@</span> <span class="p_context"> static void *__dma_alloc_coherent(struct device *dev, size_t size,</span>
 
 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		addr = page_address(page);
<span class="p_del">-		if (flags &amp; __GFP_ZERO)</span>
<span class="p_del">-			memset(addr, 0, size);</span>
<span class="p_add">+		memset(addr, 0, size);</span>
 		return addr;
 	} else {
 		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);
<span class="p_header">diff --git a/arch/arm64/mm/mmap.c b/arch/arm64/mm/mmap.c</span>
<span class="p_header">index 8ed6cb1a900f..8f7ffffc63e9 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmap.c</span>
<span class="p_chunk">@@ -47,22 +47,14 @@</span> <span class="p_context"> static int mmap_is_legacy(void)</span>
 	return sysctl_legacy_va_layout;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Since get_random_int() returns the same value within a 1 jiffy window, we</span>
<span class="p_del">- * will almost always get the same randomisation for the stack and mmap</span>
<span class="p_del">- * region. This will mean the relative distance between stack and mmap will be</span>
<span class="p_del">- * the same.</span>
<span class="p_del">- *</span>
<span class="p_del">- * To avoid this we can shift the randomness by 1 bit.</span>
<span class="p_del">- */</span>
 static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
 	if (current-&gt;flags &amp; PF_RANDOMIZE)
<span class="p_del">-		rnd = (long)get_random_int() &amp; (STACK_RND_MASK &gt;&gt; 1);</span>
<span class="p_add">+		rnd = (long)get_random_int() &amp; STACK_RND_MASK;</span>
 
<span class="p_del">-	return rnd &lt;&lt; (PAGE_SHIFT + 1);</span>
<span class="p_add">+	return rnd &lt;&lt; PAGE_SHIFT;</span>
 }
 
 static unsigned long mmap_base(void)
<span class="p_header">diff --git a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c</span>
<span class="p_header">index 55d4ba47a907..deed6fa96bb0 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/process.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/process.c</span>
<span class="p_chunk">@@ -662,7 +662,7 @@</span> <span class="p_context"> void</span>
 machine_restart (char *restart_cmd)
 {
 	(void) notify_die(DIE_MACHINE_RESTART, restart_cmd, NULL, 0, 0, 0);
<span class="p_del">-	(*efi.reset_system)(EFI_RESET_WARM, 0, 0, NULL);</span>
<span class="p_add">+	efi_reboot(REBOOT_WARM, NULL);</span>
 }
 
 void
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index c89787d43dd1..06685498b681 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -407,6 +407,10 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 	if (rc)
 		return -EINVAL;
 
<span class="p_add">+	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	parent = of_find_node_by_path(&quot;/cpus&quot;);
 	if (!parent)
 		return -ENODEV;
<span class="p_chunk">@@ -417,12 +421,6 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 
 	of_node_put(parent);
 
<span class="p_del">-	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		dlpar_free_cc_nodes(dn);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 0331d765c2bb..bfb3908493f8 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1091,6 +1091,8 @@</span> <span class="p_context"> struct boot_params *make_boot_params(struct efi_config *c)</span>
 	if (!cmdline_ptr)
 		goto fail;
 	hdr-&gt;cmd_line_ptr = (unsigned long)cmdline_ptr;
<span class="p_add">+	/* Fill in upper bits of command line address, NOP on 32 bit  */</span>
<span class="p_add">+	boot_params-&gt;ext_cmd_line_ptr = (u64)(unsigned long)cmdline_ptr &gt;&gt; 32;</span>
 
 	hdr-&gt;ramdisk_image = 0;
 	hdr-&gt;ramdisk_size = 0;
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 1eb5f6433ad8..81396a9a9277 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -156,6 +156,9 @@</span> <span class="p_context"> static inline efi_status_t efi_thunk_set_virtual_address_map(</span>
 	return EFI_SUCCESS;
 }
 #endif /* CONFIG_EFI_MIXED */
<span class="p_add">+</span>
<span class="p_add">+extern bool efi_reboot_required(void);</span>
<span class="p_add">+</span>
 #else
 /*
  * IF EFI is not configured, have the EFI calls return -ENOSYS.
<span class="p_chunk">@@ -168,6 +171,10 @@</span> <span class="p_context"> static inline efi_status_t efi_thunk_set_virtual_address_map(</span>
 #define efi_call5(_f, _a1, _a2, _a3, _a4, _a5)		(-ENOSYS)
 #define efi_call6(_f, _a1, _a2, _a3, _a4, _a5, _a6)	(-ENOSYS)
 static inline void parse_efi_setup(u64 phys_addr, u32 data_len) {}
<span class="p_add">+static inline bool efi_reboot_required(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_EFI */
 
 #endif /* _ASM_X86_EFI_H */
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index f319bfea154e..587be13be0be 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mc146818rtc.h&gt;
 #include &lt;asm/realmode.h&gt;
 #include &lt;asm/x86_init.h&gt;
<span class="p_add">+#include &lt;asm/efi.h&gt;</span>
 
 /*
  * Power off function, if any
<span class="p_chunk">@@ -411,12 +412,25 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 
 static int __init reboot_init(void)
 {
<span class="p_add">+	int rv;</span>
<span class="p_add">+</span>
 	/*
 	 * Only do the DMI check if reboot_type hasn&#39;t been overridden
 	 * on the command line
 	 */
<span class="p_del">-	if (reboot_default)</span>
<span class="p_del">-		dmi_check_system(reboot_dmi_table);</span>
<span class="p_add">+	if (!reboot_default)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The DMI quirks table takes precedence. If no quirks entry</span>
<span class="p_add">+	 * matches and the ACPI Hardware Reduced bit is set, force EFI</span>
<span class="p_add">+	 * reboot.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rv = dmi_check_system(reboot_dmi_table);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rv &amp;&amp; efi_reboot_required())</span>
<span class="p_add">+		reboot_type = BOOT_EFI;</span>
<span class="p_add">+</span>
 	return 0;
 }
 core_initcall(reboot_init);
<span class="p_chunk">@@ -538,11 +552,7 @@</span> <span class="p_context"> static void native_machine_emergency_restart(void)</span>
 			break;
 
 		case BOOT_EFI:
<span class="p_del">-			if (efi_enabled(EFI_RUNTIME_SERVICES))</span>
<span class="p_del">-				efi.reset_system(reboot_mode == REBOOT_WARM ?</span>
<span class="p_del">-						 EFI_RESET_WARM :</span>
<span class="p_del">-						 EFI_RESET_COLD,</span>
<span class="p_del">-						 EFI_SUCCESS, 0, NULL);</span>
<span class="p_add">+			efi_reboot(reboot_mode, NULL);</span>
 			reboot_type = BOOT_BIOS;
 			break;
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 87fc96bcc13c..53a324606d11 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/io.h&gt;
 #include &lt;linux/reboot.h&gt;
 #include &lt;linux/bcd.h&gt;
<span class="p_add">+#include &lt;linux/acpi.h&gt;</span>
 
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/efi.h&gt;
<span class="p_chunk">@@ -1340,3 +1341,25 @@</span> <span class="p_context"> void __init efi_apply_memmap_quirks(void)</span>
 	if (is_uv_system())
 		set_bit(EFI_OLD_MEMMAP, &amp;efi.flags);
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * For most modern platforms the preferred method of powering off is via</span>
<span class="p_add">+ * ACPI. However, there are some that are known to require the use of</span>
<span class="p_add">+ * EFI runtime services and for which ACPI does not work at all.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Using EFI is a last resort, to be used only if no other option</span>
<span class="p_add">+ * exists.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool efi_reboot_required(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!acpi_gbl_reduced_hardware)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	efi_reboot_quirk_mode = EFI_RESET_WARM;</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool efi_poweroff_required(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !!acpi_gbl_reduced_hardware;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 06ac59f5bb5a..50dd29bc4972 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -1503,22 +1503,6 @@</span> <span class="p_context"> static int blk_mq_hctx_cpu_offline(struct blk_mq_hw_ctx *hctx, int cpu)</span>
 	return NOTIFY_OK;
 }
 
<span class="p_del">-static int blk_mq_hctx_cpu_online(struct blk_mq_hw_ctx *hctx, int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct request_queue *q = hctx-&gt;queue;</span>
<span class="p_del">-	struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (set-&gt;tags[hctx-&gt;queue_num])</span>
<span class="p_del">-		return NOTIFY_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-	set-&gt;tags[hctx-&gt;queue_num] = blk_mq_init_rq_map(set, hctx-&gt;queue_num);</span>
<span class="p_del">-	if (!set-&gt;tags[hctx-&gt;queue_num])</span>
<span class="p_del">-		return NOTIFY_STOP;</span>
<span class="p_del">-</span>
<span class="p_del">-	hctx-&gt;tags = set-&gt;tags[hctx-&gt;queue_num];</span>
<span class="p_del">-	return NOTIFY_OK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int blk_mq_hctx_notify(void *data, unsigned long action,
 			      unsigned int cpu)
 {
<span class="p_chunk">@@ -1526,8 +1510,11 @@</span> <span class="p_context"> static int blk_mq_hctx_notify(void *data, unsigned long action,</span>
 
 	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
 		return blk_mq_hctx_cpu_offline(hctx, cpu);
<span class="p_del">-	else if (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)</span>
<span class="p_del">-		return blk_mq_hctx_cpu_online(hctx, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of CPU online, tags may be reallocated</span>
<span class="p_add">+	 * in blk_mq_map_swqueue() after mapping is updated.</span>
<span class="p_add">+	 */</span>
 
 	return NOTIFY_OK;
 }
<span class="p_chunk">@@ -1664,6 +1651,7 @@</span> <span class="p_context"> static void blk_mq_map_swqueue(struct request_queue *q)</span>
 	unsigned int i;
 	struct blk_mq_hw_ctx *hctx;
 	struct blk_mq_ctx *ctx;
<span class="p_add">+	struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
 
 	queue_for_each_hw_ctx(q, hctx, i) {
 		cpumask_clear(hctx-&gt;cpumask);
<span class="p_chunk">@@ -1690,16 +1678,20 @@</span> <span class="p_context"> static void blk_mq_map_swqueue(struct request_queue *q)</span>
 		 * disable it and free the request entries
 		 */
 		if (!hctx-&gt;nr_ctx) {
<span class="p_del">-			struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
<span class="p_del">-</span>
 			if (set-&gt;tags[i]) {
 				blk_mq_free_rq_map(set, set-&gt;tags[i], i);
 				set-&gt;tags[i] = NULL;
<span class="p_del">-				hctx-&gt;tags = NULL;</span>
 			}
<span class="p_add">+			hctx-&gt;tags = NULL;</span>
 			continue;
 		}
 
<span class="p_add">+		/* unmapped hw queue can be remapped after CPU topo changed */</span>
<span class="p_add">+		if (!set-&gt;tags[i])</span>
<span class="p_add">+			set-&gt;tags[i] = blk_mq_init_rq_map(set, i);</span>
<span class="p_add">+		hctx-&gt;tags = set-&gt;tags[i];</span>
<span class="p_add">+		WARN_ON(!hctx-&gt;tags);</span>
<span class="p_add">+</span>
 		/*
 		 * Initialize batch roundrobin counts
 		 */
<span class="p_header">diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">index 4ddb0dca56f6..fa13db682309 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_pnp.c</span>
<span class="p_chunk">@@ -309,6 +309,8 @@</span> <span class="p_context"> static const struct acpi_device_id acpi_pnp_device_ids[] = {</span>
 	{&quot;PNPb006&quot;},
 	/* cs423x-pnpbios */
 	{&quot;CSC0100&quot;},
<span class="p_add">+	{&quot;CSC0103&quot;},</span>
<span class="p_add">+	{&quot;CSC0110&quot;},</span>
 	{&quot;CSC0000&quot;},
 	{&quot;GIM0100&quot;},		/* Guillemot Turtlebeach something appears to be cs4232 compatible */
 	/* es18xx-pnpbios */
<span class="p_header">diff --git a/drivers/acpi/acpica/acmacros.h b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">index 4bceb11c7380..624cbb3b5683 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/acmacros.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/acmacros.h</span>
<span class="p_chunk">@@ -63,23 +63,12 @@</span> <span class="p_context"></span>
 #define ACPI_SET64(ptr, val)            (*ACPI_CAST64 (ptr) = (u64) (val))
 
 /*
<span class="p_del">- * printf() format helpers. These macros are workarounds for the difficulties</span>
<span class="p_add">+ * printf() format helper. This macros is a workaround for the difficulties</span>
  * with emitting 64-bit integers and 64-bit pointers with the same code
  * for both 32-bit and 64-bit hosts.
  */
 #define ACPI_FORMAT_UINT64(i)           ACPI_HIDWORD(i), ACPI_LODWORD(i)
 
<span class="p_del">-#if ACPI_MACHINE_WIDTH == 64</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      ACPI_FORMAT_UINT64(i)</span>
<span class="p_del">-#define ACPI_FORMAT_TO_UINT(i)          ACPI_FORMAT_UINT64(i)</span>
<span class="p_del">-#define ACPI_PRINTF_UINT                 &quot;0x%8.8X%8.8X&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define ACPI_FORMAT_NATIVE_UINT(i)      0, (u32) (i)</span>
<span class="p_del">-#define ACPI_FORMAT_TO_UINT(i)          (u32) (i)</span>
<span class="p_del">-#define ACPI_PRINTF_UINT                 &quot;0x%8.8X&quot;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * Macros for moving data around to/from buffers that are possibly unaligned.
  * If the hardware supports the transfer of unaligned data, just do the store.
<span class="p_header">diff --git a/drivers/acpi/acpica/dsopcode.c b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">index 6c0759c0db47..5e7c7c301c5c 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/dsopcode.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> acpi_ds_eval_region_operands(struct acpi_walk_state *walk_state,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_chunk">@@ -539,13 +539,12 @@</span> <span class="p_context"> acpi_ds_eval_table_region_operands(struct acpi_walk_state *walk_state,</span>
 		return_ACPI_STATUS(AE_NOT_EXIST);
 	}
 
<span class="p_del">-	obj_desc-&gt;region.address =</span>
<span class="p_del">-	    (acpi_physical_address) ACPI_TO_INTEGER(table);</span>
<span class="p_add">+	obj_desc-&gt;region.address = ACPI_PTR_TO_PHYSADDR(table);</span>
 	obj_desc-&gt;region.length = table-&gt;length;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC, &quot;RgnObj %p Addr %8.8X%8.8X Len %X\n&quot;,
 			  obj_desc,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(obj_desc-&gt;region.address),</span>
 			  obj_desc-&gt;region.length));
 
 	/* Now the address and length are valid for this opregion */
<span class="p_header">diff --git a/drivers/acpi/acpica/evregion.c b/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">index 8eb8575e8c16..9ce53980201c 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/evregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/evregion.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> acpi_ev_address_space_dispatch(union acpi_operand_object *region_obj,</span>
 	ACPI_DEBUG_PRINT((ACPI_DB_OPREGION,
 			  &quot;Handler %p (@%p) Address %8.8X%8.8X [%s]\n&quot;,
 			  &amp;region_obj-&gt;region.handler-&gt;address_space, handler,
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
 			  acpi_ut_get_region_name(region_obj-&gt;region.
 						  space_id)));
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exdump.c b/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">index 925202acc3e4..869692f12a64 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exdump.c</span>
<span class="p_chunk">@@ -767,8 +767,8 @@</span> <span class="p_context"> void acpi_ex_dump_operand(union acpi_operand_object *obj_desc, u32 depth)</span>
 			acpi_os_printf(&quot;\n&quot;);
 		} else {
 			acpi_os_printf(&quot; base %8.8X%8.8X Length %X\n&quot;,
<span class="p_del">-				       ACPI_FORMAT_NATIVE_UINT(obj_desc-&gt;region.</span>
<span class="p_del">-							       address),</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;region.</span>
<span class="p_add">+							  address),</span>
 				       obj_desc-&gt;region.length);
 		}
 		break;
<span class="p_header">diff --git a/drivers/acpi/acpica/exfldio.c b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">index 1d1b27a96c5b..58ea85e42bfc 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exfldio.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exfldio.c</span>
<span class="p_chunk">@@ -263,17 +263,15 @@</span> <span class="p_context"> acpi_ex_access_region(union acpi_operand_object *obj_desc,</span>
 	}
 
 	ACPI_DEBUG_PRINT_RAW((ACPI_DB_BFIELD,
<span class="p_del">-			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %p\n&quot;,</span>
<span class="p_add">+			      &quot; Region [%s:%X], Width %X, ByteBase %X, Offset %X at %8.8X%8.8X\n&quot;,</span>
 			      acpi_ut_get_region_name(rgn_desc-&gt;region.
 						      space_id),
 			      rgn_desc-&gt;region.space_id,
 			      obj_desc-&gt;common_field.access_byte_width,
 			      obj_desc-&gt;common_field.base_byte_offset,
<span class="p_del">-			      field_datum_byte_offset, ACPI_CAST_PTR(void,</span>
<span class="p_del">-								     (rgn_desc-&gt;</span>
<span class="p_del">-								      region.</span>
<span class="p_del">-								      address +</span>
<span class="p_del">-								      region_offset))));</span>
<span class="p_add">+			      field_datum_byte_offset,</span>
<span class="p_add">+			      ACPI_FORMAT_UINT64(rgn_desc-&gt;region.address +</span>
<span class="p_add">+						 region_offset)));</span>
 
 	/* Invoke the appropriate address_space/op_region handler */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/exregion.c b/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">index cd5288a257a9..be51d3ed4d0f 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/exregion.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/exregion.c</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 		if (!mem_info-&gt;mapped_logical_address) {
 			ACPI_ERROR((AE_INFO,
 				    &quot;Could not map memory at 0x%8.8X%8.8X, size %u&quot;,
<span class="p_del">-				    ACPI_FORMAT_NATIVE_UINT(address),</span>
<span class="p_add">+				    ACPI_FORMAT_UINT64(address),</span>
 				    (u32) map_length));
 			mem_info-&gt;mapped_length = 0;
 			return_ACPI_STATUS(AE_NO_MEMORY);
<span class="p_chunk">@@ -202,8 +202,7 @@</span> <span class="p_context"> acpi_ex_system_memory_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-Memory (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/*
 	 * Perform the memory read or write
<span class="p_chunk">@@ -318,8 +317,7 @@</span> <span class="p_context"> acpi_ex_system_io_space_handler(u32 function,</span>
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 			  &quot;System-IO (width %u) R/W %u Address=%8.8X%8.8X\n&quot;,
<span class="p_del">-			  bit_width, function,</span>
<span class="p_del">-			  ACPI_FORMAT_NATIVE_UINT(address)));</span>
<span class="p_add">+			  bit_width, function, ACPI_FORMAT_UINT64(address)));</span>
 
 	/* Decode the function parameter */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/hwvalid.c b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">index 6b919127cd9d..dabf754ea4a4 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/hwvalid.c</span>
<span class="p_chunk">@@ -142,17 +142,17 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 	byte_width = ACPI_DIV_8(bit_width);
 	last_address = address + byte_width - 1;
 
<span class="p_del">-	ACPI_DEBUG_PRINT((ACPI_DB_IO, &quot;Address %p LastAddress %p Length %X&quot;,</span>
<span class="p_del">-			  ACPI_CAST_PTR(void, address), ACPI_CAST_PTR(void,</span>
<span class="p_del">-								      last_address),</span>
<span class="p_del">-			  byte_width));</span>
<span class="p_add">+	ACPI_DEBUG_PRINT((ACPI_DB_IO,</span>
<span class="p_add">+			  &quot;Address %8.8X%8.8X LastAddress %8.8X%8.8X Length %X&quot;,</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(last_address), byte_width));</span>
 
 	/* Maximum 16-bit address in I/O space */
 
 	if (last_address &gt; ACPI_UINT16_MAX) {
 		ACPI_ERROR((AE_INFO,
<span class="p_del">-			    &quot;Illegal I/O port address/length above 64K: %p/0x%X&quot;,</span>
<span class="p_del">-			    ACPI_CAST_PTR(void, address), byte_width));</span>
<span class="p_add">+			    &quot;Illegal I/O port address/length above 64K: %8.8X%8.8X/0x%X&quot;,</span>
<span class="p_add">+			    ACPI_FORMAT_UINT64(address), byte_width));</span>
 		return_ACPI_STATUS(AE_LIMIT);
 	}
 
<span class="p_chunk">@@ -181,8 +181,8 @@</span> <span class="p_context"> acpi_hw_validate_io_request(acpi_io_address address, u32 bit_width)</span>
 
 			if (acpi_gbl_osi_data &gt;= port_info-&gt;osi_dependency) {
 				ACPI_DEBUG_PRINT((ACPI_DB_IO,
<span class="p_del">-						  &quot;Denied AML access to port 0x%p/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_del">-						  ACPI_CAST_PTR(void, address),</span>
<span class="p_add">+						  &quot;Denied AML access to port 0x%8.8X%8.8X/%X (%s 0x%.4X-0x%.4X)&quot;,</span>
<span class="p_add">+						  ACPI_FORMAT_UINT64(address),</span>
 						  byte_width, port_info-&gt;name,
 						  port_info-&gt;start,
 						  port_info-&gt;end));
<span class="p_header">diff --git a/drivers/acpi/acpica/nsdump.c b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">index 3d88ef4a3e0d..809ed52de9c8 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsdump.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsdump.c</span>
<span class="p_chunk">@@ -271,12 +271,11 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 		switch (type) {
 		case ACPI_TYPE_PROCESSOR:
 
<span class="p_del">-			acpi_os_printf(&quot;ID %02X Len %02X Addr %p\n&quot;,</span>
<span class="p_add">+			acpi_os_printf(&quot;ID %02X Len %02X Addr %8.8X%8.8X\n&quot;,</span>
 				       obj_desc-&gt;processor.proc_id,
 				       obj_desc-&gt;processor.length,
<span class="p_del">-				       ACPI_CAST_PTR(void,</span>
<span class="p_del">-						     obj_desc-&gt;processor.</span>
<span class="p_del">-						     address));</span>
<span class="p_add">+				       ACPI_FORMAT_UINT64(obj_desc-&gt;processor.</span>
<span class="p_add">+							  address));</span>
 			break;
 
 		case ACPI_TYPE_DEVICE:
<span class="p_chunk">@@ -347,8 +346,9 @@</span> <span class="p_context"> acpi_ns_dump_one_object(acpi_handle obj_handle,</span>
 							       space_id));
 			if (obj_desc-&gt;region.flags &amp; AOPOBJ_DATA_VALID) {
 				acpi_os_printf(&quot; Addr %8.8X%8.8X Len %.4X\n&quot;,
<span class="p_del">-					       ACPI_FORMAT_NATIVE_UINT</span>
<span class="p_del">-					       (obj_desc-&gt;region.address),</span>
<span class="p_add">+					       ACPI_FORMAT_UINT64(obj_desc-&gt;</span>
<span class="p_add">+								  region.</span>
<span class="p_add">+								  address),</span>
 					       obj_desc-&gt;region.length);
 			} else {
 				acpi_os_printf
<span class="p_header">diff --git a/drivers/acpi/acpica/tbdata.c b/drivers/acpi/acpica/tbdata.c</span>
<span class="p_header">index f499c10ceb4a..a078053ff473 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbdata.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbdata.c</span>
<span class="p_chunk">@@ -113,9 +113,9 @@</span> <span class="p_context"> acpi_tb_acquire_table(struct acpi_table_desc *table_desc,</span>
 	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
 	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
 
<span class="p_del">-		table =</span>
<span class="p_del">-		    ACPI_CAST_PTR(struct acpi_table_header,</span>
<span class="p_del">-				  table_desc-&gt;address);</span>
<span class="p_add">+		table = ACPI_CAST_PTR(struct acpi_table_header,</span>
<span class="p_add">+				      ACPI_PHYSADDR_TO_PTR(table_desc-&gt;</span>
<span class="p_add">+							   address));</span>
 		break;
 
 	default:
<span class="p_chunk">@@ -214,7 +214,8 @@</span> <span class="p_context"> acpi_tb_acquire_temp_table(struct acpi_table_desc *table_desc,</span>
 	case ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:
 	case ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:
 
<span class="p_del">-		table_header = ACPI_CAST_PTR(struct acpi_table_header, address);</span>
<span class="p_add">+		table_header = ACPI_CAST_PTR(struct acpi_table_header,</span>
<span class="p_add">+					     ACPI_PHYSADDR_TO_PTR(address));</span>
 		if (!table_header) {
 			return (AE_NO_MEMORY);
 		}
<span class="p_chunk">@@ -398,14 +399,14 @@</span> <span class="p_context"> acpi_tb_verify_temp_table(struct acpi_table_desc * table_desc, char *signature)</span>
 					    table_desc-&gt;length);
 		if (ACPI_FAILURE(status)) {
 			ACPI_EXCEPTION((AE_INFO, AE_NO_MEMORY,
<span class="p_del">-					&quot;%4.4s &quot; ACPI_PRINTF_UINT</span>
<span class="p_add">+					&quot;%4.4s 0x%8.8X%8.8X&quot;</span>
 					&quot; Attempted table install failed&quot;,
 					acpi_ut_valid_acpi_name(table_desc-&gt;
 								signature.
 								ascii) ?
 					table_desc-&gt;signature.ascii : &quot;????&quot;,
<span class="p_del">-					ACPI_FORMAT_TO_UINT(table_desc-&gt;</span>
<span class="p_del">-							    address)));</span>
<span class="p_add">+					ACPI_FORMAT_UINT64(table_desc-&gt;</span>
<span class="p_add">+							   address)));</span>
 			goto invalidate_and_exit;
 		}
 	}
<span class="p_header">diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">index c0b39f304ea3..8e1a43ae2f9b 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_chunk">@@ -187,8 +187,9 @@</span> <span class="p_context"> acpi_tb_install_fixed_table(acpi_physical_address address,</span>
 	status = acpi_tb_acquire_temp_table(&amp;new_table_desc, address,
 					    ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL);
 	if (ACPI_FAILURE(status)) {
<span class="p_del">-		ACPI_ERROR((AE_INFO, &quot;Could not acquire table length at %p&quot;,</span>
<span class="p_del">-			    ACPI_CAST_PTR(void, address)));</span>
<span class="p_add">+		ACPI_ERROR((AE_INFO,</span>
<span class="p_add">+			    &quot;Could not acquire table length at %8.8X%8.8X&quot;,</span>
<span class="p_add">+			    ACPI_FORMAT_UINT64(address)));</span>
 		return_ACPI_STATUS(status);
 	}
 
<span class="p_chunk">@@ -246,8 +247,9 @@</span> <span class="p_context"> acpi_tb_install_standard_table(acpi_physical_address address,</span>
 
 	status = acpi_tb_acquire_temp_table(&amp;new_table_desc, address, flags);
 	if (ACPI_FAILURE(status)) {
<span class="p_del">-		ACPI_ERROR((AE_INFO, &quot;Could not acquire table length at %p&quot;,</span>
<span class="p_del">-			    ACPI_CAST_PTR(void, address)));</span>
<span class="p_add">+		ACPI_ERROR((AE_INFO,</span>
<span class="p_add">+			    &quot;Could not acquire table length at %8.8X%8.8X&quot;,</span>
<span class="p_add">+			    ACPI_FORMAT_UINT64(address)));</span>
 		return_ACPI_STATUS(status);
 	}
 
<span class="p_chunk">@@ -258,9 +260,10 @@</span> <span class="p_context"> acpi_tb_install_standard_table(acpi_physical_address address,</span>
 	if (!reload &amp;&amp;
 	    acpi_gbl_disable_ssdt_table_install &amp;&amp;
 	    ACPI_COMPARE_NAME(&amp;new_table_desc.signature, ACPI_SIG_SSDT)) {
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;Ignoring installation of %4.4s at %p&quot;,</span>
<span class="p_del">-			   new_table_desc.signature.ascii, ACPI_CAST_PTR(void,</span>
<span class="p_del">-									 address)));</span>
<span class="p_add">+		ACPI_INFO((AE_INFO,</span>
<span class="p_add">+			   &quot;Ignoring installation of %4.4s at %8.8X%8.8X&quot;,</span>
<span class="p_add">+			   new_table_desc.signature.ascii,</span>
<span class="p_add">+			   ACPI_FORMAT_UINT64(address)));</span>
 		goto release_and_exit;
 	}
 
<span class="p_chunk">@@ -428,11 +431,11 @@</span> <span class="p_context"> finish_override:</span>
 		return;
 	}
 
<span class="p_del">-	ACPI_INFO((AE_INFO, &quot;%4.4s &quot; ACPI_PRINTF_UINT</span>
<span class="p_del">-		   &quot; %s table override, new table: &quot; ACPI_PRINTF_UINT,</span>
<span class="p_add">+	ACPI_INFO((AE_INFO, &quot;%4.4s 0x%8.8X%8.8X&quot;</span>
<span class="p_add">+		   &quot; %s table override, new table: 0x%8.8X%8.8X&quot;,</span>
 		   old_table_desc-&gt;signature.ascii,
<span class="p_del">-		   ACPI_FORMAT_TO_UINT(old_table_desc-&gt;address),</span>
<span class="p_del">-		   override_type, ACPI_FORMAT_TO_UINT(new_table_desc.address)));</span>
<span class="p_add">+		   ACPI_FORMAT_UINT64(old_table_desc-&gt;address),</span>
<span class="p_add">+		   override_type, ACPI_FORMAT_UINT64(new_table_desc.address)));</span>
 
 	/* We can now uninstall the original table */
 
<span class="p_chunk">@@ -516,7 +519,7 @@</span> <span class="p_context"> void acpi_tb_uninstall_table(struct acpi_table_desc *table_desc)</span>
 
 	if ((table_desc-&gt;flags &amp; ACPI_TABLE_ORIGIN_MASK) ==
 	    ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL) {
<span class="p_del">-		ACPI_FREE(ACPI_CAST_PTR(void, table_desc-&gt;address));</span>
<span class="p_add">+		ACPI_FREE(ACPI_PHYSADDR_TO_PTR(table_desc-&gt;address));</span>
 	}
 
 	table_desc-&gt;address = ACPI_PTR_TO_PHYSADDR(NULL);
<span class="p_header">diff --git a/drivers/acpi/acpica/tbprint.c b/drivers/acpi/acpica/tbprint.c</span>
<span class="p_header">index df3bb20ea325..a23bdaec6040 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbprint.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbprint.c</span>
<span class="p_chunk">@@ -127,18 +127,12 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 {
 	struct acpi_table_header local_header;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The reason that we use ACPI_PRINTF_UINT and ACPI_FORMAT_TO_UINT is to</span>
<span class="p_del">-	 * support both 32-bit and 64-bit hosts/addresses in a consistent manner.</span>
<span class="p_del">-	 * The %p specifier does not emit uniform output on all hosts. On some,</span>
<span class="p_del">-	 * leading zeros are not supported.</span>
<span class="p_del">-	 */</span>
 	if (ACPI_COMPARE_NAME(header-&gt;signature, ACPI_SIG_FACS)) {
 
 		/* FACS only has signature and length fields */
 
<span class="p_del">-		ACPI_INFO((AE_INFO, &quot;%-4.4s &quot; ACPI_PRINTF_UINT &quot; %06X&quot;,</span>
<span class="p_del">-			   header-&gt;signature, ACPI_FORMAT_TO_UINT(address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;%-4.4s 0x%8.8X%8.8X %06X&quot;,</span>
<span class="p_add">+			   header-&gt;signature, ACPI_FORMAT_UINT64(address),</span>
 			   header-&gt;length));
 	} else if (ACPI_VALIDATE_RSDP_SIG(header-&gt;signature)) {
 
<span class="p_chunk">@@ -149,9 +143,8 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 					  header)-&gt;oem_id, ACPI_OEM_ID_SIZE);
 		acpi_tb_fix_string(local_header.oem_id, ACPI_OEM_ID_SIZE);
 
<span class="p_del">-		ACPI_INFO((AE_INFO,</span>
<span class="p_del">-			   &quot;RSDP &quot; ACPI_PRINTF_UINT &quot; %06X (v%.2d %-6.6s)&quot;,</span>
<span class="p_del">-			   ACPI_FORMAT_TO_UINT(address),</span>
<span class="p_add">+		ACPI_INFO((AE_INFO, &quot;RSDP 0x%8.8X%8.8X %06X (v%.2d %-6.6s)&quot;,</span>
<span class="p_add">+			   ACPI_FORMAT_UINT64(address),</span>
 			   (ACPI_CAST_PTR(struct acpi_table_rsdp, header)-&gt;
 			    revision &gt;
 			    0) ? ACPI_CAST_PTR(struct acpi_table_rsdp,
<span class="p_chunk">@@ -165,9 +158,9 @@</span> <span class="p_context"> acpi_tb_print_table_header(acpi_physical_address address,</span>
 		acpi_tb_cleanup_table_header(&amp;local_header, header);
 
 		ACPI_INFO((AE_INFO,
<span class="p_del">-			   &quot;%-4.4s &quot; ACPI_PRINTF_UINT</span>
<span class="p_add">+			   &quot;%-4.4s 0x%8.8X%8.8X&quot;</span>
 			   &quot; %06X (v%.2d %-6.6s %-8.8s %08X %-4.4s %08X)&quot;,
<span class="p_del">-			   local_header.signature, ACPI_FORMAT_TO_UINT(address),</span>
<span class="p_add">+			   local_header.signature, ACPI_FORMAT_UINT64(address),</span>
 			   local_header.length, local_header.revision,
 			   local_header.oem_id, local_header.oem_table_id,
 			   local_header.oem_revision,
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfroot.c b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">index 65ab8fed3d5e..32c3ccfa22c1 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfroot.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> acpi_status acpi_tb_validate_rsdp(struct acpi_table_rsdp *rsdp)</span>
  *
  ******************************************************************************/
 
<span class="p_del">-acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
<span class="p_add">+acpi_status __init acpi_find_root_pointer(acpi_physical_address * table_address)</span>
 {
 	u8 *table_ptr;
 	u8 *mem_rover;
<span class="p_chunk">@@ -169,7 +169,8 @@</span> <span class="p_context"> acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
 			physical_address +=
 			    (u32) ACPI_PTR_DIFF(mem_rover, table_ptr);
 
<span class="p_del">-			*table_address = physical_address;</span>
<span class="p_add">+			*table_address =</span>
<span class="p_add">+			    (acpi_physical_address) physical_address;</span>
 			return_ACPI_STATUS(AE_OK);
 		}
 	}
<span class="p_chunk">@@ -202,7 +203,7 @@</span> <span class="p_context"> acpi_status __init acpi_find_root_pointer(acpi_size *table_address)</span>
 		    (ACPI_HI_RSDP_WINDOW_BASE +
 		     ACPI_PTR_DIFF(mem_rover, table_ptr));
 
<span class="p_del">-		*table_address = physical_address;</span>
<span class="p_add">+		*table_address = (acpi_physical_address) physical_address;</span>
 		return_ACPI_STATUS(AE_OK);
 	}
 
<span class="p_header">diff --git a/drivers/acpi/acpica/utaddress.c b/drivers/acpi/acpica/utaddress.c</span>
<span class="p_header">index a1acec9d2ef3..65985036c5c3 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utaddress.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utaddress.c</span>
<span class="p_chunk">@@ -107,10 +107,10 @@</span> <span class="p_context"> acpi_ut_add_address_range(acpi_adr_space_type space_id,</span>
 	acpi_gbl_address_range_list[space_id] = range_info;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
<span class="p_del">-			  &quot;\nAdded [%4.4s] address range: 0x%p-0x%p\n&quot;,</span>
<span class="p_add">+			  &quot;\nAdded [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n&quot;,</span>
 			  acpi_ut_get_node_name(range_info-&gt;region_node),
<span class="p_del">-			  ACPI_CAST_PTR(void, address),</span>
<span class="p_del">-			  ACPI_CAST_PTR(void, range_info-&gt;end_address)));</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+			  ACPI_FORMAT_UINT64(range_info-&gt;end_address)));</span>
 
 	(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);
 	return_ACPI_STATUS(AE_OK);
<span class="p_chunk">@@ -160,15 +160,13 @@</span> <span class="p_context"> acpi_ut_remove_address_range(acpi_adr_space_type space_id,</span>
 			}
 
 			ACPI_DEBUG_PRINT((ACPI_DB_NAMES,
<span class="p_del">-					  &quot;\nRemoved [%4.4s] address range: 0x%p-0x%p\n&quot;,</span>
<span class="p_add">+					  &quot;\nRemoved [%4.4s] address range: 0x%8.8X%8.8X-0x%8.8X%8.8X\n&quot;,</span>
 					  acpi_ut_get_node_name(range_info-&gt;
 								region_node),
<span class="p_del">-					  ACPI_CAST_PTR(void,</span>
<span class="p_del">-							range_info-&gt;</span>
<span class="p_del">-							start_address),</span>
<span class="p_del">-					  ACPI_CAST_PTR(void,</span>
<span class="p_del">-							range_info-&gt;</span>
<span class="p_del">-							end_address)));</span>
<span class="p_add">+					  ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+							     start_address),</span>
<span class="p_add">+					  ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+							     end_address)));</span>
 
 			ACPI_FREE(range_info);
 			return_VOID;
<span class="p_chunk">@@ -245,16 +243,14 @@</span> <span class="p_context"> acpi_ut_check_address_range(acpi_adr_space_type space_id,</span>
 								  region_node);
 
 				ACPI_WARNING((AE_INFO,
<span class="p_del">-					      &quot;%s range 0x%p-0x%p conflicts with OpRegion 0x%p-0x%p (%s)&quot;,</span>
<span class="p_add">+					      &quot;%s range 0x%8.8X%8.8X-0x%8.8X%8.8X conflicts with OpRegion 0x%8.8X%8.8X-0x%8.8X%8.8X (%s)&quot;,</span>
 					      acpi_ut_get_region_name(space_id),
<span class="p_del">-					      ACPI_CAST_PTR(void, address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void, end_address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void,</span>
<span class="p_del">-							    range_info-&gt;</span>
<span class="p_del">-							    start_address),</span>
<span class="p_del">-					      ACPI_CAST_PTR(void,</span>
<span class="p_del">-							    range_info-&gt;</span>
<span class="p_del">-							    end_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(end_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+								 start_address),</span>
<span class="p_add">+					      ACPI_FORMAT_UINT64(range_info-&gt;</span>
<span class="p_add">+								 end_address),</span>
 					      pathname));
 				ACPI_FREE(pathname);
 			}
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 73d5388bd1f6..f017d1964eb6 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -2167,6 +2167,11 @@</span> <span class="p_context"> static bool rbd_img_obj_end_request(struct rbd_obj_request *obj_request)</span>
 			result, xferred);
 		if (!img_request-&gt;result)
 			img_request-&gt;result = result;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Need to end I/O on the entire obj_request worth of</span>
<span class="p_add">+		 * bytes in case of error.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		xferred = obj_request-&gt;length;</span>
 	}
 
 	/* Image object requests don&#39;t own their page array */
<span class="p_header">diff --git a/drivers/firmware/efi/Makefile b/drivers/firmware/efi/Makefile</span>
<span class="p_header">index 9553496b0f43..c135154ead89 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/Makefile</span>
<span class="p_header">+++ b/drivers/firmware/efi/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 #
 # Makefile for linux kernel
 #
<span class="p_del">-obj-$(CONFIG_EFI)			+= efi.o vars.o</span>
<span class="p_add">+obj-$(CONFIG_EFI)			+= efi.o vars.o reboot.o</span>
 obj-$(CONFIG_EFI_VARS)			+= efivars.o
 obj-$(CONFIG_EFI_VARS_PSTORE)		+= efi-pstore.o
 obj-$(CONFIG_UEFI_CPER)			+= cper.o
<span class="p_header">diff --git a/drivers/firmware/efi/reboot.c b/drivers/firmware/efi/reboot.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9c59d1c795d1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/reboot.c</span>
<span class="p_chunk">@@ -0,0 +1,56 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Intel Corporation; author Matt Fleming</span>
<span class="p_add">+ * Copyright (c) 2014 Red Hat, Inc., Mark Salter &lt;msalter@redhat.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+int efi_reboot_quirk_mode = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+void efi_reboot(enum reboot_mode reboot_mode, const char *__unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int efi_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!efi_enabled(EFI_RUNTIME_SERVICES))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (reboot_mode) {</span>
<span class="p_add">+	case REBOOT_WARM:</span>
<span class="p_add">+	case REBOOT_SOFT:</span>
<span class="p_add">+		efi_mode = EFI_RESET_WARM;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		efi_mode = EFI_RESET_COLD;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If a quirk forced an EFI reset mode, always use that.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (efi_reboot_quirk_mode != -1)</span>
<span class="p_add">+		efi_mode = efi_reboot_quirk_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	efi.reset_system(efi_mode, EFI_SUCCESS, 0, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool __weak efi_poweroff_required(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void efi_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi.reset_system(EFI_RESET_SHUTDOWN, EFI_SUCCESS, 0, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init efi_shutdown_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!efi_enabled(EFI_RUNTIME_SERVICES))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_poweroff_required())</span>
<span class="p_add">+		pm_power_off = efi_power_off;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+late_initcall(efi_shutdown_init);</span>
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-map.c b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">index c98b101a73ae..019a7e32de4c 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_chunk">@@ -120,7 +120,8 @@</span> <span class="p_context"> add_sysfs_runtime_map_entry(struct kobject *kobj, int nr)</span>
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry) {
 		kset_unregister(map_kset);
<span class="p_del">-		return entry;</span>
<span class="p_add">+		map_kset = NULL;</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 	}
 
 	memcpy(&amp;entry-&gt;md, efi_runtime_map + nr * efi_memdesc_size,
<span class="p_chunk">@@ -132,6 +133,7 @@</span> <span class="p_context"> add_sysfs_runtime_map_entry(struct kobject *kobj, int nr)</span>
 	if (ret) {
 		kobject_put(&amp;entry-&gt;kobj);
 		kset_unregister(map_kset);
<span class="p_add">+		map_kset = NULL;</span>
 		return ERR_PTR(ret);
 	}
 
<span class="p_chunk">@@ -174,8 +176,6 @@</span> <span class="p_context"> out_add_entry:</span>
 		entry = *(map_entries + j);
 		kobject_put(&amp;entry-&gt;kobj);
 	}
<span class="p_del">-	if (map_kset)</span>
<span class="p_del">-		kset_unregister(map_kset);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index d9b8844e2715..b5f915609dc5 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -833,6 +833,7 @@</span> <span class="p_context"> static struct class gpio_class = {</span>
  */
 int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 {
<span class="p_add">+	struct gpio_chip	*chip;</span>
 	unsigned long		flags;
 	int			status;
 	const char		*ioname = NULL;
<span class="p_chunk">@@ -850,8 +851,16 @@</span> <span class="p_context"> int gpiod_export(struct gpio_desc *desc, bool direction_may_change)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	chip = desc-&gt;chip;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;sysfs_lock);
 
<span class="p_add">+	/* check if chip is being removed */</span>
<span class="p_add">+	if (!chip || !chip-&gt;exported) {</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto fail_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
 	if (!test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) ||
 	     test_bit(FLAG_EXPORT, &amp;desc-&gt;flags)) {
<span class="p_chunk">@@ -1076,12 +1085,15 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 {
 	int			status;
 	struct device		*dev;
<span class="p_add">+	struct gpio_desc *desc;</span>
<span class="p_add">+	unsigned int i;</span>
 
 	mutex_lock(&amp;sysfs_lock);
 	dev = class_find_device(&amp;gpio_class, NULL, chip, match_export);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);
<span class="p_add">+		/* prevent further gpiod exports */</span>
 		chip-&gt;exported = false;
 		status = 0;
 	} else
<span class="p_chunk">@@ -1090,6 +1102,13 @@</span> <span class="p_context"> static void gpiochip_unexport(struct gpio_chip *chip)</span>
 
 	if (status)
 		chip_dbg(chip, &quot;%s: status %d\n&quot;, __func__, status);
<span class="p_add">+</span>
<span class="p_add">+	/* unregister gpiod class devices owned by sysfs */</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;ngpio; i++) {</span>
<span class="p_add">+		desc = &amp;chip-&gt;desc[i];</span>
<span class="p_add">+		if (test_and_clear_bit(FLAG_SYSFS, &amp;desc-&gt;flags))</span>
<span class="p_add">+			gpiod_free(desc);</span>
<span class="p_add">+	}</span>
 }
 
 static int __init gpiolib_sysfs_init(void)
<span class="p_chunk">@@ -1287,6 +1306,8 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 	int		status = 0;
 	unsigned	id;
 
<span class="p_add">+	gpiochip_unexport(chip);</span>
<span class="p_add">+</span>
 	gpiochip_irqchip_remove(chip);
 
 	acpi_gpiochip_remove(chip);
<span class="p_chunk">@@ -1309,9 +1330,6 @@</span> <span class="p_context"> int gpiochip_remove(struct gpio_chip *chip)</span>
 
 	spin_unlock_irqrestore(&amp;gpio_lock, flags);
 
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		gpiochip_unexport(chip);</span>
<span class="p_del">-</span>
 	return status;
 }
 EXPORT_SYMBOL_GPL(gpiochip_remove);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index a8221d9349ee..d2f1431eb428 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -852,7 +852,7 @@</span> <span class="p_context"> intel_dp_compute_config(struct intel_encoder *encoder,</span>
 		pipe_config-&gt;has_pch_encoder = true;
 
 	pipe_config-&gt;has_dp_encoder = true;
<span class="p_del">-	pipe_config-&gt;has_audio = intel_dp-&gt;has_audio;</span>
<span class="p_add">+	pipe_config-&gt;has_audio = intel_dp-&gt;has_audio &amp;&amp; port != PORT_A;</span>
 
 	if (is_edp(intel_dp) &amp;&amp; intel_connector-&gt;panel.fixed_mode) {
 		intel_fixed_panel_mode(intel_connector-&gt;panel.fixed_mode,
<span class="p_chunk">@@ -1578,8 +1578,8 @@</span> <span class="p_context"> static void intel_dp_get_config(struct intel_encoder *encoder,</span>
 	int dotclock;
 
 	tmp = I915_READ(intel_dp-&gt;output_reg);
<span class="p_del">-	if (tmp &amp; DP_AUDIO_OUTPUT_ENABLE)</span>
<span class="p_del">-		pipe_config-&gt;has_audio = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	pipe_config-&gt;has_audio = tmp &amp; DP_AUDIO_OUTPUT_ENABLE &amp;&amp; port != PORT_A;</span>
 
 	if ((port == PORT_A) || !HAS_PCH_CPT(dev)) {
 		if (tmp &amp; DP_SYNC_HS_HIGH)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">index eef36d0076ee..e61b29cb2d29 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_chunk">@@ -802,12 +802,28 @@</span> <span class="p_context"> static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)</span>
 static const struct dmi_system_id intel_dual_link_lvds[] = {
 	{
 		.callback = intel_dual_link_lvds_callback,
<span class="p_del">-		.ident = &quot;Apple MacBook Pro (Core i5/i7 Series)&quot;,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2010)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro6,2&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2011)&quot;,</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro8,2&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2012)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro9,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }	/* terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.c b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">index 30f9f1885191..21d6f08f5324 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_chunk">@@ -1160,7 +1160,7 @@</span> <span class="p_context"> static struct radeon_asic rs780_asic = {</span>
 static struct radeon_asic_ring rv770_uvd_ring = {
 	.ib_execute = &amp;uvd_v1_0_ib_execute,
 	.emit_fence = &amp;uvd_v2_2_fence_emit,
<span class="p_del">-	.emit_semaphore = &amp;uvd_v1_0_semaphore_emit,</span>
<span class="p_add">+	.emit_semaphore = &amp;uvd_v2_2_semaphore_emit,</span>
 	.cs_parse = &amp;radeon_uvd_cs_parse,
 	.ring_test = &amp;uvd_v1_0_ring_test,
 	.ib_test = &amp;uvd_v1_0_ib_test,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.h b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">index 01e7c0ad8f01..c26b0e2cdd39 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_chunk">@@ -866,6 +866,10 @@</span> <span class="p_context"> void uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);</span>
 int uvd_v2_2_resume(struct radeon_device *rdev);
 void uvd_v2_2_fence_emit(struct radeon_device *rdev,
 			 struct radeon_fence *fence);
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait);</span>
 
 /* uvd v3.1 */
 bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">index a4ad270e8261..a86cc490c35f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_chunk">@@ -351,6 +351,29 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg_decode(uint32_t *msg, unsigned buf_sizes[])</span>
 	return 0;
 }
 
<span class="p_add">+static int radeon_uvd_validate_codec(struct radeon_cs_parser *p,</span>
<span class="p_add">+				     unsigned stream_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (stream_type) {</span>
<span class="p_add">+	case 0: /* H264 */</span>
<span class="p_add">+	case 1: /* VC1 */</span>
<span class="p_add">+		/* always supported */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 3: /* MPEG2 */</span>
<span class="p_add">+	case 4: /* MPEG4 */</span>
<span class="p_add">+		/* only since UVD 3 */</span>
<span class="p_add">+		if (p-&gt;rdev-&gt;family &gt;= CHIP_PALM)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* fall through */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		DRM_ERROR(&quot;UVD codec not supported by hardware %d!\n&quot;,</span>
<span class="p_add">+			  stream_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,
 			     unsigned offset, unsigned buf_sizes[])
 {
<span class="p_chunk">@@ -389,50 +412,70 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (msg_type == 1) {</span>
<span class="p_del">-		/* it&#39;s a decode msg, calc buffer sizes */</span>
<span class="p_del">-		r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
<span class="p_del">-		/* calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[6] * msg[7];</span>
<span class="p_add">+	switch (msg_type) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_add">+		img_size = msg[7] * msg[8];</span>
<span class="p_add">+</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		radeon_bo_kunmap(bo);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			return r;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* try to alloc a new handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				DRM_ERROR(&quot;Handle 0x%x already in use!\n&quot;, handle);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		/* it&#39;s a decode msg, validate codec and calc buffer sizes */</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		if (!r)</span>
<span class="p_add">+			r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
 		radeon_bo_kunmap(bo);
 		if (r)
 			return r;
 
<span class="p_del">-	} else if (msg_type == 2) {</span>
<span class="p_add">+		/* validate the handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				if (p-&gt;rdev-&gt;uvd.filp[i] != p-&gt;filp) {</span>
<span class="p_add">+					DRM_ERROR(&quot;UVD handle collision detected!\n&quot;);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;Invalid UVD handle 0x%x!\n&quot;, handle);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 2:</span>
 		/* it&#39;s a destroy msg, free the handle */
 		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i)
 			atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], handle, 0);
 		radeon_bo_kunmap(bo);
 		return 0;
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[7] * msg[8];</span>
<span class="p_del">-		radeon_bo_kunmap(bo);</span>
 
<span class="p_del">-		if (msg_type != 0) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* it&#39;s a create msg, no special handling needed */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* create or decode, validate the handle */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	default:</span>
 
<span class="p_del">-	/* handle not found try to alloc a new one */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
<span class="p_del">-	DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+	BUG();</span>
 	return -EINVAL;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">index aa21c31a846c..2944637b8b44 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_chunk">@@ -492,18 +492,27 @@</span> <span class="p_context"> int radeon_vce_cs_reloc(struct radeon_cs_parser *p, int lo, int hi,</span>
  *
  * @p: parser context
  * @handle: handle to validate
<span class="p_add">+ * @allocated: allocated a new handle?</span>
  *
  * Validates the handle and return the found session index or -EINVAL
  * we we don&#39;t have another free session index.
  */
<span class="p_del">-int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
<span class="p_add">+static int radeon_vce_validate_handle(struct radeon_cs_parser *p,</span>
<span class="p_add">+				      uint32_t handle, bool *allocated)</span>
 {
 	unsigned i;
 
<span class="p_add">+	*allocated = false;</span>
<span class="p_add">+</span>
 	/* validate the handle */
 	for (i = 0; i &lt; RADEON_MAX_VCE_HANDLES; ++i) {
<span class="p_del">-		if (atomic_read(&amp;p-&gt;rdev-&gt;vce.handles[i]) == handle)</span>
<span class="p_add">+		if (atomic_read(&amp;p-&gt;rdev-&gt;vce.handles[i]) == handle) {</span>
<span class="p_add">+			if (p-&gt;rdev-&gt;vce.filp[i] != p-&gt;filp) {</span>
<span class="p_add">+				DRM_ERROR(&quot;VCE handle collision detected!\n&quot;);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
 			return i;
<span class="p_add">+		}</span>
 	}
 
 	/* handle not found try to alloc a new one */
<span class="p_chunk">@@ -511,6 +520,7 @@</span> <span class="p_context"> int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
 		if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;vce.handles[i], 0, handle)) {
 			p-&gt;rdev-&gt;vce.filp[i] = p-&gt;filp;
 			p-&gt;rdev-&gt;vce.img_size[i] = 0;
<span class="p_add">+			*allocated = true;</span>
 			return i;
 		}
 	}
<span class="p_chunk">@@ -528,10 +538,10 @@</span> <span class="p_context"> int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
 int radeon_vce_cs_parse(struct radeon_cs_parser *p)
 {
 	int session_idx = -1;
<span class="p_del">-	bool destroyed = false;</span>
<span class="p_add">+	bool destroyed = false, created = false, allocated = false;</span>
 	uint32_t tmp, handle = 0;
 	uint32_t *size = &amp;tmp;
<span class="p_del">-	int i, r;</span>
<span class="p_add">+	int i, r = 0;</span>
 
 	while (p-&gt;idx &lt; p-&gt;chunks[p-&gt;chunk_ib_idx].length_dw) {
 		uint32_t len = radeon_get_ib_value(p, p-&gt;idx);
<span class="p_chunk">@@ -539,18 +549,21 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 
 		if ((len &lt; 8) || (len &amp; 3)) {
 			DRM_ERROR(&quot;invalid VCE command length (%d)!\n&quot;, len);
<span class="p_del">-                	return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		if (destroyed) {
 			DRM_ERROR(&quot;No other command allowed after destroy!\n&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		switch (cmd) {
 		case 0x00000001: // session
 			handle = radeon_get_ib_value(p, p-&gt;idx + 2);
<span class="p_del">-			session_idx = radeon_vce_validate_handle(p, handle);</span>
<span class="p_add">+			session_idx = radeon_vce_validate_handle(p, handle,</span>
<span class="p_add">+								 &amp;allocated);</span>
 			if (session_idx &lt; 0)
 				return session_idx;
 			size = &amp;p-&gt;rdev-&gt;vce.img_size[session_idx];
<span class="p_chunk">@@ -560,6 +573,13 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			break;
 
 		case 0x01000001: // create
<span class="p_add">+			created = true;</span>
<span class="p_add">+			if (!allocated) {</span>
<span class="p_add">+				DRM_ERROR(&quot;Handle already in use!\n&quot;);</span>
<span class="p_add">+				r = -EINVAL;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			*size = radeon_get_ib_value(p, p-&gt;idx + 8) *
 				radeon_get_ib_value(p, p-&gt;idx + 10) *
 				8 * 3 / 2;
<span class="p_chunk">@@ -576,12 +596,12 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 10, p-&gt;idx + 9,
 						*size);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 12, p-&gt;idx + 11,
 						*size / 3);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x02000001: // destroy
<span class="p_chunk">@@ -592,7 +612,7 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						*size * 2);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x05000004: // video bitstream buffer
<span class="p_chunk">@@ -600,36 +620,47 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						tmp);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x05000005: // feedback buffer
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						4096);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		default:
 			DRM_ERROR(&quot;invalid VCE command (0x%x)!\n&quot;, cmd);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		if (session_idx == -1) {
 			DRM_ERROR(&quot;no session command at start of IB\n&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		p-&gt;idx += len / 4;
 	}
 
<span class="p_del">-	if (destroyed) {</span>
<span class="p_del">-		/* IB contains a destroy msg, free the handle */</span>
<span class="p_add">+	if (allocated &amp;&amp; !created) {</span>
<span class="p_add">+		DRM_ERROR(&quot;New session without create command!\n&quot;);</span>
<span class="p_add">+		r = -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if ((!r &amp;&amp; destroyed) || (r &amp;&amp; allocated)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * IB contains a destroy msg or we have allocated an</span>
<span class="p_add">+		 * handle and got an error, anyway free the handle</span>
<span class="p_add">+		 */</span>
 		for (i = 0; i &lt; RADEON_MAX_VCE_HANDLES; ++i)
 			atomic_cmpxchg(&amp;p-&gt;rdev-&gt;vce.handles[i], handle, 0);
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return r;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770d.h b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">index 3cf1e2921545..9ef2064b1c9c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_chunk">@@ -989,6 +989,9 @@</span> <span class="p_context"></span>
 			 ((n) &amp; 0x3FFF) &lt;&lt; 16)
 
 /* UVD */
<span class="p_add">+#define UVD_SEMA_ADDR_LOW				0xef00</span>
<span class="p_add">+#define UVD_SEMA_ADDR_HIGH				0xef04</span>
<span class="p_add">+#define UVD_SEMA_CMD					0xef08</span>
 #define UVD_GPCOM_VCPU_CMD				0xef0c
 #define UVD_GPCOM_VCPU_DATA0				0xef10
 #define UVD_GPCOM_VCPU_DATA1				0xef14
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index e7b9f714042b..4d47c5819c9c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2920,6 +2920,7 @@</span> <span class="p_context"> struct si_dpm_quirk {</span>
 static struct si_dpm_quirk si_dpm_quirk_list[] = {
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v1_0.c b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">index be42c8125203..80856b0619fb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_chunk">@@ -365,18 +365,8 @@</span> <span class="p_context"> bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,</span>
 			     struct radeon_semaphore *semaphore,
 			     bool emit_wait)
 {
<span class="p_del">-	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	return true;</span>
<span class="p_add">+	/* disable semaphores for UVD V1 hardware */</span>
<span class="p_add">+	return false;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v2_2.c b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">index 8bfdadd56598..3eaa034a4f46 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_chunk">@@ -60,6 +60,35 @@</span> <span class="p_context"> void uvd_v2_2_fence_emit(struct radeon_device *rdev,</span>
 }
 
 /**
<span class="p_add">+ * uvd_v2_2_semaphore_emit - emit semaphore command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @rdev: radeon_device pointer</span>
<span class="p_add">+ * @ring: radeon_ring pointer</span>
<span class="p_add">+ * @semaphore: semaphore to emit commands for</span>
<span class="p_add">+ * @emit_wait: true if we should emit a wait command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Emit a semaphore command (either wait or signal) to the UVD ring.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * uvd_v2_2_resume - memory controller programming
  *
  * @rdev: radeon_device pointer
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index 4d835fbeba44..d66af95d3de4 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -1252,8 +1252,6 @@</span> <span class="p_context"> static int i2c_register_adapter(struct i2c_adapter *adap)</span>
 
 	dev_dbg(&amp;adap-&gt;dev, &quot;adapter [%s] registered\n&quot;, adap-&gt;name);
 
<span class="p_del">-	pm_runtime_no_callbacks(&amp;adap-&gt;dev);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_I2C_COMPAT
 	res = class_compat_create_link(i2c_adapter_compat_class, &amp;adap-&gt;dev,
 				       adap-&gt;dev.parent);
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index d570030d899c..06441a43c3aa 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -859,19 +859,27 @@</span> <span class="p_context"> static void cma_save_ib_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id</span>
 	memcpy(&amp;ib-&gt;sib_addr, &amp;path-&gt;dgid, 16);
 }
 
<span class="p_add">+static __be16 ss_get_port(const struct sockaddr_storage *ss)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ss-&gt;ss_family == AF_INET)</span>
<span class="p_add">+		return ((struct sockaddr_in *)ss)-&gt;sin_port;</span>
<span class="p_add">+	else if (ss-&gt;ss_family == AF_INET6)</span>
<span class="p_add">+		return ((struct sockaddr_in6 *)ss)-&gt;sin6_port;</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in *listen4, *ip4;</span>
<span class="p_add">+	struct sockaddr_in *ip4;</span>
 
<span class="p_del">-	listen4 = (struct sockaddr_in *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;dst_addr.ip4.addr;
<span class="p_del">-	ip4-&gt;sin_port = listen4-&gt;sin_port;</span>
<span class="p_add">+	ip4-&gt;sin_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;src_addr.ip4.addr;
 	ip4-&gt;sin_port = hdr-&gt;port;
 }
<span class="p_chunk">@@ -879,16 +887,15 @@</span> <span class="p_context"> static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_i</span>
 static void cma_save_ip6_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in6 *listen6, *ip6;</span>
<span class="p_add">+	struct sockaddr_in6 *ip6;</span>
 
<span class="p_del">-	listen6 = (struct sockaddr_in6 *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;dst_addr.ip6;
<span class="p_del">-	ip6-&gt;sin6_port = listen6-&gt;sin6_port;</span>
<span class="p_add">+	ip6-&gt;sin6_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;src_addr.ip6;
 	ip6-&gt;sin6_port = hdr-&gt;port;
 }
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index 683e685ed697..9afd00b45f83 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -531,6 +531,9 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			 ? (sector &amp; (chunk_sects-1))
 			 : sector_div(sector, chunk_sects));
 
<span class="p_add">+		/* Restore due to sector_div */</span>
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
<span class="p_add">+</span>
 		if (sectors &lt; bio_sectors(bio)) {
 			split = bio_split(bio, sectors, GFP_NOIO, fs_bio_set);
 			bio_chain(split, bio);
<span class="p_chunk">@@ -538,7 +541,6 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_del">-		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index b082b25ea9c4..e32206ecfa04 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1025,6 +1025,18 @@</span> <span class="p_context"> static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)</span>
 	md-&gt;reset_done &amp;= ~type;
 }
 
<span class="p_add">+int mmc_access_rpmb(struct mmc_queue *mq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmc_blk_data *md = mq-&gt;data;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If this is a RPMB partition access, return ture</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (md &amp;&amp; md-&gt;part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq-&gt;data;
<span class="p_header">diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c</span>
<span class="p_header">index 3e049c13429c..6ceede0a0bf7 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.c</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static int mmc_prep_request(struct request_queue *q, struct request *req)</span>
 		return BLKPREP_KILL;
 	}
 
<span class="p_del">-	if (mq &amp;&amp; mmc_card_removed(mq-&gt;card))</span>
<span class="p_add">+	if (mq &amp;&amp; (mmc_card_removed(mq-&gt;card) || mmc_access_rpmb(mq)))</span>
 		return BLKPREP_KILL;
 
 	req-&gt;cmd_flags |= REQ_DONTPREP;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index 5752d50049a3..99e6521e6169 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -73,4 +73,6 @@</span> <span class="p_context"> extern void mmc_queue_bounce_post(struct mmc_queue_req *);</span>
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
<span class="p_add">+extern int mmc_access_rpmb(struct mmc_queue *);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 7dc0c85fdb60..767b47296e1b 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -2620,6 +2620,7 @@</span> <span class="p_context"> int mmc_pm_notify(struct notifier_block *notify_block,</span>
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
 		spin_lock_irqsave(&amp;host-&gt;lock, flags);
 		host-&gt;rescan_disable = 1;
 		spin_unlock_irqrestore(&amp;host-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">index 656fbba4c422..1df9140c0b16 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_chunk">@@ -1402,7 +1402,7 @@</span> <span class="p_context"> static int sh_mmcif_probe(struct platform_device *pdev)</span>
 	host		= mmc_priv(mmc);
 	host-&gt;mmc	= mmc;
 	host-&gt;addr	= reg;
<span class="p_del">-	host-&gt;timeout	= msecs_to_jiffies(1000);</span>
<span class="p_add">+	host-&gt;timeout	= msecs_to_jiffies(10000);</span>
 	host-&gt;ccs_enable = !pd || !pd-&gt;ccs_unsupported;
 	host-&gt;clk_ctrl2_enable = pd &amp;&amp; pd-&gt;clk_ctrl2_present;
 
<span class="p_header">diff --git a/drivers/mtd/ubi/misc.c b/drivers/mtd/ubi/misc.c</span>
<span class="p_header">index f913d701a5b3..c4b1af07a121 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/misc.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/misc.c</span>
<span class="p_chunk">@@ -74,6 +74,8 @@</span> <span class="p_context"> int ubi_check_volume(struct ubi_device *ubi, int vol_id)</span>
 	for (i = 0; i &lt; vol-&gt;used_ebs; i++) {
 		int size;
 
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (i == vol-&gt;used_ebs - 1)
 			size = vol-&gt;last_eb_bytes;
 		else
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 1b67e902aee6..8be0c179e25d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -1497,6 +1497,7 @@</span> <span class="p_context"> static void mlx4_en_service_task(struct work_struct *work)</span>
 		if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)
 			mlx4_en_ptp_overflow_check(mdev);
 
<span class="p_add">+		mlx4_en_recover_from_oom(priv);</span>
 		queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,
 				   SERVICE_TASK_DELAY);
 	}
<span class="p_chunk">@@ -1746,7 +1747,7 @@</span> <span class="p_context"> mac_err:</span>
 cq_err:
 	while (rx_index--) {
 		mlx4_en_deactivate_cq(priv, priv-&gt;rx_cq[rx_index]);
<span class="p_del">-		mlx4_en_free_affinity_hint(priv, i);</span>
<span class="p_add">+		mlx4_en_free_affinity_hint(priv, rx_index);</span>
 	}
 	for (i = 0; i &lt; priv-&gt;rx_ring_num; i++)
 		mlx4_en_deactivate_rx_ring(priv, priv-&gt;rx_ring[i]);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index 5535862f27cc..fa742b1115f9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -237,6 +237,12 @@</span> <span class="p_context"> static int mlx4_en_prepare_rx_desc(struct mlx4_en_priv *priv,</span>
 	return mlx4_en_alloc_frags(priv, rx_desc, frags, ring-&gt;page_alloc, gfp);
 }
 
<span class="p_add">+static inline bool mlx4_en_is_ring_empty(struct mlx4_en_rx_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON((u32)(ring-&gt;prod - ring-&gt;cons) &gt; ring-&gt;actual_size);</span>
<span class="p_add">+	return ring-&gt;prod == ring-&gt;cons;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void mlx4_en_update_rx_prod_db(struct mlx4_en_rx_ring *ring)
 {
 	*ring-&gt;wqres.db.db = cpu_to_be32(ring-&gt;prod &amp; 0xffff);
<span class="p_chunk">@@ -308,8 +314,7 @@</span> <span class="p_context"> static void mlx4_en_free_rx_buf(struct mlx4_en_priv *priv,</span>
 	       ring-&gt;cons, ring-&gt;prod);
 
 	/* Unmap and free Rx buffers */
<span class="p_del">-	BUG_ON((u32) (ring-&gt;prod - ring-&gt;cons) &gt; ring-&gt;actual_size);</span>
<span class="p_del">-	while (ring-&gt;cons != ring-&gt;prod) {</span>
<span class="p_add">+	while (!mlx4_en_is_ring_empty(ring)) {</span>
 		index = ring-&gt;cons &amp; ring-&gt;size_mask;
 		en_dbg(DRV, priv, &quot;Processing descriptor:%d\n&quot;, index);
 		mlx4_en_free_rx_desc(priv, ring, index);
<span class="p_chunk">@@ -483,6 +488,23 @@</span> <span class="p_context"> err_allocator:</span>
 	return err;
 }
 
<span class="p_add">+/* We recover from out of memory by scheduling our napi poll</span>
<span class="p_add">+ * function (mlx4_en_process_cq), which tries to allocate</span>
<span class="p_add">+ * all missing RX buffers (call to mlx4_en_refill_rx_buffers).</span>
<span class="p_add">+ */</span>
<span class="p_add">+void mlx4_en_recover_from_oom(struct mlx4_en_priv *priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv-&gt;port_up)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (ring = 0; ring &lt; priv-&gt;rx_ring_num; ring++) {</span>
<span class="p_add">+		if (mlx4_en_is_ring_empty(priv-&gt;rx_ring[ring]))</span>
<span class="p_add">+			napi_reschedule(&amp;priv-&gt;rx_cq[ring]-&gt;napi);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void mlx4_en_destroy_rx_ring(struct mlx4_en_priv *priv,
 			     struct mlx4_en_rx_ring **pring,
 			     u32 size, u16 stride)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index 0610c85d4371..8068b0557c5a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -132,8 +132,10 @@</span> <span class="p_context"> int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,</span>
 	ring-&gt;hwtstamp_tx_type = priv-&gt;hwtstamp_config.tx_type;
 	ring-&gt;queue_index = queue_index;
 
<span class="p_del">-	if (queue_index &lt; priv-&gt;num_tx_rings_p_up &amp;&amp; cpu_online(queue_index))</span>
<span class="p_del">-		cpumask_set_cpu(queue_index, &amp;ring-&gt;affinity_mask);</span>
<span class="p_add">+	if (queue_index &lt; priv-&gt;num_tx_rings_p_up)</span>
<span class="p_add">+		cpumask_set_cpu_local_first(queue_index,</span>
<span class="p_add">+					    priv-&gt;mdev-&gt;dev-&gt;numa_node,</span>
<span class="p_add">+					    &amp;ring-&gt;affinity_mask);</span>
 
 	*pring = ring;
 	return 0;
<span class="p_chunk">@@ -200,7 +202,7 @@</span> <span class="p_context"> int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,</span>
 
 	err = mlx4_qp_to_ready(mdev-&gt;dev, &amp;ring-&gt;wqres.mtt, &amp;ring-&gt;context,
 			       &amp;ring-&gt;qp, &amp;ring-&gt;qp_state);
<span class="p_del">-	if (!user_prio &amp;&amp; cpu_online(ring-&gt;queue_index))</span>
<span class="p_add">+	if (!cpumask_empty(&amp;ring-&gt;affinity_mask))</span>
 		netif_set_xps_queue(priv-&gt;dev, &amp;ring-&gt;affinity_mask,
 				    ring-&gt;queue_index);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">index d72a5a894fc6..4e47239d031d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_chunk">@@ -758,6 +758,7 @@</span> <span class="p_context"> int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,</span>
 void mlx4_en_deactivate_tx_ring(struct mlx4_en_priv *priv,
 				struct mlx4_en_tx_ring *ring);
 void mlx4_en_set_num_rx_rings(struct mlx4_en_dev *mdev);
<span class="p_add">+void mlx4_en_recover_from_oom(struct mlx4_en_priv *priv);</span>
 int mlx4_en_create_rx_ring(struct mlx4_en_priv *priv,
 			   struct mlx4_en_rx_ring **pring,
 			   u32 size, u16 stride, int node);
<span class="p_header">diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c</span>
<span class="p_header">index 81ca0ce4c909..84f946a7a405 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/core.c</span>
<span class="p_chunk">@@ -1124,7 +1124,7 @@</span> <span class="p_context"> void devm_pinctrl_put(struct pinctrl *p)</span>
 EXPORT_SYMBOL_GPL(devm_pinctrl_put);
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked)</span>
<span class="p_add">+			 bool dup)</span>
 {
 	int i, ret;
 	struct pinctrl_maps *maps_node;
<span class="p_chunk">@@ -1192,11 +1192,9 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 		maps_node-&gt;maps = maps;
 	}
 
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_lock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;pinctrl_maps_mutex);</span>
 	list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps);
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_unlock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;pinctrl_maps_mutex);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1211,7 +1209,7 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 int pinctrl_register_mappings(struct pinctrl_map const *maps,
 			      unsigned num_maps)
 {
<span class="p_del">-	return pinctrl_register_map(maps, num_maps, true, false);</span>
<span class="p_add">+	return pinctrl_register_map(maps, num_maps, true);</span>
 }
 
 void pinctrl_unregister_map(struct pinctrl_map const *map)
<span class="p_header">diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h</span>
<span class="p_header">index 75476b3d87da..b24ea846c867 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.h</span>
<span class="p_header">+++ b/drivers/pinctrl/core.h</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,</span>
 }
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked);</span>
<span class="p_add">+			 bool dup);</span>
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
<span class="p_header">diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c</span>
<span class="p_header">index eda13de2e7c0..0bbf7d71b281 100644</span>
<span class="p_header">--- a/drivers/pinctrl/devicetree.c</span>
<span class="p_header">+++ b/drivers/pinctrl/devicetree.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,</span>
 	dt_map-&gt;num_maps = num_maps;
 	list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps);
 
<span class="p_del">-	return pinctrl_register_map(map, num_maps, false, true);</span>
<span class="p_add">+	return pinctrl_register_map(map, num_maps, false);</span>
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">index 0a7325361d29..5f57e3d35e26 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.c</span>
<span class="p_chunk">@@ -149,7 +149,6 @@</span> <span class="p_context"> static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);</span>
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);</span>
 
 /* Functions */
 
<span class="p_chunk">@@ -1352,11 +1351,11 @@</span> <span class="p_context"> static irqreturn_t twa_interrupt(int irq, void *dev_instance)</span>
 				}
 
 				/* Now complete the io */
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 				tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev-&gt;posted_request_count--;
<span class="p_del">-				tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, request_id);</span>
 			}
 
 			/* Check for valid status after each drain */
<span class="p_chunk">@@ -1414,26 +1413,6 @@</span> <span class="p_context"> static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm</span>
 	}
 } /* End twa_load_sgl() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1c, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twa_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
<span class="p_chunk">@@ -1612,9 +1591,11 @@</span> <span class="p_context"> static int twa_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
 			if (tw_dev-&gt;srb[i]) {
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+				struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1793,21 +1774,18 @@</span> <span class="p_context"> static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		twa_free_request_id(tw_dev, request_id);
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		break;
 	case 1:
<span class="p_del">-		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_del">-		twa_free_request_id(tw_dev, request_id);</span>
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		SCpnt-&gt;result = (DID_ERROR &lt;&lt; 16);
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		done(SCpnt);
<span class="p_add">+		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_add">+		twa_free_request_id(tw_dev, request_id);</span>
 		retval = 0;
 	}
 out:
<span class="p_chunk">@@ -1875,8 +1853,8 @@</span> <span class="p_context"> static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 				command_packet-&gt;sg_list[0].address = TW_CPU_TO_SGL(tw_dev-&gt;generic_buffer_phys[request_id]);
 				command_packet-&gt;sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
<span class="p_del">-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-				if (sg_count == 0)</span>
<span class="p_add">+				sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+				if (sg_count &lt; 0)</span>
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1991,15 +1969,6 @@</span> <span class="p_context"> static char *twa_string_lookup(twa_message_type *table, unsigned int code)</span>
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twa_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">index 040f7214e5b7..0fdc83cfa0e1 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.h</span>
<span class="p_chunk">@@ -324,11 +324,6 @@</span> <span class="p_context"> static twa_message_type twa_error_table[] = {</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE  1</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
<span class="p_header">diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c</span>
<span class="p_header">index 4de346017e9f..61702ac00d42 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.c</span>
<span class="p_chunk">@@ -303,26 +303,6 @@</span> <span class="p_context"> static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)</span>
 	return 0;
 } /* End twl_post_command_packet() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twl_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function hands scsi cdb&#39;s to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
<span class="p_chunk">@@ -370,8 +350,8 @@</span> <span class="p_context"> static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
<span class="p_del">-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-			if (sg_count == 0)</span>
<span class="p_add">+			sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+			if (sg_count &lt;= 0)</span>
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1116,15 +1096,6 @@</span> <span class="p_context"> out:</span>
 	return retval;
 } /* End twl_initialize_device_extension() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twl_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1265,11 +1236,11 @@</span> <span class="p_context"> static irqreturn_t twl_interrupt(int irq, void *dev_instance)</span>
 			}
 
 			/* Now complete the io */
<span class="p_add">+			scsi_dma_unmap(cmd);</span>
<span class="p_add">+			cmd-&gt;scsi_done(cmd);</span>
 			tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev-&gt;posted_request_count--;
<span class="p_del">-			tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-			twl_unmap_scsi_data(tw_dev, request_id);</span>
 		}
 
 		/* Check for another response interrupt */
<span class="p_chunk">@@ -1414,10 +1385,12 @@</span> <span class="p_context"> static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res</span>
 		if ((tw_dev-&gt;state[i] != TW_S_FINISHED) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
<span class="p_del">-			if (tw_dev-&gt;srb[i]) {</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twl_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+			struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+			if (cmd) {</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1521,9 +1494,6 @@</span> <span class="p_context"> static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
<span class="p_header">diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h</span>
<span class="p_header">index d474892701d4..fec6449c7595 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.h</span>
<span class="p_chunk">@@ -103,10 +103,6 @@</span> <span class="p_context"> static char *twl_aen_severity_table[] =</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">index 752624e6bc00..b327742b95ef 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.c</span>
<span class="p_chunk">@@ -1284,32 +1284,6 @@</span> <span class="p_context"> static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)</span>
 	return 0;
 } /* End tw_initialize_device_extension() */
 
<span class="p_del">-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (use_sg &lt; 0) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End tw_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
<span class="p_del">-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_unmap_scsi_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End tw_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1332,8 +1306,8 @@</span> <span class="p_context"> static int tw_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 			srb = tw_dev-&gt;srb[i];
 			if (srb != NULL) {
 				srb-&gt;result = (DID_RESET &lt;&lt; 16);
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[i]);</span>
<span class="p_add">+				scsi_dma_unmap(srb);</span>
<span class="p_add">+				srb-&gt;scsi_done(srb);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1780,8 +1754,8 @@</span> <span class="p_context"> static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)</span>
 	command_packet-&gt;byte8.io.lba = lba;
 	command_packet-&gt;byte6.block_count = num_sectors;
 
<span class="p_del">-	use_sg = tw_map_scsi_sg_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_add">+	use_sg = scsi_dma_map(srb);</span>
<span class="p_add">+	if (use_sg &lt;= 0)</span>
 		return 1;
 
 	scsi_for_each_sg(tw_dev-&gt;srb[request_id], sg, use_sg, i) {
<span class="p_chunk">@@ -1968,9 +1942,6 @@</span> <span class="p_context"> static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	switch (*command) {
 		case READ_10:
 		case READ_6:
<span class="p_chunk">@@ -2198,12 +2169,11 @@</span> <span class="p_context"> static irqreturn_t tw_interrupt(int irq, void *dev_instance)</span>
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
<span class="p_add">+					scsi_dma_unmap(tw_dev-&gt;srb[request_id]);</span>
<span class="p_add">+					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
 					tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev-&gt;posted_request_count--;
<span class="p_del">-					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-					</span>
<span class="p_del">-					tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
 				}
 			}
 				
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">index 49dcf03c631a..1d31858766ce 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.h</span>
<span class="p_chunk">@@ -195,11 +195,6 @@</span> <span class="p_context"> static unsigned char tw_sense_table[][4] =</span>
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE 1</span>
<span class="p_del">-#define TW_PHASE_SGLIST 2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 262ab837a704..9f77d23239a2 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index a299b82e6b09..44458696c7b6 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -900,6 +900,12 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	 */
 	if (*bflags &amp; BLIST_MAX_512)
 		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 512);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max 1024 sector transfer length for targets that report incorrect</span>
<span class="p_add">+	 * max/optimal lengths and relied on the old block layer safe default</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	else if (*bflags &amp; BLIST_MAX_1024)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 1024);</span>
 
 	/*
 	 * Some devices may not want to have a start command automatically
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 2dc2831840ca..8eb65f26fcae 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -299,11 +299,27 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 	return 0;
 }
 
<span class="p_add">+static void xen_console_update_evtchn(struct xencons_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+		int err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			info-&gt;evtchn = v;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		info-&gt;evtchn = xen_start_info-&gt;console.domU.evtchn;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void xen_console_resume(void)
 {
 	struct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);
<span class="p_del">-	if (info != NULL &amp;&amp; info-&gt;irq)</span>
<span class="p_add">+	if (info != NULL &amp;&amp; info-&gt;irq) {</span>
<span class="p_add">+		if (!xen_initial_domain())</span>
<span class="p_add">+			xen_console_update_evtchn(info);</span>
 		rebind_evtchn_irq(info-&gt;evtchn, info-&gt;irq);
<span class="p_add">+	}</span>
 }
 
 static void xencons_disconnect_backend(struct xencons_info *info)
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 60d05fc2c1c4..0d39ae4ff533 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -860,6 +860,7 @@</span> <span class="p_context"> static int atmel_prepare_tx_dma(struct uart_port *port)</span>
 	config.direction = DMA_MEM_TO_DEV;
 	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.dst_addr = port-&gt;mapbase + ATMEL_US_THR;
<span class="p_add">+	config.dst_maxburst = 1;</span>
 
 	ret = dmaengine_device_control(atmel_port-&gt;chan_tx,
 					DMA_SLAVE_CONFIG,
<span class="p_chunk">@@ -1024,6 +1025,7 @@</span> <span class="p_context"> static int atmel_prepare_rx_dma(struct uart_port *port)</span>
 	config.direction = DMA_DEV_TO_MEM;
 	config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.src_addr = port-&gt;mapbase + ATMEL_US_RHR;
<span class="p_add">+	config.src_maxburst = 1;</span>
 
 	ret = dmaengine_device_control(atmel_port-&gt;chan_rx,
 					DMA_SLAVE_CONFIG,
<span class="p_header">diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c</span>
<span class="p_header">index 68d4455f3cf9..3197872f307b 100644</span>
<span class="p_header">--- a/drivers/tty/serial/of_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/of_serial.c</span>
<span class="p_chunk">@@ -266,7 +266,6 @@</span> <span class="p_context"> static struct of_device_id of_platform_serial_table[] = {</span>
 	{ .compatible = &quot;ibm,qpace-nwp-serial&quot;,
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
<span class="p_del">-	{ .type = &quot;serial&quot;,         .data = (void *)PORT_UNKNOWN, },</span>
 	{ /* end of list */ },
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c</span>
<span class="p_header">index dce27f34937e..aade351c3192 100644</span>
<span class="p_header">--- a/drivers/tty/serial/uartlite.c</span>
<span class="p_header">+++ b/drivers/tty/serial/uartlite.c</span>
<span class="p_chunk">@@ -638,7 +638,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ulite_of_match);</span>
 
 static int ulite_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int irq;</span>
 	int id = pdev-&gt;id;
 #ifdef CONFIG_OF
 	const __be32 *prop;
<span class="p_chunk">@@ -652,11 +653,11 @@</span> <span class="p_context"> static int ulite_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
<span class="p_del">-	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, res2-&gt;start);</span>
<span class="p_add">+	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, irq);</span>
 }
 
 static int ulite_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">index 8809775e2ba3..efbfddf93471 100644</span>
<span class="p_header">--- a/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">+++ b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_chunk">@@ -1290,9 +1290,9 @@</span> <span class="p_context"> static SIMPLE_DEV_PM_OPS(cdns_uart_dev_pm_ops, cdns_uart_suspend,</span>
  */
 static int cdns_uart_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int rc, id;</span>
<span class="p_add">+	int rc, id, irq;</span>
 	struct uart_port *port;
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
 	struct cdns_uart *cdns_uart_data;
 
 	cdns_uart_data = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*cdns_uart_data),
<span class="p_chunk">@@ -1339,9 +1339,9 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2) {</span>
<span class="p_del">-		rc = -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0) {</span>
<span class="p_add">+		rc = -ENXIO;</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_chunk">@@ -1370,7 +1370,7 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		 * and triggers invocation of the config_port() entry point.
 		 */
 		port-&gt;mapbase = res-&gt;start;
<span class="p_del">-		port-&gt;irq = res2-&gt;start;</span>
<span class="p_add">+		port-&gt;irq = irq;</span>
 		port-&gt;dev = &amp;pdev-&gt;dev;
 		port-&gt;uartclk = clk_get_rate(cdns_uart_data-&gt;uartclk);
 		port-&gt;private_data = cdns_uart_data;
<span class="p_header">diff --git a/drivers/usb/chipidea/otg_fsm.c b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">index caaabc58021e..34a52cd7bfb7 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_chunk">@@ -537,7 +537,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on) {
 		ci_role_stop(ci);
 		ci_role_start(ci, CI_ROLE_HOST);
<span class="p_chunk">@@ -546,7 +545,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 		hw_device_reset(ci, USBMODE_CM_DC);
 		ci_role_start(ci, CI_ROLE_GADGET);
 	}
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -554,12 +552,10 @@</span> <span class="p_context"> static int ci_otg_start_gadget(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on)
 		usb_gadget_vbus_connect(&amp;ci-&gt;gadget);
 	else
 		usb_gadget_vbus_disconnect(&amp;ci-&gt;gadget);
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index bc2cacd3cb68..a8946e88978e 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1128,11 +1128,16 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	}
 
 	while (buflen &gt; 0) {
<span class="p_add">+		elength = buffer[0];</span>
<span class="p_add">+		if (!elength) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage byte\n&quot;);</span>
<span class="p_add">+			elength = 1;</span>
<span class="p_add">+			goto next_desc;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
 		}
<span class="p_del">-		elength = buffer[0];</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index 9893d696fc97..f58caa9e6a27 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -51,7 +51,8 @@</span> <span class="p_context"> static int uas_find_endpoints(struct usb_host_interface *alt,</span>
 }
 
 static int uas_use_uas_driver(struct usb_interface *intf,
<span class="p_del">-			      const struct usb_device_id *id)</span>
<span class="p_add">+			      const struct usb_device_id *id,</span>
<span class="p_add">+			      unsigned long *flags_ret)</span>
 {
 	struct usb_host_endpoint *eps[4] = { };
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 	 * this writing the following versions exist:
 	 * ASM1051 - no uas support version
 	 * ASM1051 - with broken (*) uas support
<span class="p_del">-	 * ASM1053 - with working uas support</span>
<span class="p_add">+	 * ASM1053 - with working uas support, but problems with large xfers</span>
 	 * ASM1153 - with working uas support
 	 *
 	 * Devices with these chips re-use a number of device-ids over the
<span class="p_chunk">@@ -103,6 +104,9 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		} else if (usb_ss_max_streams(&amp;eps[1]-&gt;ss_ep_comp) == 32) {
 			/* Possibly an ASM1051, disable uas */
 			flags |= US_FL_IGNORE_UAS;
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* ASM1053, these have issues with large transfers */</span>
<span class="p_add">+			flags |= US_FL_MAX_SECTORS_240;</span>
 		}
 	}
 
<span class="p_chunk">@@ -132,5 +136,8 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		return 0;
 	}
 
<span class="p_add">+	if (flags_ret)</span>
<span class="p_add">+		*flags_ret = flags;</span>
<span class="p_add">+</span>
 	return 1;
 }
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 27136935fec3..22b3b92ceda2 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -936,7 +936,10 @@</span> <span class="p_context"> static int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)</span>
 
 static int uas_slave_alloc(struct scsi_device *sdev)
 {
<span class="p_del">-	sdev-&gt;hostdata = (void *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+	struct uas_dev_info *devinfo =</span>
<span class="p_add">+		(struct uas_dev_info *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev-&gt;hostdata = devinfo;</span>
 
 	/* USB has unusual DMA-alignment requirements: Although the
 	 * starting address of each scatter-gather element doesn&#39;t matter,
<span class="p_chunk">@@ -955,6 +958,11 @@</span> <span class="p_context"> static int uas_slave_alloc(struct scsi_device *sdev)</span>
 	 */
 	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
<span class="p_add">+	if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_64)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 64);</span>
<span class="p_add">+	else if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_240)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 240);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1071,8 +1079,9 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	struct Scsi_Host *shost = NULL;
 	struct uas_dev_info *devinfo;
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_add">+	unsigned long dev_flags;</span>
 
<span class="p_del">-	if (!uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (!uas_use_uas_driver(intf, id, &amp;dev_flags))</span>
 		return -ENODEV;
 
 	if (uas_switch_interface(udev, intf))
<span class="p_chunk">@@ -1095,8 +1104,7 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	devinfo-&gt;resetting = 0;
 	devinfo-&gt;running_task = 0;
 	devinfo-&gt;shutdown = 0;
<span class="p_del">-	devinfo-&gt;flags = id-&gt;driver_info;</span>
<span class="p_del">-	usb_stor_adjust_quirks(udev, &amp;devinfo-&gt;flags);</span>
<span class="p_add">+	devinfo-&gt;flags = dev_flags;</span>
 	init_usb_anchor(&amp;devinfo-&gt;cmd_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;sense_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;data_urbs);
<span class="p_header">diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c</span>
<span class="p_header">index 20c5bcc6d3df..79323d008f2d 100644</span>
<span class="p_header">--- a/drivers/usb/storage/usb.c</span>
<span class="p_header">+++ b/drivers/usb/storage/usb.c</span>
<span class="p_chunk">@@ -477,7 +477,8 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
 			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
 			US_FL_INITIAL_READ10 | US_FL_WRITE_CACHE |
<span class="p_del">-			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES);</span>
<span class="p_add">+			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES |</span>
<span class="p_add">+			US_FL_MAX_SECTORS_240);</span>
 
 	p = quirks;
 	while (*p) {
<span class="p_chunk">@@ -518,6 +519,9 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 		case &#39;f&#39;:
 			f |= US_FL_NO_REPORT_OPCODES;
 			break;
<span class="p_add">+		case &#39;g&#39;:</span>
<span class="p_add">+			f |= US_FL_MAX_SECTORS_240;</span>
<span class="p_add">+			break;</span>
 		case &#39;h&#39;:
 			f |= US_FL_CAPACITY_HEURISTICS;
 			break;
<span class="p_chunk">@@ -1052,7 +1056,7 @@</span> <span class="p_context"> static int storage_probe(struct usb_interface *intf,</span>
 
 	/* If uas is enabled and this device can do uas then ignore it. */
 #if IS_ENABLED(CONFIG_USB_UAS)
<span class="p_del">-	if (uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (uas_use_uas_driver(intf, id, NULL))</span>
 		return -ENXIO;
 #endif
 
<span class="p_header">diff --git a/drivers/xen/events/events_2l.c b/drivers/xen/events/events_2l.c</span>
<span class="p_header">index 5db43fc100a4..7dd46312c180 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_2l.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_2l.c</span>
<span class="p_chunk">@@ -345,6 +345,15 @@</span> <span class="p_context"> irqreturn_t xen_debug_interrupt(int irq, void *dev_id)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_add">+static void evtchn_2l_resume(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_online_cpu(i)</span>
<span class="p_add">+		memset(per_cpu(cpu_evtchn_mask, i), 0, sizeof(xen_ulong_t) *</span>
<span class="p_add">+				EVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct evtchn_ops evtchn_ops_2l = {
 	.max_channels      = evtchn_2l_max_channels,
 	.nr_channels       = evtchn_2l_max_channels,
<span class="p_chunk">@@ -356,6 +365,7 @@</span> <span class="p_context"> static const struct evtchn_ops evtchn_ops_2l = {</span>
 	.mask              = evtchn_2l_mask,
 	.unmask            = evtchn_2l_unmask,
 	.handle_events     = evtchn_2l_handle_events,
<span class="p_add">+	.resume	           = evtchn_2l_resume,</span>
 };
 
 void __init xen_evtchn_2l_init(void)
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 82fbb0cd8f65..31ac2eec06e4 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -529,8 +529,8 @@</span> <span class="p_context"> static unsigned int __startup_pirq(unsigned int irq)</span>
 	if (rc)
 		goto err;
 
<span class="p_del">-	bind_evtchn_to_cpu(evtchn, 0);</span>
 	info-&gt;evtchn = evtchn;
<span class="p_add">+	bind_evtchn_to_cpu(evtchn, 0);</span>
 
 	rc = xen_evtchn_port_setup(info);
 	if (rc)
<span class="p_chunk">@@ -1278,8 +1278,9 @@</span> <span class="p_context"> void rebind_evtchn_irq(int evtchn, int irq)</span>
 
 	mutex_unlock(&amp;irq_mapping_update_lock);
 
<span class="p_del">-	/* new event channels are always bound to cpu 0 */</span>
<span class="p_del">-	irq_set_affinity(irq, cpumask_of(0));</span>
<span class="p_add">+        bind_evtchn_to_cpu(evtchn, info-&gt;cpu);</span>
<span class="p_add">+	/* This will be deferred until interrupt is processed */</span>
<span class="p_add">+	irq_set_affinity(irq, cpumask_of(info-&gt;cpu));</span>
 
 	/* Unmask the event channel. */
 	enable_irq(irq);
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 75fe3d466515..9c234209d8b5 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -16,8 +16,8 @@</span> <span class="p_context"></span>
 #include &quot;conf_space.h&quot;
 #include &quot;conf_space_quirks.h&quot;
 
<span class="p_del">-bool permissive;</span>
<span class="p_del">-module_param(permissive, bool, 0644);</span>
<span class="p_add">+bool xen_pcibk_permissive;</span>
<span class="p_add">+module_param_named(permissive, xen_pcibk_permissive, bool, 0644);</span>
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
  * xen_pcibk_write_config_word, and xen_pcibk_write_config_byte are created. */
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)</span>
 		 * This means that some fields may still be read-only because
 		 * they have entries in the config_field list that intercept
 		 * the write and do nothing. */
<span class="p_del">-		if (dev_data-&gt;permissive || permissive) {</span>
<span class="p_add">+		if (dev_data-&gt;permissive || xen_pcibk_permissive) {</span>
 			switch (size) {
 			case 1:
 				err = pci_write_config_byte(dev, offset,
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.h b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">index 2e1d73d1d5d0..62461a8ba1d6 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> struct config_field_entry {</span>
 	void *data;
 };
 
<span class="p_del">-extern bool permissive;</span>
<span class="p_add">+extern bool xen_pcibk_permissive;</span>
 
 #define OFFSET(cfg_entry) ((cfg_entry)-&gt;base_offset+(cfg_entry)-&gt;field-&gt;offset)
 
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space_header.c b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">index 2d7369391472..f8baf463dd35 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 
 	cmd-&gt;val = value;
 
<span class="p_del">-	if (!permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
<span class="p_add">+	if (!xen_pcibk_permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
 		return 0;
 
 	/* Only allow the guest to control certain bits. */
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_probe.c b/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_header">index 3c0a74b3e9b1..7d6de403e450 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_chunk">@@ -57,6 +57,7 @@</span> <span class="p_context"></span>
 #include &lt;xen/xen.h&gt;
 #include &lt;xen/xenbus.h&gt;
 #include &lt;xen/events.h&gt;
<span class="p_add">+#include &lt;xen/xen-ops.h&gt;</span>
 #include &lt;xen/page.h&gt;
 
 #include &lt;xen/hvm.h&gt;
<span class="p_chunk">@@ -731,6 +732,30 @@</span> <span class="p_context"> static int __init xenstored_local_init(void)</span>
 	return err;
 }
 
<span class="p_add">+static int xenbus_resume_cb(struct notifier_block *nb,</span>
<span class="p_add">+			    unsigned long action, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			xen_store_evtchn = v;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pr_warn(&quot;Cannot update xenstore event channel: %d\n&quot;,</span>
<span class="p_add">+				err);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		xen_store_evtchn = xen_start_info-&gt;store_evtchn;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block xenbus_resume_nb = {</span>
<span class="p_add">+	.notifier_call = xenbus_resume_cb,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init xenbus_init(void)
 {
 	int err = 0;
<span class="p_chunk">@@ -789,6 +814,10 @@</span> <span class="p_context"> static int __init xenbus_init(void)</span>
 		goto out_error;
 	}
 
<span class="p_add">+	if ((xen_store_domain_type != XS_LOCAL) &amp;&amp;</span>
<span class="p_add">+	    (xen_store_domain_type != XS_UNKNOWN))</span>
<span class="p_add">+		xen_resume_notifier_register(&amp;xenbus_resume_nb);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_XEN_COMPAT_XENFS
 	/*
 	 * Create xenfs mountpoint in /proc for compatibility with
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 5576abb92a23..7c5f053ee42c 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2451,7 +2451,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 			&quot;Attempt to delete subvolume %llu during send&quot;,
 			dest-&gt;root_key.objectid);
 		err = -EPERM;
<span class="p_del">-		goto out_dput;</span>
<span class="p_add">+		goto out_unlock_inode;</span>
 	}
 
 	err = d_invalidate(dentry);
<span class="p_chunk">@@ -2549,6 +2549,7 @@</span> <span class="p_context"> out_unlock:</span>
 				root_flags &amp; ~BTRFS_ROOT_SUBVOL_DEAD);
 		spin_unlock(&amp;dest-&gt;root_item_lock);
 	}
<span class="p_add">+out_unlock_inode:</span>
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	if (!err) {
 		shrink_dcache_sb(root-&gt;fs_info-&gt;sb);
<span class="p_header">diff --git a/fs/efivarfs/super.c b/fs/efivarfs/super.c</span>
<span class="p_header">index 0a48886e069c..c2f421c30ccd 100644</span>
<span class="p_header">--- a/fs/efivarfs/super.c</span>
<span class="p_header">+++ b/fs/efivarfs/super.c</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,</span>
 	int len, i;
 	int err = -ENOMEM;
 
<span class="p_del">-	entry = kmalloc(sizeof(*entry), GFP_KERNEL);</span>
<span class="p_add">+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);</span>
 	if (!entry)
 		return err;
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index cdfe574ba3d9..99d74306e770 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4933,13 +4933,6 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="p_del">-	 * files _only_</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
 	if (mode &amp; FALLOC_FL_COLLAPSE_RANGE)
 		return ext4_collapse_range(inode, offset, len);
 
<span class="p_chunk">@@ -4961,6 +4954,14 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only support preallocation for extent-based files only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {</span>
<span class="p_add">+		ret = -EOPNOTSUPP;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
 	     offset + len &gt; i_size_read(inode)) {
 		new_size = offset + len;
<span class="p_header">diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c</span>
<span class="p_header">index 0b7e28e7eaa4..4880ae8a9dce 100644</span>
<span class="p_header">--- a/fs/ext4/extents_status.c</span>
<span class="p_header">+++ b/fs/ext4/extents_status.c</span>
<span class="p_chunk">@@ -662,6 +662,14 @@</span> <span class="p_context"> int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,</span>
 
 	BUG_ON(end &lt; lblk);
 
<span class="p_add">+	if ((status &amp; EXTENT_STATUS_DELAYED) &amp;&amp;</span>
<span class="p_add">+	    (status &amp; EXTENT_STATUS_WRITTEN)) {</span>
<span class="p_add">+		ext4_warning(inode-&gt;i_sb, &quot;Inserting extent [%u/%u] as &quot;</span>
<span class="p_add">+				&quot; delayed and written which can potentially &quot;</span>
<span class="p_add">+				&quot; cause data loss.\n&quot;, lblk, len);</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	newes.es_lblk = lblk;
 	newes.es_len = len;
 	ext4_es_store_pblock_status(&amp;newes, pblk, status);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 02408b9c2874..6a37a1f51e56 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -577,6 +577,7 @@</span> <span class="p_context"> int ext4_map_blocks(handle_t *handle, struct inode *inode,</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_chunk">@@ -691,6 +692,7 @@</span> <span class="p_context"> found:</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 19ac9c89dbab..15fc3f5a5007 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -3194,7 +3194,7 @@</span> <span class="p_context"> static struct file *path_openat(int dfd, struct filename *pathname,</span>
 
 	if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) {
 		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &amp;opened);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out2;</span>
 	}
 
 	error = path_init(dfd, pathname-&gt;name, flags | LOOKUP_PARENT, nd, &amp;base);
<span class="p_chunk">@@ -3232,6 +3232,7 @@</span> <span class="p_context"> out:</span>
 		path_put(&amp;nd-&gt;root);
 	if (base)
 		fput(base);
<span class="p_add">+out2:</span>
 	if (!(opened &amp; FILE_OPENED)) {
 		BUG_ON(!error);
 		put_filp(file);
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index d74c67678bb1..6dfb6fc34286 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1579,8 +1579,11 @@</span> <span class="p_context"> struct vfsmount *collect_mounts(struct path *path)</span>
 {
 	struct mount *tree;
 	namespace_lock();
<span class="p_del">-	tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry,</span>
<span class="p_del">-			 CL_COPY_ALL | CL_PRIVATE);</span>
<span class="p_add">+	if (!check_mnt(real_mount(path-&gt;mnt)))</span>
<span class="p_add">+		tree = ERR_PTR(-EINVAL);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry,</span>
<span class="p_add">+				 CL_COPY_ALL | CL_PRIVATE);</span>
 	namespace_unlock();
 	if (IS_ERR(tree))
 		return ERR_CAST(tree);
<span class="p_chunk">@@ -3035,6 +3038,12 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_sb-&gt;s_type != type)
 			continue;
 
<span class="p_add">+		/* This mount is not fully visible if it&#39;s root directory</span>
<span class="p_add">+		 * is not the root directory of the filesystem.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		/* This mount is not fully visible if there are any child mounts
 		 * that cover anything except for empty directories.
 		 */
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index ecdbae19a766..090d8ce25bd1 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||
<span class="p_del">-		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     level &gt;= NILFS_BTREE_LEVEL_MAX ||</span>
 		     nchildren &lt; 0 ||
 		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 9d405d6d2504..7b9f96899812 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -768,6 +768,19 @@</span> <span class="p_context"> lookup:</span>
 	if (tmpres) {
 		spin_unlock(&amp;dlm-&gt;spinlock);
 		spin_lock(&amp;tmpres-&gt;spinlock);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right after dlm spinlock was released, dlm_thread could have</span>
<span class="p_add">+		 * purged the lockres. Check if lockres got unhashed. If so</span>
<span class="p_add">+		 * start over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hlist_unhashed(&amp;tmpres-&gt;hash_node)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmpres-&gt;spinlock);</span>
<span class="p_add">+			dlm_lockres_put(tmpres);</span>
<span class="p_add">+			tmpres = NULL;</span>
<span class="p_add">+			goto lookup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres-&gt;owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index 055459999660..c768860e22ab 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -361,7 +361,8 @@</span> <span class="p_context"> STATIC int				/* error (positive) */</span>
 xfs_zero_last_block(
 	struct xfs_inode	*ip,
 	xfs_fsize_t		offset,
<span class="p_del">-	xfs_fsize_t		isize)</span>
<span class="p_add">+	xfs_fsize_t		isize,</span>
<span class="p_add">+	bool			*did_zeroing)</span>
 {
 	struct xfs_mount	*mp = ip-&gt;i_mount;
 	xfs_fileoff_t		last_fsb = XFS_B_TO_FSBT(mp, isize);
<span class="p_chunk">@@ -389,6 +390,7 @@</span> <span class="p_context"> xfs_zero_last_block(</span>
 	zero_len = mp-&gt;m_sb.sb_blocksize - zero_offset;
 	if (isize + zero_len &gt; offset)
 		zero_len = offset - isize;
<span class="p_add">+	*did_zeroing = true;</span>
 	return xfs_iozero(ip, isize, zero_len);
 }
 
<span class="p_chunk">@@ -407,7 +409,8 @@</span> <span class="p_context"> int					/* error (positive) */</span>
 xfs_zero_eof(
 	struct xfs_inode	*ip,
 	xfs_off_t		offset,		/* starting I/O offset */
<span class="p_del">-	xfs_fsize_t		isize)		/* current inode size */</span>
<span class="p_add">+	xfs_fsize_t		isize,		/* current inode size */</span>
<span class="p_add">+	bool			*did_zeroing)</span>
 {
 	struct xfs_mount	*mp = ip-&gt;i_mount;
 	xfs_fileoff_t		start_zero_fsb;
<span class="p_chunk">@@ -429,7 +432,7 @@</span> <span class="p_context"> xfs_zero_eof(</span>
 	 * We only zero a part of that block so it is handled specially.
 	 */
 	if (XFS_B_FSB_OFFSET(mp, isize) != 0) {
<span class="p_del">-		error = xfs_zero_last_block(ip, offset, isize);</span>
<span class="p_add">+		error = xfs_zero_last_block(ip, offset, isize, did_zeroing);</span>
 		if (error)
 			return error;
 	}
<span class="p_chunk">@@ -489,6 +492,7 @@</span> <span class="p_context"> xfs_zero_eof(</span>
 		if (error)
 			return error;
 
<span class="p_add">+		*did_zeroing = true;</span>
 		start_zero_fsb = imap.br_startoff + imap.br_blockcount;
 		ASSERT(start_zero_fsb &lt;= (end_zero_fsb + 1));
 	}
<span class="p_chunk">@@ -527,13 +531,15 @@</span> <span class="p_context"> restart:</span>
 	 * having to redo all checks before.
 	 */
 	if (*pos &gt; i_size_read(inode)) {
<span class="p_add">+		bool	zero = false;</span>
<span class="p_add">+</span>
 		if (*iolock == XFS_IOLOCK_SHARED) {
 			xfs_rw_iunlock(ip, *iolock);
 			*iolock = XFS_IOLOCK_EXCL;
 			xfs_rw_ilock(ip, *iolock);
 			goto restart;
 		}
<span class="p_del">-		error = -xfs_zero_eof(ip, *pos, i_size_read(inode));</span>
<span class="p_add">+		error = -xfs_zero_eof(ip, *pos, i_size_read(inode), &amp;zero);</span>
 		if (error)
 			return error;
 	}
<span class="p_header">diff --git a/fs/xfs/xfs_inode.h b/fs/xfs/xfs_inode.h</span>
<span class="p_header">index f72bffa67266..f8397df396d7 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.h</span>
<span class="p_chunk">@@ -379,8 +379,9 @@</span> <span class="p_context"> int		xfs_droplink(struct xfs_trans *, struct xfs_inode *);</span>
 int		xfs_bumplink(struct xfs_trans *, struct xfs_inode *);
 
 /* from xfs_file.c */
<span class="p_del">-int		xfs_zero_eof(struct xfs_inode *, xfs_off_t, xfs_fsize_t);</span>
<span class="p_del">-int		xfs_iozero(struct xfs_inode *, loff_t, size_t);</span>
<span class="p_add">+int	xfs_zero_eof(struct xfs_inode *ip, xfs_off_t offset,</span>
<span class="p_add">+		     xfs_fsize_t isize, bool *did_zeroing);</span>
<span class="p_add">+int	xfs_iozero(struct xfs_inode *ip, loff_t pos, size_t count);</span>
 
 
 #define IHOLD(ip) \
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index 205613a06068..537d8daeaa9e 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -744,6 +744,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	int			error;
 	uint			lock_flags = 0;
 	uint			commit_flags = 0;
<span class="p_add">+	bool			did_zeroing = false;</span>
 
 	trace_xfs_setattr(ip);
 
<span class="p_chunk">@@ -787,20 +788,16 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 		return error;
 
 	/*
<span class="p_del">-	 * Now we can make the changes.  Before we join the inode to the</span>
<span class="p_del">-	 * transaction, take care of the part of the truncation that must be</span>
<span class="p_del">-	 * done without the inode lock.  This needs to be done before joining</span>
<span class="p_del">-	 * the inode to the transaction, because the inode cannot be unlocked</span>
<span class="p_del">-	 * once it is a part of the transaction.</span>
<span class="p_add">+	 * File data changes must be complete before we start the transaction to</span>
<span class="p_add">+	 * modify the inode.  This needs to be done before joining the inode to</span>
<span class="p_add">+	 * the transaction because the inode cannot be unlocked once it is a</span>
<span class="p_add">+	 * part of the transaction.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Start with zeroing any data block beyond EOF that we may expose on</span>
<span class="p_add">+	 * file extension.</span>
 	 */
 	if (newsize &gt; oldsize) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Do the first part of growing a file: zero any data in the</span>
<span class="p_del">-		 * last block that is beyond the old EOF.  We need to do this</span>
<span class="p_del">-		 * before the inode is joined to the transaction to modify</span>
<span class="p_del">-		 * i_size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		error = xfs_zero_eof(ip, newsize, oldsize);</span>
<span class="p_add">+		error = xfs_zero_eof(ip, newsize, oldsize, &amp;did_zeroing);</span>
 		if (error)
 			return error;
 	}
<span class="p_chunk">@@ -810,23 +807,18 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	 * any previous writes that are beyond the on disk EOF and the new
 	 * EOF that have not been written out need to be written here.  If we
 	 * do not write the data out, we expose ourselves to the null files
<span class="p_del">-	 * problem.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Only flush from the on disk size to the smaller of the in memory</span>
<span class="p_del">-	 * file size or the new size as that&#39;s the range we really care about</span>
<span class="p_del">-	 * here and prevents waiting for other data not within the range we</span>
<span class="p_del">-	 * care about here.</span>
<span class="p_add">+	 * problem. Note that this includes any block zeroing we did above;</span>
<span class="p_add">+	 * otherwise those blocks may not be zeroed after a crash.</span>
 	 */
<span class="p_del">-	if (oldsize != ip-&gt;i_d.di_size &amp;&amp; newsize &gt; ip-&gt;i_d.di_size) {</span>
<span class="p_add">+	if (newsize &gt; ip-&gt;i_d.di_size &amp;&amp;</span>
<span class="p_add">+	    (oldsize != ip-&gt;i_d.di_size || did_zeroing)) {</span>
 		error = -filemap_write_and_wait_range(VFS_I(ip)-&gt;i_mapping,
 						      ip-&gt;i_d.di_size, newsize);
 		if (error)
 			return error;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Wait for all direct I/O to complete.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Now wait for all direct I/O to complete. */</span>
 	inode_dio_wait(inode);
 
 	/*
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index 6c77a132b53b..664a1a4b6f6a 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -416,13 +416,13 @@</span> <span class="p_context"> ACPI_EXTERNAL_RETURN_STATUS(acpi_status __init acpi_load_tables(void))</span>
 ACPI_EXTERNAL_RETURN_STATUS(acpi_status __init acpi_reallocate_root_table(void))
 
 ACPI_EXTERNAL_RETURN_STATUS(acpi_status __init
<span class="p_del">-			    acpi_find_root_pointer(acpi_size * rsdp_address))</span>
<span class="p_del">-</span>
<span class="p_add">+			    acpi_find_root_pointer(acpi_physical_address *</span>
<span class="p_add">+						   rsdp_address))</span>
 ACPI_EXTERNAL_RETURN_STATUS(acpi_status
<span class="p_del">-			    acpi_get_table_header(acpi_string signature,</span>
<span class="p_del">-						  u32 instance,</span>
<span class="p_del">-						  struct acpi_table_header</span>
<span class="p_del">-						  *out_table_header))</span>
<span class="p_add">+			     acpi_get_table_header(acpi_string signature,</span>
<span class="p_add">+						   u32 instance,</span>
<span class="p_add">+						   struct acpi_table_header</span>
<span class="p_add">+						   *out_table_header))</span>
 ACPI_EXTERNAL_RETURN_STATUS(acpi_status
 			     acpi_get_table(acpi_string signature, u32 instance,
 					    struct acpi_table_header
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 19b26bb69a70..f0a23d7fd302 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int s32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index e863dd5c4e04..7049af0108b3 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"></span>
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
<span class="p_header">diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h</span>
<span class="p_header">index 6d9aeddc09bf..327b155e7cc9 100644</span>
<span class="p_header">--- a/include/kvm/arm_arch_timer.h</span>
<span class="p_header">+++ b/include/kvm/arm_arch_timer.h</span>
<span class="p_chunk">@@ -60,7 +60,8 @@</span> <span class="p_context"> struct arch_timer_cpu {</span>
 
 #ifdef CONFIG_KVM_ARM_TIMER
 int kvm_timer_hyp_init(void);
<span class="p_del">-int kvm_timer_init(struct kvm *kvm);</span>
<span class="p_add">+void kvm_timer_enable(struct kvm *kvm);</span>
<span class="p_add">+void kvm_timer_init(struct kvm *kvm);</span>
 void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 			  const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
<span class="p_chunk">@@ -73,11 +74,8 @@</span> <span class="p_context"> static inline int kvm_timer_hyp_init(void)</span>
 	return 0;
 };
 
<span class="p_del">-static inline int kvm_timer_init(struct kvm *kvm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_add">+static inline void kvm_timer_enable(struct kvm *kvm) {}</span>
<span class="p_add">+static inline void kvm_timer_init(struct kvm *kvm) {}</span>
 static inline void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 					const struct kvm_irq_level *irq) {}
 static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
<span class="p_header">diff --git a/include/linux/efi.h b/include/linux/efi.h</span>
<span class="p_header">index 41bbf8ba4ba8..b3fac7c1656c 100644</span>
<span class="p_header">--- a/include/linux/efi.h</span>
<span class="p_header">+++ b/include/linux/efi.h</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/ioport.h&gt;
 #include &lt;linux/pfn.h&gt;
 #include &lt;linux/pstore.h&gt;
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
 
 #include &lt;asm/page.h&gt;
 
<span class="p_chunk">@@ -875,6 +876,9 @@</span> <span class="p_context"> extern void efi_reserve_boot_services(void);</span>
 extern int efi_get_fdt_params(struct efi_fdt_params *params, int verbose);
 extern struct efi_memory_map memmap;
 
<span class="p_add">+extern int efi_reboot_quirk_mode;</span>
<span class="p_add">+extern bool efi_poweroff_required(void);</span>
<span class="p_add">+</span>
 /* Iterate through an efi_memory_map */
 #define for_each_efi_memory_desc(m, md)					   \
 	for ((md) = (m)-&gt;map;						   \
<span class="p_chunk">@@ -926,11 +930,14 @@</span> <span class="p_context"> static inline bool efi_enabled(int feature)</span>
 {
 	return test_bit(feature, &amp;efi.flags) != 0;
 }
<span class="p_add">+extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);</span>
 #else
 static inline bool efi_enabled(int feature)
 {
 	return false;
 }
<span class="p_add">+static inline void</span>
<span class="p_add">+efi_reboot(enum reboot_mode reboot_mode, const char *__unused) {}</span>
 #endif
 
 /*
<span class="p_header">diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h</span>
<span class="p_header">index ff3fea3194c6..9abb763e4b86 100644</span>
<span class="p_header">--- a/include/linux/nilfs2_fs.h</span>
<span class="p_header">+++ b/include/linux/nilfs2_fs.h</span>
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> struct nilfs_btree_node {</span>
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
<span class="p_del">-#define NILFS_BTREE_LEVEL_MAX           14</span>
<span class="p_add">+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */</span>
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
<span class="p_header">diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h</span>
<span class="p_header">index a7f2604c5f25..7f5f78bd15ad 100644</span>
<span class="p_header">--- a/include/linux/usb_usual.h</span>
<span class="p_header">+++ b/include/linux/usb_usual.h</span>
<span class="p_chunk">@@ -77,6 +77,8 @@</span> <span class="p_context"></span>
 		/* Cannot handle ATA_12 or ATA_16 CDBs */	\
 	US_FLAG(NO_REPORT_OPCODES,	0x04000000)		\
 		/* Cannot handle MI_REPORT_SUPPORTED_OPERATION_CODES */	\
<span class="p_add">+	US_FLAG(MAX_SECTORS_240,	0x08000000)		\</span>
<span class="p_add">+		/* Sets max_sectors to 240 */			\</span>
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index 183eaab7c380..96e3f56519e7 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -36,5 +36,6 @@</span> <span class="p_context"></span>
 					     for sequential scan */
 #define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
 #define BLIST_NO_RSOC		0x20000000 /* don&#39;t try to issue RSOC */
<span class="p_add">+#define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */</span>
 
 #endif
<span class="p_header">diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h</span>
<span class="p_header">index c46908c1bb3f..8af2fff0eb08 100644</span>
<span class="p_header">--- a/include/sound/emu10k1.h</span>
<span class="p_header">+++ b/include/sound/emu10k1.h</span>
<span class="p_chunk">@@ -41,7 +41,8 @@</span> <span class="p_context"></span>
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
<span class="p_del">-#define MAXPAGES        8192</span>
<span class="p_add">+#define MAXPAGES0       4096	/* 32 bit mode */</span>
<span class="p_add">+#define MAXPAGES1       8192	/* 31 bit mode */</span>
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
<span class="p_chunk">@@ -50,8 +51,7 @@</span> <span class="p_context"></span>
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
<span class="p_del">-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */</span>
<span class="p_del">-						/* See ALSA bug #1276 - rlrevell */</span>
<span class="p_add">+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */</span>
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
<span class="p_chunk">@@ -466,8 +466,11 @@</span> <span class="p_context"></span>
 
 #define MAPB			0x0d		/* Cache map B						*/
 
<span class="p_del">-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_del">-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
<span class="p_add">+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
 
 /* 0x0e, 0x0f: Not used */
 
<span class="p_chunk">@@ -1704,6 +1707,7 @@</span> <span class="p_context"> struct snd_emu10k1 {</span>
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
<span class="p_add">+	unsigned int address_mode;		/* address mode */</span>
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
<span class="p_header">diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h</span>
<span class="p_header">index 6b59471cdf44..f7c0a020518b 100644</span>
<span class="p_header">--- a/include/sound/soc-dapm.h</span>
<span class="p_header">+++ b/include/sound/soc-dapm.h</span>
<span class="p_chunk">@@ -287,7 +287,7 @@</span> <span class="p_context"> struct device;</span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
<span class="p_del">-	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }</span>
<span class="p_add">+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 1) }</span>
 #define SOC_DAPM_SINGLE_TLV_VIRT(xname, max, tlv_array) \
 	SOC_DAPM_SINGLE(xname, SND_SOC_NOPM, 0, max, 0, tlv_array)
 #define SOC_DAPM_ENUM(xname, xenum) \
<span class="p_header">diff --git a/kernel/sched/auto_group.c b/kernel/sched/auto_group.c</span>
<span class="p_header">index e73efba98301..798e912842d5 100644</span>
<span class="p_header">--- a/kernel/sched/auto_group.c</span>
<span class="p_header">+++ b/kernel/sched/auto_group.c</span>
<span class="p_chunk">@@ -87,8 +87,7 @@</span> <span class="p_context"> static inline struct autogroup *autogroup_create(void)</span>
 	 * so we don&#39;t have to move tasks around upon policy change,
 	 * or flail around trying to allocate bandwidth on the fly.
 	 * A bandwidth exception in __sched_setscheduler() allows
<span class="p_del">-	 * the policy change to proceed.  Thereafter, task_group()</span>
<span class="p_del">-	 * returns &amp;root_task_group, so zero bandwidth is required.</span>
<span class="p_add">+	 * the policy change to proceed.</span>
 	 */
 	free_rt_sched_group(tg);
 	tg-&gt;rt_se = root_task_group.rt_se;
<span class="p_chunk">@@ -115,9 +114,6 @@</span> <span class="p_context"> bool task_wants_autogroup(struct task_struct *p, struct task_group *tg)</span>
 	if (tg != &amp;root_task_group)
 		return false;
 
<span class="p_del">-	if (p-&gt;sched_class != &amp;fair_sched_class)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
 	/*
 	 * We can only assume the task group can&#39;t go away on us if
 	 * autogroup_move_group() can see us on -&gt;thread_group list.
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 847922e4ba67..6356f644a47b 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -7348,6 +7348,12 @@</span> <span class="p_context"> static inline int tg_has_rt_tasks(struct task_group *tg)</span>
 {
 	struct task_struct *g, *p;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Autogroups do not have RT tasks; see autogroup_create().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (task_group_is_autogroup(tg))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	do_each_thread(g, p) {
 		if (rt_task(p) &amp;&amp; task_rq(p)-&gt;rt.tg == tg)
 			return 1;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 1e080a06e6ba..5f217e906ff9 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3723,7 +3723,8 @@</span> <span class="p_context"> retry:</span>
 	if (!pmd_huge(*pmd))
 		goto out;
 	if (pmd_present(*pmd)) {
<span class="p_del">-		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		page = pte_page(*(pte_t *)pmd) +</span>
<span class="p_add">+			((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 607a6d62bcab..fad245565616 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1153,10 +1153,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * The check (unnecessarily) ignores LRU pages being isolated and
 	 * walked by the page reclaim code, however that&#39;s not a big loss.
 	 */
<span class="p_del">-	if (!PageHuge(p) &amp;&amp; !PageTransTail(p)) {</span>
<span class="p_del">-		if (!PageLRU(p))</span>
<span class="p_del">-			shake_page(p, 0);</span>
<span class="p_del">-		if (!PageLRU(p)) {</span>
<span class="p_add">+	if (!PageHuge(p)) {</span>
<span class="p_add">+		if (!PageLRU(hpage))</span>
<span class="p_add">+			shake_page(hpage, 0);</span>
<span class="p_add">+		if (!PageLRU(hpage)) {</span>
 			/*
 			 * shake_page could have turned it free.
 			 */
<span class="p_chunk">@@ -1723,12 +1723,12 @@</span> <span class="p_context"> int soft_offline_page(struct page *page, int flags)</span>
 	} else if (ret == 0) { /* for free pages */
 		if (PageHuge(page)) {
 			set_page_hwpoison_huge_page(hpage);
<span class="p_del">-			dequeue_hwpoisoned_huge_page(hpage);</span>
<span class="p_del">-			atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
<span class="p_add">+			if (!dequeue_hwpoisoned_huge_page(hpage))</span>
<span class="p_add">+				atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
 					&amp;num_poisoned_pages);
 		} else {
<span class="p_del">-			SetPageHWPoison(page);</span>
<span class="p_del">-			atomic_long_inc(&amp;num_poisoned_pages);</span>
<span class="p_add">+			if (!TestSetPageHWPoison(page))</span>
<span class="p_add">+				atomic_long_inc(&amp;num_poisoned_pages);</span>
 		}
 	}
 	unset_migratetype_isolate(page, MIGRATE_MOVABLE);
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index 6a3348761648..a6fd1a3615f9 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static long long pos_ratio_polynom(unsigned long setpoint,</span>
 	long x;
 
 	x = div64_s64(((s64)setpoint - (s64)dirty) &lt;&lt; RATELIMIT_CALC_SHIFT,
<span class="p_del">-		    limit - setpoint + 1);</span>
<span class="p_add">+		      (limit - setpoint) | 1);</span>
 	pos_ratio = x;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
<span class="p_chunk">@@ -810,7 +810,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 * scale global setpoint to bdi&#39;s:
 	 *	bdi_setpoint = setpoint * bdi_thresh / thresh
 	 */
<span class="p_del">-	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh + 1);</span>
<span class="p_add">+	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh | 1);</span>
 	bdi_setpoint = setpoint * (u64)x &gt;&gt; 16;
 	/*
 	 * Use span=(8*write_bw) in single bdi case as indicated by
<span class="p_chunk">@@ -825,7 +825,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 
 	if (bdi_dirty &lt; x_intercept - span / 4) {
 		pos_ratio = div64_u64(pos_ratio * (x_intercept - bdi_dirty),
<span class="p_del">-				    x_intercept - bdi_setpoint + 1);</span>
<span class="p_add">+				      (x_intercept - bdi_setpoint) | 1);</span>
 	} else
 		pos_ratio /= 4;
 
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index 5df05269d17a..d8b1833a363e 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static int nlmsg_populate_mdb_fill(struct sk_buff *skb,</span>
 	struct br_port_msg *bpm;
 	struct nlattr *nest, *nest2;
 
<span class="p_del">-	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);</span>
<span class="p_add">+	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), 0);</span>
 	if (!nlh)
 		return -EMSGSIZE;
 
<span class="p_header">diff --git a/net/ceph/crush/mapper.c b/net/ceph/crush/mapper.c</span>
<span class="p_header">index a1ef53c04415..b1f2d1f44d37 100644</span>
<span class="p_header">--- a/net/ceph/crush/mapper.c</span>
<span class="p_header">+++ b/net/ceph/crush/mapper.c</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> static int is_out(const struct crush_map *map,</span>
  * @type: the type of item to choose
  * @out: pointer to output vector
  * @outpos: our position in that vector
<span class="p_add">+ * @out_size: size of the out vector</span>
  * @tries: number of attempts to make
  * @recurse_tries: number of attempts to have recursive chooseleaf make
  * @local_retries: localized retries
<span class="p_chunk">@@ -304,6 +305,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 			       const __u32 *weight, int weight_max,
 			       int x, int numrep, int type,
 			       int *out, int outpos,
<span class="p_add">+			       int out_size,</span>
 			       unsigned int tries,
 			       unsigned int recurse_tries,
 			       unsigned int local_retries,
<span class="p_chunk">@@ -322,6 +324,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 	int item = 0;
 	int itemtype;
 	int collide, reject;
<span class="p_add">+	int count = out_size;</span>
 
 	dprintk(&quot;CHOOSE%s bucket %d x %d outpos %d numrep %d tries %d recurse_tries %d local_retries %d local_fallback_retries %d parent_r %d\n&quot;,
 		recurse_to_leaf ? &quot;_LEAF&quot; : &quot;&quot;,
<span class="p_chunk">@@ -329,7 +332,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 		tries, recurse_tries, local_retries, local_fallback_retries,
 		parent_r);
 
<span class="p_del">-	for (rep = outpos; rep &lt; numrep; rep++) {</span>
<span class="p_add">+	for (rep = outpos; rep &lt; numrep &amp;&amp; count &gt; 0 ; rep++) {</span>
 		/* keep trying until we get a non-out, non-colliding item */
 		ftotal = 0;
 		skip_rep = 0;
<span class="p_chunk">@@ -403,7 +406,7 @@</span> <span class="p_context"> static int crush_choose_firstn(const struct crush_map *map,</span>
 							 map-&gt;buckets[-1-item],
 							 weight, weight_max,
 							 x, outpos+1, 0,
<span class="p_del">-							 out2, outpos,</span>
<span class="p_add">+							 out2, outpos, count,</span>
 							 recurse_tries, 0,
 							 local_retries,
 							 local_fallback_retries,
<span class="p_chunk">@@ -463,6 +466,7 @@</span> <span class="p_context"> reject:</span>
 		dprintk(&quot;CHOOSE got %d\n&quot;, item);
 		out[outpos] = item;
 		outpos++;
<span class="p_add">+		count--;</span>
 	}
 
 	dprintk(&quot;CHOOSE returns %d\n&quot;, outpos);
<span class="p_chunk">@@ -654,6 +658,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 	__u32 step;
 	int i, j;
 	int numrep;
<span class="p_add">+	int out_size;</span>
 	/*
 	 * the original choose_total_tries value was off by one (it
 	 * counted &quot;retries&quot; and not &quot;tries&quot;).  add one.
<span class="p_chunk">@@ -761,6 +766,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						x, numrep,
 						curstep-&gt;arg2,
 						o+osize, j,
<span class="p_add">+						result_max-osize,</span>
 						choose_tries,
 						recurse_tries,
 						choose_local_retries,
<span class="p_chunk">@@ -770,11 +776,13 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						c+osize,
 						0);
 				} else {
<span class="p_add">+					out_size = ((numrep &lt; (result_max-osize)) ?</span>
<span class="p_add">+                                                    numrep : (result_max-osize));</span>
 					crush_choose_indep(
 						map,
 						map-&gt;buckets[-1-w[i]],
 						weight, weight_max,
<span class="p_del">-						x, numrep, numrep,</span>
<span class="p_add">+						x, out_size, numrep,</span>
 						curstep-&gt;arg2,
 						o+osize, j,
 						choose_tries,
<span class="p_chunk">@@ -783,7 +791,7 @@</span> <span class="p_context"> int crush_do_rule(const struct crush_map *map,</span>
 						recurse_to_leaf,
 						c+osize,
 						0);
<span class="p_del">-					osize += numrep;</span>
<span class="p_add">+					osize += out_size;</span>
 				}
 			}
 
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 0f3e713c5e75..fead914b09f6 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> static int ip_finish_output_gso(struct sk_buff *skb)</span>
 	 */
 	features = netif_skb_features(skb);
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
<span class="p_del">-	if (IS_ERR(segs)) {</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs)) {</span>
 		kfree_skb(skb);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c</span>
<span class="p_header">index e1cf0f89748d..7b049cb56825 100644</span>
<span class="p_header">--- a/net/netfilter/nf_tables_api.c</span>
<span class="p_header">+++ b/net/netfilter/nf_tables_api.c</span>
<span class="p_chunk">@@ -993,7 +993,10 @@</span> <span class="p_context"> static int nf_tables_newchain(struct sock *nlsk, struct sk_buff *skb,</span>
 
 	if (nla[NFTA_CHAIN_POLICY]) {
 		if ((chain != NULL &amp;&amp;
<span class="p_del">-		    !(chain-&gt;flags &amp; NFT_BASE_CHAIN)) ||</span>
<span class="p_add">+		    !(chain-&gt;flags &amp; NFT_BASE_CHAIN)))</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (chain == NULL &amp;&amp;</span>
 		    nla[NFTA_CHAIN_HOOK] == NULL)
 			return -EOPNOTSUPP;
 
<span class="p_chunk">@@ -1794,6 +1797,10 @@</span> <span class="p_context"> static int nf_tables_newrule(struct sock *nlsk, struct sk_buff *skb,</span>
 			n++;
 		}
 	}
<span class="p_add">+	/* Check for overflow of dlen field */</span>
<span class="p_add">+	err = -EFBIG;</span>
<span class="p_add">+	if (size &gt;= 1 &lt;&lt; 12)</span>
<span class="p_add">+		goto err1;</span>
 
 	if (nla[NFTA_RULE_USERDATA])
 		ulen = nla_len(nla[NFTA_RULE_USERDATA]);
<span class="p_chunk">@@ -1857,12 +1864,6 @@</span> <span class="p_context"> static int nf_tables_newrule(struct sock *nlsk, struct sk_buff *skb,</span>
 
 err3:
 	list_del_rcu(&amp;rule-&gt;list);
<span class="p_del">-	if (trans) {</span>
<span class="p_del">-		list_del_rcu(&amp;nft_trans_rule(trans)-&gt;list);</span>
<span class="p_del">-		nft_rule_clear(net, nft_trans_rule(trans));</span>
<span class="p_del">-		nft_trans_destroy(trans);</span>
<span class="p_del">-		chain-&gt;use++;</span>
<span class="p_del">-	}</span>
 err2:
 	nf_tables_rule_destroy(&amp;ctx, rule);
 err1:
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 9e287cb56a04..7f035f0772ee 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -77,6 +77,9 @@</span> <span class="p_context"> nfnl_cthelper_parse_tuple(struct nf_conntrack_tuple *tuple,</span>
 	if (!tb[NFCTH_TUPLE_L3PROTONUM] || !tb[NFCTH_TUPLE_L4PROTONUM])
 		return -EINVAL;
 
<span class="p_add">+	/* Not all fields are initialized so first zero the tuple */</span>
<span class="p_add">+	memset(tuple, 0, sizeof(struct nf_conntrack_tuple));</span>
<span class="p_add">+</span>
 	tuple-&gt;src.l3num = ntohs(nla_get_be16(tb[NFCTH_TUPLE_L3PROTONUM]));
 	tuple-&gt;dst.protonum = nla_get_u8(tb[NFCTH_TUPLE_L4PROTONUM]);
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index 108120f216b1..5b169db2049a 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -665,7 +665,7 @@</span> <span class="p_context"> nfqnl_enqueue_packet(struct nf_queue_entry *entry, unsigned int queuenum)</span>
 	 * returned by nf_queue.  For instance, callers rely on -ECANCELED to
 	 * mean &#39;ignore this hook&#39;.
 	 */
<span class="p_del">-	if (IS_ERR(segs))</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs))</span>
 		goto out_err;
 	queued = 0;
 	err = 0;
<span class="p_header">diff --git a/net/netfilter/nft_compat.c b/net/netfilter/nft_compat.c</span>
<span class="p_header">index 318e1f1b0e4c..4b8de88bb49d 100644</span>
<span class="p_header">--- a/net/netfilter/nft_compat.c</span>
<span class="p_header">+++ b/net/netfilter/nft_compat.c</span>
<span class="p_chunk">@@ -82,6 +82,9 @@</span> <span class="p_context"> nft_target_set_tgchk_param(struct xt_tgchk_param *par,</span>
 		entry-&gt;e4.ip.invflags = inv ? IPT_INV_PROTO : 0;
 		break;
 	case AF_INET6:
<span class="p_add">+		if (proto)</span>
<span class="p_add">+			entry-&gt;e6.ipv6.flags |= IP6T_F_PROTO;</span>
<span class="p_add">+</span>
 		entry-&gt;e6.ipv6.proto = proto;
 		entry-&gt;e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;
 		break;
<span class="p_chunk">@@ -322,6 +325,9 @@</span> <span class="p_context"> nft_match_set_mtchk_param(struct xt_mtchk_param *par, const struct nft_ctx *ctx,</span>
 		entry-&gt;e4.ip.invflags = inv ? IPT_INV_PROTO : 0;
 		break;
 	case AF_INET6:
<span class="p_add">+		if (proto)</span>
<span class="p_add">+			entry-&gt;e6.ipv6.flags |= IP6T_F_PROTO;</span>
<span class="p_add">+</span>
 		entry-&gt;e6.ipv6.proto = proto;
 		entry-&gt;e6.ipv6.invflags = inv ? IP6T_INV_PROTO : 0;
 		break;
<span class="p_header">diff --git a/net/netfilter/nft_rbtree.c b/net/netfilter/nft_rbtree.c</span>
<span class="p_header">index e1836ff88199..0636387c7c80 100644</span>
<span class="p_header">--- a/net/netfilter/nft_rbtree.c</span>
<span class="p_header">+++ b/net/netfilter/nft_rbtree.c</span>
<span class="p_chunk">@@ -37,10 +37,11 @@</span> <span class="p_context"> static bool nft_rbtree_lookup(const struct nft_set *set,</span>
 {
 	const struct nft_rbtree *priv = nft_set_priv(set);
 	const struct nft_rbtree_elem *rbe, *interval = NULL;
<span class="p_del">-	const struct rb_node *parent = priv-&gt;root.rb_node;</span>
<span class="p_add">+	const struct rb_node *parent;</span>
 	int d;
 
 	spin_lock_bh(&amp;nft_rbtree_lock);
<span class="p_add">+	parent = priv-&gt;root.rb_node;</span>
 	while (parent != NULL) {
 		rbe = rb_entry(parent, struct nft_rbtree_elem, node);
 
<span class="p_chunk">@@ -158,7 +159,6 @@</span> <span class="p_context"> static int nft_rbtree_get(const struct nft_set *set, struct nft_set_elem *elem)</span>
 	struct nft_rbtree_elem *rbe;
 	int d;
 
<span class="p_del">-	spin_lock_bh(&amp;nft_rbtree_lock);</span>
 	while (parent != NULL) {
 		rbe = rb_entry(parent, struct nft_rbtree_elem, node);
 
<span class="p_chunk">@@ -173,11 +173,9 @@</span> <span class="p_context"> static int nft_rbtree_get(const struct nft_set *set, struct nft_set_elem *elem)</span>
 			    !(rbe-&gt;flags &amp; NFT_SET_ELEM_INTERVAL_END))
 				nft_data_copy(&amp;elem-&gt;data, rbe-&gt;data);
 			elem-&gt;flags = rbe-&gt;flags;
<span class="p_del">-			spin_unlock_bh(&amp;nft_rbtree_lock);</span>
 			return 0;
 		}
 	}
<span class="p_del">-	spin_unlock_bh(&amp;nft_rbtree_lock);</span>
 	return -ENOENT;
 }
 
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index 1e71adeca318..4e6176d9a6cd 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -330,6 +330,8 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	segs = __skb_gso_segment(skb, NETIF_F_SG, false);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
<span class="p_add">+	if (segs == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	/* Queue all of the segments. */
 	skb = segs;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index 9ec12f834c43..8467373e2ace 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	if (rc) {
 		dprintk(&quot;RPC:       %s: ib_query_device failed %d\n&quot;,
 			__func__, rc);
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 
 	if (devattr.device_cap_flags &amp; IB_DEVICE_LOCAL_DMA_LKEY) {
<span class="p_chunk">@@ -599,14 +599,14 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 				&quot;phys register failed with %lX\n&quot;,
 				__func__, PTR_ERR(ia-&gt;ri_bind_mem));
 			rc = -ENOMEM;
<span class="p_del">-			goto out2;</span>
<span class="p_add">+			goto out3;</span>
 		}
 		break;
 	default:
 		printk(KERN_ERR &quot;RPC: Unsupported memory &quot;
 				&quot;registration mode: %d\n&quot;, memreg);
 		rc = -ENOMEM;
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 	dprintk(&quot;RPC:       %s: memory registration strategy is %d\n&quot;,
 		__func__, memreg);
<span class="p_chunk">@@ -615,6 +615,10 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	ia-&gt;ri_memreg_strategy = memreg;
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out3:</span>
<span class="p_add">+	ib_dealloc_pd(ia-&gt;ri_pd);</span>
<span class="p_add">+	ia-&gt;ri_pd = NULL;</span>
 out2:
 	rdma_destroy_id(ia-&gt;ri_id);
 	ia-&gt;ri_id = NULL;
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index c51e8f7b8653..e44f36057a2a 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -157,6 +157,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct sk_buff *skb)</span>
 	kfree_skb(skb);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
<span class="p_add">+	if (segs == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	do {
 		struct sk_buff *nskb = segs-&gt;next;
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">index ad9d9f8b48ed..2537d474057c 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_chunk">@@ -183,8 +183,10 @@</span> <span class="p_context"> static int snd_card_emu10k1_probe(struct pci_dev *pci,</span>
 	}
 #endif
  
<span class="p_del">-	strcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver);</span>
<span class="p_del">-	strcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name);</span>
<span class="p_add">+	strlcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver,</span>
<span class="p_add">+		sizeof(card-&gt;driver));</span>
<span class="p_add">+	strlcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name,</span>
<span class="p_add">+		sizeof(card-&gt;shortname));</span>
 	snprintf(card-&gt;longname, sizeof(card-&gt;longname),
 		 &quot;%s (rev.%d, serial:0x%x) at 0x%lx, irq %i&quot;,
 		 card-&gt;shortname, emu-&gt;revision, emu-&gt;serial, emu-&gt;port, emu-&gt;irq);
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">index 874cd76c7b7f..d2c7ea3a7610 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
<span class="p_del">-	temp = (hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	temp = (hw-&gt;silent_page.addr &lt;&lt; hw-&gt;address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
<span class="p_del">-		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; hw_address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">index 229269788023..92f2371791a3 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
<span class="p_del">-	silent_page = (emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = (emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	for (ch = 0; ch &lt; NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
<span class="p_chunk">@@ -348,6 +348,11 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 		outl(reg | A_IOCFG_GPOUT0, emu-&gt;port + A_IOCFG);
 	}
 
<span class="p_add">+	if (emu-&gt;address_mode == 0) {</span>
<span class="p_add">+		/* use 16M in 4G */</span>
<span class="p_add">+		outl(inl(emu-&gt;port + HCFG) | HCFG_EXPANDED_MEM, emu-&gt;port + HCFG);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1424,7 +1429,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 ZS Notebook [SB0530]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 ZS Notebook [SB0530]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
<span class="p_chunk">@@ -1574,7 +1579,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 Platinum EX [SB0280]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 Platinum EX [SB0280]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
<span class="p_chunk">@@ -1880,8 +1885,10 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	is_audigy = emu-&gt;audigy = c-&gt;emu10k2_chip;
 
<span class="p_add">+	/* set addressing mode */</span>
<span class="p_add">+	emu-&gt;address_mode = is_audigy ? 0 : 1;</span>
 	/* set the DMA transfer mask */
<span class="p_del">-	emu-&gt;dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;</span>
<span class="p_add">+	emu-&gt;dma_mask = emu-&gt;address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;</span>
 	if (pci_set_dma_mask(pci, emu-&gt;dma_mask) &lt; 0 ||
 	    pci_set_consistent_dma_mask(pci, emu-&gt;dma_mask) &lt; 0) {
 		dev_err(card-&gt;dev,
<span class="p_chunk">@@ -1906,7 +1913,7 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	emu-&gt;max_cache_pages = max_cache_bytes &gt;&gt; PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
<span class="p_del">-				32 * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
<span class="p_add">+				(emu-&gt;address_mode ? 32 : 16) * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
 		err = -ENOMEM;
 		goto error;
 	}
<span class="p_chunk">@@ -2005,8 +2012,8 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	/* Clear silent pages and set up pointers */
 	memset(emu-&gt;silent_page.area, 0, PAGE_SIZE);
<span class="p_del">-	silent_page = emu-&gt;silent_page.addr &lt;&lt; 1;</span>
<span class="p_del">-	for (idx = 0; idx &lt; MAXPAGES; idx++)</span>
<span class="p_add">+	silent_page = emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode;</span>
<span class="p_add">+	for (idx = 0; idx &lt; (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0); idx++)</span>
 		((u32 *)emu-&gt;ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
<span class="p_header">diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">index f82481bd2542..36f0b8646417 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,</span>
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
<span class="p_del">-	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
<span class="p_header">diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c</span>
<span class="p_header">index c68e6dd2fa67..4f1f69be1865 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/memory.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/memory.c</span>
<span class="p_chunk">@@ -34,10 +34,11 @@</span> <span class="p_context"></span>
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
<span class="p_del">-	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; 1) | (page)))</span>
<span class="p_add">+	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; (emu-&gt;address_mode)) | (page)))</span>
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
<span class="p_del">-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)</span>
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) &gt;&gt; PAGE_SHIFT)
 /* get offset address from aligned page */
<span class="p_chunk">@@ -124,7 +125,7 @@</span> <span class="p_context"> static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis</span>
 		}
 		page = blk-&gt;mapped_page + blk-&gt;pages;
 	}
<span class="p_del">-	size = MAX_ALIGN_PAGES - page;</span>
<span class="p_add">+	size = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;</span>
 	if (size &gt;= max_size) {
 		*nextp = pos;
 		return page;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)</span>
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q-&gt;mapped_page;
 	} else
<span class="p_del">-		end_page = MAX_ALIGN_PAGES;</span>
<span class="p_add">+		end_page = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);</span>
 
 	/* remove links */
 	list_del(&amp;blk-&gt;mapped_link);
<span class="p_chunk">@@ -307,7 +308,7 @@</span> <span class="p_context"> snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst</span>
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime-&gt;dma_bytes &lt;= 0 ||
<span class="p_del">-		       runtime-&gt;dma_bytes &gt;= MAXPAGES * EMUPAGESIZE))</span>
<span class="p_add">+		       runtime-&gt;dma_bytes &gt;= (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))</span>
 		return NULL;
 	hdr = emu-&gt;memhdr;
 	if (snd_BUG_ON(!hdr))
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index fb9497a0062a..68bea67c3ca3 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -2942,6 +2942,16 @@</span> <span class="p_context"> static struct snd_kcontrol_new vmaster_mute_mode = {</span>
 	.put = vmaster_mute_mode_put,
 };
 
<span class="p_add">+/* meta hook to call each driver&#39;s vmaster hook */</span>
<span class="p_add">+static void vmaster_hook(void *private_data, int enabled)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_vmaster_mute_hook *hook = private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hook-&gt;mute_mode != HDA_VMUTE_FOLLOW_MASTER)</span>
<span class="p_add">+		enabled = hook-&gt;mute_mode;</span>
<span class="p_add">+	hook-&gt;hook(hook-&gt;codec, enabled);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Add a mute-LED hook with the given vmaster switch kctl
  * &quot;Mute-LED Mode&quot; control is automatically created and associated with
<span class="p_chunk">@@ -2955,9 +2965,9 @@</span> <span class="p_context"> int snd_hda_add_vmaster_hook(struct hda_codec *codec,</span>
 
 	if (!hook-&gt;hook || !hook-&gt;sw_kctl)
 		return 0;
<span class="p_del">-	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, hook-&gt;hook, codec);</span>
 	hook-&gt;codec = codec;
 	hook-&gt;mute_mode = HDA_VMUTE_FOLLOW_MASTER;
<span class="p_add">+	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, vmaster_hook, hook);</span>
 	if (!expose_enum_ctl)
 		return 0;
 	kctl = snd_ctl_new1(&amp;vmaster_mute_mode, hook);
<span class="p_chunk">@@ -2980,14 +2990,7 @@</span> <span class="p_context"> void snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)</span>
 	 */
 	if (hook-&gt;codec-&gt;bus-&gt;shutdown)
 		return;
<span class="p_del">-	switch (hook-&gt;mute_mode) {</span>
<span class="p_del">-	case HDA_VMUTE_FOLLOW_MASTER:</span>
<span class="p_del">-		snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		hook-&gt;hook(hook-&gt;codec, hook-&gt;mute_mode);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
 }
 EXPORT_SYMBOL_GPL(snd_hda_sync_vmaster_hook);
 
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 6ba0b5517c40..2341fc334163 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 		if (led_set_func(TPACPI_LED_MUTE, false) &gt;= 0) {
 			old_vmaster_hook = spec-&gt;vmaster_mute.hook;
 			spec-&gt;vmaster_mute.hook = update_tpacpi_mute_led;
<span class="p_add">+			spec-&gt;vmaster_mute_enum = 1;</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_header">diff --git a/sound/soc/codecs/rt5677.c b/sound/soc/codecs/rt5677.c</span>
<span class="p_header">index 833231e27340..d48b484ce47e 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5677.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5677.c</span>
<span class="p_chunk">@@ -56,6 +56,9 @@</span> <span class="p_context"> static const struct reg_default init_list[] = {</span>
 	{RT5677_PR_BASE + 0x1e, 0x0000},
 	{RT5677_PR_BASE + 0x12, 0x0eaa},
 	{RT5677_PR_BASE + 0x14, 0x018a},
<span class="p_add">+	{RT5677_PR_BASE + 0x15,	0x0490},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x38,	0x0f71},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x39,	0x0f71},</span>
 };
 #define RT5677_INIT_REG_LEN ARRAY_SIZE(init_list)
 
<span class="p_header">diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c</span>
<span class="p_header">index 319754cf6208..daf61abc3670 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_oss.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_oss.c</span>
<span class="p_chunk">@@ -118,12 +118,8 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!snd_emux_inc_count(emu)) {</span>
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	if (!snd_emux_inc_count(emu))</span>
 		return -EFAULT;
<span class="p_del">-	}</span>
 
 	memset(&amp;callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
<span class="p_chunk">@@ -135,7 +131,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (p == NULL) {
 		snd_printk(KERN_ERR &quot;can&#39;t create port\n&quot;);
 		snd_emux_dec_count(emu);
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -148,8 +143,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	reset_port_mode(p, arg-&gt;seq_mode);
 
 	snd_emux_reset_port(p);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -195,13 +188,11 @@</span> <span class="p_context"> snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)</span>
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu-&gt;sflist, SF_CLIENT_NO(p-&gt;chset.port));
 	snd_seq_event_port_detach(p-&gt;chset.client, p-&gt;chset.port);
 	snd_emux_dec_count(emu);
 
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c</span>
<span class="p_header">index 7778b8e19782..a0209204ae48 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_seq.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_seq.c</span>
<span class="p_chunk">@@ -124,12 +124,10 @@</span> <span class="p_context"> snd_emux_detach_seq(struct snd_emux *emu)</span>
 	if (emu-&gt;voices)
 		snd_emux_terminate_all(emu);
 		
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	if (emu-&gt;client &gt;= 0) {
 		snd_seq_delete_kernel_client(emu-&gt;client);
 		emu-&gt;client = -1;
 	}
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 }
 
 
<span class="p_chunk">@@ -269,8 +267,8 @@</span> <span class="p_context"> snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,</span>
 /*
  * increment usage count
  */
<span class="p_del">-int</span>
<span class="p_del">-snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__snd_emux_inc_count(struct snd_emux *emu)</span>
 {
 	emu-&gt;used++;
 	if (!try_module_get(emu-&gt;ops.owner))
<span class="p_chunk">@@ -284,12 +282,21 @@</span> <span class="p_context"> snd_emux_inc_count(struct snd_emux *emu)</span>
 	return 1;
 }
 
<span class="p_add">+int snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	ret = __snd_emux_inc_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /*
  * decrease usage count
  */
<span class="p_del">-void</span>
<span class="p_del">-snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+static void</span>
<span class="p_add">+__snd_emux_dec_count(struct snd_emux *emu)</span>
 {
 	module_put(emu-&gt;card-&gt;module);
 	emu-&gt;used--;
<span class="p_chunk">@@ -298,6 +305,12 @@</span> <span class="p_context"> snd_emux_dec_count(struct snd_emux *emu)</span>
 	module_put(emu-&gt;ops.owner);
 }
 
<span class="p_add">+void snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+}</span>
 
 /*
  * Routine that is called upon a first use of a particular port
<span class="p_chunk">@@ -317,7 +330,7 @@</span> <span class="p_context"> snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_init_port(p);
<span class="p_del">-	snd_emux_inc_count(emu);</span>
<span class="p_add">+	__snd_emux_inc_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -340,7 +353,7 @@</span> <span class="p_context"> snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_sounds_off_all(p);
<span class="p_del">-	snd_emux_dec_count(emu);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index 22fa819a9b6a..1c0772b340d8 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -61,12 +61,14 @@</span> <span class="p_context"> static void timer_disarm(struct arch_timer_cpu *timer)</span>
 
 static void kvm_timer_inject_irq(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	int ret;</span>
 	struct arch_timer_cpu *timer = &amp;vcpu-&gt;arch.timer_cpu;
 
 	timer-&gt;cntv_ctl |= ARCH_TIMER_CTRL_IT_MASK;
<span class="p_del">-	kvm_vgic_inject_irq(vcpu-&gt;kvm, vcpu-&gt;vcpu_id,</span>
<span class="p_del">-			    timer-&gt;irq-&gt;irq,</span>
<span class="p_del">-			    timer-&gt;irq-&gt;level);</span>
<span class="p_add">+	ret = kvm_vgic_inject_irq(vcpu-&gt;kvm, vcpu-&gt;vcpu_id,</span>
<span class="p_add">+				  timer-&gt;irq-&gt;irq,</span>
<span class="p_add">+				  timer-&gt;irq-&gt;level);</span>
<span class="p_add">+	WARN_ON(ret);</span>
 }
 
 static irqreturn_t kvm_arch_timer_handler(int irq, void *dev_id)
<span class="p_chunk">@@ -307,12 +309,24 @@</span> <span class="p_context"> void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu)</span>
 	timer_disarm(timer);
 }
 
<span class="p_del">-int kvm_timer_init(struct kvm *kvm)</span>
<span class="p_add">+void kvm_timer_enable(struct kvm *kvm)</span>
 {
<span class="p_del">-	if (timecounter &amp;&amp; wqueue) {</span>
<span class="p_del">-		kvm-&gt;arch.timer.cntvoff = kvm_phys_timer_read();</span>
<span class="p_add">+	if (kvm-&gt;arch.timer.enabled)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There is a potential race here between VCPUs starting for the first</span>
<span class="p_add">+	 * time, which may be enabling the timer multiple times.  That doesn&#39;t</span>
<span class="p_add">+	 * hurt though, because we&#39;re just setting a variable to the same</span>
<span class="p_add">+	 * variable that it already was.  The important thing is that all</span>
<span class="p_add">+	 * VCPUs have the enabled variable set, before entering the guest, if</span>
<span class="p_add">+	 * the arch timers are enabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (timecounter &amp;&amp; wqueue)</span>
 		kvm-&gt;arch.timer.enabled = 1;
<span class="p_del">-	}</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+void kvm_timer_init(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvm-&gt;arch.timer.cntvoff = kvm_phys_timer_read();</span>
 }
<span class="p_header">diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c</span>
<span class="p_header">index 476d3bf540a8..24ac123f4ad8 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic.c</span>
<span class="p_chunk">@@ -674,7 +674,7 @@</span> <span class="p_context"> static bool read_set_clear_sgi_pend_reg(struct kvm_vcpu *vcpu,</span>
 {
 	struct vgic_dist *dist = &amp;vcpu-&gt;kvm-&gt;arch.vgic;
 	int sgi;
<span class="p_del">-	int min_sgi = (offset &amp; ~0x3) * 4;</span>
<span class="p_add">+	int min_sgi = (offset &amp; ~0x3);</span>
 	int max_sgi = min_sgi + 3;
 	int vcpu_id = vcpu-&gt;vcpu_id;
 	u32 reg = 0;
<span class="p_chunk">@@ -695,7 +695,7 @@</span> <span class="p_context"> static bool write_set_clear_sgi_pend_reg(struct kvm_vcpu *vcpu,</span>
 {
 	struct vgic_dist *dist = &amp;vcpu-&gt;kvm-&gt;arch.vgic;
 	int sgi;
<span class="p_del">-	int min_sgi = (offset &amp; ~0x3) * 4;</span>
<span class="p_add">+	int min_sgi = (offset &amp; ~0x3);</span>
 	int max_sgi = min_sgi + 3;
 	int vcpu_id = vcpu-&gt;vcpu_id;
 	u32 reg;
<span class="p_chunk">@@ -1042,6 +1042,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 			  lr, irq, vgic_cpu-&gt;vgic_lr[lr]);
 		BUG_ON(!test_bit(lr, vgic_cpu-&gt;lr_used));
 		vgic_cpu-&gt;vgic_lr[lr] |= GICH_LR_PENDING_BIT;
<span class="p_add">+		__clear_bit(lr, (unsigned long *)vgic_cpu-&gt;vgic_elrsr);</span>
 		return true;
 	}
 
<span class="p_chunk">@@ -1055,6 +1056,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 	vgic_cpu-&gt;vgic_lr[lr] = MK_LR_PEND(sgi_source_id, irq);
 	vgic_cpu-&gt;vgic_irq_lr_map[irq] = lr;
 	set_bit(lr, vgic_cpu-&gt;lr_used);
<span class="p_add">+	__clear_bit(lr, (unsigned long *)vgic_cpu-&gt;vgic_elrsr);</span>
 
 	if (!vgic_irq_is_edge(vcpu, irq))
 		vgic_cpu-&gt;vgic_lr[lr] |= GICH_LR_EOI;
<span class="p_chunk">@@ -1209,6 +1211,14 @@</span> <span class="p_context"> static bool vgic_process_maintenance(struct kvm_vcpu *vcpu)</span>
 	if (vgic_cpu-&gt;vgic_misr &amp; GICH_MISR_U)
 		vgic_cpu-&gt;vgic_hcr &amp;= ~GICH_HCR_UIE;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In the next iterations of the vcpu loop, if we sync the vgic state</span>
<span class="p_add">+	 * after flushing it, but before entering the guest (this happens for</span>
<span class="p_add">+	 * pending signals and vmid rollovers), then make sure we don&#39;t pick</span>
<span class="p_add">+	 * up any old maintenance interrupts here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(vgic_cpu-&gt;vgic_eisr, 0, sizeof(vgic_cpu-&gt;vgic_eisr[0]) * 2);</span>
<span class="p_add">+</span>
 	return level_pending;
 }
 
<span class="p_chunk">@@ -1387,7 +1397,8 @@</span> <span class="p_context"> out:</span>
 int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,
 			bool level)
 {
<span class="p_del">-	if (vgic_update_irq_state(kvm, cpuid, irq_num, level))</span>
<span class="p_add">+	if (likely(vgic_initialized(kvm)) &amp;&amp;</span>
<span class="p_add">+	    vgic_update_irq_state(kvm, cpuid, irq_num, level))</span>
 		vgic_kick_vcpus(kvm);
 
 	return 0;
<span class="p_chunk">@@ -1610,7 +1621,7 @@</span> <span class="p_context"> out:</span>
 
 int kvm_vgic_create(struct kvm *kvm)
 {
<span class="p_del">-	int i, vcpu_lock_idx = -1, ret = 0;</span>
<span class="p_add">+	int i, vcpu_lock_idx = -1, ret;</span>
 	struct kvm_vcpu *vcpu;
 
 	mutex_lock(&amp;kvm-&gt;lock);
<span class="p_chunk">@@ -1625,6 +1636,7 @@</span> <span class="p_context"> int kvm_vgic_create(struct kvm *kvm)</span>
 	 * vcpu-&gt;mutex.  By grabbing the vcpu-&gt;mutex of all VCPUs we ensure
 	 * that no other VCPUs are run while we create the vgic.
 	 */
<span class="p_add">+	ret = -EBUSY;</span>
 	kvm_for_each_vcpu(i, vcpu, kvm) {
 		if (!mutex_trylock(&amp;vcpu-&gt;mutex))
 			goto out_unlock;
<span class="p_chunk">@@ -1632,11 +1644,10 @@</span> <span class="p_context"> int kvm_vgic_create(struct kvm *kvm)</span>
 	}
 
 	kvm_for_each_vcpu(i, vcpu, kvm) {
<span class="p_del">-		if (vcpu-&gt;arch.has_run_once) {</span>
<span class="p_del">-			ret = -EBUSY;</span>
<span class="p_add">+		if (vcpu-&gt;arch.has_run_once)</span>
 			goto out_unlock;
<span class="p_del">-		}</span>
 	}
<span class="p_add">+	ret = 0;</span>
 
 	spin_lock_init(&amp;kvm-&gt;arch.vgic.lock);
 	kvm-&gt;arch.vgic.vctrl_base = vgic_vctrl_base;
<span class="p_chunk">@@ -1654,7 +1665,7 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static bool vgic_ioaddr_overlap(struct kvm *kvm)</span>
<span class="p_add">+static int vgic_ioaddr_overlap(struct kvm *kvm)</span>
 {
 	phys_addr_t dist = kvm-&gt;arch.vgic.vgic_dist_base;
 	phys_addr_t cpu = kvm-&gt;arch.vgic.vgic_cpu_base;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



