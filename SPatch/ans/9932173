
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/2] iommu/omap: Add support to program multiple iommus - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/2] iommu/omap: Add support to program multiple iommus</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=6924">Suman Anna</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 31, 2017, 1:14 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170831131402.29502-3-s-anna@ti.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9932173/mbox/"
   >mbox</a>
|
   <a href="/patch/9932173/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9932173/">/patch/9932173/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A69936022E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Aug 2017 13:14:28 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 97F5F285DA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Aug 2017 13:14:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8CEFB28756; Thu, 31 Aug 2017 13:14:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 56C9A285DA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 31 Aug 2017 13:14:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751873AbdHaNOY (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 31 Aug 2017 09:14:24 -0400
Received: from lelnx193.ext.ti.com ([198.47.27.77]:45163 &quot;EHLO
	lelnx193.ext.ti.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751694AbdHaNOU (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 31 Aug 2017 09:14:20 -0400
Received: from dflxv15.itg.ti.com ([128.247.5.124])
	by lelnx193.ext.ti.com (8.15.1/8.15.1) with ESMTP id v7VDE6Po012792; 
	Thu, 31 Aug 2017 08:14:06 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=ti.com;
	s=ti-com-17Q1; t=1504185246;
	bh=vVTBjgKI0W9KlWAQF9rfzX4jrFFkcMvvWhLyEoVZmTs=;
	h=From:To:CC:Subject:Date:In-Reply-To:References;
	b=Vj3IEvqplmcXLh9VxDo0h+46yMbJtGUnvE2rmXINuhLDsp1rewWoxUg2GfMrXEQ61
	M70xij3bOfcbLaB8MilkwztZ+h2vWFQYoPp0useXt+txT+UR+MLnSxRm1Efsl7MJa1
	mKo4PvhFZpARy4F6PsiqhKM8ORNLHidTJVlizXOE=
Received: from DLEE109.ent.ti.com (dlee109.ent.ti.com [157.170.170.41])
	by dflxv15.itg.ti.com (8.14.3/8.13.8) with ESMTP id v7VDE6kN022115;
	Thu, 31 Aug 2017 08:14:06 -0500
Received: from DLEE114.ent.ti.com (157.170.170.25) by DLEE109.ent.ti.com
	(157.170.170.41) with Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256) id 15.1.845.34;
	Thu, 31 Aug 2017 08:14:04 -0500
Received: from dflp32.itg.ti.com (10.64.6.15) by DLEE114.ent.ti.com
	(157.170.170.25) with Microsoft SMTP Server (version=TLS1_0,
	cipher=TLS_RSA_WITH_AES_256_CBC_SHA) id 15.1.845.34 via Frontend
	Transport; Thu, 31 Aug 2017 08:14:04 -0500
Received: from legion.dal.design.ti.com (legion.dal.design.ti.com
	[128.247.22.53])
	by dflp32.itg.ti.com (8.14.3/8.13.8) with ESMTP id v7VDE4g4013756;
	Thu, 31 Aug 2017 08:14:04 -0500
Received: from localhost (irmo.dhcp.ti.com [128.247.58.153])
	by legion.dal.design.ti.com (8.11.7p1+Sun/8.11.7) with ESMTP id
	v7VDE4303321; Thu, 31 Aug 2017 08:14:04 -0500 (CDT)
From: Suman Anna &lt;s-anna@ti.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;
CC: &lt;iommu@lists.linux-foundation.org&gt;, Tony Lindgren &lt;tony@atomide.com&gt;,
	Tero Kristo &lt;t-kristo@ti.com&gt;,
	Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;,
	&lt;linux-omap@vger.kernel.org&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	Suman Anna &lt;s-anna@ti.com&gt;
Subject: [PATCH 2/2] iommu/omap: Add support to program multiple iommus
Date: Thu, 31 Aug 2017 08:14:02 -0500
Message-ID: &lt;20170831131402.29502-3-s-anna@ti.com&gt;
X-Mailer: git-send-email 2.13.1
In-Reply-To: &lt;20170831131402.29502-1-s-anna@ti.com&gt;
References: &lt;20170831131402.29502-1-s-anna@ti.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-EXCLAIMER-MD-CONFIG: e1e8a2fd-e40a-4ac6-ac9b-f7e9cc9ee180
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6924">Suman Anna</a> - Aug. 31, 2017, 1:14 p.m.</div>
<pre class="content">
A client user instantiates and attaches to an iommu_domain to
program the OMAP IOMMU associated with the domain. The iommus
programmed by a client user are bound with the iommu_domain
through the user&#39;s device archdata. The OMAP IOMMU driver
currently supports only one IOMMU per IOMMU domain per user.

The OMAP IOMMU driver has been enhanced to support allowing
multiple IOMMUs to be programmed by a single client user. This
support is being added mainly to handle the DSP subsystems on
the DRA7xx SoCs, which have two MMUs within the same subsystem.
These MMUs provide translations to a processor core port and
an internal EDMA port. This support allows both the MMUs to
be programmed together, but with each one retaining it&#39;s own
internal state objects. The internal EDMA is managed by the
software running on the DSPs, and this design provides on-par
functionality with previous generation OMAP DSPs where the
EDMA and the DSP core shared the same MMU.

The multiple iommus are expected to be provided through a
sentinel terminated array of omap_iommu_arch_data objects
through the client user&#39;s device archdata. The OMAP driver
core is enhanced to loop through the array of attached
iommus and program them for all common operations. The
sentinel-terminated logic is used so as to not change the
omap_iommu_arch_data structure.

NOTE:
1. The IOMMU groups are still defined for both the DSP MMUs,
   but the IOMMU device linking uses only the first MMU device.
2. The OMAP IOMMU debugfs code still continues to operate on
   individual IOMMU objects.
<span class="signed-off-by">
Signed-off-by: Suman Anna &lt;s-anna@ti.com&gt;</span>
[t-kristo@ti.com: ported support to 4.13 based kernel]
<span class="signed-off-by">Signed-off-by: Tero Kristo &lt;t-kristo@ti.com&gt;</span>
---
 drivers/iommu/omap-iommu.c | 307 ++++++++++++++++++++++++++++++++++-----------
 drivers/iommu/omap-iommu.h |  30 +++--
 2 files changed, 248 insertions(+), 89 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Sept. 1, 2017, 10:01 a.m.</div>
<pre class="content">
Hi Suman,

On Thu, Aug 31, 2017 at 08:14:02AM -0500, Suman Anna wrote:
<span class="quote">&gt; The OMAP IOMMU driver has been enhanced to support allowing</span>
<span class="quote">&gt; multiple IOMMUs to be programmed by a single client user. This</span>
<span class="quote">&gt; support is being added mainly to handle the DSP subsystems on</span>
<span class="quote">&gt; the DRA7xx SoCs, which have two MMUs within the same subsystem.</span>
<span class="quote">&gt; These MMUs provide translations to a processor core port and</span>
<span class="quote">&gt; an internal EDMA port. This support allows both the MMUs to</span>
<span class="quote">&gt; be programmed together, but with each one retaining it&#39;s own</span>
<span class="quote">&gt; internal state objects. The internal EDMA is managed by the</span>
<span class="quote">&gt; software running on the DSPs, and this design provides on-par</span>
<span class="quote">&gt; functionality with previous generation OMAP DSPs where the</span>
<span class="quote">&gt; EDMA and the DSP core shared the same MMU.</span>

I didn&#39;t get that from the review, so a question here: Do both MMUs show
show up in sysfs, means, do you register both of them the the core code?

Because I think with the solution implemented here, only a single,
combined MMU should be visible to iommu core code and in sysfs.


Regards,

	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6924">Suman Anna</a> - Sept. 1, 2017, 4:21 p.m.</div>
<pre class="content">
Hi Joerg,

On 09/01/2017 05:01 AM, Joerg Roedel wrote:
<span class="quote">&gt; Hi Suman,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Thu, Aug 31, 2017 at 08:14:02AM -0500, Suman Anna wrote:</span>
<span class="quote">&gt;&gt; The OMAP IOMMU driver has been enhanced to support allowing</span>
<span class="quote">&gt;&gt; multiple IOMMUs to be programmed by a single client user. This</span>
<span class="quote">&gt;&gt; support is being added mainly to handle the DSP subsystems on</span>
<span class="quote">&gt;&gt; the DRA7xx SoCs, which have two MMUs within the same subsystem.</span>
<span class="quote">&gt;&gt; These MMUs provide translations to a processor core port and</span>
<span class="quote">&gt;&gt; an internal EDMA port. This support allows both the MMUs to</span>
<span class="quote">&gt;&gt; be programmed together, but with each one retaining it&#39;s own</span>
<span class="quote">&gt;&gt; internal state objects. The internal EDMA is managed by the</span>
<span class="quote">&gt;&gt; software running on the DSPs, and this design provides on-par</span>
<span class="quote">&gt;&gt; functionality with previous generation OMAP DSPs where the</span>
<span class="quote">&gt;&gt; EDMA and the DSP core shared the same MMU.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I didn&#39;t get that from the review, so a question here: Do both MMUs show</span>
<span class="quote">&gt; show up in sysfs, means, do you register both of them the the core code?</span>

Yes, both MMUs are identical instances of the IP, and both are
represented as their own platform devices (unique DT nodes), and since
we created the iommu_group in probe of each device, each MMU has its own
iommu_group as well.

Here&#39;s a bit more output,

root@dra7xx-evm:~# dmesg | grep mmu
[    0.519087] omap-iommu 40d01000.mmu: 40d01000.mmu registered
[    0.519580] omap-iommu 40d02000.mmu: 40d02000.mmu registered
[    0.520050] omap-iommu 58882000.mmu: 58882000.mmu registered
[    0.520495] omap-iommu 55082000.mmu: 55082000.mmu registered
[    0.521145] omap-iommu 41501000.mmu: 41501000.mmu registered
[    0.521634] omap-iommu 41502000.mmu: 41502000.mmu registered
[    0.522100] iommu: Adding device 58820000.ipu to group 2
[    0.522260] iommu: Adding device 55020000.ipu to group 3
[    0.522520] iommu: Adding device 40800000.dsp to group 0
[    0.522955] iommu: Adding device 41000000.dsp to group 4
root@dra7xx-evm:~# ls -l /sys/class/iommu/
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 40d01000.mmu -&gt;
../../devices/platform/44000000.ocp/40d01000.mmu/iommu/40d01000.mmu
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 40d02000.mmu -&gt;
../../devices/platform/44000000.ocp/40d02000.mmu/iommu/40d02000.mmu
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 41501000.mmu -&gt;
../../devices/platform/44000000.ocp/41501000.mmu/iommu/41501000.mmu
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 41502000.mmu -&gt;
../../devices/platform/44000000.ocp/41502000.mmu/iommu/41502000.mmu
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 55082000.mmu -&gt;
../../devices/platform/44000000.ocp/55082000.mmu/iommu/55082000.mmu
lrwxrwxrwx    1 root     root             0 Aug  8 03:59 58882000.mmu -&gt;
../../devices/platform/44000000.ocp/58882000.mmu/iommu/58882000.mmu
<span class="quote">
&gt; Because I think with the solution implemented here, only a single,</span>
<span class="quote">&gt; combined MMU should be visible to iommu core code and in sysfs.</span>

So, the way I have implemented atm is to do the device linking only to
one MMU in .add_device ops, while most of the remaining ops like map,
unmap, attach_device, detach_device loop through both MMUs to do the
programming.

It&#39;s primarily a question of whether each iommu platform device need to
be represented as a unique iommu_device or not. If you still think that
both these need to be presented to iommu core as one device, I would
have to add some glue logic in probe to tie the two devices together.

regards
Suman
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Sept. 1, 2017, 4:33 p.m.</div>
<pre class="content">
Hi Suman,
On Fri, Sep 01, 2017 at 11:21:45AM -0500, Suman Anna wrote:
<span class="quote">&gt; It&#39;s primarily a question of whether each iommu platform device need to</span>
<span class="quote">&gt; be represented as a unique iommu_device or not. If you still think that</span>
<span class="quote">&gt; both these need to be presented to iommu core as one device, I would</span>
<span class="quote">&gt; have to add some glue logic in probe to tie the two devices together.</span>

I think that you should only call iommu_device_register and friends for
the mmu-device you link the other devices against in .add_device.
Otherwise people will see two mmus in sysfs, one of them with no devices
behind it. That is inconsistent with the rest of the patch-set, which
basically handles bots mmus as one. But changing that should be easy, I
think.

Regards,

	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6924">Suman Anna</a> - Sept. 1, 2017, 5:05 p.m.</div>
<pre class="content">
On 09/01/2017 11:33 AM, Joerg Roedel wrote:
<span class="quote">&gt; Hi Suman,</span>
<span class="quote">&gt; On Fri, Sep 01, 2017 at 11:21:45AM -0500, Suman Anna wrote:</span>
<span class="quote">&gt;&gt; It&#39;s primarily a question of whether each iommu platform device need to</span>
<span class="quote">&gt;&gt; be represented as a unique iommu_device or not. If you still think that</span>
<span class="quote">&gt;&gt; both these need to be presented to iommu core as one device, I would</span>
<span class="quote">&gt;&gt; have to add some glue logic in probe to tie the two devices together.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think that you should only call iommu_device_register and friends for</span>
<span class="quote">&gt; the mmu-device you link the other devices against in .add_device.</span>
<span class="quote">&gt; Otherwise people will see two mmus in sysfs, one of them with no devices</span>
<span class="quote">&gt; behind it. That is inconsistent with the rest of the patch-set, which</span>
<span class="quote">&gt; basically handles bots mmus as one. But changing that should be easy, I</span>
<span class="quote">&gt; think.</span>

Thanks for the feedback and suggestions, let me look at adding that logic.

regards
Suman
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/omap-iommu.c b/drivers/iommu/omap-iommu.c</span>
<span class="p_header">index 81ef729994ce..9dd810f13c28 100644</span>
<span class="p_header">--- a/drivers/iommu/omap-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/omap-iommu.c</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"></span>
  * omap iommu: tlb and pagetable primitives
  *
  * Copyright (C) 2008-2010 Nokia Corporation
<span class="p_add">+ * Copyright (C) 2013-2017 Texas Instruments Incorporated - http://www.ti.com/</span>
  *
  * Written by Hiroshi DOYU &lt;Hiroshi.DOYU@nokia.com&gt;,
  *		Paul Mundt and Toshihiro Kobayashi
<span class="p_chunk">@@ -71,13 +72,23 @@</span> <span class="p_context"> static struct omap_iommu_domain *to_omap_domain(struct iommu_domain *dom)</span>
  **/
 void omap_iommu_save_ctx(struct device *dev)
 {
<span class="p_del">-	struct omap_iommu *obj = dev_to_omap_iommu(dev);</span>
<span class="p_del">-	u32 *p = obj-&gt;ctx;</span>
<span class="p_add">+	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct omap_iommu *obj;</span>
<span class="p_add">+	u32 *p;</span>
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; (MMU_REG_SIZE / sizeof(u32)); i++) {</span>
<span class="p_del">-		p[i] = iommu_read_reg(obj, i * sizeof(u32));</span>
<span class="p_del">-		dev_dbg(obj-&gt;dev, &quot;%s\t[%02d] %08x\n&quot;, __func__, i, p[i]);</span>
<span class="p_add">+	if (!arch_data)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (arch_data-&gt;iommu_dev) {</span>
<span class="p_add">+		obj = arch_data-&gt;iommu_dev;</span>
<span class="p_add">+		p = obj-&gt;ctx;</span>
<span class="p_add">+		for (i = 0; i &lt; (MMU_REG_SIZE / sizeof(u32)); i++) {</span>
<span class="p_add">+			p[i] = iommu_read_reg(obj, i * sizeof(u32));</span>
<span class="p_add">+			dev_dbg(obj-&gt;dev, &quot;%s\t[%02d] %08x\n&quot;, __func__, i,</span>
<span class="p_add">+				p[i]);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		arch_data++;</span>
 	}
 }
 EXPORT_SYMBOL_GPL(omap_iommu_save_ctx);
<span class="p_chunk">@@ -88,13 +99,23 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(omap_iommu_save_ctx);</span>
  **/
 void omap_iommu_restore_ctx(struct device *dev)
 {
<span class="p_del">-	struct omap_iommu *obj = dev_to_omap_iommu(dev);</span>
<span class="p_del">-	u32 *p = obj-&gt;ctx;</span>
<span class="p_add">+	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct omap_iommu *obj;</span>
<span class="p_add">+	u32 *p;</span>
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; (MMU_REG_SIZE / sizeof(u32)); i++) {</span>
<span class="p_del">-		iommu_write_reg(obj, p[i], i * sizeof(u32));</span>
<span class="p_del">-		dev_dbg(obj-&gt;dev, &quot;%s\t[%02d] %08x\n&quot;, __func__, i, p[i]);</span>
<span class="p_add">+	if (!arch_data)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (arch_data-&gt;iommu_dev) {</span>
<span class="p_add">+		obj = arch_data-&gt;iommu_dev;</span>
<span class="p_add">+		p = obj-&gt;ctx;</span>
<span class="p_add">+		for (i = 0; i &lt; (MMU_REG_SIZE / sizeof(u32)); i++) {</span>
<span class="p_add">+			iommu_write_reg(obj, p[i], i * sizeof(u32));</span>
<span class="p_add">+			dev_dbg(obj-&gt;dev, &quot;%s\t[%02d] %08x\n&quot;, __func__, i,</span>
<span class="p_add">+				p[i]);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		arch_data++;</span>
 	}
 }
 EXPORT_SYMBOL_GPL(omap_iommu_restore_ctx);
<span class="p_chunk">@@ -1068,11 +1089,13 @@</span> <span class="p_context"> static int omap_iommu_map(struct iommu_domain *domain, unsigned long da,</span>
 			  phys_addr_t pa, size_t bytes, int prot)
 {
 	struct omap_iommu_domain *omap_domain = to_omap_domain(domain);
<span class="p_del">-	struct omap_iommu *oiommu = omap_domain-&gt;iommu_dev;</span>
<span class="p_del">-	struct device *dev = oiommu-&gt;dev;</span>
<span class="p_add">+	struct device *dev = omap_domain-&gt;dev;</span>
<span class="p_add">+	struct omap_iommu_device *iommu;</span>
<span class="p_add">+	struct omap_iommu *oiommu;</span>
 	struct iotlb_entry e;
 	int omap_pgsz;
<span class="p_del">-	u32 ret;</span>
<span class="p_add">+	u32 ret = -EINVAL;</span>
<span class="p_add">+	int i;</span>
 
 	omap_pgsz = bytes_to_iopgsz(bytes);
 	if (omap_pgsz &lt; 0) {
<span class="p_chunk">@@ -1084,9 +1107,24 @@</span> <span class="p_context"> static int omap_iommu_map(struct iommu_domain *domain, unsigned long da,</span>
 
 	iotlb_init_entry(&amp;e, da, pa, omap_pgsz);
 
<span class="p_del">-	ret = omap_iopgtable_store_entry(oiommu, &amp;e);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		dev_err(dev, &quot;omap_iopgtable_store_entry failed: %d\n&quot;, ret);</span>
<span class="p_add">+	iommu = omap_domain-&gt;iommus;</span>
<span class="p_add">+	for (i = 0; i &lt; omap_domain-&gt;num_iommus; i++, iommu++) {</span>
<span class="p_add">+		oiommu = iommu-&gt;iommu_dev;</span>
<span class="p_add">+		ret = omap_iopgtable_store_entry(oiommu, &amp;e);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(dev, &quot;omap_iopgtable_store_entry failed: %d\n&quot;,</span>
<span class="p_add">+				ret);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		while (i--) {</span>
<span class="p_add">+			iommu--;</span>
<span class="p_add">+			oiommu = iommu-&gt;iommu_dev;</span>
<span class="p_add">+			iopgtable_clear_entry(oiommu, da);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1095,12 +1133,90 @@</span> <span class="p_context"> static size_t omap_iommu_unmap(struct iommu_domain *domain, unsigned long da,</span>
 			       size_t size)
 {
 	struct omap_iommu_domain *omap_domain = to_omap_domain(domain);
<span class="p_del">-	struct omap_iommu *oiommu = omap_domain-&gt;iommu_dev;</span>
<span class="p_del">-	struct device *dev = oiommu-&gt;dev;</span>
<span class="p_add">+	struct device *dev = omap_domain-&gt;dev;</span>
<span class="p_add">+	struct omap_iommu_device *iommu;</span>
<span class="p_add">+	struct omap_iommu *oiommu;</span>
<span class="p_add">+	bool error = false;</span>
<span class="p_add">+	size_t bytes = 0;</span>
<span class="p_add">+	int i;</span>
 
 	dev_dbg(dev, &quot;unmapping da 0x%lx size %u\n&quot;, da, size);
 
<span class="p_del">-	return iopgtable_clear_entry(oiommu, da);</span>
<span class="p_add">+	iommu = omap_domain-&gt;iommus;</span>
<span class="p_add">+	for (i = 0; i &lt; omap_domain-&gt;num_iommus; i++, iommu++) {</span>
<span class="p_add">+		oiommu = iommu-&gt;iommu_dev;</span>
<span class="p_add">+		bytes = iopgtable_clear_entry(oiommu, da);</span>
<span class="p_add">+		if (!bytes)</span>
<span class="p_add">+			error = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * simplify return - we are only checking if any of the iommus</span>
<span class="p_add">+	 * reported an error, but not if all of them are unmapping the</span>
<span class="p_add">+	 * same number of entries. This should not occur due to the</span>
<span class="p_add">+	 * mirror programming.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return error ? 0 : bytes;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int omap_iommu_count(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	int count = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (arch_data-&gt;iommu_dev) {</span>
<span class="p_add">+		count++;</span>
<span class="p_add">+		arch_data++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* caller should call cleanup if this function fails */</span>
<span class="p_add">+static int omap_iommu_attach_init(struct device *dev,</span>
<span class="p_add">+				  struct omap_iommu_domain *odomain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct omap_iommu_device *iommu;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	odomain-&gt;num_iommus = omap_iommu_count(dev);</span>
<span class="p_add">+	if (!odomain-&gt;num_iommus)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	odomain-&gt;iommus = kcalloc(odomain-&gt;num_iommus, sizeof(*iommu),</span>
<span class="p_add">+				  GFP_ATOMIC);</span>
<span class="p_add">+	if (!odomain-&gt;iommus)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu = odomain-&gt;iommus;</span>
<span class="p_add">+	for (i = 0; i &lt; odomain-&gt;num_iommus; i++, iommu++) {</span>
<span class="p_add">+		iommu-&gt;pgtable = kzalloc(IOPGD_TABLE_SIZE, GFP_ATOMIC);</span>
<span class="p_add">+		if (!iommu-&gt;pgtable)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * should never fail, but please keep this around to ensure</span>
<span class="p_add">+		 * we keep the hardware happy</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (WARN_ON(!IS_ALIGNED((long)iommu-&gt;pgtable,</span>
<span class="p_add">+					IOPGD_TABLE_SIZE)))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void omap_iommu_detach_fini(struct omap_iommu_domain *odomain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct omap_iommu_device *iommu = odomain-&gt;iommus;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; iommu &amp;&amp; i &lt; odomain-&gt;num_iommus; i++, iommu++)</span>
<span class="p_add">+		kfree(iommu-&gt;pgtable);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(odomain-&gt;iommus);</span>
<span class="p_add">+	odomain-&gt;num_iommus = 0;</span>
<span class="p_add">+	odomain-&gt;iommus = NULL;</span>
 }
 
 static int
<span class="p_chunk">@@ -1108,8 +1224,10 @@</span> <span class="p_context"> omap_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 {
 	struct omap_iommu_domain *omap_domain = to_omap_domain(domain);
 	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;
<span class="p_add">+	struct omap_iommu_device *iommu;</span>
 	struct omap_iommu *oiommu;
 	int ret = 0;
<span class="p_add">+	int i;</span>
 
 	if (!arch_data || !arch_data-&gt;iommu_dev) {
 		dev_err(dev, &quot;device doesn&#39;t have an associated iommu\n&quot;);
<span class="p_chunk">@@ -1125,19 +1243,42 @@</span> <span class="p_context"> omap_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 		goto out;
 	}
 
<span class="p_del">-	oiommu = arch_data-&gt;iommu_dev;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get a handle to and enable the omap iommu */</span>
<span class="p_del">-	ret = omap_iommu_attach(oiommu, omap_domain-&gt;pgtable);</span>
<span class="p_add">+	ret = omap_iommu_attach_init(dev, omap_domain);</span>
 	if (ret) {
<span class="p_del">-		dev_err(dev, &quot;can&#39;t get omap iommu: %d\n&quot;, ret);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		dev_err(dev, &quot;failed to allocate required iommu data %d\n&quot;,</span>
<span class="p_add">+			ret);</span>
<span class="p_add">+		goto init_fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu = omap_domain-&gt;iommus;</span>
<span class="p_add">+	for (i = 0; i &lt; omap_domain-&gt;num_iommus; i++, iommu++, arch_data++) {</span>
<span class="p_add">+		/* configure and enable the omap iommu */</span>
<span class="p_add">+		oiommu = arch_data-&gt;iommu_dev;</span>
<span class="p_add">+		ret = omap_iommu_attach(oiommu, iommu-&gt;pgtable);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(dev, &quot;can&#39;t get omap iommu: %d\n&quot;, ret);</span>
<span class="p_add">+			goto attach_fail;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		oiommu-&gt;domain = domain;</span>
<span class="p_add">+		iommu-&gt;iommu_dev = oiommu;</span>
 	}
 
<span class="p_del">-	omap_domain-&gt;iommu_dev = oiommu;</span>
 	omap_domain-&gt;dev = dev;
<span class="p_del">-	oiommu-&gt;domain = domain;</span>
 
<span class="p_add">+	goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+attach_fail:</span>
<span class="p_add">+	while (i--) {</span>
<span class="p_add">+		iommu--;</span>
<span class="p_add">+		arch_data--;</span>
<span class="p_add">+		oiommu = iommu-&gt;iommu_dev;</span>
<span class="p_add">+		omap_iommu_detach(oiommu);</span>
<span class="p_add">+		iommu-&gt;iommu_dev = NULL;</span>
<span class="p_add">+		oiommu-&gt;domain = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+init_fail:</span>
<span class="p_add">+	omap_iommu_detach_fini(omap_domain);</span>
 out:
 	spin_unlock(&amp;omap_domain-&gt;lock);
 	return ret;
<span class="p_chunk">@@ -1146,7 +1287,10 @@</span> <span class="p_context"> omap_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 static void _omap_iommu_detach_dev(struct omap_iommu_domain *omap_domain,
 				   struct device *dev)
 {
<span class="p_del">-	struct omap_iommu *oiommu = dev_to_omap_iommu(dev);</span>
<span class="p_add">+	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct omap_iommu_device *iommu = omap_domain-&gt;iommus;</span>
<span class="p_add">+	struct omap_iommu *oiommu;</span>
<span class="p_add">+	int i;</span>
 
 	if (!omap_domain-&gt;dev) {
 		dev_err(dev, &quot;domain has no attached device\n&quot;);
<span class="p_chunk">@@ -1159,13 +1303,24 @@</span> <span class="p_context"> static void _omap_iommu_detach_dev(struct omap_iommu_domain *omap_domain,</span>
 		return;
 	}
 
<span class="p_del">-	iopgtable_clear_entry_all(oiommu);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * cleanup in the reverse order of attachment - this addresses</span>
<span class="p_add">+	 * any h/w dependencies between multiple instances, if any</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iommu += (omap_domain-&gt;num_iommus - 1);</span>
<span class="p_add">+	arch_data += (omap_domain-&gt;num_iommus - 1);</span>
<span class="p_add">+	for (i = 0; i &lt; omap_domain-&gt;num_iommus; i++, iommu--, arch_data--) {</span>
<span class="p_add">+		oiommu = iommu-&gt;iommu_dev;</span>
<span class="p_add">+		iopgtable_clear_entry_all(oiommu);</span>
<span class="p_add">+</span>
<span class="p_add">+		omap_iommu_detach(oiommu);</span>
<span class="p_add">+		iommu-&gt;iommu_dev = NULL;</span>
<span class="p_add">+		oiommu-&gt;domain = NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	omap_iommu_detach(oiommu);</span>
<span class="p_add">+	omap_iommu_detach_fini(omap_domain);</span>
 
<span class="p_del">-	omap_domain-&gt;iommu_dev = NULL;</span>
 	omap_domain-&gt;dev = NULL;
<span class="p_del">-	oiommu-&gt;domain = NULL;</span>
 }
 
 static void omap_iommu_detach_dev(struct iommu_domain *domain,
<span class="p_chunk">@@ -1187,18 +1342,7 @@</span> <span class="p_context"> static struct iommu_domain *omap_iommu_domain_alloc(unsigned type)</span>
 
 	omap_domain = kzalloc(sizeof(*omap_domain), GFP_KERNEL);
 	if (!omap_domain)
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	omap_domain-&gt;pgtable = kzalloc(IOPGD_TABLE_SIZE, GFP_KERNEL);</span>
<span class="p_del">-	if (!omap_domain-&gt;pgtable)</span>
<span class="p_del">-		goto fail_nomem;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * should never fail, but please keep this around to ensure</span>
<span class="p_del">-	 * we keep the hardware happy</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (WARN_ON(!IS_ALIGNED((long)omap_domain-&gt;pgtable, IOPGD_TABLE_SIZE)))</span>
<span class="p_del">-		goto fail_align;</span>
<span class="p_add">+		return NULL;</span>
 
 	spin_lock_init(&amp;omap_domain-&gt;lock);
 
<span class="p_chunk">@@ -1207,13 +1351,6 @@</span> <span class="p_context"> static struct iommu_domain *omap_iommu_domain_alloc(unsigned type)</span>
 	omap_domain-&gt;domain.geometry.force_aperture = true;
 
 	return &amp;omap_domain-&gt;domain;
<span class="p_del">-</span>
<span class="p_del">-fail_align:</span>
<span class="p_del">-	kfree(omap_domain-&gt;pgtable);</span>
<span class="p_del">-fail_nomem:</span>
<span class="p_del">-	kfree(omap_domain);</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return NULL;</span>
 }
 
 static void omap_iommu_domain_free(struct iommu_domain *domain)
<span class="p_chunk">@@ -1227,7 +1364,6 @@</span> <span class="p_context"> static void omap_iommu_domain_free(struct iommu_domain *domain)</span>
 	if (omap_domain-&gt;dev)
 		_omap_iommu_detach_dev(omap_domain, omap_domain-&gt;dev);
 
<span class="p_del">-	kfree(omap_domain-&gt;pgtable);</span>
 	kfree(omap_domain);
 }
 
<span class="p_chunk">@@ -1235,11 +1371,16 @@</span> <span class="p_context"> static phys_addr_t omap_iommu_iova_to_phys(struct iommu_domain *domain,</span>
 					   dma_addr_t da)
 {
 	struct omap_iommu_domain *omap_domain = to_omap_domain(domain);
<span class="p_del">-	struct omap_iommu *oiommu = omap_domain-&gt;iommu_dev;</span>
<span class="p_add">+	struct omap_iommu_device *iommu = omap_domain-&gt;iommus;</span>
<span class="p_add">+	struct omap_iommu *oiommu = iommu-&gt;iommu_dev;</span>
 	struct device *dev = oiommu-&gt;dev;
 	u32 *pgd, *pte;
 	phys_addr_t ret = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * all the iommus within the domain will have identical programming,</span>
<span class="p_add">+	 * so perform the lookup using just the first iommu</span>
<span class="p_add">+	 */</span>
 	iopgtable_lookup_entry(oiommu, da, &amp;pgd, &amp;pte);
 
 	if (pte) {
<span class="p_chunk">@@ -1265,11 +1406,12 @@</span> <span class="p_context"> static phys_addr_t omap_iommu_iova_to_phys(struct iommu_domain *domain,</span>
 
 static int omap_iommu_add_device(struct device *dev)
 {
<span class="p_del">-	struct omap_iommu_arch_data *arch_data;</span>
<span class="p_add">+	struct omap_iommu_arch_data *arch_data, *tmp;</span>
 	struct omap_iommu *oiommu;
 	struct iommu_group *group;
 	struct device_node *np;
 	struct platform_device *pdev;
<span class="p_add">+	int num_iommus, i;</span>
 	int ret;
 
 	/*
<span class="p_chunk">@@ -1281,36 +1423,57 @@</span> <span class="p_context"> static int omap_iommu_add_device(struct device *dev)</span>
 	if (!dev-&gt;of_node)
 		return 0;
 
<span class="p_del">-	np = of_parse_phandle(dev-&gt;of_node, &quot;iommus&quot;, 0);</span>
<span class="p_del">-	if (!np)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * retrieve the count of IOMMU nodes using phandle size as element size</span>
<span class="p_add">+	 * since #iommu-cells = 0 for OMAP</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	num_iommus = of_property_count_elems_of_size(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="p_add">+						     sizeof(phandle));</span>
<span class="p_add">+	if (num_iommus &lt; 0)</span>
 		return 0;
 
<span class="p_del">-	pdev = of_find_device_by_node(np);</span>
<span class="p_del">-	if (WARN_ON(!pdev)) {</span>
<span class="p_del">-		of_node_put(np);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	arch_data = kzalloc((num_iommus + 1) * sizeof(*arch_data), GFP_KERNEL);</span>
<span class="p_add">+	if (!arch_data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	oiommu = platform_get_drvdata(pdev);</span>
<span class="p_del">-	if (!oiommu) {</span>
<span class="p_del">-		of_node_put(np);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = 0, tmp = arch_data; i &lt; num_iommus; i++, tmp++) {</span>
<span class="p_add">+		np = of_parse_phandle(dev-&gt;of_node, &quot;iommus&quot;, i);</span>
<span class="p_add">+		if (!np) {</span>
<span class="p_add">+			kfree(arch_data);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		pdev = of_find_device_by_node(np);</span>
<span class="p_add">+		if (WARN_ON(!pdev)) {</span>
<span class="p_add">+			of_node_put(np);</span>
<span class="p_add">+			kfree(arch_data);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		oiommu = platform_get_drvdata(pdev);</span>
<span class="p_add">+		if (!oiommu) {</span>
<span class="p_add">+			of_node_put(np);</span>
<span class="p_add">+			kfree(arch_data);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp-&gt;iommu_dev = oiommu;</span>
 
<span class="p_del">-	arch_data = kzalloc(sizeof(*arch_data), GFP_KERNEL);</span>
<span class="p_del">-	if (!arch_data) {</span>
 		of_node_put(np);
<span class="p_del">-		return -ENOMEM;</span>
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * use the first IOMMU alone for the sysfs device linking.</span>
<span class="p_add">+	 * TODO: Evaluate if a single iommu_group needs to be</span>
<span class="p_add">+	 * maintained for both IOMMUs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	oiommu = arch_data-&gt;iommu_dev;</span>
 	ret = iommu_device_link(&amp;oiommu-&gt;iommu, dev);
 	if (ret) {
 		kfree(arch_data);
<span class="p_del">-		of_node_put(np);</span>
 		return ret;
 	}
 
<span class="p_del">-	arch_data-&gt;iommu_dev = oiommu;</span>
 	dev-&gt;archdata.iommu = arch_data;
 
 	/*
<span class="p_chunk">@@ -1326,8 +1489,6 @@</span> <span class="p_context"> static int omap_iommu_add_device(struct device *dev)</span>
 	}
 	iommu_group_put(group);
 
<span class="p_del">-	of_node_put(np);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/iommu/omap-iommu.h b/drivers/iommu/omap-iommu.h</span>
<span class="p_header">index a675af29a6ec..1703159ef5af 100644</span>
<span class="p_header">--- a/drivers/iommu/omap-iommu.h</span>
<span class="p_header">+++ b/drivers/iommu/omap-iommu.h</span>
<span class="p_chunk">@@ -29,17 +29,26 @@</span> <span class="p_context"> struct iotlb_entry {</span>
 };
 
 /**
<span class="p_add">+ * struct omap_iommu_device - omap iommu device data</span>
<span class="p_add">+ * @pgtable:	page table used by an omap iommu attached to a domain</span>
<span class="p_add">+ * @iommu_dev:	pointer to store an omap iommu instance attached to a domain</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct omap_iommu_device {</span>
<span class="p_add">+	u32 *pgtable;</span>
<span class="p_add">+	struct omap_iommu *iommu_dev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * struct omap_iommu_domain - omap iommu domain
<span class="p_del">- * @pgtable:	the page table</span>
<span class="p_del">- * @iommu_dev:	an omap iommu device attached to this domain. only a single</span>
<span class="p_del">- *		iommu device can be attached for now.</span>
<span class="p_add">+ * @num_iommus: number of iommus in this domain</span>
<span class="p_add">+ * @iommus:	omap iommu device data for all iommus in this domain</span>
  * @dev:	Device using this domain.
  * @lock:	domain lock, should be taken when attaching/detaching
  * @domain:	generic domain handle used by iommu core code
  */
 struct omap_iommu_domain {
<span class="p_del">-	u32 *pgtable;</span>
<span class="p_del">-	struct omap_iommu *iommu_dev;</span>
<span class="p_add">+	u32 num_iommus;</span>
<span class="p_add">+	struct omap_iommu_device *iommus;</span>
 	struct device *dev;
 	spinlock_t lock;
 	struct iommu_domain domain;
<span class="p_chunk">@@ -97,17 +106,6 @@</span> <span class="p_context"> struct iotlb_lock {</span>
 	short vict;
 };
 
<span class="p_del">-/**</span>
<span class="p_del">- * dev_to_omap_iommu() - retrieves an omap iommu object from a user device</span>
<span class="p_del">- * @dev: iommu client device</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline struct omap_iommu *dev_to_omap_iommu(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct omap_iommu_arch_data *arch_data = dev-&gt;archdata.iommu;</span>
<span class="p_del">-</span>
<span class="p_del">-	return arch_data-&gt;iommu_dev;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * MMU Register offsets
  */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



