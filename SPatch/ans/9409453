
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 2, 2016, 4:11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1478103063-17653-4-git-send-email-matt.redfearn@imgtec.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9409453/mbox/"
   >mbox</a>
|
   <a href="/patch/9409453/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9409453/">/patch/9409453/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A98E160722 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Nov 2016 16:11:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 985EA2A443
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Nov 2016 16:11:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8CA832A444; Wed,  2 Nov 2016 16:11:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 716662A451
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Nov 2016 16:11:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756165AbcKBQLf (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 2 Nov 2016 12:11:35 -0400
Received: from mailapp01.imgtec.com ([195.59.15.196]:41507 &quot;EHLO
	mailapp01.imgtec.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756025AbcKBQLY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 2 Nov 2016 12:11:24 -0400
Received: from HHMAIL01.hh.imgtec.org (unknown [10.100.10.19])
	by Forcepoint Email with ESMTPS id 83C2AA516B9F3;
	Wed,  2 Nov 2016 16:11:17 +0000 (GMT)
Received: from mredfearn-linux.le.imgtec.org (10.150.130.83) by
	HHMAIL01.hh.imgtec.org (10.100.10.21) with Microsoft SMTP Server
	(TLS) id 14.3.294.0; Wed, 2 Nov 2016 16:11:21 +0000
From: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
To: Ralf Baechle &lt;ralf@linux-mips.org&gt;,
	Bjorn Andersson &lt;bjorn.andersson@linaro.org&gt;,
	Ohad Ben-Cohen &lt;ohad@wizery.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;
CC: &lt;linux-mips@linux-mips.org&gt;, &lt;linux-remoteproc@vger.kernel.org&gt;,
	&lt;lisa.parratt@imgtec.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
Subject: [PATCH v4 3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS
Date: Wed, 2 Nov 2016 16:11:02 +0000
Message-ID: &lt;1478103063-17653-4-git-send-email-matt.redfearn@imgtec.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1478103063-17653-1-git-send-email-matt.redfearn@imgtec.com&gt;
References: &lt;1478103063-17653-1-git-send-email-matt.redfearn@imgtec.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.150.130.83]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Nov. 2, 2016, 4:11 p.m.</div>
<pre class="content">
This driver allows a MIPS processor offlined from Linux to be used as a
remote processor. Firmware may be loaded via the sysfs interface and
changed at runtime, allowing the processor to handle real-time tasks or
perform coprocessing while remaining processors are available to Linux.

Coprocessor firmware must abide by the remoteproc standard, i.e.
implement the resource table containing memory layouts and virtio device
descriptions, and additionally abide by the MIPS UHI coprocessor boot
protocol in the startup code.
<span class="signed-off-by">
Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>

---

Changes in v4:
Have a single mips-rproc device to be parent to each CPU&#39;s rproc device.
Support per-device coherence introduced in v4.9
Add a sysfs interface to control the mask of cpus available to rproc

Changes in v3:
Update MIPS remoteproc driver to use CPU hotplug state machine
Remove sysfs interface from MIPS rproc driver, now provided by the core.
Drop patches that Ralf has already merged to mips-next

Changes in v2: None

 Documentation/ABI/testing/sysfs-devices-mips-rproc |  13 +
 drivers/remoteproc/Kconfig                         |  11 +
 drivers/remoteproc/Makefile                        |   1 +
 drivers/remoteproc/mips_remoteproc.c               | 592 +++++++++++++++++++++
 4 files changed, 617 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-devices-mips-rproc
 create mode 100644 drivers/remoteproc/mips_remoteproc.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-devices-mips-rproc b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
new file mode 100644
<span class="p_header">index 000000000000..b06f6671807a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
<span class="p_chunk">@@ -0,0 +1,13 @@</span> <span class="p_context"></span>
<span class="p_add">+What:		/sys/devices/mips-rproc/cpus</span>
<span class="p_add">+Date:		October 2016</span>
<span class="p_add">+Contact:	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+Description:</span>
<span class="p_add">+		CPU topology file describing which CPUs may be used by the</span>
<span class="p_add">+		MIPS remote processor driver when offline from Linux.</span>
<span class="p_add">+</span>
<span class="p_add">+		This can be read to observe the current setting, or written to</span>
<span class="p_add">+		change the allowed CPUs.</span>
<span class="p_add">+</span>
<span class="p_add">+		The format is compatible with cpulist_parse()</span>
<span class="p_add">+		[see &lt;linux/cpumask.h&gt;], for example to enable the MIPS remote</span>
<span class="p_add">+		processor driver on CPUs 1,2 &amp; 3, write &quot;1-3&quot; into this file.</span>
<span class="p_header">diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="p_header">index f396bfef5d42..debdc60230b2 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Kconfig</span>
<span class="p_header">+++ b/drivers/remoteproc/Kconfig</span>
<span class="p_chunk">@@ -116,4 +116,15 @@</span> <span class="p_context"> config ST_REMOTEPROC</span>
 	  processor framework.
 	  This can be either built-in or a loadable module.
 
<span class="p_add">+config MIPS_REMOTEPROC</span>
<span class="p_add">+	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="p_add">+	depends on MIPS_CPS &amp;&amp; HAS_DMA</span>
<span class="p_add">+	select CMA</span>
<span class="p_add">+	select REMOTEPROC</span>
<span class="p_add">+	select MIPS_CPU_STEAL</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="p_add">+	  via the remote processor framework.</span>
<span class="p_add">+	  If unsure say N.</span>
<span class="p_add">+</span>
 endmenu
<span class="p_header">diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="p_header">index 6dfb62ed643f..cc7488dce76b 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Makefile</span>
<span class="p_header">+++ b/drivers/remoteproc/Makefile</span>
<span class="p_chunk">@@ -16,3 +16,4 @@</span> <span class="p_context"> obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o</span>
 obj-$(CONFIG_QCOM_WCNSS_IRIS)		+= qcom_wcnss_iris.o
 obj-$(CONFIG_QCOM_WCNSS_PIL)		+= qcom_wcnss.o
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
<span class="p_add">+obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
<span class="p_header">diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..725064a59f7b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="p_chunk">@@ -0,0 +1,592 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MIPS Remote Processor driver</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Imagination Technologies</span>
<span class="p_add">+ * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+ * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms of the GNU General Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/remoteproc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/smp-cps.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbmisc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;remoteproc_internal.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+struct mips_rproc {</span>
<span class="p_add">+	char			name[16];</span>
<span class="p_add">+	struct rproc		*rproc;</span>
<span class="p_add">+	struct task_struct	*tsk;</span>
<span class="p_add">+	unsigned int		cpu;</span>
<span class="p_add">+	int			ipi_linux;</span>
<span class="p_add">+	int			ipi_remote;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Parent device for MIPS remoteproc */</span>
<span class="p_add">+static struct device mips_rproc_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Array of allocated MIPS remote processor instances */</span>
<span class="p_add">+static struct mips_rproc *mips_rprocs[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+/* Bitmap used to identify which CPUs are available to rproc */</span>
<span class="p_add">+static cpumask_var_t mips_rproc_cpumask;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dynamic CPU hotplug state associated with this driver */</span>
<span class="p_add">+static int cpuhp_state;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Add wired entry to map a device address to physical memory */</span>
<span class="p_add">+static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+			  unsigned long pagesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="p_add">+	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="p_add">+	unsigned long pagemask = pagesize - 0x2000;</span>
<span class="p_add">+</span>
<span class="p_add">+	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	entryhi = da &amp; 0xfffffe000;</span>
<span class="p_add">+	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="p_add">+	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="p_add">+	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="p_add">+	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="p_add">+	pr_debug(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="p_add">+static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="p_add">+					   unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long mask;</span>
<span class="p_add">+	/* Find address bits limiting alignment */</span>
<span class="p_add">+	unsigned long shift = ffs(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Obey MIPS restrictions on page sizes */</span>
<span class="p_add">+	if (pa) {</span>
<span class="p_add">+		if (shift &amp; 1)</span>
<span class="p_add">+			shift -= 2;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			shift--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="p_add">+	return maxmask &amp; ~mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the page mask one step larger than a given page mask */</span>
<span class="p_add">+static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+#define PM_SHIFT 13</span>
<span class="p_add">+	return ((pm &lt;&lt; 2) | (0x3 &lt;&lt; PM_SHIFT)) &amp; maxmask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Add mappings to the TLB such that memory allocated by the kernel for a</span>
<span class="p_add">+ * firmware component appears at the right virtual address</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void mips_rproc_map(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+				  unsigned long size, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* minimum mappable size is 2 * 4k pages */</span>
<span class="p_add">+	const unsigned long min_map_sz = 0x2000;</span>
<span class="p_add">+	unsigned long bigmask, nextmask;</span>
<span class="p_add">+	unsigned long distance, target;</span>
<span class="p_add">+	unsigned long page2_size; /* Size of the 2 buddy pages */</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		/* Compute the current largest page mask */</span>
<span class="p_add">+		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="p_add">+		/* Compute the next largest pagesize */</span>
<span class="p_add">+		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Compute the distance from our current physical address to</span>
<span class="p_add">+		 * the next page boundary.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		distance = (nextmask + min_map_sz) - (pa &amp; nextmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Decide between searching to get to the next highest page</span>
<span class="p_add">+		 * boundary or finishing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		target = distance &lt; size ? distance : size;</span>
<span class="p_add">+		while (target) {</span>
<span class="p_add">+			/* Find the largest supported page size that will fit */</span>
<span class="p_add">+			for (page2_size = maxmask + min_map_sz;</span>
<span class="p_add">+			    (page2_size &gt; min_map_sz) &amp;&amp; (page2_size &gt; target);</span>
<span class="p_add">+			     page2_size /= 4) {</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* Emit it */</span>
<span class="p_add">+			mips_map_page(da, pa, c, page2_size);</span>
<span class="p_add">+			/* Move to next step */</span>
<span class="p_add">+			size -= page2_size;</span>
<span class="p_add">+			da += page2_size;</span>
<span class="p_add">+			pa += page2_size;</span>
<span class="p_add">+			target -= page2_size;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_mem_entry *carveout;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="p_add">+		int c = CONF_CM_CACHABLE_COW;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="p_add">+</span>
<span class="p_add">+		mips_rproc_map(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="p_add">+				carveout-&gt;len, max_pagemask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_vdev *rvdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="p_add">+		int i, size;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="p_add">+			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="p_add">+			unsigned long pa = vring-&gt;dma;</span>
<span class="p_add">+			int c;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (plat_device_is_coherent(&amp;mips_rproc_dev)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * The DMA API will allocate cacheable buffers</span>
<span class="p_add">+				 * for shared resources, so the firmware should</span>
<span class="p_add">+				 * also access those buffers cached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Otherwise, shared buffers should be accessed</span>
<span class="p_add">+				 * uncached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = CONF_CM_UNCACHED;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* actual size of vring (in bytes) */</span>
<span class="p_add">+			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="p_add">+</span>
<span class="p_add">+			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="p_add">+</span>
<span class="p_add">+			mips_rproc_map(pa, pa, c, size, max_pagemask);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_cpu_entry(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = mips_rprocs[smp_processor_id()];</span>
<span class="p_add">+	struct rproc *rproc = mproc-&gt;rproc;</span>
<span class="p_add">+	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="p_add">+	unsigned long old_pagemask, max_pagemask;</span>
<span class="p_add">+	void (*fw_entry)(int, int ipi_to_remote, int ipi_from_remote, int);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;rproc-&gt;dev, &quot;%s booting firmware %s\n&quot;,</span>
<span class="p_add">+		 rproc-&gt;name, rproc-&gt;firmware);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the maximum pagemask supported on this CPU */</span>
<span class="p_add">+	old_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(~0);</span>
<span class="p_add">+	back_to_back_c0_hazard();</span>
<span class="p_add">+	max_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(old_pagemask);</span>
<span class="p_add">+	back_to_back_c0_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start with no wired entries */</span>
<span class="p_add">+	write_c0_wired(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush all previous TLB entries */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set ASID 0 */</span>
<span class="p_add">+	write_c0_entryhi(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map firmware resources into virtual memory */</span>
<span class="p_add">+	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="p_add">+	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Hand off the CPU to the firmware */</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Jump into the firmware, obeying the firmware protocol. */</span>
<span class="p_add">+	fw_entry = (void *)rproc-&gt;bootaddr;</span>
<span class="p_add">+	fw_entry(-3, ipi_to_remote, ipi_from_remote, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="p_add">+	return IRQ_WAKE_THREAD;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = (struct rproc *)p;</span>
<span class="p_add">+	void *entry;</span>
<span class="p_add">+	int id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="p_add">+	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="p_add">+		rproc_vq_interrupt(rproc, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function to find the IPI domain */</span>
<span class="p_add">+static struct irq_domain *ipi_domain(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="p_add">+	struct irq_domain *ipidomain;</span>
<span class="p_add">+</span>
<span class="p_add">+	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="p_add">+	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="p_add">+	 * DT.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (node &amp;&amp; !ipidomain)</span>
<span class="p_add">+		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ipidomain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int cpu = mproc-&gt;cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="p_add">+	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="p_add">+	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="p_add">+	if (mips_smp_ipi_free(get_cpu_mask(cpu))) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_free_tsk;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="p_add">+	 * offlined while the remote CPU is running.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_linux) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_restore_ipi;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_remote) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="p_add">+		goto exit_destroy_ipi_linux;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* register incoming ipi */</span>
<span class="p_add">+	err = request_threaded_irq(mproc-&gt;ipi_linux, mips_rproc_ipi_handler,</span>
<span class="p_add">+				   mips_rproc_vq_int, 0,</span>
<span class="p_add">+				   &quot;mips-rproc IPI in&quot;, rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="p_add">+			err);</span>
<span class="p_add">+		goto exit_destroy_ipi_remote;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="p_add">+						mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="p_add">+		goto exit_free_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_irq:</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+exit_destroy_ipi_remote:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="p_add">+exit_destroy_ipi_linux:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+exit_restore_ipi:</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="p_add">+exit_free_tsk:</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rproc-&gt;state == RPROC_RUNNING)</span>
<span class="p_add">+		ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="p_add">+	.start	= mips_rproc_op_start,</span>
<span class="p_add">+	.stop	= mips_rproc_op_stop,</span>
<span class="p_add">+	.kick	= mips_rproc_op_kick,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Create an rproc instance in response to CPU down */</span>
<span class="p_add">+static int mips_rproc_device_register(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *template = &quot;mips-cpu%u&quot;;</span>
<span class="p_add">+	struct rproc *rproc;</span>
<span class="p_add">+	struct mips_rproc *mproc;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpumask_test_cpu(cpu, mips_rproc_cpumask))</span>
<span class="p_add">+		/* The CPU is not in the mask, so don&#39;t register rproc on it */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Allocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_rprocs[cpu]) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc = kzalloc(sizeof(struct mips_rproc), GFP_KERNEL);</span>
<span class="p_add">+	if (!mproc) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	snprintf(mproc-&gt;name, sizeof(mproc-&gt;name), template, cpu);</span>
<span class="p_add">+	mproc-&gt;cpu = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc = rproc_alloc(&amp;mips_rproc_dev, mproc-&gt;name,</span>
<span class="p_add">+			    &amp;mips_rproc_proc_ops, NULL,</span>
<span class="p_add">+			    sizeof(struct mips_rproc *));</span>
<span class="p_add">+	if (!rproc) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Error allocating rproc\n&quot;);</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit_free_mproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;rproc = rproc;</span>
<span class="p_add">+	rproc-&gt;priv = (void *)mproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = rproc_add(rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="p_add">+		goto exit_free_rproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = mproc;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_rproc:</span>
<span class="p_add">+	rproc_free(rproc);</span>
<span class="p_add">+exit_free_mproc:</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+exit:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Destroy rproc instance in response to CPU up */</span>
<span class="p_add">+static int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = mips_rprocs[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mproc)</span>
<span class="p_add">+		/* No rproc instance has been created for this CPU */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Deallocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc_del(mproc-&gt;rproc);</span>
<span class="p_add">+	rproc_put(mproc-&gt;rproc);</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = NULL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Show MIPS CPUs available to rproc */</span>
<span class="p_add">+static ssize_t cpus_show(struct device *dev, struct device_attribute *attr,</span>
<span class="p_add">+			  char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cpumap_print_to_pagebuf(true, buf, mips_rproc_cpumask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allow MIPS CPUs to be made available to rproc */</span>
<span class="p_add">+static ssize_t cpus_store(struct device *dev,</span>
<span class="p_add">+			      struct device_attribute *attr,</span>
<span class="p_add">+			      const char *buf, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static cpumask_var_t new_mask;</span>
<span class="p_add">+	int err, cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = cpulist_parse(buf, new_mask);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prevent CPU hotplug on/offlining CPUs while we do this */</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_possible_cpu(cpu) {</span>
<span class="p_add">+		if (cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="p_add">+		    !cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="p_add">+			/* CPU no longer allowed. Release any instance on it */</span>
<span class="p_add">+			cpumask_clear_cpu(cpu, mips_rproc_cpumask);</span>
<span class="p_add">+			mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		} else if (!cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="p_add">+			   cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="p_add">+			/* If the CPU isn&#39;t online, start an instance */</span>
<span class="p_add">+			cpumask_set_cpu(cpu, mips_rproc_cpumask);</span>
<span class="p_add">+			if (!cpu_online(cpu))</span>
<span class="p_add">+				mips_rproc_device_register(cpu);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+static DEVICE_ATTR_RW(cpus);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *mips_rproc_attrs[] = {</span>
<span class="p_add">+	&amp;dev_attr_cpus.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group mips_rproc_devgroup = {</span>
<span class="p_add">+	.attrs = mips_rproc_attrs</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *mips_rproc_devgroups[] = {</span>
<span class="p_add">+	&amp;mips_rproc_devgroup,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+static struct device_type mips_rproc_type = {</span>
<span class="p_add">+	.groups = mips_rproc_devgroups,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mips_rproc_driver = {</span>
<span class="p_add">+	.driver = {</span>
<span class="p_add">+		.name = &quot;mips-rproc&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mips_rproc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!cpu_has_mipsmt) &amp;&amp; (!cpu_has_vp)) {</span>
<span class="p_add">+		pr_debug(&quot;MIPS rproc not supported on this cpu\n&quot;);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rproc_dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="p_add">+	mips_rproc_dev.type = &amp;mips_rproc_type;</span>
<span class="p_add">+	dev_set_name(&amp;mips_rproc_dev, &quot;mips-rproc&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set device to have coherent DMA ops */</span>
<span class="p_add">+	arch_setup_dma_ops(&amp;mips_rproc_dev, 0, 0, NULL, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = device_register(&amp;mips_rproc_dev);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Error adding MIPS rproc: %d\n&quot;, err);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Register with the cpu hotplug state machine.</span>
<span class="p_add">+	 * This driver requires opposite sense to &quot;normal&quot; drivers, since the</span>
<span class="p_add">+	 * driver is activated for offline CPUs via the teardown callback and</span>
<span class="p_add">+	 * deactivated via the online callback.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;MIPS:REMOTEPROC&quot;,</span>
<span class="p_add">+				mips_rproc_device_unregister,</span>
<span class="p_add">+				mips_rproc_device_register);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		device_unregister(&amp;mips_rproc_dev);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cpuhp_state = err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mips_rproc_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpuhp_state) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Unregister with the cpu hotplug state machine, but don&#39;t call</span>
<span class="p_add">+		 * the teardown callback, since that would try to start the</span>
<span class="p_add">+		 * remote processor device.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__cpuhp_remove_state(cpuhp_state, false);</span>
<span class="p_add">+		cpuhp_state = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	/* Unregister devices created for any offline CPUs */</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+late_initcall(mips_rproc_init);</span>
<span class="p_add">+module_exit(mips_rproc_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(mips_rproc_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



