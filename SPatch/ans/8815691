
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 12, 2016, 9:01 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160412210146.GB11374@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8815691/mbox/"
   >mbox</a>
|
   <a href="/patch/8815691/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8815691/">/patch/8815691/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 804B09F39A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Apr 2016 21:02:42 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 79FE820379
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Apr 2016 21:02:27 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 0CC022035D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Apr 2016 21:02:13 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1030604AbcDLVCD (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 12 Apr 2016 17:02:03 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37395 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755991AbcDLVBs (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 12 Apr 2016 17:01:48 -0400
Received: from localhost (unknown [67.51.76.21])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 739EFEE8;
	Tue, 12 Apr 2016 21:01:47 +0000 (UTC)
Date: Tue, 12 Apr 2016 14:01:46 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.7
Message-ID: &lt;20160412210146.GB11374@kroah.com&gt;
References: &lt;20160412210129.GA11374@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160412210129.GA11374@kroah.com&gt;
User-Agent: Mutt/1.6.0 (2016-04-01)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-2.9 required=5.0 tests=BAYES_00,RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - April 12, 2016, 9:01 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index d826f1b9eb02..4c3e1d2ac31b 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -230,13 +230,13 @@</span> <span class="p_context"> F:	kernel/sys_ni.c</span>
 
 ABIT UGURU 1,2 HARDWARE MONITOR DRIVER
 M:	Hans de Goede &lt;hdegoede@redhat.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/abituguru.c
 
 ABIT UGURU 3 HARDWARE MONITOR DRIVER
 M:	Alistair John Strachan &lt;alistair@devzero.co.uk&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/abituguru3.c
 
<span class="p_chunk">@@ -373,14 +373,14 @@</span> <span class="p_context"> S:	Maintained</span>
 
 ADM1025 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/adm1025
 F:	drivers/hwmon/adm1025.c
 
 ADM1029 HARDWARE MONITOR DRIVER
 M:	Corentin Labbe &lt;clabbe.montjoie@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/adm1029.c
 
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> F:	drivers/video/backlight/adp8860_bl.c</span>
 
 ADS1015 HARDWARE MONITOR DRIVER
 M:	Dirk Eibach &lt;eibach@gdsys.de&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/ads1015
 F:	drivers/hwmon/ads1015.c
<span class="p_chunk">@@ -438,7 +438,7 @@</span> <span class="p_context"> F:	drivers/macintosh/therm_adt746x.c</span>
 
 ADT7475 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/adt7475
 F:	drivers/hwmon/adt7475.c
<span class="p_chunk">@@ -615,7 +615,7 @@</span> <span class="p_context"> F:	include/linux/ccp.h</span>
 
 AMD FAM15H PROCESSOR POWER MONITORING DRIVER
 M:	Andreas Herrmann &lt;herrmann.der.user@googlemail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/fam15h_power
 F:	drivers/hwmon/fam15h_power.c
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> F:	drivers/input/mouse/bcm5974.c</span>
 
 APPLE SMC DRIVER
 M:	Henrik Rydberg &lt;rydberg@bitmath.org&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Odd fixes
 F:	drivers/hwmon/applesmc.c
 
<span class="p_chunk">@@ -1777,7 +1777,7 @@</span> <span class="p_context"> F:	include/media/as3645a.h</span>
 
 ASC7621 HARDWARE MONITOR DRIVER
 M:	George Joseph &lt;george.joseph@fairview5.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/asc7621
 F:	drivers/hwmon/asc7621.c
<span class="p_chunk">@@ -1864,7 +1864,7 @@</span> <span class="p_context"> F:	drivers/net/wireless/ath/carl9170/</span>
 
 ATK0110 HWMON DRIVER
 M:	Luca Tettamanti &lt;kronos.it@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/asus_atk0110.c
 
<span class="p_chunk">@@ -2984,7 +2984,7 @@</span> <span class="p_context"> F:	mm/swap_cgroup.c</span>
 
 CORETEMP HARDWARE MONITORING DRIVER
 M:	Fenghua Yu &lt;fenghua.yu@intel.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/coretemp
 F:	drivers/hwmon/coretemp.c
<span class="p_chunk">@@ -3549,7 +3549,7 @@</span> <span class="p_context"> T:	git git://git.infradead.org/users/vkoul/slave-dma.git</span>
 
 DME1737 HARDWARE MONITOR DRIVER
 M:	Juerg Haefliger &lt;juergh@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/dme1737
 F:	drivers/hwmon/dme1737.c
<span class="p_chunk">@@ -4262,7 +4262,7 @@</span> <span class="p_context"> F:	include/video/exynos_mipi*</span>
 
 F71805F HARDWARE MONITORING DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/f71805f
 F:	drivers/hwmon/f71805f.c
<span class="p_chunk">@@ -4341,7 +4341,7 @@</span> <span class="p_context"> F:	fs/*</span>
 
 FINTEK F75375S HARDWARE MONITOR AND FAN CONTROLLER DRIVER
 M:	Riku Voipio &lt;riku.voipio@iki.fi&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/f75375s.c
 F:	include/linux/f75375s.h
<span class="p_chunk">@@ -4883,8 +4883,8 @@</span> <span class="p_context"> F:	drivers/media/usb/hackrf/</span>
 HARDWARE MONITORING
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_del">-W:	http://www.lm-sensors.org/</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
<span class="p_add">+W:	http://hwmon.wiki.kernel.org/</span>
 T:	quilt http://jdelvare.nerim.net/devel/linux/jdelvare-hwmon/
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/groeck/linux-staging.git
 S:	Maintained
<span class="p_chunk">@@ -5393,7 +5393,7 @@</span> <span class="p_context"> F:	drivers/usb/atm/ueagle-atm.c</span>
 
 INA209 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/ina209
 F:	Documentation/devicetree/bindings/i2c/ina209.txt
<span class="p_chunk">@@ -5401,7 +5401,7 @@</span> <span class="p_context"> F:	drivers/hwmon/ina209.c</span>
 
 INA2XX HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/ina2xx
 F:	drivers/hwmon/ina2xx.c
<span class="p_chunk">@@ -5884,7 +5884,7 @@</span> <span class="p_context"> F:	drivers/isdn/hardware/eicon/</span>
 
 IT87 HARDWARE MONITORING DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/it87
 F:	drivers/hwmon/it87.c
<span class="p_chunk">@@ -5920,7 +5920,7 @@</span> <span class="p_context"> F:	drivers/media/dvb-frontends/ix2505v*</span>
 
 JC42.4 TEMPERATURE SENSOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/jc42.c
 F:	Documentation/hwmon/jc42
<span class="p_chunk">@@ -5970,14 +5970,14 @@</span> <span class="p_context"> F:	drivers/tty/serial/jsm/</span>
 
 K10TEMP HARDWARE MONITORING DRIVER
 M:	Clemens Ladisch &lt;clemens@ladisch.de&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/k10temp
 F:	drivers/hwmon/k10temp.c
 
 K8TEMP HARDWARE MONITORING DRIVER
 M:	Rudolf Marek &lt;r.marek@assembler.cz&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/k8temp
 F:	drivers/hwmon/k8temp.c
<span class="p_chunk">@@ -6485,27 +6485,27 @@</span> <span class="p_context"> F:	net/llc/</span>
 
 LM73 HARDWARE MONITOR DRIVER
 M:	Guillaume Ligneul &lt;guillaume.ligneul@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/lm73.c
 
 LM78 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/lm78
 F:	drivers/hwmon/lm78.c
 
 LM83 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/lm83
 F:	drivers/hwmon/lm83.c
 
 LM90 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/lm90
 F:	Documentation/devicetree/bindings/hwmon/lm90.txt
<span class="p_chunk">@@ -6513,7 +6513,7 @@</span> <span class="p_context"> F:	drivers/hwmon/lm90.c</span>
 
 LM95234 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/lm95234
 F:	drivers/hwmon/lm95234.c
<span class="p_chunk">@@ -6580,7 +6580,7 @@</span> <span class="p_context"> F:	drivers/scsi/sym53c8xx_2/</span>
 
 LTC4261 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/ltc4261
 F:	drivers/hwmon/ltc4261.c
<span class="p_chunk">@@ -6749,28 +6749,28 @@</span> <span class="p_context"> F:	include/uapi/linux/matroxfb.h</span>
 
 MAX16065 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/max16065
 F:	drivers/hwmon/max16065.c
 
 MAX20751 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/max20751
 F:	drivers/hwmon/max20751.c
 
 MAX6650 HARDWARE MONITOR AND FAN CONTROLLER DRIVER
 M:	&quot;Hans J. Koch&quot; &lt;hjk@hansjkoch.de&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/max6650
 F:	drivers/hwmon/max6650.c
 
 MAX6697 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/max6697
 F:	Documentation/devicetree/bindings/i2c/max6697.txt
<span class="p_chunk">@@ -7303,7 +7303,7 @@</span> <span class="p_context"> F:	drivers/scsi/NCR_D700.*</span>
 
 NCT6775 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/nct6775
 F:	drivers/hwmon/nct6775.c
<span class="p_chunk">@@ -8064,7 +8064,7 @@</span> <span class="p_context"> F:	drivers/video/logo/logo_parisc*</span>
 
 PC87360 HARDWARE MONITORING DRIVER
 M:	Jim Cromie &lt;jim.cromie@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/pc87360
 F:	drivers/hwmon/pc87360.c
<span class="p_chunk">@@ -8076,7 +8076,7 @@</span> <span class="p_context"> F:	drivers/char/pc8736x_gpio.c</span>
 
 PC87427 HARDWARE MONITORING DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/pc87427
 F:	drivers/hwmon/pc87427.c
<span class="p_chunk">@@ -8415,8 +8415,8 @@</span> <span class="p_context"> F:	drivers/rtc/rtc-puv3.c</span>
 
 PMBUS HARDWARE MONITORING DRIVERS
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_del">-W:	http://www.lm-sensors.org/</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
<span class="p_add">+W:	http://hwmon.wiki.kernel.org/</span>
 W:	http://www.roeck-us.net/linux/drivers/
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/groeck/linux-staging.git
 S:	Maintained
<span class="p_chunk">@@ -8610,7 +8610,7 @@</span> <span class="p_context"> F:	drivers/media/usb/pwc/*</span>
 
 PWM FAN DRIVER
 M:	Kamil Debski &lt;k.debski@samsung.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Supported
 F:	Documentation/devicetree/bindings/hwmon/pwm-fan.txt
 F:	Documentation/hwmon/pwm-fan
<span class="p_chunk">@@ -9882,28 +9882,28 @@</span> <span class="p_context"> F:	Documentation/devicetree/bindings/media/i2c/nokia,smia.txt</span>
 
 SMM665 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/smm665
 F:	drivers/hwmon/smm665.c
 
 SMSC EMC2103 HARDWARE MONITOR DRIVER
 M:	Steve Glendinning &lt;steve.glendinning@shawell.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/emc2103
 F:	drivers/hwmon/emc2103.c
 
 SMSC SCH5627 HARDWARE MONITOR DRIVER
 M:	Hans de Goede &lt;hdegoede@redhat.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Supported
 F:	Documentation/hwmon/sch5627
 F:	drivers/hwmon/sch5627.c
 
 SMSC47B397 HARDWARE MONITOR DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/smsc47b397
 F:	drivers/hwmon/smsc47b397.c
<span class="p_chunk">@@ -10830,7 +10830,7 @@</span> <span class="p_context"> F:	include/linux/mmc/sh_mobile_sdhi.h</span>
 
 TMP401 HARDWARE MONITOR DRIVER
 M:	Guenter Roeck &lt;linux@roeck-us.net&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/tmp401
 F:	drivers/hwmon/tmp401.c
<span class="p_chunk">@@ -11564,14 +11564,14 @@</span> <span class="p_context"> F:	Documentation/networking/vrf.txt</span>
 
 VT1211 HARDWARE MONITOR DRIVER
 M:	Juerg Haefliger &lt;juergh@gmail.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/vt1211
 F:	drivers/hwmon/vt1211.c
 
 VT8231 HARDWARE MONITOR DRIVER
 M:	Roger Lucas &lt;vt8231@hiddenengine.co.uk&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/vt8231.c
 
<span class="p_chunk">@@ -11590,21 +11590,21 @@</span> <span class="p_context"> F:	drivers/w1/</span>
 
 W83791D HARDWARE MONITORING DRIVER
 M:	Marc Hulsman &lt;m.hulsman@tudelft.nl&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/w83791d
 F:	drivers/hwmon/w83791d.c
 
 W83793 HARDWARE MONITORING DRIVER
 M:	Rudolf Marek &lt;r.marek@assembler.cz&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	Documentation/hwmon/w83793
 F:	drivers/hwmon/w83793.c
 
 W83795 HARDWARE MONITORING DRIVER
 M:	Jean Delvare &lt;jdelvare@suse.com&gt;
<span class="p_del">-L:	lm-sensors@lm-sensors.org</span>
<span class="p_add">+L:	linux-hwmon@vger.kernel.org</span>
 S:	Maintained
 F:	drivers/hwmon/w83795.c
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 87d12b44ab66..5a493e785aca 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/include/asm/bitops.h b/arch/arc/include/asm/bitops.h</span>
<span class="p_header">index 57c1f33844d4..0352fb8d21b9 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/bitops.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/bitops.h</span>
<span class="p_chunk">@@ -35,21 +35,6 @@</span> <span class="p_context"> static inline void op##_bit(unsigned long nr, volatile unsigned long *m)\</span>
 									\
 	m += nr &gt;&gt; 5;							\
 									\
<span class="p_del">-	/*								\</span>
<span class="p_del">-	 * ARC ISA micro-optimization:					\</span>
<span class="p_del">-	 *								\</span>
<span class="p_del">-	 * Instructions dealing with bitpos only consider lower 5 bits	\</span>
<span class="p_del">-	 * e.g (x &lt;&lt; 33) is handled like (x &lt;&lt; 1) by ASL instruction	\</span>
<span class="p_del">-	 *  (mem pointer still needs adjustment to point to next word)	\</span>
<span class="p_del">-	 *								\</span>
<span class="p_del">-	 * Hence the masking to clamp @nr arg can be elided in general.	\</span>
<span class="p_del">-	 *								\</span>
<span class="p_del">-	 * However if @nr is a constant (above assumed in a register),	\</span>
<span class="p_del">-	 * and greater than 31, gcc can optimize away (x &lt;&lt; 33) to 0,	\</span>
<span class="p_del">-	 * as overflow, given the 32-bit ISA. Thus masking needs to be	\</span>
<span class="p_del">-	 * done for const @nr, but no code is generated due to gcc	\</span>
<span class="p_del">-	 * const prop.							\</span>
<span class="p_del">-	 */								\</span>
 	nr &amp;= 0x1f;							\
 									\
 	__asm__ __volatile__(						\
<span class="p_header">diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h</span>
<span class="p_header">index 694ece8a0243..27b17adea50d 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/io.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/io.h</span>
<span class="p_chunk">@@ -129,15 +129,23 @@</span> <span class="p_context"> static inline void __raw_writel(u32 w, volatile void __iomem *addr)</span>
 #define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
 
 /*
<span class="p_del">- * Relaxed API for drivers which can handle any ordering themselves</span>
<span class="p_add">+ * Relaxed API for drivers which can handle barrier ordering themselves</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Also these are defined to perform little endian accesses.</span>
<span class="p_add">+ * To provide the typical device register semantics of fixed endian,</span>
<span class="p_add">+ * swap the byte order for Big Endian</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://lkml.kernel.org/r/201603100845.30602.arnd@arndb.de</span>
  */
 #define readb_relaxed(c)	__raw_readb(c)
<span class="p_del">-#define readw_relaxed(c)	__raw_readw(c)</span>
<span class="p_del">-#define readl_relaxed(c)	__raw_readl(c)</span>
<span class="p_add">+#define readw_relaxed(c) ({ u16 __r = le16_to_cpu((__force __le16) \</span>
<span class="p_add">+					__raw_readw(c)); __r; })</span>
<span class="p_add">+#define readl_relaxed(c) ({ u32 __r = le32_to_cpu((__force __le32) \</span>
<span class="p_add">+					__raw_readl(c)); __r; })</span>
 
 #define writeb_relaxed(v,c)	__raw_writeb(v,c)
<span class="p_del">-#define writew_relaxed(v,c)	__raw_writew(v,c)</span>
<span class="p_del">-#define writel_relaxed(v,c)	__raw_writel(v,c)</span>
<span class="p_add">+#define writew_relaxed(v,c)	__raw_writew((__force u16) cpu_to_le16(v),c)</span>
<span class="p_add">+#define writel_relaxed(v,c)	__raw_writel((__force u32) cpu_to_le32(v),c)</span>
 
 #include &lt;asm-generic/io.h&gt;
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d3_xplained.dts b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">index ff888d21c786..f3e2b96c06a3 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_chunk">@@ -303,6 +303,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;mmc0-card-supply&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		regulator-always-on;</span>
 	};
 
 	gpio_keys {
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4_xplained.dts b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">index 569026e8f96c..da84e65b56ef 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_chunk">@@ -268,5 +268,6 @@</span> <span class="p_context"></span>
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
 		vin-supply = &lt;&amp;vcc_3v3_reg&gt;;
<span class="p_add">+		regulator-always-on;</span>
 	};
 };
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/dev-audio.c b/arch/arm/mach-s3c64xx/dev-audio.c</span>
<span class="p_header">index ff780a8d8366..9a42736ef4ac 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/dev-audio.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/dev-audio.c</span>
<span class="p_chunk">@@ -54,12 +54,12 @@</span> <span class="p_context"> static int s3c64xx_i2s_cfg_gpio(struct platform_device *pdev)</span>
 
 static struct resource s3c64xx_iis0_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_IIS0, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_I2S0_OUT),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_I2S0_IN),</span>
 };
 
<span class="p_del">-static struct s3c_audio_pdata i2sv3_pdata = {</span>
<span class="p_add">+static struct s3c_audio_pdata i2s0_pdata = {</span>
 	.cfg_gpio = s3c64xx_i2s_cfg_gpio,
<span class="p_add">+	.dma_playback = DMACH_I2S0_OUT,</span>
<span class="p_add">+	.dma_capture = DMACH_I2S0_IN,</span>
 };
 
 struct platform_device s3c64xx_device_iis0 = {
<span class="p_chunk">@@ -68,15 +68,19 @@</span> <span class="p_context"> struct platform_device s3c64xx_device_iis0 = {</span>
 	.num_resources	  = ARRAY_SIZE(s3c64xx_iis0_resource),
 	.resource	  = s3c64xx_iis0_resource,
 	.dev = {
<span class="p_del">-		.platform_data = &amp;i2sv3_pdata,</span>
<span class="p_add">+		.platform_data = &amp;i2s0_pdata,</span>
 	},
 };
 EXPORT_SYMBOL(s3c64xx_device_iis0);
 
 static struct resource s3c64xx_iis1_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_IIS1, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_I2S1_OUT),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_I2S1_IN),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct s3c_audio_pdata i2s1_pdata = {</span>
<span class="p_add">+	.cfg_gpio = s3c64xx_i2s_cfg_gpio,</span>
<span class="p_add">+	.dma_playback = DMACH_I2S1_OUT,</span>
<span class="p_add">+	.dma_capture = DMACH_I2S1_IN,</span>
 };
 
 struct platform_device s3c64xx_device_iis1 = {
<span class="p_chunk">@@ -85,19 +89,19 @@</span> <span class="p_context"> struct platform_device s3c64xx_device_iis1 = {</span>
 	.num_resources	  = ARRAY_SIZE(s3c64xx_iis1_resource),
 	.resource	  = s3c64xx_iis1_resource,
 	.dev = {
<span class="p_del">-		.platform_data = &amp;i2sv3_pdata,</span>
<span class="p_add">+		.platform_data = &amp;i2s1_pdata,</span>
 	},
 };
 EXPORT_SYMBOL(s3c64xx_device_iis1);
 
 static struct resource s3c64xx_iisv4_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_IISV4, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_HSI_I2SV40_TX),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_HSI_I2SV40_RX),</span>
 };
 
 static struct s3c_audio_pdata i2sv4_pdata = {
 	.cfg_gpio = s3c64xx_i2s_cfg_gpio,
<span class="p_add">+	.dma_playback = DMACH_HSI_I2SV40_TX,</span>
<span class="p_add">+	.dma_capture = DMACH_HSI_I2SV40_RX,</span>
 	.type = {
 		.i2s = {
 			.quirks = QUIRK_PRI_6CHAN,
<span class="p_chunk">@@ -142,12 +146,12 @@</span> <span class="p_context"> static int s3c64xx_pcm_cfg_gpio(struct platform_device *pdev)</span>
 
 static struct resource s3c64xx_pcm0_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_PCM0, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_PCM0_TX),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_PCM0_RX),</span>
 };
 
 static struct s3c_audio_pdata s3c_pcm0_pdata = {
 	.cfg_gpio = s3c64xx_pcm_cfg_gpio,
<span class="p_add">+	.dma_capture = DMACH_PCM0_RX,</span>
<span class="p_add">+	.dma_playback = DMACH_PCM0_TX,</span>
 };
 
 struct platform_device s3c64xx_device_pcm0 = {
<span class="p_chunk">@@ -163,12 +167,12 @@</span> <span class="p_context"> EXPORT_SYMBOL(s3c64xx_device_pcm0);</span>
 
 static struct resource s3c64xx_pcm1_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_PCM1, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_PCM1_TX),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_PCM1_RX),</span>
 };
 
 static struct s3c_audio_pdata s3c_pcm1_pdata = {
 	.cfg_gpio = s3c64xx_pcm_cfg_gpio,
<span class="p_add">+	.dma_playback = DMACH_PCM1_TX,</span>
<span class="p_add">+	.dma_capture = DMACH_PCM1_RX,</span>
 };
 
 struct platform_device s3c64xx_device_pcm1 = {
<span class="p_chunk">@@ -196,13 +200,14 @@</span> <span class="p_context"> static int s3c64xx_ac97_cfg_gpe(struct platform_device *pdev)</span>
 
 static struct resource s3c64xx_ac97_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C64XX_PA_AC97, SZ_256),
<span class="p_del">-	[1] = DEFINE_RES_DMA(DMACH_AC97_PCMOUT),</span>
<span class="p_del">-	[2] = DEFINE_RES_DMA(DMACH_AC97_PCMIN),</span>
<span class="p_del">-	[3] = DEFINE_RES_DMA(DMACH_AC97_MICIN),</span>
<span class="p_del">-	[4] = DEFINE_RES_IRQ(IRQ_AC97),</span>
<span class="p_add">+	[1] = DEFINE_RES_IRQ(IRQ_AC97),</span>
 };
 
<span class="p_del">-static struct s3c_audio_pdata s3c_ac97_pdata;</span>
<span class="p_add">+static struct s3c_audio_pdata s3c_ac97_pdata = {</span>
<span class="p_add">+	.dma_playback = DMACH_AC97_PCMOUT,</span>
<span class="p_add">+	.dma_capture = DMACH_AC97_PCMIN,</span>
<span class="p_add">+	.dma_capture_mic = DMACH_AC97_MICIN,</span>
<span class="p_add">+};</span>
 
 static u64 s3c64xx_ac97_dmamask = DMA_BIT_MASK(32);
 
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/include/mach/dma.h b/arch/arm/mach-s3c64xx/include/mach/dma.h</span>
<span class="p_header">index 096e14073bd9..9c739eafe95c 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/include/mach/dma.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/include/mach/dma.h</span>
<span class="p_chunk">@@ -14,38 +14,38 @@</span> <span class="p_context"></span>
 #define S3C64XX_DMA_CHAN(name)		((unsigned long)(name))
 
 /* DMA0/SDMA0 */
<span class="p_del">-#define DMACH_UART0		S3C64XX_DMA_CHAN(&quot;uart0_tx&quot;)</span>
<span class="p_del">-#define DMACH_UART0_SRC2	S3C64XX_DMA_CHAN(&quot;uart0_rx&quot;)</span>
<span class="p_del">-#define DMACH_UART1		S3C64XX_DMA_CHAN(&quot;uart1_tx&quot;)</span>
<span class="p_del">-#define DMACH_UART1_SRC2	S3C64XX_DMA_CHAN(&quot;uart1_rx&quot;)</span>
<span class="p_del">-#define DMACH_UART2		S3C64XX_DMA_CHAN(&quot;uart2_tx&quot;)</span>
<span class="p_del">-#define DMACH_UART2_SRC2	S3C64XX_DMA_CHAN(&quot;uart2_rx&quot;)</span>
<span class="p_del">-#define DMACH_UART3		S3C64XX_DMA_CHAN(&quot;uart3_tx&quot;)</span>
<span class="p_del">-#define DMACH_UART3_SRC2	S3C64XX_DMA_CHAN(&quot;uart3_rx&quot;)</span>
<span class="p_del">-#define DMACH_PCM0_TX		S3C64XX_DMA_CHAN(&quot;pcm0_tx&quot;)</span>
<span class="p_del">-#define DMACH_PCM0_RX		S3C64XX_DMA_CHAN(&quot;pcm0_rx&quot;)</span>
<span class="p_del">-#define DMACH_I2S0_OUT		S3C64XX_DMA_CHAN(&quot;i2s0_tx&quot;)</span>
<span class="p_del">-#define DMACH_I2S0_IN		S3C64XX_DMA_CHAN(&quot;i2s0_rx&quot;)</span>
<span class="p_add">+#define DMACH_UART0		&quot;uart0_tx&quot;</span>
<span class="p_add">+#define DMACH_UART0_SRC2	&quot;uart0_rx&quot;</span>
<span class="p_add">+#define DMACH_UART1		&quot;uart1_tx&quot;</span>
<span class="p_add">+#define DMACH_UART1_SRC2	&quot;uart1_rx&quot;</span>
<span class="p_add">+#define DMACH_UART2		&quot;uart2_tx&quot;</span>
<span class="p_add">+#define DMACH_UART2_SRC2	&quot;uart2_rx&quot;</span>
<span class="p_add">+#define DMACH_UART3		&quot;uart3_tx&quot;</span>
<span class="p_add">+#define DMACH_UART3_SRC2	&quot;uart3_rx&quot;</span>
<span class="p_add">+#define DMACH_PCM0_TX		&quot;pcm0_tx&quot;</span>
<span class="p_add">+#define DMACH_PCM0_RX		&quot;pcm0_rx&quot;</span>
<span class="p_add">+#define DMACH_I2S0_OUT		&quot;i2s0_tx&quot;</span>
<span class="p_add">+#define DMACH_I2S0_IN		&quot;i2s0_rx&quot;</span>
 #define DMACH_SPI0_TX		S3C64XX_DMA_CHAN(&quot;spi0_tx&quot;)
 #define DMACH_SPI0_RX		S3C64XX_DMA_CHAN(&quot;spi0_rx&quot;)
<span class="p_del">-#define DMACH_HSI_I2SV40_TX	S3C64XX_DMA_CHAN(&quot;i2s2_tx&quot;)</span>
<span class="p_del">-#define DMACH_HSI_I2SV40_RX	S3C64XX_DMA_CHAN(&quot;i2s2_rx&quot;)</span>
<span class="p_add">+#define DMACH_HSI_I2SV40_TX	&quot;i2s2_tx&quot;</span>
<span class="p_add">+#define DMACH_HSI_I2SV40_RX	&quot;i2s2_rx&quot;</span>
 
 /* DMA1/SDMA1 */
<span class="p_del">-#define DMACH_PCM1_TX		S3C64XX_DMA_CHAN(&quot;pcm1_tx&quot;)</span>
<span class="p_del">-#define DMACH_PCM1_RX		S3C64XX_DMA_CHAN(&quot;pcm1_rx&quot;)</span>
<span class="p_del">-#define DMACH_I2S1_OUT		S3C64XX_DMA_CHAN(&quot;i2s1_tx&quot;)</span>
<span class="p_del">-#define DMACH_I2S1_IN		S3C64XX_DMA_CHAN(&quot;i2s1_rx&quot;)</span>
<span class="p_add">+#define DMACH_PCM1_TX		&quot;pcm1_tx&quot;</span>
<span class="p_add">+#define DMACH_PCM1_RX		&quot;pcm1_rx&quot;</span>
<span class="p_add">+#define DMACH_I2S1_OUT		&quot;i2s1_tx&quot;</span>
<span class="p_add">+#define DMACH_I2S1_IN		&quot;i2s1_rx&quot;</span>
 #define DMACH_SPI1_TX		S3C64XX_DMA_CHAN(&quot;spi1_tx&quot;)
 #define DMACH_SPI1_RX		S3C64XX_DMA_CHAN(&quot;spi1_rx&quot;)
<span class="p_del">-#define DMACH_AC97_PCMOUT	S3C64XX_DMA_CHAN(&quot;ac97_out&quot;)</span>
<span class="p_del">-#define DMACH_AC97_PCMIN	S3C64XX_DMA_CHAN(&quot;ac97_in&quot;)</span>
<span class="p_del">-#define DMACH_AC97_MICIN	S3C64XX_DMA_CHAN(&quot;ac97_mic&quot;)</span>
<span class="p_del">-#define DMACH_PWM		S3C64XX_DMA_CHAN(&quot;pwm&quot;)</span>
<span class="p_del">-#define DMACH_IRDA		S3C64XX_DMA_CHAN(&quot;irda&quot;)</span>
<span class="p_del">-#define DMACH_EXTERNAL		S3C64XX_DMA_CHAN(&quot;external&quot;)</span>
<span class="p_del">-#define DMACH_SECURITY_RX	S3C64XX_DMA_CHAN(&quot;sec_rx&quot;)</span>
<span class="p_del">-#define DMACH_SECURITY_TX	S3C64XX_DMA_CHAN(&quot;sec_tx&quot;)</span>
<span class="p_add">+#define DMACH_AC97_PCMOUT	&quot;ac97_out&quot;</span>
<span class="p_add">+#define DMACH_AC97_PCMIN	&quot;ac97_in&quot;</span>
<span class="p_add">+#define DMACH_AC97_MICIN	&quot;ac97_mic&quot;</span>
<span class="p_add">+#define DMACH_PWM		&quot;pwm&quot;</span>
<span class="p_add">+#define DMACH_IRDA		&quot;irda&quot;</span>
<span class="p_add">+#define DMACH_EXTERNAL		&quot;external&quot;</span>
<span class="p_add">+#define DMACH_SECURITY_RX	&quot;sec_rx&quot;</span>
<span class="p_add">+#define DMACH_SECURITY_TX	&quot;sec_tx&quot;</span>
 
 enum dma_ch {
 	DMACH_MAX = 32
<span class="p_header">diff --git a/arch/arm/plat-samsung/devs.c b/arch/arm/plat-samsung/devs.c</span>
<span class="p_header">index 82074625de5c..e212f9d804bd 100644</span>
<span class="p_header">--- a/arch/arm/plat-samsung/devs.c</span>
<span class="p_header">+++ b/arch/arm/plat-samsung/devs.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_data/usb-ohci-s3c2410.h&gt;
 #include &lt;plat/usb-phy.h&gt;
 #include &lt;plat/regs-spi.h&gt;
<span class="p_add">+#include &lt;linux/platform_data/asoc-s3c.h&gt;</span>
 #include &lt;linux/platform_data/spi-s3c64xx.h&gt;
 
 static u64 samsung_device_dma_mask = DMA_BIT_MASK(32);
<span class="p_chunk">@@ -74,9 +75,12 @@</span> <span class="p_context"> static u64 samsung_device_dma_mask = DMA_BIT_MASK(32);</span>
 static struct resource s3c_ac97_resource[] = {
 	[0] = DEFINE_RES_MEM(S3C2440_PA_AC97, S3C2440_SZ_AC97),
 	[1] = DEFINE_RES_IRQ(IRQ_S3C244X_AC97),
<span class="p_del">-	[2] = DEFINE_RES_DMA_NAMED(DMACH_PCM_OUT, &quot;PCM out&quot;),</span>
<span class="p_del">-	[3] = DEFINE_RES_DMA_NAMED(DMACH_PCM_IN, &quot;PCM in&quot;),</span>
<span class="p_del">-	[4] = DEFINE_RES_DMA_NAMED(DMACH_MIC_IN, &quot;Mic in&quot;),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct s3c_audio_pdata s3c_ac97_pdata = {</span>
<span class="p_add">+	.dma_playback = (void *)DMACH_PCM_OUT,</span>
<span class="p_add">+	.dma_capture = (void *)DMACH_PCM_IN,</span>
<span class="p_add">+	.dma_capture_mic = (void *)DMACH_MIC_IN,</span>
 };
 
 struct platform_device s3c_device_ac97 = {
<span class="p_chunk">@@ -87,6 +91,7 @@</span> <span class="p_context"> struct platform_device s3c_device_ac97 = {</span>
 	.dev		= {
 		.dma_mask		= &amp;samsung_device_dma_mask,
 		.coherent_dma_mask	= DMA_BIT_MASK(32),
<span class="p_add">+		.platform_data		= &amp;s3c_ac97_pdata,</span>
 	}
 };
 #endif /* CONFIG_CPU_S3C2440 */
<span class="p_header">diff --git a/arch/ia64/include/asm/io.h b/arch/ia64/include/asm/io.h</span>
<span class="p_header">index 9041bbe2b7b4..8fdb9c7eeb66 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/io.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/io.h</span>
<span class="p_chunk">@@ -436,6 +436,7 @@</span> <span class="p_context"> static inline void __iomem * ioremap_cache (unsigned long phys_addr, unsigned lo</span>
 	return ioremap(phys_addr, size);
 }
 #define ioremap_cache ioremap_cache
<span class="p_add">+#define ioremap_uc ioremap_nocache</span>
 
 
 /*
<span class="p_header">diff --git a/arch/s390/include/asm/pci.h b/arch/s390/include/asm/pci.h</span>
<span class="p_header">index c873e682b67f..2b2ced9dc00a 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pci.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pci.h</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> struct zpci_fmb {</span>
 	u64 rpcit_ops;
 	u64 dma_rbytes;
 	u64 dma_wbytes;
<span class="p_del">-} __packed __aligned(16);</span>
<span class="p_add">+} __packed __aligned(64);</span>
 
 enum zpci_state {
 	ZPCI_FN_STATE_RESERVED,
<span class="p_header">diff --git a/arch/s390/kernel/entry.S b/arch/s390/kernel/entry.S</span>
<span class="p_header">index 857b6526d298..424e6809ad07 100644</span>
<span class="p_header">--- a/arch/s390/kernel/entry.S</span>
<span class="p_header">+++ b/arch/s390/kernel/entry.S</span>
<span class="p_chunk">@@ -1197,114 +1197,12 @@</span> <span class="p_context"> cleanup_critical:</span>
 	.quad	.Lpsw_idle_lpsw
 
 .Lcleanup_save_fpu_regs:
<span class="p_del">-	TSTMSK	__LC_CPU_FLAGS,_CIF_FPU</span>
<span class="p_del">-	bor	%r14</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_save_fpu_regs_done)</span>
<span class="p_del">-	jhe	5f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_save_fpu_regs_fp)</span>
<span class="p_del">-	jhe	4f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_save_fpu_regs_vx_high)</span>
<span class="p_del">-	jhe	3f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_save_fpu_regs_vx_low)</span>
<span class="p_del">-	jhe	2f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_save_fpu_fpc_end)</span>
<span class="p_del">-	jhe	1f</span>
<span class="p_del">-	lg	%r2,__LC_CURRENT</span>
<span class="p_del">-	aghi	%r2,__TASK_thread</span>
<span class="p_del">-0:	# Store floating-point controls</span>
<span class="p_del">-	stfpc	__THREAD_FPU_fpc(%r2)</span>
<span class="p_del">-1:	# Load register save area and check if VX is active</span>
<span class="p_del">-	lg	%r3,__THREAD_FPU_regs(%r2)</span>
<span class="p_del">-	TSTMSK	__LC_MACHINE_FLAGS,MACHINE_FLAG_VX</span>
<span class="p_del">-	jz	4f			  # no VX -&gt; store FP regs</span>
<span class="p_del">-2:	# Store vector registers (V0-V15)</span>
<span class="p_del">-	VSTM	%v0,%v15,0,%r3		  # vstm 0,15,0(3)</span>
<span class="p_del">-3:	# Store vector registers (V16-V31)</span>
<span class="p_del">-	VSTM	%v16,%v31,256,%r3	  # vstm 16,31,256(3)</span>
<span class="p_del">-	j	5f			  # -&gt; done, set CIF_FPU flag</span>
<span class="p_del">-4:	# Store floating-point registers</span>
<span class="p_del">-	std	0,0(%r3)</span>
<span class="p_del">-	std	1,8(%r3)</span>
<span class="p_del">-	std	2,16(%r3)</span>
<span class="p_del">-	std	3,24(%r3)</span>
<span class="p_del">-	std	4,32(%r3)</span>
<span class="p_del">-	std	5,40(%r3)</span>
<span class="p_del">-	std	6,48(%r3)</span>
<span class="p_del">-	std	7,56(%r3)</span>
<span class="p_del">-	std	8,64(%r3)</span>
<span class="p_del">-	std	9,72(%r3)</span>
<span class="p_del">-	std	10,80(%r3)</span>
<span class="p_del">-	std	11,88(%r3)</span>
<span class="p_del">-	std	12,96(%r3)</span>
<span class="p_del">-	std	13,104(%r3)</span>
<span class="p_del">-	std	14,112(%r3)</span>
<span class="p_del">-	std	15,120(%r3)</span>
<span class="p_del">-5:	# Set CIF_FPU flag</span>
<span class="p_del">-	oi	__LC_CPU_FLAGS+7,_CIF_FPU</span>
<span class="p_del">-	lg	%r9,48(%r11)		# return from save_fpu_regs</span>
<span class="p_add">+	larl	%r9,save_fpu_regs</span>
 	br	%r14
<span class="p_del">-.Lcleanup_save_fpu_fpc_end:</span>
<span class="p_del">-	.quad	.Lsave_fpu_regs_fpc_end</span>
<span class="p_del">-.Lcleanup_save_fpu_regs_vx_low:</span>
<span class="p_del">-	.quad	.Lsave_fpu_regs_vx_low</span>
<span class="p_del">-.Lcleanup_save_fpu_regs_vx_high:</span>
<span class="p_del">-	.quad	.Lsave_fpu_regs_vx_high</span>
<span class="p_del">-.Lcleanup_save_fpu_regs_fp:</span>
<span class="p_del">-	.quad	.Lsave_fpu_regs_fp</span>
<span class="p_del">-.Lcleanup_save_fpu_regs_done:</span>
<span class="p_del">-	.quad	.Lsave_fpu_regs_done</span>
 
 .Lcleanup_load_fpu_regs:
<span class="p_del">-	TSTMSK	__LC_CPU_FLAGS,_CIF_FPU</span>
<span class="p_del">-	bnor	%r14</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_load_fpu_regs_done)</span>
<span class="p_del">-	jhe	1f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_load_fpu_regs_fp)</span>
<span class="p_del">-	jhe	2f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_load_fpu_regs_vx_high)</span>
<span class="p_del">-	jhe	3f</span>
<span class="p_del">-	clg	%r9,BASED(.Lcleanup_load_fpu_regs_vx)</span>
<span class="p_del">-	jhe	4f</span>
<span class="p_del">-	lg	%r4,__LC_CURRENT</span>
<span class="p_del">-	aghi	%r4,__TASK_thread</span>
<span class="p_del">-	lfpc	__THREAD_FPU_fpc(%r4)</span>
<span class="p_del">-	TSTMSK	__LC_MACHINE_FLAGS,MACHINE_FLAG_VX</span>
<span class="p_del">-	lg	%r4,__THREAD_FPU_regs(%r4)	# %r4 &lt;- reg save area</span>
<span class="p_del">-	jz	2f				# -&gt; no VX, load FP regs</span>
<span class="p_del">-4:	# Load V0 ..V15 registers</span>
<span class="p_del">-	VLM	%v0,%v15,0,%r4</span>
<span class="p_del">-3:	# Load V16..V31 registers</span>
<span class="p_del">-	VLM	%v16,%v31,256,%r4</span>
<span class="p_del">-	j	1f</span>
<span class="p_del">-2:	# Load floating-point registers</span>
<span class="p_del">-	ld	0,0(%r4)</span>
<span class="p_del">-	ld	1,8(%r4)</span>
<span class="p_del">-	ld	2,16(%r4)</span>
<span class="p_del">-	ld	3,24(%r4)</span>
<span class="p_del">-	ld	4,32(%r4)</span>
<span class="p_del">-	ld	5,40(%r4)</span>
<span class="p_del">-	ld	6,48(%r4)</span>
<span class="p_del">-	ld	7,56(%r4)</span>
<span class="p_del">-	ld	8,64(%r4)</span>
<span class="p_del">-	ld	9,72(%r4)</span>
<span class="p_del">-	ld	10,80(%r4)</span>
<span class="p_del">-	ld	11,88(%r4)</span>
<span class="p_del">-	ld	12,96(%r4)</span>
<span class="p_del">-	ld	13,104(%r4)</span>
<span class="p_del">-	ld	14,112(%r4)</span>
<span class="p_del">-	ld	15,120(%r4)</span>
<span class="p_del">-1:	# Clear CIF_FPU bit</span>
<span class="p_del">-	ni	__LC_CPU_FLAGS+7,255-_CIF_FPU</span>
<span class="p_del">-	lg	%r9,48(%r11)		# return from load_fpu_regs</span>
<span class="p_add">+	larl	%r9,load_fpu_regs</span>
 	br	%r14
<span class="p_del">-.Lcleanup_load_fpu_regs_vx:</span>
<span class="p_del">-	.quad	.Lload_fpu_regs_vx</span>
<span class="p_del">-.Lcleanup_load_fpu_regs_vx_high:</span>
<span class="p_del">-	.quad	.Lload_fpu_regs_vx_high</span>
<span class="p_del">-.Lcleanup_load_fpu_regs_fp:</span>
<span class="p_del">-	.quad	.Lload_fpu_regs_fp</span>
<span class="p_del">-.Lcleanup_load_fpu_regs_done:</span>
<span class="p_del">-	.quad	.Lload_fpu_regs_done</span>
 
 /*
  * Integer constants
<span class="p_header">diff --git a/arch/s390/kernel/head64.S b/arch/s390/kernel/head64.S</span>
<span class="p_header">index 58b719fa8067..1ad2407c7f75 100644</span>
<span class="p_header">--- a/arch/s390/kernel/head64.S</span>
<span class="p_header">+++ b/arch/s390/kernel/head64.S</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 
 __HEAD
 ENTRY(startup_continue)
<span class="p_del">-	tm	__LC_STFL_FAC_LIST+6,0x80	# LPP available ?</span>
<span class="p_add">+	tm	__LC_STFL_FAC_LIST+5,0x80	# LPP available ?</span>
 	jz	0f
 	xc	__LC_LPP+1(7,0),__LC_LPP+1	# clear lpp and current_pid
 	mvi	__LC_LPP,0x80			#   and set LPP_MAGIC
<span class="p_header">diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c</span>
<span class="p_header">index c837bcacf218..1f581eb61bc2 100644</span>
<span class="p_header">--- a/arch/s390/kernel/setup.c</span>
<span class="p_header">+++ b/arch/s390/kernel/setup.c</span>
<span class="p_chunk">@@ -329,6 +329,7 @@</span> <span class="p_context"> static void __init setup_lowcore(void)</span>
 		+ PAGE_SIZE - STACK_FRAME_OVERHEAD - sizeof(struct pt_regs);
 	lc-&gt;current_task = (unsigned long) init_thread_union.thread_info.task;
 	lc-&gt;thread_info = (unsigned long) &amp;init_thread_union;
<span class="p_add">+	lc-&gt;lpp = LPP_MAGIC;</span>
 	lc-&gt;machine_flags = S390_lowcore.machine_flags;
 	lc-&gt;stfl_fac_list = S390_lowcore.stfl_fac_list;
 	memcpy(lc-&gt;stfle_fac_list, S390_lowcore.stfle_fac_list,
<span class="p_header">diff --git a/arch/s390/pci/pci.c b/arch/s390/pci/pci.c</span>
<span class="p_header">index 7ef12a3ace3a..19442395f413 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci.c</span>
<span class="p_chunk">@@ -871,8 +871,11 @@</span> <span class="p_context"> static inline int barsize(u8 size)</span>
 
 static int zpci_mem_init(void)
 {
<span class="p_add">+	BUILD_BUG_ON(!is_power_of_2(__alignof__(struct zpci_fmb)) ||</span>
<span class="p_add">+		     __alignof__(struct zpci_fmb) &lt; sizeof(struct zpci_fmb));</span>
<span class="p_add">+</span>
 	zdev_fmb_cache = kmem_cache_create(&quot;PCI_FMB_cache&quot;, sizeof(struct zpci_fmb),
<span class="p_del">-				16, 0, NULL);</span>
<span class="p_add">+					   __alignof__(struct zpci_fmb), 0, NULL);</span>
 	if (!zdev_fmb_cache)
 		goto error_zdev;
 
<span class="p_header">diff --git a/arch/sh/mm/kmap.c b/arch/sh/mm/kmap.c</span>
<span class="p_header">index ec29e14ec5a8..bf25d7c79a2d 100644</span>
<span class="p_header">--- a/arch/sh/mm/kmap.c</span>
<span class="p_header">+++ b/arch/sh/mm/kmap.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"> void *kmap_coherent(struct page *page, unsigned long addr)</span>
 
 	BUG_ON(!test_bit(PG_dcache_clean, &amp;page-&gt;flags));
 
<span class="p_add">+	preempt_disable();</span>
 	pagefault_disable();
 
 	idx = FIX_CMAP_END -
<span class="p_chunk">@@ -64,4 +65,5 @@</span> <span class="p_context"> void kunmap_coherent(void *kvaddr)</span>
 	}
 
 	pagefault_enable();
<span class="p_add">+	preempt_enable();</span>
 }
<span class="p_header">diff --git a/arch/um/drivers/mconsole_kern.c b/arch/um/drivers/mconsole_kern.c</span>
<span class="p_header">index 29880c9b324e..e22e57298522 100644</span>
<span class="p_header">--- a/arch/um/drivers/mconsole_kern.c</span>
<span class="p_header">+++ b/arch/um/drivers/mconsole_kern.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> void mconsole_proc(struct mc_request *req)</span>
 	ptr += strlen(&quot;proc&quot;);
 	ptr = skip_spaces(ptr);
 
<span class="p_del">-	file = file_open_root(mnt-&gt;mnt_root, mnt, ptr, O_RDONLY);</span>
<span class="p_add">+	file = file_open_root(mnt-&gt;mnt_root, mnt, ptr, O_RDONLY, 0);</span>
 	if (IS_ERR(file)) {
 		mconsole_reply(req, &quot;Failed to open file&quot;, 1, 0);
 		printk(KERN_ERR &quot;open /proc/%s: %ld\n&quot;, ptr, PTR_ERR(file));
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index db3622f22b61..436639a31624 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -1126,22 +1126,23 @@</span> <span class="p_context"> config MICROCODE</span>
 	bool &quot;CPU microcode loading support&quot;
 	default y
 	depends on CPU_SUP_AMD || CPU_SUP_INTEL
<span class="p_del">-	depends on BLK_DEV_INITRD</span>
 	select FW_LOADER
 	---help---
<span class="p_del">-</span>
 	  If you say Y here, you will be able to update the microcode on
<span class="p_del">-	  certain Intel and AMD processors. The Intel support is for the</span>
<span class="p_del">-	  IA32 family, e.g. Pentium Pro, Pentium II, Pentium III, Pentium 4,</span>
<span class="p_del">-	  Xeon etc. The AMD support is for families 0x10 and later. You will</span>
<span class="p_del">-	  obviously need the actual microcode binary data itself which is not</span>
<span class="p_del">-	  shipped with the Linux kernel.</span>
<span class="p_del">-</span>
<span class="p_del">-	  This option selects the general module only, you need to select</span>
<span class="p_del">-	  at least one vendor specific module as well.</span>
<span class="p_del">-</span>
<span class="p_del">-	  To compile this driver as a module, choose M here: the module</span>
<span class="p_del">-	  will be called microcode.</span>
<span class="p_add">+	  Intel and AMD processors. The Intel support is for the IA32 family,</span>
<span class="p_add">+	  e.g. Pentium Pro, Pentium II, Pentium III, Pentium 4, Xeon etc. The</span>
<span class="p_add">+	  AMD support is for families 0x10 and later. You will obviously need</span>
<span class="p_add">+	  the actual microcode binary data itself which is not shipped with</span>
<span class="p_add">+	  the Linux kernel.</span>
<span class="p_add">+</span>
<span class="p_add">+	  The preferred method to load microcode from a detached initrd is described</span>
<span class="p_add">+	  in Documentation/x86/early-microcode.txt. For that you need to enable</span>
<span class="p_add">+	  CONFIG_BLK_DEV_INITRD in order for the loader to be able to scan the</span>
<span class="p_add">+	  initrd for microcode blobs.</span>
<span class="p_add">+</span>
<span class="p_add">+	  In addition, you can build-in the microcode into the kernel. For that you</span>
<span class="p_add">+	  need to enable FIRMWARE_IN_KERNEL and add the vendor-supplied microcode</span>
<span class="p_add">+	  to the CONFIG_EXTRA_FIRMWARE config option.</span>
 
 config MICROCODE_INTEL
 	bool &quot;Intel microcode loading support&quot;
<span class="p_header">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span>
<span class="p_header">index 03663740c866..1a4477cedc49 100644</span>
<span class="p_header">--- a/arch/x86/entry/common.c</span>
<span class="p_header">+++ b/arch/x86/entry/common.c</span>
<span class="p_chunk">@@ -268,6 +268,7 @@</span> <span class="p_context"> static void exit_to_usermode_loop(struct pt_regs *regs, u32 cached_flags)</span>
 /* Called with IRQs disabled. */
 __visible inline void prepare_exit_to_usermode(struct pt_regs *regs)
 {
<span class="p_add">+	struct thread_info *ti = pt_regs_to_thread_info(regs);</span>
 	u32 cached_flags;
 
 	if (IS_ENABLED(CONFIG_PROVE_LOCKING) &amp;&amp; WARN_ON(!irqs_disabled()))
<span class="p_chunk">@@ -275,12 +276,22 @@</span> <span class="p_context"> __visible inline void prepare_exit_to_usermode(struct pt_regs *regs)</span>
 
 	lockdep_sys_exit();
 
<span class="p_del">-	cached_flags =</span>
<span class="p_del">-		READ_ONCE(pt_regs_to_thread_info(regs)-&gt;flags);</span>
<span class="p_add">+	cached_flags = READ_ONCE(ti-&gt;flags);</span>
 
 	if (unlikely(cached_flags &amp; EXIT_TO_USERMODE_LOOP_FLAGS))
 		exit_to_usermode_loop(regs, cached_flags);
 
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Compat syscalls set TS_COMPAT.  Make sure we clear it before</span>
<span class="p_add">+	 * returning to user mode.  We need to clear it *after* signal</span>
<span class="p_add">+	 * handling, because syscall restart has a fixup for compat</span>
<span class="p_add">+	 * syscalls.  The fixup is exercised by the ptrace_syscall_32</span>
<span class="p_add">+	 * selftest.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ti-&gt;status &amp;= ~TS_COMPAT;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	user_enter();
 }
 
<span class="p_chunk">@@ -332,14 +343,6 @@</span> <span class="p_context"> __visible inline void syscall_return_slowpath(struct pt_regs *regs)</span>
 	if (unlikely(cached_flags &amp; SYSCALL_EXIT_WORK_FLAGS))
 		syscall_slow_exit_work(regs, cached_flags);
 
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Compat syscalls set TS_COMPAT.  Make sure we clear it before</span>
<span class="p_del">-	 * returning to user mode.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ti-&gt;status &amp;= ~TS_COMPAT;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	local_irq_disable();
 	prepare_exit_to_usermode(regs);
 }
<span class="p_header">diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h</span>
<span class="p_header">index a30316bf801a..163769d82475 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/apic.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/apic.h</span>
<span class="p_chunk">@@ -638,8 +638,8 @@</span> <span class="p_context"> static inline void entering_irq(void)</span>
 
 static inline void entering_ack_irq(void)
 {
<span class="p_del">-	ack_APIC_irq();</span>
 	entering_irq();
<span class="p_add">+	ack_APIC_irq();</span>
 }
 
 static inline void ipi_entering_ack_irq(void)
<span class="p_header">diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h</span>
<span class="p_header">index 1e3408e88604..59caa55fb9b5 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hw_irq.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hw_irq.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> struct irq_alloc_info {</span>
 struct irq_cfg {
 	unsigned int		dest_apicid;
 	u8			vector;
<span class="p_add">+	u8			old_vector;</span>
 };
 
 extern struct irq_cfg *irq_cfg(unsigned int irq);
<span class="p_header">diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h</span>
<span class="p_header">index 34e62b1dcfce..712b24ed3a64 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode.h</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"></span>
 #define _ASM_X86_MICROCODE_H
 
 #include &lt;linux/earlycpio.h&gt;
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
 
 #define native_rdmsr(msr, val1, val2)			\
 do {							\
<span class="p_chunk">@@ -168,4 +169,29 @@</span> <span class="p_context"> static inline void reload_early_microcode(void)			{ }</span>
 static inline bool
 get_builtin_firmware(struct cpio_data *cd, const char *name)	{ return false; }
 #endif
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_initrd_start(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	return initrd_start;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_initrd_start_addr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long *initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return get_initrd_start();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#else /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_MICROCODE_H */
<span class="p_header">diff --git a/arch/x86/include/asm/perf_event.h b/arch/x86/include/asm/perf_event.h</span>
<span class="p_header">index 7bcb861a04e5..5a2ed3ed2f26 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/perf_event.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/perf_event.h</span>
<span class="p_chunk">@@ -165,6 +165,7 @@</span> <span class="p_context"> struct x86_pmu_capability {</span>
 #define GLOBAL_STATUS_ASIF				BIT_ULL(60)
 #define GLOBAL_STATUS_COUNTERS_FROZEN			BIT_ULL(59)
 #define GLOBAL_STATUS_LBRS_FROZEN			BIT_ULL(58)
<span class="p_add">+#define GLOBAL_STATUS_TRACE_TOPAPMI			BIT_ULL(55)</span>
 
 /*
  * IBS cpuid feature detection
<span class="p_header">diff --git a/arch/x86/include/asm/xen/hypervisor.h b/arch/x86/include/asm/xen/hypervisor.h</span>
<span class="p_header">index 8b2d4bea9962..39171b3646bb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/xen/hypervisor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/xen/hypervisor.h</span>
<span class="p_chunk">@@ -62,4 +62,6 @@</span> <span class="p_context"> void xen_arch_register_cpu(int num);</span>
 void xen_arch_unregister_cpu(int num);
 #endif
 
<span class="p_add">+extern void xen_set_iopl_mask(unsigned mask);</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_XEN_HYPERVISOR_H */
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index a35f6b5473f4..7af2505f20c2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -211,6 +211,7 @@</span> <span class="p_context"> update:</span>
 	 */
 	cpumask_and(d-&gt;old_domain, d-&gt;old_domain, cpu_online_mask);
 	d-&gt;move_in_progress = !cpumask_empty(d-&gt;old_domain);
<span class="p_add">+	d-&gt;cfg.old_vector = d-&gt;move_in_progress ? d-&gt;cfg.vector : 0;</span>
 	d-&gt;cfg.vector = vector;
 	cpumask_copy(d-&gt;domain, vector_cpumask);
 success:
<span class="p_chunk">@@ -653,46 +654,97 @@</span> <span class="p_context"> void irq_complete_move(struct irq_cfg *cfg)</span>
 }
 
 /*
<span class="p_del">- * Called with @desc-&gt;lock held and interrupts disabled.</span>
<span class="p_add">+ * Called from fixup_irqs() with @desc-&gt;lock held and interrupts disabled.</span>
  */
 void irq_force_complete_move(struct irq_desc *desc)
 {
 	struct irq_data *irqdata = irq_desc_get_irq_data(desc);
 	struct apic_chip_data *data = apic_chip_data(irqdata);
 	struct irq_cfg *cfg = data ? &amp;data-&gt;cfg : NULL;
<span class="p_add">+	unsigned int cpu;</span>
 
 	if (!cfg)
 		return;
 
<span class="p_del">-	__irq_complete_move(cfg, cfg-&gt;vector);</span>
<span class="p_del">-</span>
 	/*
 	 * This is tricky. If the cleanup of @data-&gt;old_domain has not been
 	 * done yet, then the following setaffinity call will fail with
 	 * -EBUSY. This can leave the interrupt in a stale state.
 	 *
<span class="p_del">-	 * The cleanup cannot make progress because we hold @desc-&gt;lock. So in</span>
<span class="p_del">-	 * case @data-&gt;old_domain is not yet cleaned up, we need to drop the</span>
<span class="p_del">-	 * lock and acquire it again. @desc cannot go away, because the</span>
<span class="p_del">-	 * hotplug code holds the sparse irq lock.</span>
<span class="p_add">+	 * All CPUs are stuck in stop machine with interrupts disabled so</span>
<span class="p_add">+	 * calling __irq_complete_move() would be completely pointless.</span>
 	 */
 	raw_spin_lock(&amp;vector_lock);
<span class="p_del">-	/* Clean out all offline cpus (including ourself) first. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clean out all offline cpus (including the outgoing one) from the</span>
<span class="p_add">+	 * old_domain mask.</span>
<span class="p_add">+	 */</span>
 	cpumask_and(data-&gt;old_domain, data-&gt;old_domain, cpu_online_mask);
<span class="p_del">-	while (!cpumask_empty(data-&gt;old_domain)) {</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If move_in_progress is cleared and the old_domain mask is empty,</span>
<span class="p_add">+	 * then there is nothing to cleanup. fixup_irqs() will take care of</span>
<span class="p_add">+	 * the stale vectors on the outgoing cpu.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!data-&gt;move_in_progress &amp;&amp; cpumask_empty(data-&gt;old_domain)) {</span>
 		raw_spin_unlock(&amp;vector_lock);
<span class="p_del">-		raw_spin_unlock(&amp;desc-&gt;lock);</span>
<span class="p_del">-		cpu_relax();</span>
<span class="p_del">-		raw_spin_lock(&amp;desc-&gt;lock);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 1) The interrupt is in move_in_progress state. That means that we</span>
<span class="p_add">+	 *    have not seen an interrupt since the io_apic was reprogrammed to</span>
<span class="p_add">+	 *    the new vector.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 2) The interrupt has fired on the new vector, but the cleanup IPIs</span>
<span class="p_add">+	 *    have not been processed yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (data-&gt;move_in_progress) {</span>
 		/*
<span class="p_del">-		 * Reevaluate apic_chip_data. It might have been cleared after</span>
<span class="p_del">-		 * we dropped @desc-&gt;lock.</span>
<span class="p_add">+		 * In theory there is a race:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * set_ioapic(new_vector) &lt;-- Interrupt is raised before update</span>
<span class="p_add">+		 *			      is effective, i.e. it&#39;s raised on</span>
<span class="p_add">+		 *			      the old vector.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * So if the target cpu cannot handle that interrupt before</span>
<span class="p_add">+		 * the old vector is cleaned up, we get a spurious interrupt</span>
<span class="p_add">+		 * and in the worst case the ioapic irq line becomes stale.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * But in case of cpu hotplug this should be a non issue</span>
<span class="p_add">+		 * because if the affinity update happens right before all</span>
<span class="p_add">+		 * cpus rendevouz in stop machine, there is no way that the</span>
<span class="p_add">+		 * interrupt can be blocked on the target cpu because all cpus</span>
<span class="p_add">+		 * loops first with interrupts enabled in stop machine, so the</span>
<span class="p_add">+		 * old vector is not yet cleaned up when the interrupt fires.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * So the only way to run into this issue is if the delivery</span>
<span class="p_add">+		 * of the interrupt on the apic/system bus would be delayed</span>
<span class="p_add">+		 * beyond the point where the target cpu disables interrupts</span>
<span class="p_add">+		 * in stop machine. I doubt that it can happen, but at least</span>
<span class="p_add">+		 * there is a theroretical chance. Virtualization might be</span>
<span class="p_add">+		 * able to expose this, but AFAICT the IOAPIC emulation is not</span>
<span class="p_add">+		 * as stupid as the real hardware.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Anyway, there is nothing we can do about that at this point</span>
<span class="p_add">+		 * w/o refactoring the whole fixup_irq() business completely.</span>
<span class="p_add">+		 * We print at least the irq number and the old vector number,</span>
<span class="p_add">+		 * so we have the necessary information when a problem in that</span>
<span class="p_add">+		 * area arises.</span>
 		 */
<span class="p_del">-		data = apic_chip_data(irqdata);</span>
<span class="p_del">-		if (!data)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		raw_spin_lock(&amp;vector_lock);</span>
<span class="p_add">+		pr_warn(&quot;IRQ fixup: irq %d move in progress, old vector %d\n&quot;,</span>
<span class="p_add">+			irqdata-&gt;irq, cfg-&gt;old_vector);</span>
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If old_domain is not empty, then other cpus still have the irq</span>
<span class="p_add">+	 * descriptor set in their vector array. Clean it up.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for_each_cpu(cpu, data-&gt;old_domain)</span>
<span class="p_add">+		per_cpu(vector_irq, cpu)[cfg-&gt;old_vector] = VECTOR_UNUSED;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Cleanup the left overs of the (half finished) move */</span>
<span class="p_add">+	cpumask_clear(data-&gt;old_domain);</span>
<span class="p_add">+	data-&gt;move_in_progress = 0;</span>
 	raw_spin_unlock(&amp;vector_lock);
 }
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index ce47402eb2f9..ac8975a65280 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -555,10 +555,14 @@</span> <span class="p_context"> scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
 	cd.data = NULL;
 	cd.size = 0;
 
<span class="p_del">-	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_del">-	if (!cd.data) {</span>
<span class="p_add">+	/* try built-in microcode if no initrd */</span>
<span class="p_add">+	if (!size) {</span>
 		if (!load_builtin_intel_microcode(&amp;cd))
 			return UCODE_ERROR;
<span class="p_add">+	} else {</span>
<span class="p_add">+		cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_add">+		if (!cd.data)</span>
<span class="p_add">+			return UCODE_ERROR;</span>
 	}
 
 	return get_matching_model_microcode(0, start, cd.data, cd.size,
<span class="p_chunk">@@ -694,7 +698,7 @@</span> <span class="p_context"> int __init save_microcode_in_initrd_intel(void)</span>
 	if (count == 0)
 		return ret;
 
<span class="p_del">-	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_add">+	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, get_initrd_start(), count);</span>
 	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);
 	if (ret)
 		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);
<span class="p_chunk">@@ -732,16 +736,20 @@</span> <span class="p_context"> void __init load_ucode_intel_bsp(void)</span>
 	struct boot_params *p;
 
 	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);
<span class="p_del">-	start	= p-&gt;hdr.ramdisk_image;</span>
 	size	= p-&gt;hdr.ramdisk_size;
 
<span class="p_del">-	_load_ucode_intel_bsp(</span>
<span class="p_del">-			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_del">-			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_del">-			start, size);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set start only if we have an initrd image. We cannot use initrd_start</span>
<span class="p_add">+	 * because it is not set that early yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	start	= (size ? p-&gt;hdr.ramdisk_image : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp((struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_add">+			      (unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_add">+			      start, size);</span>
 #else
<span class="p_del">-	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
 	size	= boot_params.hdr.ramdisk_size;
<span class="p_add">+	start	= (size ? boot_params.hdr.ramdisk_image + PAGE_OFFSET : 0);</span>
 
 	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);
 #endif
<span class="p_chunk">@@ -752,20 +760,14 @@</span> <span class="p_context"> void load_ucode_intel_ap(void)</span>
 	struct mc_saved_data *mc_saved_data_p;
 	struct ucode_cpu_info uci;
 	unsigned long *mc_saved_in_initrd_p;
<span class="p_del">-	unsigned long initrd_start_addr;</span>
 	enum ucode_state ret;
 #ifdef CONFIG_X86_32
<span class="p_del">-	unsigned long *initrd_start_p;</span>
 
<span class="p_del">-	mc_saved_in_initrd_p =</span>
<span class="p_del">-		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_add">+	mc_saved_in_initrd_p = (unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
 	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);
<span class="p_del">-	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_del">-	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
 #else
<span class="p_del">-	mc_saved_data_p = &amp;mc_saved_data;</span>
 	mc_saved_in_initrd_p = mc_saved_in_initrd;
<span class="p_del">-	initrd_start_addr = initrd_start;</span>
<span class="p_add">+	mc_saved_data_p = &amp;mc_saved_data;</span>
 #endif
 
 	/*
<span class="p_chunk">@@ -777,7 +779,7 @@</span> <span class="p_context"> void load_ucode_intel_ap(void)</span>
 
 	collect_cpu_info_early(&amp;uci);
 	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,
<span class="p_del">-			     initrd_start_addr, &amp;uci);</span>
<span class="p_add">+			     get_initrd_start_addr(), &amp;uci);</span>
 
 	if (ret != UCODE_OK)
 		return;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index 2bf79d7c97df..a3aeb2cc361e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -593,6 +593,19 @@</span> <span class="p_context"> void x86_pmu_disable_all(void)</span>
 	}
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * There may be PMI landing after enabled=0. The PMI hitting could be before or</span>
<span class="p_add">+ * after disable_all.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If PMI hits before disable_all, the PMU will be disabled in the NMI handler.</span>
<span class="p_add">+ * It will not be re-enabled in the NMI handler again, because enabled=0. After</span>
<span class="p_add">+ * handling the NMI, disable_all will be called, which will not change the</span>
<span class="p_add">+ * state either. If PMI hits after disable_all, the PMU is already disabled</span>
<span class="p_add">+ * before entering NMI handler. The NMI handler will not change the state</span>
<span class="p_add">+ * either.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * So either situation is harmless.</span>
<span class="p_add">+ */</span>
 static void x86_pmu_disable(struct pmu *pmu)
 {
 	struct cpu_hw_events *cpuc = this_cpu_ptr(&amp;cpu_hw_events);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.h b/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_header">index d0e35ebb2adb..ee70445fbb1f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_chunk">@@ -591,6 +591,7 @@</span> <span class="p_context"> struct x86_pmu {</span>
 			pebs_active	:1,
 			pebs_broken	:1;
 	int		pebs_record_size;
<span class="p_add">+	int		pebs_buffer_size;</span>
 	void		(*drain_pebs)(struct pt_regs *regs);
 	struct event_constraint *pebs_constraints;
 	void		(*pebs_aliases)(struct perf_event *event);
<span class="p_chunk">@@ -907,6 +908,8 @@</span> <span class="p_context"> void intel_pmu_lbr_init_hsw(void);</span>
 
 void intel_pmu_lbr_init_skl(void);
 
<span class="p_add">+void intel_pmu_pebs_data_source_nhm(void);</span>
<span class="p_add">+</span>
 int intel_pmu_setup_lbr_filter(struct perf_event *event);
 
 void intel_pt_interrupt(void);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">index e2a430021e46..078de2e86b7a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_chunk">@@ -1458,7 +1458,15 @@</span> <span class="p_context"> static __initconst const u64 slm_hw_cache_event_ids</span>
 };
 
 /*
<span class="p_del">- * Use from PMIs where the LBRs are already disabled.</span>
<span class="p_add">+ * Used from PMIs where the LBRs are already disabled.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function could be called consecutively. It is required to remain in</span>
<span class="p_add">+ * disabled state if called consecutively.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * During consecutive calls, the same disable value will be written to related</span>
<span class="p_add">+ * registers, so the PMU state remains unchanged. hw.state in</span>
<span class="p_add">+ * intel_bts_disable_local will remain PERF_HES_STOPPED too in consecutive</span>
<span class="p_add">+ * calls.</span>
  */
 static void __intel_pmu_disable_all(void)
 {
<span class="p_chunk">@@ -1840,6 +1848,16 @@</span> <span class="p_context"> again:</span>
 	if (__test_and_clear_bit(62, (unsigned long *)&amp;status)) {
 		handled++;
 		x86_pmu.drain_pebs(regs);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * There are cases where, even though, the PEBS ovfl bit is set</span>
<span class="p_add">+		 * in GLOBAL_OVF_STATUS, the PEBS events may also have their</span>
<span class="p_add">+		 * overflow bits set for their counters. We must clear them</span>
<span class="p_add">+		 * here because they have been processed as exact samples in</span>
<span class="p_add">+		 * the drain_pebs() routine. They must not be processed again</span>
<span class="p_add">+		 * in the for_each_bit_set() loop for regular samples below.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		status &amp;= ~cpuc-&gt;pebs_enabled;</span>
<span class="p_add">+		status &amp;= x86_pmu.intel_ctrl | GLOBAL_STATUS_TRACE_TOPAPMI;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -1885,7 +1903,10 @@</span> <span class="p_context"> again:</span>
 		goto again;
 
 done:
<span class="p_del">-	__intel_pmu_enable_all(0, true);</span>
<span class="p_add">+	/* Only restore PMU state when it&#39;s active. See x86_pmu_disable(). */</span>
<span class="p_add">+	if (cpuc-&gt;enabled)</span>
<span class="p_add">+		__intel_pmu_enable_all(0, true);</span>
<span class="p_add">+</span>
 	/*
 	 * Only unmask the NMI after the overflow counters
 	 * have been reset. This avoids spurious NMIs on
<span class="p_chunk">@@ -3315,6 +3336,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =
 			X86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);
 
<span class="p_add">+		intel_pmu_pebs_data_source_nhm();</span>
 		x86_add_quirk(intel_nehalem_quirk);
 
 		pr_cont(&quot;Nehalem events, &quot;);
<span class="p_chunk">@@ -3377,6 +3399,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 		intel_perfmon_event_map[PERF_COUNT_HW_STALLED_CYCLES_BACKEND] =
 			X86_CONFIG(.event=0xb1, .umask=0x3f, .inv=1, .cmask=1);
 
<span class="p_add">+		intel_pmu_pebs_data_source_nhm();</span>
 		pr_cont(&quot;Westmere events, &quot;);
 		break;
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_ds.c b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">index 5db1c7755548..7abb2b88572e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_chunk">@@ -51,7 +51,8 @@</span> <span class="p_context"> union intel_x86_pebs_dse {</span>
 #define OP_LH (P(OP, LOAD) | P(LVL, HIT))
 #define SNOOP_NONE_MISS (P(SNOOP, NONE) | P(SNOOP, MISS))
 
<span class="p_del">-static const u64 pebs_data_source[] = {</span>
<span class="p_add">+/* Version for Sandy Bridge and later */</span>
<span class="p_add">+static u64 pebs_data_source[] = {</span>
 	P(OP, LOAD) | P(LVL, MISS) | P(LVL, L3) | P(SNOOP, NA),/* 0x00:ukn L3 */
 	OP_LH | P(LVL, L1)  | P(SNOOP, NONE),	/* 0x01: L1 local */
 	OP_LH | P(LVL, LFB) | P(SNOOP, NONE),	/* 0x02: LFB hit */
<span class="p_chunk">@@ -70,6 +71,14 @@</span> <span class="p_context"> static const u64 pebs_data_source[] = {</span>
 	OP_LH | P(LVL, UNC) | P(SNOOP, NONE), /* 0x0f: uncached */
 };
 
<span class="p_add">+/* Patch up minor differences in the bits */</span>
<span class="p_add">+void __init intel_pmu_pebs_data_source_nhm(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pebs_data_source[0x05] = OP_LH | P(LVL, L3)  | P(SNOOP, HIT);</span>
<span class="p_add">+	pebs_data_source[0x06] = OP_LH | P(LVL, L3)  | P(SNOOP, HITM);</span>
<span class="p_add">+	pebs_data_source[0x07] = OP_LH | P(LVL, L3)  | P(SNOOP, HITM);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u64 precise_store_data(u64 status)
 {
 	union intel_x86_pebs_dse dse;
<span class="p_chunk">@@ -269,7 +278,7 @@</span> <span class="p_context"> static int alloc_pebs_buffer(int cpu)</span>
 	if (!x86_pmu.pebs)
 		return 0;
 
<span class="p_del">-	buffer = kzalloc_node(PEBS_BUFFER_SIZE, GFP_KERNEL, node);</span>
<span class="p_add">+	buffer = kzalloc_node(x86_pmu.pebs_buffer_size, GFP_KERNEL, node);</span>
 	if (unlikely(!buffer))
 		return -ENOMEM;
 
<span class="p_chunk">@@ -286,7 +295,7 @@</span> <span class="p_context"> static int alloc_pebs_buffer(int cpu)</span>
 		per_cpu(insn_buffer, cpu) = ibuffer;
 	}
 
<span class="p_del">-	max = PEBS_BUFFER_SIZE / x86_pmu.pebs_record_size;</span>
<span class="p_add">+	max = x86_pmu.pebs_buffer_size / x86_pmu.pebs_record_size;</span>
 
 	ds-&gt;pebs_buffer_base = (u64)(unsigned long)buffer;
 	ds-&gt;pebs_index = ds-&gt;pebs_buffer_base;
<span class="p_chunk">@@ -1296,6 +1305,7 @@</span> <span class="p_context"> void __init intel_ds_init(void)</span>
 
 	x86_pmu.bts  = boot_cpu_has(X86_FEATURE_BTS);
 	x86_pmu.pebs = boot_cpu_has(X86_FEATURE_PEBS);
<span class="p_add">+	x86_pmu.pebs_buffer_size = PEBS_BUFFER_SIZE;</span>
 	if (x86_pmu.pebs) {
 		char pebs_type = x86_pmu.intel_cap.pebs_trap ?  &#39;+&#39; : &#39;-&#39;;
 		int format = x86_pmu.intel_cap.pebs_format;
<span class="p_chunk">@@ -1304,6 +1314,14 @@</span> <span class="p_context"> void __init intel_ds_init(void)</span>
 		case 0:
 			printk(KERN_CONT &quot;PEBS fmt0%c, &quot;, pebs_type);
 			x86_pmu.pebs_record_size = sizeof(struct pebs_record_core);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Using &gt;PAGE_SIZE buffers makes the WRMSR to</span>
<span class="p_add">+			 * PERF_GLOBAL_CTRL in intel_pmu_enable_all()</span>
<span class="p_add">+			 * mysteriously hang on Core2.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As a workaround, we don&#39;t do this.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			x86_pmu.pebs_buffer_size = PAGE_SIZE;</span>
 			x86_pmu.drain_pebs = intel_pmu_drain_pebs_core;
 			break;
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_knc.c b/arch/x86/kernel/cpu/perf_event_knc.c</span>
<span class="p_header">index 5b0c232d1ee6..b931095e86d4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_knc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_knc.c</span>
<span class="p_chunk">@@ -263,7 +263,9 @@</span> <span class="p_context"> again:</span>
 		goto again;
 
 done:
<span class="p_del">-	knc_pmu_enable_all(0);</span>
<span class="p_add">+	/* Only restore PMU state when it&#39;s active. See x86_pmu_disable(). */</span>
<span class="p_add">+	if (cpuc-&gt;enabled)</span>
<span class="p_add">+		knc_pmu_enable_all(0);</span>
 
 	return handled;
 }
<span class="p_header">diff --git a/arch/x86/kernel/ioport.c b/arch/x86/kernel/ioport.c</span>
<span class="p_header">index 37dae792dbbe..589b3193f102 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ioport.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ioport.c</span>
<span class="p_chunk">@@ -96,9 +96,14 @@</span> <span class="p_context"> asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int turn_on)</span>
 SYSCALL_DEFINE1(iopl, unsigned int, level)
 {
 	struct pt_regs *regs = current_pt_regs();
<span class="p_del">-	unsigned int old = (regs-&gt;flags &gt;&gt; 12) &amp; 3;</span>
 	struct thread_struct *t = &amp;current-&gt;thread;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Careful: the IOPL bits in regs-&gt;flags are undefined under Xen PV</span>
<span class="p_add">+	 * and changing them has no effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned int old = t-&gt;iopl &gt;&gt; X86_EFLAGS_IOPL_BIT;</span>
<span class="p_add">+</span>
 	if (level &gt; 3)
 		return -EINVAL;
 	/* Trying to gain more privileges? */
<span class="p_chunk">@@ -106,8 +111,9 @@</span> <span class="p_context"> SYSCALL_DEFINE1(iopl, unsigned int, level)</span>
 		if (!capable(CAP_SYS_RAWIO))
 			return -EPERM;
 	}
<span class="p_del">-	regs-&gt;flags = (regs-&gt;flags &amp; ~X86_EFLAGS_IOPL) | (level &lt;&lt; 12);</span>
<span class="p_del">-	t-&gt;iopl = level &lt;&lt; 12;</span>
<span class="p_add">+	regs-&gt;flags = (regs-&gt;flags &amp; ~X86_EFLAGS_IOPL) |</span>
<span class="p_add">+		(level &lt;&lt; X86_EFLAGS_IOPL_BIT);</span>
<span class="p_add">+	t-&gt;iopl = level &lt;&lt; X86_EFLAGS_IOPL_BIT;</span>
 	set_iopl_mask(t-&gt;iopl);
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index e835d263a33b..4cbb60fbff3e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/syscalls.h&gt;
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/switch_to.h&gt;
<span class="p_add">+#include &lt;asm/xen/hypervisor.h&gt;</span>
 
 asmlinkage extern void ret_from_fork(void);
 
<span class="p_chunk">@@ -411,6 +412,17 @@</span> <span class="p_context"> __switch_to(struct task_struct *prev_p, struct task_struct *next_p)</span>
 		     task_thread_info(prev_p)-&gt;flags &amp; _TIF_WORK_CTXSW_PREV))
 		__switch_to_xtra(prev_p, next_p, tss);
 
<span class="p_add">+#ifdef CONFIG_XEN</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On Xen PV, IOPL bits in pt_regs-&gt;flags have no effect, and</span>
<span class="p_add">+	 * current_pt_regs()-&gt;flags may not match the current task&#39;s</span>
<span class="p_add">+	 * intended IOPL.  We need to switch it manually.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(static_cpu_has(X86_FEATURE_XENPV) &amp;&amp;</span>
<span class="p_add">+		     prev-&gt;iopl != next-&gt;iopl))</span>
<span class="p_add">+		xen_set_iopl_mask(next-&gt;iopl);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	if (static_cpu_has_bug(X86_BUG_SYSRET_SS_ATTRS)) {
 		/*
 		 * AMD CPUs have a misfeature: SYSRET sets the SS selector but
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index b0ea42b78ccd..ab5318727579 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)</span>
 		 * PIC is being reset.  Handle it gracefully here
 		 */
 		atomic_inc(&amp;ps-&gt;pending);
<span class="p_del">-	else if (value &gt; 0)</span>
<span class="p_add">+	else if (value &gt; 0 &amp;&amp; ps-&gt;reinject)</span>
 		/* in this case, we had multiple outstanding pit interrupts
 		 * that we needed to inject.  Reinject
 		 */
<span class="p_chunk">@@ -288,7 +288,9 @@</span> <span class="p_context"> static void pit_do_work(struct kthread_work *work)</span>
 	 * last one has been acked.
 	 */
 	spin_lock(&amp;ps-&gt;inject_lock);
<span class="p_del">-	if (ps-&gt;irq_ack) {</span>
<span class="p_add">+	if (!ps-&gt;reinject)</span>
<span class="p_add">+		inject = 1;</span>
<span class="p_add">+	else if (ps-&gt;irq_ack) {</span>
 		ps-&gt;irq_ack = 0;
 		inject = 1;
 	}
<span class="p_chunk">@@ -317,10 +319,10 @@</span> <span class="p_context"> static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)</span>
 	struct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);
 	struct kvm_pit *pt = ps-&gt;kvm-&gt;arch.vpit;
 
<span class="p_del">-	if (ps-&gt;reinject || !atomic_read(&amp;ps-&gt;pending)) {</span>
<span class="p_add">+	if (ps-&gt;reinject)</span>
 		atomic_inc(&amp;ps-&gt;pending);
<span class="p_del">-		queue_kthread_work(&amp;pt-&gt;worker, &amp;pt-&gt;expired);</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	queue_kthread_work(&amp;pt-&gt;worker, &amp;pt-&gt;expired);</span>
 
 	if (ps-&gt;is_periodic) {
 		hrtimer_add_expires_ns(&amp;ps-&gt;timer, ps-&gt;period);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 0958fa2b7cb7..f34ab71dfd57 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2637,8 +2637,15 @@</span> <span class="p_context"> static void nested_vmx_setup_ctls_msrs(struct vcpu_vmx *vmx)</span>
 	} else
 		vmx-&gt;nested.nested_vmx_ept_caps = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Old versions of KVM use the single-context version without</span>
<span class="p_add">+	 * checking for support, so declare that it is supported even</span>
<span class="p_add">+	 * though it is treated as global context.  The alternative is</span>
<span class="p_add">+	 * not failing the single-context invvpid, and it is worse.</span>
<span class="p_add">+	 */</span>
 	if (enable_vpid)
 		vmx-&gt;nested.nested_vmx_vpid_caps = VMX_VPID_INVVPID_BIT |
<span class="p_add">+				VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT |</span>
 				VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;
 	else
 		vmx-&gt;nested.nested_vmx_vpid_caps = 0;
<span class="p_chunk">@@ -7340,6 +7347,7 @@</span> <span class="p_context"> static int handle_invept(struct kvm_vcpu *vcpu)</span>
 	if (!(types &amp; (1UL &lt;&lt; type))) {
 		nested_vmx_failValid(vcpu,
 				VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
<span class="p_add">+		skip_emulated_instruction(vcpu);</span>
 		return 1;
 	}
 
<span class="p_chunk">@@ -7398,6 +7406,7 @@</span> <span class="p_context"> static int handle_invvpid(struct kvm_vcpu *vcpu)</span>
 	if (!(types &amp; (1UL &lt;&lt; type))) {
 		nested_vmx_failValid(vcpu,
 			VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);
<span class="p_add">+		skip_emulated_instruction(vcpu);</span>
 		return 1;
 	}
 
<span class="p_chunk">@@ -7414,12 +7423,17 @@</span> <span class="p_context"> static int handle_invvpid(struct kvm_vcpu *vcpu)</span>
 	}
 
 	switch (type) {
<span class="p_add">+	case VMX_VPID_EXTENT_SINGLE_CONTEXT:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Old versions of KVM use the single-context version so we</span>
<span class="p_add">+		 * have to support it; just treat it the same as all-context.</span>
<span class="p_add">+		 */</span>
 	case VMX_VPID_EXTENT_ALL_CONTEXT:
 		__vmx_flush_tlb(vcpu, to_vmx(vcpu)-&gt;nested.vpid02);
 		nested_vmx_succeed(vcpu);
 		break;
 	default:
<span class="p_del">-		/* Trap single context invalidation invvpid calls */</span>
<span class="p_add">+		/* Trap individual address invalidation invvpid calls */</span>
 		BUG_ON(1);
 		break;
 	}
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index d2945024ed33..8bfc5fc6a39b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -2736,6 +2736,7 @@</span> <span class="p_context"> void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)</span>
 	}
 
 	kvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);
<span class="p_add">+	vcpu-&gt;arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;</span>
 }
 
 void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 8f4cc3dfac32..5fb6adaaa796 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -106,8 +106,6 @@</span> <span class="p_context"> static void flush_tlb_func(void *info)</span>
 
 	if (f-&gt;flush_mm != this_cpu_read(cpu_tlbstate.active_mm))
 		return;
<span class="p_del">-	if (!f-&gt;flush_end)</span>
<span class="p_del">-		f-&gt;flush_end = f-&gt;flush_start + PAGE_SIZE;</span>
 
 	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH_RECEIVED);
 	if (this_cpu_read(cpu_tlbstate.state) == TLBSTATE_OK) {
<span class="p_chunk">@@ -135,12 +133,20 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 				 unsigned long end)
 {
 	struct flush_tlb_info info;
<span class="p_add">+</span>
<span class="p_add">+	if (end == 0)</span>
<span class="p_add">+		end = start + PAGE_SIZE;</span>
 	info.flush_mm = mm;
 	info.flush_start = start;
 	info.flush_end = end;
 
 	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH);
<span class="p_del">-	trace_tlb_flush(TLB_REMOTE_SEND_IPI, end - start);</span>
<span class="p_add">+	if (end == TLB_FLUSH_ALL)</span>
<span class="p_add">+		trace_tlb_flush(TLB_REMOTE_SEND_IPI, TLB_FLUSH_ALL);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		trace_tlb_flush(TLB_REMOTE_SEND_IPI,</span>
<span class="p_add">+				(end - start) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	if (is_uv_system()) {
 		unsigned int cpu;
 
<span class="p_header">diff --git a/arch/x86/pci/fixup.c b/arch/x86/pci/fixup.c</span>
<span class="p_header">index e58565556703..0ae7e9fa348d 100644</span>
<span class="p_header">--- a/arch/x86/pci/fixup.c</span>
<span class="p_header">+++ b/arch/x86/pci/fixup.c</span>
<span class="p_chunk">@@ -540,3 +540,10 @@</span> <span class="p_context"> static void twinhead_reserve_killing_zone(struct pci_dev *dev)</span>
         }
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);
<span class="p_add">+</span>
<span class="p_add">+static void pci_bdwep_bar(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dev-&gt;non_compliant_bars = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fa0, pci_bdwep_bar);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x6fc0, pci_bdwep_bar);</span>
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index b7de78bdc09c..beab8c706ac9 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -961,7 +961,7 @@</span> <span class="p_context"> static void xen_load_sp0(struct tss_struct *tss,</span>
 	tss-&gt;x86_tss.sp0 = thread-&gt;sp0;
 }
 
<span class="p_del">-static void xen_set_iopl_mask(unsigned mask)</span>
<span class="p_add">+void xen_set_iopl_mask(unsigned mask)</span>
 {
 	struct physdev_set_iopl set_iopl;
 
<span class="p_header">diff --git a/arch/xtensa/kernel/head.S b/arch/xtensa/kernel/head.S</span>
<span class="p_header">index 9ed55649ac8e..05e1df943856 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/head.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/head.S</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> ENTRY(_startup)</span>
 	wsr	a0, icountlevel
 
 	.set	_index, 0
<span class="p_del">-	.rept	XCHAL_NUM_DBREAK - 1</span>
<span class="p_add">+	.rept	XCHAL_NUM_DBREAK</span>
 	wsr	a0, SREG_DBREAKC + _index
 	.set	_index, _index + 1
 	.endr
<span class="p_header">diff --git a/arch/xtensa/mm/cache.c b/arch/xtensa/mm/cache.c</span>
<span class="p_header">index d75aa1476da7..1a804a2f9a5b 100644</span>
<span class="p_header">--- a/arch/xtensa/mm/cache.c</span>
<span class="p_header">+++ b/arch/xtensa/mm/cache.c</span>
<span class="p_chunk">@@ -97,11 +97,11 @@</span> <span class="p_context"> void clear_user_highpage(struct page *page, unsigned long vaddr)</span>
 	unsigned long paddr;
 	void *kvaddr = coherent_kvaddr(page, TLBTEMP_BASE_1, vaddr, &amp;paddr);
 
<span class="p_del">-	pagefault_disable();</span>
<span class="p_add">+	preempt_disable();</span>
 	kmap_invalidate_coherent(page, vaddr);
 	set_bit(PG_arch_1, &amp;page-&gt;flags);
 	clear_page_alias(kvaddr, paddr);
<span class="p_del">-	pagefault_enable();</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 void copy_user_highpage(struct page *dst, struct page *src,
<span class="p_chunk">@@ -113,11 +113,11 @@</span> <span class="p_context"> void copy_user_highpage(struct page *dst, struct page *src,</span>
 	void *src_vaddr = coherent_kvaddr(src, TLBTEMP_BASE_2, vaddr,
 					  &amp;src_paddr);
 
<span class="p_del">-	pagefault_disable();</span>
<span class="p_add">+	preempt_disable();</span>
 	kmap_invalidate_coherent(dst, vaddr);
 	set_bit(PG_arch_1, &amp;dst-&gt;flags);
 	copy_page_alias(dst_vaddr, src_vaddr, dst_paddr, src_paddr);
<span class="p_del">-	pagefault_enable();</span>
<span class="p_add">+	preempt_enable();</span>
 }
 
 #endif /* DCACHE_WAY_SIZE &gt; PAGE_SIZE */
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/console.c b/arch/xtensa/platforms/iss/console.c</span>
<span class="p_header">index 70cb408bc20d..92d785fefb6d 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/console.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/console.c</span>
<span class="p_chunk">@@ -100,21 +100,23 @@</span> <span class="p_context"> static void rs_poll(unsigned long priv)</span>
 {
 	struct tty_port *port = (struct tty_port *)priv;
 	int i = 0;
<span class="p_add">+	int rd = 1;</span>
 	unsigned char c;
 
 	spin_lock(&amp;timer_lock);
 
 	while (simc_poll(0)) {
<span class="p_del">-		simc_read(0, &amp;c, 1);</span>
<span class="p_add">+		rd = simc_read(0, &amp;c, 1);</span>
<span class="p_add">+		if (rd &lt;= 0)</span>
<span class="p_add">+			break;</span>
 		tty_insert_flip_char(port, c, TTY_NORMAL);
 		i++;
 	}
 
 	if (i)
 		tty_flip_buffer_push(port);
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	mod_timer(&amp;serial_timer, jiffies + SERIAL_TIMER_VALUE);</span>
<span class="p_add">+	if (rd)</span>
<span class="p_add">+		mod_timer(&amp;serial_timer, jiffies + SERIAL_TIMER_VALUE);</span>
 	spin_unlock(&amp;timer_lock);
 }
 
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 33e2f62d5062..f8e64cac981a 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -2189,7 +2189,7 @@</span> <span class="p_context"> int blk_insert_cloned_request(struct request_queue *q, struct request *rq)</span>
 	if (q-&gt;mq_ops) {
 		if (blk_queue_io_stat(q))
 			blk_account_io_start(rq, true);
<span class="p_del">-		blk_mq_insert_request(rq, false, true, true);</span>
<span class="p_add">+		blk_mq_insert_request(rq, false, true, false);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_cert_parser.c b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">index 021d39c0ba75..13c4e5a5fe8c 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_cert_parser.c</span>
<span class="p_chunk">@@ -494,7 +494,7 @@</span> <span class="p_context"> int x509_decode_time(time64_t *_t,  size_t hdrlen,</span>
 		     unsigned char tag,
 		     const unsigned char *value, size_t vlen)
 {
<span class="p_del">-	static const unsigned char month_lengths[] = { 31, 29, 31, 30, 31, 30,</span>
<span class="p_add">+	static const unsigned char month_lengths[] = { 31, 28, 31, 30, 31, 30,</span>
 						       31, 31, 30, 31, 30, 31 };
 	const unsigned char *p = value;
 	unsigned year, mon, day, hour, min, sec, mon_len;
<span class="p_chunk">@@ -540,9 +540,9 @@</span> <span class="p_context"> int x509_decode_time(time64_t *_t,  size_t hdrlen,</span>
 		if (year % 4 == 0) {
 			mon_len = 29;
 			if (year % 100 == 0) {
<span class="p_del">-				year /= 100;</span>
<span class="p_del">-				if (year % 4 != 0)</span>
<span class="p_del">-					mon_len = 28;</span>
<span class="p_add">+				mon_len = 28;</span>
<span class="p_add">+				if (year % 400 == 0)</span>
<span class="p_add">+					mon_len = 29;</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/crypto/keywrap.c b/crypto/keywrap.c</span>
<span class="p_header">index b1d106ce55f3..72014f963ba7 100644</span>
<span class="p_header">--- a/crypto/keywrap.c</span>
<span class="p_header">+++ b/crypto/keywrap.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static int crypto_kw_decrypt(struct blkcipher_desc *desc,</span>
 			  SEMIBSIZE))
 		ret = -EBADMSG;
 
<span class="p_del">-	memzero_explicit(&amp;block, sizeof(struct crypto_kw_block));</span>
<span class="p_add">+	memzero_explicit(block, sizeof(struct crypto_kw_block));</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> static int crypto_kw_encrypt(struct blkcipher_desc *desc,</span>
 	/* establish the IV for the caller to pick up */
 	memcpy(desc-&gt;info, block-&gt;A, SEMIBSIZE);
 
<span class="p_del">-	memzero_explicit(&amp;block, sizeof(struct crypto_kw_block));</span>
<span class="p_add">+	memzero_explicit(block, sizeof(struct crypto_kw_block));</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/acpi/resource.c b/drivers/acpi/resource.c</span>
<span class="p_header">index cdc5c2599beb..627f8fbb5e9a 100644</span>
<span class="p_header">--- a/drivers/acpi/resource.c</span>
<span class="p_header">+++ b/drivers/acpi/resource.c</span>
<span class="p_chunk">@@ -26,8 +26,20 @@</span> <span class="p_context"></span>
 
 #ifdef CONFIG_X86
 #define valid_IRQ(i) (((i) != 0) &amp;&amp; ((i) != 2))
<span class="p_add">+static inline bool acpi_iospace_resource_valid(struct resource *res)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* On X86 IO space is limited to the [0 - 64K] IO port range */</span>
<span class="p_add">+	return res-&gt;end &lt; 0x10003;</span>
<span class="p_add">+}</span>
 #else
 #define valid_IRQ(i) (true)
<span class="p_add">+/*</span>
<span class="p_add">+ * ACPI IO descriptors on arches other than X86 contain MMIO CPU physical</span>
<span class="p_add">+ * addresses mapping IO space in CPU physical address space, IO space</span>
<span class="p_add">+ * resources can be placed anywhere in the 64-bit physical address space.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool</span>
<span class="p_add">+acpi_iospace_resource_valid(struct resource *res) { return true; }</span>
 #endif
 
 static bool acpi_dev_resource_len_valid(u64 start, u64 end, u64 len, bool io)
<span class="p_chunk">@@ -126,7 +138,7 @@</span> <span class="p_context"> static void acpi_dev_ioresource_flags(struct resource *res, u64 len,</span>
 	if (!acpi_dev_resource_len_valid(res-&gt;start, res-&gt;end, len, true))
 		res-&gt;flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
 
<span class="p_del">-	if (res-&gt;end &gt;= 0x10003)</span>
<span class="p_add">+	if (!acpi_iospace_resource_valid(res))</span>
 		res-&gt;flags |= IORESOURCE_DISABLED | IORESOURCE_UNSET;
 
 	if (io_decode == ACPI_DECODE_16)
<span class="p_header">diff --git a/drivers/acpi/sleep.c b/drivers/acpi/sleep.c</span>
<span class="p_header">index 0d94621dc856..e3322adaaae0 100644</span>
<span class="p_header">--- a/drivers/acpi/sleep.c</span>
<span class="p_header">+++ b/drivers/acpi/sleep.c</span>
<span class="p_chunk">@@ -714,6 +714,7 @@</span> <span class="p_context"> static int acpi_hibernation_enter(void)</span>
 
 static void acpi_hibernation_leave(void)
 {
<span class="p_add">+	pm_set_resume_via_firmware();</span>
 	/*
 	 * If ACPI is not enabled by the BIOS and the boot kernel, we need to
 	 * enable it here.
<span class="p_header">diff --git a/drivers/block/brd.c b/drivers/block/brd.c</span>
<span class="p_header">index a5880f4ab40e..1914c63ca8b1 100644</span>
<span class="p_header">--- a/drivers/block/brd.c</span>
<span class="p_header">+++ b/drivers/block/brd.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> static blk_qc_t brd_make_request(struct request_queue *q, struct bio *bio)</span>
 
 	if (unlikely(bio-&gt;bi_rw &amp; REQ_DISCARD)) {
 		if (sector &amp; ((PAGE_SIZE &gt;&gt; SECTOR_SHIFT) - 1) ||
<span class="p_del">-		    bio-&gt;bi_iter.bi_size &amp; PAGE_MASK)</span>
<span class="p_add">+		    bio-&gt;bi_iter.bi_size &amp; ~PAGE_MASK)</span>
 			goto io_error;
 		discard_from_brd(brd, sector, bio-&gt;bi_iter.bi_size);
 		goto out;
<span class="p_header">diff --git a/drivers/block/mtip32xx/mtip32xx.c b/drivers/block/mtip32xx/mtip32xx.c</span>
<span class="p_header">index 3457ac8c03e2..55d3d1da72de 100644</span>
<span class="p_header">--- a/drivers/block/mtip32xx/mtip32xx.c</span>
<span class="p_header">+++ b/drivers/block/mtip32xx/mtip32xx.c</span>
<span class="p_chunk">@@ -173,7 +173,13 @@</span> <span class="p_context"> static struct mtip_cmd *mtip_get_int_command(struct driver_data *dd)</span>
 {
 	struct request *rq;
 
<span class="p_add">+	if (mtip_check_surprise_removal(dd-&gt;pdev))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	rq = blk_mq_alloc_request(dd-&gt;queue, 0, __GFP_RECLAIM, true);
<span class="p_add">+	if (IS_ERR(rq))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
 	return blk_mq_rq_to_pdu(rq);
 }
 
<span class="p_chunk">@@ -233,15 +239,9 @@</span> <span class="p_context"> static void mtip_async_complete(struct mtip_port *port,</span>
 			&quot;Command tag %d failed due to TFE\n&quot;, tag);
 	}
 
<span class="p_del">-	/* Unmap the DMA scatter list entries */</span>
<span class="p_del">-	dma_unmap_sg(&amp;dd-&gt;pdev-&gt;dev, cmd-&gt;sg, cmd-&gt;scatter_ents, cmd-&gt;direction);</span>
<span class="p_del">-</span>
 	rq = mtip_rq_from_tag(dd, tag);
 
<span class="p_del">-	if (unlikely(cmd-&gt;unaligned))</span>
<span class="p_del">-		up(&amp;port-&gt;cmd_slot_unal);</span>
<span class="p_del">-</span>
<span class="p_del">-	blk_mq_end_request(rq, status ? -EIO : 0);</span>
<span class="p_add">+	blk_mq_complete_request(rq, status);</span>
 }
 
 /*
<span class="p_chunk">@@ -581,6 +581,8 @@</span> <span class="p_context"> static void mtip_completion(struct mtip_port *port,</span>
 		dev_warn(&amp;port-&gt;dd-&gt;pdev-&gt;dev,
 			&quot;Internal command %d completed with TFE\n&quot;, tag);
 
<span class="p_add">+	command-&gt;comp_func = NULL;</span>
<span class="p_add">+	command-&gt;comp_data = NULL;</span>
 	complete(waiting);
 }
 
<span class="p_chunk">@@ -618,8 +620,6 @@</span> <span class="p_context"> static void mtip_handle_tfe(struct driver_data *dd)</span>
 
 	port = dd-&gt;port;
 
<span class="p_del">-	set_bit(MTIP_PF_EH_ACTIVE_BIT, &amp;port-&gt;flags);</span>
<span class="p_del">-</span>
 	if (test_bit(MTIP_PF_IC_ACTIVE_BIT, &amp;port-&gt;flags)) {
 		cmd = mtip_cmd_from_tag(dd, MTIP_TAG_INTERNAL);
 		dbg_printk(MTIP_DRV_NAME &quot; TFE for the internal command\n&quot;);
<span class="p_chunk">@@ -628,7 +628,7 @@</span> <span class="p_context"> static void mtip_handle_tfe(struct driver_data *dd)</span>
 			cmd-&gt;comp_func(port, MTIP_TAG_INTERNAL,
 					cmd, PORT_IRQ_TF_ERR);
 		}
<span class="p_del">-		goto handle_tfe_exit;</span>
<span class="p_add">+		return;</span>
 	}
 
 	/* clear the tag accumulator */
<span class="p_chunk">@@ -701,7 +701,7 @@</span> <span class="p_context"> static void mtip_handle_tfe(struct driver_data *dd)</span>
 			fail_reason = &quot;thermal shutdown&quot;;
 		}
 		if (buf[288] == 0xBF) {
<span class="p_del">-			set_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;dd-&gt;dd_flag);</span>
<span class="p_add">+			set_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;dd-&gt;dd_flag);</span>
 			dev_info(&amp;dd-&gt;pdev-&gt;dev,
 				&quot;Drive indicates rebuild has failed. Secure erase required.\n&quot;);
 			fail_all_ncq_cmds = 1;
<span class="p_chunk">@@ -771,11 +771,6 @@</span> <span class="p_context"> static void mtip_handle_tfe(struct driver_data *dd)</span>
 		}
 	}
 	print_tags(dd, &quot;reissued (TFE)&quot;, tagaccum, cmd_cnt);
<span class="p_del">-</span>
<span class="p_del">-handle_tfe_exit:</span>
<span class="p_del">-	/* clear eh_active */</span>
<span class="p_del">-	clear_bit(MTIP_PF_EH_ACTIVE_BIT, &amp;port-&gt;flags);</span>
<span class="p_del">-	wake_up_interruptible(&amp;port-&gt;svc_wait);</span>
 }
 
 /*
<span class="p_chunk">@@ -1007,6 +1002,7 @@</span> <span class="p_context"> static bool mtip_pause_ncq(struct mtip_port *port,</span>
 			(fis-&gt;features == 0x27 || fis-&gt;features == 0x72 ||
 			 fis-&gt;features == 0x62 || fis-&gt;features == 0x26))) {
 		clear_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;port-&gt;dd-&gt;dd_flag);
<span class="p_add">+		clear_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;port-&gt;dd-&gt;dd_flag);</span>
 		/* Com reset after secure erase or lowlevel format */
 		mtip_restart_port(port);
 		clear_bit(MTIP_PF_SE_ACTIVE_BIT, &amp;port-&gt;flags);
<span class="p_chunk">@@ -1021,12 +1017,14 @@</span> <span class="p_context"> static bool mtip_pause_ncq(struct mtip_port *port,</span>
  *
  * @port    Pointer to port data structure
  * @timeout Max duration to wait (ms)
<span class="p_add">+ * @atomic  gfp_t flag to indicate blockable context or not</span>
  *
  * return value
  *	0	Success
  *	-EBUSY  Commands still active
  */
<span class="p_del">-static int mtip_quiesce_io(struct mtip_port *port, unsigned long timeout)</span>
<span class="p_add">+static int mtip_quiesce_io(struct mtip_port *port, unsigned long timeout,</span>
<span class="p_add">+								gfp_t atomic)</span>
 {
 	unsigned long to;
 	unsigned int n;
<span class="p_chunk">@@ -1037,16 +1035,21 @@</span> <span class="p_context"> static int mtip_quiesce_io(struct mtip_port *port, unsigned long timeout)</span>
 	to = jiffies + msecs_to_jiffies(timeout);
 	do {
 		if (test_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &amp;port-&gt;flags) &amp;&amp;
<span class="p_del">-			test_bit(MTIP_PF_ISSUE_CMDS_BIT, &amp;port-&gt;flags)) {</span>
<span class="p_add">+			test_bit(MTIP_PF_ISSUE_CMDS_BIT, &amp;port-&gt;flags) &amp;&amp;</span>
<span class="p_add">+			atomic == GFP_KERNEL) {</span>
 			msleep(20);
 			continue; /* svc thd is actively issuing commands */
 		}
 
<span class="p_del">-		msleep(100);</span>
<span class="p_add">+		if (atomic == GFP_KERNEL)</span>
<span class="p_add">+			msleep(100);</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			cpu_relax();</span>
<span class="p_add">+			udelay(100);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (mtip_check_surprise_removal(port-&gt;dd-&gt;pdev))
 			goto err_fault;
<span class="p_del">-		if (test_bit(MTIP_DDF_REMOVE_PENDING_BIT, &amp;port-&gt;dd-&gt;dd_flag))</span>
<span class="p_del">-			goto err_fault;</span>
 
 		/*
 		 * Ignore s_active bit 0 of array element 0.
<span class="p_chunk">@@ -1099,6 +1102,7 @@</span> <span class="p_context"> static int mtip_exec_internal_command(struct mtip_port *port,</span>
 	struct mtip_cmd *int_cmd;
 	struct driver_data *dd = port-&gt;dd;
 	int rv = 0;
<span class="p_add">+	unsigned long start;</span>
 
 	/* Make sure the buffer is 8 byte aligned. This is asic specific. */
 	if (buffer &amp; 0x00000007) {
<span class="p_chunk">@@ -1107,6 +1111,10 @@</span> <span class="p_context"> static int mtip_exec_internal_command(struct mtip_port *port,</span>
 	}
 
 	int_cmd = mtip_get_int_command(dd);
<span class="p_add">+	if (!int_cmd) {</span>
<span class="p_add">+		dbg_printk(MTIP_DRV_NAME &quot;Unable to allocate tag for PIO cmd\n&quot;);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
 
 	set_bit(MTIP_PF_IC_ACTIVE_BIT, &amp;port-&gt;flags);
 
<span class="p_chunk">@@ -1119,7 +1127,7 @@</span> <span class="p_context"> static int mtip_exec_internal_command(struct mtip_port *port,</span>
 		if (fis-&gt;command != ATA_CMD_STANDBYNOW1) {
 			/* wait for io to complete if non atomic */
 			if (mtip_quiesce_io(port,
<span class="p_del">-					MTIP_QUIESCE_IO_TIMEOUT_MS) &lt; 0) {</span>
<span class="p_add">+				MTIP_QUIESCE_IO_TIMEOUT_MS, atomic) &lt; 0) {</span>
 				dev_warn(&amp;dd-&gt;pdev-&gt;dev,
 					&quot;Failed to quiesce IO\n&quot;);
 				mtip_put_int_command(dd, int_cmd);
<span class="p_chunk">@@ -1162,6 +1170,8 @@</span> <span class="p_context"> static int mtip_exec_internal_command(struct mtip_port *port,</span>
 	/* Populate the command header */
 	int_cmd-&gt;command_header-&gt;byte_count = 0;
 
<span class="p_add">+	start = jiffies;</span>
<span class="p_add">+</span>
 	/* Issue the command to the hardware */
 	mtip_issue_non_ncq_command(port, MTIP_TAG_INTERNAL);
 
<span class="p_chunk">@@ -1170,10 +1180,12 @@</span> <span class="p_context"> static int mtip_exec_internal_command(struct mtip_port *port,</span>
 		if ((rv = wait_for_completion_interruptible_timeout(
 				&amp;wait,
 				msecs_to_jiffies(timeout))) &lt;= 0) {
<span class="p_add">+</span>
 			if (rv == -ERESTARTSYS) { /* interrupted */
 				dev_err(&amp;dd-&gt;pdev-&gt;dev,
<span class="p_del">-					&quot;Internal command [%02X] was interrupted after %lu ms\n&quot;,</span>
<span class="p_del">-					fis-&gt;command, timeout);</span>
<span class="p_add">+					&quot;Internal command [%02X] was interrupted after %u ms\n&quot;,</span>
<span class="p_add">+					fis-&gt;command,</span>
<span class="p_add">+					jiffies_to_msecs(jiffies - start));</span>
 				rv = -EINTR;
 				goto exec_ic_exit;
 			} else if (rv == 0) /* timeout */
<span class="p_chunk">@@ -2897,6 +2909,42 @@</span> <span class="p_context"> static int mtip_ftl_rebuild_poll(struct driver_data *dd)</span>
 	return -EFAULT;
 }
 
<span class="p_add">+static void mtip_softirq_done_fn(struct request *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtip_cmd *cmd = blk_mq_rq_to_pdu(rq);</span>
<span class="p_add">+	struct driver_data *dd = rq-&gt;q-&gt;queuedata;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unmap the DMA scatter list entries */</span>
<span class="p_add">+	dma_unmap_sg(&amp;dd-&gt;pdev-&gt;dev, cmd-&gt;sg, cmd-&gt;scatter_ents,</span>
<span class="p_add">+							cmd-&gt;direction);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(cmd-&gt;unaligned))</span>
<span class="p_add">+		up(&amp;dd-&gt;port-&gt;cmd_slot_unal);</span>
<span class="p_add">+</span>
<span class="p_add">+	blk_mq_end_request(rq, rq-&gt;errors);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtip_abort_cmd(struct request *req, void *data,</span>
<span class="p_add">+							bool reserved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct driver_data *dd = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	dbg_printk(MTIP_DRV_NAME &quot; Aborting request, tag = %d\n&quot;, req-&gt;tag);</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(req-&gt;tag, dd-&gt;port-&gt;cmds_to_issue);</span>
<span class="p_add">+	req-&gt;errors = -EIO;</span>
<span class="p_add">+	mtip_softirq_done_fn(req);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtip_queue_cmd(struct request *req, void *data,</span>
<span class="p_add">+							bool reserved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct driver_data *dd = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_bit(req-&gt;tag, dd-&gt;port-&gt;cmds_to_issue);</span>
<span class="p_add">+	blk_abort_request(req);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * service thread to issue queued commands
  *
<span class="p_chunk">@@ -2909,7 +2957,7 @@</span> <span class="p_context"> static int mtip_ftl_rebuild_poll(struct driver_data *dd)</span>
 static int mtip_service_thread(void *data)
 {
 	struct driver_data *dd = (struct driver_data *)data;
<span class="p_del">-	unsigned long slot, slot_start, slot_wrap;</span>
<span class="p_add">+	unsigned long slot, slot_start, slot_wrap, to;</span>
 	unsigned int num_cmd_slots = dd-&gt;slot_groups * 32;
 	struct mtip_port *port = dd-&gt;port;
 
<span class="p_chunk">@@ -2924,9 +2972,7 @@</span> <span class="p_context"> static int mtip_service_thread(void *data)</span>
 		 * is in progress nor error handling is active
 		 */
 		wait_event_interruptible(port-&gt;svc_wait, (port-&gt;flags) &amp;&amp;
<span class="p_del">-			!(port-&gt;flags &amp; MTIP_PF_PAUSE_IO));</span>
<span class="p_del">-</span>
<span class="p_del">-		set_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &amp;port-&gt;flags);</span>
<span class="p_add">+			(port-&gt;flags &amp; MTIP_PF_SVC_THD_WORK));</span>
 
 		if (kthread_should_stop() ||
 			test_bit(MTIP_PF_SVC_THD_STOP_BIT, &amp;port-&gt;flags))
<span class="p_chunk">@@ -2936,6 +2982,8 @@</span> <span class="p_context"> static int mtip_service_thread(void *data)</span>
 				&amp;dd-&gt;dd_flag)))
 			goto st_out;
 
<span class="p_add">+		set_bit(MTIP_PF_SVC_THD_ACTIVE_BIT, &amp;port-&gt;flags);</span>
<span class="p_add">+</span>
 restart_eh:
 		/* Demux bits: start with error handling */
 		if (test_bit(MTIP_PF_EH_ACTIVE_BIT, &amp;port-&gt;flags)) {
<span class="p_chunk">@@ -2946,6 +2994,32 @@</span> <span class="p_context"> restart_eh:</span>
 		if (test_bit(MTIP_PF_EH_ACTIVE_BIT, &amp;port-&gt;flags))
 			goto restart_eh;
 
<span class="p_add">+		if (test_bit(MTIP_PF_TO_ACTIVE_BIT, &amp;port-&gt;flags)) {</span>
<span class="p_add">+			to = jiffies + msecs_to_jiffies(5000);</span>
<span class="p_add">+</span>
<span class="p_add">+			do {</span>
<span class="p_add">+				mdelay(100);</span>
<span class="p_add">+			} while (atomic_read(&amp;dd-&gt;irq_workers_active) != 0 &amp;&amp;</span>
<span class="p_add">+				time_before(jiffies, to));</span>
<span class="p_add">+</span>
<span class="p_add">+			if (atomic_read(&amp;dd-&gt;irq_workers_active) != 0)</span>
<span class="p_add">+				dev_warn(&amp;dd-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					&quot;Completion workers still active!&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_lock(dd-&gt;queue-&gt;queue_lock);</span>
<span class="p_add">+			blk_mq_all_tag_busy_iter(*dd-&gt;tags.tags,</span>
<span class="p_add">+							mtip_queue_cmd, dd);</span>
<span class="p_add">+			spin_unlock(dd-&gt;queue-&gt;queue_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			set_bit(MTIP_PF_ISSUE_CMDS_BIT, &amp;dd-&gt;port-&gt;flags);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (mtip_device_reset(dd))</span>
<span class="p_add">+				blk_mq_all_tag_busy_iter(*dd-&gt;tags.tags,</span>
<span class="p_add">+							mtip_abort_cmd, dd);</span>
<span class="p_add">+</span>
<span class="p_add">+			clear_bit(MTIP_PF_TO_ACTIVE_BIT, &amp;dd-&gt;port-&gt;flags);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (test_bit(MTIP_PF_ISSUE_CMDS_BIT, &amp;port-&gt;flags)) {
 			slot = 1;
 			/* used to restrict the loop to one iteration */
<span class="p_chunk">@@ -2978,10 +3052,8 @@</span> <span class="p_context"> restart_eh:</span>
 		}
 
 		if (test_bit(MTIP_PF_REBUILD_BIT, &amp;port-&gt;flags)) {
<span class="p_del">-			if (mtip_ftl_rebuild_poll(dd) &lt; 0)</span>
<span class="p_del">-				set_bit(MTIP_DDF_REBUILD_FAILED_BIT,</span>
<span class="p_del">-							&amp;dd-&gt;dd_flag);</span>
<span class="p_del">-			clear_bit(MTIP_PF_REBUILD_BIT, &amp;port-&gt;flags);</span>
<span class="p_add">+			if (mtip_ftl_rebuild_poll(dd) == 0)</span>
<span class="p_add">+				clear_bit(MTIP_PF_REBUILD_BIT, &amp;port-&gt;flags);</span>
 		}
 	}
 
<span class="p_chunk">@@ -3096,7 +3168,7 @@</span> <span class="p_context"> static int mtip_hw_get_identify(struct driver_data *dd)</span>
 		if (buf[288] == 0xBF) {
 			dev_info(&amp;dd-&gt;pdev-&gt;dev,
 				&quot;Drive indicates rebuild has failed.\n&quot;);
<span class="p_del">-			/* TODO */</span>
<span class="p_add">+			set_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;dd-&gt;dd_flag);</span>
 		}
 	}
 
<span class="p_chunk">@@ -3270,20 +3342,25 @@</span> <span class="p_context"> out1:</span>
 	return rv;
 }
 
<span class="p_del">-static void mtip_standby_drive(struct driver_data *dd)</span>
<span class="p_add">+static int mtip_standby_drive(struct driver_data *dd)</span>
 {
<span class="p_del">-	if (dd-&gt;sr)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	int rv = 0;</span>
 
<span class="p_add">+	if (dd-&gt;sr || !dd-&gt;port)</span>
<span class="p_add">+		return -ENODEV;</span>
 	/*
 	 * Send standby immediate (E0h) to the drive so that it
 	 * saves its state.
 	 */
 	if (!test_bit(MTIP_PF_REBUILD_BIT, &amp;dd-&gt;port-&gt;flags) &amp;&amp;
<span class="p_del">-	    !test_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;dd-&gt;dd_flag))</span>
<span class="p_del">-		if (mtip_standby_immediate(dd-&gt;port))</span>
<span class="p_add">+	    !test_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;dd-&gt;dd_flag) &amp;&amp;</span>
<span class="p_add">+	    !test_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;dd-&gt;dd_flag)) {</span>
<span class="p_add">+		rv = mtip_standby_immediate(dd-&gt;port);</span>
<span class="p_add">+		if (rv)</span>
 			dev_warn(&amp;dd-&gt;pdev-&gt;dev,
 				&quot;STANDBY IMMEDIATE failed\n&quot;);
<span class="p_add">+	}</span>
<span class="p_add">+	return rv;</span>
 }
 
 /*
<span class="p_chunk">@@ -3296,10 +3373,6 @@</span> <span class="p_context"> static void mtip_standby_drive(struct driver_data *dd)</span>
  */
 static int mtip_hw_exit(struct driver_data *dd)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Send standby immediate (E0h) to the drive so that it</span>
<span class="p_del">-	 * saves its state.</span>
<span class="p_del">-	 */</span>
 	if (!dd-&gt;sr) {
 		/* de-initialize the port. */
 		mtip_deinit_port(dd-&gt;port);
<span class="p_chunk">@@ -3341,8 +3414,7 @@</span> <span class="p_context"> static int mtip_hw_shutdown(struct driver_data *dd)</span>
 	 * Send standby immediate (E0h) to the drive so that it
 	 * saves its state.
 	 */
<span class="p_del">-	if (!dd-&gt;sr &amp;&amp; dd-&gt;port)</span>
<span class="p_del">-		mtip_standby_immediate(dd-&gt;port);</span>
<span class="p_add">+	mtip_standby_drive(dd);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -3365,7 +3437,7 @@</span> <span class="p_context"> static int mtip_hw_suspend(struct driver_data *dd)</span>
 	 * Send standby immediate (E0h) to the drive
 	 * so that it saves its state.
 	 */
<span class="p_del">-	if (mtip_standby_immediate(dd-&gt;port) != 0) {</span>
<span class="p_add">+	if (mtip_standby_drive(dd) != 0) {</span>
 		dev_err(&amp;dd-&gt;pdev-&gt;dev,
 			&quot;Failed standby-immediate command\n&quot;);
 		return -EFAULT;
<span class="p_chunk">@@ -3603,6 +3675,28 @@</span> <span class="p_context"> static int mtip_block_getgeo(struct block_device *dev,</span>
 	return 0;
 }
 
<span class="p_add">+static int mtip_block_open(struct block_device *dev, fmode_t mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct driver_data *dd;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev &amp;&amp; dev-&gt;bd_disk) {</span>
<span class="p_add">+		dd = (struct driver_data *) dev-&gt;bd_disk-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dd) {</span>
<span class="p_add">+			if (test_bit(MTIP_DDF_REMOVAL_BIT,</span>
<span class="p_add">+							&amp;dd-&gt;dd_flag)) {</span>
<span class="p_add">+				return -ENODEV;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -ENODEV;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void mtip_block_release(struct gendisk *disk, fmode_t mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Block device operation function.
  *
<span class="p_chunk">@@ -3610,6 +3704,8 @@</span> <span class="p_context"> static int mtip_block_getgeo(struct block_device *dev,</span>
  * layer.
  */
 static const struct block_device_operations mtip_block_ops = {
<span class="p_add">+	.open		= mtip_block_open,</span>
<span class="p_add">+	.release	= mtip_block_release,</span>
 	.ioctl		= mtip_block_ioctl,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= mtip_block_compat_ioctl,
<span class="p_chunk">@@ -3671,10 +3767,9 @@</span> <span class="p_context"> static int mtip_submit_request(struct blk_mq_hw_ctx *hctx, struct request *rq)</span>
 				rq_data_dir(rq))) {
 			return -ENODATA;
 		}
<span class="p_del">-		if (unlikely(test_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;dd-&gt;dd_flag)))</span>
<span class="p_add">+		if (unlikely(test_bit(MTIP_DDF_SEC_LOCK_BIT, &amp;dd-&gt;dd_flag) ||</span>
<span class="p_add">+			test_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;dd-&gt;dd_flag)))</span>
 			return -ENODATA;
<span class="p_del">-		if (test_bit(MTIP_DDF_REBUILD_FAILED_BIT, &amp;dd-&gt;dd_flag))</span>
<span class="p_del">-			return -ENXIO;</span>
 	}
 
 	if (rq-&gt;cmd_flags &amp; REQ_DISCARD) {
<span class="p_chunk">@@ -3786,11 +3881,33 @@</span> <span class="p_context"> static int mtip_init_cmd(void *data, struct request *rq, unsigned int hctx_idx,</span>
 	return 0;
 }
 
<span class="p_add">+static enum blk_eh_timer_return mtip_cmd_timeout(struct request *req,</span>
<span class="p_add">+								bool reserved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct driver_data *dd = req-&gt;q-&gt;queuedata;</span>
<span class="p_add">+	int ret = BLK_EH_RESET_TIMER;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (reserved)</span>
<span class="p_add">+		goto exit_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_bit(req-&gt;tag, dd-&gt;port-&gt;cmds_to_issue))</span>
<span class="p_add">+		goto exit_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_and_set_bit(MTIP_PF_TO_ACTIVE_BIT, &amp;dd-&gt;port-&gt;flags))</span>
<span class="p_add">+		goto exit_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	wake_up_interruptible(&amp;dd-&gt;port-&gt;svc_wait);</span>
<span class="p_add">+exit_handler:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct blk_mq_ops mtip_mq_ops = {
 	.queue_rq	= mtip_queue_rq,
 	.map_queue	= blk_mq_map_queue,
 	.init_request	= mtip_init_cmd,
 	.exit_request	= mtip_free_cmd,
<span class="p_add">+	.complete	= mtip_softirq_done_fn,</span>
<span class="p_add">+	.timeout        = mtip_cmd_timeout,</span>
 };
 
 /*
<span class="p_chunk">@@ -3857,7 +3974,6 @@</span> <span class="p_context"> static int mtip_block_initialize(struct driver_data *dd)</span>
 
 	mtip_hw_debugfs_init(dd);
 
<span class="p_del">-skip_create_disk:</span>
 	memset(&amp;dd-&gt;tags, 0, sizeof(dd-&gt;tags));
 	dd-&gt;tags.ops = &amp;mtip_mq_ops;
 	dd-&gt;tags.nr_hw_queues = 1;
<span class="p_chunk">@@ -3867,12 +3983,13 @@</span> <span class="p_context"> skip_create_disk:</span>
 	dd-&gt;tags.numa_node = dd-&gt;numa_node;
 	dd-&gt;tags.flags = BLK_MQ_F_SHOULD_MERGE;
 	dd-&gt;tags.driver_data = dd;
<span class="p_add">+	dd-&gt;tags.timeout = MTIP_NCQ_CMD_TIMEOUT_MS;</span>
 
 	rv = blk_mq_alloc_tag_set(&amp;dd-&gt;tags);
 	if (rv) {
 		dev_err(&amp;dd-&gt;pdev-&gt;dev,
 			&quot;Unable to allocate request queue\n&quot;);
<span class="p_del">-		goto block_queue_alloc_init_error;</span>
<span class="p_add">+		goto block_queue_alloc_tag_error;</span>
 	}
 
 	/* Allocate the request queue. */
<span class="p_chunk">@@ -3887,6 +4004,7 @@</span> <span class="p_context"> skip_create_disk:</span>
 	dd-&gt;disk-&gt;queue		= dd-&gt;queue;
 	dd-&gt;queue-&gt;queuedata	= dd;
 
<span class="p_add">+skip_create_disk:</span>
 	/* Initialize the protocol layer. */
 	wait_for_rebuild = mtip_hw_get_identify(dd);
 	if (wait_for_rebuild &lt; 0) {
<span class="p_chunk">@@ -3983,8 +4101,9 @@</span> <span class="p_context"> kthread_run_error:</span>
 read_capacity_error:
 init_hw_cmds_error:
 	blk_cleanup_queue(dd-&gt;queue);
<span class="p_del">-	blk_mq_free_tag_set(&amp;dd-&gt;tags);</span>
 block_queue_alloc_init_error:
<span class="p_add">+	blk_mq_free_tag_set(&amp;dd-&gt;tags);</span>
<span class="p_add">+block_queue_alloc_tag_error:</span>
 	mtip_hw_debugfs_exit(dd);
 disk_index_error:
 	spin_lock(&amp;rssd_index_lock);
<span class="p_chunk">@@ -4001,6 +4120,22 @@</span> <span class="p_context"> protocol_init_error:</span>
 	return rv;
 }
 
<span class="p_add">+static void mtip_no_dev_cleanup(struct request *rq, void *data, bool reserv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct driver_data *dd = (struct driver_data *)data;</span>
<span class="p_add">+	struct mtip_cmd *cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(!reserv))</span>
<span class="p_add">+		blk_mq_complete_request(rq, -ENODEV);</span>
<span class="p_add">+	else if (test_bit(MTIP_PF_IC_ACTIVE_BIT, &amp;dd-&gt;port-&gt;flags)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		cmd = mtip_cmd_from_tag(dd, MTIP_TAG_INTERNAL);</span>
<span class="p_add">+		if (cmd-&gt;comp_func)</span>
<span class="p_add">+			cmd-&gt;comp_func(dd-&gt;port, MTIP_TAG_INTERNAL,</span>
<span class="p_add">+					cmd, -ENODEV);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Block layer deinitialization function.
  *
<span class="p_chunk">@@ -4032,12 +4167,23 @@</span> <span class="p_context"> static int mtip_block_remove(struct driver_data *dd)</span>
 		}
 	}
 
<span class="p_del">-	if (!dd-&gt;sr)</span>
<span class="p_del">-		mtip_standby_drive(dd);</span>
<span class="p_add">+	if (!dd-&gt;sr) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Explicitly wait here for IOs to quiesce,</span>
<span class="p_add">+		 * as mtip_standby_drive usually won&#39;t wait for IOs.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!mtip_quiesce_io(dd-&gt;port, MTIP_QUIESCE_IO_TIMEOUT_MS,</span>
<span class="p_add">+								GFP_KERNEL))</span>
<span class="p_add">+			mtip_standby_drive(dd);</span>
<span class="p_add">+	}</span>
 	else
 		dev_info(&amp;dd-&gt;pdev-&gt;dev, &quot;device %s surprise removal\n&quot;,
 						dd-&gt;disk-&gt;disk_name);
 
<span class="p_add">+	blk_mq_freeze_queue_start(dd-&gt;queue);</span>
<span class="p_add">+	blk_mq_stop_hw_queues(dd-&gt;queue);</span>
<span class="p_add">+	blk_mq_all_tag_busy_iter(dd-&gt;tags.tags[0], mtip_no_dev_cleanup, dd);</span>
<span class="p_add">+</span>
 	/*
 	 * Delete our gendisk structure. This also removes the device
 	 * from /dev
<span class="p_chunk">@@ -4047,7 +4193,8 @@</span> <span class="p_context"> static int mtip_block_remove(struct driver_data *dd)</span>
 		dd-&gt;bdev = NULL;
 	}
 	if (dd-&gt;disk) {
<span class="p_del">-		del_gendisk(dd-&gt;disk);</span>
<span class="p_add">+		if (test_bit(MTIP_DDF_INIT_DONE_BIT, &amp;dd-&gt;dd_flag))</span>
<span class="p_add">+			del_gendisk(dd-&gt;disk);</span>
 		if (dd-&gt;disk-&gt;queue) {
 			blk_cleanup_queue(dd-&gt;queue);
 			blk_mq_free_tag_set(&amp;dd-&gt;tags);
<span class="p_chunk">@@ -4088,7 +4235,8 @@</span> <span class="p_context"> static int mtip_block_shutdown(struct driver_data *dd)</span>
 		dev_info(&amp;dd-&gt;pdev-&gt;dev,
 			&quot;Shutting down %s ...\n&quot;, dd-&gt;disk-&gt;disk_name);
 
<span class="p_del">-		del_gendisk(dd-&gt;disk);</span>
<span class="p_add">+		if (test_bit(MTIP_DDF_INIT_DONE_BIT, &amp;dd-&gt;dd_flag))</span>
<span class="p_add">+			del_gendisk(dd-&gt;disk);</span>
 		if (dd-&gt;disk-&gt;queue) {
 			blk_cleanup_queue(dd-&gt;queue);
 			blk_mq_free_tag_set(&amp;dd-&gt;tags);
<span class="p_chunk">@@ -4433,7 +4581,7 @@</span> <span class="p_context"> static void mtip_pci_remove(struct pci_dev *pdev)</span>
 	struct driver_data *dd = pci_get_drvdata(pdev);
 	unsigned long flags, to;
 
<span class="p_del">-	set_bit(MTIP_DDF_REMOVE_PENDING_BIT, &amp;dd-&gt;dd_flag);</span>
<span class="p_add">+	set_bit(MTIP_DDF_REMOVAL_BIT, &amp;dd-&gt;dd_flag);</span>
 
 	spin_lock_irqsave(&amp;dev_lock, flags);
 	list_del_init(&amp;dd-&gt;online_list);
<span class="p_chunk">@@ -4450,12 +4598,17 @@</span> <span class="p_context"> static void mtip_pci_remove(struct pci_dev *pdev)</span>
 	} while (atomic_read(&amp;dd-&gt;irq_workers_active) != 0 &amp;&amp;
 		time_before(jiffies, to));
 
<span class="p_add">+	if (!dd-&gt;sr)</span>
<span class="p_add">+		fsync_bdev(dd-&gt;bdev);</span>
<span class="p_add">+</span>
 	if (atomic_read(&amp;dd-&gt;irq_workers_active) != 0) {
 		dev_warn(&amp;dd-&gt;pdev-&gt;dev,
 			&quot;Completion workers still active!\n&quot;);
 	}
 
<span class="p_del">-	blk_mq_stop_hw_queues(dd-&gt;queue);</span>
<span class="p_add">+	blk_set_queue_dying(dd-&gt;queue);</span>
<span class="p_add">+	set_bit(MTIP_DDF_REMOVE_PENDING_BIT, &amp;dd-&gt;dd_flag);</span>
<span class="p_add">+</span>
 	/* Clean up the block layer. */
 	mtip_block_remove(dd);
 
<span class="p_header">diff --git a/drivers/block/mtip32xx/mtip32xx.h b/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_header">index 3274784008eb..7617888f7944 100644</span>
<span class="p_header">--- a/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_header">+++ b/drivers/block/mtip32xx/mtip32xx.h</span>
<span class="p_chunk">@@ -134,16 +134,24 @@</span> <span class="p_context"> enum {</span>
 	MTIP_PF_EH_ACTIVE_BIT       = 1, /* error handling */
 	MTIP_PF_SE_ACTIVE_BIT       = 2, /* secure erase */
 	MTIP_PF_DM_ACTIVE_BIT       = 3, /* download microcde */
<span class="p_add">+	MTIP_PF_TO_ACTIVE_BIT       = 9, /* timeout handling */</span>
 	MTIP_PF_PAUSE_IO      =	((1 &lt;&lt; MTIP_PF_IC_ACTIVE_BIT) |
 				(1 &lt;&lt; MTIP_PF_EH_ACTIVE_BIT) |
 				(1 &lt;&lt; MTIP_PF_SE_ACTIVE_BIT) |
<span class="p_del">-				(1 &lt;&lt; MTIP_PF_DM_ACTIVE_BIT)),</span>
<span class="p_add">+				(1 &lt;&lt; MTIP_PF_DM_ACTIVE_BIT) |</span>
<span class="p_add">+				(1 &lt;&lt; MTIP_PF_TO_ACTIVE_BIT)),</span>
 
 	MTIP_PF_SVC_THD_ACTIVE_BIT  = 4,
 	MTIP_PF_ISSUE_CMDS_BIT      = 5,
 	MTIP_PF_REBUILD_BIT         = 6,
 	MTIP_PF_SVC_THD_STOP_BIT    = 8,
 
<span class="p_add">+	MTIP_PF_SVC_THD_WORK	= ((1 &lt;&lt; MTIP_PF_EH_ACTIVE_BIT) |</span>
<span class="p_add">+				  (1 &lt;&lt; MTIP_PF_ISSUE_CMDS_BIT) |</span>
<span class="p_add">+				  (1 &lt;&lt; MTIP_PF_REBUILD_BIT) |</span>
<span class="p_add">+				  (1 &lt;&lt; MTIP_PF_SVC_THD_STOP_BIT) |</span>
<span class="p_add">+				  (1 &lt;&lt; MTIP_PF_TO_ACTIVE_BIT)),</span>
<span class="p_add">+</span>
 	/* below are bit numbers in &#39;dd_flag&#39; defined in driver_data */
 	MTIP_DDF_SEC_LOCK_BIT	    = 0,
 	MTIP_DDF_REMOVE_PENDING_BIT = 1,
<span class="p_chunk">@@ -153,6 +161,7 @@</span> <span class="p_context"> enum {</span>
 	MTIP_DDF_RESUME_BIT         = 6,
 	MTIP_DDF_INIT_DONE_BIT      = 7,
 	MTIP_DDF_REBUILD_FAILED_BIT = 8,
<span class="p_add">+	MTIP_DDF_REMOVAL_BIT	    = 9,</span>
 
 	MTIP_DDF_STOP_IO      = ((1 &lt;&lt; MTIP_DDF_REMOVE_PENDING_BIT) |
 				(1 &lt;&lt; MTIP_DDF_SEC_LOCK_BIT) |
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index fa893c3ec408..0beaa52df66b 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -82,6 +82,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe05f) },
 	{ USB_DEVICE(0x0489, 0xe076) },
 	{ USB_DEVICE(0x0489, 0xe078) },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe095) },</span>
 	{ USB_DEVICE(0x04c5, 0x1330) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
 	{ USB_DEVICE(0x04CA, 0x3005) },
<span class="p_chunk">@@ -92,6 +93,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x04CA, 0x300d) },
 	{ USB_DEVICE(0x04CA, 0x300f) },
 	{ USB_DEVICE(0x04CA, 0x3010) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x3014) },</span>
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x021c) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -113,10 +115,12 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3362) },
 	{ USB_DEVICE(0x13d3, 0x3375) },
 	{ USB_DEVICE(0x13d3, 0x3393) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3395) },</span>
 	{ USB_DEVICE(0x13d3, 0x3402) },
 	{ USB_DEVICE(0x13d3, 0x3408) },
 	{ USB_DEVICE(0x13d3, 0x3423) },
 	{ USB_DEVICE(0x13d3, 0x3432) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3472) },</span>
 	{ USB_DEVICE(0x13d3, 0x3474) },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_chunk">@@ -144,6 +148,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe095), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -154,6 +159,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -175,10 +181,12 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3395), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU22 with sflash firmware */
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 968897108c76..79107597a594 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -196,6 +196,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe095), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -206,6 +207,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -227,10 +229,12 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3395), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_header">diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">index 45cc39aabeee..252142524ff2 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_chunk">@@ -136,11 +136,13 @@</span> <span class="p_context"> struct tpm_chip *tpmm_chip_alloc(struct device *dev,</span>
 	chip-&gt;cdev.owner = chip-&gt;pdev-&gt;driver-&gt;owner;
 	chip-&gt;cdev.kobj.parent = &amp;chip-&gt;dev.kobj;
 
<span class="p_add">+	devm_add_action(dev, (void (*)(void *)) put_device, &amp;chip-&gt;dev);</span>
<span class="p_add">+</span>
 	return chip;
 }
 EXPORT_SYMBOL_GPL(tpmm_chip_alloc);
 
<span class="p_del">-static int tpm_dev_add_device(struct tpm_chip *chip)</span>
<span class="p_add">+static int tpm_add_char_device(struct tpm_chip *chip)</span>
 {
 	int rc;
 
<span class="p_chunk">@@ -151,7 +153,6 @@</span> <span class="p_context"> static int tpm_dev_add_device(struct tpm_chip *chip)</span>
 			chip-&gt;devname, MAJOR(chip-&gt;dev.devt),
 			MINOR(chip-&gt;dev.devt), rc);
 
<span class="p_del">-		device_unregister(&amp;chip-&gt;dev);</span>
 		return rc;
 	}
 
<span class="p_chunk">@@ -162,16 +163,17 @@</span> <span class="p_context"> static int tpm_dev_add_device(struct tpm_chip *chip)</span>
 			chip-&gt;devname, MAJOR(chip-&gt;dev.devt),
 			MINOR(chip-&gt;dev.devt), rc);
 
<span class="p_add">+		cdev_del(&amp;chip-&gt;cdev);</span>
 		return rc;
 	}
 
 	return rc;
 }
 
<span class="p_del">-static void tpm_dev_del_device(struct tpm_chip *chip)</span>
<span class="p_add">+static void tpm_del_char_device(struct tpm_chip *chip)</span>
 {
 	cdev_del(&amp;chip-&gt;cdev);
<span class="p_del">-	device_unregister(&amp;chip-&gt;dev);</span>
<span class="p_add">+	device_del(&amp;chip-&gt;dev);</span>
 }
 
 static int tpm1_chip_register(struct tpm_chip *chip)
<span class="p_chunk">@@ -222,7 +224,7 @@</span> <span class="p_context"> int tpm_chip_register(struct tpm_chip *chip)</span>
 
 	tpm_add_ppi(chip);
 
<span class="p_del">-	rc = tpm_dev_add_device(chip);</span>
<span class="p_add">+	rc = tpm_add_char_device(chip);</span>
 	if (rc)
 		goto out_err;
 
<span class="p_chunk">@@ -274,6 +276,6 @@</span> <span class="p_context"> void tpm_chip_unregister(struct tpm_chip *chip)</span>
 		sysfs_remove_link(&amp;chip-&gt;pdev-&gt;kobj, &quot;ppi&quot;);
 
 	tpm1_chip_unregister(chip);
<span class="p_del">-	tpm_dev_del_device(chip);</span>
<span class="p_add">+	tpm_del_char_device(chip);</span>
 }
 EXPORT_SYMBOL_GPL(tpm_chip_unregister);
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index 4bb9727c1047..61e64293b765 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -310,11 +310,11 @@</span> <span class="p_context"> static int crb_acpi_remove(struct acpi_device *device)</span>
 	struct device *dev = &amp;device-&gt;dev;
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 
<span class="p_del">-	tpm_chip_unregister(chip);</span>
<span class="p_del">-</span>
 	if (chip-&gt;flags &amp; TPM_CHIP_FLAG_TPM2)
 		tpm2_shutdown(chip, TPM2_SU_CLEAR);
 
<span class="p_add">+	tpm_chip_unregister(chip);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/char/tpm/tpm_eventlog.c b/drivers/char/tpm/tpm_eventlog.c</span>
<span class="p_header">index bd72fb04225e..4e6940acf639 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_eventlog.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_eventlog.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static int tpm_binary_bios_measurements_show(struct seq_file *m, void *v)</span>
 {
 	struct tcpa_event *event = v;
 	struct tcpa_event temp_event;
<span class="p_del">-	char *tempPtr;</span>
<span class="p_add">+	char *temp_ptr;</span>
 	int i;
 
 	memcpy(&amp;temp_event, event, sizeof(struct tcpa_event));
<span class="p_chunk">@@ -242,10 +242,16 @@</span> <span class="p_context"> static int tpm_binary_bios_measurements_show(struct seq_file *m, void *v)</span>
 	temp_event.event_type = do_endian_conversion(event-&gt;event_type);
 	temp_event.event_size = do_endian_conversion(event-&gt;event_size);
 
<span class="p_del">-	tempPtr = (char *)&amp;temp_event;</span>
<span class="p_add">+	temp_ptr = (char *) &amp;temp_event;</span>
 
<span class="p_del">-	for (i = 0; i &lt; sizeof(struct tcpa_event) + temp_event.event_size; i++)</span>
<span class="p_del">-		seq_putc(m, tempPtr[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; (sizeof(struct tcpa_event) - 1) ; i++)</span>
<span class="p_add">+		seq_putc(m, temp_ptr[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+	temp_ptr = (char *) v;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = (sizeof(struct tcpa_event) - 1);</span>
<span class="p_add">+	     i &lt; (sizeof(struct tcpa_event) + temp_event.event_size); i++)</span>
<span class="p_add">+		seq_putc(m, temp_ptr[i]);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/drivers/clk/bcm/clk-bcm2835.c b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">index 39bf5820297e..4f9830c1b121 100644</span>
<span class="p_header">--- a/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">+++ b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_chunk">@@ -1097,13 +1097,15 @@</span> <span class="p_context"> static int bcm2835_pll_divider_set_rate(struct clk_hw *hw,</span>
 	struct bcm2835_pll_divider *divider = bcm2835_pll_divider_from_hw(hw);
 	struct bcm2835_cprman *cprman = divider-&gt;cprman;
 	const struct bcm2835_pll_divider_data *data = divider-&gt;data;
<span class="p_del">-	u32 cm;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	u32 cm, div, max_div = 1 &lt;&lt; A2W_PLL_DIV_BITS;</span>
 
<span class="p_del">-	ret = clk_divider_ops.set_rate(hw, rate, parent_rate);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	div = DIV_ROUND_UP_ULL(parent_rate, rate);</span>
<span class="p_add">+</span>
<span class="p_add">+	div = min(div, max_div);</span>
<span class="p_add">+	if (div == max_div)</span>
<span class="p_add">+		div = 0;</span>
 
<span class="p_add">+	cprman_write(cprman, data-&gt;a2w_reg, div);</span>
 	cm = cprman_read(cprman, data-&gt;cm_reg);
 	cprman_write(cprman, data-&gt;cm_reg, cm | data-&gt;load_mask);
 	cprman_write(cprman, data-&gt;cm_reg, cm &amp; ~data-&gt;load_mask);
<span class="p_header">diff --git a/drivers/clk/rockchip/clk-rk3188.c b/drivers/clk/rockchip/clk-rk3188.c</span>
<span class="p_header">index abb47608713b..fe728f8dcbe4 100644</span>
<span class="p_header">--- a/drivers/clk/rockchip/clk-rk3188.c</span>
<span class="p_header">+++ b/drivers/clk/rockchip/clk-rk3188.c</span>
<span class="p_chunk">@@ -718,6 +718,7 @@</span> <span class="p_context"> static const char *const rk3188_critical_clocks[] __initconst = {</span>
 	&quot;hclk_peri&quot;,
 	&quot;pclk_cpu&quot;,
 	&quot;pclk_peri&quot;,
<span class="p_add">+	&quot;hclk_cpubus&quot;</span>
 };
 
 static void __init rk3188_common_clk_init(struct device_node *np)
<span class="p_header">diff --git a/drivers/clk/rockchip/clk-rk3368.c b/drivers/clk/rockchip/clk-rk3368.c</span>
<span class="p_header">index 7e6b783e6eee..1b148694b633 100644</span>
<span class="p_header">--- a/drivers/clk/rockchip/clk-rk3368.c</span>
<span class="p_header">+++ b/drivers/clk/rockchip/clk-rk3368.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static const struct rockchip_cpuclk_reg_data rk3368_cpuclkb_data = {</span>
 	.core_reg = RK3368_CLKSEL_CON(0),
 	.div_core_shift = 0,
 	.div_core_mask = 0x1f,
<span class="p_del">-	.mux_core_shift = 15,</span>
<span class="p_add">+	.mux_core_shift = 7,</span>
 };
 
 static const struct rockchip_cpuclk_reg_data rk3368_cpuclkl_data = {
<span class="p_chunk">@@ -218,29 +218,29 @@</span> <span class="p_context"> static const struct rockchip_cpuclk_reg_data rk3368_cpuclkl_data = {</span>
 	}
 
 static struct rockchip_cpuclk_rate_table rk3368_cpuclkb_rates[] __initdata = {
<span class="p_del">-	RK3368_CPUCLKB_RATE(1512000000, 2, 6, 6),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE(1488000000, 2, 5, 5),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE(1416000000, 2, 5, 5),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE(1200000000, 2, 4, 4),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE(1008000000, 2, 4, 4),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE( 816000000, 2, 3, 3),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE( 696000000, 2, 3, 3),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE( 600000000, 2, 2, 2),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE( 408000000, 2, 2, 2),</span>
<span class="p_del">-	RK3368_CPUCLKB_RATE( 312000000, 2, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE(1512000000, 1, 5, 5),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE(1488000000, 1, 4, 4),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE(1416000000, 1, 4, 4),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE(1200000000, 1, 3, 3),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE(1008000000, 1, 3, 3),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE( 816000000, 1, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE( 696000000, 1, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE( 600000000, 1, 1, 1),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE( 408000000, 1, 1, 1),</span>
<span class="p_add">+	RK3368_CPUCLKB_RATE( 312000000, 1, 1, 1),</span>
 };
 
 static struct rockchip_cpuclk_rate_table rk3368_cpuclkl_rates[] __initdata = {
<span class="p_del">-	RK3368_CPUCLKL_RATE(1512000000, 2, 7, 7),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE(1488000000, 2, 6, 6),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE(1416000000, 2, 6, 6),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE(1200000000, 2, 5, 5),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE(1008000000, 2, 5, 5),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE( 816000000, 2, 4, 4),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE( 696000000, 2, 3, 3),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE( 600000000, 2, 3, 3),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE( 408000000, 2, 2, 2),</span>
<span class="p_del">-	RK3368_CPUCLKL_RATE( 312000000, 2, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE(1512000000, 1, 6, 6),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE(1488000000, 1, 5, 5),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE(1416000000, 1, 5, 5),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE(1200000000, 1, 4, 4),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE(1008000000, 1, 4, 4),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE( 816000000, 1, 3, 3),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE( 696000000, 1, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE( 600000000, 1, 2, 2),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE( 408000000, 1, 1, 1),</span>
<span class="p_add">+	RK3368_CPUCLKL_RATE( 312000000, 1, 1, 1),</span>
 };
 
 static struct rockchip_clk_branch rk3368_clk_branches[] __initdata = {
<span class="p_chunk">@@ -384,10 +384,10 @@</span> <span class="p_context"> static struct rockchip_clk_branch rk3368_clk_branches[] __initdata = {</span>
 	 * Clock-Architecture Diagram 3
 	 */
 
<span class="p_del">-	COMPOSITE(0, &quot;aclk_vepu&quot;, mux_pll_src_cpll_gpll_usb_p, 0,</span>
<span class="p_add">+	COMPOSITE(0, &quot;aclk_vepu&quot;, mux_pll_src_cpll_gpll_npll_usb_p, 0,</span>
 			RK3368_CLKSEL_CON(15), 6, 2, MFLAGS, 0, 5, DFLAGS,
 			RK3368_CLKGATE_CON(4), 6, GFLAGS),
<span class="p_del">-	COMPOSITE(0, &quot;aclk_vdpu&quot;, mux_pll_src_cpll_gpll_usb_p, 0,</span>
<span class="p_add">+	COMPOSITE(0, &quot;aclk_vdpu&quot;, mux_pll_src_cpll_gpll_npll_usb_p, 0,</span>
 			RK3368_CLKSEL_CON(15), 14, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3368_CLKGATE_CON(4), 7, GFLAGS),
 
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> static struct rockchip_clk_branch rk3368_clk_branches[] __initdata = {</span>
 	GATE(SCLK_HDMI_HDCP, &quot;sclk_hdmi_hdcp&quot;, &quot;xin24m&quot;, 0,
 			RK3368_CLKGATE_CON(4), 13, GFLAGS),
 	GATE(SCLK_HDMI_CEC, &quot;sclk_hdmi_cec&quot;, &quot;xin32k&quot;, 0,
<span class="p_del">-			RK3368_CLKGATE_CON(5), 12, GFLAGS),</span>
<span class="p_add">+			RK3368_CLKGATE_CON(4), 12, GFLAGS),</span>
 
 	COMPOSITE_NODIV(0, &quot;vip_src&quot;, mux_pll_src_cpll_gpll_p, 0,
 			RK3368_CLKSEL_CON(21), 15, 1, MFLAGS,
<span class="p_header">diff --git a/drivers/crypto/atmel-aes.c b/drivers/crypto/atmel-aes.c</span>
<span class="p_header">index fb16d812c8f5..1dffb13e5c2f 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-aes.c</span>
<span class="p_chunk">@@ -1396,9 +1396,9 @@</span> <span class="p_context"> static int atmel_aes_probe(struct platform_device *pdev)</span>
 	}
 
 	aes_dd-&gt;io_base = devm_ioremap_resource(&amp;pdev-&gt;dev, aes_res);
<span class="p_del">-	if (!aes_dd-&gt;io_base) {</span>
<span class="p_add">+	if (IS_ERR(aes_dd-&gt;io_base)) {</span>
 		dev_err(dev, &quot;can&#39;t ioremap\n&quot;);
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+		err = PTR_ERR(aes_dd-&gt;io_base);</span>
 		goto res_err;
 	}
 
<span class="p_header">diff --git a/drivers/crypto/atmel-sha.c b/drivers/crypto/atmel-sha.c</span>
<span class="p_header">index 3178f84d2757..0dadb6332f0e 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-sha.c</span>
<span class="p_chunk">@@ -1405,9 +1405,9 @@</span> <span class="p_context"> static int atmel_sha_probe(struct platform_device *pdev)</span>
 	}
 
 	sha_dd-&gt;io_base = devm_ioremap_resource(&amp;pdev-&gt;dev, sha_res);
<span class="p_del">-	if (!sha_dd-&gt;io_base) {</span>
<span class="p_add">+	if (IS_ERR(sha_dd-&gt;io_base)) {</span>
 		dev_err(dev, &quot;can&#39;t ioremap\n&quot;);
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+		err = PTR_ERR(sha_dd-&gt;io_base);</span>
 		goto res_err;
 	}
 
<span class="p_header">diff --git a/drivers/crypto/atmel-tdes.c b/drivers/crypto/atmel-tdes.c</span>
<span class="p_header">index 2c7a628d0375..bf467d7be35c 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-tdes.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-tdes.c</span>
<span class="p_chunk">@@ -1417,9 +1417,9 @@</span> <span class="p_context"> static int atmel_tdes_probe(struct platform_device *pdev)</span>
 	}
 
 	tdes_dd-&gt;io_base = devm_ioremap_resource(&amp;pdev-&gt;dev, tdes_res);
<span class="p_del">-	if (!tdes_dd-&gt;io_base) {</span>
<span class="p_add">+	if (IS_ERR(tdes_dd-&gt;io_base)) {</span>
 		dev_err(dev, &quot;can&#39;t ioremap\n&quot;);
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_add">+		err = PTR_ERR(tdes_dd-&gt;io_base);</span>
 		goto res_err;
 	}
 
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">index d89f20c04266..3d9acc53d247 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-cmac.c</span>
<span class="p_chunk">@@ -220,6 +220,39 @@</span> <span class="p_context"> static int ccp_aes_cmac_digest(struct ahash_request *req)</span>
 	return ccp_aes_cmac_finup(req);
 }
 
<span class="p_add">+static int ccp_aes_cmac_export(struct ahash_request *req, void *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct ccp_aes_cmac_exp_ctx state;</span>
<span class="p_add">+</span>
<span class="p_add">+	state.null_msg = rctx-&gt;null_msg;</span>
<span class="p_add">+	memcpy(state.iv, rctx-&gt;iv, sizeof(state.iv));</span>
<span class="p_add">+	state.buf_count = rctx-&gt;buf_count;</span>
<span class="p_add">+	memcpy(state.buf, rctx-&gt;buf, sizeof(state.buf));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* &#39;out&#39; may not be aligned so memcpy from local variable */</span>
<span class="p_add">+	memcpy(out, &amp;state, sizeof(state));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ccp_aes_cmac_import(struct ahash_request *req, const void *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ccp_aes_cmac_req_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct ccp_aes_cmac_exp_ctx state;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* &#39;in&#39; may not be aligned so memcpy to local variable */</span>
<span class="p_add">+	memcpy(&amp;state, in, sizeof(state));</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(rctx, 0, sizeof(*rctx));</span>
<span class="p_add">+	rctx-&gt;null_msg = state.null_msg;</span>
<span class="p_add">+	memcpy(rctx-&gt;iv, state.iv, sizeof(rctx-&gt;iv));</span>
<span class="p_add">+	rctx-&gt;buf_count = state.buf_count;</span>
<span class="p_add">+	memcpy(rctx-&gt;buf, state.buf, sizeof(rctx-&gt;buf));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ccp_aes_cmac_setkey(struct crypto_ahash *tfm, const u8 *key,
 			       unsigned int key_len)
 {
<span class="p_chunk">@@ -352,10 +385,13 @@</span> <span class="p_context"> int ccp_register_aes_cmac_algs(struct list_head *head)</span>
 	alg-&gt;final = ccp_aes_cmac_final;
 	alg-&gt;finup = ccp_aes_cmac_finup;
 	alg-&gt;digest = ccp_aes_cmac_digest;
<span class="p_add">+	alg-&gt;export = ccp_aes_cmac_export;</span>
<span class="p_add">+	alg-&gt;import = ccp_aes_cmac_import;</span>
 	alg-&gt;setkey = ccp_aes_cmac_setkey;
 
 	halg = &amp;alg-&gt;halg;
 	halg-&gt;digestsize = AES_BLOCK_SIZE;
<span class="p_add">+	halg-&gt;statesize = sizeof(struct ccp_aes_cmac_exp_ctx);</span>
 
 	base = &amp;halg-&gt;base;
 	snprintf(base-&gt;cra_name, CRYPTO_MAX_ALG_NAME, &quot;cmac(aes)&quot;);
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-sha.c b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">index d14b3f28e010..8ef06fad8b14 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-sha.c</span>
<span class="p_chunk">@@ -207,6 +207,43 @@</span> <span class="p_context"> static int ccp_sha_digest(struct ahash_request *req)</span>
 	return ccp_sha_finup(req);
 }
 
<span class="p_add">+static int ccp_sha_export(struct ahash_request *req, void *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ccp_sha_req_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct ccp_sha_exp_ctx state;</span>
<span class="p_add">+</span>
<span class="p_add">+	state.type = rctx-&gt;type;</span>
<span class="p_add">+	state.msg_bits = rctx-&gt;msg_bits;</span>
<span class="p_add">+	state.first = rctx-&gt;first;</span>
<span class="p_add">+	memcpy(state.ctx, rctx-&gt;ctx, sizeof(state.ctx));</span>
<span class="p_add">+	state.buf_count = rctx-&gt;buf_count;</span>
<span class="p_add">+	memcpy(state.buf, rctx-&gt;buf, sizeof(state.buf));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* &#39;out&#39; may not be aligned so memcpy from local variable */</span>
<span class="p_add">+	memcpy(out, &amp;state, sizeof(state));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ccp_sha_import(struct ahash_request *req, const void *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ccp_sha_req_ctx *rctx = ahash_request_ctx(req);</span>
<span class="p_add">+	struct ccp_sha_exp_ctx state;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* &#39;in&#39; may not be aligned so memcpy to local variable */</span>
<span class="p_add">+	memcpy(&amp;state, in, sizeof(state));</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(rctx, 0, sizeof(*rctx));</span>
<span class="p_add">+	rctx-&gt;type = state.type;</span>
<span class="p_add">+	rctx-&gt;msg_bits = state.msg_bits;</span>
<span class="p_add">+	rctx-&gt;first = state.first;</span>
<span class="p_add">+	memcpy(rctx-&gt;ctx, state.ctx, sizeof(rctx-&gt;ctx));</span>
<span class="p_add">+	rctx-&gt;buf_count = state.buf_count;</span>
<span class="p_add">+	memcpy(rctx-&gt;buf, state.buf, sizeof(rctx-&gt;buf));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ccp_sha_setkey(struct crypto_ahash *tfm, const u8 *key,
 			  unsigned int key_len)
 {
<span class="p_chunk">@@ -403,9 +440,12 @@</span> <span class="p_context"> static int ccp_register_sha_alg(struct list_head *head,</span>
 	alg-&gt;final = ccp_sha_final;
 	alg-&gt;finup = ccp_sha_finup;
 	alg-&gt;digest = ccp_sha_digest;
<span class="p_add">+	alg-&gt;export = ccp_sha_export;</span>
<span class="p_add">+	alg-&gt;import = ccp_sha_import;</span>
 
 	halg = &amp;alg-&gt;halg;
 	halg-&gt;digestsize = def-&gt;digest_size;
<span class="p_add">+	halg-&gt;statesize = sizeof(struct ccp_sha_exp_ctx);</span>
 
 	base = &amp;halg-&gt;base;
 	snprintf(base-&gt;cra_name, CRYPTO_MAX_ALG_NAME, &quot;%s&quot;, def-&gt;name);
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto.h b/drivers/crypto/ccp/ccp-crypto.h</span>
<span class="p_header">index 76a96f0f44c6..a326ec20bfa8 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto.h</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto.h</span>
<span class="p_chunk">@@ -129,6 +129,15 @@</span> <span class="p_context"> struct ccp_aes_cmac_req_ctx {</span>
 	struct ccp_cmd cmd;
 };
 
<span class="p_add">+struct ccp_aes_cmac_exp_ctx {</span>
<span class="p_add">+	unsigned int null_msg;</span>
<span class="p_add">+</span>
<span class="p_add">+	u8 iv[AES_BLOCK_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned int buf_count;</span>
<span class="p_add">+	u8 buf[AES_BLOCK_SIZE];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /***** SHA related defines *****/
 #define MAX_SHA_CONTEXT_SIZE	SHA256_DIGEST_SIZE
 #define MAX_SHA_BLOCK_SIZE	SHA256_BLOCK_SIZE
<span class="p_chunk">@@ -171,6 +180,19 @@</span> <span class="p_context"> struct ccp_sha_req_ctx {</span>
 	struct ccp_cmd cmd;
 };
 
<span class="p_add">+struct ccp_sha_exp_ctx {</span>
<span class="p_add">+	enum ccp_sha_type type;</span>
<span class="p_add">+</span>
<span class="p_add">+	u64 msg_bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned int first;</span>
<span class="p_add">+</span>
<span class="p_add">+	u8 ctx[MAX_SHA_CONTEXT_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned int buf_count;</span>
<span class="p_add">+	u8 buf[MAX_SHA_BLOCK_SIZE];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /***** Common Context Structure *****/
 struct ccp_ctx {
 	int (*complete)(struct crypto_async_request *req, int ret);
<span class="p_header">diff --git a/drivers/crypto/marvell/cesa.c b/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">index c0656e7f37b5..80239ae69527 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/cesa.c</span>
<span class="p_chunk">@@ -420,7 +420,7 @@</span> <span class="p_context"> static int mv_cesa_probe(struct platform_device *pdev)</span>
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, &quot;regs&quot;);
 	cesa-&gt;regs = devm_ioremap_resource(dev, res);
 	if (IS_ERR(cesa-&gt;regs))
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		return PTR_ERR(cesa-&gt;regs);</span>
 
 	ret = mv_cesa_dev_dma_init(cesa);
 	if (ret)
<span class="p_header">diff --git a/drivers/crypto/ux500/cryp/cryp_core.c b/drivers/crypto/ux500/cryp/cryp_core.c</span>
<span class="p_header">index 4c243c1ffc7f..790f7cadc1ed 100644</span>
<span class="p_header">--- a/drivers/crypto/ux500/cryp/cryp_core.c</span>
<span class="p_header">+++ b/drivers/crypto/ux500/cryp/cryp_core.c</span>
<span class="p_chunk">@@ -1440,9 +1440,9 @@</span> <span class="p_context"> static int ux500_cryp_probe(struct platform_device *pdev)</span>
 
 	device_data-&gt;phybase = res-&gt;start;
 	device_data-&gt;base = devm_ioremap_resource(dev, res);
<span class="p_del">-	if (!device_data-&gt;base) {</span>
<span class="p_add">+	if (IS_ERR(device_data-&gt;base)) {</span>
 		dev_err(dev, &quot;[%s]: ioremap failed!&quot;, __func__);
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+		ret = PTR_ERR(device_data-&gt;base);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/drivers/crypto/ux500/hash/hash_core.c b/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_header">index f47d112041b2..66b1c3313e2e 100644</span>
<span class="p_header">--- a/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_header">+++ b/drivers/crypto/ux500/hash/hash_core.c</span>
<span class="p_chunk">@@ -1675,9 +1675,9 @@</span> <span class="p_context"> static int ux500_hash_probe(struct platform_device *pdev)</span>
 
 	device_data-&gt;phybase = res-&gt;start;
 	device_data-&gt;base = devm_ioremap_resource(dev, res);
<span class="p_del">-	if (!device_data-&gt;base) {</span>
<span class="p_add">+	if (IS_ERR(device_data-&gt;base)) {</span>
 		dev_err(dev, &quot;%s: ioremap() failed!\n&quot;, __func__);
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_add">+		ret = PTR_ERR(device_data-&gt;base);</span>
 		goto out;
 	}
 	spin_lock_init(&amp;device_data-&gt;ctx_lock);
<span class="p_header">diff --git a/drivers/edac/amd64_edac.c b/drivers/edac/amd64_edac.c</span>
<span class="p_header">index 9eee13ef83a5..d87a47547ba5 100644</span>
<span class="p_header">--- a/drivers/edac/amd64_edac.c</span>
<span class="p_header">+++ b/drivers/edac/amd64_edac.c</span>
<span class="p_chunk">@@ -1452,7 +1452,7 @@</span> <span class="p_context"> static u64 f1x_get_norm_dct_addr(struct amd64_pvt *pvt, u8 range,</span>
 	u64 chan_off;
 	u64 dram_base		= get_dram_base(pvt, range);
 	u64 hole_off		= f10_dhar_offset(pvt);
<span class="p_del">-	u64 dct_sel_base_off	= (pvt-&gt;dct_sel_hi &amp; 0xFFFFFC00) &lt;&lt; 16;</span>
<span class="p_add">+	u64 dct_sel_base_off	= (u64)(pvt-&gt;dct_sel_hi &amp; 0xFFFFFC00) &lt;&lt; 16;</span>
 
 	if (hi_rng) {
 		/*
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 429309c62699..cbee3179ec08 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -1117,8 +1117,8 @@</span> <span class="p_context"> static void get_memory_layout(const struct mem_ctl_info *mci)</span>
 		edac_dbg(0, &quot;TAD#%d: up to %u.%03u GB (0x%016Lx), socket interleave %d, memory interleave %d, TGT: %d, %d, %d, %d, reg=0x%08x\n&quot;,
 			 n_tads, gb, (mb*1000)/1024,
 			 ((u64)tmp_mb) &lt;&lt; 20L,
<span class="p_del">-			 (u32)TAD_SOCK(reg),</span>
<span class="p_del">-			 (u32)TAD_CH(reg),</span>
<span class="p_add">+			 (u32)(1 &lt;&lt; TAD_SOCK(reg)),</span>
<span class="p_add">+			 (u32)TAD_CH(reg) + 1,</span>
 			 (u32)TAD_TGT0(reg),
 			 (u32)TAD_TGT1(reg),
 			 (u32)TAD_TGT2(reg),
<span class="p_chunk">@@ -1396,7 +1396,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 	}
 
 	ch_way = TAD_CH(reg) + 1;
<span class="p_del">-	sck_way = TAD_SOCK(reg) + 1;</span>
<span class="p_add">+	sck_way = 1 &lt;&lt; TAD_SOCK(reg);</span>
 
 	if (ch_way == 3)
 		idx = addr &gt;&gt; 6;
<span class="p_chunk">@@ -1453,7 +1453,7 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 		 n_tads,
 		 addr,
 		 limit,
<span class="p_del">-		 (u32)TAD_SOCK(reg),</span>
<span class="p_add">+		 sck_way,</span>
 		 ch_way,
 		 offset,
 		 idx,
<span class="p_chunk">@@ -1468,18 +1468,12 @@</span> <span class="p_context"> static int get_memory_error_data(struct mem_ctl_info *mci,</span>
 			offset, addr);
 		return -EINVAL;
 	}
<span class="p_del">-	addr -= offset;</span>
<span class="p_del">-	/* Store the low bits [0:6] of the addr */</span>
<span class="p_del">-	ch_addr = addr &amp; 0x7f;</span>
<span class="p_del">-	/* Remove socket wayness and remove 6 bits */</span>
<span class="p_del">-	addr &gt;&gt;= 6;</span>
<span class="p_del">-	addr = div_u64(addr, sck_xch);</span>
<span class="p_del">-#if 0</span>
<span class="p_del">-	/* Divide by channel way */</span>
<span class="p_del">-	addr = addr / ch_way;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	/* Recover the last 6 bits */</span>
<span class="p_del">-	ch_addr |= addr &lt;&lt; 6;</span>
<span class="p_add">+</span>
<span class="p_add">+	ch_addr = addr - offset;</span>
<span class="p_add">+	ch_addr &gt;&gt;= (6 + shiftup);</span>
<span class="p_add">+	ch_addr /= ch_way * sck_way;</span>
<span class="p_add">+	ch_addr &lt;&lt;= (6 + shiftup);</span>
<span class="p_add">+	ch_addr |= addr &amp; ((1 &lt;&lt; (6 + shiftup)) - 1);</span>
 
 	/*
 	 * Step 3) Decode rank
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">index 5a8fbadbd27b..8ac49812a716 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_chunk">@@ -63,6 +63,10 @@</span> <span class="p_context"> bool amdgpu_has_atpx(void) {</span>
 	return amdgpu_atpx_priv.atpx_detected;
 }
 
<span class="p_add">+bool amdgpu_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_add">+	return amdgpu_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * amdgpu_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -142,10 +146,6 @@</span> <span class="p_context"> static void amdgpu_atpx_parse_functions(struct amdgpu_atpx_functions *f, u32 mas</span>
  */
 static int amdgpu_atpx_validate(struct amdgpu_atpx *atpx)
 {
<span class="p_del">-	/* make sure required functions are enabled */</span>
<span class="p_del">-	/* dGPU power control is required */</span>
<span class="p_del">-	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_del">-</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index c961fe093e12..9d88023df836 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -61,6 +61,12 @@</span> <span class="p_context"> static const char *amdgpu_asic_name[] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_add">+#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_add">+bool amdgpu_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool amdgpu_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 bool amdgpu_device_is_px(struct drm_device *dev)
 {
 	struct amdgpu_device *adev = dev-&gt;dev_private;
<span class="p_chunk">@@ -1469,7 +1475,7 @@</span> <span class="p_context"> int amdgpu_device_init(struct amdgpu_device *adev,</span>
 
 	if (amdgpu_runtime_pm == 1)
 		runtime = true;
<span class="p_del">-	if (amdgpu_device_is_px(ddev))</span>
<span class="p_add">+	if (amdgpu_device_is_px(ddev) &amp;&amp; amdgpu_has_atpx_dgpu_power_cntl())</span>
 		runtime = true;
 	vga_switcheroo_register_client(adev-&gt;pdev, &amp;amdgpu_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c</span>
<span class="p_header">index 2cf50180cc51..b1c7a9b3631b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/sdma_v2_4.c</span>
<span class="p_chunk">@@ -32,8 +32,8 @@</span> <span class="p_context"></span>
 #include &quot;oss/oss_2_4_d.h&quot;
 #include &quot;oss/oss_2_4_sh_mask.h&quot;
 
<span class="p_del">-#include &quot;gmc/gmc_8_1_d.h&quot;</span>
<span class="p_del">-#include &quot;gmc/gmc_8_1_sh_mask.h&quot;</span>
<span class="p_add">+#include &quot;gmc/gmc_7_1_d.h&quot;</span>
<span class="p_add">+#include &quot;gmc/gmc_7_1_sh_mask.h&quot;</span>
 
 #include &quot;gca/gfx_8_0_d.h&quot;
 #include &quot;gca/gfx_8_0_enum.h&quot;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index bb292143997e..adf74f4366bb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -892,8 +892,6 @@</span> <span class="p_context"> atombios_dig_encoder_setup2(struct drm_encoder *encoder, int action, int panel_m</span>
 			else
 				args.v1.ucLaneNum = 4;
 
<span class="p_del">-			if (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) &amp;&amp; (dp_clock == 270000))</span>
<span class="p_del">-				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;</span>
 			switch (radeon_encoder-&gt;encoder_id) {
 			case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 				args.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;
<span class="p_chunk">@@ -910,6 +908,10 @@</span> <span class="p_context"> atombios_dig_encoder_setup2(struct drm_encoder *encoder, int action, int panel_m</span>
 				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;
 			else
 				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;
<span class="p_add">+</span>
<span class="p_add">+			if (ENCODER_MODE_IS_DP(args.v1.ucEncoderMode) &amp;&amp; (dp_clock == 270000))</span>
<span class="p_add">+				args.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;</span>
<span class="p_add">+</span>
 			break;
 		case 2:
 		case 3:
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index c4b4f298a283..9bc408c9f9f6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -62,6 +62,10 @@</span> <span class="p_context"> bool radeon_has_atpx(void) {</span>
 	return radeon_atpx_priv.atpx_detected;
 }
 
<span class="p_add">+bool radeon_has_atpx_dgpu_power_cntl(void) {</span>
<span class="p_add">+	return radeon_atpx_priv.atpx.functions.power_cntl;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * radeon_atpx_call - call an ATPX method
  *
<span class="p_chunk">@@ -141,10 +145,6 @@</span> <span class="p_context"> static void radeon_atpx_parse_functions(struct radeon_atpx_functions *f, u32 mas</span>
  */
 static int radeon_atpx_validate(struct radeon_atpx *atpx)
 {
<span class="p_del">-	/* make sure required functions are enabled */</span>
<span class="p_del">-	/* dGPU power control is required */</span>
<span class="p_del">-	atpx-&gt;functions.power_cntl = true;</span>
<span class="p_del">-</span>
 	if (atpx-&gt;functions.px_params) {
 		union acpi_object *info;
 		struct atpx_px_params output;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index c566993a2ec3..f78f111e68de 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -103,6 +103,12 @@</span> <span class="p_context"> static const char radeon_family_name[][16] = {</span>
 	&quot;LAST&quot;,
 };
 
<span class="p_add">+#if defined(CONFIG_VGA_SWITCHEROO)</span>
<span class="p_add">+bool radeon_has_atpx_dgpu_power_cntl(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool radeon_has_atpx_dgpu_power_cntl(void) { return false; }</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #define RADEON_PX_QUIRK_DISABLE_PX  (1 &lt;&lt; 0)
 #define RADEON_PX_QUIRK_LONG_WAKEUP (1 &lt;&lt; 1)
 
<span class="p_chunk">@@ -1433,7 +1439,7 @@</span> <span class="p_context"> int radeon_device_init(struct radeon_device *rdev,</span>
 	 * ignore it */
 	vga_client_register(rdev-&gt;pdev, rdev, NULL, radeon_vga_set_decode);
 
<span class="p_del">-	if (rdev-&gt;flags &amp; RADEON_IS_PX)</span>
<span class="p_add">+	if ((rdev-&gt;flags &amp; RADEON_IS_PX) &amp;&amp; radeon_has_atpx_dgpu_power_cntl())</span>
 		runtime = true;
 	vga_switcheroo_register_client(rdev-&gt;pdev, &amp;radeon_switcheroo_ops, runtime);
 	if (runtime)
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index c6f7a694f67a..ec791e169f8f 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1897,6 +1897,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_ELITE_KBD) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_CORDLESS_DESKTOP_LX500) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_EXTREME_3D) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_DUAL_ACTION) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_WHEEL) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD_CORD) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD) },
<span class="p_chunk">@@ -2615,9 +2616,10 @@</span> <span class="p_context"> int hid_add_device(struct hid_device *hdev)</span>
 	/*
 	 * Scan generic devices for group information
 	 */
<span class="p_del">-	if (hid_ignore_special_drivers ||</span>
<span class="p_del">-	    (!hdev-&gt;group &amp;&amp;</span>
<span class="p_del">-	     !hid_match_id(hdev, hid_have_special_driver))) {</span>
<span class="p_add">+	if (hid_ignore_special_drivers) {</span>
<span class="p_add">+		hdev-&gt;group = HID_GROUP_GENERIC;</span>
<span class="p_add">+	} else if (!hdev-&gt;group &amp;&amp;</span>
<span class="p_add">+		   !hid_match_id(hdev, hid_have_special_driver)) {</span>
 		ret = hid_scan_report(hdev);
 		if (ret)
 			hid_warn(hdev, &quot;bad device descriptor (%d)\n&quot;, ret);
<span class="p_header">diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c</span>
<span class="p_header">index 2b8ff18d3713..c5ec4f915594 100644</span>
<span class="p_header">--- a/drivers/hid/hid-multitouch.c</span>
<span class="p_header">+++ b/drivers/hid/hid-multitouch.c</span>
<span class="p_chunk">@@ -396,6 +396,11 @@</span> <span class="p_context"> static void mt_feature_mapping(struct hid_device *hdev,</span>
 			td-&gt;is_buttonpad = true;
 
 		break;
<span class="p_add">+	case 0xff0000c5:</span>
<span class="p_add">+		/* Retrieve the Win8 blob once to enable some devices */</span>
<span class="p_add">+		if (usage-&gt;usage_index == 0)</span>
<span class="p_add">+			mt_get_feature(hdev, field-&gt;report);</span>
<span class="p_add">+		break;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 10bd8e6e4c9c..0b80633bae91 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -282,17 +282,21 @@</span> <span class="p_context"> static int i2c_hid_set_or_send_report(struct i2c_client *client, u8 reportType,</span>
 	u16 dataRegister = le16_to_cpu(ihid-&gt;hdesc.wDataRegister);
 	u16 outputRegister = le16_to_cpu(ihid-&gt;hdesc.wOutputRegister);
 	u16 maxOutputLength = le16_to_cpu(ihid-&gt;hdesc.wMaxOutputLength);
<span class="p_add">+	u16 size;</span>
<span class="p_add">+	int args_len;</span>
<span class="p_add">+	int index = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	i2c_hid_dbg(ihid, &quot;%s\n&quot;, __func__);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data_len &gt; ihid-&gt;bufsize)</span>
<span class="p_add">+		return -EINVAL;</span>
 
<span class="p_del">-	/* hid_hw_* already checked that data_len &lt; HID_MAX_BUFFER_SIZE */</span>
<span class="p_del">-	u16 size =	2			/* size */ +</span>
<span class="p_add">+	size =		2			/* size */ +</span>
 			(reportID ? 1 : 0)	/* reportID */ +
 			data_len		/* buf */;
<span class="p_del">-	int args_len =	(reportID &gt;= 0x0F ? 1 : 0) /* optional third byte */ +</span>
<span class="p_add">+	args_len =	(reportID &gt;= 0x0F ? 1 : 0) /* optional third byte */ +</span>
 			2			/* dataRegister */ +
 			size			/* args */;
<span class="p_del">-	int index = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	i2c_hid_dbg(ihid, &quot;%s\n&quot;, __func__);</span>
 
 	if (!use_data &amp;&amp; maxOutputLength == 0)
 		return -ENOSYS;
<span class="p_header">diff --git a/drivers/idle/intel_idle.c b/drivers/idle/intel_idle.c</span>
<span class="p_header">index cd4510a63375..146eed70bdf4 100644</span>
<span class="p_header">--- a/drivers/idle/intel_idle.c</span>
<span class="p_header">+++ b/drivers/idle/intel_idle.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mwait.h&gt;
 #include &lt;asm/msr.h&gt;
 
<span class="p_del">-#define INTEL_IDLE_VERSION &quot;0.4&quot;</span>
<span class="p_add">+#define INTEL_IDLE_VERSION &quot;0.4.1&quot;</span>
 #define PREFIX &quot;intel_idle: &quot;
 
 static struct cpuidle_driver intel_idle_driver = {
<span class="p_chunk">@@ -994,36 +994,92 @@</span> <span class="p_context"> static void intel_idle_cpuidle_devices_uninit(void)</span>
 }
 
 /*
<span class="p_del">- * intel_idle_state_table_update()</span>
<span class="p_del">- *</span>
<span class="p_del">- * Update the default state_table for this CPU-id</span>
<span class="p_add">+ * ivt_idle_state_table_update(void)</span>
  *
<span class="p_del">- * Currently used to access tuned IVT multi-socket targets</span>
<span class="p_add">+ * Tune IVT multi-socket targets</span>
  * Assumption: num_sockets == (max_package_num + 1)
  */
<span class="p_del">-void intel_idle_state_table_update(void)</span>
<span class="p_add">+static void ivt_idle_state_table_update(void)</span>
 {
 	/* IVT uses a different table for 1-2, 3-4, and &gt; 4 sockets */
<span class="p_del">-	if (boot_cpu_data.x86_model == 0x3e) { /* IVT */</span>
<span class="p_del">-		int cpu, package_num, num_sockets = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_online_cpu(cpu) {</span>
<span class="p_del">-			package_num = topology_physical_package_id(cpu);</span>
<span class="p_del">-			if (package_num + 1 &gt; num_sockets) {</span>
<span class="p_del">-				num_sockets = package_num + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-				if (num_sockets &gt; 4) {</span>
<span class="p_del">-					cpuidle_state_table = ivt_cstates_8s;</span>
<span class="p_del">-					return;</span>
<span class="p_del">-				}</span>
<span class="p_add">+	int cpu, package_num, num_sockets = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_online_cpu(cpu) {</span>
<span class="p_add">+		package_num = topology_physical_package_id(cpu);</span>
<span class="p_add">+		if (package_num + 1 &gt; num_sockets) {</span>
<span class="p_add">+			num_sockets = package_num + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (num_sockets &gt; 4) {</span>
<span class="p_add">+				cpuidle_state_table = ivt_cstates_8s;</span>
<span class="p_add">+				return;</span>
 			}
 		}
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_sockets &gt; 2)</span>
<span class="p_add">+		cpuidle_state_table = ivt_cstates_4s;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* else, 1 and 2 socket systems use default ivt_cstates */</span>
<span class="p_add">+}</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * sklh_idle_state_table_update(void)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On SKL-H (model 0x5e) disable C8 and C9 if:</span>
<span class="p_add">+ * C10 is enabled and SGX disabled</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sklh_idle_state_table_update(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long long msr;</span>
<span class="p_add">+	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if PC10 disabled via cmdline intel_idle.max_cstate=7 or shallower */</span>
<span class="p_add">+	if (max_cstate &lt;= 7)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if PC10 not present in CPUID.MWAIT.EDX */</span>
<span class="p_add">+	if ((mwait_substates &amp; (0xF &lt;&lt; 28)) == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	rdmsrl(MSR_NHM_SNB_PKG_CST_CFG_CTL, msr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PC10 is not enabled in PKG C-state limit */</span>
<span class="p_add">+	if ((msr &amp; 0xF) != 8)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	cpuid(7, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if SGX is present */</span>
<span class="p_add">+	if (ebx &amp; (1 &lt;&lt; 2)) {</span>
 
<span class="p_del">-		if (num_sockets &gt; 2)</span>
<span class="p_del">-			cpuidle_state_table = ivt_cstates_4s;</span>
<span class="p_del">-		/* else, 1 and 2 socket systems use default ivt_cstates */</span>
<span class="p_add">+		rdmsrl(MSR_IA32_FEATURE_CONTROL, msr);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* if SGX is enabled */</span>
<span class="p_add">+		if (msr &amp; (1 &lt;&lt; 18))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	skl_cstates[5].disabled = 1;	/* C8-SKL */</span>
<span class="p_add">+	skl_cstates[6].disabled = 1;	/* C9-SKL */</span>
<span class="p_add">+}</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * intel_idle_state_table_update()</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update the default state_table for this CPU-id</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void intel_idle_state_table_update(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (boot_cpu_data.x86_model) {</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x3e: /* IVT */</span>
<span class="p_add">+		ivt_idle_state_table_update();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x5e: /* SKL-H */</span>
<span class="p_add">+		sklh_idle_state_table_update();</span>
<span class="p_add">+		break;</span>
 	}
<span class="p_del">-	return;</span>
 }
 
 /*
<span class="p_chunk">@@ -1063,6 +1119,14 @@</span> <span class="p_context"> static int __init intel_idle_cpuidle_driver_init(void)</span>
 		if (num_substates == 0)
 			continue;
 
<span class="p_add">+		/* if state marked as disabled, skip it */</span>
<span class="p_add">+		if (cpuidle_state_table[cstate].disabled != 0) {</span>
<span class="p_add">+			pr_debug(PREFIX &quot;state %s is disabled&quot;,</span>
<span class="p_add">+				cpuidle_state_table[cstate].name);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 		if (((mwait_cstate + 1) &gt; 2) &amp;&amp;
 			!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
 			mark_tsc_unstable(&quot;TSC halts in idle&quot;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_header">index f357ca67a41c..87799de90a1d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c</span>
<span class="p_chunk">@@ -456,7 +456,10 @@</span> <span class="p_context"> out_locked:</span>
 	return status;
 }
 
<span class="p_del">-static void ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Caller must hold &#39;priv-&gt;lock&#39;</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct ib_sa_multicast *multicast;
<span class="p_chunk">@@ -466,6 +469,10 @@</span> <span class="p_context"> static void ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)</span>
 	ib_sa_comp_mask comp_mask;
 	int ret = 0;
 
<span class="p_add">+	if (!priv-&gt;broadcast ||</span>
<span class="p_add">+	    !test_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	ipoib_dbg_mcast(priv, &quot;joining MGID %pI6\n&quot;, mcast-&gt;mcmember.mgid.raw);
 
 	rec.mgid     = mcast-&gt;mcmember.mgid;
<span class="p_chunk">@@ -525,20 +532,23 @@</span> <span class="p_context"> static void ipoib_mcast_join(struct net_device *dev, struct ipoib_mcast *mcast)</span>
 			rec.join_state = 4;
 #endif
 	}
<span class="p_add">+	spin_unlock_irq(&amp;priv-&gt;lock);</span>
 
 	multicast = ib_sa_join_multicast(&amp;ipoib_sa_client, priv-&gt;ca, priv-&gt;port,
 					 &amp;rec, comp_mask, GFP_KERNEL,
 					 ipoib_mcast_join_complete, mcast);
<span class="p_add">+	spin_lock_irq(&amp;priv-&gt;lock);</span>
 	if (IS_ERR(multicast)) {
 		ret = PTR_ERR(multicast);
 		ipoib_warn(priv, &quot;ib_sa_join_multicast failed, status %d\n&quot;, ret);
<span class="p_del">-		spin_lock_irq(&amp;priv-&gt;lock);</span>
 		/* Requeue this join task with a backoff delay */
 		__ipoib_mcast_schedule_join_thread(priv, mcast, 1);
 		clear_bit(IPOIB_MCAST_FLAG_BUSY, &amp;mcast-&gt;flags);
 		spin_unlock_irq(&amp;priv-&gt;lock);
 		complete(&amp;mcast-&gt;done);
<span class="p_add">+		spin_lock_irq(&amp;priv-&gt;lock);</span>
 	}
<span class="p_add">+	return 0;</span>
 }
 
 void ipoib_mcast_join_task(struct work_struct *work)
<span class="p_chunk">@@ -620,9 +630,10 @@</span> <span class="p_context"> void ipoib_mcast_join_task(struct work_struct *work)</span>
 				/* Found the next unjoined group */
 				init_completion(&amp;mcast-&gt;done);
 				set_bit(IPOIB_MCAST_FLAG_BUSY, &amp;mcast-&gt;flags);
<span class="p_del">-				spin_unlock_irq(&amp;priv-&gt;lock);</span>
<span class="p_del">-				ipoib_mcast_join(dev, mcast);</span>
<span class="p_del">-				spin_lock_irq(&amp;priv-&gt;lock);</span>
<span class="p_add">+				if (ipoib_mcast_join(dev, mcast)) {</span>
<span class="p_add">+					spin_unlock_irq(&amp;priv-&gt;lock);</span>
<span class="p_add">+					return;</span>
<span class="p_add">+				}</span>
 			} else if (!delay_until ||
 				 time_before(mcast-&gt;delay_until, delay_until))
 				delay_until = mcast-&gt;delay_until;
<span class="p_chunk">@@ -641,10 +652,9 @@</span> <span class="p_context"> out:</span>
 	if (mcast) {
 		init_completion(&amp;mcast-&gt;done);
 		set_bit(IPOIB_MCAST_FLAG_BUSY, &amp;mcast-&gt;flags);
<span class="p_add">+		ipoib_mcast_join(dev, mcast);</span>
 	}
 	spin_unlock_irq(&amp;priv-&gt;lock);
<span class="p_del">-	if (mcast)</span>
<span class="p_del">-		ipoib_mcast_join(dev, mcast);</span>
 }
 
 int ipoib_mcast_start_thread(struct net_device *dev)
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index 8a51c3b5d657..b0edb66a291b 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> isert_rdma_accept(struct isert_conn *isert_conn);</span>
 struct rdma_cm_id *isert_setup_id(struct isert_np *isert_np);
 
 static void isert_release_work(struct work_struct *work);
<span class="p_add">+static void isert_wait4flush(struct isert_conn *isert_conn);</span>
 
 static inline bool
 isert_prot_cmd(struct isert_conn *conn, struct se_cmd *cmd)
<span class="p_chunk">@@ -815,12 +816,31 @@</span> <span class="p_context"> isert_put_conn(struct isert_conn *isert_conn)</span>
 	kref_put(&amp;isert_conn-&gt;kref, isert_release_kref);
 }
 
<span class="p_add">+static void</span>
<span class="p_add">+isert_handle_unbound_conn(struct isert_conn *isert_conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct isert_np *isert_np = isert_conn-&gt;cm_id-&gt;context;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;isert_np-&gt;mutex);</span>
<span class="p_add">+	if (!list_empty(&amp;isert_conn-&gt;node)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This means iscsi doesn&#39;t know this connection</span>
<span class="p_add">+		 * so schedule a cleanup ourselves</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_del_init(&amp;isert_conn-&gt;node);</span>
<span class="p_add">+		isert_put_conn(isert_conn);</span>
<span class="p_add">+		complete(&amp;isert_conn-&gt;wait);</span>
<span class="p_add">+		queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;isert_np-&gt;mutex);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * isert_conn_terminate() - Initiate connection termination
  * @isert_conn: isert connection struct
  *
  * Notes:
<span class="p_del">- * In case the connection state is FULL_FEATURE, move state</span>
<span class="p_add">+ * In case the connection state is BOUND, move state</span>
  * to TEMINATING and start teardown sequence (rdma_disconnect).
  * In case the connection state is UP, complete flush as well.
  *
<span class="p_chunk">@@ -832,23 +852,19 @@</span> <span class="p_context"> isert_conn_terminate(struct isert_conn *isert_conn)</span>
 {
 	int err;
 
<span class="p_del">-	switch (isert_conn-&gt;state) {</span>
<span class="p_del">-	case ISER_CONN_TERMINATING:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case ISER_CONN_UP:</span>
<span class="p_del">-	case ISER_CONN_FULL_FEATURE: /* FALLTHRU */</span>
<span class="p_del">-		isert_info(&quot;Terminating conn %p state %d\n&quot;,</span>
<span class="p_del">-			   isert_conn, isert_conn-&gt;state);</span>
<span class="p_del">-		isert_conn-&gt;state = ISER_CONN_TERMINATING;</span>
<span class="p_del">-		err = rdma_disconnect(isert_conn-&gt;cm_id);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			isert_warn(&quot;Failed rdma_disconnect isert_conn %p\n&quot;,</span>
<span class="p_del">-				   isert_conn);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		isert_warn(&quot;conn %p teminating in state %d\n&quot;,</span>
<span class="p_del">-			   isert_conn, isert_conn-&gt;state);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (isert_conn-&gt;state &gt;= ISER_CONN_TERMINATING)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	isert_info(&quot;Terminating conn %p state %d\n&quot;,</span>
<span class="p_add">+		   isert_conn, isert_conn-&gt;state);</span>
<span class="p_add">+	isert_conn-&gt;state = ISER_CONN_TERMINATING;</span>
<span class="p_add">+	err = rdma_disconnect(isert_conn-&gt;cm_id);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		isert_warn(&quot;Failed rdma_disconnect isert_conn %p\n&quot;,</span>
<span class="p_add">+			   isert_conn);</span>
<span class="p_add">+</span>
<span class="p_add">+	isert_info(&quot;conn %p completing wait\n&quot;, isert_conn);</span>
<span class="p_add">+	complete(&amp;isert_conn-&gt;wait);</span>
 }
 
 static int
<span class="p_chunk">@@ -882,35 +898,27 @@</span> <span class="p_context"> static int</span>
 isert_disconnected_handler(struct rdma_cm_id *cma_id,
 			   enum rdma_cm_event_type event)
 {
<span class="p_del">-	struct isert_np *isert_np = cma_id-&gt;context;</span>
<span class="p_del">-	struct isert_conn *isert_conn;</span>
<span class="p_del">-	bool terminating = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (isert_np-&gt;cm_id == cma_id)</span>
<span class="p_del">-		return isert_np_cma_handler(cma_id-&gt;context, event);</span>
<span class="p_del">-</span>
<span class="p_del">-	isert_conn = cma_id-&gt;qp-&gt;qp_context;</span>
<span class="p_add">+	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;</span>
 
 	mutex_lock(&amp;isert_conn-&gt;mutex);
<span class="p_del">-	terminating = (isert_conn-&gt;state == ISER_CONN_TERMINATING);</span>
<span class="p_del">-	isert_conn_terminate(isert_conn);</span>
<span class="p_del">-	mutex_unlock(&amp;isert_conn-&gt;mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	isert_info(&quot;conn %p completing wait\n&quot;, isert_conn);</span>
<span class="p_del">-	complete(&amp;isert_conn-&gt;wait);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (terminating)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;isert_np-&gt;mutex);</span>
<span class="p_del">-	if (!list_empty(&amp;isert_conn-&gt;node)) {</span>
<span class="p_del">-		list_del_init(&amp;isert_conn-&gt;node);</span>
<span class="p_del">-		isert_put_conn(isert_conn);</span>
<span class="p_del">-		queue_work(isert_release_wq, &amp;isert_conn-&gt;release_work);</span>
<span class="p_add">+	switch (isert_conn-&gt;state) {</span>
<span class="p_add">+	case ISER_CONN_TERMINATING:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ISER_CONN_UP:</span>
<span class="p_add">+		isert_conn_terminate(isert_conn);</span>
<span class="p_add">+		isert_wait4flush(isert_conn);</span>
<span class="p_add">+		isert_handle_unbound_conn(isert_conn);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ISER_CONN_BOUND:</span>
<span class="p_add">+	case ISER_CONN_FULL_FEATURE: /* FALLTHRU */</span>
<span class="p_add">+		iscsit_cause_connection_reinstatement(isert_conn-&gt;conn, 0);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		isert_warn(&quot;conn %p teminating in state %d\n&quot;,</span>
<span class="p_add">+			   isert_conn, isert_conn-&gt;state);</span>
 	}
<span class="p_del">-	mutex_unlock(&amp;isert_np-&gt;mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;isert_conn-&gt;mutex);</span>
 
<span class="p_del">-out:</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -929,12 +937,16 @@</span> <span class="p_context"> isert_connect_error(struct rdma_cm_id *cma_id)</span>
 static int
 isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 {
<span class="p_add">+	struct isert_np *isert_np = cma_id-&gt;context;</span>
 	int ret = 0;
 
 	isert_info(&quot;%s (%d): status %d id %p np %p\n&quot;,
 		   rdma_event_msg(event-&gt;event), event-&gt;event,
 		   event-&gt;status, cma_id, cma_id-&gt;context);
 
<span class="p_add">+	if (isert_np-&gt;cm_id == cma_id)</span>
<span class="p_add">+		return isert_np_cma_handler(cma_id-&gt;context, event-&gt;event);</span>
<span class="p_add">+</span>
 	switch (event-&gt;event) {
 	case RDMA_CM_EVENT_CONNECT_REQUEST:
 		ret = isert_connect_request(cma_id, event);
<span class="p_chunk">@@ -980,13 +992,10 @@</span> <span class="p_context"> isert_post_recvm(struct isert_conn *isert_conn, u32 count)</span>
 	rx_wr--;
 	rx_wr-&gt;next = NULL; /* mark end of work requests list */
 
<span class="p_del">-	isert_conn-&gt;post_recv_buf_count += count;</span>
 	ret = ib_post_recv(isert_conn-&gt;qp, isert_conn-&gt;rx_wr,
 			   &amp;rx_wr_failed);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret)</span>
 		isert_err(&quot;ib_post_recv() failed with ret: %d\n&quot;, ret);
<span class="p_del">-		isert_conn-&gt;post_recv_buf_count -= count;</span>
<span class="p_del">-	}</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1002,12 +1011,9 @@</span> <span class="p_context"> isert_post_recv(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc)</span>
 	rx_wr.num_sge = 1;
 	rx_wr.next = NULL;
 
<span class="p_del">-	isert_conn-&gt;post_recv_buf_count++;</span>
 	ret = ib_post_recv(isert_conn-&gt;qp, &amp;rx_wr, &amp;rx_wr_failed);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret)</span>
 		isert_err(&quot;ib_post_recv() failed with ret: %d\n&quot;, ret);
<span class="p_del">-		isert_conn-&gt;post_recv_buf_count--;</span>
<span class="p_del">-	}</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1120,12 +1126,9 @@</span> <span class="p_context"> isert_rdma_post_recvl(struct isert_conn *isert_conn)</span>
 	rx_wr.sg_list = &amp;sge;
 	rx_wr.num_sge = 1;
 
<span class="p_del">-	isert_conn-&gt;post_recv_buf_count++;</span>
 	ret = ib_post_recv(isert_conn-&gt;qp, &amp;rx_wr, &amp;rx_wr_fail);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret)</span>
 		isert_err(&quot;ib_post_recv() failed: %d\n&quot;, ret);
<span class="p_del">-		isert_conn-&gt;post_recv_buf_count--;</span>
<span class="p_del">-	}</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1620,7 +1623,6 @@</span> <span class="p_context"> isert_rcv_completion(struct iser_rx_desc *desc,</span>
 	ib_dma_sync_single_for_device(ib_dev, rx_dma, rx_buflen,
 				      DMA_FROM_DEVICE);
 
<span class="p_del">-	isert_conn-&gt;post_recv_buf_count--;</span>
 }
 
 static int
<span class="p_chunk">@@ -2035,7 +2037,8 @@</span> <span class="p_context"> is_isert_tx_desc(struct isert_conn *isert_conn, void *wr_id)</span>
 	void *start = isert_conn-&gt;rx_descs;
 	int len = ISERT_QP_MAX_RECV_DTOS * sizeof(*isert_conn-&gt;rx_descs);
 
<span class="p_del">-	if (wr_id &gt;= start &amp;&amp; wr_id &lt; start + len)</span>
<span class="p_add">+	if ((wr_id &gt;= start &amp;&amp; wr_id &lt; start + len) ||</span>
<span class="p_add">+	    (wr_id == isert_conn-&gt;login_req_buf))</span>
 		return false;
 
 	return true;
<span class="p_chunk">@@ -2059,10 +2062,6 @@</span> <span class="p_context"> isert_cq_comp_err(struct isert_conn *isert_conn, struct ib_wc *wc)</span>
 			isert_unmap_tx_desc(desc, ib_dev);
 		else
 			isert_completion_put(desc, isert_cmd, ib_dev, true);
<span class="p_del">-	} else {</span>
<span class="p_del">-		isert_conn-&gt;post_recv_buf_count--;</span>
<span class="p_del">-		if (!isert_conn-&gt;post_recv_buf_count)</span>
<span class="p_del">-			iscsit_cause_connection_reinstatement(isert_conn-&gt;conn, 0);</span>
 	}
 }
 
<span class="p_chunk">@@ -3193,6 +3192,7 @@</span> <span class="p_context"> accept_wait:</span>
 
 	conn-&gt;context = isert_conn;
 	isert_conn-&gt;conn = conn;
<span class="p_add">+	isert_conn-&gt;state = ISER_CONN_BOUND;</span>
 
 	isert_set_conn_info(np, conn, isert_conn);
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.h b/drivers/infiniband/ulp/isert/ib_isert.h</span>
<span class="p_header">index 3d7fbc47c343..1874d21daee0 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.h</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> enum iser_ib_op_code {</span>
 enum iser_conn_state {
 	ISER_CONN_INIT,
 	ISER_CONN_UP,
<span class="p_add">+	ISER_CONN_BOUND,</span>
 	ISER_CONN_FULL_FEATURE,
 	ISER_CONN_TERMINATING,
 	ISER_CONN_DOWN,
<span class="p_chunk">@@ -144,7 +145,6 @@</span> <span class="p_context"> struct isert_device;</span>
 
 struct isert_conn {
 	enum iser_conn_state	state;
<span class="p_del">-	int			post_recv_buf_count;</span>
 	u32			responder_resources;
 	u32			initiator_depth;
 	bool			pi_support;
<span class="p_header">diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.c b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">index 2e2fe818ca9f..eaabf3125846 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_chunk">@@ -1737,47 +1737,6 @@</span> <span class="p_context"> send_sense:</span>
 	return -1;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * srpt_rx_mgmt_fn_tag() - Process a task management function by tag.</span>
<span class="p_del">- * @ch: RDMA channel of the task management request.</span>
<span class="p_del">- * @fn: Task management function to perform.</span>
<span class="p_del">- * @req_tag: Tag of the SRP task management request.</span>
<span class="p_del">- * @mgmt_ioctx: I/O context of the task management request.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns zero if the target core will process the task management</span>
<span class="p_del">- * request asynchronously.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Note: It is assumed that the initiator serializes tag-based task management</span>
<span class="p_del">- * requests.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct srpt_device *sdev;</span>
<span class="p_del">-	struct srpt_rdma_ch *ch;</span>
<span class="p_del">-	struct srpt_send_ioctx *target;</span>
<span class="p_del">-	int ret, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = -EINVAL;</span>
<span class="p_del">-	ch = ioctx-&gt;ch;</span>
<span class="p_del">-	BUG_ON(!ch);</span>
<span class="p_del">-	BUG_ON(!ch-&gt;sport);</span>
<span class="p_del">-	sdev = ch-&gt;sport-&gt;sdev;</span>
<span class="p_del">-	BUG_ON(!sdev);</span>
<span class="p_del">-	spin_lock_irq(&amp;sdev-&gt;spinlock);</span>
<span class="p_del">-	for (i = 0; i &lt; ch-&gt;rq_size; ++i) {</span>
<span class="p_del">-		target = ch-&gt;ioctx_ring[i];</span>
<span class="p_del">-		if (target-&gt;cmd.se_lun == ioctx-&gt;cmd.se_lun &amp;&amp;</span>
<span class="p_del">-		    target-&gt;cmd.tag == tag &amp;&amp;</span>
<span class="p_del">-		    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {</span>
<span class="p_del">-			ret = 0;</span>
<span class="p_del">-			/* now let the target core abort &amp;target-&gt;cmd; */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	spin_unlock_irq(&amp;sdev-&gt;spinlock);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int srp_tmr_to_tcm(int fn)
 {
 	switch (fn) {
<span class="p_chunk">@@ -1812,7 +1771,6 @@</span> <span class="p_context"> static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,</span>
 	struct se_cmd *cmd;
 	struct se_session *sess = ch-&gt;sess;
 	uint64_t unpacked_lun;
<span class="p_del">-	uint32_t tag = 0;</span>
 	int tcm_tmr;
 	int rc;
 
<span class="p_chunk">@@ -1828,25 +1786,10 @@</span> <span class="p_context"> static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,</span>
 	srpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);
 	send_ioctx-&gt;cmd.tag = srp_tsk-&gt;tag;
 	tcm_tmr = srp_tmr_to_tcm(srp_tsk-&gt;tsk_mgmt_func);
<span class="p_del">-	if (tcm_tmr &lt; 0) {</span>
<span class="p_del">-		send_ioctx-&gt;cmd.se_tmr_req-&gt;response =</span>
<span class="p_del">-			TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-	}</span>
 	unpacked_lun = srpt_unpack_lun((uint8_t *)&amp;srp_tsk-&gt;lun,
 				       sizeof(srp_tsk-&gt;lun));
<span class="p_del">-</span>
<span class="p_del">-	if (srp_tsk-&gt;tsk_mgmt_func == SRP_TSK_ABORT_TASK) {</span>
<span class="p_del">-		rc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk-&gt;task_tag);</span>
<span class="p_del">-		if (rc &lt; 0) {</span>
<span class="p_del">-			send_ioctx-&gt;cmd.se_tmr_req-&gt;response =</span>
<span class="p_del">-					TMR_TASK_DOES_NOT_EXIST;</span>
<span class="p_del">-			goto fail;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		tag = srp_tsk-&gt;task_tag;</span>
<span class="p_del">-	}</span>
 	rc = target_submit_tmr(&amp;send_ioctx-&gt;cmd, sess, NULL, unpacked_lun,
<span class="p_del">-				srp_tsk, tcm_tmr, GFP_KERNEL, tag,</span>
<span class="p_add">+				srp_tsk, tcm_tmr, GFP_KERNEL, srp_tsk-&gt;task_tag,</span>
 				TARGET_SCF_ACK_KREF);
 	if (rc != 0) {
 		send_ioctx-&gt;cmd.se_tmr_req-&gt;response = TMR_FUNCTION_REJECTED;
<span class="p_header">diff --git a/drivers/input/misc/ati_remote2.c b/drivers/input/misc/ati_remote2.c</span>
<span class="p_header">index cfd58e87da26..1c5914cae853 100644</span>
<span class="p_header">--- a/drivers/input/misc/ati_remote2.c</span>
<span class="p_header">+++ b/drivers/input/misc/ati_remote2.c</span>
<span class="p_chunk">@@ -817,26 +817,49 @@</span> <span class="p_context"> static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d</span>
 
 	ar2-&gt;udev = udev;
 
<span class="p_add">+	/* Sanity check, first interface must have an endpoint */</span>
<span class="p_add">+	if (alt-&gt;desc.bNumEndpoints &lt; 1 || !alt-&gt;endpoint) {</span>
<span class="p_add">+		dev_err(&amp;interface-&gt;dev,</span>
<span class="p_add">+			&quot;%s(): interface 0 must have an endpoint\n&quot;, __func__);</span>
<span class="p_add">+		r = -ENODEV;</span>
<span class="p_add">+		goto fail1;</span>
<span class="p_add">+	}</span>
 	ar2-&gt;intf[0] = interface;
 	ar2-&gt;ep[0] = &amp;alt-&gt;endpoint[0].desc;
 
<span class="p_add">+	/* Sanity check, the device must have two interfaces */</span>
 	ar2-&gt;intf[1] = usb_ifnum_to_if(udev, 1);
<span class="p_add">+	if ((udev-&gt;actconfig-&gt;desc.bNumInterfaces &lt; 2) || !ar2-&gt;intf[1]) {</span>
<span class="p_add">+		dev_err(&amp;interface-&gt;dev, &quot;%s(): need 2 interfaces, found %d\n&quot;,</span>
<span class="p_add">+			__func__, udev-&gt;actconfig-&gt;desc.bNumInterfaces);</span>
<span class="p_add">+		r = -ENODEV;</span>
<span class="p_add">+		goto fail1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	r = usb_driver_claim_interface(&amp;ati_remote2_driver, ar2-&gt;intf[1], ar2);
 	if (r)
 		goto fail1;
<span class="p_add">+</span>
<span class="p_add">+	/* Sanity check, second interface must have an endpoint */</span>
 	alt = ar2-&gt;intf[1]-&gt;cur_altsetting;
<span class="p_add">+	if (alt-&gt;desc.bNumEndpoints &lt; 1 || !alt-&gt;endpoint) {</span>
<span class="p_add">+		dev_err(&amp;interface-&gt;dev,</span>
<span class="p_add">+			&quot;%s(): interface 1 must have an endpoint\n&quot;, __func__);</span>
<span class="p_add">+		r = -ENODEV;</span>
<span class="p_add">+		goto fail2;</span>
<span class="p_add">+	}</span>
 	ar2-&gt;ep[1] = &amp;alt-&gt;endpoint[0].desc;
 
 	r = ati_remote2_urb_init(ar2);
 	if (r)
<span class="p_del">-		goto fail2;</span>
<span class="p_add">+		goto fail3;</span>
 
 	ar2-&gt;channel_mask = channel_mask;
 	ar2-&gt;mode_mask = mode_mask;
 
 	r = ati_remote2_setup(ar2, ar2-&gt;channel_mask);
 	if (r)
<span class="p_del">-		goto fail2;</span>
<span class="p_add">+		goto fail3;</span>
 
 	usb_make_path(udev, ar2-&gt;phys, sizeof(ar2-&gt;phys));
 	strlcat(ar2-&gt;phys, &quot;/input0&quot;, sizeof(ar2-&gt;phys));
<span class="p_chunk">@@ -845,11 +868,11 @@</span> <span class="p_context"> static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d</span>
 
 	r = sysfs_create_group(&amp;udev-&gt;dev.kobj, &amp;ati_remote2_attr_group);
 	if (r)
<span class="p_del">-		goto fail2;</span>
<span class="p_add">+		goto fail3;</span>
 
 	r = ati_remote2_input_init(ar2);
 	if (r)
<span class="p_del">-		goto fail3;</span>
<span class="p_add">+		goto fail4;</span>
 
 	usb_set_intfdata(interface, ar2);
 
<span class="p_chunk">@@ -857,10 +880,11 @@</span> <span class="p_context"> static int ati_remote2_probe(struct usb_interface *interface, const struct usb_d</span>
 
 	return 0;
 
<span class="p_del">- fail3:</span>
<span class="p_add">+ fail4:</span>
 	sysfs_remove_group(&amp;udev-&gt;dev.kobj, &amp;ati_remote2_attr_group);
<span class="p_del">- fail2:</span>
<span class="p_add">+ fail3:</span>
 	ati_remote2_urb_cleanup(ar2);
<span class="p_add">+ fail2:</span>
 	usb_driver_release_interface(&amp;ati_remote2_driver, ar2-&gt;intf[1]);
  fail1:
 	kfree(ar2);
<span class="p_header">diff --git a/drivers/input/misc/ims-pcu.c b/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">index ac1fa5f44580..9c0ea36913b4 100644</span>
<span class="p_header">--- a/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">+++ b/drivers/input/misc/ims-pcu.c</span>
<span class="p_chunk">@@ -1663,6 +1663,8 @@</span> <span class="p_context"> static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc</span>
 
 	pcu-&gt;ctrl_intf = usb_ifnum_to_if(pcu-&gt;udev,
 					 union_desc-&gt;bMasterInterface0);
<span class="p_add">+	if (!pcu-&gt;ctrl_intf)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	alt = pcu-&gt;ctrl_intf-&gt;cur_altsetting;
 	pcu-&gt;ep_ctrl = &amp;alt-&gt;endpoint[0].desc;
<span class="p_chunk">@@ -1670,6 +1672,8 @@</span> <span class="p_context"> static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc</span>
 
 	pcu-&gt;data_intf = usb_ifnum_to_if(pcu-&gt;udev,
 					 union_desc-&gt;bSlaveInterface0);
<span class="p_add">+	if (!pcu-&gt;data_intf)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	alt = pcu-&gt;data_intf-&gt;cur_altsetting;
 	if (alt-&gt;desc.bNumEndpoints != 2) {
<span class="p_header">diff --git a/drivers/input/misc/powermate.c b/drivers/input/misc/powermate.c</span>
<span class="p_header">index 63b539d3daba..84909a12ff36 100644</span>
<span class="p_header">--- a/drivers/input/misc/powermate.c</span>
<span class="p_header">+++ b/drivers/input/misc/powermate.c</span>
<span class="p_chunk">@@ -307,6 +307,9 @@</span> <span class="p_context"> static int powermate_probe(struct usb_interface *intf, const struct usb_device_i</span>
 	int error = -ENOMEM;
 
 	interface = intf-&gt;cur_altsetting;
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	endpoint = &amp;interface-&gt;endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -EIO;
<span class="p_header">diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c</span>
<span class="p_header">index 6025eb430c0a..a41d8328c064 100644</span>
<span class="p_header">--- a/drivers/input/mouse/synaptics.c</span>
<span class="p_header">+++ b/drivers/input/mouse/synaptics.c</span>
<span class="p_chunk">@@ -862,8 +862,9 @@</span> <span class="p_context"> static void synaptics_report_ext_buttons(struct psmouse *psmouse,</span>
 	if (!SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap))
 		return;
 
<span class="p_del">-	/* Bug in FW 8.1, buttons are reported only when ExtBit is 1 */</span>
<span class="p_del">-	if (SYN_ID_FULL(priv-&gt;identity) == 0x801 &amp;&amp;</span>
<span class="p_add">+	/* Bug in FW 8.1 &amp; 8.2, buttons are reported only when ExtBit is 1 */</span>
<span class="p_add">+	if ((SYN_ID_FULL(priv-&gt;identity) == 0x801 ||</span>
<span class="p_add">+	     SYN_ID_FULL(priv-&gt;identity) == 0x802) &amp;&amp;</span>
 	    !((psmouse-&gt;packet[0] ^ psmouse-&gt;packet[3]) &amp; 0x02))
 		return;
 
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 8d0ead98eb6e..a296425a7270 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1015,8 +1015,12 @@</span> <span class="p_context"> int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c)</span>
 	 */
 	atomic_set(&amp;dc-&gt;count, 1);
 
<span class="p_del">-	if (bch_cached_dev_writeback_start(dc))</span>
<span class="p_add">+	/* Block writeback thread, but spawn it */</span>
<span class="p_add">+	down_write(&amp;dc-&gt;writeback_lock);</span>
<span class="p_add">+	if (bch_cached_dev_writeback_start(dc)) {</span>
<span class="p_add">+		up_write(&amp;dc-&gt;writeback_lock);</span>
 		return -ENOMEM;
<span class="p_add">+	}</span>
 
 	if (BDEV_STATE(&amp;dc-&gt;sb) == BDEV_STATE_DIRTY) {
 		bch_sectors_dirty_init(dc);
<span class="p_chunk">@@ -1028,6 +1032,9 @@</span> <span class="p_context"> int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c)</span>
 	bch_cached_dev_run(dc);
 	bcache_device_link(&amp;dc-&gt;disk, c, &quot;bdev&quot;);
 
<span class="p_add">+	/* Allow the writeback thread to proceed */</span>
<span class="p_add">+	up_write(&amp;dc-&gt;writeback_lock);</span>
<span class="p_add">+</span>
 	pr_info(&quot;Caching %s as %s on set %pU&quot;,
 		bdevname(dc-&gt;bdev, buf), dc-&gt;disk.disk-&gt;disk_name,
 		dc-&gt;disk.c-&gt;sb.set_uuid);
<span class="p_chunk">@@ -1366,6 +1373,9 @@</span> <span class="p_context"> static void cache_set_flush(struct closure *cl)</span>
 	struct btree *b;
 	unsigned i;
 
<span class="p_add">+	if (!c)</span>
<span class="p_add">+		closure_return(cl);</span>
<span class="p_add">+</span>
 	bch_cache_accounting_destroy(&amp;c-&gt;accounting);
 
 	kobject_put(&amp;c-&gt;internal);
<span class="p_chunk">@@ -1828,11 +1838,12 @@</span> <span class="p_context"> static int cache_alloc(struct cache_sb *sb, struct cache *ca)</span>
 	return 0;
 }
 
<span class="p_del">-static void register_cache(struct cache_sb *sb, struct page *sb_page,</span>
<span class="p_add">+static int register_cache(struct cache_sb *sb, struct page *sb_page,</span>
 				struct block_device *bdev, struct cache *ca)
 {
 	char name[BDEVNAME_SIZE];
<span class="p_del">-	const char *err = &quot;cannot allocate memory&quot;;</span>
<span class="p_add">+	const char *err = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	memcpy(&amp;ca-&gt;sb, sb, sizeof(struct cache_sb));
 	ca-&gt;bdev = bdev;
<span class="p_chunk">@@ -1847,27 +1858,35 @@</span> <span class="p_context"> static void register_cache(struct cache_sb *sb, struct page *sb_page,</span>
 	if (blk_queue_discard(bdev_get_queue(ca-&gt;bdev)))
 		ca-&gt;discard = CACHE_DISCARD(&amp;ca-&gt;sb);
 
<span class="p_del">-	if (cache_alloc(sb, ca) != 0)</span>
<span class="p_add">+	ret = cache_alloc(sb, ca);</span>
<span class="p_add">+	if (ret != 0)</span>
 		goto err;
 
<span class="p_del">-	err = &quot;error creating kobject&quot;;</span>
<span class="p_del">-	if (kobject_add(&amp;ca-&gt;kobj, &amp;part_to_dev(bdev-&gt;bd_part)-&gt;kobj, &quot;bcache&quot;))</span>
<span class="p_del">-		goto err;</span>
<span class="p_add">+	if (kobject_add(&amp;ca-&gt;kobj, &amp;part_to_dev(bdev-&gt;bd_part)-&gt;kobj, &quot;bcache&quot;)) {</span>
<span class="p_add">+		err = &quot;error calling kobject_add&quot;;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	mutex_lock(&amp;bch_register_lock);
 	err = register_cache_set(ca);
 	mutex_unlock(&amp;bch_register_lock);
 
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto err;</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	pr_info(&quot;registered cache device %s&quot;, bdevname(bdev, name));
<span class="p_add">+</span>
 out:
 	kobject_put(&amp;ca-&gt;kobj);
<span class="p_del">-	return;</span>
<span class="p_add">+</span>
 err:
<span class="p_del">-	pr_notice(&quot;error opening %s: %s&quot;, bdevname(bdev, name), err);</span>
<span class="p_del">-	goto out;</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		pr_notice(&quot;error opening %s: %s&quot;, bdevname(bdev, name), err);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /* Global interfaces/init */
<span class="p_chunk">@@ -1965,7 +1984,8 @@</span> <span class="p_context"> static ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,</span>
 		if (!ca)
 			goto err_close;
 
<span class="p_del">-		register_cache(sb, sb_page, bdev, ca);</span>
<span class="p_add">+		if (register_cache(sb, sb_page, bdev, ca) != 0)</span>
<span class="p_add">+			goto err_close;</span>
 	}
 out:
 	if (sb_page)
<span class="p_header">diff --git a/drivers/md/dm-cache-metadata.c b/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">index f6543f3a970f..27f2ef300f8b 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-metadata.c</span>
<span class="p_chunk">@@ -867,19 +867,40 @@</span> <span class="p_context"> static int blocks_are_unmapped_or_clean(struct dm_cache_metadata *cmd,</span>
 	return 0;
 }
 
<span class="p_del">-#define WRITE_LOCK(cmd) \</span>
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) \</span>
<span class="p_add">+#define WRITE_LOCK(cmd)	\</span>
<span class="p_add">+	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_add">+		up_write(&amp;cmd-&gt;root_lock); \</span>
 		return -EINVAL; \
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	}</span>
 
 #define WRITE_LOCK_VOID(cmd) \
<span class="p_del">-	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) \</span>
<span class="p_add">+	down_write(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_add">+		up_write(&amp;cmd-&gt;root_lock); \</span>
 		return; \
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+	}</span>
 
 #define WRITE_UNLOCK(cmd) \
 	up_write(&amp;cmd-&gt;root_lock)
 
<span class="p_add">+#define READ_LOCK(cmd) \</span>
<span class="p_add">+	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_add">+		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+		return -EINVAL; \</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_LOCK_VOID(cmd)	\</span>
<span class="p_add">+	down_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+	if (cmd-&gt;fail_io || dm_bm_is_read_only(cmd-&gt;bm)) { \</span>
<span class="p_add">+		up_read(&amp;cmd-&gt;root_lock); \</span>
<span class="p_add">+		return; \</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_UNLOCK(cmd) \</span>
<span class="p_add">+	up_read(&amp;cmd-&gt;root_lock)</span>
<span class="p_add">+</span>
 int dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size)
 {
 	int r;
<span class="p_chunk">@@ -1015,22 +1036,20 @@</span> <span class="p_context"> int dm_cache_load_discards(struct dm_cache_metadata *cmd,</span>
 {
 	int r;
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
 	r = __load_discards(cmd, fn, context);
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
 	return r;
 }
 
<span class="p_del">-dm_cblock_t dm_cache_size(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+int dm_cache_size(struct dm_cache_metadata *cmd, dm_cblock_t *result)</span>
 {
<span class="p_del">-	dm_cblock_t r;</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
<span class="p_add">+	*result = cmd-&gt;cache_blocks;</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_del">-	r = cmd-&gt;cache_blocks;</span>
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int __remove(struct dm_cache_metadata *cmd, dm_cblock_t cblock)
<span class="p_chunk">@@ -1188,9 +1207,9 @@</span> <span class="p_context"> int dm_cache_load_mappings(struct dm_cache_metadata *cmd,</span>
 {
 	int r;
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
 	r = __load_mappings(cmd, policy, fn, context);
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -1215,18 +1234,18 @@</span> <span class="p_context"> static int __dump_mappings(struct dm_cache_metadata *cmd)</span>
 
 void dm_cache_dump(struct dm_cache_metadata *cmd)
 {
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK_VOID(cmd);</span>
 	__dump_mappings(cmd);
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 }
 
 int dm_cache_changed_this_transaction(struct dm_cache_metadata *cmd)
 {
 	int r;
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
 	r = cmd-&gt;changed;
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -1276,9 +1295,9 @@</span> <span class="p_context"> int dm_cache_set_dirty(struct dm_cache_metadata *cmd,</span>
 void dm_cache_metadata_get_stats(struct dm_cache_metadata *cmd,
 				 struct dm_cache_statistics *stats)
 {
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK_VOID(cmd);</span>
 	*stats = cmd-&gt;stats;
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 }
 
 void dm_cache_metadata_set_stats(struct dm_cache_metadata *cmd,
<span class="p_chunk">@@ -1312,9 +1331,9 @@</span> <span class="p_context"> int dm_cache_get_free_metadata_block_count(struct dm_cache_metadata *cmd,</span>
 {
 	int r = -EINVAL;
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
 	r = dm_sm_get_nr_free(cmd-&gt;metadata_sm, result);
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -1324,9 +1343,9 @@</span> <span class="p_context"> int dm_cache_get_metadata_dev_size(struct dm_cache_metadata *cmd,</span>
 {
 	int r = -EINVAL;
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
 	r = dm_sm_get_nr_blocks(cmd-&gt;metadata_sm, result);
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
 	return r;
 }
<span class="p_chunk">@@ -1417,7 +1436,13 @@</span> <span class="p_context"> int dm_cache_write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *</span>
 
 int dm_cache_metadata_all_clean(struct dm_cache_metadata *cmd, bool *result)
 {
<span class="p_del">-	return blocks_are_unmapped_or_clean(cmd, 0, cmd-&gt;cache_blocks, result);</span>
<span class="p_add">+	int r;</span>
<span class="p_add">+</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
<span class="p_add">+	r = blocks_are_unmapped_or_clean(cmd, 0, cmd-&gt;cache_blocks, result);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
 }
 
 void dm_cache_metadata_set_read_only(struct dm_cache_metadata *cmd)
<span class="p_chunk">@@ -1440,10 +1465,7 @@</span> <span class="p_context"> int dm_cache_metadata_set_needs_check(struct dm_cache_metadata *cmd)</span>
 	struct dm_block *sblock;
 	struct cache_disk_superblock *disk_super;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We ignore fail_io for this function.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	down_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	WRITE_LOCK(cmd);</span>
 	set_bit(NEEDS_CHECK, &amp;cmd-&gt;flags);
 
 	r = superblock_lock(cmd, &amp;sblock);
<span class="p_chunk">@@ -1458,19 +1480,17 @@</span> <span class="p_context"> int dm_cache_metadata_set_needs_check(struct dm_cache_metadata *cmd)</span>
 	dm_bm_unlock(sblock);
 
 out:
<span class="p_del">-	up_write(&amp;cmd-&gt;root_lock);</span>
<span class="p_add">+	WRITE_UNLOCK(cmd);</span>
 	return r;
 }
 
<span class="p_del">-bool dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd)</span>
<span class="p_add">+int dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd, bool *result)</span>
 {
<span class="p_del">-	bool needs_check;</span>
<span class="p_add">+	READ_LOCK(cmd);</span>
<span class="p_add">+	*result = !!test_bit(NEEDS_CHECK, &amp;cmd-&gt;flags);</span>
<span class="p_add">+	READ_UNLOCK(cmd);</span>
 
<span class="p_del">-	down_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_del">-	needs_check = !!test_bit(NEEDS_CHECK, &amp;cmd-&gt;flags);</span>
<span class="p_del">-	up_read(&amp;cmd-&gt;root_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return needs_check;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int dm_cache_metadata_abort(struct dm_cache_metadata *cmd)
<span class="p_header">diff --git a/drivers/md/dm-cache-metadata.h b/drivers/md/dm-cache-metadata.h</span>
<span class="p_header">index 2ffee21f318d..8528744195e5 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-metadata.h</span>
<span class="p_header">+++ b/drivers/md/dm-cache-metadata.h</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> void dm_cache_metadata_close(struct dm_cache_metadata *cmd);</span>
  * origin blocks to map to.
  */
 int dm_cache_resize(struct dm_cache_metadata *cmd, dm_cblock_t new_cache_size);
<span class="p_del">-dm_cblock_t dm_cache_size(struct dm_cache_metadata *cmd);</span>
<span class="p_add">+int dm_cache_size(struct dm_cache_metadata *cmd, dm_cblock_t *result);</span>
 
 int dm_cache_discard_bitset_resize(struct dm_cache_metadata *cmd,
 				   sector_t discard_block_size,
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> int dm_cache_write_hints(struct dm_cache_metadata *cmd, struct dm_cache_policy *</span>
  */
 int dm_cache_metadata_all_clean(struct dm_cache_metadata *cmd, bool *result);
 
<span class="p_del">-bool dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd);</span>
<span class="p_add">+int dm_cache_metadata_needs_check(struct dm_cache_metadata *cmd, bool *result);</span>
 int dm_cache_metadata_set_needs_check(struct dm_cache_metadata *cmd);
 void dm_cache_metadata_set_read_only(struct dm_cache_metadata *cmd);
 void dm_cache_metadata_set_read_write(struct dm_cache_metadata *cmd);
<span class="p_header">diff --git a/drivers/md/dm-cache-target.c b/drivers/md/dm-cache-target.c</span>
<span class="p_header">index 2fd4c8296144..515f83e7d9ab 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-target.c</span>
<span class="p_chunk">@@ -987,9 +987,14 @@</span> <span class="p_context"> static void notify_mode_switch(struct cache *cache, enum cache_metadata_mode mod</span>
 
 static void set_cache_mode(struct cache *cache, enum cache_metadata_mode new_mode)
 {
<span class="p_del">-	bool needs_check = dm_cache_metadata_needs_check(cache-&gt;cmd);</span>
<span class="p_add">+	bool needs_check;</span>
 	enum cache_metadata_mode old_mode = get_cache_mode(cache);
 
<span class="p_add">+	if (dm_cache_metadata_needs_check(cache-&gt;cmd, &amp;needs_check)) {</span>
<span class="p_add">+		DMERR(&quot;unable to read needs_check flag, setting failure mode&quot;);</span>
<span class="p_add">+		new_mode = CM_FAIL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (new_mode == CM_WRITE &amp;&amp; needs_check) {
 		DMERR(&quot;%s: unable to switch cache to write mode until repaired.&quot;,
 		      cache_device_name(cache));
<span class="p_chunk">@@ -3513,6 +3518,7 @@</span> <span class="p_context"> static void cache_status(struct dm_target *ti, status_type_t type,</span>
 	char buf[BDEVNAME_SIZE];
 	struct cache *cache = ti-&gt;private;
 	dm_cblock_t residency;
<span class="p_add">+	bool needs_check;</span>
 
 	switch (type) {
 	case STATUSTYPE_INFO:
<span class="p_chunk">@@ -3586,7 +3592,9 @@</span> <span class="p_context"> static void cache_status(struct dm_target *ti, status_type_t type,</span>
 		else
 			DMEMIT(&quot;rw &quot;);
 
<span class="p_del">-		if (dm_cache_metadata_needs_check(cache-&gt;cmd))</span>
<span class="p_add">+		r = dm_cache_metadata_needs_check(cache-&gt;cmd, &amp;needs_check);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (r || needs_check)</span>
 			DMEMIT(&quot;needs_check &quot;);
 		else
 			DMEMIT(&quot;- &quot;);
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index 61f184ad081c..e108deebbaaa 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1106,6 +1106,7 @@</span> <span class="p_context"> static int snapshot_ctr(struct dm_target *ti, unsigned int argc, char **argv)</span>
 	int i;
 	int r = -EINVAL;
 	char *origin_path, *cow_path;
<span class="p_add">+	dev_t origin_dev, cow_dev;</span>
 	unsigned args_used, num_flush_bios = 1;
 	fmode_t origin_mode = FMODE_READ;
 
<span class="p_chunk">@@ -1136,11 +1137,19 @@</span> <span class="p_context"> static int snapshot_ctr(struct dm_target *ti, unsigned int argc, char **argv)</span>
 		ti-&gt;error = &quot;Cannot get origin device&quot;;
 		goto bad_origin;
 	}
<span class="p_add">+	origin_dev = s-&gt;origin-&gt;bdev-&gt;bd_dev;</span>
 
 	cow_path = argv[0];
 	argv++;
 	argc--;
 
<span class="p_add">+	cow_dev = dm_get_dev_t(cow_path);</span>
<span class="p_add">+	if (cow_dev &amp;&amp; cow_dev == origin_dev) {</span>
<span class="p_add">+		ti-&gt;error = &quot;COW device cannot be the same as origin device&quot;;</span>
<span class="p_add">+		r = -EINVAL;</span>
<span class="p_add">+		goto bad_cow;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	r = dm_get_device(ti, cow_path, dm_table_get_mode(ti-&gt;table), &amp;s-&gt;cow);
 	if (r) {
 		ti-&gt;error = &quot;Cannot get COW device&quot;;
<span class="p_header">diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c</span>
<span class="p_header">index 061152a43730..cb5d0daf53bb 100644</span>
<span class="p_header">--- a/drivers/md/dm-table.c</span>
<span class="p_header">+++ b/drivers/md/dm-table.c</span>
<span class="p_chunk">@@ -365,6 +365,26 @@</span> <span class="p_context"> static int upgrade_mode(struct dm_dev_internal *dd, fmode_t new_mode,</span>
 }
 
 /*
<span class="p_add">+ * Convert the path to a device</span>
<span class="p_add">+ */</span>
<span class="p_add">+dev_t dm_get_dev_t(const char *path)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dev_t uninitialized_var(dev);</span>
<span class="p_add">+	struct block_device *bdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	bdev = lookup_bdev(path);</span>
<span class="p_add">+	if (IS_ERR(bdev))</span>
<span class="p_add">+		dev = name_to_dev_t(path);</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		dev = bdev-&gt;bd_dev;</span>
<span class="p_add">+		bdput(bdev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return dev;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(dm_get_dev_t);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Add a device to the list, or just increment the usage count if
  * it&#39;s already present.
  */
<span class="p_chunk">@@ -372,23 +392,15 @@</span> <span class="p_context"> int dm_get_device(struct dm_target *ti, const char *path, fmode_t mode,</span>
 		  struct dm_dev **result)
 {
 	int r;
<span class="p_del">-	dev_t uninitialized_var(dev);</span>
<span class="p_add">+	dev_t dev;</span>
 	struct dm_dev_internal *dd;
 	struct dm_table *t = ti-&gt;table;
<span class="p_del">-	struct block_device *bdev;</span>
 
 	BUG_ON(!t);
 
<span class="p_del">-	/* convert the path to a device */</span>
<span class="p_del">-	bdev = lookup_bdev(path);</span>
<span class="p_del">-	if (IS_ERR(bdev)) {</span>
<span class="p_del">-		dev = name_to_dev_t(path);</span>
<span class="p_del">-		if (!dev)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		dev = bdev-&gt;bd_dev;</span>
<span class="p_del">-		bdput(bdev);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	dev = dm_get_dev_t(path);</span>
<span class="p_add">+	if (!dev)</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	dd = find_device(&amp;t-&gt;devices, dev);
 	if (!dd) {
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index c219a053c7f6..911ada643364 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1943,5 +1943,8 @@</span> <span class="p_context"> bool dm_pool_metadata_needs_check(struct dm_pool_metadata *pmd)</span>
 
 void dm_pool_issue_prefetches(struct dm_pool_metadata *pmd)
 {
<span class="p_del">-	dm_tm_issue_prefetches(pmd-&gt;tm);</span>
<span class="p_add">+	down_read(&amp;pmd-&gt;root_lock);</span>
<span class="p_add">+	if (!pmd-&gt;fail_io)</span>
<span class="p_add">+		dm_tm_issue_prefetches(pmd-&gt;tm);</span>
<span class="p_add">+	up_read(&amp;pmd-&gt;root_lock);</span>
 }
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index dd834927bc66..c338aebb4ccd 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1109,12 +1109,8 @@</span> <span class="p_context"> static void rq_completed(struct mapped_device *md, int rw, bool run_queue)</span>
 	 * back into -&gt;request_fn() could deadlock attempting to grab the
 	 * queue lock again.
 	 */
<span class="p_del">-	if (run_queue) {</span>
<span class="p_del">-		if (md-&gt;queue-&gt;mq_ops)</span>
<span class="p_del">-			blk_mq_run_hw_queues(md-&gt;queue, true);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			blk_run_queue_async(md-&gt;queue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!md-&gt;queue-&gt;mq_ops &amp;&amp; run_queue)</span>
<span class="p_add">+		blk_run_queue_async(md-&gt;queue);</span>
 
 	/*
 	 * dm_put() must be at the end of this function. See the comment above
<span class="p_chunk">@@ -1214,9 +1210,9 @@</span> <span class="p_context"> static void dm_requeue_original_request(struct mapped_device *md,</span>
 {
 	int rw = rq_data_dir(rq);
 
<span class="p_add">+	rq_end_stats(md, rq);</span>
 	dm_unprep_request(rq);
 
<span class="p_del">-	rq_end_stats(md, rq);</span>
 	if (!rq-&gt;q-&gt;mq_ops)
 		old_requeue_request(rq);
 	else {
<span class="p_chunk">@@ -1336,7 +1332,10 @@</span> <span class="p_context"> static void dm_complete_request(struct request *rq, int error)</span>
 	struct dm_rq_target_io *tio = tio_from_request(rq);
 
 	tio-&gt;error = error;
<span class="p_del">-	blk_complete_request(rq);</span>
<span class="p_add">+	if (!rq-&gt;q-&gt;mq_ops)</span>
<span class="p_add">+		blk_complete_request(rq);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		blk_mq_complete_request(rq, error);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/multipath.c b/drivers/md/multipath.c</span>
<span class="p_header">index 0a72ab6e6c20..dd483bb2e111 100644</span>
<span class="p_header">--- a/drivers/md/multipath.c</span>
<span class="p_header">+++ b/drivers/md/multipath.c</span>
<span class="p_chunk">@@ -129,7 +129,9 @@</span> <span class="p_context"> static void multipath_make_request(struct mddev *mddev, struct bio * bio)</span>
 	}
 	multipath = conf-&gt;multipaths + mp_bh-&gt;path;
 
<span class="p_del">-	mp_bh-&gt;bio = *bio;</span>
<span class="p_add">+	bio_init(&amp;mp_bh-&gt;bio);</span>
<span class="p_add">+	__bio_clone_fast(&amp;mp_bh-&gt;bio, bio);</span>
<span class="p_add">+</span>
 	mp_bh-&gt;bio.bi_iter.bi_sector += multipath-&gt;rdev-&gt;data_offset;
 	mp_bh-&gt;bio.bi_bdev = multipath-&gt;rdev-&gt;bdev;
 	mp_bh-&gt;bio.bi_rw |= REQ_FAILFAST_TRANSPORT;
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index c4b913409226..515554c7365b 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -2274,6 +2274,7 @@</span> <span class="p_context"> static void handle_write_finished(struct r1conf *conf, struct r1bio *r1_bio)</span>
 	if (fail) {
 		spin_lock_irq(&amp;conf-&gt;device_lock);
 		list_add(&amp;r1_bio-&gt;retry_list, &amp;conf-&gt;bio_end_io_list);
<span class="p_add">+		conf-&gt;nr_queued++;</span>
 		spin_unlock_irq(&amp;conf-&gt;device_lock);
 		md_wakeup_thread(conf-&gt;mddev-&gt;thread);
 	} else {
<span class="p_chunk">@@ -2391,8 +2392,10 @@</span> <span class="p_context"> static void raid1d(struct md_thread *thread)</span>
 		LIST_HEAD(tmp);
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (!test_bit(MD_CHANGE_PENDING, &amp;mddev-&gt;flags)) {
<span class="p_del">-			list_add(&amp;tmp, &amp;conf-&gt;bio_end_io_list);</span>
<span class="p_del">-			list_del_init(&amp;conf-&gt;bio_end_io_list);</span>
<span class="p_add">+			while (!list_empty(&amp;conf-&gt;bio_end_io_list)) {</span>
<span class="p_add">+				list_move(conf-&gt;bio_end_io_list.prev, &amp;tmp);</span>
<span class="p_add">+				conf-&gt;nr_queued--;</span>
<span class="p_add">+			}</span>
 		}
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 		while (!list_empty(&amp;tmp)) {
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index ce959b4ae4df..ebb0dd612ebd 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -2664,6 +2664,7 @@</span> <span class="p_context"> static void handle_write_completed(struct r10conf *conf, struct r10bio *r10_bio)</span>
 		if (fail) {
 			spin_lock_irq(&amp;conf-&gt;device_lock);
 			list_add(&amp;r10_bio-&gt;retry_list, &amp;conf-&gt;bio_end_io_list);
<span class="p_add">+			conf-&gt;nr_queued++;</span>
 			spin_unlock_irq(&amp;conf-&gt;device_lock);
 			md_wakeup_thread(conf-&gt;mddev-&gt;thread);
 		} else {
<span class="p_chunk">@@ -2691,8 +2692,10 @@</span> <span class="p_context"> static void raid10d(struct md_thread *thread)</span>
 		LIST_HEAD(tmp);
 		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
 		if (!test_bit(MD_CHANGE_PENDING, &amp;mddev-&gt;flags)) {
<span class="p_del">-			list_add(&amp;tmp, &amp;conf-&gt;bio_end_io_list);</span>
<span class="p_del">-			list_del_init(&amp;conf-&gt;bio_end_io_list);</span>
<span class="p_add">+			while (!list_empty(&amp;conf-&gt;bio_end_io_list)) {</span>
<span class="p_add">+				list_move(conf-&gt;bio_end_io_list.prev, &amp;tmp);</span>
<span class="p_add">+				conf-&gt;nr_queued--;</span>
<span class="p_add">+			}</span>
 		}
 		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 		while (!list_empty(&amp;tmp)) {
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 704ef7fcfbf8..10ce885445f6 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -340,8 +340,7 @@</span> <span class="p_context"> static void release_inactive_stripe_list(struct r5conf *conf,</span>
 					 int hash)
 {
 	int size;
<span class="p_del">-	unsigned long do_wakeup = 0;</span>
<span class="p_del">-	int i = 0;</span>
<span class="p_add">+	bool do_wakeup = false;</span>
 	unsigned long flags;
 
 	if (hash == NR_STRIPE_HASH_LOCKS) {
<span class="p_chunk">@@ -362,19 +361,15 @@</span> <span class="p_context"> static void release_inactive_stripe_list(struct r5conf *conf,</span>
 			    !list_empty(list))
 				atomic_dec(&amp;conf-&gt;empty_inactive_list_nr);
 			list_splice_tail_init(list, conf-&gt;inactive_list + hash);
<span class="p_del">-			do_wakeup |= 1 &lt;&lt; hash;</span>
<span class="p_add">+			do_wakeup = true;</span>
 			spin_unlock_irqrestore(conf-&gt;hash_locks + hash, flags);
 		}
 		size--;
 		hash--;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; NR_STRIPE_HASH_LOCKS; i++) {</span>
<span class="p_del">-		if (do_wakeup &amp; (1 &lt;&lt; i))</span>
<span class="p_del">-			wake_up(&amp;conf-&gt;wait_for_stripe[i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (do_wakeup) {
<span class="p_add">+		wake_up(&amp;conf-&gt;wait_for_stripe);</span>
 		if (atomic_read(&amp;conf-&gt;active_stripes) == 0)
 			wake_up(&amp;conf-&gt;wait_for_quiescent);
 		if (conf-&gt;retry_read_aligned)
<span class="p_chunk">@@ -687,15 +682,14 @@</span> <span class="p_context"> raid5_get_active_stripe(struct r5conf *conf, sector_t sector,</span>
 			if (!sh) {
 				set_bit(R5_INACTIVE_BLOCKED,
 					&amp;conf-&gt;cache_state);
<span class="p_del">-				wait_event_exclusive_cmd(</span>
<span class="p_del">-					conf-&gt;wait_for_stripe[hash],</span>
<span class="p_add">+				wait_event_lock_irq(</span>
<span class="p_add">+					conf-&gt;wait_for_stripe,</span>
 					!list_empty(conf-&gt;inactive_list + hash) &amp;&amp;
 					(atomic_read(&amp;conf-&gt;active_stripes)
 					 &lt; (conf-&gt;max_nr_stripes * 3 / 4)
 					 || !test_bit(R5_INACTIVE_BLOCKED,
 						      &amp;conf-&gt;cache_state)),
<span class="p_del">-					spin_unlock_irq(conf-&gt;hash_locks + hash),</span>
<span class="p_del">-					spin_lock_irq(conf-&gt;hash_locks + hash));</span>
<span class="p_add">+					*(conf-&gt;hash_locks + hash));</span>
 				clear_bit(R5_INACTIVE_BLOCKED,
 					  &amp;conf-&gt;cache_state);
 			} else {
<span class="p_chunk">@@ -720,9 +714,6 @@</span> <span class="p_context"> raid5_get_active_stripe(struct r5conf *conf, sector_t sector,</span>
 		}
 	} while (sh == NULL);
 
<span class="p_del">-	if (!list_empty(conf-&gt;inactive_list + hash))</span>
<span class="p_del">-		wake_up(&amp;conf-&gt;wait_for_stripe[hash]);</span>
<span class="p_del">-</span>
 	spin_unlock_irq(conf-&gt;hash_locks + hash);
 	return sh;
 }
<span class="p_chunk">@@ -2091,6 +2082,14 @@</span> <span class="p_context"> static int resize_chunks(struct r5conf *conf, int new_disks, int new_sectors)</span>
 	unsigned long cpu;
 	int err = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Never shrink. And mddev_suspend() could deadlock if this is called</span>
<span class="p_add">+	 * from raid5d. In that case, scribble_disks and scribble_sectors</span>
<span class="p_add">+	 * should equal to new_disks and new_sectors</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (conf-&gt;scribble_disks &gt;= new_disks &amp;&amp;</span>
<span class="p_add">+	    conf-&gt;scribble_sectors &gt;= new_sectors)</span>
<span class="p_add">+		return 0;</span>
 	mddev_suspend(conf-&gt;mddev);
 	get_online_cpus();
 	for_each_present_cpu(cpu) {
<span class="p_chunk">@@ -2112,6 +2111,10 @@</span> <span class="p_context"> static int resize_chunks(struct r5conf *conf, int new_disks, int new_sectors)</span>
 	}
 	put_online_cpus();
 	mddev_resume(conf-&gt;mddev);
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		conf-&gt;scribble_disks = new_disks;</span>
<span class="p_add">+		conf-&gt;scribble_sectors = new_sectors;</span>
<span class="p_add">+	}</span>
 	return err;
 }
 
<span class="p_chunk">@@ -2192,7 +2195,7 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 	cnt = 0;
 	list_for_each_entry(nsh, &amp;newstripes, lru) {
 		lock_device_hash_lock(conf, hash);
<span class="p_del">-		wait_event_exclusive_cmd(conf-&gt;wait_for_stripe[hash],</span>
<span class="p_add">+		wait_event_cmd(conf-&gt;wait_for_stripe,</span>
 				    !list_empty(conf-&gt;inactive_list + hash),
 				    unlock_device_hash_lock(conf, hash),
 				    lock_device_hash_lock(conf, hash));
<span class="p_chunk">@@ -4238,7 +4241,6 @@</span> <span class="p_context"> static void break_stripe_batch_list(struct stripe_head *head_sh,</span>
 		WARN_ON_ONCE(sh-&gt;state &amp; ((1 &lt;&lt; STRIPE_ACTIVE) |
 					  (1 &lt;&lt; STRIPE_SYNCING) |
 					  (1 &lt;&lt; STRIPE_REPLACED) |
<span class="p_del">-					  (1 &lt;&lt; STRIPE_PREREAD_ACTIVE) |</span>
 					  (1 &lt;&lt; STRIPE_DELAYED) |
 					  (1 &lt;&lt; STRIPE_BIT_DELAY) |
 					  (1 &lt;&lt; STRIPE_FULL_WRITE) |
<span class="p_chunk">@@ -4253,6 +4255,7 @@</span> <span class="p_context"> static void break_stripe_batch_list(struct stripe_head *head_sh,</span>
 					      (1 &lt;&lt; STRIPE_REPLACED)));
 
 		set_mask_bits(&amp;sh-&gt;state, ~(STRIPE_EXPAND_SYNC_FLAGS |
<span class="p_add">+					    (1 &lt;&lt; STRIPE_PREREAD_ACTIVE) |</span>
 					    (1 &lt;&lt; STRIPE_DEGRADED)),
 			      head_sh-&gt;state &amp; (1 &lt;&lt; STRIPE_INSYNC));
 
<span class="p_chunk">@@ -6414,6 +6417,12 @@</span> <span class="p_context"> static int raid5_alloc_percpu(struct r5conf *conf)</span>
 	}
 	put_online_cpus();
 
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		conf-&gt;scribble_disks = max(conf-&gt;raid_disks,</span>
<span class="p_add">+			conf-&gt;previous_raid_disks);</span>
<span class="p_add">+		conf-&gt;scribble_sectors = max(conf-&gt;chunk_sectors,</span>
<span class="p_add">+			conf-&gt;prev_chunk_sectors);</span>
<span class="p_add">+	}</span>
 	return err;
 }
 
<span class="p_chunk">@@ -6504,9 +6513,7 @@</span> <span class="p_context"> static struct r5conf *setup_conf(struct mddev *mddev)</span>
 	seqcount_init(&amp;conf-&gt;gen_lock);
 	mutex_init(&amp;conf-&gt;cache_size_mutex);
 	init_waitqueue_head(&amp;conf-&gt;wait_for_quiescent);
<span class="p_del">-	for (i = 0; i &lt; NR_STRIPE_HASH_LOCKS; i++) {</span>
<span class="p_del">-		init_waitqueue_head(&amp;conf-&gt;wait_for_stripe[i]);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	init_waitqueue_head(&amp;conf-&gt;wait_for_stripe);</span>
 	init_waitqueue_head(&amp;conf-&gt;wait_for_overlap);
 	INIT_LIST_HEAD(&amp;conf-&gt;handle_list);
 	INIT_LIST_HEAD(&amp;conf-&gt;hold_list);
<span class="p_chunk">@@ -7015,8 +7022,8 @@</span> <span class="p_context"> static int run(struct mddev *mddev)</span>
 		}
 
 		if (discard_supported &amp;&amp;
<span class="p_del">-		   mddev-&gt;queue-&gt;limits.max_discard_sectors &gt;= stripe &amp;&amp;</span>
<span class="p_del">-		   mddev-&gt;queue-&gt;limits.discard_granularity &gt;= stripe)</span>
<span class="p_add">+		    mddev-&gt;queue-&gt;limits.max_discard_sectors &gt;= (stripe &gt;&gt; 9) &amp;&amp;</span>
<span class="p_add">+		    mddev-&gt;queue-&gt;limits.discard_granularity &gt;= stripe)</span>
 			queue_flag_set_unlocked(QUEUE_FLAG_DISCARD,
 						mddev-&gt;queue);
 		else
<span class="p_header">diff --git a/drivers/md/raid5.h b/drivers/md/raid5.h</span>
<span class="p_header">index a415e1cd39b8..517d4b68a1be 100644</span>
<span class="p_header">--- a/drivers/md/raid5.h</span>
<span class="p_header">+++ b/drivers/md/raid5.h</span>
<span class="p_chunk">@@ -510,6 +510,8 @@</span> <span class="p_context"> struct r5conf {</span>
 					      * conversions
 					      */
 	} __percpu *percpu;
<span class="p_add">+	int scribble_disks;</span>
<span class="p_add">+	int scribble_sectors;</span>
 #ifdef CONFIG_HOTPLUG_CPU
 	struct notifier_block	cpu_notify;
 #endif
<span class="p_chunk">@@ -522,7 +524,7 @@</span> <span class="p_context"> struct r5conf {</span>
 	atomic_t		empty_inactive_list_nr;
 	struct llist_head	released_stripes;
 	wait_queue_head_t	wait_for_quiescent;
<span class="p_del">-	wait_queue_head_t	wait_for_stripe[NR_STRIPE_HASH_LOCKS];</span>
<span class="p_add">+	wait_queue_head_t	wait_for_stripe;</span>
 	wait_queue_head_t	wait_for_overlap;
 	unsigned long		cache_state;
 #define R5_INACTIVE_BLOCKED	1	/* release of inactive stripes blocked,
<span class="p_header">diff --git a/drivers/media/i2c/adv7511.c b/drivers/media/i2c/adv7511.c</span>
<span class="p_header">index e4900df1140b..c24839cfcc35 100644</span>
<span class="p_header">--- a/drivers/media/i2c/adv7511.c</span>
<span class="p_header">+++ b/drivers/media/i2c/adv7511.c</span>
<span class="p_chunk">@@ -1161,12 +1161,23 @@</span> <span class="p_context"> static void adv7511_dbg_dump_edid(int lvl, int debug, struct v4l2_subdev *sd, in</span>
 	}
 }
 
<span class="p_add">+static void adv7511_notify_no_edid(struct v4l2_subdev *sd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct adv7511_state *state = get_adv7511_state(sd);</span>
<span class="p_add">+	struct adv7511_edid_detect ed;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We failed to read the EDID, so send an event for this. */</span>
<span class="p_add">+	ed.present = false;</span>
<span class="p_add">+	ed.segment = adv7511_rd(sd, 0xc4);</span>
<span class="p_add">+	v4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&amp;ed);</span>
<span class="p_add">+	v4l2_ctrl_s_ctrl(state-&gt;have_edid0_ctrl, 0x0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void adv7511_edid_handler(struct work_struct *work)
 {
 	struct delayed_work *dwork = to_delayed_work(work);
 	struct adv7511_state *state = container_of(dwork, struct adv7511_state, edid_handler);
 	struct v4l2_subdev *sd = &amp;state-&gt;sd;
<span class="p_del">-	struct adv7511_edid_detect ed;</span>
 
 	v4l2_dbg(1, debug, sd, &quot;%s:\n&quot;, __func__);
 
<span class="p_chunk">@@ -1191,9 +1202,7 @@</span> <span class="p_context"> static void adv7511_edid_handler(struct work_struct *work)</span>
 	}
 
 	/* We failed to read the EDID, so send an event for this. */
<span class="p_del">-	ed.present = false;</span>
<span class="p_del">-	ed.segment = adv7511_rd(sd, 0xc4);</span>
<span class="p_del">-	v4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&amp;ed);</span>
<span class="p_add">+	adv7511_notify_no_edid(sd);</span>
 	v4l2_dbg(1, debug, sd, &quot;%s: no edid found\n&quot;, __func__);
 }
 
<span class="p_chunk">@@ -1264,7 +1273,6 @@</span> <span class="p_context"> static void adv7511_check_monitor_present_status(struct v4l2_subdev *sd)</span>
 	/* update read only ctrls */
 	v4l2_ctrl_s_ctrl(state-&gt;hotplug_ctrl, adv7511_have_hotplug(sd) ? 0x1 : 0x0);
 	v4l2_ctrl_s_ctrl(state-&gt;rx_sense_ctrl, adv7511_have_rx_sense(sd) ? 0x1 : 0x0);
<span class="p_del">-	v4l2_ctrl_s_ctrl(state-&gt;have_edid0_ctrl, state-&gt;edid.segments ? 0x1 : 0x0);</span>
 
 	if ((status &amp; MASK_ADV7511_HPD_DETECT) &amp;&amp; ((status &amp; MASK_ADV7511_MSEN_DETECT) || state-&gt;edid.segments)) {
 		v4l2_dbg(1, debug, sd, &quot;%s: hotplug and (rx-sense or edid)\n&quot;, __func__);
<span class="p_chunk">@@ -1294,6 +1302,7 @@</span> <span class="p_context"> static void adv7511_check_monitor_present_status(struct v4l2_subdev *sd)</span>
 		}
 		adv7511_s_power(sd, false);
 		memset(&amp;state-&gt;edid, 0, sizeof(struct adv7511_state_edid));
<span class="p_add">+		adv7511_notify_no_edid(sd);</span>
 	}
 }
 
<span class="p_chunk">@@ -1370,6 +1379,7 @@</span> <span class="p_context"> static bool adv7511_check_edid_status(struct v4l2_subdev *sd)</span>
 		}
 		/* one more segment read ok */
 		state-&gt;edid.segments = segment + 1;
<span class="p_add">+		v4l2_ctrl_s_ctrl(state-&gt;have_edid0_ctrl, 0x1);</span>
 		if (((state-&gt;edid.data[0x7e] &gt;&gt; 1) + 1) &gt; state-&gt;edid.segments) {
 			/* Request next EDID segment */
 			v4l2_dbg(1, debug, sd, &quot;%s: request segment %d\n&quot;, __func__, state-&gt;edid.segments);
<span class="p_chunk">@@ -1389,7 +1399,6 @@</span> <span class="p_context"> static bool adv7511_check_edid_status(struct v4l2_subdev *sd)</span>
 		ed.present = true;
 		ed.segment = 0;
 		state-&gt;edid_detect_counter++;
<span class="p_del">-		v4l2_ctrl_s_ctrl(state-&gt;have_edid0_ctrl, state-&gt;edid.segments ? 0x1 : 0x0);</span>
 		v4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&amp;ed);
 		return ed.present;
 	}
<span class="p_header">diff --git a/drivers/media/pci/bt8xx/bttv-driver.c b/drivers/media/pci/bt8xx/bttv-driver.c</span>
<span class="p_header">index 15a4ebc2844d..51dbef2f9a48 100644</span>
<span class="p_header">--- a/drivers/media/pci/bt8xx/bttv-driver.c</span>
<span class="p_header">+++ b/drivers/media/pci/bt8xx/bttv-driver.c</span>
<span class="p_chunk">@@ -2334,6 +2334,19 @@</span> <span class="p_context"> static int bttv_g_fmt_vid_overlay(struct file *file, void *priv,</span>
 	return 0;
 }
 
<span class="p_add">+static void bttv_get_width_mask_vid_cap(const struct bttv_format *fmt,</span>
<span class="p_add">+					unsigned int *width_mask,</span>
<span class="p_add">+					unsigned int *width_bias)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (fmt-&gt;flags &amp; FORMAT_FLAGS_PLANAR) {</span>
<span class="p_add">+		*width_mask = ~15; /* width must be a multiple of 16 pixels */</span>
<span class="p_add">+		*width_bias = 8;   /* nearest */</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		*width_mask = ~3; /* width must be a multiple of 4 pixels */</span>
<span class="p_add">+		*width_bias = 2;  /* nearest */</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bttv_try_fmt_vid_cap(struct file *file, void *priv,
 						struct v4l2_format *f)
 {
<span class="p_chunk">@@ -2343,6 +2356,7 @@</span> <span class="p_context"> static int bttv_try_fmt_vid_cap(struct file *file, void *priv,</span>
 	enum v4l2_field field;
 	__s32 width, height;
 	__s32 height2;
<span class="p_add">+	unsigned int width_mask, width_bias;</span>
 	int rc;
 
 	fmt = format_by_fourcc(f-&gt;fmt.pix.pixelformat);
<span class="p_chunk">@@ -2375,9 +2389,9 @@</span> <span class="p_context"> static int bttv_try_fmt_vid_cap(struct file *file, void *priv,</span>
 	width = f-&gt;fmt.pix.width;
 	height = f-&gt;fmt.pix.height;
 
<span class="p_add">+	bttv_get_width_mask_vid_cap(fmt, &amp;width_mask, &amp;width_bias);</span>
 	rc = limit_scaled_size_lock(fh, &amp;width, &amp;height, field,
<span class="p_del">-			       /* width_mask: 4 pixels */ ~3,</span>
<span class="p_del">-			       /* width_bias: nearest */ 2,</span>
<span class="p_add">+			       width_mask, width_bias,</span>
 			       /* adjust_size */ 1,
 			       /* adjust_crop */ 0);
 	if (0 != rc)
<span class="p_chunk">@@ -2410,6 +2424,7 @@</span> <span class="p_context"> static int bttv_s_fmt_vid_cap(struct file *file, void *priv,</span>
 	struct bttv_fh *fh = priv;
 	struct bttv *btv = fh-&gt;btv;
 	__s32 width, height;
<span class="p_add">+	unsigned int width_mask, width_bias;</span>
 	enum v4l2_field field;
 
 	retval = bttv_switch_type(fh, f-&gt;type);
<span class="p_chunk">@@ -2424,9 +2439,10 @@</span> <span class="p_context"> static int bttv_s_fmt_vid_cap(struct file *file, void *priv,</span>
 	height = f-&gt;fmt.pix.height;
 	field = f-&gt;fmt.pix.field;
 
<span class="p_add">+	fmt = format_by_fourcc(f-&gt;fmt.pix.pixelformat);</span>
<span class="p_add">+	bttv_get_width_mask_vid_cap(fmt, &amp;width_mask, &amp;width_bias);</span>
 	retval = limit_scaled_size_lock(fh, &amp;width, &amp;height, f-&gt;fmt.pix.field,
<span class="p_del">-			       /* width_mask: 4 pixels */ ~3,</span>
<span class="p_del">-			       /* width_bias: nearest */ 2,</span>
<span class="p_add">+			       width_mask, width_bias,</span>
 			       /* adjust_size */ 1,
 			       /* adjust_crop */ 1);
 	if (0 != retval)
<span class="p_chunk">@@ -2434,8 +2450,6 @@</span> <span class="p_context"> static int bttv_s_fmt_vid_cap(struct file *file, void *priv,</span>
 
 	f-&gt;fmt.pix.field = field;
 
<span class="p_del">-	fmt = format_by_fourcc(f-&gt;fmt.pix.pixelformat);</span>
<span class="p_del">-</span>
 	/* update our state informations */
 	fh-&gt;fmt              = fmt;
 	fh-&gt;cap.field        = f-&gt;fmt.pix.field;
<span class="p_header">diff --git a/drivers/media/pci/saa7134/saa7134-video.c b/drivers/media/pci/saa7134/saa7134-video.c</span>
<span class="p_header">index 518086c7aed5..15e56c07b217 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7134/saa7134-video.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7134/saa7134-video.c</span>
<span class="p_chunk">@@ -1219,10 +1219,13 @@</span> <span class="p_context"> static int saa7134_g_fmt_vid_cap(struct file *file, void *priv,</span>
 	f-&gt;fmt.pix.height       = dev-&gt;height;
 	f-&gt;fmt.pix.field        = dev-&gt;field;
 	f-&gt;fmt.pix.pixelformat  = dev-&gt;fmt-&gt;fourcc;
<span class="p_del">-	f-&gt;fmt.pix.bytesperline =</span>
<span class="p_del">-		(f-&gt;fmt.pix.width * dev-&gt;fmt-&gt;depth) &gt;&gt; 3;</span>
<span class="p_add">+	if (dev-&gt;fmt-&gt;planar)</span>
<span class="p_add">+		f-&gt;fmt.pix.bytesperline = f-&gt;fmt.pix.width;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		f-&gt;fmt.pix.bytesperline =</span>
<span class="p_add">+			(f-&gt;fmt.pix.width * dev-&gt;fmt-&gt;depth) / 8;</span>
 	f-&gt;fmt.pix.sizeimage =
<span class="p_del">-		f-&gt;fmt.pix.height * f-&gt;fmt.pix.bytesperline;</span>
<span class="p_add">+		(f-&gt;fmt.pix.height * f-&gt;fmt.pix.width * dev-&gt;fmt-&gt;depth) / 8;</span>
 	f-&gt;fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;
 	return 0;
 }
<span class="p_chunk">@@ -1298,10 +1301,13 @@</span> <span class="p_context"> static int saa7134_try_fmt_vid_cap(struct file *file, void *priv,</span>
 	if (f-&gt;fmt.pix.height &gt; maxh)
 		f-&gt;fmt.pix.height = maxh;
 	f-&gt;fmt.pix.width &amp;= ~0x03;
<span class="p_del">-	f-&gt;fmt.pix.bytesperline =</span>
<span class="p_del">-		(f-&gt;fmt.pix.width * fmt-&gt;depth) &gt;&gt; 3;</span>
<span class="p_add">+	if (fmt-&gt;planar)</span>
<span class="p_add">+		f-&gt;fmt.pix.bytesperline = f-&gt;fmt.pix.width;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		f-&gt;fmt.pix.bytesperline =</span>
<span class="p_add">+			(f-&gt;fmt.pix.width * fmt-&gt;depth) / 8;</span>
 	f-&gt;fmt.pix.sizeimage =
<span class="p_del">-		f-&gt;fmt.pix.height * f-&gt;fmt.pix.bytesperline;</span>
<span class="p_add">+		(f-&gt;fmt.pix.height * f-&gt;fmt.pix.width * fmt-&gt;depth) / 8;</span>
 	f-&gt;fmt.pix.colorspace   = V4L2_COLORSPACE_SMPTE170M;
 
 	return 0;
<span class="p_header">diff --git a/drivers/media/platform/coda/coda-bit.c b/drivers/media/platform/coda/coda-bit.c</span>
<span class="p_header">index 654e964f84a2..d76511c1c1e3 100644</span>
<span class="p_header">--- a/drivers/media/platform/coda/coda-bit.c</span>
<span class="p_header">+++ b/drivers/media/platform/coda/coda-bit.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void coda_finish_encode(struct coda_ctx *ctx)</span>
 
 	/* Calculate bytesused field */
 	if (dst_buf-&gt;sequence == 0) {
<span class="p_del">-		vb2_set_plane_payload(&amp;dst_buf-&gt;vb2_buf, 0,</span>
<span class="p_add">+		vb2_set_plane_payload(&amp;dst_buf-&gt;vb2_buf, 0, wr_ptr - start_ptr +</span>
 					ctx-&gt;vpu_header_size[0] +
 					ctx-&gt;vpu_header_size[1] +
 					ctx-&gt;vpu_header_size[2]);
<span class="p_header">diff --git a/drivers/media/usb/pwc/pwc-if.c b/drivers/media/usb/pwc/pwc-if.c</span>
<span class="p_header">index b79c36fd8cd2..58f23bcfe94e 100644</span>
<span class="p_header">--- a/drivers/media/usb/pwc/pwc-if.c</span>
<span class="p_header">+++ b/drivers/media/usb/pwc/pwc-if.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static const struct usb_device_id pwc_device_table [] = {</span>
 	{ USB_DEVICE(0x0471, 0x0312) },
 	{ USB_DEVICE(0x0471, 0x0313) }, /* the &#39;new&#39; 720K */
 	{ USB_DEVICE(0x0471, 0x0329) }, /* Philips SPC 900NC PC Camera */
<span class="p_add">+	{ USB_DEVICE(0x0471, 0x032C) }, /* Philips SPC 880NC PC Camera */</span>
 	{ USB_DEVICE(0x069A, 0x0001) }, /* Askey */
 	{ USB_DEVICE(0x046D, 0x08B0) }, /* Logitech QuickCam Pro 3000 */
 	{ USB_DEVICE(0x046D, 0x08B1) }, /* Logitech QuickCam Notebook Pro */
<span class="p_chunk">@@ -811,6 +812,11 @@</span> <span class="p_context"> static int usb_pwc_probe(struct usb_interface *intf, const struct usb_device_id</span>
 			name = &quot;Philips SPC 900NC webcam&quot;;
 			type_id = 740;
 			break;
<span class="p_add">+		case 0x032C:</span>
<span class="p_add">+			PWC_INFO(&quot;Philips SPC 880NC USB webcam detected.\n&quot;);</span>
<span class="p_add">+			name = &quot;Philips SPC 880NC webcam&quot;;</span>
<span class="p_add">+			type_id = 740;</span>
<span class="p_add">+			break;</span>
 		default:
 			return -ENODEV;
 			break;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index 327e83ac2469..f38c076752ce 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -415,7 +415,8 @@</span> <span class="p_context"> static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 		get_user(kp-&gt;index, &amp;up-&gt;index) ||
 		get_user(kp-&gt;type, &amp;up-&gt;type) ||
 		get_user(kp-&gt;flags, &amp;up-&gt;flags) ||
<span class="p_del">-		get_user(kp-&gt;memory, &amp;up-&gt;memory))</span>
<span class="p_add">+		get_user(kp-&gt;memory, &amp;up-&gt;memory) ||</span>
<span class="p_add">+		get_user(kp-&gt;length, &amp;up-&gt;length))</span>
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_OUTPUT(kp-&gt;type))
<span class="p_chunk">@@ -427,9 +428,6 @@</span> <span class="p_context"> static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_MULTIPLANAR(kp-&gt;type)) {
<span class="p_del">-		if (get_user(kp-&gt;length, &amp;up-&gt;length))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-</span>
 		num_planes = kp-&gt;length;
 		if (num_planes == 0) {
 			kp-&gt;m.planes = NULL;
<span class="p_chunk">@@ -462,16 +460,14 @@</span> <span class="p_context"> static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 	} else {
 		switch (kp-&gt;memory) {
 		case V4L2_MEMORY_MMAP:
<span class="p_del">-			if (get_user(kp-&gt;length, &amp;up-&gt;length) ||</span>
<span class="p_del">-				get_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+			if (get_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_USERPTR:
 			{
 			compat_long_t tmp;
 
<span class="p_del">-			if (get_user(kp-&gt;length, &amp;up-&gt;length) ||</span>
<span class="p_del">-			    get_user(tmp, &amp;up-&gt;m.userptr))</span>
<span class="p_add">+			if (get_user(tmp, &amp;up-&gt;m.userptr))</span>
 				return -EFAULT;
 
 			kp-&gt;m.userptr = (unsigned long)compat_ptr(tmp);
<span class="p_chunk">@@ -513,7 +509,8 @@</span> <span class="p_context"> static int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 		copy_to_user(&amp;up-&gt;timecode, &amp;kp-&gt;timecode, sizeof(struct v4l2_timecode)) ||
 		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||
 		put_user(kp-&gt;reserved2, &amp;up-&gt;reserved2) ||
<span class="p_del">-		put_user(kp-&gt;reserved, &amp;up-&gt;reserved))</span>
<span class="p_add">+		put_user(kp-&gt;reserved, &amp;up-&gt;reserved) ||</span>
<span class="p_add">+		put_user(kp-&gt;length, &amp;up-&gt;length))</span>
 			return -EFAULT;
 
 	if (V4L2_TYPE_IS_MULTIPLANAR(kp-&gt;type)) {
<span class="p_chunk">@@ -536,13 +533,11 @@</span> <span class="p_context"> static int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 	} else {
 		switch (kp-&gt;memory) {
 		case V4L2_MEMORY_MMAP:
<span class="p_del">-			if (put_user(kp-&gt;length, &amp;up-&gt;length) ||</span>
<span class="p_del">-				put_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+			if (put_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_USERPTR:
<span class="p_del">-			if (put_user(kp-&gt;length, &amp;up-&gt;length) ||</span>
<span class="p_del">-				put_user(kp-&gt;m.userptr, &amp;up-&gt;m.userptr))</span>
<span class="p_add">+			if (put_user(kp-&gt;m.userptr, &amp;up-&gt;m.userptr))</span>
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_OVERLAY:
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index 0b05aa938799..1a173d0af694 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -53,6 +53,11 @@</span> <span class="p_context"> ssize_t __mei_cl_send(struct mei_cl *cl, u8 *buf, size_t length,</span>
 	bus = cl-&gt;dev;
 
 	mutex_lock(&amp;bus-&gt;device_lock);
<span class="p_add">+	if (bus-&gt;dev_state != MEI_DEV_ENABLED) {</span>
<span class="p_add">+		rets = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!mei_cl_is_connected(cl)) {
 		rets = -ENODEV;
 		goto out;
<span class="p_chunk">@@ -109,6 +114,10 @@</span> <span class="p_context"> ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)</span>
 	bus = cl-&gt;dev;
 
 	mutex_lock(&amp;bus-&gt;device_lock);
<span class="p_add">+	if (bus-&gt;dev_state != MEI_DEV_ENABLED) {</span>
<span class="p_add">+		rets = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	cb = mei_cl_read_cb(cl, NULL);
 	if (cb)
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index d8486168415a..553113eb1bdb 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -596,6 +596,14 @@</span> <span class="p_context"> static int mmc_blk_ioctl_cmd(struct block_device *bdev,</span>
 	struct mmc_card *card;
 	int err = 0, ioc_err = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The caller must have CAP_SYS_RAWIO, and must be calling this on the</span>
<span class="p_add">+	 * whole block device, not on a partition.  This prevents overspray</span>
<span class="p_add">+	 * between sibling partitions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((!capable(CAP_SYS_RAWIO)) || (bdev != bdev-&gt;bd_contains))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	idata = mmc_blk_ioctl_copy_from_user(ic_ptr);
 	if (IS_ERR(idata))
 		return PTR_ERR(idata);
<span class="p_chunk">@@ -638,6 +646,14 @@</span> <span class="p_context"> static int mmc_blk_ioctl_multi_cmd(struct block_device *bdev,</span>
 	int i, err = 0, ioc_err = 0;
 	__u64 num_of_cmds;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The caller must have CAP_SYS_RAWIO, and must be calling this on the</span>
<span class="p_add">+	 * whole block device, not on a partition.  This prevents overspray</span>
<span class="p_add">+	 * between sibling partitions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((!capable(CAP_SYS_RAWIO)) || (bdev != bdev-&gt;bd_contains))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	if (copy_from_user(&amp;num_of_cmds, &amp;user-&gt;num_of_cmds,
 			   sizeof(num_of_cmds)))
 		return -EFAULT;
<span class="p_chunk">@@ -693,14 +709,6 @@</span> <span class="p_context"> cmd_err:</span>
 static int mmc_blk_ioctl(struct block_device *bdev, fmode_t mode,
 	unsigned int cmd, unsigned long arg)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The caller must have CAP_SYS_RAWIO, and must be calling this on the</span>
<span class="p_del">-	 * whole block device, not on a partition.  This prevents overspray</span>
<span class="p_del">-	 * between sibling partitions.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((!capable(CAP_SYS_RAWIO)) || (bdev != bdev-&gt;bd_contains))</span>
<span class="p_del">-		return -EPERM;</span>
<span class="p_del">-</span>
 	switch (cmd) {
 	case MMC_IOC_CMD:
 		return mmc_blk_ioctl_cmd(bdev,
<span class="p_header">diff --git a/drivers/mmc/host/mmc_spi.c b/drivers/mmc/host/mmc_spi.c</span>
<span class="p_header">index 1c1b45ef3faf..aad3243a48fc 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mmc_spi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mmc_spi.c</span>
<span class="p_chunk">@@ -1436,6 +1436,12 @@</span> <span class="p_context"> static int mmc_spi_probe(struct spi_device *spi)</span>
 					     host-&gt;pdata-&gt;cd_debounce);
 		if (status != 0)
 			goto fail_add_host;
<span class="p_add">+</span>
<span class="p_add">+		/* The platform has a CD GPIO signal that may support</span>
<span class="p_add">+		 * interrupts, so let mmc_gpiod_request_cd_irq() decide</span>
<span class="p_add">+		 * if polling is needed or not.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mmc-&gt;caps &amp;= ~MMC_CAP_NEEDS_POLL;</span>
 		mmc_gpiod_request_cd_irq(mmc);
 	}
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 8814eb6b83bf..1a802af827ed 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -666,9 +666,20 @@</span> <span class="p_context"> static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)</span>
 	if (!data)
 		target_timeout = cmd-&gt;busy_timeout * 1000;
 	else {
<span class="p_del">-		target_timeout = data-&gt;timeout_ns / 1000;</span>
<span class="p_del">-		if (host-&gt;clock)</span>
<span class="p_del">-			target_timeout += data-&gt;timeout_clks / host-&gt;clock;</span>
<span class="p_add">+		target_timeout = DIV_ROUND_UP(data-&gt;timeout_ns, 1000);</span>
<span class="p_add">+		if (host-&gt;clock &amp;&amp; data-&gt;timeout_clks) {</span>
<span class="p_add">+			unsigned long long val;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * data-&gt;timeout_clks is in units of clock cycles.</span>
<span class="p_add">+			 * host-&gt;clock is in Hz.  target_timeout is in us.</span>
<span class="p_add">+			 * Hence, us = 1000000 * cycles / Hz.  Round up.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			val = 1000000 * data-&gt;timeout_clks;</span>
<span class="p_add">+			if (do_div(val, host-&gt;clock))</span>
<span class="p_add">+				target_timeout++;</span>
<span class="p_add">+			target_timeout += val;</span>
<span class="p_add">+		}</span>
 	}
 
 	/*
<span class="p_chunk">@@ -3095,14 +3106,14 @@</span> <span class="p_context"> int sdhci_add_host(struct sdhci_host *host)</span>
 		if (caps[0] &amp; SDHCI_TIMEOUT_CLK_UNIT)
 			host-&gt;timeout_clk *= 1000;
 
<span class="p_add">+		if (override_timeout_clk)</span>
<span class="p_add">+			host-&gt;timeout_clk = override_timeout_clk;</span>
<span class="p_add">+</span>
 		mmc-&gt;max_busy_timeout = host-&gt;ops-&gt;get_max_timeout_count ?
 			host-&gt;ops-&gt;get_max_timeout_count(host) : 1 &lt;&lt; 27;
 		mmc-&gt;max_busy_timeout /= host-&gt;timeout_clk;
 	}
 
<span class="p_del">-	if (override_timeout_clk)</span>
<span class="p_del">-		host-&gt;timeout_clk = override_timeout_clk;</span>
<span class="p_del">-</span>
 	mmc-&gt;caps |= MMC_CAP_SDIO_IRQ | MMC_CAP_ERASE | MMC_CAP_CMD23;
 	mmc-&gt;caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;
 
<span class="p_header">diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">index ad9ffea7d659..6234eab38ff3 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_chunk">@@ -397,38 +397,26 @@</span> <span class="p_context"> static void sh_mmcif_start_dma_tx(struct sh_mmcif_host *host)</span>
 }
 
 static struct dma_chan *
<span class="p_del">-sh_mmcif_request_dma_one(struct sh_mmcif_host *host,</span>
<span class="p_del">-			 struct sh_mmcif_plat_data *pdata,</span>
<span class="p_del">-			 enum dma_transfer_direction direction)</span>
<span class="p_add">+sh_mmcif_request_dma_pdata(struct sh_mmcif_host *host, uintptr_t slave_id)</span>
 {
<span class="p_del">-	struct dma_slave_config cfg = { 0, };</span>
<span class="p_del">-	struct dma_chan *chan;</span>
<span class="p_del">-	void *slave_data = NULL;</span>
<span class="p_del">-	struct resource *res;</span>
<span class="p_del">-	struct device *dev = sh_mmcif_host_to_dev(host);</span>
 	dma_cap_mask_t mask;
<span class="p_del">-	int ret;</span>
 
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
<span class="p_add">+	if (slave_id &lt;= 0)</span>
<span class="p_add">+		return NULL;</span>
 
<span class="p_del">-	if (pdata)</span>
<span class="p_del">-		slave_data = direction == DMA_MEM_TO_DEV ?</span>
<span class="p_del">-			(void *)pdata-&gt;slave_id_tx :</span>
<span class="p_del">-			(void *)pdata-&gt;slave_id_rx;</span>
<span class="p_del">-</span>
<span class="p_del">-	chan = dma_request_slave_channel_compat(mask, shdma_chan_filter,</span>
<span class="p_del">-				slave_data, dev,</span>
<span class="p_del">-				direction == DMA_MEM_TO_DEV ? &quot;tx&quot; : &quot;rx&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_dbg(dev, &quot;%s: %s: got channel %p\n&quot;, __func__,</span>
<span class="p_del">-		direction == DMA_MEM_TO_DEV ? &quot;TX&quot; : &quot;RX&quot;, chan);</span>
<span class="p_add">+	return dma_request_channel(mask, shdma_chan_filter, (void *)slave_id);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (!chan)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+static int sh_mmcif_dma_slave_config(struct sh_mmcif_host *host,</span>
<span class="p_add">+				     struct dma_chan *chan,</span>
<span class="p_add">+				     enum dma_transfer_direction direction)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	struct dma_slave_config cfg = { 0, };</span>
 
 	res = platform_get_resource(host-&gt;pd, IORESOURCE_MEM, 0);
<span class="p_del">-</span>
 	cfg.direction = direction;
 
 	if (direction == DMA_DEV_TO_MEM) {
<span class="p_chunk">@@ -439,38 +427,42 @@</span> <span class="p_context"> sh_mmcif_request_dma_one(struct sh_mmcif_host *host,</span>
 		cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	}
 
<span class="p_del">-	ret = dmaengine_slave_config(chan, &amp;cfg);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dma_release_channel(chan);</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return chan;</span>
<span class="p_add">+	return dmaengine_slave_config(chan, &amp;cfg);</span>
 }
 
<span class="p_del">-static void sh_mmcif_request_dma(struct sh_mmcif_host *host,</span>
<span class="p_del">-				 struct sh_mmcif_plat_data *pdata)</span>
<span class="p_add">+static void sh_mmcif_request_dma(struct sh_mmcif_host *host)</span>
 {
 	struct device *dev = sh_mmcif_host_to_dev(host);
 	host-&gt;dma_active = false;
 
<span class="p_del">-	if (pdata) {</span>
<span class="p_del">-		if (pdata-&gt;slave_id_tx &lt;= 0 || pdata-&gt;slave_id_rx &lt;= 0)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-	} else if (!dev-&gt;of_node) {</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	/* We can only either use DMA for both Tx and Rx or not use it at all */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_SUPERH) &amp;&amp; dev-&gt;platform_data) {</span>
<span class="p_add">+		struct sh_mmcif_plat_data *pdata = dev-&gt;platform_data;</span>
<span class="p_add">+</span>
<span class="p_add">+		host-&gt;chan_tx = sh_mmcif_request_dma_pdata(host,</span>
<span class="p_add">+							pdata-&gt;slave_id_tx);</span>
<span class="p_add">+		host-&gt;chan_rx = sh_mmcif_request_dma_pdata(host,</span>
<span class="p_add">+							pdata-&gt;slave_id_rx);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		host-&gt;chan_tx = dma_request_slave_channel(dev, &quot;tx&quot;);</span>
<span class="p_add">+		host-&gt;chan_rx = dma_request_slave_channel(dev, &quot;rx&quot;);</span>
 	}
<span class="p_add">+	dev_dbg(dev, &quot;%s: got channel TX %p RX %p\n&quot;, __func__, host-&gt;chan_tx,</span>
<span class="p_add">+		host-&gt;chan_rx);</span>
 
<span class="p_del">-	/* We can only either use DMA for both Tx and Rx or not use it at all */</span>
<span class="p_del">-	host-&gt;chan_tx = sh_mmcif_request_dma_one(host, pdata, DMA_MEM_TO_DEV);</span>
<span class="p_del">-	if (!host-&gt;chan_tx)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (!host-&gt;chan_tx || !host-&gt;chan_rx ||</span>
<span class="p_add">+	    sh_mmcif_dma_slave_config(host, host-&gt;chan_tx, DMA_MEM_TO_DEV) ||</span>
<span class="p_add">+	    sh_mmcif_dma_slave_config(host, host-&gt;chan_rx, DMA_DEV_TO_MEM))</span>
<span class="p_add">+		goto error;</span>
 
<span class="p_del">-	host-&gt;chan_rx = sh_mmcif_request_dma_one(host, pdata, DMA_DEV_TO_MEM);</span>
<span class="p_del">-	if (!host-&gt;chan_rx) {</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+error:</span>
<span class="p_add">+	if (host-&gt;chan_tx)</span>
 		dma_release_channel(host-&gt;chan_tx);
<span class="p_del">-		host-&gt;chan_tx = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (host-&gt;chan_rx)</span>
<span class="p_add">+		dma_release_channel(host-&gt;chan_rx);</span>
<span class="p_add">+	host-&gt;chan_tx = host-&gt;chan_rx = NULL;</span>
 }
 
 static void sh_mmcif_release_dma(struct sh_mmcif_host *host)
<span class="p_chunk">@@ -1102,7 +1094,7 @@</span> <span class="p_context"> static void sh_mmcif_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 	if (ios-&gt;power_mode == MMC_POWER_UP) {
 		if (!host-&gt;card_present) {
 			/* See if we also get DMA */
<span class="p_del">-			sh_mmcif_request_dma(host, dev-&gt;platform_data);</span>
<span class="p_add">+			sh_mmcif_request_dma(host);</span>
 			host-&gt;card_present = true;
 		}
 		sh_mmcif_set_power(host, ios);
<span class="p_header">diff --git a/drivers/mtd/onenand/onenand_base.c b/drivers/mtd/onenand/onenand_base.c</span>
<span class="p_header">index 43b3392ffee7..652d01832873 100644</span>
<span class="p_header">--- a/drivers/mtd/onenand/onenand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/onenand/onenand_base.c</span>
<span class="p_chunk">@@ -2599,6 +2599,7 @@</span> <span class="p_context"> static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)</span>
  */
 static int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
 {
<span class="p_add">+	struct onenand_chip *this = mtd-&gt;priv;</span>
 	int ret;
 
 	ret = onenand_block_isbad(mtd, ofs);
<span class="p_chunk">@@ -2610,7 +2611,7 @@</span> <span class="p_context"> static int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)</span>
 	}
 
 	onenand_get_device(mtd, FL_WRITING);
<span class="p_del">-	ret = mtd_block_markbad(mtd, ofs);</span>
<span class="p_add">+	ret = this-&gt;block_markbad(mtd, ofs);</span>
 	onenand_release_device(mtd);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index ed622fa29dfa..a4ac6fedac75 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -3404,7 +3404,7 @@</span> <span class="p_context"> static int mvneta_probe(struct platform_device *pdev)</span>
 	dev-&gt;features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
 	dev-&gt;hw_features |= dev-&gt;features;
 	dev-&gt;vlan_features |= dev-&gt;features;
<span class="p_del">-	dev-&gt;priv_flags |= IFF_UNICAST_FLT;</span>
<span class="p_add">+	dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;</span>
 	dev-&gt;gso_max_segs = MVNETA_MAX_TSO_SEGS;
 
 	err = register_netdev(dev);
<span class="p_header">diff --git a/drivers/net/irda/irtty-sir.c b/drivers/net/irda/irtty-sir.c</span>
<span class="p_header">index 696852eb23c3..7a3f990c1935 100644</span>
<span class="p_header">--- a/drivers/net/irda/irtty-sir.c</span>
<span class="p_header">+++ b/drivers/net/irda/irtty-sir.c</span>
<span class="p_chunk">@@ -430,16 +430,6 @@</span> <span class="p_context"> static int irtty_open(struct tty_struct *tty)</span>
 
 	/* Module stuff handled via irda_ldisc.owner - Jean II */
 
<span class="p_del">-	/* First make sure we&#39;re not already connected. */</span>
<span class="p_del">-	if (tty-&gt;disc_data != NULL) {</span>
<span class="p_del">-		priv = tty-&gt;disc_data;</span>
<span class="p_del">-		if (priv &amp;&amp; priv-&gt;magic == IRTTY_MAGIC) {</span>
<span class="p_del">-			ret = -EEXIST;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		tty-&gt;disc_data = NULL;		/* ### */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* stop the underlying  driver */
 	irtty_stop_receiver(tty, TRUE);
 	if (tty-&gt;ops-&gt;stop)
<span class="p_header">diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c</span>
<span class="p_header">index 01f08a7751f7..e7034c55e796 100644</span>
<span class="p_header">--- a/drivers/net/rionet.c</span>
<span class="p_header">+++ b/drivers/net/rionet.c</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo</span>
 	struct net_device *ndev = dev_id;
 	struct rionet_private *rnet = netdev_priv(ndev);
 
<span class="p_del">-	spin_lock(&amp;rnet-&gt;lock);</span>
<span class="p_add">+	spin_lock(&amp;rnet-&gt;tx_lock);</span>
 
 	if (netif_msg_intr(rnet))
 		printk(KERN_INFO
<span class="p_chunk">@@ -299,7 +299,7 @@</span> <span class="p_context"> static void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbo</span>
 	if (rnet-&gt;tx_cnt &lt; RIONET_TX_RING_SIZE)
 		netif_wake_queue(ndev);
 
<span class="p_del">-	spin_unlock(&amp;rnet-&gt;lock);</span>
<span class="p_add">+	spin_unlock(&amp;rnet-&gt;tx_lock);</span>
 }
 
 static int rionet_open(struct net_device *ndev)
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/fw.c b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">index d906fa13ba97..610c442c7ab2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static int iwl_send_tx_ant_cfg(struct iwl_mvm *mvm, u8 valid_tx_ant)</span>
 				    sizeof(tx_ant_cmd), &amp;tx_ant_cmd);
 }
 
<span class="p_del">-static void iwl_free_fw_paging(struct iwl_mvm *mvm)</span>
<span class="p_add">+void iwl_free_fw_paging(struct iwl_mvm *mvm)</span>
 {
 	int i;
 
<span class="p_chunk">@@ -126,6 +126,8 @@</span> <span class="p_context"> static void iwl_free_fw_paging(struct iwl_mvm *mvm)</span>
 			     get_order(mvm-&gt;fw_paging_db[i].fw_paging_size));
 	}
 	kfree(mvm-&gt;trans-&gt;paging_download_buf);
<span class="p_add">+	mvm-&gt;trans-&gt;paging_download_buf = NULL;</span>
<span class="p_add">+</span>
 	memset(mvm-&gt;fw_paging_db, 0, sizeof(mvm-&gt;fw_paging_db));
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index 4bde2d027dcd..244e26c26821 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -1190,6 +1190,9 @@</span> <span class="p_context"> void iwl_mvm_rx_umac_scan_complete_notif(struct iwl_mvm *mvm,</span>
 void iwl_mvm_rx_umac_scan_iter_complete_notif(struct iwl_mvm *mvm,
 					      struct iwl_rx_cmd_buffer *rxb);
 
<span class="p_add">+/* Paging */</span>
<span class="p_add">+void iwl_free_fw_paging(struct iwl_mvm *mvm);</span>
<span class="p_add">+</span>
 /* MVM debugfs */
 #ifdef CONFIG_IWLWIFI_DEBUGFS
 int iwl_mvm_dbgfs_register(struct iwl_mvm *mvm, struct dentry *dbgfs_dir);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/ops.c b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">index 13c97f665ba8..c3adf2bcdc85 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -645,6 +645,8 @@</span> <span class="p_context"> static void iwl_op_mode_mvm_stop(struct iwl_op_mode *op_mode)</span>
 	for (i = 0; i &lt; NVM_MAX_NUM_SECTIONS; i++)
 		kfree(mvm-&gt;nvm_sections[i].data);
 
<span class="p_add">+	iwl_free_fw_paging(mvm);</span>
<span class="p_add">+</span>
 	iwl_mvm_tof_clean(mvm);
 
 	ieee80211_free_hw(mvm-&gt;hw);
<span class="p_header">diff --git a/drivers/nvdimm/bus.c b/drivers/nvdimm/bus.c</span>
<span class="p_header">index 7e2c43f701bc..496b9b662dc6 100644</span>
<span class="p_header">--- a/drivers/nvdimm/bus.c</span>
<span class="p_header">+++ b/drivers/nvdimm/bus.c</span>
<span class="p_chunk">@@ -513,10 +513,10 @@</span> <span class="p_context"> static int __nd_ioctl(struct nvdimm_bus *nvdimm_bus, struct nvdimm *nvdimm,</span>
 
 	/* fail write commands (when read-only) */
 	if (read_only)
<span class="p_del">-		switch (ioctl_cmd) {</span>
<span class="p_del">-		case ND_IOCTL_VENDOR:</span>
<span class="p_del">-		case ND_IOCTL_SET_CONFIG_DATA:</span>
<span class="p_del">-		case ND_IOCTL_ARS_START:</span>
<span class="p_add">+		switch (cmd) {</span>
<span class="p_add">+		case ND_CMD_VENDOR:</span>
<span class="p_add">+		case ND_CMD_SET_CONFIG_DATA:</span>
<span class="p_add">+		case ND_CMD_ARS_START:</span>
 			dev_dbg(&amp;nvdimm_bus-&gt;dev, &quot;&#39;%s&#39; command while read-only.\n&quot;,
 					nvdimm ? nvdimm_cmd_name(cmd)
 					: nvdimm_bus_cmd_name(cmd));
<span class="p_header">diff --git a/drivers/of/of_reserved_mem.c b/drivers/of/of_reserved_mem.c</span>
<span class="p_header">index 1a3556a9e9ea..ed01c0172e4a 100644</span>
<span class="p_header">--- a/drivers/of/of_reserved_mem.c</span>
<span class="p_header">+++ b/drivers/of/of_reserved_mem.c</span>
<span class="p_chunk">@@ -32,11 +32,13 @@</span> <span class="p_context"> int __init __weak early_init_dt_alloc_reserved_memory_arch(phys_addr_t size,</span>
 	phys_addr_t align, phys_addr_t start, phys_addr_t end, bool nomap,
 	phys_addr_t *res_base)
 {
<span class="p_add">+	phys_addr_t base;</span>
 	/*
 	 * We use __memblock_alloc_base() because memblock_alloc_base()
 	 * panic()s on allocation failure.
 	 */
<span class="p_del">-	phys_addr_t base = __memblock_alloc_base(size, align, end);</span>
<span class="p_add">+	end = !end ? MEMBLOCK_ALLOC_ANYWHERE : end;</span>
<span class="p_add">+	base = __memblock_alloc_base(size, align, end);</span>
 	if (!base)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index edb1984201e9..7aafb5fb9336 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -179,6 +179,9 @@</span> <span class="p_context"> int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,</span>
 	u16 orig_cmd;
 	struct pci_bus_region region, inverted_region;
 
<span class="p_add">+	if (dev-&gt;non_compliant_bars)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;
 
 	/* No printks while decoding is disabled! */
<span class="p_chunk">@@ -1174,6 +1177,7 @@</span> <span class="p_context"> void pci_msi_setup_pci_dev(struct pci_dev *dev)</span>
 int pci_setup_device(struct pci_dev *dev)
 {
 	u32 class;
<span class="p_add">+	u16 cmd;</span>
 	u8 hdr_type;
 	int pos = 0;
 	struct pci_bus_region region;
<span class="p_chunk">@@ -1219,6 +1223,16 @@</span> <span class="p_context"> int pci_setup_device(struct pci_dev *dev)</span>
 	/* device class may be changed after fixup */
 	class = dev-&gt;class &gt;&gt; 8;
 
<span class="p_add">+	if (dev-&gt;non_compliant_bars) {</span>
<span class="p_add">+		pci_read_config_word(dev, PCI_COMMAND, &amp;cmd);</span>
<span class="p_add">+		if (cmd &amp; (PCI_COMMAND_IO | PCI_COMMAND_MEMORY)) {</span>
<span class="p_add">+			dev_info(&amp;dev-&gt;dev, &quot;device has non-compliant BARs; disabling IO/MEM decoding\n&quot;);</span>
<span class="p_add">+			cmd &amp;= ~PCI_COMMAND_IO;</span>
<span class="p_add">+			cmd &amp;= ~PCI_COMMAND_MEMORY;</span>
<span class="p_add">+			pci_write_config_word(dev, PCI_COMMAND, cmd);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (dev-&gt;hdr_type) {		    /* header type */
 	case PCI_HEADER_TYPE_NORMAL:		    /* standard header */
 		if (class == PCI_CLASS_BRIDGE_PCI)
<span class="p_header">diff --git a/drivers/pinctrl/bcm/pinctrl-bcm2835.c b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">index 2e6ca69635aa..17dd8fe12b54 100644</span>
<span class="p_header">--- a/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_header">+++ b/drivers/pinctrl/bcm/pinctrl-bcm2835.c</span>
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> static int bcm2835_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,</span>
 		}
 		if (num_pulls) {
 			err = of_property_read_u32_index(np, &quot;brcm,pull&quot;,
<span class="p_del">-					(num_funcs &gt; 1) ? i : 0, &amp;pull);</span>
<span class="p_add">+					(num_pulls &gt; 1) ? i : 0, &amp;pull);</span>
 			if (err)
 				goto out;
 			err = bcm2835_pctl_dt_node_to_map_pull(pc, np, pin,
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index d78ee151c9e4..be3bc2f4edd4 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -865,6 +865,20 @@</span> <span class="p_context"> static const struct dmi_system_id no_hw_rfkill_list[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		.ident = &quot;Lenovo ideapad Y700-15ISK&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo ideapad Y700-15ISK&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.ident = &quot;Lenovo ideapad Y700 Touch-15ISK&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo ideapad Y700 Touch-15ISK&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo ideapad Y700-17ISK&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 73b7683355cd..7b94b8ee087c 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -132,24 +132,24 @@</span> <span class="p_context"> static bool have_full_constraints(void)</span>
 	return has_full_constraints || of_have_populated_dt();
 }
 
<span class="p_add">+static inline struct regulator_dev *rdev_get_supply(struct regulator_dev *rdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (rdev &amp;&amp; rdev-&gt;supply)</span>
<span class="p_add">+		return rdev-&gt;supply-&gt;rdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * regulator_lock_supply - lock a regulator and its supplies
  * @rdev:         regulator source
  */
 static void regulator_lock_supply(struct regulator_dev *rdev)
 {
<span class="p_del">-	struct regulator *supply;</span>
<span class="p_del">-	int i = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (1) {</span>
<span class="p_del">-		mutex_lock_nested(&amp;rdev-&gt;mutex, i++);</span>
<span class="p_del">-		supply = rdev-&gt;supply;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!rdev-&gt;supply)</span>
<span class="p_del">-			return;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-		rdev = supply-&gt;rdev;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = 0; rdev-&gt;supply; rdev = rdev_get_supply(rdev), i++)</span>
<span class="p_add">+		mutex_lock_nested(&amp;rdev-&gt;mutex, i);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_header">index 074878b55a0b..d044f3f273be 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/aacraid.h</span>
<span class="p_chunk">@@ -944,6 +944,7 @@</span> <span class="p_context"> struct fib {</span>
 	 */
 	struct list_head	fiblink;
 	void			*data;
<span class="p_add">+	u32			vector_no;</span>
 	struct hw_fib		*hw_fib_va;		/* Actual shared object */
 	dma_addr_t		hw_fib_pa;		/* physical address of hw_fib*/
 };
<span class="p_chunk">@@ -2113,6 +2114,7 @@</span> <span class="p_context"> static inline unsigned int cap_to_cyls(sector_t capacity, unsigned divisor)</span>
 int aac_acquire_irq(struct aac_dev *dev);
 void aac_free_irq(struct aac_dev *dev);
 const char *aac_driverinfo(struct Scsi_Host *);
<span class="p_add">+void aac_fib_vector_assign(struct aac_dev *dev);</span>
 struct fib *aac_fib_alloc(struct aac_dev *dev);
 int aac_fib_setup(struct aac_dev *dev);
 void aac_fib_map_free(struct aac_dev *dev);
<span class="p_header">diff --git a/drivers/scsi/aacraid/commsup.c b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">index a1f90fe849c9..4cbf54928640 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commsup.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commsup.c</span>
<span class="p_chunk">@@ -83,13 +83,38 @@</span> <span class="p_context"> static int fib_map_alloc(struct aac_dev *dev)</span>
 
 void aac_fib_map_free(struct aac_dev *dev)
 {
<span class="p_del">-	pci_free_consistent(dev-&gt;pdev,</span>
<span class="p_del">-	  dev-&gt;max_fib_size * (dev-&gt;scsi_host_ptr-&gt;can_queue + AAC_NUM_MGT_FIB),</span>
<span class="p_del">-	  dev-&gt;hw_fib_va, dev-&gt;hw_fib_pa);</span>
<span class="p_add">+	if (dev-&gt;hw_fib_va &amp;&amp; dev-&gt;max_fib_size) {</span>
<span class="p_add">+		pci_free_consistent(dev-&gt;pdev,</span>
<span class="p_add">+		(dev-&gt;max_fib_size *</span>
<span class="p_add">+		(dev-&gt;scsi_host_ptr-&gt;can_queue + AAC_NUM_MGT_FIB)),</span>
<span class="p_add">+		dev-&gt;hw_fib_va, dev-&gt;hw_fib_pa);</span>
<span class="p_add">+	}</span>
 	dev-&gt;hw_fib_va = NULL;
 	dev-&gt;hw_fib_pa = 0;
 }
 
<span class="p_add">+void aac_fib_vector_assign(struct aac_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 i = 0;</span>
<span class="p_add">+	u32 vector = 1;</span>
<span class="p_add">+	struct fib *fibptr = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0, fibptr = &amp;dev-&gt;fibs[i];</span>
<span class="p_add">+		i &lt; (dev-&gt;scsi_host_ptr-&gt;can_queue + AAC_NUM_MGT_FIB);</span>
<span class="p_add">+		i++, fibptr++) {</span>
<span class="p_add">+		if ((dev-&gt;max_msix == 1) ||</span>
<span class="p_add">+		  (i &gt; ((dev-&gt;scsi_host_ptr-&gt;can_queue + AAC_NUM_MGT_FIB - 1)</span>
<span class="p_add">+			- dev-&gt;vector_cap))) {</span>
<span class="p_add">+			fibptr-&gt;vector_no = 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			fibptr-&gt;vector_no = vector;</span>
<span class="p_add">+			vector++;</span>
<span class="p_add">+			if (vector == dev-&gt;max_msix)</span>
<span class="p_add">+				vector = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	aac_fib_setup	-	setup the fibs
  *	@dev: Adapter to set up
<span class="p_chunk">@@ -151,6 +176,12 @@</span> <span class="p_context"> int aac_fib_setup(struct aac_dev * dev)</span>
 		hw_fib_pa = hw_fib_pa +
 			dev-&gt;max_fib_size + sizeof(struct aac_fib_xporthdr);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *Assign vector numbers to fibs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	aac_fib_vector_assign(dev);</span>
<span class="p_add">+</span>
 	/*
 	 *	Add the fib chain to the free list
 	 */
<span class="p_header">diff --git a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c</span>
<span class="p_header">index 3b6e5c67e853..aa6eccb8940b 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/linit.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/linit.c</span>
<span class="p_chunk">@@ -1404,8 +1404,18 @@</span> <span class="p_context"> static int aac_acquire_resources(struct aac_dev *dev)</span>
 
 	aac_adapter_enable_int(dev);
 
<span class="p_del">-	if (!dev-&gt;sync_mode)</span>
<span class="p_add">+	/*max msix may change  after EEH</span>
<span class="p_add">+	 * Re-assign vectors to fibs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	aac_fib_vector_assign(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;sync_mode) {</span>
<span class="p_add">+		/* After EEH recovery or suspend resume, max_msix count</span>
<span class="p_add">+		 * may change, therfore updating in init as well.</span>
<span class="p_add">+		 */</span>
 		aac_adapter_start(dev);
<span class="p_add">+		dev-&gt;init-&gt;Sa_MSIXVectors = cpu_to_le32(dev-&gt;max_msix);</span>
<span class="p_add">+	}</span>
 	return 0;
 
 error_iounmap:
<span class="p_header">diff --git a/drivers/scsi/aacraid/src.c b/drivers/scsi/aacraid/src.c</span>
<span class="p_header">index 2aa34ea8ceb1..bc0203f3d243 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/src.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/src.c</span>
<span class="p_chunk">@@ -156,8 +156,8 @@</span> <span class="p_context"> static irqreturn_t aac_src_intr_message(int irq, void *dev_id)</span>
 				break;
 			if (dev-&gt;msi_enabled &amp;&amp; dev-&gt;max_msix &gt; 1)
 				atomic_dec(&amp;dev-&gt;rrq_outstanding[vector_no]);
<span class="p_del">-			aac_intr_normal(dev, handle-1, 0, isFastResponse, NULL);</span>
 			dev-&gt;host_rrq[index++] = 0;
<span class="p_add">+			aac_intr_normal(dev, handle-1, 0, isFastResponse, NULL);</span>
 			if (index == (vector_no + 1) * dev-&gt;vector_cap)
 				index = vector_no * dev-&gt;vector_cap;
 			dev-&gt;host_rrq_idx[vector_no] = index;
<span class="p_chunk">@@ -452,36 +452,20 @@</span> <span class="p_context"> static int aac_src_deliver_message(struct fib *fib)</span>
 #endif
 
 	u16 hdr_size = le16_to_cpu(fib-&gt;hw_fib_va-&gt;header.Size);
<span class="p_add">+	u16 vector_no;</span>
 
 	atomic_inc(&amp;q-&gt;numpending);
 
 	if (dev-&gt;msi_enabled &amp;&amp; fib-&gt;hw_fib_va-&gt;header.Command != AifRequest &amp;&amp;
 	    dev-&gt;max_msix &gt; 1) {
<span class="p_del">-		u_int16_t vector_no, first_choice = 0xffff;</span>
<span class="p_del">-</span>
<span class="p_del">-		vector_no = dev-&gt;fibs_pushed_no % dev-&gt;max_msix;</span>
<span class="p_del">-		do {</span>
<span class="p_del">-			vector_no += 1;</span>
<span class="p_del">-			if (vector_no == dev-&gt;max_msix)</span>
<span class="p_del">-				vector_no = 1;</span>
<span class="p_del">-			if (atomic_read(&amp;dev-&gt;rrq_outstanding[vector_no]) &lt;</span>
<span class="p_del">-			    dev-&gt;vector_cap)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			if (0xffff == first_choice)</span>
<span class="p_del">-				first_choice = vector_no;</span>
<span class="p_del">-			else if (vector_no == first_choice)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		} while (1);</span>
<span class="p_del">-		if (vector_no == first_choice)</span>
<span class="p_del">-			vector_no = 0;</span>
<span class="p_del">-		atomic_inc(&amp;dev-&gt;rrq_outstanding[vector_no]);</span>
<span class="p_del">-		if (dev-&gt;fibs_pushed_no == 0xffffffff)</span>
<span class="p_del">-			dev-&gt;fibs_pushed_no = 0;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			dev-&gt;fibs_pushed_no++;</span>
<span class="p_add">+		vector_no = fib-&gt;vector_no;</span>
 		fib-&gt;hw_fib_va-&gt;header.Handle += (vector_no &lt;&lt; 16);
<span class="p_add">+	} else {</span>
<span class="p_add">+		vector_no = 0;</span>
 	}
 
<span class="p_add">+	atomic_inc(&amp;dev-&gt;rrq_outstanding[vector_no]);</span>
<span class="p_add">+</span>
 	if (dev-&gt;comm_interface == AAC_COMM_MESSAGE_TYPE2) {
 		/* Calculate the amount to the fibsize bits */
 		fibsize = (hdr_size + 127) / 128 - 1;
<span class="p_header">diff --git a/drivers/scsi/aic7xxx/aic7xxx_osm.c b/drivers/scsi/aic7xxx/aic7xxx_osm.c</span>
<span class="p_header">index b846a4683562..fc6a83188c1e 100644</span>
<span class="p_header">--- a/drivers/scsi/aic7xxx/aic7xxx_osm.c</span>
<span class="p_header">+++ b/drivers/scsi/aic7xxx/aic7xxx_osm.c</span>
<span class="p_chunk">@@ -1336,6 +1336,7 @@</span> <span class="p_context"> ahc_platform_set_tags(struct ahc_softc *ahc, struct scsi_device *sdev,</span>
 	case AHC_DEV_Q_TAGGED:
 		scsi_change_queue_depth(sdev,
 				dev-&gt;openings + dev-&gt;active);
<span class="p_add">+		break;</span>
 	default:
 		/*
 		 * We allow the OS to queue 2 untagged transactions to
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index fe0c5143f8e6..758f76e88704 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -4470,6 +4470,7 @@</span> <span class="p_context"> put_shost:</span>
 	scsi_host_put(phba-&gt;shost);
 free_kset:
 	iscsi_boot_destroy_kset(phba-&gt;boot_kset);
<span class="p_add">+	phba-&gt;boot_kset = NULL;</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c</span>
<span class="p_header">index 536cd5a80422..43ac62623bf2 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.c</span>
<span class="p_header">+++ b/drivers/scsi/ipr.c</span>
<span class="p_chunk">@@ -4003,13 +4003,17 @@</span> <span class="p_context"> static ssize_t ipr_store_update_fw(struct device *dev,</span>
 	struct ipr_sglist *sglist;
 	char fname[100];
 	char *src;
<span class="p_del">-	int len, result, dnld_size;</span>
<span class="p_add">+	char *endline;</span>
<span class="p_add">+	int result, dnld_size;</span>
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
<span class="p_del">-	len = snprintf(fname, 99, &quot;%s&quot;, buf);</span>
<span class="p_del">-	fname[len-1] = &#39;\0&#39;;</span>
<span class="p_add">+	snprintf(fname, sizeof(fname), &quot;%s&quot;, buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	endline = strchr(fname, &#39;\n&#39;);</span>
<span class="p_add">+	if (endline)</span>
<span class="p_add">+		*endline = &#39;\0&#39;;</span>
 
 	if (request_firmware(&amp;fw_entry, fname, &amp;ioa_cfg-&gt;pdev-&gt;dev)) {
 		dev_err(&amp;ioa_cfg-&gt;pdev-&gt;dev, &quot;Firmware file %s not found\n&quot;, fname);
<span class="p_header">diff --git a/drivers/scsi/scsi_common.c b/drivers/scsi/scsi_common.c</span>
<span class="p_header">index c126966130ab..ce79de822e46 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_common.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_common.c</span>
<span class="p_chunk">@@ -278,8 +278,16 @@</span> <span class="p_context"> int scsi_set_sense_information(u8 *buf, int buf_len, u64 info)</span>
 		ucp[3] = 0;
 		put_unaligned_be64(info, &amp;ucp[4]);
 	} else if ((buf[0] &amp; 0x7f) == 0x70) {
<span class="p_del">-		buf[0] |= 0x80;</span>
<span class="p_del">-		put_unaligned_be64(info, &amp;buf[3]);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Only set the &#39;VALID&#39; bit if we can represent the value</span>
<span class="p_add">+		 * correctly; otherwise just fill out the lower bytes and</span>
<span class="p_add">+		 * clear the &#39;VALID&#39; flag.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (info &lt;= 0xffffffffUL)</span>
<span class="p_add">+			buf[0] |= 0x80;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			buf[0] &amp;= 0x7f;</span>
<span class="p_add">+		put_unaligned_be32((u32)info, &amp;buf[3]);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index bb669d32ccd0..cc84ea7d09cc 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -648,7 +648,7 @@</span> <span class="p_context"> static void sd_config_discard(struct scsi_disk *sdkp, unsigned int mode)</span>
 	 */
 	if (sdkp-&gt;lbprz) {
 		q-&gt;limits.discard_alignment = 0;
<span class="p_del">-		q-&gt;limits.discard_granularity = 1;</span>
<span class="p_add">+		q-&gt;limits.discard_granularity = logical_block_size;</span>
 	} else {
 		q-&gt;limits.discard_alignment = sdkp-&gt;unmap_alignment *
 			logical_block_size;
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 5e820674432c..ae7d9bdf409c 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -652,7 +652,8 @@</span> <span class="p_context"> sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)</span>
 	else
 		hp-&gt;dxfer_direction = (mxsize &gt; 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
 	hp-&gt;dxfer_len = mxsize;
<span class="p_del">-	if (hp-&gt;dxfer_direction == SG_DXFER_TO_DEV)</span>
<span class="p_add">+	if ((hp-&gt;dxfer_direction == SG_DXFER_TO_DEV) ||</span>
<span class="p_add">+	    (hp-&gt;dxfer_direction == SG_DXFER_TO_FROM_DEV))</span>
 		hp-&gt;dxferp = (char __user *)buf + cmd_size;
 	else
 		hp-&gt;dxferp = NULL;
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 3fba42ad9fb8..0f636cc4c809 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -889,8 +889,9 @@</span> <span class="p_context"> static void storvsc_handle_error(struct vmscsi_request *vm_srb,</span>
 		do_work = true;
 		process_err_fn = storvsc_remove_lun;
 		break;
<span class="p_del">-	case (SRB_STATUS_ABORTED | SRB_STATUS_AUTOSENSE_VALID):</span>
<span class="p_del">-		if ((asc == 0x2a) &amp;&amp; (ascq == 0x9)) {</span>
<span class="p_add">+	case SRB_STATUS_ABORTED:</span>
<span class="p_add">+		if (vm_srb-&gt;srb_status &amp; SRB_STATUS_AUTOSENSE_VALID &amp;&amp;</span>
<span class="p_add">+		    (asc == 0x2a) &amp;&amp; (ascq == 0x9)) {</span>
 			do_work = true;
 			process_err_fn = storvsc_device_scan;
 			/*
<span class="p_header">diff --git a/drivers/staging/android/ion/ion_test.c b/drivers/staging/android/ion/ion_test.c</span>
<span class="p_header">index b8dcf5a26cc4..58d46893e5ff 100644</span>
<span class="p_header">--- a/drivers/staging/android/ion/ion_test.c</span>
<span class="p_header">+++ b/drivers/staging/android/ion/ion_test.c</span>
<span class="p_chunk">@@ -285,8 +285,8 @@</span> <span class="p_context"> static int __init ion_test_init(void)</span>
 {
 	ion_test_pdev = platform_device_register_simple(&quot;ion-test&quot;,
 							-1, NULL, 0);
<span class="p_del">-	if (!ion_test_pdev)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(ion_test_pdev))</span>
<span class="p_add">+		return PTR_ERR(ion_test_pdev);</span>
 
 	return platform_driver_probe(&amp;ion_test_platform_driver, ion_test_probe);
 }
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">index 6cc304a4c59b..27fbf1a81097 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_chunk">@@ -246,24 +246,24 @@</span> <span class="p_context"> static void ni_writel(struct comedi_device *dev, uint32_t data, int reg)</span>
 {
 	if (dev-&gt;mmio)
 		writel(data, dev-&gt;mmio + reg);
<span class="p_del">-</span>
<span class="p_del">-	outl(data, dev-&gt;iobase + reg);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		outl(data, dev-&gt;iobase + reg);</span>
 }
 
 static void ni_writew(struct comedi_device *dev, uint16_t data, int reg)
 {
 	if (dev-&gt;mmio)
 		writew(data, dev-&gt;mmio + reg);
<span class="p_del">-</span>
<span class="p_del">-	outw(data, dev-&gt;iobase + reg);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		outw(data, dev-&gt;iobase + reg);</span>
 }
 
 static void ni_writeb(struct comedi_device *dev, uint8_t data, int reg)
 {
 	if (dev-&gt;mmio)
 		writeb(data, dev-&gt;mmio + reg);
<span class="p_del">-</span>
<span class="p_del">-	outb(data, dev-&gt;iobase + reg);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		outb(data, dev-&gt;iobase + reg);</span>
 }
 
 static uint32_t ni_readl(struct comedi_device *dev, int reg)
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/ni_tiocmd.c b/drivers/staging/comedi/drivers/ni_tiocmd.c</span>
<span class="p_header">index 437f723bb34d..823e47910004 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/ni_tiocmd.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/ni_tiocmd.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static int ni_tio_input_inttrig(struct comedi_device *dev,</span>
 	unsigned long flags;
 	int ret = 0;
 
<span class="p_del">-	if (trig_num != cmd-&gt;start_src)</span>
<span class="p_add">+	if (trig_num != cmd-&gt;start_arg)</span>
 		return -EINVAL;
 
 	spin_lock_irqsave(&amp;counter-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 94f4ffac723f..d151bc3d6971 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -2618,8 +2618,6 @@</span> <span class="p_context"> void target_wait_for_sess_cmds(struct se_session *se_sess)</span>
 
 	list_for_each_entry_safe(se_cmd, tmp_cmd,
 				&amp;se_sess-&gt;sess_wait_list, se_cmd_list) {
<span class="p_del">-		list_del_init(&amp;se_cmd-&gt;se_cmd_list);</span>
<span class="p_del">-</span>
 		pr_debug(&quot;Waiting for se_cmd: %p t_state: %d, fabric state:&quot;
 			&quot; %d\n&quot;, se_cmd, se_cmd-&gt;t_state,
 			se_cmd-&gt;se_tfo-&gt;get_cmd_state(se_cmd));
<span class="p_header">diff --git a/drivers/thermal/thermal_core.c b/drivers/thermal/thermal_core.c</span>
<span class="p_header">index ba08b5521382..3d5f8f432b5b 100644</span>
<span class="p_header">--- a/drivers/thermal/thermal_core.c</span>
<span class="p_header">+++ b/drivers/thermal/thermal_core.c</span>
<span class="p_chunk">@@ -454,6 +454,10 @@</span> <span class="p_context"> static void handle_thermal_trip(struct thermal_zone_device *tz, int trip)</span>
 {
 	enum thermal_trip_type type;
 
<span class="p_add">+	/* Ignore disabled trip points */</span>
<span class="p_add">+	if (test_bit(trip, &amp;tz-&gt;trips_disabled))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	tz-&gt;ops-&gt;get_trip_type(tz, trip, &amp;type);
 
 	if (type == THERMAL_TRIP_CRITICAL || type == THERMAL_TRIP_HOT)
<span class="p_chunk">@@ -1796,6 +1800,7 @@</span> <span class="p_context"> struct thermal_zone_device *thermal_zone_device_register(const char *type,</span>
 {
 	struct thermal_zone_device *tz;
 	enum thermal_trip_type trip_type;
<span class="p_add">+	int trip_temp;</span>
 	int result;
 	int count;
 	int passive = 0;
<span class="p_chunk">@@ -1867,9 +1872,15 @@</span> <span class="p_context"> struct thermal_zone_device *thermal_zone_device_register(const char *type,</span>
 		goto unregister;
 
 	for (count = 0; count &lt; trips; count++) {
<span class="p_del">-		tz-&gt;ops-&gt;get_trip_type(tz, count, &amp;trip_type);</span>
<span class="p_add">+		if (tz-&gt;ops-&gt;get_trip_type(tz, count, &amp;trip_type))</span>
<span class="p_add">+			set_bit(count, &amp;tz-&gt;trips_disabled);</span>
 		if (trip_type == THERMAL_TRIP_PASSIVE)
 			passive = 1;
<span class="p_add">+		if (tz-&gt;ops-&gt;get_trip_temp(tz, count, &amp;trip_temp))</span>
<span class="p_add">+			set_bit(count, &amp;tz-&gt;trips_disabled);</span>
<span class="p_add">+		/* Check for bogus trip points */</span>
<span class="p_add">+		if (trip_temp == 0)</span>
<span class="p_add">+			set_bit(count, &amp;tz-&gt;trips_disabled);</span>
 	}
 
 	if (!passive) {
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">index 52d82d2ac726..56ccbcefdd85 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_chunk">@@ -713,22 +713,16 @@</span> <span class="p_context"> static int size_fifo(struct uart_8250_port *up)</span>
  */
 static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
 {
<span class="p_del">-	unsigned char old_dll, old_dlm, old_lcr;</span>
<span class="p_del">-	unsigned int id;</span>
<span class="p_add">+	unsigned char old_lcr;</span>
<span class="p_add">+	unsigned int id, old_dl;</span>
 
 	old_lcr = serial_in(p, UART_LCR);
 	serial_out(p, UART_LCR, UART_LCR_CONF_MODE_A);
<span class="p_add">+	old_dl = serial_dl_read(p);</span>
<span class="p_add">+	serial_dl_write(p, 0);</span>
<span class="p_add">+	id = serial_dl_read(p);</span>
<span class="p_add">+	serial_dl_write(p, old_dl);</span>
 
<span class="p_del">-	old_dll = serial_in(p, UART_DLL);</span>
<span class="p_del">-	old_dlm = serial_in(p, UART_DLM);</span>
<span class="p_del">-</span>
<span class="p_del">-	serial_out(p, UART_DLL, 0);</span>
<span class="p_del">-	serial_out(p, UART_DLM, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	id = serial_in(p, UART_DLL) | serial_in(p, UART_DLM) &lt;&lt; 8;</span>
<span class="p_del">-</span>
<span class="p_del">-	serial_out(p, UART_DLL, old_dll);</span>
<span class="p_del">-	serial_out(p, UART_DLM, old_dlm);</span>
 	serial_out(p, UART_LCR, old_lcr);
 
 	return id;
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index fa4e23930614..d37fdcc3143c 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1114,6 +1114,9 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	if (quirks == NO_UNION_NORMAL) {
 		data_interface = usb_ifnum_to_if(usb_dev, 1);
 		control_interface = usb_ifnum_to_if(usb_dev, 0);
<span class="p_add">+		/* we would crash */</span>
<span class="p_add">+		if (!data_interface || !control_interface)</span>
<span class="p_add">+			return -ENODEV;</span>
 		goto skip_normal_probe;
 	}
 
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index 56593a9a8726..2057d91d8336 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -502,11 +502,15 @@</span> <span class="p_context"> static int usb_unbind_interface(struct device *dev)</span>
 int usb_driver_claim_interface(struct usb_driver *driver,
 				struct usb_interface *iface, void *priv)
 {
<span class="p_del">-	struct device *dev = &amp;iface-&gt;dev;</span>
<span class="p_add">+	struct device *dev;</span>
 	struct usb_device *udev;
 	int retval = 0;
 	int lpm_disable_error;
 
<span class="p_add">+	if (!iface)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev = &amp;iface-&gt;dev;</span>
 	if (dev-&gt;driver)
 		return -EBUSY;
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 1560f3f3e756..2a274884c7ea 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -4277,7 +4277,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 {
 	struct usb_device	*hdev = hub-&gt;hdev;
 	struct usb_hcd		*hcd = bus_to_hcd(hdev-&gt;bus);
<span class="p_del">-	int			i, j, retval;</span>
<span class="p_add">+	int			retries, operations, retval, i;</span>
 	unsigned		delay = HUB_SHORT_RESET_TIME;
 	enum usb_device_speed	oldspeed = udev-&gt;speed;
 	const char		*speed;
<span class="p_chunk">@@ -4379,7 +4379,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	 * first 8 bytes of the device descriptor to get the ep0 maxpacket
 	 * value.
 	 */
<span class="p_del">-	for (i = 0; i &lt; GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {</span>
<span class="p_add">+	for (retries = 0; retries &lt; GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {</span>
 		bool did_new_scheme = false;
 
 		if (use_new_scheme(udev, retry_counter)) {
<span class="p_chunk">@@ -4406,7 +4406,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
<span class="p_del">-			for (j = 0; j &lt; 3; ++j) {</span>
<span class="p_add">+			for (operations = 0; operations &lt; 3; ++operations) {</span>
 				buf-&gt;bMaxPacketSize0 = 0;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
<span class="p_chunk">@@ -4426,7 +4426,13 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 						r = -EPROTO;
 					break;
 				}
<span class="p_del">-				if (r == 0)</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Some devices time out if they are powered on</span>
<span class="p_add">+				 * when already connected. They need a second</span>
<span class="p_add">+				 * reset. But only on the first attempt,</span>
<span class="p_add">+				 * lest we get into a time out/reset loop</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (r == 0  || (r == -ETIMEDOUT &amp;&amp; retries == 0))</span>
 					break;
 			}
 			udev-&gt;descriptor.bMaxPacketSize0 =
<span class="p_chunk">@@ -4458,7 +4464,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 		 * authorization will assign the final address.
 		 */
 		if (udev-&gt;wusb == 0) {
<span class="p_del">-			for (j = 0; j &lt; SET_ADDRESS_TRIES; ++j) {</span>
<span class="p_add">+			for (operations = 0; operations &lt; SET_ADDRESS_TRIES; ++operations) {</span>
 				retval = hub_set_address(udev, devnum);
 				if (retval &gt;= 0)
 					break;
<span class="p_header">diff --git a/drivers/usb/misc/iowarrior.c b/drivers/usb/misc/iowarrior.c</span>
<span class="p_header">index c6bfd13f6c92..1950e87b4219 100644</span>
<span class="p_header">--- a/drivers/usb/misc/iowarrior.c</span>
<span class="p_header">+++ b/drivers/usb/misc/iowarrior.c</span>
<span class="p_chunk">@@ -787,6 +787,12 @@</span> <span class="p_context"> static int iowarrior_probe(struct usb_interface *interface,</span>
 	iface_desc = interface-&gt;cur_altsetting;
 	dev-&gt;product_id = le16_to_cpu(udev-&gt;descriptor.idProduct);
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;interface-&gt;dev, &quot;Invalid number of endpoints\n&quot;);</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* set up the endpoint information */
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {
 		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 7a76fe4c2f9e..bdc0f2f24f19 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -164,6 +164,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
 	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
 	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
<span class="p_add">+	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */</span>
 	{ USB_DEVICE(0x19CF, 0x3000) }, /* Parrot NMEA GPS Flight Recorder */
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
<span class="p_header">diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c</span>
<span class="p_header">index 01bf53392819..244acb1299a9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cypress_m8.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cypress_m8.c</span>
<span class="p_chunk">@@ -447,6 +447,11 @@</span> <span class="p_context"> static int cypress_generic_port_probe(struct usb_serial_port *port)</span>
 	struct usb_serial *serial = port-&gt;serial;
 	struct cypress_private *priv;
 
<span class="p_add">+	if (!port-&gt;interrupt_out_urb || !port-&gt;interrupt_in_urb) {</span>
<span class="p_add">+		dev_err(&amp;port-&gt;dev, &quot;required endpoint is missing\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
<span class="p_chunk">@@ -606,12 +611,6 @@</span> <span class="p_context"> static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)</span>
 		cypress_set_termios(tty, port, &amp;priv-&gt;tmp_termios);
 
 	/* setup the port and start reading from the device */
<span class="p_del">-	if (!port-&gt;interrupt_in_urb) {</span>
<span class="p_del">-		dev_err(&amp;port-&gt;dev, &quot;%s - interrupt_in_urb is empty!\n&quot;,</span>
<span class="p_del">-			__func__);</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	usb_fill_int_urb(port-&gt;interrupt_in_urb, serial-&gt;dev,
 		usb_rcvintpipe(serial-&gt;dev, port-&gt;interrupt_in_endpointAddress),
 		port-&gt;interrupt_in_urb-&gt;transfer_buffer,
<span class="p_header">diff --git a/drivers/usb/serial/digi_acceleport.c b/drivers/usb/serial/digi_acceleport.c</span>
<span class="p_header">index 12b0e67473ba..3df7b7ec178e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/digi_acceleport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/digi_acceleport.c</span>
<span class="p_chunk">@@ -1251,8 +1251,27 @@</span> <span class="p_context"> static int digi_port_init(struct usb_serial_port *port, unsigned port_num)</span>
 
 static int digi_startup(struct usb_serial *serial)
 {
<span class="p_add">+	struct device *dev = &amp;serial-&gt;interface-&gt;dev;</span>
 	struct digi_serial *serial_priv;
 	int ret;
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* check whether the device has the expected number of endpoints */</span>
<span class="p_add">+	if (serial-&gt;num_port_pointers &lt; serial-&gt;type-&gt;num_ports + 1) {</span>
<span class="p_add">+		dev_err(dev, &quot;OOB endpoints missing\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; serial-&gt;type-&gt;num_ports + 1 ; i++) {</span>
<span class="p_add">+		if (!serial-&gt;port[i]-&gt;read_urb) {</span>
<span class="p_add">+			dev_err(dev, &quot;bulk-in endpoint missing\n&quot;);</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!serial-&gt;port[i]-&gt;write_urb) {</span>
<span class="p_add">+			dev_err(dev, &quot;bulk-out endpoint missing\n&quot;);</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);
 	if (!serial_priv)
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 8c660ae401d8..b61f12160d37 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1004,6 +1004,10 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_DISPLAY_PID) },
 	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_LITE_PID) },
 	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ANALOG_PID) },
<span class="p_add">+	/* ICP DAS I-756xU devices */</span>
<span class="p_add">+	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index a84df2513994..c5d6c1e73e8e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -872,6 +872,14 @@</span> <span class="p_context"></span>
 #define NOVITUS_BONO_E_PID		0x6010
 
 /*
<span class="p_add">+ * ICPDAS I-756*U devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ICPDAS_VID			0x1b5c</span>
<span class="p_add">+#define ICPDAS_I7560U_PID		0x0103</span>
<span class="p_add">+#define ICPDAS_I7561U_PID		0x0104</span>
<span class="p_add">+#define ICPDAS_I7563U_PID		0x0105</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * RT Systems programming cables for various ham radios
  */
 #define RTSYSTEMS_VID		0x2100	/* Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mct_u232.c b/drivers/usb/serial/mct_u232.c</span>
<span class="p_header">index fd707d6a10e2..89726f702202 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mct_u232.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mct_u232.c</span>
<span class="p_chunk">@@ -376,14 +376,21 @@</span> <span class="p_context"> static void mct_u232_msr_to_state(struct usb_serial_port *port,</span>
 
 static int mct_u232_port_probe(struct usb_serial_port *port)
 {
<span class="p_add">+	struct usb_serial *serial = port-&gt;serial;</span>
 	struct mct_u232_private *priv;
 
<span class="p_add">+	/* check first to simplify error handling */</span>
<span class="p_add">+	if (!serial-&gt;port[1] || !serial-&gt;port[1]-&gt;interrupt_in_urb) {</span>
<span class="p_add">+		dev_err(&amp;port-&gt;dev, &quot;expected endpoint missing\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
 
 	/* Use second interrupt-in endpoint for reading. */
<span class="p_del">-	priv-&gt;read_urb = port-&gt;serial-&gt;port[1]-&gt;interrupt_in_urb;</span>
<span class="p_add">+	priv-&gt;read_urb = serial-&gt;port[1]-&gt;interrupt_in_urb;</span>
 	priv-&gt;read_urb-&gt;context = port;
 
 	spin_lock_init(&amp;priv-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 348e19834b83..c6f497f16526 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1818,6 +1818,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d02, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x02, 0x01) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e19, 0xff),			/* D-Link DWM-221 B1 */</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
 	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 5c66d3f7a6d0..ce0cd6e20d4f 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -812,7 +812,7 @@</span> <span class="p_context"> static struct scsi_host_template uas_host_template = {</span>
 	.slave_configure = uas_slave_configure,
 	.eh_abort_handler = uas_eh_abort_handler,
 	.eh_bus_reset_handler = uas_eh_bus_reset_handler,
<span class="p_del">-	.can_queue = 65536,	/* Is there a limit on the _host_ ? */</span>
<span class="p_add">+	.can_queue = MAX_CMNDS,</span>
 	.this_id = -1,
 	.sg_tablesize = SG_NONE,
 	.skip_settle_delay = 1,
<span class="p_header">diff --git a/drivers/watchdog/rc32434_wdt.c b/drivers/watchdog/rc32434_wdt.c</span>
<span class="p_header">index 71e78ef4b736..3a75f3b53452 100644</span>
<span class="p_header">--- a/drivers/watchdog/rc32434_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/rc32434_wdt.c</span>
<span class="p_chunk">@@ -237,7 +237,7 @@</span> <span class="p_context"> static long rc32434_wdt_ioctl(struct file *file, unsigned int cmd,</span>
 			return -EINVAL;
 		/* Fall through */
 	case WDIOC_GETTIMEOUT:
<span class="p_del">-		return copy_to_user(argp, &amp;timeout, sizeof(int));</span>
<span class="p_add">+		return copy_to_user(argp, &amp;timeout, sizeof(int)) ? -EFAULT : 0;</span>
 	default:
 		return -ENOTTY;
 	}
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index 1777331eee76..dfc87c5f5a54 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -32,6 +32,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/pipe_fs_i.h&gt;
 #include &lt;linux/oom.h&gt;
 #include &lt;linux/compat.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/fs.h&gt;</span>
<span class="p_add">+#include &lt;linux/path.h&gt;</span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_chunk">@@ -627,6 +630,8 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 		}
 	} else {
 		struct inode *inode;
<span class="p_add">+		int open_flags = O_CREAT | O_RDWR | O_NOFOLLOW |</span>
<span class="p_add">+				 O_LARGEFILE | O_EXCL;</span>
 
 		if (cprm.limit &lt; binfmt-&gt;min_coredump)
 			goto fail_unlock;
<span class="p_chunk">@@ -665,10 +670,27 @@</span> <span class="p_context"> void do_coredump(const siginfo_t *siginfo)</span>
 		 * what matters is that at least one of the two processes
 		 * writes its coredump successfully, not which one.
 		 */
<span class="p_del">-		cprm.file = filp_open(cn.corename,</span>
<span class="p_del">-				 O_CREAT | 2 | O_NOFOLLOW |</span>
<span class="p_del">-				 O_LARGEFILE | O_EXCL,</span>
<span class="p_del">-				 0600);</span>
<span class="p_add">+		if (need_suid_safe) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Using user namespaces, normal user tasks can change</span>
<span class="p_add">+			 * their current-&gt;fs-&gt;root to point to arbitrary</span>
<span class="p_add">+			 * directories. Since the intention of the &quot;only dump</span>
<span class="p_add">+			 * with a fully qualified path&quot; rule is to control where</span>
<span class="p_add">+			 * coredumps may be placed using root privileges,</span>
<span class="p_add">+			 * current-&gt;fs-&gt;root must not be used. Instead, use the</span>
<span class="p_add">+			 * root directory of init_task.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			struct path root;</span>
<span class="p_add">+</span>
<span class="p_add">+			task_lock(&amp;init_task);</span>
<span class="p_add">+			get_fs_root(init_task.fs, &amp;root);</span>
<span class="p_add">+			task_unlock(&amp;init_task);</span>
<span class="p_add">+			cprm.file = file_open_root(root.dentry, root.mnt,</span>
<span class="p_add">+				cn.corename, open_flags, 0600);</span>
<span class="p_add">+			path_put(&amp;root);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			cprm.file = filp_open(cn.corename, open_flags, 0600);</span>
<span class="p_add">+		}</span>
 		if (IS_ERR(cprm.file))
 			goto fail_unlock;
 
<span class="p_header">diff --git a/fs/fhandle.c b/fs/fhandle.c</span>
<span class="p_header">index d59712dfa3e7..ca3c3dd01789 100644</span>
<span class="p_header">--- a/fs/fhandle.c</span>
<span class="p_header">+++ b/fs/fhandle.c</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> long do_handle_open(int mountdirfd,</span>
 		path_put(&amp;path);
 		return fd;
 	}
<span class="p_del">-	file = file_open_root(path.dentry, path.mnt, &quot;&quot;, open_flag);</span>
<span class="p_add">+	file = file_open_root(path.dentry, path.mnt, &quot;&quot;, open_flag, 0);</span>
 	if (IS_ERR(file)) {
 		put_unused_fd(fd);
 		retval =  PTR_ERR(file);
<span class="p_header">diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c</span>
<span class="p_header">index 7a8ea1351584..60d6fc2e0e4b 100644</span>
<span class="p_header">--- a/fs/fs-writeback.c</span>
<span class="p_header">+++ b/fs/fs-writeback.c</span>
<span class="p_chunk">@@ -281,13 +281,15 @@</span> <span class="p_context"> locked_inode_to_wb_and_lock_list(struct inode *inode)</span>
 		wb_get(wb);
 		spin_unlock(&amp;inode-&gt;i_lock);
 		spin_lock(&amp;wb-&gt;list_lock);
<span class="p_del">-		wb_put(wb);		/* not gonna deref it anymore */</span>
 
 		/* i_wb may have changed inbetween, can&#39;t use inode_to_wb() */
<span class="p_del">-		if (likely(wb == inode-&gt;i_wb))</span>
<span class="p_del">-			return wb;	/* @inode already has ref */</span>
<span class="p_add">+		if (likely(wb == inode-&gt;i_wb)) {</span>
<span class="p_add">+			wb_put(wb);	/* @inode already has ref */</span>
<span class="p_add">+			return wb;</span>
<span class="p_add">+		}</span>
 
 		spin_unlock(&amp;wb-&gt;list_lock);
<span class="p_add">+		wb_put(wb);</span>
 		cpu_relax();
 		spin_lock(&amp;inode-&gt;i_lock);
 	}
<span class="p_chunk">@@ -1339,10 +1341,10 @@</span> <span class="p_context"> __writeback_single_inode(struct inode *inode, struct writeback_control *wbc)</span>
  * we go e.g. from filesystem. Flusher thread uses __writeback_single_inode()
  * and does more profound writeback list handling in writeback_sb_inodes().
  */
<span class="p_del">-static int</span>
<span class="p_del">-writeback_single_inode(struct inode *inode, struct bdi_writeback *wb,</span>
<span class="p_del">-		       struct writeback_control *wbc)</span>
<span class="p_add">+static int writeback_single_inode(struct inode *inode,</span>
<span class="p_add">+				  struct writeback_control *wbc)</span>
 {
<span class="p_add">+	struct bdi_writeback *wb;</span>
 	int ret = 0;
 
 	spin_lock(&amp;inode-&gt;i_lock);
<span class="p_chunk">@@ -1380,7 +1382,8 @@</span> <span class="p_context"> writeback_single_inode(struct inode *inode, struct bdi_writeback *wb,</span>
 	ret = __writeback_single_inode(inode, wbc);
 
 	wbc_detach_inode(wbc);
<span class="p_del">-	spin_lock(&amp;wb-&gt;list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	wb = inode_to_wb_and_lock_list(inode);</span>
 	spin_lock(&amp;inode-&gt;i_lock);
 	/*
 	 * If inode is clean, remove it from writeback lists. Otherwise don&#39;t
<span class="p_chunk">@@ -1455,6 +1458,7 @@</span> <span class="p_context"> static long writeback_sb_inodes(struct super_block *sb,</span>
 
 	while (!list_empty(&amp;wb-&gt;b_io)) {
 		struct inode *inode = wb_inode(wb-&gt;b_io.prev);
<span class="p_add">+		struct bdi_writeback *tmp_wb;</span>
 
 		if (inode-&gt;i_sb != sb) {
 			if (work-&gt;sb) {
<span class="p_chunk">@@ -1545,15 +1549,23 @@</span> <span class="p_context"> static long writeback_sb_inodes(struct super_block *sb,</span>
 			cond_resched();
 		}
 
<span class="p_del">-</span>
<span class="p_del">-		spin_lock(&amp;wb-&gt;list_lock);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Requeue @inode if still dirty.  Be careful as @inode may</span>
<span class="p_add">+		 * have been switched to another wb in the meantime.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmp_wb = inode_to_wb_and_lock_list(inode);</span>
 		spin_lock(&amp;inode-&gt;i_lock);
 		if (!(inode-&gt;i_state &amp; I_DIRTY_ALL))
 			wrote++;
<span class="p_del">-		requeue_inode(inode, wb, &amp;wbc);</span>
<span class="p_add">+		requeue_inode(inode, tmp_wb, &amp;wbc);</span>
 		inode_sync_complete(inode);
 		spin_unlock(&amp;inode-&gt;i_lock);
 
<span class="p_add">+		if (unlikely(tmp_wb != wb)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmp_wb-&gt;list_lock);</span>
<span class="p_add">+			spin_lock(&amp;wb-&gt;list_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * bail out to wb_writeback() often enough to check
 		 * background threshold and other termination conditions.
<span class="p_chunk">@@ -2340,7 +2352,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(sync_inodes_sb);</span>
  */
 int write_inode_now(struct inode *inode, int sync)
 {
<span class="p_del">-	struct bdi_writeback *wb = &amp;inode_to_bdi(inode)-&gt;wb;</span>
 	struct writeback_control wbc = {
 		.nr_to_write = LONG_MAX,
 		.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,
<span class="p_chunk">@@ -2352,7 +2363,7 @@</span> <span class="p_context"> int write_inode_now(struct inode *inode, int sync)</span>
 		wbc.nr_to_write = 0;
 
 	might_sleep();
<span class="p_del">-	return writeback_single_inode(inode, wb, &amp;wbc);</span>
<span class="p_add">+	return writeback_single_inode(inode, &amp;wbc);</span>
 }
 EXPORT_SYMBOL(write_inode_now);
 
<span class="p_chunk">@@ -2369,7 +2380,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(write_inode_now);</span>
  */
 int sync_inode(struct inode *inode, struct writeback_control *wbc)
 {
<span class="p_del">-	return writeback_single_inode(inode, &amp;inode_to_bdi(inode)-&gt;wb, wbc);</span>
<span class="p_add">+	return writeback_single_inode(inode, wbc);</span>
 }
 EXPORT_SYMBOL(sync_inode);
 
<span class="p_header">diff --git a/fs/fuse/cuse.c b/fs/fuse/cuse.c</span>
<span class="p_header">index 8e3ee1936c7e..c5b6b7165489 100644</span>
<span class="p_header">--- a/fs/fuse/cuse.c</span>
<span class="p_header">+++ b/fs/fuse/cuse.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static struct list_head *cuse_conntbl_head(dev_t devt)</span>
 
 static ssize_t cuse_read_iter(struct kiocb *kiocb, struct iov_iter *to)
 {
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = kiocb-&gt;ki_filp };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(kiocb-&gt;ki_filp);</span>
 	loff_t pos = 0;
 
 	return fuse_direct_io(&amp;io, to, &amp;pos, FUSE_DIO_CUSE);
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static ssize_t cuse_read_iter(struct kiocb *kiocb, struct iov_iter *to)</span>
 
 static ssize_t cuse_write_iter(struct kiocb *kiocb, struct iov_iter *from)
 {
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = kiocb-&gt;ki_filp };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(kiocb-&gt;ki_filp);</span>
 	loff_t pos = 0;
 	/*
 	 * No locking or generic_write_checks(), the server is
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 570ca4053c80..c2e340d6ec6e 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -528,6 +528,11 @@</span> <span class="p_context"> static void fuse_release_user_pages(struct fuse_req *req, int write)</span>
 	}
 }
 
<span class="p_add">+static void fuse_io_release(struct kref *kref)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kfree(container_of(kref, struct fuse_io_priv, refcnt));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ssize_t fuse_get_res_by_io(struct fuse_io_priv *io)
 {
 	if (io-&gt;err)
<span class="p_chunk">@@ -585,8 +590,9 @@</span> <span class="p_context"> static void fuse_aio_complete(struct fuse_io_priv *io, int err, ssize_t pos)</span>
 		}
 
 		io-&gt;iocb-&gt;ki_complete(io-&gt;iocb, res, 0);
<span class="p_del">-		kfree(io);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	kref_put(&amp;io-&gt;refcnt, fuse_io_release);</span>
 }
 
 static void fuse_aio_complete_req(struct fuse_conn *fc, struct fuse_req *req)
<span class="p_chunk">@@ -613,6 +619,7 @@</span> <span class="p_context"> static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req *req,</span>
 		size_t num_bytes, struct fuse_io_priv *io)
 {
 	spin_lock(&amp;io-&gt;lock);
<span class="p_add">+	kref_get(&amp;io-&gt;refcnt);</span>
 	io-&gt;size += num_bytes;
 	io-&gt;reqs++;
 	spin_unlock(&amp;io-&gt;lock);
<span class="p_chunk">@@ -691,7 +698,7 @@</span> <span class="p_context"> static void fuse_short_read(struct fuse_req *req, struct inode *inode,</span>
 
 static int fuse_do_readpage(struct file *file, struct page *page)
 {
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = file };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(file);</span>
 	struct inode *inode = page-&gt;mapping-&gt;host;
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_req *req;
<span class="p_chunk">@@ -984,7 +991,7 @@</span> <span class="p_context"> static size_t fuse_send_write_pages(struct fuse_req *req, struct file *file,</span>
 	size_t res;
 	unsigned offset;
 	unsigned i;
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = file };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(file);</span>
 
 	for (i = 0; i &lt; req-&gt;num_pages; i++)
 		fuse_wait_on_page_writeback(inode, req-&gt;pages[i]-&gt;index);
<span class="p_chunk">@@ -1398,7 +1405,7 @@</span> <span class="p_context"> static ssize_t __fuse_direct_read(struct fuse_io_priv *io,</span>
 
 static ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)
 {
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = iocb-&gt;ki_filp };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(iocb-&gt;ki_filp);</span>
 	return __fuse_direct_read(&amp;io, to, &amp;iocb-&gt;ki_pos);
 }
 
<span class="p_chunk">@@ -1406,7 +1413,7 @@</span> <span class="p_context"> static ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)</span>
 {
 	struct file *file = iocb-&gt;ki_filp;
 	struct inode *inode = file_inode(file);
<span class="p_del">-	struct fuse_io_priv io = { .async = 0, .file = file };</span>
<span class="p_add">+	struct fuse_io_priv io = FUSE_IO_PRIV_SYNC(file);</span>
 	ssize_t res;
 
 	if (is_bad_inode(inode))
<span class="p_chunk">@@ -2786,6 +2793,7 @@</span> <span class="p_context"> fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)</span>
 	loff_t i_size;
 	size_t count = iov_iter_count(iter);
 	struct fuse_io_priv *io;
<span class="p_add">+	bool is_sync = is_sync_kiocb(iocb);</span>
 
 	pos = offset;
 	inode = file-&gt;f_mapping-&gt;host;
<span class="p_chunk">@@ -2806,6 +2814,7 @@</span> <span class="p_context"> fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)</span>
 	if (!io)
 		return -ENOMEM;
 	spin_lock_init(&amp;io-&gt;lock);
<span class="p_add">+	kref_init(&amp;io-&gt;refcnt);</span>
 	io-&gt;reqs = 1;
 	io-&gt;bytes = -1;
 	io-&gt;size = 0;
<span class="p_chunk">@@ -2825,12 +2834,18 @@</span> <span class="p_context"> fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)</span>
 	 * to wait on real async I/O requests, so we must submit this request
 	 * synchronously.
 	 */
<span class="p_del">-	if (!is_sync_kiocb(iocb) &amp;&amp; (offset + count &gt; i_size) &amp;&amp;</span>
<span class="p_add">+	if (!is_sync &amp;&amp; (offset + count &gt; i_size) &amp;&amp;</span>
 	    iov_iter_rw(iter) == WRITE)
 		io-&gt;async = false;
 
<span class="p_del">-	if (io-&gt;async &amp;&amp; is_sync_kiocb(iocb))</span>
<span class="p_add">+	if (io-&gt;async &amp;&amp; is_sync) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Additional reference to keep io around after</span>
<span class="p_add">+		 * calling fuse_aio_complete()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		kref_get(&amp;io-&gt;refcnt);</span>
 		io-&gt;done = &amp;wait;
<span class="p_add">+	}</span>
 
 	if (iov_iter_rw(iter) == WRITE) {
 		ret = fuse_direct_io(io, iter, &amp;pos, FUSE_DIO_WRITE);
<span class="p_chunk">@@ -2843,14 +2858,14 @@</span> <span class="p_context"> fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)</span>
 		fuse_aio_complete(io, ret &lt; 0 ? ret : 0, -1);
 
 		/* we have a non-extending, async request, so return */
<span class="p_del">-		if (!is_sync_kiocb(iocb))</span>
<span class="p_add">+		if (!is_sync)</span>
 			return -EIOCBQUEUED;
 
 		wait_for_completion(&amp;wait);
 		ret = fuse_get_res_by_io(io);
 	}
 
<span class="p_del">-	kfree(io);</span>
<span class="p_add">+	kref_put(&amp;io-&gt;refcnt, fuse_io_release);</span>
 
 	if (iov_iter_rw(iter) == WRITE) {
 		if (ret &gt; 0)
<span class="p_header">diff --git a/fs/fuse/fuse_i.h b/fs/fuse/fuse_i.h</span>
<span class="p_header">index 405113101db8..604cd42dafef 100644</span>
<span class="p_header">--- a/fs/fuse/fuse_i.h</span>
<span class="p_header">+++ b/fs/fuse/fuse_i.h</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rbtree.h&gt;
 #include &lt;linux/poll.h&gt;
 #include &lt;linux/workqueue.h&gt;
<span class="p_add">+#include &lt;linux/kref.h&gt;</span>
 
 /** Max number of pages that can be used in a single read request */
 #define FUSE_MAX_PAGES_PER_REQ 32
<span class="p_chunk">@@ -243,6 +244,7 @@</span> <span class="p_context"> struct fuse_args {</span>
 
 /** The request IO state (for asynchronous processing) */
 struct fuse_io_priv {
<span class="p_add">+	struct kref refcnt;</span>
 	int async;
 	spinlock_t lock;
 	unsigned reqs;
<span class="p_chunk">@@ -256,6 +258,13 @@</span> <span class="p_context"> struct fuse_io_priv {</span>
 	struct completion *done;
 };
 
<span class="p_add">+#define FUSE_IO_PRIV_SYNC(f) \</span>
<span class="p_add">+{					\</span>
<span class="p_add">+	.refcnt = { ATOMIC_INIT(1) },	\</span>
<span class="p_add">+	.async = 0,			\</span>
<span class="p_add">+	.file = f,			\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * Request flags
  *
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 81e622681c82..624a57a9c4aa 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -1408,11 +1408,12 @@</span> <span class="p_context"> out:</span>
 /**
  * jbd2_mark_journal_empty() - Mark on disk journal as empty.
  * @journal: The journal to update.
<span class="p_add">+ * @write_op: With which operation should we write the journal sb</span>
  *
  * Update a journal&#39;s dynamic superblock fields to show that journal is empty.
  * Write updated superblock to disk waiting for IO to complete.
  */
<span class="p_del">-static void jbd2_mark_journal_empty(journal_t *journal)</span>
<span class="p_add">+static void jbd2_mark_journal_empty(journal_t *journal, int write_op)</span>
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
 
<span class="p_chunk">@@ -1430,7 +1431,7 @@</span> <span class="p_context"> static void jbd2_mark_journal_empty(journal_t *journal)</span>
 	sb-&gt;s_start    = cpu_to_be32(0);
 	read_unlock(&amp;journal-&gt;j_state_lock);
 
<span class="p_del">-	jbd2_write_superblock(journal, WRITE_FUA);</span>
<span class="p_add">+	jbd2_write_superblock(journal, write_op);</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
<span class="p_chunk">@@ -1716,7 +1717,13 @@</span> <span class="p_context"> int jbd2_journal_destroy(journal_t *journal)</span>
 	if (journal-&gt;j_sb_buffer) {
 		if (!is_journal_aborted(journal)) {
 			mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-			jbd2_mark_journal_empty(journal);</span>
<span class="p_add">+</span>
<span class="p_add">+			write_lock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+			journal-&gt;j_tail_sequence =</span>
<span class="p_add">+				++journal-&gt;j_transaction_sequence;</span>
<span class="p_add">+			write_unlock(&amp;journal-&gt;j_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			jbd2_mark_journal_empty(journal, WRITE_FLUSH_FUA);</span>
 			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);
 		} else
 			err = -EIO;
<span class="p_chunk">@@ -1975,7 +1982,7 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	 * the magic code for a fully-recovered superblock.  Any future
 	 * commits of data to the journal will restore the current
 	 * s_start value. */
<span class="p_del">-	jbd2_mark_journal_empty(journal);</span>
<span class="p_add">+	jbd2_mark_journal_empty(journal, WRITE_FUA);</span>
 	mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);
 	write_lock(&amp;journal-&gt;j_state_lock);
 	J_ASSERT(!journal-&gt;j_running_transaction);
<span class="p_chunk">@@ -2021,7 +2028,7 @@</span> <span class="p_context"> int jbd2_journal_wipe(journal_t *journal, int write)</span>
 	if (write) {
 		/* Lock to make assertions happy... */
 		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-		jbd2_mark_journal_empty(journal);</span>
<span class="p_add">+		jbd2_mark_journal_empty(journal, WRITE_FUA);</span>
 		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);
 	}
 
<span class="p_header">diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c</span>
<span class="p_header">index a9f096c7e99f..7d5351cd67fb 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4proc.c</span>
<span class="p_chunk">@@ -877,6 +877,7 @@</span> <span class="p_context"> nfsd4_secinfo(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 				    &amp;exp, &amp;dentry);
 	if (err)
 		return err;
<span class="p_add">+	fh_unlock(&amp;cstate-&gt;current_fh);</span>
 	if (d_really_is_negative(dentry)) {
 		exp_put(exp);
 		err = nfserr_noent;
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index 51c9e9ca39a4..12935209deca 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -1072,8 +1072,9 @@</span> <span class="p_context"> nfsd4_decode_rename(struct nfsd4_compoundargs *argp, struct nfsd4_rename *rename</span>
 
 	READ_BUF(4);
 	rename-&gt;rn_snamelen = be32_to_cpup(p++);
<span class="p_del">-	READ_BUF(rename-&gt;rn_snamelen + 4);</span>
<span class="p_add">+	READ_BUF(rename-&gt;rn_snamelen);</span>
 	SAVEMEM(rename-&gt;rn_sname, rename-&gt;rn_snamelen);
<span class="p_add">+	READ_BUF(4);</span>
 	rename-&gt;rn_tnamelen = be32_to_cpup(p++);
 	READ_BUF(rename-&gt;rn_tnamelen);
 	SAVEMEM(rename-&gt;rn_tname, rename-&gt;rn_tnamelen);
<span class="p_chunk">@@ -1155,13 +1156,14 @@</span> <span class="p_context"> nfsd4_decode_setclientid(struct nfsd4_compoundargs *argp, struct nfsd4_setclient</span>
 	READ_BUF(8);
 	setclientid-&gt;se_callback_prog = be32_to_cpup(p++);
 	setclientid-&gt;se_callback_netid_len = be32_to_cpup(p++);
<span class="p_del">-</span>
<span class="p_del">-	READ_BUF(setclientid-&gt;se_callback_netid_len + 4);</span>
<span class="p_add">+	READ_BUF(setclientid-&gt;se_callback_netid_len);</span>
 	SAVEMEM(setclientid-&gt;se_callback_netid_val, setclientid-&gt;se_callback_netid_len);
<span class="p_add">+	READ_BUF(4);</span>
 	setclientid-&gt;se_callback_addr_len = be32_to_cpup(p++);
 
<span class="p_del">-	READ_BUF(setclientid-&gt;se_callback_addr_len + 4);</span>
<span class="p_add">+	READ_BUF(setclientid-&gt;se_callback_addr_len);</span>
 	SAVEMEM(setclientid-&gt;se_callback_addr_val, setclientid-&gt;se_callback_addr_len);
<span class="p_add">+	READ_BUF(4);</span>
 	setclientid-&gt;se_callback_ident = be32_to_cpup(p++);
 
 	DECODE_TAIL;
<span class="p_chunk">@@ -1815,8 +1817,9 @@</span> <span class="p_context"> nfsd4_decode_compound(struct nfsd4_compoundargs *argp)</span>
 
 	READ_BUF(4);
 	argp-&gt;taglen = be32_to_cpup(p++);
<span class="p_del">-	READ_BUF(argp-&gt;taglen + 8);</span>
<span class="p_add">+	READ_BUF(argp-&gt;taglen);</span>
 	SAVEMEM(argp-&gt;tag, argp-&gt;taglen);
<span class="p_add">+	READ_BUF(8);</span>
 	argp-&gt;minorversion = be32_to_cpup(p++);
 	argp-&gt;opcnt = be32_to_cpup(p++);
 	max_reply += 4 + (XDR_QUADLEN(argp-&gt;taglen) &lt;&lt; 2);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">index e36d63ff1783..f90931335c6b 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_chunk">@@ -262,6 +262,7 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
<span class="p_add">+	u8 old_owner = res-&gt;owner;</span>
 
 	mlog(0, &quot;type=%d, convert_type=%d, busy=%d\n&quot;, lock-&gt;ml.type,
 	     lock-&gt;ml.convert_type, res-&gt;state &amp; DLM_LOCK_RES_IN_PROGRESS);
<span class="p_chunk">@@ -287,6 +288,19 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 		status = DLM_DENIED;
 		goto bail;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (lock-&gt;ml.type == type &amp;&amp; lock-&gt;ml.convert_type == LKM_IVMODE) {</span>
<span class="p_add">+		mlog(0, &quot;last convert request returned DLM_RECOVERING, but &quot;</span>
<span class="p_add">+		     &quot;owner has already queued and sent ast to me. res %.*s, &quot;</span>
<span class="p_add">+		     &quot;(cookie=%u:%llu, type=%d, conv=%d)\n&quot;,</span>
<span class="p_add">+		     res-&gt;lockname.len, res-&gt;lockname.name,</span>
<span class="p_add">+		     dlm_get_lock_cookie_node(be64_to_cpu(lock-&gt;ml.cookie)),</span>
<span class="p_add">+		     dlm_get_lock_cookie_seq(be64_to_cpu(lock-&gt;ml.cookie)),</span>
<span class="p_add">+		     lock-&gt;ml.type, lock-&gt;ml.convert_type);</span>
<span class="p_add">+		status = DLM_NORMAL;</span>
<span class="p_add">+		goto bail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	res-&gt;state |= DLM_LOCK_RES_IN_PROGRESS;
 	/* move lock to local convert queue */
 	/* do not alter lock refcount.  switching lists. */
<span class="p_chunk">@@ -316,11 +330,19 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 	spin_lock(&amp;res-&gt;spinlock);
 	res-&gt;state &amp;= ~DLM_LOCK_RES_IN_PROGRESS;
 	lock-&gt;convert_pending = 0;
<span class="p_del">-	/* if it failed, move it back to granted queue */</span>
<span class="p_add">+	/* if it failed, move it back to granted queue.</span>
<span class="p_add">+	 * if master returns DLM_NORMAL and then down before sending ast,</span>
<span class="p_add">+	 * it may have already been moved to granted queue, reset to</span>
<span class="p_add">+	 * DLM_RECOVERING and retry convert */</span>
 	if (status != DLM_NORMAL) {
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
<span class="p_add">+	} else if ((res-&gt;state &amp; DLM_LOCK_RES_RECOVERING) ||</span>
<span class="p_add">+			(old_owner != res-&gt;owner)) {</span>
<span class="p_add">+		mlog(0, &quot;res %.*s is in recovering or has been recovered.\n&quot;,</span>
<span class="p_add">+				res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="p_add">+		status = DLM_RECOVERING;</span>
 	}
 bail:
 	spin_unlock(&amp;res-&gt;spinlock);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">index 42f0cae93a0a..4a338803e7e9 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_chunk">@@ -2064,7 +2064,6 @@</span> <span class="p_context"> void dlm_move_lockres_to_recovery_list(struct dlm_ctxt *dlm,</span>
 			dlm_lock_get(lock);
 			if (lock-&gt;convert_pending) {
 				/* move converting lock back to granted */
<span class="p_del">-				BUG_ON(i != DLM_CONVERTING_LIST);</span>
 				mlog(0, &quot;node died with convert pending &quot;
 				     &quot;on %.*s. move back to granted list.\n&quot;,
 				     res-&gt;lockname.len, res-&gt;lockname.name);
<span class="p_header">diff --git a/fs/open.c b/fs/open.c</span>
<span class="p_header">index b6f1e96a7c0b..6a24f988d253 100644</span>
<span class="p_header">--- a/fs/open.c</span>
<span class="p_header">+++ b/fs/open.c</span>
<span class="p_chunk">@@ -995,14 +995,12 @@</span> <span class="p_context"> struct file *filp_open(const char *filename, int flags, umode_t mode)</span>
 EXPORT_SYMBOL(filp_open);
 
 struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,
<span class="p_del">-			    const char *filename, int flags)</span>
<span class="p_add">+			    const char *filename, int flags, umode_t mode)</span>
 {
 	struct open_flags op;
<span class="p_del">-	int err = build_open_flags(flags, 0, &amp;op);</span>
<span class="p_add">+	int err = build_open_flags(flags, mode, &amp;op);</span>
 	if (err)
 		return ERR_PTR(err);
<span class="p_del">-	if (flags &amp; O_CREAT)</span>
<span class="p_del">-		return ERR_PTR(-EINVAL);</span>
 	return do_file_open_root(dentry, mnt, filename, &amp;op);
 }
 EXPORT_SYMBOL(file_open_root);
<span class="p_header">diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c</span>
<span class="p_header">index 8ebd9a334085..87645955990d 100644</span>
<span class="p_header">--- a/fs/proc_namespace.c</span>
<span class="p_header">+++ b/fs/proc_namespace.c</span>
<span class="p_chunk">@@ -197,6 +197,8 @@</span> <span class="p_context"> static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)</span>
 	if (sb-&gt;s_op-&gt;show_devname) {
 		seq_puts(m, &quot;device &quot;);
 		err = sb-&gt;s_op-&gt;show_devname(m, mnt_path.dentry);
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out;</span>
 	} else {
 		if (r-&gt;mnt_devname) {
 			seq_puts(m, &quot;device &quot;);
<span class="p_header">diff --git a/fs/quota/dquot.c b/fs/quota/dquot.c</span>
<span class="p_header">index ef0d64b2a6d9..353ff31dcee1 100644</span>
<span class="p_header">--- a/fs/quota/dquot.c</span>
<span class="p_header">+++ b/fs/quota/dquot.c</span>
<span class="p_chunk">@@ -1398,7 +1398,7 @@</span> <span class="p_context"> static int dquot_active(const struct inode *inode)</span>
 static int __dquot_initialize(struct inode *inode, int type)
 {
 	int cnt, init_needed = 0;
<span class="p_del">-	struct dquot **dquots, *got[MAXQUOTAS];</span>
<span class="p_add">+	struct dquot **dquots, *got[MAXQUOTAS] = {};</span>
 	struct super_block *sb = inode-&gt;i_sb;
 	qsize_t rsv;
 	int ret = 0;
<span class="p_chunk">@@ -1415,7 +1415,6 @@</span> <span class="p_context"> static int __dquot_initialize(struct inode *inode, int type)</span>
 		int rc;
 		struct dquot *dquot;
 
<span class="p_del">-		got[cnt] = NULL;</span>
 		if (type != -1 &amp;&amp; cnt != type)
 			continue;
 		/*
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index 4cf700d50b40..0f77e9682857 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -185,6 +185,9 @@</span> <span class="p_context"> ssize_t splice_to_pipe(struct pipe_inode_info *pipe,</span>
 	unsigned int spd_pages = spd-&gt;nr_pages;
 	int ret, do_wakeup, page_nr;
 
<span class="p_add">+	if (!spd_pages)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ret = 0;
 	do_wakeup = 0;
 	page_nr = 0;
<span class="p_header">diff --git a/fs/xfs/xfs_attr_list.c b/fs/xfs/xfs_attr_list.c</span>
<span class="p_header">index 0ef7c2ed3f8a..4fa14820e2e2 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_list.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_list.c</span>
<span class="p_chunk">@@ -202,8 +202,10 @@</span> <span class="p_context"> xfs_attr_shortform_list(xfs_attr_list_context_t *context)</span>
 					sbp-&gt;namelen,
 					sbp-&gt;valuelen,
 					&amp;sbp-&gt;name[sbp-&gt;namelen]);
<span class="p_del">-		if (error)</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			kmem_free(sbuf);</span>
 			return error;
<span class="p_add">+		}</span>
 		if (context-&gt;seen_enough)
 			break;
 		cursor-&gt;offset++;
<span class="p_chunk">@@ -454,14 +456,13 @@</span> <span class="p_context"> xfs_attr3_leaf_list_int(</span>
 				args.rmtblkcnt = xfs_attr3_rmt_blocks(
 							args.dp-&gt;i_mount, valuelen);
 				retval = xfs_attr_rmtval_get(&amp;args);
<span class="p_del">-				if (retval)</span>
<span class="p_del">-					return retval;</span>
<span class="p_del">-				retval = context-&gt;put_listent(context,</span>
<span class="p_del">-						entry-&gt;flags,</span>
<span class="p_del">-						name_rmt-&gt;name,</span>
<span class="p_del">-						(int)name_rmt-&gt;namelen,</span>
<span class="p_del">-						valuelen,</span>
<span class="p_del">-						args.value);</span>
<span class="p_add">+				if (!retval)</span>
<span class="p_add">+					retval = context-&gt;put_listent(context,</span>
<span class="p_add">+							entry-&gt;flags,</span>
<span class="p_add">+							name_rmt-&gt;name,</span>
<span class="p_add">+							(int)name_rmt-&gt;namelen,</span>
<span class="p_add">+							valuelen,</span>
<span class="p_add">+							args.value);</span>
 				kmem_free(args.value);
 			} else {
 				retval = context-&gt;put_listent(context,
<span class="p_header">diff --git a/include/asm-generic/bitops/lock.h b/include/asm-generic/bitops/lock.h</span>
<span class="p_header">index c30266e94806..8ef0ccbf8167 100644</span>
<span class="p_header">--- a/include/asm-generic/bitops/lock.h</span>
<span class="p_header">+++ b/include/asm-generic/bitops/lock.h</span>
<span class="p_chunk">@@ -29,16 +29,16 @@</span> <span class="p_context"> do {					\</span>
  * @nr: the bit to set
  * @addr: the address to start counting from
  *
<span class="p_del">- * This operation is like clear_bit_unlock, however it is not atomic.</span>
<span class="p_del">- * It does provide release barrier semantics so it can be used to unlock</span>
<span class="p_del">- * a bit lock, however it would only be used if no other CPU can modify</span>
<span class="p_del">- * any bits in the memory until the lock is released (a good example is</span>
<span class="p_del">- * if the bit lock itself protects access to the other bits in the word).</span>
<span class="p_add">+ * A weaker form of clear_bit_unlock() as used by __bit_lock_unlock(). If all</span>
<span class="p_add">+ * the bits in the word are protected by this lock some archs can use weaker</span>
<span class="p_add">+ * ops to safely unlock.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See for example x86&#39;s implementation.</span>
  */
 #define __clear_bit_unlock(nr, addr)	\
 do {					\
<span class="p_del">-	smp_mb();			\</span>
<span class="p_del">-	__clear_bit(nr, addr);		\</span>
<span class="p_add">+	smp_mb__before_atomic();	\</span>
<span class="p_add">+	clear_bit(nr, addr);		\</span>
 } while (0)
 
 #endif /* _ASM_GENERIC_BITOPS_LOCK_H_ */
<span class="p_header">diff --git a/include/linux/cgroup-defs.h b/include/linux/cgroup-defs.h</span>
<span class="p_header">index 8e30faeab183..a7c7f74808a4 100644</span>
<span class="p_header">--- a/include/linux/cgroup-defs.h</span>
<span class="p_header">+++ b/include/linux/cgroup-defs.h</span>
<span class="p_chunk">@@ -216,6 +216,9 @@</span> <span class="p_context"> struct css_set {</span>
 	/* all css_task_iters currently walking this cset */
 	struct list_head task_iters;
 
<span class="p_add">+	/* dead and being drained, ignore for migration */</span>
<span class="p_add">+	bool dead;</span>
<span class="p_add">+</span>
 	/* For RCU-protected deletion */
 	struct rcu_head rcu_head;
 };
<span class="p_header">diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h</span>
<span class="p_header">index ec1c61c87d89..899ab9f8549e 100644</span>
<span class="p_header">--- a/include/linux/device-mapper.h</span>
<span class="p_header">+++ b/include/linux/device-mapper.h</span>
<span class="p_chunk">@@ -124,6 +124,8 @@</span> <span class="p_context"> struct dm_dev {</span>
 	char name[16];
 };
 
<span class="p_add">+dev_t dm_get_dev_t(const char *path);</span>
<span class="p_add">+</span>
 /*
  * Constructors should call these functions to ensure destination devices
  * are opened/closed correctly.
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 3aa514254161..22c5a0cf16e3 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -2217,7 +2217,7 @@</span> <span class="p_context"> extern long do_sys_open(int dfd, const char __user *filename, int flags,</span>
 extern struct file *file_open_name(struct filename *, int, umode_t);
 extern struct file *filp_open(const char *, int, umode_t);
 extern struct file *file_open_root(struct dentry *, struct vfsmount *,
<span class="p_del">-				   const char *, int);</span>
<span class="p_add">+				   const char *, int, umode_t);</span>
 extern struct file * dentry_open(const struct path *, int, const struct cred *);
 extern int filp_close(struct file *, fl_owner_t id);
 
<span class="p_header">diff --git a/include/linux/kernel.h b/include/linux/kernel.h</span>
<span class="p_header">index 350dfb08aee3..924853d33a13 100644</span>
<span class="p_header">--- a/include/linux/kernel.h</span>
<span class="p_header">+++ b/include/linux/kernel.h</span>
<span class="p_chunk">@@ -607,7 +607,7 @@</span> <span class="p_context"> do {							\</span>
 
 #define do_trace_printk(fmt, args...)					\
 do {									\
<span class="p_del">-	static const char *trace_printk_fmt				\</span>
<span class="p_add">+	static const char *trace_printk_fmt __used			\</span>
 		__attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\
 		__builtin_constant_p(fmt) ? fmt : NULL;			\
 									\
<span class="p_chunk">@@ -651,7 +651,7 @@</span> <span class="p_context"> int __trace_printk(unsigned long ip, const char *fmt, ...);</span>
  */
 
 #define trace_puts(str) ({						\
<span class="p_del">-	static const char *trace_printk_fmt				\</span>
<span class="p_add">+	static const char *trace_printk_fmt __used			\</span>
 		__attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\
 		__builtin_constant_p(str) ? str : NULL;			\
 									\
<span class="p_chunk">@@ -673,7 +673,7 @@</span> <span class="p_context"> extern void trace_dump_stack(int skip);</span>
 #define ftrace_vprintk(fmt, vargs)					\
 do {									\
 	if (__builtin_constant_p(fmt)) {				\
<span class="p_del">-		static const char *trace_printk_fmt			\</span>
<span class="p_add">+		static const char *trace_printk_fmt __used		\</span>
 		  __attribute__((section(&quot;__trace_printk_fmt&quot;))) =	\
 			__builtin_constant_p(fmt) ? fmt : NULL;		\
 									\
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index 6ae25aae88fd..4e554bfff129 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -359,6 +359,7 @@</span> <span class="p_context"> struct pci_dev {</span>
 	unsigned int	io_window_1k:1;	/* Intel P2P bridge 1K I/O windows */
 	unsigned int	irq_managed:1;
 	unsigned int	has_secondary_link:1;
<span class="p_add">+	unsigned int	non_compliant_bars:1;	/* broken BARs; ignore them */</span>
 	pci_dev_flags_t dev_flags;
 	atomic_t	enable_cnt;	/* pci_enable_device has been called */
 
<span class="p_header">diff --git a/include/linux/platform_data/asoc-s3c.h b/include/linux/platform_data/asoc-s3c.h</span>
<span class="p_header">index 5e0bc779e6c5..33f88b4479e4 100644</span>
<span class="p_header">--- a/include/linux/platform_data/asoc-s3c.h</span>
<span class="p_header">+++ b/include/linux/platform_data/asoc-s3c.h</span>
<span class="p_chunk">@@ -39,6 +39,10 @@</span> <span class="p_context"> struct samsung_i2s {</span>
  */
 struct s3c_audio_pdata {
 	int (*cfg_gpio)(struct platform_device *);
<span class="p_add">+	void *dma_playback;</span>
<span class="p_add">+	void *dma_capture;</span>
<span class="p_add">+	void *dma_play_sec;</span>
<span class="p_add">+	void *dma_capture_mic;</span>
 	union {
 		struct samsung_i2s i2s;
 	} type;
<span class="p_header">diff --git a/include/linux/thermal.h b/include/linux/thermal.h</span>
<span class="p_header">index e13a1ace50e9..4a849f19e6c9 100644</span>
<span class="p_header">--- a/include/linux/thermal.h</span>
<span class="p_header">+++ b/include/linux/thermal.h</span>
<span class="p_chunk">@@ -156,6 +156,7 @@</span> <span class="p_context"> struct thermal_attr {</span>
  * @trip_hyst_attrs:	attributes for trip points for sysfs: trip hysteresis
  * @devdata:	private pointer for device private data
  * @trips:	number of trip points the thermal zone supports
<span class="p_add">+ * @trips_disabled;	bitmap for disabled trips</span>
  * @passive_delay:	number of milliseconds to wait between polls when
  *			performing passive cooling.
  * @polling_delay:	number of milliseconds to wait between polls when
<span class="p_chunk">@@ -191,6 +192,7 @@</span> <span class="p_context"> struct thermal_zone_device {</span>
 	struct thermal_attr *trip_hyst_attrs;
 	void *devdata;
 	int trips;
<span class="p_add">+	unsigned long trips_disabled;	/* bitmap for disabled trips */</span>
 	int passive_delay;
 	int polling_delay;
 	int temperature;
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 6b6e811f4575..3bf03b6b52e9 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -594,7 +594,7 @@</span> <span class="p_context"> static inline int tty_ldisc_receive_buf(struct tty_ldisc *ld, unsigned char *p,</span>
 		count = ld-&gt;ops-&gt;receive_buf2(ld-&gt;tty, p, f, count);
 	else {
 		count = min_t(int, count, ld-&gt;tty-&gt;receive_room);
<span class="p_del">-		if (count)</span>
<span class="p_add">+		if (count &amp;&amp; ld-&gt;ops-&gt;receive_buf)</span>
 			ld-&gt;ops-&gt;receive_buf(ld-&gt;tty, p, f, count);
 	}
 	return count;
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index fb1ecfd2decd..dc94f8beb097 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -2498,6 +2498,14 @@</span> <span class="p_context"> static void cgroup_migrate_add_src(struct css_set *src_cset,</span>
 	lockdep_assert_held(&amp;cgroup_mutex);
 	lockdep_assert_held(&amp;css_set_lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If -&gt;dead, @src_set is associated with one or more dead cgroups</span>
<span class="p_add">+	 * and doesn&#39;t contain any migratable tasks.  Ignore it early so</span>
<span class="p_add">+	 * that the rest of migration path doesn&#39;t get confused by it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (src_cset-&gt;dead)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	src_cgrp = cset_cgroup_from_root(src_cset, dst_cgrp-&gt;root);
 
 	if (!list_empty(&amp;src_cset-&gt;mg_preload_node))
<span class="p_chunk">@@ -5131,6 +5139,7 @@</span> <span class="p_context"> static int cgroup_destroy_locked(struct cgroup *cgrp)</span>
 	__releases(&amp;cgroup_mutex) __acquires(&amp;cgroup_mutex)
 {
 	struct cgroup_subsys_state *css;
<span class="p_add">+	struct cgrp_cset_link *link;</span>
 	int ssid;
 
 	lockdep_assert_held(&amp;cgroup_mutex);
<span class="p_chunk">@@ -5151,11 +5160,18 @@</span> <span class="p_context"> static int cgroup_destroy_locked(struct cgroup *cgrp)</span>
 		return -EBUSY;
 
 	/*
<span class="p_del">-	 * Mark @cgrp dead.  This prevents further task migration and child</span>
<span class="p_del">-	 * creation by disabling cgroup_lock_live_group().</span>
<span class="p_add">+	 * Mark @cgrp and the associated csets dead.  The former prevents</span>
<span class="p_add">+	 * further task migration and child creation by disabling</span>
<span class="p_add">+	 * cgroup_lock_live_group().  The latter makes the csets ignored by</span>
<span class="p_add">+	 * the migration path.</span>
 	 */
 	cgrp-&gt;self.flags &amp;= ~CSS_ONLINE;
 
<span class="p_add">+	spin_lock_bh(&amp;css_set_lock);</span>
<span class="p_add">+	list_for_each_entry(link, &amp;cgrp-&gt;cset_links, cset_link)</span>
<span class="p_add">+		link-&gt;cset-&gt;dead = true;</span>
<span class="p_add">+	spin_unlock_bh(&amp;css_set_lock);</span>
<span class="p_add">+</span>
 	/* initiate massacre of all css&#39;s */
 	for_each_css(css, ssid, cgrp)
 		kill_css(css);
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 1087bbeb152b..faf2067fc8e2 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -7979,6 +7979,9 @@</span> <span class="p_context"> perf_event_alloc(struct perf_event_attr *attr, int cpu,</span>
 		}
 	}
 
<span class="p_add">+	/* symmetric to unaccount_event() in _free_event() */</span>
<span class="p_add">+	account_event(event);</span>
<span class="p_add">+</span>
 	return event;
 
 err_per_task:
<span class="p_chunk">@@ -8342,8 +8345,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 		}
 	}
 
<span class="p_del">-	account_event(event);</span>
<span class="p_del">-</span>
 	/*
 	 * Special case software events and allow them to be part of
 	 * any hardware group.
<span class="p_chunk">@@ -8626,8 +8627,6 @@</span> <span class="p_context"> perf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,</span>
 	/* Mark owner so we could distinguish it from user events. */
 	event-&gt;owner = EVENT_OWNER_KERNEL;
 
<span class="p_del">-	account_event(event);</span>
<span class="p_del">-</span>
 	ctx = find_get_context(event-&gt;pmu, task, event);
 	if (IS_ERR(ctx)) {
 		err = PTR_ERR(ctx);
<span class="p_header">diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c</span>
<span class="p_header">index b7342a24f559..b7dd5718836e 100644</span>
<span class="p_header">--- a/kernel/power/hibernate.c</span>
<span class="p_header">+++ b/kernel/power/hibernate.c</span>
<span class="p_chunk">@@ -339,6 +339,7 @@</span> <span class="p_context"> int hibernation_snapshot(int platform_mode)</span>
 	pm_message_t msg;
 	int error;
 
<span class="p_add">+	pm_suspend_clear_flags();</span>
 	error = platform_begin(platform_mode);
 	if (error)
 		goto Close;
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index eb70592f03f6..70e5e09341f1 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5525,6 +5525,7 @@</span> <span class="p_context"> migration_call(struct notifier_block *nfb, unsigned long action, void *hcpu)</span>
 
 	case CPU_UP_PREPARE:
 		rq-&gt;calc_load_update = calc_load_update;
<span class="p_add">+		account_reset_rq(rq);</span>
 		break;
 
 	case CPU_ONLINE:
<span class="p_header">diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c</span>
<span class="p_header">index 05de80b48586..f74ea89e77a8 100644</span>
<span class="p_header">--- a/kernel/sched/cputime.c</span>
<span class="p_header">+++ b/kernel/sched/cputime.c</span>
<span class="p_chunk">@@ -259,21 +259,21 @@</span> <span class="p_context"> static __always_inline bool steal_account_process_tick(void)</span>
 #ifdef CONFIG_PARAVIRT
 	if (static_key_false(&amp;paravirt_steal_enabled)) {
 		u64 steal;
<span class="p_del">-		cputime_t steal_ct;</span>
<span class="p_add">+		unsigned long steal_jiffies;</span>
 
 		steal = paravirt_steal_clock(smp_processor_id());
 		steal -= this_rq()-&gt;prev_steal_time;
 
 		/*
<span class="p_del">-		 * cputime_t may be less precise than nsecs (eg: if it&#39;s</span>
<span class="p_del">-		 * based on jiffies). Lets cast the result to cputime</span>
<span class="p_add">+		 * steal is in nsecs but our caller is expecting steal</span>
<span class="p_add">+		 * time in jiffies. Lets cast the result to jiffies</span>
 		 * granularity and account the rest on the next rounds.
 		 */
<span class="p_del">-		steal_ct = nsecs_to_cputime(steal);</span>
<span class="p_del">-		this_rq()-&gt;prev_steal_time += cputime_to_nsecs(steal_ct);</span>
<span class="p_add">+		steal_jiffies = nsecs_to_jiffies(steal);</span>
<span class="p_add">+		this_rq()-&gt;prev_steal_time += jiffies_to_nsecs(steal_jiffies);</span>
 
<span class="p_del">-		account_steal_time(steal_ct);</span>
<span class="p_del">-		return steal_ct;</span>
<span class="p_add">+		account_steal_time(jiffies_to_cputime(steal_jiffies));</span>
<span class="p_add">+		return steal_jiffies;</span>
 	}
 #endif
 	return false;
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index b242775bf670..0517abd7dd73 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -1770,3 +1770,16 @@</span> <span class="p_context"> static inline u64 irq_time_read(int cpu)</span>
 }
 #endif /* CONFIG_64BIT */
 #endif /* CONFIG_IRQ_TIME_ACCOUNTING */
<span class="p_add">+</span>
<span class="p_add">+static inline void account_reset_rq(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_IRQ_TIME_ACCOUNTING</span>
<span class="p_add">+	rq-&gt;prev_irq_time = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+	rq-&gt;prev_steal_time = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_TIME_ACCOUNTING</span>
<span class="p_add">+	rq-&gt;prev_steal_time_rq = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/kernel/sysctl_binary.c b/kernel/sysctl_binary.c</span>
<span class="p_header">index 7e7746a42a62..10a1d7dc9313 100644</span>
<span class="p_header">--- a/kernel/sysctl_binary.c</span>
<span class="p_header">+++ b/kernel/sysctl_binary.c</span>
<span class="p_chunk">@@ -1321,7 +1321,7 @@</span> <span class="p_context"> static ssize_t binary_sysctl(const int *name, int nlen,</span>
 	}
 
 	mnt = task_active_pid_ns(current)-&gt;proc_mnt;
<span class="p_del">-	file = file_open_root(mnt-&gt;mnt_root, mnt, pathname, flags);</span>
<span class="p_add">+	file = file_open_root(mnt-&gt;mnt_root, mnt, pathname, flags, 0);</span>
 	result = PTR_ERR(file);
 	if (IS_ERR(file))
 		goto out_putname;
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index d9293402ee68..8305cbb2d5a2 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -4949,7 +4949,10 @@</span> <span class="p_context"> static ssize_t tracing_splice_read_pipe(struct file *filp,</span>
 
 	spd.nr_pages = i;
 
<span class="p_del">-	ret = splice_to_pipe(pipe, &amp;spd);</span>
<span class="p_add">+	if (i)</span>
<span class="p_add">+		ret = splice_to_pipe(pipe, &amp;spd);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = 0;</span>
 out:
 	splice_shrink_spd(&amp;spd);
 	return ret;
<span class="p_header">diff --git a/kernel/trace/trace_irqsoff.c b/kernel/trace/trace_irqsoff.c</span>
<span class="p_header">index e4e56589ec1d..be3222b7d72e 100644</span>
<span class="p_header">--- a/kernel/trace/trace_irqsoff.c</span>
<span class="p_header">+++ b/kernel/trace/trace_irqsoff.c</span>
<span class="p_chunk">@@ -109,8 +109,12 @@</span> <span class="p_context"> static int func_prolog_dec(struct trace_array *tr,</span>
 		return 0;
 
 	local_save_flags(*flags);
<span class="p_del">-	/* slight chance to get a false positive on tracing_cpu */</span>
<span class="p_del">-	if (!irqs_disabled_flags(*flags))</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Slight chance to get a false positive on tracing_cpu,</span>
<span class="p_add">+	 * although I&#39;m starting to think there isn&#39;t a chance.</span>
<span class="p_add">+	 * Leave this for now just to be paranoid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!irqs_disabled_flags(*flags) &amp;&amp; !preempt_count())</span>
 		return 0;
 
 	*data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);
<span class="p_header">diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c</span>
<span class="p_header">index 060df67dbdd1..f96f0383f6c6 100644</span>
<span class="p_header">--- a/kernel/trace/trace_printk.c</span>
<span class="p_header">+++ b/kernel/trace/trace_printk.c</span>
<span class="p_chunk">@@ -296,6 +296,9 @@</span> <span class="p_context"> static int t_show(struct seq_file *m, void *v)</span>
 	const char *str = *fmt;
 	int i;
 
<span class="p_add">+	if (!*fmt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	seq_printf(m, &quot;0x%lx : \&quot;&quot;, *(unsigned long *)fmt);
 
 	/*
<span class="p_header">diff --git a/kernel/watchdog.c b/kernel/watchdog.c</span>
<span class="p_header">index 18f34cf75f74..198137b1cadc 100644</span>
<span class="p_header">--- a/kernel/watchdog.c</span>
<span class="p_header">+++ b/kernel/watchdog.c</span>
<span class="p_chunk">@@ -907,6 +907,9 @@</span> <span class="p_context"> static int proc_watchdog_common(int which, struct ctl_table *table, int write,</span>
 		 * both lockup detectors are disabled if proc_watchdog_update()
 		 * returns an error.
 		 */
<span class="p_add">+		if (old == new)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		err = proc_watchdog_update();
 	}
 out:
<span class="p_chunk">@@ -951,7 +954,7 @@</span> <span class="p_context"> int proc_soft_watchdog(struct ctl_table *table, int write,</span>
 int proc_watchdog_thresh(struct ctl_table *table, int write,
 			 void __user *buffer, size_t *lenp, loff_t *ppos)
 {
<span class="p_del">-	int err, old;</span>
<span class="p_add">+	int err, old, new;</span>
 
 	get_online_cpus();
 	mutex_lock(&amp;watchdog_proc_mutex);
<span class="p_chunk">@@ -971,6 +974,10 @@</span> <span class="p_context"> int proc_watchdog_thresh(struct ctl_table *table, int write,</span>
 	/*
 	 * Update the sample period. Restore on failure.
 	 */
<span class="p_add">+	new = ACCESS_ONCE(watchdog_thresh);</span>
<span class="p_add">+	if (old == new)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	set_sample_period();
 	err = proc_watchdog_update();
 	if (err) {
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index ee6acd279953..fc0bcc41d57f 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -1332,7 +1332,7 @@</span> <span class="p_context"> static unsigned long mem_cgroup_get_limit(struct mem_cgroup *memcg)</span>
 	return limit;
 }
 
<span class="p_del">-static void mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,</span>
<span class="p_add">+static bool mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,</span>
 				     int order)
 {
 	struct oom_control oc = {
<span class="p_chunk">@@ -1410,6 +1410,7 @@</span> <span class="p_context"> static void mem_cgroup_out_of_memory(struct mem_cgroup *memcg, gfp_t gfp_mask,</span>
 	}
 unlock:
 	mutex_unlock(&amp;oom_lock);
<span class="p_add">+	return chosen;</span>
 }
 
 #if MAX_NUMNODES &gt; 1
<span class="p_chunk">@@ -5121,6 +5122,7 @@</span> <span class="p_context"> static ssize_t memory_high_write(struct kernfs_open_file *of,</span>
 				 char *buf, size_t nbytes, loff_t off)
 {
 	struct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));
<span class="p_add">+	unsigned long nr_pages;</span>
 	unsigned long high;
 	int err;
 
<span class="p_chunk">@@ -5131,6 +5133,11 @@</span> <span class="p_context"> static ssize_t memory_high_write(struct kernfs_open_file *of,</span>
 
 	memcg-&gt;high = high;
 
<span class="p_add">+	nr_pages = page_counter_read(&amp;memcg-&gt;memory);</span>
<span class="p_add">+	if (nr_pages &gt; high)</span>
<span class="p_add">+		try_to_free_mem_cgroup_pages(memcg, nr_pages - high,</span>
<span class="p_add">+					     GFP_KERNEL, true);</span>
<span class="p_add">+</span>
 	memcg_wb_domain_size_changed(memcg);
 	return nbytes;
 }
<span class="p_chunk">@@ -5152,6 +5159,8 @@</span> <span class="p_context"> static ssize_t memory_max_write(struct kernfs_open_file *of,</span>
 				char *buf, size_t nbytes, loff_t off)
 {
 	struct mem_cgroup *memcg = mem_cgroup_from_css(of_css(of));
<span class="p_add">+	unsigned int nr_reclaims = MEM_CGROUP_RECLAIM_RETRIES;</span>
<span class="p_add">+	bool drained = false;</span>
 	unsigned long max;
 	int err;
 
<span class="p_chunk">@@ -5160,9 +5169,36 @@</span> <span class="p_context"> static ssize_t memory_max_write(struct kernfs_open_file *of,</span>
 	if (err)
 		return err;
 
<span class="p_del">-	err = mem_cgroup_resize_limit(memcg, max);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+	xchg(&amp;memcg-&gt;memory.limit, max);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		unsigned long nr_pages = page_counter_read(&amp;memcg-&gt;memory);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (nr_pages &lt;= max)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (signal_pending(current)) {</span>
<span class="p_add">+			err = -EINTR;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!drained) {</span>
<span class="p_add">+			drain_all_stock(memcg);</span>
<span class="p_add">+			drained = true;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (nr_reclaims) {</span>
<span class="p_add">+			if (!try_to_free_mem_cgroup_pages(memcg, nr_pages - max,</span>
<span class="p_add">+							  GFP_KERNEL, true))</span>
<span class="p_add">+				nr_reclaims--;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mem_cgroup_events(memcg, MEMCG_OOM, 1);</span>
<span class="p_add">+		if (!mem_cgroup_out_of_memory(memcg, GFP_KERNEL, 0))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
 
 	memcg_wb_domain_size_changed(memcg);
 	return nbytes;
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 9d666df5ef95..c69531afbd8f 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -662,34 +662,28 @@</span> <span class="p_context"> static inline void __free_one_page(struct page *page,</span>
 	unsigned long combined_idx;
 	unsigned long uninitialized_var(buddy_idx);
 	struct page *buddy;
<span class="p_del">-	unsigned int max_order = MAX_ORDER;</span>
<span class="p_add">+	unsigned int max_order;</span>
<span class="p_add">+</span>
<span class="p_add">+	max_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);</span>
 
 	VM_BUG_ON(!zone_is_initialized(zone));
 	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);
 
 	VM_BUG_ON(migratetype == -1);
<span class="p_del">-	if (is_migrate_isolate(migratetype)) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We restrict max order of merging to prevent merge</span>
<span class="p_del">-		 * between freepages on isolate pageblock and normal</span>
<span class="p_del">-		 * pageblock. Without this, pageblock isolation</span>
<span class="p_del">-		 * could cause incorrect freepage accounting.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		max_order = min_t(unsigned int, MAX_ORDER, pageblock_order + 1);</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (likely(!is_migrate_isolate(migratetype)))</span>
 		__mod_zone_freepage_state(zone, 1 &lt;&lt; order, migratetype);
<span class="p_del">-	}</span>
 
<span class="p_del">-	page_idx = pfn &amp; ((1 &lt;&lt; max_order) - 1);</span>
<span class="p_add">+	page_idx = pfn &amp; ((1 &lt;&lt; MAX_ORDER) - 1);</span>
 
 	VM_BUG_ON_PAGE(page_idx &amp; ((1 &lt;&lt; order) - 1), page);
 	VM_BUG_ON_PAGE(bad_range(zone, page), page);
 
<span class="p_add">+continue_merging:</span>
 	while (order &lt; max_order - 1) {
 		buddy_idx = __find_buddy_index(page_idx, order);
 		buddy = page + (buddy_idx - page_idx);
 		if (!page_is_buddy(page, buddy, order))
<span class="p_del">-			break;</span>
<span class="p_add">+			goto done_merging;</span>
 		/*
 		 * Our buddy is free or it is CONFIG_DEBUG_PAGEALLOC guard page,
 		 * merge with it and move up one order.
<span class="p_chunk">@@ -706,6 +700,32 @@</span> <span class="p_context"> static inline void __free_one_page(struct page *page,</span>
 		page_idx = combined_idx;
 		order++;
 	}
<span class="p_add">+	if (max_order &lt; MAX_ORDER) {</span>
<span class="p_add">+		/* If we are here, it means order is &gt;= pageblock_order.</span>
<span class="p_add">+		 * We want to prevent merge between freepages on isolate</span>
<span class="p_add">+		 * pageblock and normal pageblock. Without this, pageblock</span>
<span class="p_add">+		 * isolation could cause incorrect freepage or CMA accounting.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We don&#39;t want to hit this code for the more frequent</span>
<span class="p_add">+		 * low-order merging.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (unlikely(has_isolate_pageblock(zone))) {</span>
<span class="p_add">+			int buddy_mt;</span>
<span class="p_add">+</span>
<span class="p_add">+			buddy_idx = __find_buddy_index(page_idx, order);</span>
<span class="p_add">+			buddy = page + (buddy_idx - page_idx);</span>
<span class="p_add">+			buddy_mt = get_pageblock_migratetype(buddy);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (migratetype != buddy_mt</span>
<span class="p_add">+					&amp;&amp; (is_migrate_isolate(migratetype) ||</span>
<span class="p_add">+						is_migrate_isolate(buddy_mt)))</span>
<span class="p_add">+				goto done_merging;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		max_order++;</span>
<span class="p_add">+		goto continue_merging;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+done_merging:</span>
 	set_page_order(page, order);
 
 	/*
<span class="p_header">diff --git a/net/bluetooth/mgmt.c b/net/bluetooth/mgmt.c</span>
<span class="p_header">index 7f22119276f3..b1b0a1c0bd8d 100644</span>
<span class="p_header">--- a/net/bluetooth/mgmt.c</span>
<span class="p_header">+++ b/net/bluetooth/mgmt.c</span>
<span class="p_chunk">@@ -7155,6 +7155,10 @@</span> <span class="p_context"> static int add_advertising(struct sock *sk, struct hci_dev *hdev,</span>
 		return mgmt_cmd_status(sk, hdev-&gt;id, MGMT_OP_ADD_ADVERTISING,
 				       status);
 
<span class="p_add">+	if (data_len != sizeof(*cp) + cp-&gt;adv_data_len + cp-&gt;scan_rsp_len)</span>
<span class="p_add">+		return mgmt_cmd_status(sk, hdev-&gt;id, MGMT_OP_ADD_ADVERTISING,</span>
<span class="p_add">+				       MGMT_STATUS_INVALID_PARAMS);</span>
<span class="p_add">+</span>
 	flags = __le32_to_cpu(cp-&gt;flags);
 	timeout = __le16_to_cpu(cp-&gt;timeout);
 	duration = __le16_to_cpu(cp-&gt;duration);
<span class="p_header">diff --git a/scripts/coccinelle/iterators/use_after_iter.cocci b/scripts/coccinelle/iterators/use_after_iter.cocci</span>
<span class="p_header">index f085f5968c52..ce8cc9c006e5 100644</span>
<span class="p_header">--- a/scripts/coccinelle/iterators/use_after_iter.cocci</span>
<span class="p_header">+++ b/scripts/coccinelle/iterators/use_after_iter.cocci</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> list_remove_head(x,c,...)</span>
 |
 sizeof(&lt;+...c...+&gt;)
 |
<span class="p_del">-&amp;c-&gt;member</span>
<span class="p_add">+ &amp;c-&gt;member</span>
 |
 c = E
 |
<span class="p_header">diff --git a/scripts/kconfig/Makefile b/scripts/kconfig/Makefile</span>
<span class="p_header">index d79cba4ce3eb..ebced77deb9c 100644</span>
<span class="p_header">--- a/scripts/kconfig/Makefile</span>
<span class="p_header">+++ b/scripts/kconfig/Makefile</span>
<span class="p_chunk">@@ -96,13 +96,15 @@</span> <span class="p_context"> savedefconfig: $(obj)/conf</span>
 defconfig: $(obj)/conf
 ifeq ($(KBUILD_DEFCONFIG),)
 	$&lt; $(silent) --defconfig $(Kconfig)
<span class="p_del">-else ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/configs/$(KBUILD_DEFCONFIG)),)</span>
<span class="p_add">+else</span>
<span class="p_add">+ifneq ($(wildcard $(srctree)/arch/$(SRCARCH)/configs/$(KBUILD_DEFCONFIG)),)</span>
 	@$(kecho) &quot;*** Default configuration is based on &#39;$(KBUILD_DEFCONFIG)&#39;&quot;
 	$(Q)$&lt; $(silent) --defconfig=arch/$(SRCARCH)/configs/$(KBUILD_DEFCONFIG) $(Kconfig)
 else
 	@$(kecho) &quot;*** Default configuration is based on target &#39;$(KBUILD_DEFCONFIG)&#39;&quot;
 	$(Q)$(MAKE) -f $(srctree)/Makefile $(KBUILD_DEFCONFIG)
 endif
<span class="p_add">+endif</span>
 
 %_defconfig: $(obj)/conf
 	$(Q)$&lt; $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
<span class="p_header">diff --git a/scripts/package/mkspec b/scripts/package/mkspec</span>
<span class="p_header">index 71004daefe31..fe44d68e9344 100755</span>
<span class="p_header">--- a/scripts/package/mkspec</span>
<span class="p_header">+++ b/scripts/package/mkspec</span>
<span class="p_chunk">@@ -131,11 +131,11 @@</span> <span class="p_context"> echo &#39;rm -rf $RPM_BUILD_ROOT&#39;</span>
 echo &quot;&quot;
 echo &quot;%post&quot;
 echo &quot;if [ -x /sbin/installkernel -a -r /boot/vmlinuz-$KERNELRELEASE -a -r /boot/System.map-$KERNELRELEASE ]; then&quot;
<span class="p_del">-echo &quot;cp /boot/vmlinuz-$KERNELRELEASE /boot/vmlinuz-$KERNELRELEASE-rpm&quot;</span>
<span class="p_del">-echo &quot;cp /boot/System.map-$KERNELRELEASE /boot/System.map-$KERNELRELEASE-rpm&quot;</span>
<span class="p_add">+echo &quot;cp /boot/vmlinuz-$KERNELRELEASE /boot/.vmlinuz-$KERNELRELEASE-rpm&quot;</span>
<span class="p_add">+echo &quot;cp /boot/System.map-$KERNELRELEASE /boot/.System.map-$KERNELRELEASE-rpm&quot;</span>
 echo &quot;rm -f /boot/vmlinuz-$KERNELRELEASE /boot/System.map-$KERNELRELEASE&quot;
<span class="p_del">-echo &quot;/sbin/installkernel $KERNELRELEASE /boot/vmlinuz-$KERNELRELEASE-rpm /boot/System.map-$KERNELRELEASE-rpm&quot;</span>
<span class="p_del">-echo &quot;rm -f /boot/vmlinuz-$KERNELRELEASE-rpm /boot/System.map-$KERNELRELEASE-rpm&quot;</span>
<span class="p_add">+echo &quot;/sbin/installkernel $KERNELRELEASE /boot/.vmlinuz-$KERNELRELEASE-rpm /boot/.System.map-$KERNELRELEASE-rpm&quot;</span>
<span class="p_add">+echo &quot;rm -f /boot/.vmlinuz-$KERNELRELEASE-rpm /boot/.System.map-$KERNELRELEASE-rpm&quot;</span>
 echo &quot;fi&quot;
 echo &quot;&quot;
 echo &quot;%files&quot;
<span class="p_header">diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c</span>
<span class="p_header">index 6b5a811e01a5..3a9b66c6e09c 100644</span>
<span class="p_header">--- a/sound/core/pcm_lib.c</span>
<span class="p_header">+++ b/sound/core/pcm_lib.c</span>
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"> static int snd_pcm_update_hw_ptr0(struct snd_pcm_substream *substream,</span>
 			char name[16];
 			snd_pcm_debug_name(substream, name, sizeof(name));
 			pcm_err(substream-&gt;pcm,
<span class="p_del">-				&quot;BUG: %s, pos = %ld, buffer size = %ld, period size = %ld\n&quot;,</span>
<span class="p_add">+				&quot;invalid position: %s, pos = %ld, buffer size = %ld, period size = %ld\n&quot;,</span>
 				name, pos, runtime-&gt;buffer_size,
 				runtime-&gt;period_size);
 		}
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index c1c855a6c0af..a47e8ae0eb30 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -174,8 +174,12 @@</span> <span class="p_context"> static void cs_automute(struct hda_codec *codec)</span>
 	snd_hda_gen_update_outputs(codec);
 
 	if (spec-&gt;gpio_eapd_hp || spec-&gt;gpio_eapd_speaker) {
<span class="p_del">-		spec-&gt;gpio_data = spec-&gt;gen.hp_jack_present ?</span>
<span class="p_del">-			spec-&gt;gpio_eapd_hp : spec-&gt;gpio_eapd_speaker;</span>
<span class="p_add">+		if (spec-&gt;gen.automute_speaker)</span>
<span class="p_add">+			spec-&gt;gpio_data = spec-&gt;gen.hp_jack_present ?</span>
<span class="p_add">+				spec-&gt;gpio_eapd_hp : spec-&gt;gpio_eapd_speaker;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			spec-&gt;gpio_data =</span>
<span class="p_add">+				spec-&gt;gpio_eapd_hp | spec-&gt;gpio_eapd_speaker;</span>
 		snd_hda_codec_write(codec, 0x01, 0,
 				    AC_VERB_SET_GPIO_DATA, spec-&gt;gpio_data);
 	}
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index ef198903c0c3..600af5878e75 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -204,8 +204,13 @@</span> <span class="p_context"> static void cx_auto_reboot_notify(struct hda_codec *codec)</span>
 {
 	struct conexant_spec *spec = codec-&gt;spec;
 
<span class="p_del">-	if (codec-&gt;core.vendor_id != 0x14f150f2)</span>
<span class="p_add">+	switch (codec-&gt;core.vendor_id) {</span>
<span class="p_add">+	case 0x14f150f2: /* CX20722 */</span>
<span class="p_add">+	case 0x14f150f4: /* CX20724 */</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* Turn the CX20722 codec into D3 to avoid spurious noises
 	   from the internal speaker during (and after) reboot */
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 70c945603379..f7bcd8dbac14 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -2353,6 +2353,10 @@</span> <span class="p_context"> static void intel_pin_eld_notify(void *audio_ptr, int port)</span>
 	struct hda_codec *codec = audio_ptr;
 	int pin_nid = port + 0x04;
 
<span class="p_add">+	/* we assume only from port-B to port-D */</span>
<span class="p_add">+	if (port &lt; 1 || port &gt; 3)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* skip notification during system suspend (but not in runtime PM);
 	 * the state will be updated at resume
 	 */
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index c2430b36e1ce..6968b796baa3 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5529,6 +5529,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC293_FIXUP_LENOVO_SPK_NOISE),
 	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x30e2, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3902, &quot;Lenovo E50-80&quot;, ALC269_FIXUP_DMIC_THINKPAD_ACPI),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
<span class="p_header">diff --git a/sound/pci/intel8x0.c b/sound/pci/intel8x0.c</span>
<span class="p_header">index 42bcbac801a3..ccdab29a8b66 100644</span>
<span class="p_header">--- a/sound/pci/intel8x0.c</span>
<span class="p_header">+++ b/sound/pci/intel8x0.c</span>
<span class="p_chunk">@@ -2879,6 +2879,7 @@</span> <span class="p_context"> static void intel8x0_measure_ac97_clock(struct intel8x0 *chip)</span>
 
 static struct snd_pci_quirk intel8x0_clock_list[] = {
 	SND_PCI_QUIRK(0x0e11, 0x008a, &quot;AD1885&quot;, 41000),
<span class="p_add">+	SND_PCI_QUIRK(0x1014, 0x0581, &quot;AD1981B&quot;, 48000),</span>
 	SND_PCI_QUIRK(0x1028, 0x00be, &quot;AD1885&quot;, 44100),
 	SND_PCI_QUIRK(0x1028, 0x0177, &quot;AD1980&quot;, 48000),
 	SND_PCI_QUIRK(0x1028, 0x01ad, &quot;AD1981B&quot;, 48000),
<span class="p_header">diff --git a/sound/soc/samsung/ac97.c b/sound/soc/samsung/ac97.c</span>
<span class="p_header">index e4145509d63c..9c5219392460 100644</span>
<span class="p_header">--- a/sound/soc/samsung/ac97.c</span>
<span class="p_header">+++ b/sound/soc/samsung/ac97.c</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> static const struct snd_soc_component_driver s3c_ac97_component = {</span>
 
 static int s3c_ac97_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *mem_res, *dmatx_res, *dmarx_res, *dmamic_res, *irq_res;</span>
<span class="p_add">+	struct resource *mem_res, *irq_res;</span>
 	struct s3c_audio_pdata *ac97_pdata;
 	int ret;
 
<span class="p_chunk">@@ -335,24 +335,6 @@</span> <span class="p_context"> static int s3c_ac97_probe(struct platform_device *pdev)</span>
 	}
 
 	/* Check for availability of necessary resource */
<span class="p_del">-	dmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);</span>
<span class="p_del">-	if (!dmatx_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get AC97-TX dma resource\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);</span>
<span class="p_del">-	if (!dmarx_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get AC97-RX dma resource\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dmamic_res = platform_get_resource(pdev, IORESOURCE_DMA, 2);</span>
<span class="p_del">-	if (!dmamic_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get AC97-MIC dma resource\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq_res) {
 		dev_err(&amp;pdev-&gt;dev, &quot;AC97 IRQ not provided!\n&quot;);
<span class="p_chunk">@@ -364,11 +346,11 @@</span> <span class="p_context"> static int s3c_ac97_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(s3c_ac97.regs))
 		return PTR_ERR(s3c_ac97.regs);
 
<span class="p_del">-	s3c_ac97_pcm_out.channel = dmatx_res-&gt;start;</span>
<span class="p_add">+	s3c_ac97_pcm_out.slave = ac97_pdata-&gt;dma_playback;</span>
 	s3c_ac97_pcm_out.dma_addr = mem_res-&gt;start + S3C_AC97_PCM_DATA;
<span class="p_del">-	s3c_ac97_pcm_in.channel = dmarx_res-&gt;start;</span>
<span class="p_add">+	s3c_ac97_pcm_in.slave = ac97_pdata-&gt;dma_capture;</span>
 	s3c_ac97_pcm_in.dma_addr = mem_res-&gt;start + S3C_AC97_PCM_DATA;
<span class="p_del">-	s3c_ac97_mic_in.channel = dmamic_res-&gt;start;</span>
<span class="p_add">+	s3c_ac97_mic_in.slave = ac97_pdata-&gt;dma_capture_mic;</span>
 	s3c_ac97_mic_in.dma_addr = mem_res-&gt;start + S3C_AC97_MIC_DATA;
 
 	init_completion(&amp;s3c_ac97.done);
<span class="p_header">diff --git a/sound/soc/samsung/dma.h b/sound/soc/samsung/dma.h</span>
<span class="p_header">index 0e85dcfec023..085ef30f5ca2 100644</span>
<span class="p_header">--- a/sound/soc/samsung/dma.h</span>
<span class="p_header">+++ b/sound/soc/samsung/dma.h</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;sound/dmaengine_pcm.h&gt;
 
 struct s3c_dma_params {
<span class="p_del">-	int channel;				/* Channel ID */</span>
<span class="p_add">+	void *slave;				/* Channel ID */</span>
 	dma_addr_t dma_addr;
 	int dma_size;			/* Size of the DMA transfer */
 	char *ch_name;
<span class="p_header">diff --git a/sound/soc/samsung/dmaengine.c b/sound/soc/samsung/dmaengine.c</span>
<span class="p_header">index 506f5bf6d082..727008d57d14 100644</span>
<span class="p_header">--- a/sound/soc/samsung/dmaengine.c</span>
<span class="p_header">+++ b/sound/soc/samsung/dmaengine.c</span>
<span class="p_chunk">@@ -50,14 +50,14 @@</span> <span class="p_context"> void samsung_asoc_init_dma_data(struct snd_soc_dai *dai,</span>
 
 	if (playback) {
 		playback_data = &amp;playback-&gt;dma_data;
<span class="p_del">-		playback_data-&gt;filter_data = (void *)playback-&gt;channel;</span>
<span class="p_add">+		playback_data-&gt;filter_data = playback-&gt;slave;</span>
 		playback_data-&gt;chan_name = playback-&gt;ch_name;
 		playback_data-&gt;addr = playback-&gt;dma_addr;
 		playback_data-&gt;addr_width = playback-&gt;dma_size;
 	}
 	if (capture) {
 		capture_data = &amp;capture-&gt;dma_data;
<span class="p_del">-		capture_data-&gt;filter_data = (void *)capture-&gt;channel;</span>
<span class="p_add">+		capture_data-&gt;filter_data = capture-&gt;slave;</span>
 		capture_data-&gt;chan_name = capture-&gt;ch_name;
 		capture_data-&gt;addr = capture-&gt;dma_addr;
 		capture_data-&gt;addr_width = capture-&gt;dma_size;
<span class="p_header">diff --git a/sound/soc/samsung/i2s.c b/sound/soc/samsung/i2s.c</span>
<span class="p_header">index 7dbf899b2af2..e163b0148c4b 100644</span>
<span class="p_header">--- a/sound/soc/samsung/i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/i2s.c</span>
<span class="p_chunk">@@ -1260,27 +1260,14 @@</span> <span class="p_context"> static int samsung_i2s_probe(struct platform_device *pdev)</span>
 	pri_dai-&gt;lock = &amp;pri_dai-&gt;spinlock;
 
 	if (!np) {
<span class="p_del">-		res = platform_get_resource(pdev, IORESOURCE_DMA, 0);</span>
<span class="p_del">-		if (!res) {</span>
<span class="p_del">-			dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_del">-				&quot;Unable to get I2S-TX dma resource\n&quot;);</span>
<span class="p_del">-			return -ENXIO;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pri_dai-&gt;dma_playback.channel = res-&gt;start;</span>
<span class="p_del">-</span>
<span class="p_del">-		res = platform_get_resource(pdev, IORESOURCE_DMA, 1);</span>
<span class="p_del">-		if (!res) {</span>
<span class="p_del">-			dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_del">-				&quot;Unable to get I2S-RX dma resource\n&quot;);</span>
<span class="p_del">-			return -ENXIO;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pri_dai-&gt;dma_capture.channel = res-&gt;start;</span>
<span class="p_del">-</span>
 		if (i2s_pdata == NULL) {
 			dev_err(&amp;pdev-&gt;dev, &quot;Can&#39;t work without s3c_audio_pdata\n&quot;);
 			return -EINVAL;
 		}
 
<span class="p_add">+		pri_dai-&gt;dma_playback.slave = i2s_pdata-&gt;dma_playback;</span>
<span class="p_add">+		pri_dai-&gt;dma_capture.slave = i2s_pdata-&gt;dma_capture;</span>
<span class="p_add">+</span>
 		if (&amp;i2s_pdata-&gt;type)
 			i2s_cfg = &amp;i2s_pdata-&gt;type.i2s;
 
<span class="p_chunk">@@ -1341,11 +1328,8 @@</span> <span class="p_context"> static int samsung_i2s_probe(struct platform_device *pdev)</span>
 		sec_dai-&gt;dma_playback.dma_addr = regs_base + I2STXDS;
 		sec_dai-&gt;dma_playback.ch_name = &quot;tx-sec&quot;;
 
<span class="p_del">-		if (!np) {</span>
<span class="p_del">-			res = platform_get_resource(pdev, IORESOURCE_DMA, 2);</span>
<span class="p_del">-			if (res)</span>
<span class="p_del">-				sec_dai-&gt;dma_playback.channel = res-&gt;start;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!np)</span>
<span class="p_add">+			sec_dai-&gt;dma_playback.slave = i2s_pdata-&gt;dma_play_sec;</span>
 
 		sec_dai-&gt;dma_playback.dma_size = 4;
 		sec_dai-&gt;addr = pri_dai-&gt;addr;
<span class="p_header">diff --git a/sound/soc/samsung/pcm.c b/sound/soc/samsung/pcm.c</span>
<span class="p_header">index b320a9d3fbf8..c77f324e0bb8 100644</span>
<span class="p_header">--- a/sound/soc/samsung/pcm.c</span>
<span class="p_header">+++ b/sound/soc/samsung/pcm.c</span>
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> static const struct snd_soc_component_driver s3c_pcm_component = {</span>
 static int s3c_pcm_dev_probe(struct platform_device *pdev)
 {
 	struct s3c_pcm_info *pcm;
<span class="p_del">-	struct resource *mem_res, *dmatx_res, *dmarx_res;</span>
<span class="p_add">+	struct resource *mem_res;</span>
 	struct s3c_audio_pdata *pcm_pdata;
 	int ret;
 
<span class="p_chunk">@@ -499,18 +499,6 @@</span> <span class="p_context"> static int s3c_pcm_dev_probe(struct platform_device *pdev)</span>
 	pcm_pdata = pdev-&gt;dev.platform_data;
 
 	/* Check for availability of necessary resource */
<span class="p_del">-	dmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);</span>
<span class="p_del">-	if (!dmatx_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get PCM-TX dma resource\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);</span>
<span class="p_del">-	if (!dmarx_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get PCM-RX dma resource\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem_res) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get register resource\n&quot;);
<span class="p_chunk">@@ -568,8 +556,10 @@</span> <span class="p_context"> static int s3c_pcm_dev_probe(struct platform_device *pdev)</span>
 	s3c_pcm_stereo_out[pdev-&gt;id].dma_addr = mem_res-&gt;start
 							+ S3C_PCM_TXFIFO;
 
<span class="p_del">-	s3c_pcm_stereo_in[pdev-&gt;id].channel = dmarx_res-&gt;start;</span>
<span class="p_del">-	s3c_pcm_stereo_out[pdev-&gt;id].channel = dmatx_res-&gt;start;</span>
<span class="p_add">+	if (pcm_pdata) {</span>
<span class="p_add">+		s3c_pcm_stereo_in[pdev-&gt;id].slave = pcm_pdata-&gt;dma_capture;</span>
<span class="p_add">+		s3c_pcm_stereo_out[pdev-&gt;id].slave = pcm_pdata-&gt;dma_playback;</span>
<span class="p_add">+	}</span>
 
 	pcm-&gt;dma_capture = &amp;s3c_pcm_stereo_in[pdev-&gt;id];
 	pcm-&gt;dma_playback = &amp;s3c_pcm_stereo_out[pdev-&gt;id];
<span class="p_header">diff --git a/sound/soc/samsung/s3c2412-i2s.c b/sound/soc/samsung/s3c2412-i2s.c</span>
<span class="p_header">index 2b766d212ce0..77d27c85a32a 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c2412-i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c2412-i2s.c</span>
<span class="p_chunk">@@ -34,13 +34,13 @@</span> <span class="p_context"></span>
 #include &quot;s3c2412-i2s.h&quot;
 
 static struct s3c_dma_params s3c2412_i2s_pcm_stereo_out = {
<span class="p_del">-	.channel	= DMACH_I2S_OUT,</span>
<span class="p_add">+	.slave		= (void *)(uintptr_t)DMACH_I2S_OUT,</span>
 	.ch_name	= &quot;tx&quot;,
 	.dma_size	= 4,
 };
 
 static struct s3c_dma_params s3c2412_i2s_pcm_stereo_in = {
<span class="p_del">-	.channel	= DMACH_I2S_IN,</span>
<span class="p_add">+	.slave		= (void *)(uintptr_t)DMACH_I2S_IN,</span>
 	.ch_name	= &quot;rx&quot;,
 	.dma_size	= 4,
 };
<span class="p_header">diff --git a/sound/soc/samsung/s3c24xx-i2s.c b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">index 5bf723689692..9da3a77ea2c7 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_chunk">@@ -32,13 +32,13 @@</span> <span class="p_context"></span>
 #include &quot;s3c24xx-i2s.h&quot;
 
 static struct s3c_dma_params s3c24xx_i2s_pcm_stereo_out = {
<span class="p_del">-	.channel	= DMACH_I2S_OUT,</span>
<span class="p_add">+	.slave		= (void *)(uintptr_t)DMACH_I2S_OUT,</span>
 	.ch_name	= &quot;tx&quot;,
 	.dma_size	= 2,
 };
 
 static struct s3c_dma_params s3c24xx_i2s_pcm_stereo_in = {
<span class="p_del">-	.channel	= DMACH_I2S_IN,</span>
<span class="p_add">+	.slave		= (void *)(uintptr_t)DMACH_I2S_IN,</span>
 	.ch_name	= &quot;rx&quot;,
 	.dma_size	= 2,
 };
<span class="p_header">diff --git a/sound/soc/samsung/spdif.c b/sound/soc/samsung/spdif.c</span>
<span class="p_header">index 36dbc0e96004..9dd7ee6d03ff 100644</span>
<span class="p_header">--- a/sound/soc/samsung/spdif.c</span>
<span class="p_header">+++ b/sound/soc/samsung/spdif.c</span>
<span class="p_chunk">@@ -359,7 +359,7 @@</span> <span class="p_context"> static const struct snd_soc_component_driver samsung_spdif_component = {</span>
 static int spdif_probe(struct platform_device *pdev)
 {
 	struct s3c_audio_pdata *spdif_pdata;
<span class="p_del">-	struct resource *mem_res, *dma_res;</span>
<span class="p_add">+	struct resource *mem_res;</span>
 	struct samsung_spdif_info *spdif;
 	int ret;
 
<span class="p_chunk">@@ -367,12 +367,6 @@</span> <span class="p_context"> static int spdif_probe(struct platform_device *pdev)</span>
 
 	dev_dbg(&amp;pdev-&gt;dev, &quot;Entered %s\n&quot;, __func__);
 
<span class="p_del">-	dma_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);</span>
<span class="p_del">-	if (!dma_res) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get dma resource.\n&quot;);</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	mem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem_res) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Unable to get register resource.\n&quot;);
<span class="p_chunk">@@ -432,7 +426,7 @@</span> <span class="p_context"> static int spdif_probe(struct platform_device *pdev)</span>
 
 	spdif_stereo_out.dma_size = 2;
 	spdif_stereo_out.dma_addr = mem_res-&gt;start + DATA_OUTBUF;
<span class="p_del">-	spdif_stereo_out.channel = dma_res-&gt;start;</span>
<span class="p_add">+	spdif_stereo_out.slave = spdif_pdata ? spdif_pdata-&gt;dma_playback : NULL;</span>
 
 	spdif-&gt;dma_playback = &amp;spdif_stereo_out;
 
<span class="p_header">diff --git a/sound/usb/clock.c b/sound/usb/clock.c</span>
<span class="p_header">index 2ed260b10f6d..7ccbcaf6a147 100644</span>
<span class="p_header">--- a/sound/usb/clock.c</span>
<span class="p_header">+++ b/sound/usb/clock.c</span>
<span class="p_chunk">@@ -285,6 +285,8 @@</span> <span class="p_context"> static int set_sample_rate_v1(struct snd_usb_audio *chip, int iface,</span>
 	unsigned char data[3];
 	int err, crate;
 
<span class="p_add">+	if (get_iface_desc(alts)-&gt;bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -EINVAL;</span>
 	ep = get_endpoint(alts, 0)-&gt;bEndpointAddress;
 
 	/* if endpoint doesn&#39;t have sampling rate control, bail out */
<span class="p_header">diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c</span>
<span class="p_header">index 7b1cb365ffab..c07a7eda42a2 100644</span>
<span class="p_header">--- a/sound/usb/endpoint.c</span>
<span class="p_header">+++ b/sound/usb/endpoint.c</span>
<span class="p_chunk">@@ -438,6 +438,9 @@</span> <span class="p_context"> exit_clear:</span>
  *
  * New endpoints will be added to chip-&gt;ep_list and must be freed by
  * calling snd_usb_endpoint_free().
<span class="p_add">+ *</span>
<span class="p_add">+ * For SND_USB_ENDPOINT_TYPE_SYNC, the caller needs to guarantee that</span>
<span class="p_add">+ * bNumEndpoints &gt; 1 beforehand.</span>
  */
 struct snd_usb_endpoint *snd_usb_add_endpoint(struct snd_usb_audio *chip,
 					      struct usb_host_interface *alts,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 279025650568..f6c3bf79af9a 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1519,7 +1519,11 @@</span> <span class="p_context"> static int snd_microii_spdif_default_get(struct snd_kcontrol *kcontrol,</span>
 
 	/* use known values for that card: interface#1 altsetting#1 */
 	iface = usb_ifnum_to_if(chip-&gt;dev, 1);
<span class="p_add">+	if (!iface || iface-&gt;num_altsetting &lt; 2)</span>
<span class="p_add">+		return -EINVAL;</span>
 	alts = &amp;iface-&gt;altsetting[1];
<span class="p_add">+	if (get_iface_desc(alts)-&gt;bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -EINVAL;</span>
 	ep = get_endpoint(alts, 0)-&gt;bEndpointAddress;
 
 	err = snd_usb_ctl_msg(chip-&gt;dev,
<span class="p_header">diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c</span>
<span class="p_header">index 9245f52d43bd..44d178ee9177 100644</span>
<span class="p_header">--- a/sound/usb/pcm.c</span>
<span class="p_header">+++ b/sound/usb/pcm.c</span>
<span class="p_chunk">@@ -159,6 +159,8 @@</span> <span class="p_context"> static int init_pitch_v1(struct snd_usb_audio *chip, int iface,</span>
 	unsigned char data[1];
 	int err;
 
<span class="p_add">+	if (get_iface_desc(alts)-&gt;bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -EINVAL;</span>
 	ep = get_endpoint(alts, 0)-&gt;bEndpointAddress;
 
 	data[0] = 1;
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index c458d60d5030..cd7eac28edee 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -150,6 +150,7 @@</span> <span class="p_context"> static int create_fixed_stream_quirk(struct snd_usb_audio *chip,</span>
 		usb_audio_err(chip, &quot;cannot memdup\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+	INIT_LIST_HEAD(&amp;fp-&gt;list);</span>
 	if (fp-&gt;nr_rates &gt; MAX_NR_RATES) {
 		kfree(fp);
 		return -EINVAL;
<span class="p_chunk">@@ -167,19 +168,20 @@</span> <span class="p_context"> static int create_fixed_stream_quirk(struct snd_usb_audio *chip,</span>
 	stream = (fp-&gt;endpoint &amp; USB_DIR_IN)
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 	err = snd_usb_add_audio_stream(chip, stream, fp);
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		kfree(fp);</span>
<span class="p_del">-		kfree(rate_table);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
 	if (fp-&gt;iface != get_iface_desc(&amp;iface-&gt;altsetting[0])-&gt;bInterfaceNumber ||
 	    fp-&gt;altset_idx &gt;= iface-&gt;num_altsetting) {
<span class="p_del">-		kfree(fp);</span>
<span class="p_del">-		kfree(rate_table);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto error;</span>
 	}
 	alts = &amp;iface-&gt;altsetting[fp-&gt;altset_idx];
 	altsd = get_iface_desc(alts);
<span class="p_add">+	if (altsd-&gt;bNumEndpoints &lt; 1) {</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	fp-&gt;protocol = altsd-&gt;bInterfaceProtocol;
 
 	if (fp-&gt;datainterval == 0)
<span class="p_chunk">@@ -190,6 +192,12 @@</span> <span class="p_context"> static int create_fixed_stream_quirk(struct snd_usb_audio *chip,</span>
 	snd_usb_init_pitch(chip, fp-&gt;iface, alts, fp);
 	snd_usb_init_sample_rate(chip, fp-&gt;iface, alts, fp, fp-&gt;rate_max);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ error:</span>
<span class="p_add">+	list_del(&amp;fp-&gt;list); /* unlink for avoiding double-free */</span>
<span class="p_add">+	kfree(fp);</span>
<span class="p_add">+	kfree(rate_table);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int create_auto_pcm_quirk(struct snd_usb_audio *chip,
<span class="p_chunk">@@ -462,6 +470,7 @@</span> <span class="p_context"> static int create_uaxx_quirk(struct snd_usb_audio *chip,</span>
 	fp-&gt;ep_attr = get_endpoint(alts, 0)-&gt;bmAttributes;
 	fp-&gt;datainterval = 0;
 	fp-&gt;maxpacksize = le16_to_cpu(get_endpoint(alts, 0)-&gt;wMaxPacketSize);
<span class="p_add">+	INIT_LIST_HEAD(&amp;fp-&gt;list);</span>
 
 	switch (fp-&gt;maxpacksize) {
 	case 0x120:
<span class="p_chunk">@@ -485,6 +494,7 @@</span> <span class="p_context"> static int create_uaxx_quirk(struct snd_usb_audio *chip,</span>
 		? SNDRV_PCM_STREAM_CAPTURE : SNDRV_PCM_STREAM_PLAYBACK;
 	err = snd_usb_add_audio_stream(chip, stream, fp);
 	if (err &lt; 0) {
<span class="p_add">+		list_del(&amp;fp-&gt;list); /* unlink for avoiding double-free */</span>
 		kfree(fp);
 		return err;
 	}
<span class="p_chunk">@@ -1121,6 +1131,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	switch (chip-&gt;usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
<span class="p_add">+	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */</span>
 	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
<span class="p_header">diff --git a/sound/usb/stream.c b/sound/usb/stream.c</span>
<span class="p_header">index 8ee14f2365e7..3b23102230c0 100644</span>
<span class="p_header">--- a/sound/usb/stream.c</span>
<span class="p_header">+++ b/sound/usb/stream.c</span>
<span class="p_chunk">@@ -316,7 +316,9 @@</span> <span class="p_context"> static struct snd_pcm_chmap_elem *convert_chmap(int channels, unsigned int bits,</span>
 /*
  * add this endpoint to the chip instance.
  * if a stream with the same endpoint already exists, append to it.
<span class="p_del">- * if not, create a new pcm stream.</span>
<span class="p_add">+ * if not, create a new pcm stream. note, fp is added to the substream</span>
<span class="p_add">+ * fmt_list and will be freed on the chip instance release. do not free</span>
<span class="p_add">+ * fp or do remove it from the substream fmt_list to avoid double-free.</span>
  */
 int snd_usb_add_audio_stream(struct snd_usb_audio *chip,
 			     int stream,
<span class="p_chunk">@@ -677,6 +679,7 @@</span> <span class="p_context"> int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)</span>
 					* (fp-&gt;maxpacksize &amp; 0x7ff);
 		fp-&gt;attributes = parse_uac_endpoint_attributes(chip, alts, protocol, iface_no);
 		fp-&gt;clock = clock;
<span class="p_add">+		INIT_LIST_HEAD(&amp;fp-&gt;list);</span>
 
 		/* some quirks for attributes here */
 
<span class="p_chunk">@@ -725,6 +728,7 @@</span> <span class="p_context"> int snd_usb_parse_audio_interface(struct snd_usb_audio *chip, int iface_no)</span>
 		dev_dbg(&amp;dev-&gt;dev, &quot;%u:%d: add audio endpoint %#x\n&quot;, iface_no, altno, fp-&gt;endpoint);
 		err = snd_usb_add_audio_stream(chip, stream, fp);
 		if (err &lt; 0) {
<span class="p_add">+			list_del(&amp;fp-&gt;list); /* unlink for avoiding double-free */</span>
 			kfree(fp-&gt;rate_table);
 			kfree(fp-&gt;chmap);
 			kfree(fp);
<span class="p_header">diff --git a/tools/hv/Makefile b/tools/hv/Makefile</span>
<span class="p_header">index a8ab79556926..a8c4644022a6 100644</span>
<span class="p_header">--- a/tools/hv/Makefile</span>
<span class="p_header">+++ b/tools/hv/Makefile</span>
<span class="p_chunk">@@ -5,6 +5,8 @@</span> <span class="p_context"> PTHREAD_LIBS = -lpthread</span>
 WARNINGS = -Wall -Wextra
 CFLAGS = $(WARNINGS) -g $(PTHREAD_LIBS) $(shell getconf LFS_CFLAGS)
 
<span class="p_add">+CFLAGS += -D__EXPORTED_HEADERS__ -I../../include/uapi -I../../include</span>
<span class="p_add">+</span>
 all: hv_kvp_daemon hv_vss_daemon hv_fcopy_daemon
 %: %.c
 	$(CC) $(CFLAGS) -o $@ $^
<span class="p_header">diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c</span>
<span class="p_header">index b48e87693aa5..a35db828bd0d 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.c</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.c</span>
<span class="p_chunk">@@ -2101,11 +2101,11 @@</span> <span class="p_context"> char *parse_events_formats_error_string(char *additional_terms)</span>
 
 	/* valid terms */
 	if (additional_terms) {
<span class="p_del">-		if (!asprintf(&amp;str, &quot;valid terms: %s,%s&quot;,</span>
<span class="p_del">-			      additional_terms, static_terms))</span>
<span class="p_add">+		if (asprintf(&amp;str, &quot;valid terms: %s,%s&quot;,</span>
<span class="p_add">+			     additional_terms, static_terms) &lt; 0)</span>
 			goto fail;
 	} else {
<span class="p_del">-		if (!asprintf(&amp;str, &quot;valid terms: %s&quot;, static_terms))</span>
<span class="p_add">+		if (asprintf(&amp;str, &quot;valid terms: %s&quot;, static_terms) &lt; 0)</span>
 			goto fail;
 	}
 	return str;
<span class="p_header">diff --git a/tools/perf/util/pmu.c b/tools/perf/util/pmu.c</span>
<span class="p_header">index e4b173dec4b9..6f2a0279476c 100644</span>
<span class="p_header">--- a/tools/perf/util/pmu.c</span>
<span class="p_header">+++ b/tools/perf/util/pmu.c</span>
<span class="p_chunk">@@ -283,13 +283,12 @@</span> <span class="p_context"> static int pmu_aliases_parse(char *dir, struct list_head *head)</span>
 {
 	struct dirent *evt_ent;
 	DIR *event_dir;
<span class="p_del">-	int ret = 0;</span>
 
 	event_dir = opendir(dir);
 	if (!event_dir)
 		return -EINVAL;
 
<span class="p_del">-	while (!ret &amp;&amp; (evt_ent = readdir(event_dir))) {</span>
<span class="p_add">+	while ((evt_ent = readdir(event_dir))) {</span>
 		char path[PATH_MAX];
 		char *name = evt_ent-&gt;d_name;
 		FILE *file;
<span class="p_chunk">@@ -305,17 +304,19 @@</span> <span class="p_context"> static int pmu_aliases_parse(char *dir, struct list_head *head)</span>
 
 		snprintf(path, PATH_MAX, &quot;%s/%s&quot;, dir, name);
 
<span class="p_del">-		ret = -EINVAL;</span>
 		file = fopen(path, &quot;r&quot;);
<span class="p_del">-		if (!file)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		if (!file) {</span>
<span class="p_add">+			pr_debug(&quot;Cannot open %s\n&quot;, path);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		ret = perf_pmu__new_alias(head, dir, name, file);</span>
<span class="p_add">+		if (perf_pmu__new_alias(head, dir, name, file) &lt; 0)</span>
<span class="p_add">+			pr_debug(&quot;Cannot set up %s\n&quot;, name);</span>
 		fclose(file);
 	}
 
 	closedir(event_dir);
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/tools/perf/util/setup.py b/tools/perf/util/setup.py</span>
<span class="p_header">index 1833103768cb..c8680984d2d6 100644</span>
<span class="p_header">--- a/tools/perf/util/setup.py</span>
<span class="p_header">+++ b/tools/perf/util/setup.py</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"> cflags = getenv(&#39;CFLAGS&#39;, &#39;&#39;).split()</span>
 # switch off several checks (need to be at the end of cflags list)
 cflags += [&#39;-fno-strict-aliasing&#39;, &#39;-Wno-write-strings&#39;, &#39;-Wno-unused-parameter&#39; ]
 
<span class="p_add">+src_perf  = getenv(&#39;srctree&#39;) + &#39;/tools/perf&#39;</span>
 build_lib = getenv(&#39;PYTHON_EXTBUILD_LIB&#39;)
 build_tmp = getenv(&#39;PYTHON_EXTBUILD_TMP&#39;)
 libtraceevent = getenv(&#39;LIBTRACEEVENT&#39;)
<span class="p_chunk">@@ -30,6 +31,9 @@</span> <span class="p_context"> libapikfs = getenv(&#39;LIBAPI&#39;)</span>
 ext_sources = [f.strip() for f in file(&#39;util/python-ext-sources&#39;)
 				if len(f.strip()) &gt; 0 and f[0] != &#39;#&#39;]
 
<span class="p_add">+# use full paths with source files</span>
<span class="p_add">+ext_sources = map(lambda x: &#39;%s/%s&#39; % (src_perf, x) , ext_sources)</span>
<span class="p_add">+</span>
 perf = Extension(&#39;perf&#39;,
 		  sources = ext_sources,
 		  include_dirs = [&#39;util/include&#39;],
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 7338e30421d8..fefbf2d148ef 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -547,6 +547,16 @@</span> <span class="p_context"> static struct kvm *kvm_create_vm(unsigned long type)</span>
 	if (!kvm)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	spin_lock_init(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_add">+	atomic_inc(&amp;current-&gt;mm-&gt;mm_count);</span>
<span class="p_add">+	kvm-&gt;mm = current-&gt;mm;</span>
<span class="p_add">+	kvm_eventfd_init(kvm);</span>
<span class="p_add">+	mutex_init(&amp;kvm-&gt;lock);</span>
<span class="p_add">+	mutex_init(&amp;kvm-&gt;irq_lock);</span>
<span class="p_add">+	mutex_init(&amp;kvm-&gt;slots_lock);</span>
<span class="p_add">+	atomic_set(&amp;kvm-&gt;users_count, 1);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;kvm-&gt;devices);</span>
<span class="p_add">+</span>
 	r = kvm_arch_init_vm(kvm, type);
 	if (r)
 		goto out_err_no_disable;
<span class="p_chunk">@@ -579,16 +589,6 @@</span> <span class="p_context"> static struct kvm *kvm_create_vm(unsigned long type)</span>
 			goto out_err;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;kvm-&gt;mmu_lock);</span>
<span class="p_del">-	kvm-&gt;mm = current-&gt;mm;</span>
<span class="p_del">-	atomic_inc(&amp;kvm-&gt;mm-&gt;mm_count);</span>
<span class="p_del">-	kvm_eventfd_init(kvm);</span>
<span class="p_del">-	mutex_init(&amp;kvm-&gt;lock);</span>
<span class="p_del">-	mutex_init(&amp;kvm-&gt;irq_lock);</span>
<span class="p_del">-	mutex_init(&amp;kvm-&gt;slots_lock);</span>
<span class="p_del">-	atomic_set(&amp;kvm-&gt;users_count, 1);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;kvm-&gt;devices);</span>
<span class="p_del">-</span>
 	r = kvm_init_mmu_notifier(kvm);
 	if (r)
 		goto out_err;
<span class="p_chunk">@@ -613,6 +613,7 @@</span> <span class="p_context"> out_err_no_disable:</span>
 	for (i = 0; i &lt; KVM_ADDRESS_SPACE_NUM; i++)
 		kvm_free_memslots(kvm, kvm-&gt;memslots[i]);
 	kvm_arch_free_vm(kvm);
<span class="p_add">+	mmdrop(current-&gt;mm);</span>
 	return ERR_PTR(r);
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



