
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.19.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.19.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 7, 2015, 11:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150507231056.GB5221@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6361191/mbox/"
   >mbox</a>
|
   <a href="/patch/6361191/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6361191/">/patch/6361191/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id ACB6DBEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:12:01 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id E83EF2034C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:11:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id DB99A203B1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:11:31 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752122AbbEGXLT (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 7 May 2015 19:11:19 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46093 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752033AbbEGXLD (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 7 May 2015 19:11:03 -0400
Received: from localhost (gob75-2-82-67-192-59.fbx.proxad.net [82.67.192.59])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id A12C3ACB;
	Thu,  7 May 2015 23:10:58 +0000 (UTC)
Date: Fri, 8 May 2015 01:10:56 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.19.7
Message-ID: &lt;20150507231056.GB5221@kroah.com&gt;
References: &lt;20150507231046.GA5221@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150507231046.GA5221@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 7, 2015, 11:10 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/virtual/kvm/devices/s390_flic.txt b/Documentation/virtual/kvm/devices/s390_flic.txt</span>
<span class="p_header">index 4ceef53164b0..d1ad9d5cae46 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/devices/s390_flic.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/devices/s390_flic.txt</span>
<span class="p_chunk">@@ -27,6 +27,9 @@</span> <span class="p_context"> Groups:</span>
     Copies all floating interrupts into a buffer provided by userspace.
     When the buffer is too small it returns -ENOMEM, which is the indication
     for userspace to try again with a bigger buffer.
<span class="p_add">+    -ENOBUFS is returned when the allocation of a kernelspace buffer has</span>
<span class="p_add">+    failed.</span>
<span class="p_add">+    -EFAULT is returned when copying data to userspace failed.</span>
     All interrupts remain pending, i.e. are not deleted from the list of
     currently pending interrupts.
     attr-&gt;addr contains the userspace address of the buffer into which all
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 65c7c8756803..69952c1404b2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Diseased Newt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d3_xplained.dts b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">index fec1fca2ad66..6c4bc53cbf4e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_chunk">@@ -167,7 +167,13 @@</span> <span class="p_context"></span>
 
 			macb1: ethernet@f802c000 {
 				phy-mode = &quot;rmii&quot;;
<span class="p_add">+				#address-cells = &lt;1&gt;;</span>
<span class="p_add">+				#size-cells = &lt;0&gt;;</span>
 				status = &quot;okay&quot;;
<span class="p_add">+</span>
<span class="p_add">+				ethernet-phy@1 {</span>
<span class="p_add">+					reg = &lt;0x1&gt;;</span>
<span class="p_add">+				};</span>
 			};
 
 			dbgu: serial@ffffee00 {
<span class="p_header">diff --git a/arch/arm/boot/dts/dove.dtsi b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">index a5441d5482a6..3cc8b8320345 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dove.dtsi</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"></span>
 
 			uart2: serial@12200 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12000 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12200 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;9&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"></span>
 
 			uart3: serial@12300 {
 				compatible = &quot;ns16550a&quot;;
<span class="p_del">-				reg = &lt;0x12100 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0x12300 0x100&gt;;</span>
 				reg-shift = &lt;2&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;core_clk 0&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos5250-spring.dts b/arch/arm/boot/dts/exynos5250-spring.dts</span>
<span class="p_header">index f02775487cd4..c41600e587e0 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos5250-spring.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos5250-spring.dts</span>
<span class="p_chunk">@@ -429,7 +429,6 @@</span> <span class="p_context"></span>
 &amp;mmc_0 {
 	status = &quot;okay&quot;;
 	num-slots = &lt;1&gt;;
<span class="p_del">-	supports-highspeed;</span>
 	broken-cd;
 	card-detect-delay = &lt;200&gt;;
 	samsung,dw-mshc-ciu-div = &lt;3&gt;;
<span class="p_chunk">@@ -437,11 +436,8 @@</span> <span class="p_context"></span>
 	samsung,dw-mshc-ddr-timing = &lt;1 2&gt;;
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;sd0_clk &amp;sd0_cmd &amp;sd0_cd &amp;sd0_bus4 &amp;sd0_bus8&gt;;
<span class="p_del">-</span>
<span class="p_del">-	slot@0 {</span>
<span class="p_del">-		reg = &lt;0&gt;;</span>
<span class="p_del">-		bus-width = &lt;8&gt;;</span>
<span class="p_del">-	};</span>
<span class="p_add">+	bus-width = &lt;8&gt;;</span>
<span class="p_add">+	cap-mmc-highspeed;</span>
 };
 
 /*
<span class="p_chunk">@@ -451,7 +447,6 @@</span> <span class="p_context"></span>
 &amp;mmc_1 {
 	status = &quot;okay&quot;;
 	num-slots = &lt;1&gt;;
<span class="p_del">-	supports-highspeed;</span>
 	broken-cd;
 	card-detect-delay = &lt;200&gt;;
 	samsung,dw-mshc-ciu-div = &lt;3&gt;;
<span class="p_chunk">@@ -459,11 +454,8 @@</span> <span class="p_context"></span>
 	samsung,dw-mshc-ddr-timing = &lt;1 2&gt;;
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;sd1_clk &amp;sd1_cmd &amp;sd1_cd &amp;sd1_bus4&gt;;
<span class="p_del">-</span>
<span class="p_del">-	slot@0 {</span>
<span class="p_del">-		reg = &lt;0&gt;;</span>
<span class="p_del">-		bus-width = &lt;4&gt;;</span>
<span class="p_del">-	};</span>
<span class="p_add">+	bus-width = &lt;4&gt;;</span>
<span class="p_add">+	cap-sd-highspeed;</span>
 };
 
 &amp;pinctrl_0 {
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index afb9cafd3786..674d03f4ba15 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 1bca8f8af442..5de64c0e477d 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -128,29 +128,28 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\
 })
 
<span class="p_add">+#define kvm_pgd_index(addr)			pgd_index(addr)</span>
<span class="p_add">+</span>
 static inline bool kvm_page_empty(void *ptr)
 {
 	struct page *ptr_page = virt_to_page(ptr);
 	return page_count(ptr_page) == 1;
 }
 
<span class="p_del">-</span>
 #define kvm_pte_table_empty(kvm, ptep) kvm_page_empty(ptep)
 #define kvm_pmd_table_empty(kvm, pmdp) kvm_page_empty(pmdp)
 #define kvm_pud_table_empty(kvm, pudp) (0)
 
 #define KVM_PREALLOC_LEVEL	0
 
<span class="p_del">-static inline int kvm_prealloc_hwpgd(struct kvm *kvm, pgd_t *pgd)</span>
<span class="p_add">+static inline void *kvm_get_hwpgd(struct kvm *kvm)</span>
 {
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return kvm-&gt;arch.pgd;</span>
 }
 
<span class="p_del">-static inline void kvm_free_hwpgd(struct kvm *kvm) { }</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void *kvm_get_hwpgd(struct kvm *kvm)</span>
<span class="p_add">+static inline unsigned int kvm_get_hwpgd_size(void)</span>
 {
<span class="p_del">-	return kvm-&gt;arch.pgd;</span>
<span class="p_add">+	return PTRS_PER_S2_PGD * sizeof(pgd_t);</span>
 }
 
 struct kvm;
<span class="p_chunk">@@ -186,7 +185,7 @@</span> <span class="p_context"> static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu, pfn_t pfn,</span>
 
 	bool need_flush = !vcpu_has_cache_enabled(vcpu) || ipa_uncached;
 
<span class="p_del">-	VM_BUG_ON(size &amp; PAGE_MASK);</span>
<span class="p_add">+	VM_BUG_ON(size &amp; ~PAGE_MASK);</span>
 
 	if (!need_flush &amp;&amp; !icache_is_pipt())
 		goto vipt_cache;
<span class="p_header">diff --git a/arch/arm/include/uapi/asm/kvm.h b/arch/arm/include/uapi/asm/kvm.h</span>
<span class="p_header">index 09ee408c1a67..b404cf886029 100644</span>
<span class="p_header">--- a/arch/arm/include/uapi/asm/kvm.h</span>
<span class="p_header">+++ b/arch/arm/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -193,8 +193,14 @@</span> <span class="p_context"> struct kvm_arch_memory_slot {</span>
 #define KVM_ARM_IRQ_CPU_IRQ		0
 #define KVM_ARM_IRQ_CPU_FIQ		1
 
<span class="p_del">-/* Highest supported SPI, from VGIC_NR_IRQS */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This used to hold the highest supported SPI, but it is now obsolete</span>
<span class="p_add">+ * and only here to provide source code level compatibility with older</span>
<span class="p_add">+ * userland. The highest SPI number can be set via KVM_DEV_ARM_VGIC_GRP_NR_IRQS.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __KERNEL__</span>
 #define KVM_ARM_IRQ_GIC_MAX		127
<span class="p_add">+#endif</span>
 
 /* PSCI interface */
 #define KVM_PSCI_FN_BASE		0x95c1ba5e
<span class="p_header">diff --git a/arch/arm/kernel/hibernate.c b/arch/arm/kernel/hibernate.c</span>
<span class="p_header">index c4cc50e58c13..cfb354ff2a60 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/arm/kernel/hibernate.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/suspend.h&gt;
 #include &lt;asm/memory.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_add">+#include &quot;reboot.h&quot;</span>
 
 int pfn_is_nosave(unsigned long pfn)
 {
<span class="p_chunk">@@ -61,7 +62,7 @@</span> <span class="p_context"> static int notrace arch_save_image(unsigned long unused)</span>
 
 	ret = swsusp_save();
 	if (ret == 0)
<span class="p_del">-		soft_restart(virt_to_phys(cpu_resume));</span>
<span class="p_add">+		_soft_restart(virt_to_phys(cpu_resume), false);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -86,7 +87,7 @@</span> <span class="p_context"> static void notrace arch_restore_image(void *unused)</span>
 	for (pbe = restore_pblist; pbe; pbe = pbe-&gt;next)
 		copy_page(pbe-&gt;orig_address, pbe-&gt;address);
 
<span class="p_del">-	soft_restart(virt_to_phys(cpu_resume));</span>
<span class="p_add">+	_soft_restart(virt_to_phys(cpu_resume), false);</span>
 }
 
 static u64 resume_stack[PAGE_SIZE/2/sizeof(u64)] __nosavedata;
<span class="p_header">diff --git a/arch/arm/kernel/process.c b/arch/arm/kernel/process.c</span>
<span class="p_header">index fdfa3a78ec8c..2bf1a162defb 100644</span>
<span class="p_header">--- a/arch/arm/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm/kernel/process.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/system_misc.h&gt;
 #include &lt;asm/mach/time.h&gt;
 #include &lt;asm/tls.h&gt;
<span class="p_add">+#include &quot;reboot.h&quot;</span>
 
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include &lt;linux/stackprotector.h&gt;
<span class="p_chunk">@@ -95,7 +96,7 @@</span> <span class="p_context"> static void __soft_restart(void *addr)</span>
 	BUG();
 }
 
<span class="p_del">-void soft_restart(unsigned long addr)</span>
<span class="p_add">+void _soft_restart(unsigned long addr, bool disable_l2)</span>
 {
 	u64 *stack = soft_restart_stack + ARRAY_SIZE(soft_restart_stack);
 
<span class="p_chunk">@@ -104,7 +105,7 @@</span> <span class="p_context"> void soft_restart(unsigned long addr)</span>
 	local_fiq_disable();
 
 	/* Disable the L2 if we&#39;re the last man standing. */
<span class="p_del">-	if (num_online_cpus() == 1)</span>
<span class="p_add">+	if (disable_l2)</span>
 		outer_disable();
 
 	/* Change to the new stack and continue with the reset. */
<span class="p_chunk">@@ -114,6 +115,11 @@</span> <span class="p_context"> void soft_restart(unsigned long addr)</span>
 	BUG();
 }
 
<span class="p_add">+void soft_restart(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	_soft_restart(addr, num_online_cpus() == 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Function pointers to optional machine specific functions
  */
<span class="p_header">diff --git a/arch/arm/kernel/reboot.h b/arch/arm/kernel/reboot.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c87f05816d6b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/kernel/reboot.h</span>
<span class="p_chunk">@@ -0,0 +1,6 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef REBOOT_H</span>
<span class="p_add">+#define REBOOT_H</span>
<span class="p_add">+</span>
<span class="p_add">+extern void _soft_restart(unsigned long addr, bool disable_l2);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index 0b0d58a905c4..3ec96878e1c3 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -644,8 +644,7 @@</span> <span class="p_context"> int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irq_level,</span>
 		if (!irqchip_in_kernel(kvm))
 			return -ENXIO;
 
<span class="p_del">-		if (irq_num &lt; VGIC_NR_PRIVATE_IRQS ||</span>
<span class="p_del">-		    irq_num &gt; KVM_ARM_IRQ_GIC_MAX)</span>
<span class="p_add">+		if (irq_num &lt; VGIC_NR_PRIVATE_IRQS)</span>
 			return -EINVAL;
 
 		return kvm_vgic_inject_irq(kvm, 0, irq_num, level);
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 136662547ca6..9ec6dfee6a9c 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -251,7 +251,7 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 	phys_addr_t addr = start, end = start + size;
 	phys_addr_t next;
 
<span class="p_del">-	pgd = pgdp + pgd_index(addr);</span>
<span class="p_add">+	pgd = pgdp + kvm_pgd_index(addr);</span>
 	do {
 		next = kvm_pgd_addr_end(addr, end);
 		if (!pgd_none(*pgd))
<span class="p_chunk">@@ -316,7 +316,7 @@</span> <span class="p_context"> static void stage2_flush_memslot(struct kvm *kvm,</span>
 	phys_addr_t next;
 	pgd_t *pgd;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	do {
 		next = kvm_pgd_addr_end(addr, end);
 		stage2_flush_puds(kvm, pgd, addr, next);
<span class="p_chunk">@@ -593,6 +593,20 @@</span> <span class="p_context"> int create_hyp_io_mappings(void *from, void *to, phys_addr_t phys_addr)</span>
 				     __phys_to_pfn(phys_addr), PAGE_HYP_DEVICE);
 }
 
<span class="p_add">+/* Free the HW pgd, one page at a time */</span>
<span class="p_add">+static void kvm_free_hwpgd(void *hwpgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	free_pages_exact(hwpgd, kvm_get_hwpgd_size());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allocate the HW PGD, making sure that each page gets its own refcount */</span>
<span class="p_add">+static void *kvm_alloc_hwpgd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int size = kvm_get_hwpgd_size();</span>
<span class="p_add">+</span>
<span class="p_add">+	return alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * kvm_alloc_stage2_pgd - allocate level-1 table for stage-2 translation.
  * @kvm:	The KVM struct pointer for the VM.
<span class="p_chunk">@@ -606,15 +620,31 @@</span> <span class="p_context"> int create_hyp_io_mappings(void *from, void *to, phys_addr_t phys_addr)</span>
  */
 int kvm_alloc_stage2_pgd(struct kvm *kvm)
 {
<span class="p_del">-	int ret;</span>
 	pgd_t *pgd;
<span class="p_add">+	void *hwpgd;</span>
 
 	if (kvm-&gt;arch.pgd != NULL) {
 		kvm_err(&quot;kvm_arch already initialized?\n&quot;);
 		return -EINVAL;
 	}
 
<span class="p_add">+	hwpgd = kvm_alloc_hwpgd();</span>
<span class="p_add">+	if (!hwpgd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* When the kernel uses more levels of page tables than the</span>
<span class="p_add">+	 * guest, we allocate a fake PGD and pre-populate it to point</span>
<span class="p_add">+	 * to the next-level page table, which will be the real</span>
<span class="p_add">+	 * initial page table pointed to by the VTTBR.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * When KVM_PREALLOC_LEVEL==2, we allocate a single page for</span>
<span class="p_add">+	 * the PMD and the kernel will use folded pud.</span>
<span class="p_add">+	 * When KVM_PREALLOC_LEVEL==1, we allocate 2 consecutive PUD</span>
<span class="p_add">+	 * pages.</span>
<span class="p_add">+	 */</span>
 	if (KVM_PREALLOC_LEVEL &gt; 0) {
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
 		/*
 		 * Allocate fake pgd for the page table manipulation macros to
 		 * work.  This is not used by the hardware and we have no
<span class="p_chunk">@@ -622,30 +652,32 @@</span> <span class="p_context"> int kvm_alloc_stage2_pgd(struct kvm *kvm)</span>
 		 */
 		pgd = (pgd_t *)kmalloc(PTRS_PER_S2_PGD * sizeof(pgd_t),
 				       GFP_KERNEL | __GFP_ZERO);
<span class="p_add">+</span>
<span class="p_add">+		if (!pgd) {</span>
<span class="p_add">+			kvm_free_hwpgd(hwpgd);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Plug the HW PGD into the fake one. */</span>
<span class="p_add">+		for (i = 0; i &lt; PTRS_PER_S2_PGD; i++) {</span>
<span class="p_add">+			if (KVM_PREALLOC_LEVEL == 1)</span>
<span class="p_add">+				pgd_populate(NULL, pgd + i,</span>
<span class="p_add">+					     (pud_t *)hwpgd + i * PTRS_PER_PUD);</span>
<span class="p_add">+			else if (KVM_PREALLOC_LEVEL == 2)</span>
<span class="p_add">+				pud_populate(NULL, pud_offset(pgd, 0) + i,</span>
<span class="p_add">+					     (pmd_t *)hwpgd + i * PTRS_PER_PMD);</span>
<span class="p_add">+		}</span>
 	} else {
 		/*
 		 * Allocate actual first-level Stage-2 page table used by the
 		 * hardware for Stage-2 page table walks.
 		 */
<span class="p_del">-		pgd = (pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, S2_PGD_ORDER);</span>
<span class="p_add">+		pgd = (pgd_t *)hwpgd;</span>
 	}
 
<span class="p_del">-	if (!pgd)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = kvm_prealloc_hwpgd(kvm, pgd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_err;</span>
<span class="p_del">-</span>
 	kvm_clean_pgd(pgd);
 	kvm-&gt;arch.pgd = pgd;
 	return 0;
<span class="p_del">-out_err:</span>
<span class="p_del">-	if (KVM_PREALLOC_LEVEL &gt; 0)</span>
<span class="p_del">-		kfree(pgd);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		free_pages((unsigned long)pgd, S2_PGD_ORDER);</span>
<span class="p_del">-	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -746,11 +778,10 @@</span> <span class="p_context"> void kvm_free_stage2_pgd(struct kvm *kvm)</span>
 		return;
 
 	unmap_stage2_range(kvm, 0, KVM_PHYS_SIZE);
<span class="p_del">-	kvm_free_hwpgd(kvm);</span>
<span class="p_add">+	kvm_free_hwpgd(kvm_get_hwpgd(kvm));</span>
 	if (KVM_PREALLOC_LEVEL &gt; 0)
 		kfree(kvm-&gt;arch.pgd);
<span class="p_del">-	else</span>
<span class="p_del">-		free_pages((unsigned long)kvm-&gt;arch.pgd, S2_PGD_ORDER);</span>
<span class="p_add">+</span>
 	kvm-&gt;arch.pgd = NULL;
 }
 
<span class="p_chunk">@@ -760,7 +791,7 @@</span> <span class="p_context"> static pud_t *stage2_get_pud(struct kvm *kvm, struct kvm_mmu_memory_cache *cache</span>
 	pgd_t *pgd;
 	pud_t *pud;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	if (WARN_ON(pgd_none(*pgd))) {
 		if (!cache)
 			return NULL;
<span class="p_header">diff --git a/arch/arm/mach-mvebu/pmsu.c b/arch/arm/mach-mvebu/pmsu.c</span>
<span class="p_header">index d8ab605a44fa..e8ba3c692527 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/pmsu.c</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/pmsu.c</span>
<span class="p_chunk">@@ -415,6 +415,9 @@</span> <span class="p_context"> static __init int armada_38x_cpuidle_init(void)</span>
 	void __iomem *mpsoc_base;
 	u32 reg;
 
<span class="p_add">+	pr_warn(&quot;CPU idle is currently broken on Armada 38x: disabling&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
 	np = of_find_compatible_node(NULL, NULL,
 				     &quot;marvell,armada-380-coherency-fabric&quot;);
 	if (!np)
<span class="p_chunk">@@ -476,6 +479,16 @@</span> <span class="p_context"> static int __init mvebu_v7_cpu_pm_init(void)</span>
 		return 0;
 	of_node_put(np);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Currently the CPU idle support for Armada 38x is broken, as</span>
<span class="p_add">+	 * the CPU hotplug uses some of the CPU idle functions it is</span>
<span class="p_add">+	 * broken too, so let&#39;s disable it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (of_machine_is_compatible(&quot;marvell,armada380&quot;)) {</span>
<span class="p_add">+		cpu_hotplug_disable();</span>
<span class="p_add">+		pr_warn(&quot;CPU hotplug support is currently broken on Armada 38x: disabling&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (of_machine_is_compatible(&quot;marvell,armadaxp&quot;))
 		ret = armada_xp_cpuidle_init();
 	else if (of_machine_is_compatible(&quot;marvell,armada370&quot;))
<span class="p_chunk">@@ -489,7 +502,8 @@</span> <span class="p_context"> static int __init mvebu_v7_cpu_pm_init(void)</span>
 		return ret;
 
 	mvebu_v7_pmsu_enable_l2_powerdown_onidle();
<span class="p_del">-	platform_device_register(&amp;mvebu_v7_cpuidle_device);</span>
<span class="p_add">+	if (mvebu_v7_cpuidle_device.name)</span>
<span class="p_add">+		platform_device_register(&amp;mvebu_v7_cpuidle_device);</span>
 	cpu_pm_register_notifier(&amp;mvebu_v7_cpu_pm_notifier);
 
 	return 0;
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">index 7bc66682687e..dcbe17f5e5f8 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;mach/gpio-samsung.h&gt;
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
<span class="p_add">+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)</span>
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">index 10b913baab28..65c426bc45f7 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_chunk">@@ -554,6 +554,7 @@</span> <span class="p_context"> static struct wm831x_touch_pdata touch_pdata = {</span>
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
<span class="p_add">+	.irq_base = BANFF_PMIC_IRQ_BASE,</span>
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index b1f9a20a3677..840c232dd456 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -306,6 +306,27 @@</span> <span class="p_context"> config ARM64_ERRATUM_832075</span>
 
 	  If unsure, say Y.
 
<span class="p_add">+config ARM64_ERRATUM_845719</span>
<span class="p_add">+	bool &quot;Cortex-A53: 845719: a load might read incorrect data&quot;</span>
<span class="p_add">+	depends on COMPAT</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This option adds an alternative code sequence to work around ARM</span>
<span class="p_add">+	  erratum 845719 on Cortex-A53 parts up to r0p4.</span>
<span class="p_add">+</span>
<span class="p_add">+	  When running a compat (AArch32) userspace on an affected Cortex-A53</span>
<span class="p_add">+	  part, a load at EL0 from a virtual address that matches the bottom 32</span>
<span class="p_add">+	  bits of the virtual address used by a recent load at (AArch64) EL1</span>
<span class="p_add">+	  might return incorrect data.</span>
<span class="p_add">+</span>
<span class="p_add">+	  The workaround is to write the contextidr_el1 register on exception</span>
<span class="p_add">+	  return to a 32-bit task.</span>
<span class="p_add">+	  Please note that this does not necessarily enable the workaround,</span>
<span class="p_add">+	  as it depends on the alternative framework, which will only patch</span>
<span class="p_add">+	  the kernel if an affected CPU is detected.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
 endmenu
 
 
<span class="p_chunk">@@ -416,6 +437,10 @@</span> <span class="p_context"> config HOTPLUG_CPU</span>
 
 source kernel/Kconfig.preempt
 
<span class="p_add">+config UP_LATE_INIT</span>
<span class="p_add">+       def_bool y</span>
<span class="p_add">+       depends on !SMP</span>
<span class="p_add">+</span>
 config HZ
 	int
 	default 100
<span class="p_header">diff --git a/arch/arm64/include/asm/cpufeature.h b/arch/arm64/include/asm/cpufeature.h</span>
<span class="p_header">index 07547ccc1f2b..5fe4befda1a5 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/cpufeature.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/cpufeature.h</span>
<span class="p_chunk">@@ -23,8 +23,9 @@</span> <span class="p_context"></span>
 
 #define ARM64_WORKAROUND_CLEAN_CACHE		0
 #define ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE	1
<span class="p_add">+#define ARM64_WORKAROUND_845719			2</span>
 
<span class="p_del">-#define ARM64_NCAPS				2</span>
<span class="p_add">+#define ARM64_NCAPS				3</span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index adcf49547301..df150ae862f2 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -137,6 +137,8 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 #define PTRS_PER_S2_PGD		(1 &lt;&lt; PTRS_PER_S2_PGD_SHIFT)
 #define S2_PGD_ORDER		get_order(PTRS_PER_S2_PGD * sizeof(pgd_t))
 
<span class="p_add">+#define kvm_pgd_index(addr)	(((addr) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_S2_PGD - 1))</span>
<span class="p_add">+</span>
 /*
  * If we are concatenating first level stage-2 page tables, we would have less
  * than or equal to 16 pointers in the fake PGD, because that&#39;s what the
<span class="p_chunk">@@ -150,43 +152,6 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 #define KVM_PREALLOC_LEVEL	(0)
 #endif
 
<span class="p_del">-/**</span>
<span class="p_del">- * kvm_prealloc_hwpgd - allocate inital table for VTTBR</span>
<span class="p_del">- * @kvm:	The KVM struct pointer for the VM.</span>
<span class="p_del">- * @pgd:	The kernel pseudo pgd</span>
<span class="p_del">- *</span>
<span class="p_del">- * When the kernel uses more levels of page tables than the guest, we allocate</span>
<span class="p_del">- * a fake PGD and pre-populate it to point to the next-level page table, which</span>
<span class="p_del">- * will be the real initial page table pointed to by the VTTBR.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When KVM_PREALLOC_LEVEL==2, we allocate a single page for the PMD and</span>
<span class="p_del">- * the kernel will use folded pud.  When KVM_PREALLOC_LEVEL==1, we</span>
<span class="p_del">- * allocate 2 consecutive PUD pages.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int kvm_prealloc_hwpgd(struct kvm *kvm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	unsigned long hwpgd;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (KVM_PREALLOC_LEVEL == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	hwpgd = __get_free_pages(GFP_KERNEL | __GFP_ZERO, PTRS_PER_S2_PGD_SHIFT);</span>
<span class="p_del">-	if (!hwpgd)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; PTRS_PER_S2_PGD; i++) {</span>
<span class="p_del">-		if (KVM_PREALLOC_LEVEL == 1)</span>
<span class="p_del">-			pgd_populate(NULL, pgd + i,</span>
<span class="p_del">-				     (pud_t *)hwpgd + i * PTRS_PER_PUD);</span>
<span class="p_del">-		else if (KVM_PREALLOC_LEVEL == 2)</span>
<span class="p_del">-			pud_populate(NULL, pud_offset(pgd, 0) + i,</span>
<span class="p_del">-				     (pmd_t *)hwpgd + i * PTRS_PER_PMD);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void *kvm_get_hwpgd(struct kvm *kvm)
 {
 	pgd_t *pgd = kvm-&gt;arch.pgd;
<span class="p_chunk">@@ -203,12 +168,11 @@</span> <span class="p_context"> static inline void *kvm_get_hwpgd(struct kvm *kvm)</span>
 	return pmd_offset(pud, 0);
 }
 
<span class="p_del">-static inline void kvm_free_hwpgd(struct kvm *kvm)</span>
<span class="p_add">+static inline unsigned int kvm_get_hwpgd_size(void)</span>
 {
<span class="p_del">-	if (KVM_PREALLOC_LEVEL &gt; 0) {</span>
<span class="p_del">-		unsigned long hwpgd = (unsigned long)kvm_get_hwpgd(kvm);</span>
<span class="p_del">-		free_pages(hwpgd, PTRS_PER_S2_PGD_SHIFT);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (KVM_PREALLOC_LEVEL &gt; 0)</span>
<span class="p_add">+		return PTRS_PER_S2_PGD * PAGE_SIZE;</span>
<span class="p_add">+	return PTRS_PER_S2_PGD * sizeof(pgd_t);</span>
 }
 
 static inline bool kvm_page_empty(void *ptr)
<span class="p_header">diff --git a/arch/arm64/include/asm/smp_plat.h b/arch/arm64/include/asm/smp_plat.h</span>
<span class="p_header">index 59e282311b58..8dcd61e32176 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/smp_plat.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/smp_plat.h</span>
<span class="p_chunk">@@ -40,4 +40,6 @@</span> <span class="p_context"> static inline u32 mpidr_hash_size(void)</span>
 extern u64 __cpu_logical_map[NR_CPUS];
 #define cpu_logical_map(cpu)    __cpu_logical_map[cpu]
 
<span class="p_add">+void __init do_post_cpus_up_work(void);</span>
<span class="p_add">+</span>
 #endif /* __ASM_SMP_PLAT_H */
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/kvm.h b/arch/arm64/include/uapi/asm/kvm.h</span>
<span class="p_header">index 8e38878c87c6..d9e9822efcee 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/kvm.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -179,8 +179,14 @@</span> <span class="p_context"> struct kvm_arch_memory_slot {</span>
 #define KVM_ARM_IRQ_CPU_IRQ		0
 #define KVM_ARM_IRQ_CPU_FIQ		1
 
<span class="p_del">-/* Highest supported SPI, from VGIC_NR_IRQS */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This used to hold the highest supported SPI, but it is now obsolete</span>
<span class="p_add">+ * and only here to provide source code level compatibility with older</span>
<span class="p_add">+ * userland. The highest SPI number can be set via KVM_DEV_ARM_VGIC_GRP_NR_IRQS.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __KERNEL__</span>
 #define KVM_ARM_IRQ_GIC_MAX		127
<span class="p_add">+#endif</span>
 
 /* PSCI interface */
 #define KVM_PSCI_FN_BASE		0x95c1ba5e
<span class="p_header">diff --git a/arch/arm64/kernel/cpu_errata.c b/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_header">index fa62637e63a8..ad6d52392bb1 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_chunk">@@ -88,7 +88,16 @@</span> <span class="p_context"> struct arm64_cpu_capabilities arm64_errata[] = {</span>
 	/* Cortex-A57 r0p0 - r1p2 */
 		.desc = &quot;ARM erratum 832075&quot;,
 		.capability = ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE,
<span class="p_del">-		MIDR_RANGE(MIDR_CORTEX_A57, 0x00, 0x12),</span>
<span class="p_add">+		MIDR_RANGE(MIDR_CORTEX_A57, 0x00,</span>
<span class="p_add">+			   (1 &lt;&lt; MIDR_VARIANT_SHIFT) | 2),</span>
<span class="p_add">+	},</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_ARM64_ERRATUM_845719</span>
<span class="p_add">+	{</span>
<span class="p_add">+	/* Cortex-A53 r0p[01234] */</span>
<span class="p_add">+		.desc = &quot;ARM erratum 845719&quot;,</span>
<span class="p_add">+		.capability = ARM64_WORKAROUND_845719,</span>
<span class="p_add">+		MIDR_RANGE(MIDR_CORTEX_A53, 0x00, 0x04),</span>
 	},
 #endif
 	{
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index fd4fa374e5d2..9b870a2815e6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -21,8 +21,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/linkage.h&gt;
 
<span class="p_add">+#include &lt;asm/alternative-asm.h&gt;</span>
 #include &lt;asm/assembler.h&gt;
 #include &lt;asm/asm-offsets.h&gt;
<span class="p_add">+#include &lt;asm/cpufeature.h&gt;</span>
 #include &lt;asm/errno.h&gt;
 #include &lt;asm/esr.h&gt;
 #include &lt;asm/thread_info.h&gt;
<span class="p_chunk">@@ -120,6 +122,24 @@</span> <span class="p_context"></span>
 	ct_user_enter
 	ldr	x23, [sp, #S_SP]		// load return stack pointer
 	msr	sp_el0, x23
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ARM64_ERRATUM_845719</span>
<span class="p_add">+	alternative_insn						\</span>
<span class="p_add">+	&quot;nop&quot;,								\</span>
<span class="p_add">+	&quot;tbz x22, #4, 1f&quot;,						\</span>
<span class="p_add">+	ARM64_WORKAROUND_845719</span>
<span class="p_add">+#ifdef CONFIG_PID_IN_CONTEXTIDR</span>
<span class="p_add">+	alternative_insn						\</span>
<span class="p_add">+	&quot;nop; nop&quot;,							\</span>
<span class="p_add">+	&quot;mrs x29, contextidr_el1; msr contextidr_el1, x29; 1:&quot;,		\</span>
<span class="p_add">+	ARM64_WORKAROUND_845719</span>
<span class="p_add">+#else</span>
<span class="p_add">+	alternative_insn						\</span>
<span class="p_add">+	&quot;nop&quot;,								\</span>
<span class="p_add">+	&quot;msr contextidr_el1, xzr; 1:&quot;,					\</span>
<span class="p_add">+	ARM64_WORKAROUND_845719</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#endif</span>
 	.endif
 	msr	elr_el1, x21			// set up the return data
 	msr	spsr_el1, x22
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 8ce88e08c030..98af7da1b8b5 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -426,6 +426,7 @@</span> <span class="p_context"> __create_page_tables:</span>
 	 */
 	mov	x0, x25
 	add	x1, x26, #SWAPPER_DIR_SIZE
<span class="p_add">+	dmb	sy</span>
 	bl	__inval_cache_range
 
 	mov	lr, x27
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index 20fe2932ad0c..79fedd8dbdd7 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -206,6 +206,18 @@</span> <span class="p_context"> static void __init smp_build_mpidr_hash(void)</span>
 }
 #endif
 
<span class="p_add">+void __init do_post_cpus_up_work(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	apply_alternatives_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_UP_LATE_INIT</span>
<span class="p_add">+void __init up_late_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	do_post_cpus_up_work();</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_UP_LATE_INIT */</span>
<span class="p_add">+</span>
 static void __init setup_processor(void)
 {
 	struct cpu_info *cpu_info;
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 7ae6ee085261..e1b857fa2a1d 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -310,7 +310,7 @@</span> <span class="p_context"> void cpu_die(void)</span>
 void __init smp_cpus_done(unsigned int max_cpus)
 {
 	pr_info(&quot;SMP: Total of %d processors activated.\n&quot;, num_online_cpus());
<span class="p_del">-	apply_alternatives_all();</span>
<span class="p_add">+	do_post_cpus_up_work();</span>
 }
 
 void __init smp_prepare_boot_cpu(void)
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84cad95..04845aaf5985 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/include/asm/asm-eva.h b/arch/mips/include/asm/asm-eva.h</span>
<span class="p_header">index e41c56e375b1..1e38f0e1ea3e 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/asm-eva.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/asm-eva.h</span>
<span class="p_chunk">@@ -11,6 +11,36 @@</span> <span class="p_context"></span>
 #define __ASM_ASM_EVA_H
 
 #ifndef __ASSEMBLY__
<span class="p_add">+</span>
<span class="p_add">+/* Kernel variants */</span>
<span class="p_add">+</span>
<span class="p_add">+#define kernel_cache(op, base)		&quot;cache &quot; op &quot;, &quot; base &quot;\n&quot;</span>
<span class="p_add">+#define kernel_ll(reg, addr)		&quot;ll &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sc(reg, addr)		&quot;sc &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lw(reg, addr)		&quot;lw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lwl(reg, addr)		&quot;lwl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lwr(reg, addr)		&quot;lwr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lh(reg, addr)		&quot;lh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lb(reg, addr)		&quot;lb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_lbu(reg, addr)		&quot;lbu &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sw(reg, addr)		&quot;sw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_swl(reg, addr)		&quot;swl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_swr(reg, addr)		&quot;swr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sh(reg, addr)		&quot;sh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_sb(reg, addr)		&quot;sb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_32BIT</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_add">+ * do the correct thing</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define kernel_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_add">+#define kernel_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define kernel_sd(reg, addr)		&quot;sd &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define kernel_ld(reg, addr)		&quot;ld &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#endif /* CONFIG_32BIT */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_EVA
 
 #define __BUILD_EVA_INSN(insn, reg, addr)				\
<span class="p_chunk">@@ -41,37 +71,60 @@</span> <span class="p_context"></span>
 
 #else
 
<span class="p_del">-#define user_cache(op, base)		&quot;cache &quot; op &quot;, &quot; base &quot;\n&quot;</span>
<span class="p_del">-#define user_ll(reg, addr)		&quot;ll &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sc(reg, addr)		&quot;sc &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lw(reg, addr)		&quot;lw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lwl(reg, addr)		&quot;lwl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lwr(reg, addr)		&quot;lwr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lh(reg, addr)		&quot;lh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lb(reg, addr)		&quot;lb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_lbu(reg, addr)		&quot;lbu &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sw(reg, addr)		&quot;sw &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_swl(reg, addr)		&quot;swl &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_swr(reg, addr)		&quot;swr &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sh(reg, addr)		&quot;sh &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_sb(reg, addr)		&quot;sb &quot; reg &quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define user_cache(op, base)		kernel_cache(op, base)</span>
<span class="p_add">+#define user_ll(reg, addr)		kernel_ll(reg, addr)</span>
<span class="p_add">+#define user_sc(reg, addr)		kernel_sc(reg, addr)</span>
<span class="p_add">+#define user_lw(reg, addr)		kernel_lw(reg, addr)</span>
<span class="p_add">+#define user_lwl(reg, addr)		kernel_lwl(reg, addr)</span>
<span class="p_add">+#define user_lwr(reg, addr)		kernel_lwr(reg, addr)</span>
<span class="p_add">+#define user_lh(reg, addr)		kernel_lh(reg, addr)</span>
<span class="p_add">+#define user_lb(reg, addr)		kernel_lb(reg, addr)</span>
<span class="p_add">+#define user_lbu(reg, addr)		kernel_lbu(reg, addr)</span>
<span class="p_add">+#define user_sw(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_swl(reg, addr)		kernel_swl(reg, addr)</span>
<span class="p_add">+#define user_swr(reg, addr)		kernel_swr(reg, addr)</span>
<span class="p_add">+#define user_sh(reg, addr)		kernel_sh(reg, addr)</span>
<span class="p_add">+#define user_sb(reg, addr)		kernel_sb(reg, addr)</span>
 
 #ifdef CONFIG_32BIT
<span class="p_del">-/*</span>
<span class="p_del">- * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_del">- * do the correct thing</span>
<span class="p_del">- */</span>
<span class="p_del">-#define user_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_del">-#define user_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_lw(reg, addr)</span>
 #else
<span class="p_del">-#define user_sd(reg, addr)		&quot;sd &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_del">-#define user_ld(reg, addr)		&quot;ld &quot; reg&quot;, &quot; addr &quot;\n&quot;</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sd(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_ld(reg, addr)</span>
 #endif /* CONFIG_32BIT */
 
 #endif /* CONFIG_EVA */
 
 #else /* __ASSEMBLY__ */
 
<span class="p_add">+#define kernel_cache(op, base)		cache op, base</span>
<span class="p_add">+#define kernel_ll(reg, addr)		ll reg, addr</span>
<span class="p_add">+#define kernel_sc(reg, addr)		sc reg, addr</span>
<span class="p_add">+#define kernel_lw(reg, addr)		lw reg, addr</span>
<span class="p_add">+#define kernel_lwl(reg, addr)		lwl reg, addr</span>
<span class="p_add">+#define kernel_lwr(reg, addr)		lwr reg, addr</span>
<span class="p_add">+#define kernel_lh(reg, addr)		lh reg, addr</span>
<span class="p_add">+#define kernel_lb(reg, addr)		lb reg, addr</span>
<span class="p_add">+#define kernel_lbu(reg, addr)		lbu reg, addr</span>
<span class="p_add">+#define kernel_sw(reg, addr)		sw reg, addr</span>
<span class="p_add">+#define kernel_swl(reg, addr)		swl reg, addr</span>
<span class="p_add">+#define kernel_swr(reg, addr)		swr reg, addr</span>
<span class="p_add">+#define kernel_sh(reg, addr)		sh reg, addr</span>
<span class="p_add">+#define kernel_sb(reg, addr)		sb reg, addr</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_32BIT</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_add">+ * do the correct thing</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define kernel_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_add">+#define kernel_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define kernel_sd(reg, addr)		sd reg, addr</span>
<span class="p_add">+#define kernel_ld(reg, addr)		ld reg, addr</span>
<span class="p_add">+#endif /* CONFIG_32BIT */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_EVA
 
 #define __BUILD_EVA_INSN(insn, reg, addr)			\
<span class="p_chunk">@@ -101,31 +154,27 @@</span> <span class="p_context"></span>
 #define user_sd(reg, addr)		user_sw(reg, addr)
 #else
 
<span class="p_del">-#define user_cache(op, base)		cache op, base</span>
<span class="p_del">-#define user_ll(reg, addr)		ll reg, addr</span>
<span class="p_del">-#define user_sc(reg, addr)		sc reg, addr</span>
<span class="p_del">-#define user_lw(reg, addr)		lw reg, addr</span>
<span class="p_del">-#define user_lwl(reg, addr)		lwl reg, addr</span>
<span class="p_del">-#define user_lwr(reg, addr)		lwr reg, addr</span>
<span class="p_del">-#define user_lh(reg, addr)		lh reg, addr</span>
<span class="p_del">-#define user_lb(reg, addr)		lb reg, addr</span>
<span class="p_del">-#define user_lbu(reg, addr)		lbu reg, addr</span>
<span class="p_del">-#define user_sw(reg, addr)		sw reg, addr</span>
<span class="p_del">-#define user_swl(reg, addr)		swl reg, addr</span>
<span class="p_del">-#define user_swr(reg, addr)		swr reg, addr</span>
<span class="p_del">-#define user_sh(reg, addr)		sh reg, addr</span>
<span class="p_del">-#define user_sb(reg, addr)		sb reg, addr</span>
<span class="p_add">+#define user_cache(op, base)		kernel_cache(op, base)</span>
<span class="p_add">+#define user_ll(reg, addr)		kernel_ll(reg, addr)</span>
<span class="p_add">+#define user_sc(reg, addr)		kernel_sc(reg, addr)</span>
<span class="p_add">+#define user_lw(reg, addr)		kernel_lw(reg, addr)</span>
<span class="p_add">+#define user_lwl(reg, addr)		kernel_lwl(reg, addr)</span>
<span class="p_add">+#define user_lwr(reg, addr)		kernel_lwr(reg, addr)</span>
<span class="p_add">+#define user_lh(reg, addr)		kernel_lh(reg, addr)</span>
<span class="p_add">+#define user_lb(reg, addr)		kernel_lb(reg, addr)</span>
<span class="p_add">+#define user_lbu(reg, addr)		kernel_lbu(reg, addr)</span>
<span class="p_add">+#define user_sw(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_swl(reg, addr)		kernel_swl(reg, addr)</span>
<span class="p_add">+#define user_swr(reg, addr)		kernel_swr(reg, addr)</span>
<span class="p_add">+#define user_sh(reg, addr)		kernel_sh(reg, addr)</span>
<span class="p_add">+#define user_sb(reg, addr)		kernel_sb(reg, addr)</span>
 
 #ifdef CONFIG_32BIT
<span class="p_del">-/*</span>
<span class="p_del">- * No &#39;sd&#39; or &#39;ld&#39; instructions in 32-bit but the code will</span>
<span class="p_del">- * do the correct thing</span>
<span class="p_del">- */</span>
<span class="p_del">-#define user_sd(reg, addr)		user_sw(reg, addr)</span>
<span class="p_del">-#define user_ld(reg, addr)		user_lw(reg, addr)</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sw(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_lw(reg, addr)</span>
 #else
<span class="p_del">-#define user_sd(reg, addr)		sd reg, addr</span>
<span class="p_del">-#define user_ld(reg, addr)		ld reg, addr</span>
<span class="p_add">+#define user_sd(reg, addr)		kernel_sd(reg, addr)</span>
<span class="p_add">+#define user_ld(reg, addr)		kernel_sd(reg, addr)</span>
 #endif /* CONFIG_32BIT */
 
 #endif /* CONFIG_EVA */
<span class="p_header">diff --git a/arch/mips/include/asm/fpu.h b/arch/mips/include/asm/fpu.h</span>
<span class="p_header">index affebb78f5d6..270ecc148443 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/fpu.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/fpu.h</span>
<span class="p_chunk">@@ -169,6 +169,7 @@</span> <span class="p_context"> static inline void lose_fpu(int save)</span>
 		}
 		disable_msa();
 		clear_thread_flag(TIF_USEDMSA);
<span class="p_add">+		__disable_fpu();</span>
 	} else if (is_fpu_owner()) {
 		if (save)
 			_save_fp(current);
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index f2c249796ea8..4e3205a3bee2 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> enum mips_mmu_types {</span>
 #define T_TRAP			13	/* Trap instruction */
 #define T_VCEI			14	/* Virtual coherency exception */
 #define T_FPE			15	/* Floating point exception */
<span class="p_add">+#define T_MSADIS		21	/* MSA disabled exception */</span>
 #define T_WATCH			23	/* Watch address reference */
 #define T_VCED			31	/* Virtual coherency data */
 
<span class="p_chunk">@@ -577,6 +578,7 @@</span> <span class="p_context"> struct kvm_mips_callbacks {</span>
 	int (*handle_syscall)(struct kvm_vcpu *vcpu);
 	int (*handle_res_inst)(struct kvm_vcpu *vcpu);
 	int (*handle_break)(struct kvm_vcpu *vcpu);
<span class="p_add">+	int (*handle_msa_disabled)(struct kvm_vcpu *vcpu);</span>
 	int (*vm_init)(struct kvm *kvm);
 	int (*vcpu_init)(struct kvm_vcpu *vcpu);
 	int (*vcpu_setup)(struct kvm_vcpu *vcpu);
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index fb3e8dfd1ff6..838d3a6a5b7d 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -2176,6 +2176,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_check_privilege(unsigned long cause,</span>
 		case T_SYSCALL:
 		case T_BREAK:
 		case T_RES_INST:
<span class="p_add">+		case T_MSADIS:</span>
 			break;
 
 		case T_COP_UNUSABLE:
<span class="p_header">diff --git a/arch/mips/kvm/mips.c b/arch/mips/kvm/mips.c</span>
<span class="p_header">index 270bbd41769e..39074fb83bad 100644</span>
<span class="p_header">--- a/arch/mips/kvm/mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/mips.c</span>
<span class="p_chunk">@@ -1119,6 +1119,10 @@</span> <span class="p_context"> int kvm_mips_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 		ret = kvm_mips_callbacks-&gt;handle_break(vcpu);
 		break;
 
<span class="p_add">+	case T_MSADIS:</span>
<span class="p_add">+		ret = kvm_mips_callbacks-&gt;handle_msa_disabled(vcpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	default:
 		kvm_err(&quot;Exception Code: %d, not yet handled, @ PC: %p, inst: 0x%08x  BadVaddr: %#lx Status: %#lx\n&quot;,
 			exccode, opc, kvm_get_inst(opc, vcpu), badvaddr,
<span class="p_header">diff --git a/arch/mips/kvm/trap_emul.c b/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">index fd7257b70e65..4372cc86650c 100644</span>
<span class="p_header">--- a/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/trap_emul.c</span>
<span class="p_chunk">@@ -330,6 +330,33 @@</span> <span class="p_context"> static int kvm_trap_emul_handle_break(struct kvm_vcpu *vcpu)</span>
 	return ret;
 }
 
<span class="p_add">+static int kvm_trap_emul_handle_msa_disabled(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_run *run = vcpu-&gt;run;</span>
<span class="p_add">+	uint32_t __user *opc = (uint32_t __user *) vcpu-&gt;arch.pc;</span>
<span class="p_add">+	unsigned long cause = vcpu-&gt;arch.host_cp0_cause;</span>
<span class="p_add">+	enum emulation_result er = EMULATE_DONE;</span>
<span class="p_add">+	int ret = RESUME_GUEST;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No MSA supported in guest, guest reserved instruction exception */</span>
<span class="p_add">+	er = kvm_mips_emulate_ri_exc(cause, opc, run, vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (er) {</span>
<span class="p_add">+	case EMULATE_DONE:</span>
<span class="p_add">+		ret = RESUME_GUEST;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case EMULATE_FAIL:</span>
<span class="p_add">+		run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;</span>
<span class="p_add">+		ret = RESUME_HOST;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int kvm_trap_emul_vm_init(struct kvm *kvm)
 {
 	return 0;
<span class="p_chunk">@@ -470,6 +497,7 @@</span> <span class="p_context"> static struct kvm_mips_callbacks kvm_trap_emul_callbacks = {</span>
 	.handle_syscall = kvm_trap_emul_handle_syscall,
 	.handle_res_inst = kvm_trap_emul_handle_res_inst,
 	.handle_break = kvm_trap_emul_handle_break,
<span class="p_add">+	.handle_msa_disabled = kvm_trap_emul_handle_msa_disabled,</span>
 
 	.vm_init = kvm_trap_emul_vm_init,
 	.vcpu_init = kvm_trap_emul_vcpu_init,
<span class="p_header">diff --git a/arch/mips/loongson/loongson-3/irq.c b/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_header">index 21221edda7a9..0f75b6b3d218 100644</span>
<span class="p_header">--- a/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_header">+++ b/arch/mips/loongson/loongson-3/irq.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"> void mach_irq_dispatch(unsigned int pending)</span>
 
 static struct irqaction cascade_irqaction = {
 	.handler = no_action,
<span class="p_add">+	.flags = IRQF_NO_SUSPEND,</span>
 	.name = &quot;cascade&quot;,
 };
 
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-memory.c b/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_header">index 8fddd2cdbff7..efe366d618b1 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-memory.c</span>
<span class="p_chunk">@@ -53,6 +53,12 @@</span> <span class="p_context"> fw_memblock_t * __init fw_getmdesc(int eva)</span>
 		pr_warn(&quot;memsize not set in YAMON, set to default (32Mb)\n&quot;);
 		physical_memsize = 0x02000000;
 	} else {
<span class="p_add">+		if (memsize &gt; (256 &lt;&lt; 20)) { /* memsize should be capped to 256M */</span>
<span class="p_add">+			pr_warn(&quot;Unsupported memsize value (0x%lx) detected! &quot;</span>
<span class="p_add">+				&quot;Using 0x10000000 (256M) instead\n&quot;,</span>
<span class="p_add">+				memsize);</span>
<span class="p_add">+			memsize = 256 &lt;&lt; 20;</span>
<span class="p_add">+		}</span>
 		/* If ememsize is set, then set physical_memsize to that */
 		physical_memsize = ememsize ? : memsize;
 	}
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 32a7c828f073..e7567c8a9e79 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -43,7 +45,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index 40198d50b4c2..8005b79ecbcf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -61,12 +61,22 @@</span> <span class="p_context"> struct cache_type_info {</span>
 };
 
 /* These are used to index the cache_type_info array. */
<span class="p_del">-#define CACHE_TYPE_UNIFIED     0</span>
<span class="p_del">-#define CACHE_TYPE_INSTRUCTION 1</span>
<span class="p_del">-#define CACHE_TYPE_DATA        2</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED     0 /* cache-size, cache-block-size, etc. */</span>
<span class="p_add">+#define CACHE_TYPE_UNIFIED_D   1 /* d-cache-size, d-cache-block-size, etc */</span>
<span class="p_add">+#define CACHE_TYPE_INSTRUCTION 2</span>
<span class="p_add">+#define CACHE_TYPE_DATA        3</span>
 
 static const struct cache_type_info cache_type_info[] = {
 	{
<span class="p_add">+		/* Embedded systems that use cache-size, cache-block-size,</span>
<span class="p_add">+		 * etc. for the Unified (typically L2) cache. */</span>
<span class="p_add">+		.name            = &quot;Unified&quot;,</span>
<span class="p_add">+		.size_prop       = &quot;cache-size&quot;,</span>
<span class="p_add">+		.line_size_props = { &quot;cache-line-size&quot;,</span>
<span class="p_add">+				     &quot;cache-block-size&quot;, },</span>
<span class="p_add">+		.nr_sets_prop    = &quot;cache-sets&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* PowerPC Processor binding says the [di]-cache-*
 		 * must be equal on unified caches, so just use
 		 * d-cache properties. */
<span class="p_chunk">@@ -293,7 +303,8 @@</span> <span class="p_context"> static struct cache *cache_find_first_sibling(struct cache *cache)</span>
 {
 	struct cache *iter;
 
<span class="p_del">-	if (cache-&gt;type == CACHE_TYPE_UNIFIED)</span>
<span class="p_add">+	if (cache-&gt;type == CACHE_TYPE_UNIFIED ||</span>
<span class="p_add">+	    cache-&gt;type == CACHE_TYPE_UNIFIED_D)</span>
 		return cache;
 
 	list_for_each_entry(iter, &amp;cache_list, list)
<span class="p_chunk">@@ -324,16 +335,29 @@</span> <span class="p_context"> static bool cache_node_is_unified(const struct device_node *np)</span>
 	return of_get_property(np, &quot;cache-unified&quot;, NULL);
 }
 
<span class="p_del">-static struct cache *cache_do_one_devnode_unified(struct device_node *node,</span>
<span class="p_del">-						  int level)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Unified caches can have two different sets of tags.  Most embedded</span>
<span class="p_add">+ * use cache-size, etc. for the unified cache size, but open firmware systems</span>
<span class="p_add">+ * use d-cache-size, etc.   Check on initialization for which type we have, and</span>
<span class="p_add">+ * return the appropriate structure type.  Assume it&#39;s embedded if it isn&#39;t</span>
<span class="p_add">+ * open firmware.  If it&#39;s yet a 3rd type, then there will be missing entries</span>
<span class="p_add">+ * in /sys/devices/system/cpu/cpu0/cache/index2/, and this code will need</span>
<span class="p_add">+ * to be extended further.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int cache_is_unified_d(const struct device_node *np)</span>
 {
<span class="p_del">-	struct cache *cache;</span>
<span class="p_add">+	return of_get_property(np,</span>
<span class="p_add">+		cache_type_info[CACHE_TYPE_UNIFIED_D].size_prop, NULL) ?</span>
<span class="p_add">+		CACHE_TYPE_UNIFIED_D : CACHE_TYPE_UNIFIED;</span>
<span class="p_add">+}</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct cache *cache_do_one_devnode_unified(struct device_node *node, int level)</span>
<span class="p_add">+{</span>
 	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);
 
<span class="p_del">-	cache = new_cache(CACHE_TYPE_UNIFIED, level, node);</span>
<span class="p_del">-</span>
<span class="p_del">-	return cache;</span>
<span class="p_add">+	return new_cache(cache_is_unified_d(node), level, node);</span>
 }
 
 static struct cache *cache_do_one_devnode_split(struct device_node *node,
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index 2396dda282cd..ead55351b254 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/interrupt.c b/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_header">index 4c11421847be..3af8324c122e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> static unsigned int iic_get_irq(void)</span>
 
 void iic_setup_cpu(void)
 {
<span class="p_del">-	out_be64(this_cpu_ptr(&amp;cpu_iic.regs-&gt;prio), 0xff);</span>
<span class="p_add">+	out_be64(&amp;this_cpu_ptr(&amp;cpu_iic)-&gt;regs-&gt;prio, 0xff);</span>
 }
 
 u8 iic_get_target_id(int cpu)
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">index c7c8720aa39f..63db1b03e756 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_chunk">@@ -197,7 +197,7 @@</span> <span class="p_context"> static int tce_build_cell(struct iommu_table *tbl, long index, long npages,</span>
 
 	io_pte = (unsigned long *)tbl-&gt;it_base + (index - tbl-&gt;it_offset);
 
<span class="p_del">-	for (i = 0; i &lt; npages; i++, uaddr += tbl-&gt;it_page_shift)</span>
<span class="p_add">+	for (i = 0; i &lt; npages; i++, uaddr += (1 &lt;&lt; tbl-&gt;it_page_shift))</span>
 		io_pte[i] = base_pte | (__pa(uaddr) &amp; CBE_IOPTE_RPN_Mask);
 
 	mb();
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 6a9a255d8058..2578b148ddc4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -1750,7 +1750,8 @@</span> <span class="p_context"> static void pnv_ioda_setup_pe_seg(struct pci_controller *hose,</span>
 				region.start += phb-&gt;ioda.io_segsize;
 				index++;
 			}
<span class="p_del">-		} else if (res-&gt;flags &amp; IORESOURCE_MEM) {</span>
<span class="p_add">+		} else if ((res-&gt;flags &amp; IORESOURCE_MEM) &amp;&amp;</span>
<span class="p_add">+			   !pnv_pci_is_mem_pref_64(res-&gt;flags)) {</span>
 			region.start = res-&gt;start -
 				       hose-&gt;mem_offset[0] -
 				       phb-&gt;ioda.m32_pci_base;
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index 1c4c5accd220..d3236c9e226b 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -138,6 +138,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -145,6 +147,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.c</span>
<span class="p_header">index f512cffbf84e..07da75c385e6 100644</span>
<span class="p_header">--- a/arch/s390/kvm/interrupt.c</span>
<span class="p_header">+++ b/arch/s390/kvm/interrupt.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/signal.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/bitmap.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 #include &lt;asm/asm-offsets.h&gt;
 #include &lt;asm/uaccess.h&gt;
 #include &quot;kvm-s390.h&quot;
<span class="p_chunk">@@ -1131,7 +1132,6 @@</span> <span class="p_context"> struct kvm_s390_interrupt_info *kvm_s390_get_io_int(struct kvm *kvm,</span>
 
 	if ((!schid &amp;&amp; !cr6) || (schid &amp;&amp; cr6))
 		return NULL;
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
 	fi = &amp;kvm-&gt;arch.float_int;
 	spin_lock(&amp;fi-&gt;lock);
 	inti = NULL;
<span class="p_chunk">@@ -1159,7 +1159,6 @@</span> <span class="p_context"> struct kvm_s390_interrupt_info *kvm_s390_get_io_int(struct kvm *kvm,</span>
 	if (list_empty(&amp;fi-&gt;list))
 		atomic_set(&amp;fi-&gt;active, 0);
 	spin_unlock(&amp;fi-&gt;lock);
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
 	return inti;
 }
 
<span class="p_chunk">@@ -1172,7 +1171,6 @@</span> <span class="p_context"> static int __inject_vm(struct kvm *kvm, struct kvm_s390_interrupt_info *inti)</span>
 	int sigcpu;
 	int rc = 0;
 
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
 	fi = &amp;kvm-&gt;arch.float_int;
 	spin_lock(&amp;fi-&gt;lock);
 	if (fi-&gt;irq_count &gt;= KVM_S390_MAX_FLOAT_IRQS) {
<span class="p_chunk">@@ -1225,7 +1223,6 @@</span> <span class="p_context"> static int __inject_vm(struct kvm *kvm, struct kvm_s390_interrupt_info *inti)</span>
 	kvm_s390_vcpu_wakeup(kvm_get_vcpu(kvm, sigcpu));
 unlock_fi:
 	spin_unlock(&amp;fi-&gt;lock);
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -1287,10 +1284,10 @@</span> <span class="p_context"> int kvm_s390_inject_vm(struct kvm *kvm,</span>
 	return rc;
 }
 
<span class="p_del">-void kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_add">+int kvm_s390_reinject_io_int(struct kvm *kvm,</span>
 			      struct kvm_s390_interrupt_info *inti)
 {
<span class="p_del">-	__inject_vm(kvm, inti);</span>
<span class="p_add">+	return __inject_vm(kvm, inti);</span>
 }
 
 int s390int_to_s390irq(struct kvm_s390_interrupt *s390int,
<span class="p_chunk">@@ -1379,7 +1376,6 @@</span> <span class="p_context"> void kvm_s390_clear_float_irqs(struct kvm *kvm)</span>
 	struct kvm_s390_float_interrupt *fi;
 	struct kvm_s390_interrupt_info	*n, *inti = NULL;
 
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
 	fi = &amp;kvm-&gt;arch.float_int;
 	spin_lock(&amp;fi-&gt;lock);
 	list_for_each_entry_safe(inti, n, &amp;fi-&gt;list, list) {
<span class="p_chunk">@@ -1389,66 +1385,68 @@</span> <span class="p_context"> void kvm_s390_clear_float_irqs(struct kvm *kvm)</span>
 	fi-&gt;irq_count = 0;
 	atomic_set(&amp;fi-&gt;active, 0);
 	spin_unlock(&amp;fi-&gt;lock);
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
 }
 
<span class="p_del">-static inline int copy_irq_to_user(struct kvm_s390_interrupt_info *inti,</span>
<span class="p_del">-				   u8 *addr)</span>
<span class="p_add">+static void inti_to_irq(struct kvm_s390_interrupt_info *inti,</span>
<span class="p_add">+		       struct kvm_s390_irq *irq)</span>
 {
<span class="p_del">-	struct kvm_s390_irq __user *uptr = (struct kvm_s390_irq __user *) addr;</span>
<span class="p_del">-	struct kvm_s390_irq irq = {0};</span>
<span class="p_del">-</span>
<span class="p_del">-	irq.type = inti-&gt;type;</span>
<span class="p_add">+	irq-&gt;type = inti-&gt;type;</span>
 	switch (inti-&gt;type) {
 	case KVM_S390_INT_PFAULT_INIT:
 	case KVM_S390_INT_PFAULT_DONE:
 	case KVM_S390_INT_VIRTIO:
 	case KVM_S390_INT_SERVICE:
<span class="p_del">-		irq.u.ext = inti-&gt;ext;</span>
<span class="p_add">+		irq-&gt;u.ext = inti-&gt;ext;</span>
 		break;
 	case KVM_S390_INT_IO_MIN...KVM_S390_INT_IO_MAX:
<span class="p_del">-		irq.u.io = inti-&gt;io;</span>
<span class="p_add">+		irq-&gt;u.io = inti-&gt;io;</span>
 		break;
 	case KVM_S390_MCHK:
<span class="p_del">-		irq.u.mchk = inti-&gt;mchk;</span>
<span class="p_add">+		irq-&gt;u.mchk = inti-&gt;mchk;</span>
 		break;
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	if (copy_to_user(uptr, &amp;irq, sizeof(irq)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
<span class="p_del">-static int get_all_floating_irqs(struct kvm *kvm, __u8 *buf, __u64 len)</span>
<span class="p_add">+static int get_all_floating_irqs(struct kvm *kvm, u8 __user *usrbuf, u64 len)</span>
 {
 	struct kvm_s390_interrupt_info *inti;
 	struct kvm_s390_float_interrupt *fi;
<span class="p_add">+	struct kvm_s390_irq *buf;</span>
<span class="p_add">+	int max_irqs;</span>
 	int ret = 0;
 	int n = 0;
 
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="p_add">+	if (len &gt; KVM_S390_FLIC_MAX_BUFFER || len == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We are already using -ENOMEM to signal</span>
<span class="p_add">+	 * userspace it may retry with a bigger buffer,</span>
<span class="p_add">+	 * so we need to use something else for this case</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	buf = vzalloc(len);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOBUFS;</span>
<span class="p_add">+</span>
<span class="p_add">+	max_irqs = len / sizeof(struct kvm_s390_irq);</span>
<span class="p_add">+</span>
 	fi = &amp;kvm-&gt;arch.float_int;
 	spin_lock(&amp;fi-&gt;lock);
<span class="p_del">-</span>
 	list_for_each_entry(inti, &amp;fi-&gt;list, list) {
<span class="p_del">-		if (len &lt; sizeof(struct kvm_s390_irq)) {</span>
<span class="p_add">+		if (n == max_irqs) {</span>
 			/* signal userspace to try again */
 			ret = -ENOMEM;
 			break;
 		}
<span class="p_del">-		ret = copy_irq_to_user(inti, buf);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		buf += sizeof(struct kvm_s390_irq);</span>
<span class="p_del">-		len -= sizeof(struct kvm_s390_irq);</span>
<span class="p_add">+		inti_to_irq(inti, &amp;buf[n]);</span>
 		n++;
 	}
<span class="p_del">-</span>
 	spin_unlock(&amp;fi-&gt;lock);
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
<span class="p_add">+	if (!ret &amp;&amp; n &gt; 0) {</span>
<span class="p_add">+		if (copy_to_user(usrbuf, buf, sizeof(struct kvm_s390_irq) * n))</span>
<span class="p_add">+			ret = -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	vfree(buf);</span>
 
 	return ret &lt; 0 ? ret : n;
 }
<span class="p_chunk">@@ -1459,7 +1457,7 @@</span> <span class="p_context"> static int flic_get_attr(struct kvm_device *dev, struct kvm_device_attr *attr)</span>
 
 	switch (attr-&gt;group) {
 	case KVM_DEV_FLIC_GET_ALL_IRQS:
<span class="p_del">-		r = get_all_floating_irqs(dev-&gt;kvm, (u8 *) attr-&gt;addr,</span>
<span class="p_add">+		r = get_all_floating_irqs(dev-&gt;kvm, (u8 __user *) attr-&gt;addr,</span>
 					  attr-&gt;attr);
 		break;
 	default:
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.h b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">index a8f3d9b71c11..2c1ea12ed55d 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_chunk">@@ -146,8 +146,8 @@</span> <span class="p_context"> int __must_check kvm_s390_inject_vcpu(struct kvm_vcpu *vcpu,</span>
 int __must_check kvm_s390_inject_program_int(struct kvm_vcpu *vcpu, u16 code);
 struct kvm_s390_interrupt_info *kvm_s390_get_io_int(struct kvm *kvm,
 						    u64 cr6, u64 schid);
<span class="p_del">-void kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_del">-			      struct kvm_s390_interrupt_info *inti);</span>
<span class="p_add">+int kvm_s390_reinject_io_int(struct kvm *kvm,</span>
<span class="p_add">+			     struct kvm_s390_interrupt_info *inti);</span>
 int kvm_s390_mask_adapter(struct kvm *kvm, unsigned int id, bool masked);
 
 /* implemented in intercept.c */
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 1be578d64dfc..1edbf953cf0e 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -229,18 +229,19 @@</span> <span class="p_context"> static int handle_tpi(struct kvm_vcpu *vcpu)</span>
 	struct kvm_s390_interrupt_info *inti;
 	unsigned long len;
 	u32 tpi_data[3];
<span class="p_del">-	int cc, rc;</span>
<span class="p_add">+	int rc;</span>
 	u64 addr;
 
<span class="p_del">-	rc = 0;</span>
 	addr = kvm_s390_get_base_disp_s(vcpu);
 	if (addr &amp; 3)
 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
<span class="p_del">-	cc = 0;</span>
<span class="p_add">+</span>
 	inti = kvm_s390_get_io_int(vcpu-&gt;kvm, vcpu-&gt;arch.sie_block-&gt;gcr[6], 0);
<span class="p_del">-	if (!inti)</span>
<span class="p_del">-		goto no_interrupt;</span>
<span class="p_del">-	cc = 1;</span>
<span class="p_add">+	if (!inti) {</span>
<span class="p_add">+		kvm_s390_set_psw_cc(vcpu, 0);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	tpi_data[0] = inti-&gt;io.subchannel_id &lt;&lt; 16 | inti-&gt;io.subchannel_nr;
 	tpi_data[1] = inti-&gt;io.io_int_parm;
 	tpi_data[2] = inti-&gt;io.io_int_word;
<span class="p_chunk">@@ -251,30 +252,38 @@</span> <span class="p_context"> static int handle_tpi(struct kvm_vcpu *vcpu)</span>
 		 */
 		len = sizeof(tpi_data) - 4;
 		rc = write_guest(vcpu, addr, &amp;tpi_data, len);
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			return kvm_s390_inject_prog_cond(vcpu, rc);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			rc = kvm_s390_inject_prog_cond(vcpu, rc);</span>
<span class="p_add">+			goto reinject_interrupt;</span>
<span class="p_add">+		}</span>
 	} else {
 		/*
 		 * Store the three-word I/O interruption code into
 		 * the appropriate lowcore area.
 		 */
 		len = sizeof(tpi_data);
<span class="p_del">-		if (write_guest_lc(vcpu, __LC_SUBCHANNEL_ID, &amp;tpi_data, len))</span>
<span class="p_add">+		if (write_guest_lc(vcpu, __LC_SUBCHANNEL_ID, &amp;tpi_data, len)) {</span>
<span class="p_add">+			/* failed writes to the low core are not recoverable */</span>
 			rc = -EFAULT;
<span class="p_add">+			goto reinject_interrupt;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* irq was successfully handed to the guest */</span>
<span class="p_add">+	kfree(inti);</span>
<span class="p_add">+	kvm_s390_set_psw_cc(vcpu, 1);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+reinject_interrupt:</span>
 	/*
 	 * If we encounter a problem storing the interruption code, the
 	 * instruction is suppressed from the guest&#39;s view: reinject the
 	 * interrupt.
 	 */
<span class="p_del">-	if (!rc)</span>
<span class="p_add">+	if (kvm_s390_reinject_io_int(vcpu-&gt;kvm, inti)) {</span>
 		kfree(inti);
<span class="p_del">-	else</span>
<span class="p_del">-		kvm_s390_reinject_io_int(vcpu-&gt;kvm, inti);</span>
<span class="p_del">-no_interrupt:</span>
<span class="p_del">-	/* Set condition code and we&#39;re done. */</span>
<span class="p_del">-	if (!rc)</span>
<span class="p_del">-		kvm_s390_set_psw_cc(vcpu, cc);</span>
<span class="p_add">+		rc = -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* don&#39;t set the cc, a pgm irq was injected or we drop to user space */</span>
 	return rc ? -EFAULT : 0;
 }
 
<span class="p_chunk">@@ -462,6 +471,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/x86/include/asm/insn.h b/arch/x86/include/asm/insn.h</span>
<span class="p_header">index 47f29b1d1846..e7814b74caf8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/insn.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/insn.h</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> struct insn {</span>
 	const insn_byte_t *next_byte;
 };
 
<span class="p_del">-#define MAX_INSN_SIZE	16</span>
<span class="p_add">+#define MAX_INSN_SIZE	15</span>
 
 #define X86_MODRM_MOD(modrm) (((modrm) &amp; 0xc0) &gt;&gt; 6)
 #define X86_MODRM_REG(modrm) (((modrm) &amp; 0x38) &gt;&gt; 3)
<span class="p_header">diff --git a/arch/x86/include/asm/mwait.h b/arch/x86/include/asm/mwait.h</span>
<span class="p_header">index a1410db38a1a..653dfa7662e1 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mwait.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mwait.h</span>
<span class="p_chunk">@@ -30,6 +30,14 @@</span> <span class="p_context"> static inline void __mwait(unsigned long eax, unsigned long ecx)</span>
 		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));
 }
 
<span class="p_add">+static inline void __sti_mwait(unsigned long eax, unsigned long ecx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_hardirqs_on();</span>
<span class="p_add">+	/* &quot;mwait %eax, %ecx;&quot; */</span>
<span class="p_add">+	asm volatile(&quot;sti; .byte 0x0f, 0x01, 0xc9;&quot;</span>
<span class="p_add">+		     :: &quot;a&quot; (eax), &quot;c&quot; (ecx));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This uses new MONITOR/MWAIT instructions on P4 processors with PNI,
  * which can obviate IPI to trigger checking of need_resched.
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_ds.c b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">index 073983398364..666bcf14ce10 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_ds.c</span>
<span class="p_chunk">@@ -557,6 +557,8 @@</span> <span class="p_context"> struct event_constraint intel_core2_pebs_event_constraints[] = {</span>
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x00c5, 0x1), /* BR_INST_RETIRED.MISPRED */
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x1fc7, 0x1), /* SIMD_INST_RETURED.ANY */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xcb, 0x1),    /* MEM_LOAD_RETIRED.* */
<span class="p_add">+	/* INST_RETIRED.ANY_P, inv=1, cmask=16 (cycles:p). */</span>
<span class="p_add">+	INTEL_FLAGS_EVENT_CONSTRAINT(0x108000c0, 0x01),</span>
 	EVENT_CONSTRAINT_END
 };
 
<span class="p_chunk">@@ -564,6 +566,8 @@</span> <span class="p_context"> struct event_constraint intel_atom_pebs_event_constraints[] = {</span>
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x00c0, 0x1), /* INST_RETIRED.ANY */
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x00c5, 0x1), /* MISPREDICTED_BRANCH_RETIRED */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xcb, 0x1),    /* MEM_LOAD_RETIRED.* */
<span class="p_add">+	/* INST_RETIRED.ANY_P, inv=1, cmask=16 (cycles:p). */</span>
<span class="p_add">+	INTEL_FLAGS_EVENT_CONSTRAINT(0x108000c0, 0x01),</span>
 	EVENT_CONSTRAINT_END
 };
 
<span class="p_chunk">@@ -587,6 +591,8 @@</span> <span class="p_context"> struct event_constraint intel_nehalem_pebs_event_constraints[] = {</span>
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x20c8, 0xf), /* ITLB_MISS_RETIRED */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xcb, 0xf),    /* MEM_LOAD_RETIRED.* */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xf7, 0xf),    /* FP_ASSIST.* */
<span class="p_add">+	/* INST_RETIRED.ANY_P, inv=1, cmask=16 (cycles:p). */</span>
<span class="p_add">+	INTEL_FLAGS_EVENT_CONSTRAINT(0x108000c0, 0x0f),</span>
 	EVENT_CONSTRAINT_END
 };
 
<span class="p_chunk">@@ -602,6 +608,8 @@</span> <span class="p_context"> struct event_constraint intel_westmere_pebs_event_constraints[] = {</span>
 	INTEL_FLAGS_UEVENT_CONSTRAINT(0x20c8, 0xf), /* ITLB_MISS_RETIRED */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xcb, 0xf),    /* MEM_LOAD_RETIRED.* */
 	INTEL_FLAGS_EVENT_CONSTRAINT(0xf7, 0xf),    /* FP_ASSIST.* */
<span class="p_add">+	/* INST_RETIRED.ANY_P, inv=1, cmask=16 (cycles:p). */</span>
<span class="p_add">+	INTEL_FLAGS_EVENT_CONSTRAINT(0x108000c0, 0x0f),</span>
 	EVENT_CONSTRAINT_END
 };
 
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index e127ddaa2d5a..6ad8a6396b75 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/syscalls.h&gt;
 #include &lt;asm/idle.h&gt;
 #include &lt;asm/uaccess.h&gt;
<span class="p_add">+#include &lt;asm/mwait.h&gt;</span>
 #include &lt;asm/i387.h&gt;
 #include &lt;asm/fpu-internal.h&gt;
 #include &lt;asm/debugreg.h&gt;
<span class="p_chunk">@@ -398,6 +399,53 @@</span> <span class="p_context"> static void amd_e400_idle(void)</span>
 		default_idle();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Core2 and older machines prefer MWAIT over HALT for C1.</span>
<span class="p_add">+ * We can&#39;t rely on cpuidle installing MWAIT, because it will not load</span>
<span class="p_add">+ * on systems that support only C1 -- so the boot default must be MWAIT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some AMD machines are the opposite, they depend on using HALT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * So for default C1, which is used during boot until cpuidle loads,</span>
<span class="p_add">+ * use MWAIT-C1 on Intel HW that has it, else use HALT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int prefer_mwait_c1_over_halt(const struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (c-&gt;x86_vendor != X86_VENDOR_INTEL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu_has(c, X86_FEATURE_MWAIT))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MONITOR/MWAIT with no hints, used for default default C1 state.</span>
<span class="p_add">+ * This invokes MWAIT with interrutps enabled and no flags,</span>
<span class="p_add">+ * which is backwards compatible with the original MWAIT implementation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void mwait_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!current_set_polling_and_test()) {</span>
<span class="p_add">+		if (this_cpu_has(X86_BUG_CLFLUSH_MONITOR)) {</span>
<span class="p_add">+			smp_mb(); /* quirk */</span>
<span class="p_add">+			clflush((void *)&amp;current_thread_info()-&gt;flags);</span>
<span class="p_add">+			smp_mb(); /* quirk */</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		__monitor((void *)&amp;current_thread_info()-&gt;flags, 0, 0);</span>
<span class="p_add">+		if (!need_resched())</span>
<span class="p_add">+			__sti_mwait(0, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			local_irq_enable();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	__current_clr_polling();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void select_idle_routine(const struct cpuinfo_x86 *c)
 {
 #ifdef CONFIG_SMP
<span class="p_chunk">@@ -411,6 +459,9 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 		/* E400: APIC timer interrupt does not wake up CPU from C1e */
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
<span class="p_add">+	} else if (prefer_mwait_c1_over_halt(c)) {</span>
<span class="p_add">+		pr_info(&quot;using mwait in idle threads\n&quot;);</span>
<span class="p_add">+		x86_idle = mwait_idle;</span>
 	} else
 		x86_idle = default_idle;
 }
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 64d76c102230..5ec6a9969581 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5781,7 +5781,6 @@</span> <span class="p_context"> int kvm_arch_init(void *opaque)</span>
 	kvm_set_mmio_spte_mask();
 
 	kvm_x86_ops = ops;
<span class="p_del">-	kvm_init_msr_list();</span>
 
 	kvm_mmu_set_mask_ptes(PT_USER_MASK, PT_ACCESSED_MASK,
 			PT_DIRTY_MASK, PT64_NX_MASK, 0);
<span class="p_chunk">@@ -7218,7 +7217,14 @@</span> <span class="p_context"> void kvm_arch_hardware_disable(void)</span>
 
 int kvm_arch_hardware_setup(void)
 {
<span class="p_del">-	return kvm_x86_ops-&gt;hardware_setup();</span>
<span class="p_add">+	int r;</span>
<span class="p_add">+</span>
<span class="p_add">+	r = kvm_x86_ops-&gt;hardware_setup();</span>
<span class="p_add">+	if (r != 0)</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_init_msr_list();</span>
<span class="p_add">+	return 0;</span>
 }
 
 void kvm_arch_hardware_unsetup(void)
<span class="p_header">diff --git a/arch/x86/lib/insn.c b/arch/x86/lib/insn.c</span>
<span class="p_header">index 1313ae6b478b..85994f5d48e4 100644</span>
<span class="p_header">--- a/arch/x86/lib/insn.c</span>
<span class="p_header">+++ b/arch/x86/lib/insn.c</span>
<span class="p_chunk">@@ -52,6 +52,13 @@</span> <span class="p_context"></span>
  */
 void insn_init(struct insn *insn, const void *kaddr, int buf_len, int x86_64)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Instructions longer than MAX_INSN_SIZE (15 bytes) are invalid</span>
<span class="p_add">+	 * even if the input buffer is long enough to hold them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (buf_len &gt; MAX_INSN_SIZE)</span>
<span class="p_add">+		buf_len = MAX_INSN_SIZE;</span>
<span class="p_add">+</span>
 	memset(insn, 0, sizeof(*insn));
 	insn-&gt;kaddr = kaddr;
 	insn-&gt;end_kaddr = kaddr + buf_len;
<span class="p_header">diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig</span>
<span class="p_header">index e31d4949124a..87be10e8b57a 100644</span>
<span class="p_header">--- a/arch/xtensa/Kconfig</span>
<span class="p_header">+++ b/arch/xtensa/Kconfig</span>
<span class="p_chunk">@@ -428,6 +428,36 @@</span> <span class="p_context"> config DEFAULT_MEM_SIZE</span>
 
 	  If unsure, leave the default value here.
 
<span class="p_add">+config XTFPGA_LCD</span>
<span class="p_add">+	bool &quot;Enable XTFPGA LCD driver&quot;</span>
<span class="p_add">+	depends on XTENSA_PLATFORM_XTFPGA</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  There&#39;s a 2x16 LCD on most of XTFPGA boards, kernel may output</span>
<span class="p_add">+	  progress messages there during bootup/shutdown. It may be useful</span>
<span class="p_add">+	  during board bringup.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_BASE_ADDR</span>
<span class="p_add">+	hex &quot;XTFPGA LCD base address&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default &quot;0x0d0c0000&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Base address of the LCD controller inside KIO region.</span>
<span class="p_add">+	  Different boards from XTFPGA family have LCD controller at different</span>
<span class="p_add">+	  addresses. Please consult prototyping user guide for your board for</span>
<span class="p_add">+	  the correct address. Wrong address here may lead to hardware lockup.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	bool &quot;Use 8-bit access to XTFPGA LCD&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may</span>
<span class="p_add">+	  only be used with 8-bit interface. Please consult prototyping user</span>
<span class="p_add">+	  guide for your board for the correct interface width.</span>
<span class="p_add">+</span>
 endmenu
 
 menu &quot;Executable file formats&quot;
<span class="p_header">diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">index db5bb72e2f4e..62d84657c60b 100644</span>
<span class="p_header">--- a/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">+++ b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> __SYSCALL(323, sys_process_vm_writev, 6)</span>
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
<span class="p_del">-#define __NR_sync_file_range			326</span>
<span class="p_add">+#define __NR_sync_file_range2			326</span>
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/network.c b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">index d05f8feeb8d7..17b1ef3232e4 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/network.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/network.c</span>
<span class="p_chunk">@@ -349,8 +349,8 @@</span> <span class="p_context"> static void iss_net_timer(unsigned long priv)</span>
 {
 	struct iss_net_private *lp = (struct iss_net_private *)priv;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
 	iss_net_poll();
<span class="p_add">+	spin_lock(&amp;lp-&gt;lock);</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 	spin_unlock(&amp;lp-&gt;lock);
 }
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	struct iss_net_private *lp = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	err = lp-&gt;tp.open(lp);
 	if (err &lt; 0)
<span class="p_chunk">@@ -376,9 +376,11 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	while ((err = iss_net_rx(dev)) &gt; 0)
 		;
 
<span class="p_del">-	spin_lock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;opened_lock);</span>
 	list_add(&amp;lp-&gt;opened_list, &amp;opened);
<span class="p_del">-	spin_unlock(&amp;opened_lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;opened_lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	init_timer(&amp;lp-&gt;timer);
 	lp-&gt;timer_val = ISS_NET_TIMER_VALUE;
<span class="p_chunk">@@ -387,7 +389,7 @@</span> <span class="p_context"> static int iss_net_open(struct net_device *dev)</span>
 	mod_timer(&amp;lp-&gt;timer, jiffies + lp-&gt;timer_val);
 
 out:
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -395,7 +397,7 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 {
 	struct iss_net_private *lp = netdev_priv(dev);
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	spin_lock(&amp;opened_lock);
 	list_del(&amp;opened);
<span class="p_chunk">@@ -405,18 +407,17 @@</span> <span class="p_context"> static int iss_net_close(struct net_device *dev)</span>
 
 	lp-&gt;tp.close(lp);
 
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
 static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct iss_net_private *lp = netdev_priv(dev);
<span class="p_del">-	unsigned long flags;</span>
 	int len;
 
 	netif_stop_queue(dev);
<span class="p_del">-	spin_lock_irqsave(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 
 	len = lp-&gt;tp.write(lp, &amp;skb);
 
<span class="p_chunk">@@ -438,7 +439,7 @@</span> <span class="p_context"> static int iss_net_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		pr_err(&quot;%s: %s failed(%d)\n&quot;, dev-&gt;name, __func__, len);
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;lp-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 
 	dev_kfree_skb(skb);
 	return NETDEV_TX_OK;
<span class="p_chunk">@@ -466,9 +467,9 @@</span> <span class="p_context"> static int iss_net_set_mac(struct net_device *dev, void *addr)</span>
 
 	if (!is_valid_ether_addr(hwaddr-&gt;sa_data))
 		return -EADDRNOTAVAIL;
<span class="p_del">-	spin_lock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_lock_bh(&amp;lp-&gt;lock);</span>
 	memcpy(dev-&gt;dev_addr, hwaddr-&gt;sa_data, ETH_ALEN);
<span class="p_del">-	spin_unlock(&amp;lp-&gt;lock);</span>
<span class="p_add">+	spin_unlock_bh(&amp;lp-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -520,11 +521,11 @@</span> <span class="p_context"> static int iss_net_configure(int index, char *init)</span>
 	*lp = (struct iss_net_private) {
 		.device_list		= LIST_HEAD_INIT(lp-&gt;device_list),
 		.opened_list		= LIST_HEAD_INIT(lp-&gt;opened_list),
<span class="p_del">-		.lock			= __SPIN_LOCK_UNLOCKED(lp.lock),</span>
 		.dev			= dev,
 		.index			= index,
<span class="p_del">-		};</span>
<span class="p_add">+	};</span>
 
<span class="p_add">+	spin_lock_init(&amp;lp-&gt;lock);</span>
 	/*
 	 * If this name ends up conflicting with an existing registered
 	 * netdevice, that is OK, register_netdev{,ice}() will notice this
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">index b9ae206340cd..7839d38b2337 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_chunk">@@ -6,4 +6,5 @@</span> <span class="p_context"></span>
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
<span class="p_del">-obj-y			= setup.o lcd.o</span>
<span class="p_add">+obj-y			+= setup.o</span>
<span class="p_add">+obj-$(CONFIG_XTFPGA_LCD) += lcd.o</span>
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">index 6edd20bb4565..4e0af2662a21 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_chunk">@@ -40,9 +40,6 @@</span> <span class="p_context"></span>
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
<span class="p_del">-/* LCD instruction and data addresses. */</span>
<span class="p_del">-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))</span>
<span class="p_del">-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))</span>
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">index 0e435645af5a..4c8541ed1139 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_chunk">@@ -11,10 +11,25 @@</span> <span class="p_context"></span>
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD</span>
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
<span class="p_add">+#else</span>
<span class="p_add">+static inline void lcd_disp_at_pos(char *str, unsigned char pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftleft(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftright(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 2872301598df..4dc0c1b43f4b 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -1,50 +1,63 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Driver for the LCD display on the Tensilica LX60 Board.</span>
<span class="p_add">+ * Driver for the LCD display on the Tensilica XTFPGA board family.</span>
<span class="p_add">+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf</span>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file &quot;COPYING&quot; in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
<span class="p_add">+ * Copyright (C) 2015 Cadence Design Systems Inc.</span>
  */
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * FIXME: this code is from the examples from the LX60 user guide.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The lcd_pause function does busy waiting, which is probably not</span>
<span class="p_del">- * great. Maybe the code could be changed to use kernel timers, or</span>
<span class="p_del">- * change the hardware to not need to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/io.h&gt;
 
 #include &lt;platform/hardware.h&gt;
 #include &lt;platform/lcd.h&gt;
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
 
<span class="p_del">-#define LCD_PAUSE_ITERATIONS	4000</span>
<span class="p_add">+/* LCD instruction and data addresses. */</span>
<span class="p_add">+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))</span>
<span class="p_add">+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)</span>
<span class="p_add">+</span>
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
<span class="p_add">+#define LCD_DISPLAY_MODE4BIT	0x28</span>
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
<span class="p_add">+static void lcd_put_byte(u8 *addr, u8 data)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init lcd_init(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	mdelay(5);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	udelay(200);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_CLEAR;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);</span>
 	mdelay(10);
 	lcd_disp_at_pos(&quot;XTENSA LINUX&quot;, 0);
 	return 0;
<span class="p_chunk">@@ -52,10 +65,10 @@</span> <span class="p_context"> static int __init lcd_init(void)</span>
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);</span>
 	udelay(100);
 	while (*str != 0) {
<span class="p_del">-		*LCD_DATA_ADDR = *str;</span>
<span class="p_add">+		lcd_put_byte(LCD_DATA_ADDR, *str);</span>
 		udelay(200);
 		str++;
 	}
<span class="p_chunk">@@ -63,13 +76,13 @@</span> <span class="p_context"> void lcd_disp_at_pos(char *str, unsigned char pos)</span>
 
 void lcd_shiftleft(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);</span>
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);</span>
 	udelay(50);
 }
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbinstal.c b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">index 755b90c40ddf..c0b39f304ea3 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbinstal.c</span>
<span class="p_chunk">@@ -346,7 +346,6 @@</span> <span class="p_context"> acpi_tb_install_standard_table(acpi_physical_address address,</span>
 				 */
 				acpi_tb_uninstall_table(&amp;new_table_desc);
 				*table_index = i;
<span class="p_del">-				(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);</span>
 				return_ACPI_STATUS(AE_OK);
 			}
 		}
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index dc4d8960684a..6b69f7bf2500 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -298,7 +298,11 @@</span> <span class="p_context"> bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent)</span>
 	struct acpi_device_physical_node *pn;
 	bool offline = true;
 
<span class="p_del">-	mutex_lock(&amp;adev-&gt;physical_node_lock);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * acpi_container_offline() calls this for all of the container&#39;s</span>
<span class="p_add">+	 * children under the container&#39;s physical_node_lock lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock_nested(&amp;adev-&gt;physical_node_lock, SINGLE_DEPTH_NESTING);</span>
 
 	list_for_each_entry(pn, &amp;adev-&gt;physical_node_list, node)
 		if (device_supports_offline(pn-&gt;dev) &amp;&amp; !pn-&gt;dev-&gt;offline) {
<span class="p_header">diff --git a/drivers/base/bus.c b/drivers/base/bus.c</span>
<span class="p_header">index 876bae5ade33..79bc203f51ef 100644</span>
<span class="p_header">--- a/drivers/base/bus.c</span>
<span class="p_header">+++ b/drivers/base/bus.c</span>
<span class="p_chunk">@@ -515,11 +515,11 @@</span> <span class="p_context"> int bus_add_device(struct device *dev)</span>
 			goto out_put;
 		error = device_add_groups(dev, bus-&gt;dev_groups);
 		if (error)
<span class="p_del">-			goto out_groups;</span>
<span class="p_add">+			goto out_id;</span>
 		error = sysfs_create_link(&amp;bus-&gt;p-&gt;devices_kset-&gt;kobj,
 						&amp;dev-&gt;kobj, dev_name(dev));
 		if (error)
<span class="p_del">-			goto out_id;</span>
<span class="p_add">+			goto out_groups;</span>
 		error = sysfs_create_link(&amp;dev-&gt;kobj,
 				&amp;dev-&gt;bus-&gt;p-&gt;subsys.kobj, &quot;subsystem&quot;);
 		if (error)
<span class="p_header">diff --git a/drivers/base/cacheinfo.c b/drivers/base/cacheinfo.c</span>
<span class="p_header">index 6e64563361f0..9c2ba1c97c42 100644</span>
<span class="p_header">--- a/drivers/base/cacheinfo.c</span>
<span class="p_header">+++ b/drivers/base/cacheinfo.c</span>
<span class="p_chunk">@@ -62,15 +62,21 @@</span> <span class="p_context"> static int cache_setup_of_node(unsigned int cpu)</span>
 		return -ENOENT;
 	}
 
<span class="p_del">-	while (np &amp;&amp; index &lt; cache_leaves(cpu)) {</span>
<span class="p_add">+	while (index &lt; cache_leaves(cpu)) {</span>
 		this_leaf = this_cpu_ci-&gt;info_list + index;
 		if (this_leaf-&gt;level != 1)
 			np = of_find_next_cache_node(np);
 		else
 			np = of_node_get(np);/* cpu node itself */
<span class="p_add">+		if (!np)</span>
<span class="p_add">+			break;</span>
 		this_leaf-&gt;of_node = np;
 		index++;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (index != cache_leaves(cpu)) /* not all OF nodes populated */</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -189,8 +195,11 @@</span> <span class="p_context"> static int detect_cache_attributes(unsigned int cpu)</span>
 	 * will be set up here only if they are not populated already
 	 */
 	ret = cache_shared_cpu_map_setup(cpu);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;Unable to detect cache hierarcy from DT for CPU %d\n&quot;,</span>
<span class="p_add">+			cpu);</span>
 		goto free_ci;
<span class="p_add">+	}</span>
 	return 0;
 
 free_ci:
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 9421fed40905..e68ab79df28b 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -101,6 +101,15 @@</span> <span class="p_context"> int platform_get_irq(struct platform_device *dev, unsigned int num)</span>
 	}
 
 	r = platform_get_resource(dev, IORESOURCE_IRQ, num);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The resources may pass trigger flags to the irqs that need</span>
<span class="p_add">+	 * to be set up. It so happens that the trigger flags for</span>
<span class="p_add">+	 * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*</span>
<span class="p_add">+	 * settings.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (r &amp;&amp; r-&gt;flags &amp; IORESOURCE_BITS)</span>
<span class="p_add">+		irqd_set_trigger_type(irq_get_irq_data(r-&gt;start),</span>
<span class="p_add">+				      r-&gt;flags &amp; IORESOURCE_BITS);</span>
 
 	return r ? r-&gt;start : -ENXIO;
 #endif
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index de4c8499cbac..288547a3c566 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	/* Atheros AR3011 with sflash firmware*/
 	{ USB_DEVICE(0x0489, 0xE027) },
 	{ USB_DEVICE(0x0489, 0xE03D) },
<span class="p_add">+	{ USB_DEVICE(0x04F2, 0xAFF1) },</span>
 	{ USB_DEVICE(0x0930, 0x0215) },
 	{ USB_DEVICE(0x0CF3, 0x3002) },
 	{ USB_DEVICE(0x0CF3, 0xE019) },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index c91ec52a8948..b0449bb18873 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -153,6 +153,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	/* Atheros 3011 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },
<span class="p_add">+	{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },</span>
 	{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },
 	{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },
<span class="p_header">diff --git a/drivers/clk/at91/clk-usb.c b/drivers/clk/at91/clk-usb.c</span>
<span class="p_header">index a23ac0c724f0..0b7c3e8840ba 100644</span>
<span class="p_header">--- a/drivers/clk/at91/clk-usb.c</span>
<span class="p_header">+++ b/drivers/clk/at91/clk-usb.c</span>
<span class="p_chunk">@@ -56,22 +56,55 @@</span> <span class="p_context"> static unsigned long at91sam9x5_clk_usb_recalc_rate(struct clk_hw *hw,</span>
 	return DIV_ROUND_CLOSEST(parent_rate, (usbdiv + 1));
 }
 
<span class="p_del">-static long at91sam9x5_clk_usb_round_rate(struct clk_hw *hw, unsigned long rate,</span>
<span class="p_del">-					  unsigned long *parent_rate)</span>
<span class="p_add">+static long at91sam9x5_clk_usb_determine_rate(struct clk_hw *hw,</span>
<span class="p_add">+					      unsigned long rate,</span>
<span class="p_add">+					      unsigned long min_rate,</span>
<span class="p_add">+					      unsigned long max_rate,</span>
<span class="p_add">+					      unsigned long *best_parent_rate,</span>
<span class="p_add">+					      struct clk_hw **best_parent_hw)</span>
 {
<span class="p_del">-	unsigned long div;</span>
<span class="p_add">+	struct clk *parent = NULL;</span>
<span class="p_add">+	long best_rate = -EINVAL;</span>
<span class="p_add">+	unsigned long tmp_rate;</span>
<span class="p_add">+	int best_diff = -1;</span>
<span class="p_add">+	int tmp_diff;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-	if (!rate)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	for (i = 0; i &lt; __clk_get_num_parents(hw-&gt;clk); i++) {</span>
<span class="p_add">+		int div;</span>
 
<span class="p_del">-	if (rate &gt;= *parent_rate)</span>
<span class="p_del">-		return *parent_rate;</span>
<span class="p_add">+		parent = clk_get_parent_by_index(hw-&gt;clk, i);</span>
<span class="p_add">+		if (!parent)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (div = 1; div &lt; SAM9X5_USB_MAX_DIV + 2; div++) {</span>
<span class="p_add">+			unsigned long tmp_parent_rate;</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp_parent_rate = rate * div;</span>
<span class="p_add">+			tmp_parent_rate = __clk_round_rate(parent,</span>
<span class="p_add">+							   tmp_parent_rate);</span>
<span class="p_add">+			tmp_rate = DIV_ROUND_CLOSEST(tmp_parent_rate, div);</span>
<span class="p_add">+			if (tmp_rate &lt; rate)</span>
<span class="p_add">+				tmp_diff = rate - tmp_rate;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				tmp_diff = tmp_rate - rate;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (best_diff &lt; 0 || best_diff &gt; tmp_diff) {</span>
<span class="p_add">+				best_rate = tmp_rate;</span>
<span class="p_add">+				best_diff = tmp_diff;</span>
<span class="p_add">+				*best_parent_rate = tmp_parent_rate;</span>
<span class="p_add">+				*best_parent_hw = __clk_get_hw(parent);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!best_diff || tmp_rate &lt; rate)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	div = DIV_ROUND_CLOSEST(*parent_rate, rate);</span>
<span class="p_del">-	if (div &gt; SAM9X5_USB_MAX_DIV + 1)</span>
<span class="p_del">-		div = SAM9X5_USB_MAX_DIV + 1;</span>
<span class="p_add">+		if (!best_diff)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return DIV_ROUND_CLOSEST(*parent_rate, div);</span>
<span class="p_add">+	return best_rate;</span>
 }
 
 static int at91sam9x5_clk_usb_set_parent(struct clk_hw *hw, u8 index)
<span class="p_chunk">@@ -121,7 +154,7 @@</span> <span class="p_context"> static int at91sam9x5_clk_usb_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 
 static const struct clk_ops at91sam9x5_usb_ops = {
 	.recalc_rate = at91sam9x5_clk_usb_recalc_rate,
<span class="p_del">-	.round_rate = at91sam9x5_clk_usb_round_rate,</span>
<span class="p_add">+	.determine_rate = at91sam9x5_clk_usb_determine_rate,</span>
 	.get_parent = at91sam9x5_clk_usb_get_parent,
 	.set_parent = at91sam9x5_clk_usb_set_parent,
 	.set_rate = at91sam9x5_clk_usb_set_rate,
<span class="p_chunk">@@ -159,7 +192,7 @@</span> <span class="p_context"> static const struct clk_ops at91sam9n12_usb_ops = {</span>
 	.disable = at91sam9n12_clk_usb_disable,
 	.is_enabled = at91sam9n12_clk_usb_is_enabled,
 	.recalc_rate = at91sam9x5_clk_usb_recalc_rate,
<span class="p_del">-	.round_rate = at91sam9x5_clk_usb_round_rate,</span>
<span class="p_add">+	.determine_rate = at91sam9x5_clk_usb_determine_rate,</span>
 	.set_rate = at91sam9x5_clk_usb_set_rate,
 };
 
<span class="p_chunk">@@ -179,7 +212,8 @@</span> <span class="p_context"> at91sam9x5_clk_register_usb(struct at91_pmc *pmc, const char *name,</span>
 	init.ops = &amp;at91sam9x5_usb_ops;
 	init.parent_names = parent_names;
 	init.num_parents = num_parents;
<span class="p_del">-	init.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;</span>
<span class="p_add">+	init.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE |</span>
<span class="p_add">+		     CLK_SET_RATE_PARENT;</span>
 
 	usb-&gt;hw.init = &amp;init;
 	usb-&gt;pmc = pmc;
<span class="p_chunk">@@ -207,7 +241,7 @@</span> <span class="p_context"> at91sam9n12_clk_register_usb(struct at91_pmc *pmc, const char *name,</span>
 	init.ops = &amp;at91sam9n12_usb_ops;
 	init.parent_names = &amp;parent_name;
 	init.num_parents = 1;
<span class="p_del">-	init.flags = CLK_SET_RATE_GATE;</span>
<span class="p_add">+	init.flags = CLK_SET_RATE_GATE | CLK_SET_RATE_PARENT;</span>
 
 	usb-&gt;hw.init = &amp;init;
 	usb-&gt;pmc = pmc;
<span class="p_header">diff --git a/drivers/clk/qcom/clk-rcg2.c b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">index 08b8b3729f53..4fe9c01a14b4 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static int clk_rcg2_configure(struct clk_rcg2 *rcg, const struct freq_tbl *f)</span>
 	mask |= CFG_SRC_SEL_MASK | CFG_MODE_MASK;
 	cfg = f-&gt;pre_div &lt;&lt; CFG_SRC_DIV_SHIFT;
 	cfg |= rcg-&gt;parent_map[f-&gt;src] &lt;&lt; CFG_SRC_SEL_SHIFT;
<span class="p_del">-	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n)</span>
<span class="p_add">+	if (rcg-&gt;mnd_width &amp;&amp; f-&gt;n &amp;&amp; (f-&gt;m != f-&gt;n))</span>
 		cfg |= CFG_MODE_DUAL_EDGE;
 	ret = regmap_update_bits(rcg-&gt;clkr.regmap,
 			rcg-&gt;cmd_rcgr + CFG_REG, mask, cfg);
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-ipq806x.c b/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_header">index afed5eb0691e..2d12fee408a2 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-ipq806x.c</span>
<span class="p_chunk">@@ -514,8 +514,8 @@</span> <span class="p_context"> static struct freq_tbl clk_tbl_gsbi_qup[] = {</span>
 	{ 10800000, P_PXO,  1, 2,  5 },
 	{ 15060000, P_PLL8, 1, 2, 51 },
 	{ 24000000, P_PLL8, 4, 1,  4 },
<span class="p_add">+	{ 25000000, P_PXO,  1, 0,  0 },</span>
 	{ 25600000, P_PLL8, 1, 1, 15 },
<span class="p_del">-	{ 27000000, P_PXO,  1, 0,  0 },</span>
 	{ 48000000, P_PLL8, 4, 1,  2 },
 	{ 51200000, P_PLL8, 1, 2, 15 },
 	{ }
<span class="p_header">diff --git a/drivers/clk/samsung/clk-exynos4.c b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">index 88e8c6bbd77f..4bc7ccd7e494 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_chunk">@@ -1354,7 +1354,7 @@</span> <span class="p_context"> static struct samsung_pll_clock exynos4x12_plls[nr_plls] __initdata = {</span>
 			VPLL_LOCK, VPLL_CON0, NULL),
 };
 
<span class="p_del">-static void __init exynos4_core_down_clock(enum exynos4_soc soc)</span>
<span class="p_add">+static void __init exynos4x12_core_down_clock(void)</span>
 {
 	unsigned int tmp;
 
<span class="p_chunk">@@ -1373,11 +1373,9 @@</span> <span class="p_context"> static void __init exynos4_core_down_clock(enum exynos4_soc soc)</span>
 	__raw_writel(tmp, reg_base + PWR_CTRL1);
 
 	/*
<span class="p_del">-	 * Disable the clock up feature on Exynos4x12, in case it was</span>
<span class="p_del">-	 * enabled by bootloader.</span>
<span class="p_add">+	 * Disable the clock up feature in case it was enabled by bootloader.</span>
 	 */
<span class="p_del">-	if (exynos4_soc == EXYNOS4X12)</span>
<span class="p_del">-		__raw_writel(0x0, reg_base + E4X12_PWR_CTRL2);</span>
<span class="p_add">+	__raw_writel(0x0, reg_base + E4X12_PWR_CTRL2);</span>
 }
 
 /* register exynos4 clocks */
<span class="p_chunk">@@ -1474,7 +1472,8 @@</span> <span class="p_context"> static void __init exynos4_clk_init(struct device_node *np,</span>
 	samsung_clk_register_alias(ctx, exynos4_aliases,
 			ARRAY_SIZE(exynos4_aliases));
 
<span class="p_del">-	exynos4_core_down_clock(soc);</span>
<span class="p_add">+	if (soc == EXYNOS4X12)</span>
<span class="p_add">+		exynos4x12_core_down_clock();</span>
 	exynos4_clk_sleep_init();
 
 	samsung_clk_of_add_provider(np, ctx);
<span class="p_header">diff --git a/drivers/clk/tegra/clk.c b/drivers/clk/tegra/clk.c</span>
<span class="p_header">index 97dc8595c3cd..c51f7c84c163 100644</span>
<span class="p_header">--- a/drivers/clk/tegra/clk.c</span>
<span class="p_header">+++ b/drivers/clk/tegra/clk.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> void __init tegra_add_of_provider(struct device_node *np)</span>
 	of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data);
 
 	rst_ctlr.of_node = np;
<span class="p_del">-	rst_ctlr.nr_resets = clk_num * 32;</span>
<span class="p_add">+	rst_ctlr.nr_resets = periph_banks * 32;</span>
 	reset_controller_register(&amp;rst_ctlr);
 }
 
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index f79dd410dede..af3b77b14835 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -554,15 +554,23 @@</span> <span class="p_context"> static int omap_aes_crypt_dma_stop(struct omap_aes_dev *dd)</span>
 	return err;
 }
 
<span class="p_del">-static int omap_aes_check_aligned(struct scatterlist *sg)</span>
<span class="p_add">+static int omap_aes_check_aligned(struct scatterlist *sg, int total)</span>
 {
<span class="p_add">+	int len = 0;</span>
<span class="p_add">+</span>
 	while (sg) {
 		if (!IS_ALIGNED(sg-&gt;offset, 4))
 			return -1;
 		if (!IS_ALIGNED(sg-&gt;length, AES_BLOCK_SIZE))
 			return -1;
<span class="p_add">+</span>
<span class="p_add">+		len += sg-&gt;length;</span>
 		sg = sg_next(sg);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (len != total)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -633,8 +641,8 @@</span> <span class="p_context"> static int omap_aes_handle_queue(struct omap_aes_dev *dd,</span>
 	dd-&gt;in_sg = req-&gt;src;
 	dd-&gt;out_sg = req-&gt;dst;
 
<span class="p_del">-	if (omap_aes_check_aligned(dd-&gt;in_sg) ||</span>
<span class="p_del">-	    omap_aes_check_aligned(dd-&gt;out_sg)) {</span>
<span class="p_add">+	if (omap_aes_check_aligned(dd-&gt;in_sg, dd-&gt;total) ||</span>
<span class="p_add">+	    omap_aes_check_aligned(dd-&gt;out_sg, dd-&gt;total)) {</span>
 		if (omap_aes_copy_sgs(dd))
 			pr_err(&quot;Failed to copy SGs for unaligned cases\n&quot;);
 		dd-&gt;sgs_copied = 1;
<span class="p_header">diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">index 7bc3e9b288f3..1be85afe4a00 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_chunk">@@ -313,11 +313,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -325,11 +327,13 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_edge_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_edge_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -337,11 +341,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_mask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache &amp;= ~mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv &amp;= ~mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -349,11 +355,13 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_unmask(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_add">+	struct irq_chip_type *ct = irq_data_get_chip_type(d);</span>
<span class="p_add">+</span>
 	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);
 
 	irq_gc_lock(gc);
<span class="p_del">-	gc-&gt;mask_cache |= mask;</span>
<span class="p_del">-	writel_relaxed(gc-&gt;mask_cache, mvebu_gpioreg_level_mask(mvchip));</span>
<span class="p_add">+	ct-&gt;mask_cache_priv |= mask;</span>
<span class="p_add">+	writel_relaxed(ct-&gt;mask_cache_priv, mvebu_gpioreg_level_mask(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i2c/adv7511.c b/drivers/gpu/drm/i2c/adv7511.c</span>
<span class="p_header">index faf1c0c5ab2e..e5b19c8a0265 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i2c/adv7511.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i2c/adv7511.c</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"> struct adv7511 {</span>
 
 	unsigned int current_edid_segment;
 	uint8_t edid_buf[256];
<span class="p_add">+	bool edid_read;</span>
 
 	wait_queue_head_t wq;
 	struct drm_encoder *encoder;
<span class="p_chunk">@@ -379,69 +380,71 @@</span> <span class="p_context"> static bool adv7511_hpd(struct adv7511 *adv7511)</span>
 	return false;
 }
 
<span class="p_del">-static irqreturn_t adv7511_irq_handler(int irq, void *devid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct adv7511 *adv7511 = devid;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (adv7511_hpd(adv7511))</span>
<span class="p_del">-		drm_helper_hpd_irq_event(adv7511-&gt;encoder-&gt;dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	wake_up_all(&amp;adv7511-&gt;wq);</span>
<span class="p_del">-</span>
<span class="p_del">-	return IRQ_HANDLED;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned int adv7511_is_interrupt_pending(struct adv7511 *adv7511,</span>
<span class="p_del">-						 unsigned int irq)</span>
<span class="p_add">+static int adv7511_irq_process(struct adv7511 *adv7511)</span>
 {
 	unsigned int irq0, irq1;
<span class="p_del">-	unsigned int pending;</span>
 	int ret;
 
 	ret = regmap_read(adv7511-&gt;regmap, ADV7511_REG_INT(0), &amp;irq0);
 	if (ret &lt; 0)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	ret = regmap_read(adv7511-&gt;regmap, ADV7511_REG_INT(1), &amp;irq1);
 	if (ret &lt; 0)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(0), irq0);</span>
<span class="p_add">+	regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(1), irq1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (irq0 &amp; ADV7511_INT0_HDP)</span>
<span class="p_add">+		drm_helper_hpd_irq_event(adv7511-&gt;encoder-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (irq0 &amp; ADV7511_INT0_EDID_READY || irq1 &amp; ADV7511_INT1_DDC_ERROR) {</span>
<span class="p_add">+		adv7511-&gt;edid_read = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (adv7511-&gt;i2c_main-&gt;irq)</span>
<span class="p_add">+			wake_up_all(&amp;adv7511-&gt;wq);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	pending = (irq1 &lt;&lt; 8) | irq0;</span>
<span class="p_add">+static irqreturn_t adv7511_irq_handler(int irq, void *devid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct adv7511 *adv7511 = devid;</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	return pending &amp; irq;</span>
<span class="p_add">+	ret = adv7511_irq_process(adv7511);</span>
<span class="p_add">+	return ret &lt; 0 ? IRQ_NONE : IRQ_HANDLED;</span>
 }
 
<span class="p_del">-static int adv7511_wait_for_interrupt(struct adv7511 *adv7511, int irq,</span>
<span class="p_del">-				      int timeout)</span>
<span class="p_add">+/* -----------------------------------------------------------------------------</span>
<span class="p_add">+ * EDID retrieval</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int adv7511_wait_for_edid(struct adv7511 *adv7511, int timeout)</span>
 {
<span class="p_del">-	unsigned int pending;</span>
 	int ret;
 
 	if (adv7511-&gt;i2c_main-&gt;irq) {
 		ret = wait_event_interruptible_timeout(adv7511-&gt;wq,
<span class="p_del">-				adv7511_is_interrupt_pending(adv7511, irq),</span>
<span class="p_del">-				msecs_to_jiffies(timeout));</span>
<span class="p_del">-		if (ret &lt;= 0)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		pending = adv7511_is_interrupt_pending(adv7511, irq);</span>
<span class="p_add">+				adv7511-&gt;edid_read, msecs_to_jiffies(timeout));</span>
 	} else {
<span class="p_del">-		if (timeout &lt; 25)</span>
<span class="p_del">-			timeout = 25;</span>
<span class="p_del">-		do {</span>
<span class="p_del">-			pending = adv7511_is_interrupt_pending(adv7511, irq);</span>
<span class="p_del">-			if (pending)</span>
<span class="p_add">+		for (; timeout &gt; 0; timeout -= 25) {</span>
<span class="p_add">+			ret = adv7511_irq_process(adv7511);</span>
<span class="p_add">+			if (ret &lt; 0)</span>
 				break;
<span class="p_add">+</span>
<span class="p_add">+			if (adv7511-&gt;edid_read)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
 			msleep(25);
<span class="p_del">-			timeout -= 25;</span>
<span class="p_del">-		} while (timeout &gt;= 25);</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	return pending;</span>
<span class="p_add">+	return adv7511-&gt;edid_read ? 0 : -EIO;</span>
 }
 
<span class="p_del">-/* -----------------------------------------------------------------------------</span>
<span class="p_del">- * EDID retrieval</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
 static int adv7511_get_edid_block(void *data, u8 *buf, unsigned int block,
 				  size_t len)
 {
<span class="p_chunk">@@ -463,19 +466,14 @@</span> <span class="p_context"> static int adv7511_get_edid_block(void *data, u8 *buf, unsigned int block,</span>
 			return ret;
 
 		if (status != 2) {
<span class="p_add">+			adv7511-&gt;edid_read = false;</span>
 			regmap_write(adv7511-&gt;regmap, ADV7511_REG_EDID_SEGMENT,
 				     block);
<span class="p_del">-			ret = adv7511_wait_for_interrupt(adv7511,</span>
<span class="p_del">-					ADV7511_INT0_EDID_READY |</span>
<span class="p_del">-					ADV7511_INT1_DDC_ERROR, 200);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!(ret &amp; ADV7511_INT0_EDID_READY))</span>
<span class="p_del">-				return -EIO;</span>
<span class="p_add">+			ret = adv7511_wait_for_edid(adv7511, 200);</span>
<span class="p_add">+			if (ret &lt; 0)</span>
<span class="p_add">+				return ret;</span>
 		}
 
<span class="p_del">-		regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(0),</span>
<span class="p_del">-			     ADV7511_INT0_EDID_READY | ADV7511_INT1_DDC_ERROR);</span>
<span class="p_del">-</span>
 		/* Break this apart, hopefully more I2C controllers will
 		 * support 64 byte transfers than 256 byte transfers
 		 */
<span class="p_chunk">@@ -528,7 +526,9 @@</span> <span class="p_context"> static int adv7511_get_modes(struct drm_encoder *encoder,</span>
 	/* Reading the EDID only works if the device is powered */
 	if (adv7511-&gt;dpms_mode != DRM_MODE_DPMS_ON) {
 		regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(0),
<span class="p_del">-			     ADV7511_INT0_EDID_READY | ADV7511_INT1_DDC_ERROR);</span>
<span class="p_add">+			     ADV7511_INT0_EDID_READY);</span>
<span class="p_add">+		regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(1),</span>
<span class="p_add">+			     ADV7511_INT1_DDC_ERROR);</span>
 		regmap_update_bits(adv7511-&gt;regmap, ADV7511_REG_POWER,
 				   ADV7511_POWER_POWER_DOWN, 0);
 		adv7511-&gt;current_edid_segment = -1;
<span class="p_chunk">@@ -563,7 +563,9 @@</span> <span class="p_context"> static void adv7511_encoder_dpms(struct drm_encoder *encoder, int mode)</span>
 		adv7511-&gt;current_edid_segment = -1;
 
 		regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(0),
<span class="p_del">-			     ADV7511_INT0_EDID_READY | ADV7511_INT1_DDC_ERROR);</span>
<span class="p_add">+			     ADV7511_INT0_EDID_READY);</span>
<span class="p_add">+		regmap_write(adv7511-&gt;regmap, ADV7511_REG_INT(1),</span>
<span class="p_add">+			     ADV7511_INT1_DDC_ERROR);</span>
 		regmap_update_bits(adv7511-&gt;regmap, ADV7511_REG_POWER,
 				   ADV7511_POWER_POWER_DOWN, 0);
 		/*
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index 391d47e1f131..34d0e58f6421 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -1040,7 +1040,7 @@</span> <span class="p_context"> static void vlv_save_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 		s-&gt;lra_limits[i] = I915_READ(GEN7_LRA_LIMITS_BASE + i * 4);
 
 	s-&gt;media_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);
<span class="p_del">-	s-&gt;gfx_max_req_count	= I915_READ(GEN7_MEDIA_MAX_REQ_COUNT);</span>
<span class="p_add">+	s-&gt;gfx_max_req_count	= I915_READ(GEN7_GFX_MAX_REQ_COUNT);</span>
 
 	s-&gt;render_hwsp		= I915_READ(RENDER_HWS_PGA_GEN7);
 	s-&gt;ecochk		= I915_READ(GAM_ECOCHK);
<span class="p_chunk">@@ -1122,7 +1122,7 @@</span> <span class="p_context"> static void vlv_restore_gunit_s0ix_state(struct drm_i915_private *dev_priv)</span>
 		I915_WRITE(GEN7_LRA_LIMITS_BASE + i * 4, s-&gt;lra_limits[i]);
 
 	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s-&gt;media_max_req_count);
<span class="p_del">-	I915_WRITE(GEN7_MEDIA_MAX_REQ_COUNT, s-&gt;gfx_max_req_count);</span>
<span class="p_add">+	I915_WRITE(GEN7_GFX_MAX_REQ_COUNT, s-&gt;gfx_max_req_count);</span>
 
 	I915_WRITE(RENDER_HWS_PGA_GEN7,	s-&gt;render_hwsp);
 	I915_WRITE(GAM_ECOCHK,		s-&gt;ecochk);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">index 1464bc1f8943..247cc18a6f9b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_chunk">@@ -3717,14 +3717,12 @@</span> <span class="p_context"> static int i8xx_irq_postinstall(struct drm_device *dev)</span>
 		~(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 	I915_WRITE16(IMR, dev_priv-&gt;irq_mask);
 
 	I915_WRITE16(IER,
 		     I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		     I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		     I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		     I915_USER_INTERRUPT);
 	POSTING_READ16(IER);
 
<span class="p_chunk">@@ -3886,14 +3884,12 @@</span> <span class="p_context"> static int i915_irq_postinstall(struct drm_device *dev)</span>
 		  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
 		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
<span class="p_del">-		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |</span>
<span class="p_del">-		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);</span>
<span class="p_add">+		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);</span>
 
 	enable_mask =
 		I915_ASLE_INTERRUPT |
 		I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
 		I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
<span class="p_del">-		I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |</span>
 		I915_USER_INTERRUPT;
 
 	if (I915_HAS_HOTPLUG(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 172de3b3433b..6e7a6f03fca3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1713,6 +1713,7 @@</span> <span class="p_context"> enum punit_power_well {</span>
 #define   GMBUS_CYCLE_INDEX	(2&lt;&lt;25)
 #define   GMBUS_CYCLE_STOP	(4&lt;&lt;25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
<span class="p_add">+#define   GMBUS_BYTE_COUNT_MAX   256U</span>
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index b31088a551f2..56e437e31580 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -270,18 +270,17 @@</span> <span class="p_context"> gmbus_wait_idle(struct drm_i915_private *dev_priv)</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_del">-		u32 gmbus1_index)</span>
<span class="p_add">+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		      unsigned short addr, u8 *buf, unsigned int len,</span>
<span class="p_add">+		      u32 gmbus1_index)</span>
 {
 	int reg_offset = dev_priv-&gt;gpio_mmio_base;
<span class="p_del">-	u16 len = msg-&gt;len;</span>
<span class="p_del">-	u8 *buf = msg-&gt;buf;</span>
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -303,11 +302,35 @@</span> <span class="p_context"> gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_add">+		u32 gmbus1_index)</span>
 {
<span class="p_del">-	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_del">-	u16 len = msg-&gt;len;</span>
 	u8 *buf = msg-&gt;buf;
<span class="p_add">+	unsigned int rx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_read_chunk(dev_priv, msg-&gt;addr,</span>
<span class="p_add">+					    buf, len, gmbus1_index);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		rx_size -= len;</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+	} while (rx_size != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		       unsigned short addr, u8 *buf, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_add">+	unsigned int chunk_size = len;</span>
 	u32 val, loop;
 
 	val = loop = 0;
<span class="p_chunk">@@ -319,8 +342,8 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
<span class="p_del">-		   (msg-&gt;len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (chunk_size &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -337,6 +360,29 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 		if (ret)
 			return ret;
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *buf = msg-&gt;buf;</span>
<span class="p_add">+	unsigned int tx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_write_chunk(dev_priv, msg-&gt;addr, buf, len);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+		tx_size -= len;</span>
<span class="p_add">+	} while (tx_size != 0);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 86807ee91bd1..9bd56116fd5a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -330,8 +330,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -374,8 +376,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 433f72a1c006..995e2a0cf096 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -195,6 +195,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">index 92462843db66..648cea462269 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_chunk">@@ -800,7 +800,7 @@</span> <span class="p_context"> static int rk3x_i2c_xfer(struct i2c_adapter *adap,</span>
 	clk_disable(i2c-&gt;clk);
 	spin_unlock_irqrestore(&amp;i2c-&gt;lock, flags);
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return ret &lt; 0 ? ret : num;</span>
 }
 
 static u32 rk3x_i2c_func(struct i2c_adapter *adap)
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index 63663332391d..c421e1159037 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -596,6 +596,7 @@</span> <span class="p_context"> int i2c_generic_scl_recovery(struct i2c_adapter *adap)</span>
 	adap-&gt;bus_recovery_info-&gt;set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);</span>
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -610,6 +611,7 @@</span> <span class="p_context"> int i2c_generic_gpio_recovery(struct i2c_adapter *adap)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);</span>
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -619,6 +621,7 @@</span> <span class="p_context"> int i2c_recover_bus(struct i2c_adapter *adap)</span>
 	dev_dbg(&amp;adap-&gt;dev, &quot;Trying i2c bus recovery\n&quot;);
 	return adap-&gt;bus_recovery_info-&gt;recover_bus(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_recover_bus);</span>
 
 static int i2c_device_probe(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/i2c/i2c-mux.c b/drivers/i2c/i2c-mux.c</span>
<span class="p_header">index 593f7ca9adc7..06cc1ff088f1 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-mux.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-mux.c</span>
<span class="p_chunk">@@ -32,8 +32,9 @@</span> <span class="p_context"> struct i2c_mux_priv {</span>
 	struct i2c_algorithm algo;
 
 	struct i2c_adapter *parent;
<span class="p_del">-	void *mux_priv;	/* the mux chip/device */</span>
<span class="p_del">-	u32  chan_id;	/* the channel id */</span>
<span class="p_add">+	struct device *mux_dev;</span>
<span class="p_add">+	void *mux_priv;</span>
<span class="p_add">+	u32 chan_id;</span>
 
 	int (*select)(struct i2c_adapter *, void *mux_priv, u32 chan_id);
 	int (*deselect)(struct i2c_adapter *, void *mux_priv, u32 chan_id);
<span class="p_chunk">@@ -119,6 +120,7 @@</span> <span class="p_context"> struct i2c_adapter *i2c_add_mux_adapter(struct i2c_adapter *parent,</span>
 
 	/* Set up private adapter data */
 	priv-&gt;parent = parent;
<span class="p_add">+	priv-&gt;mux_dev = mux_dev;</span>
 	priv-&gt;mux_priv = mux_priv;
 	priv-&gt;chan_id = chan_id;
 	priv-&gt;select = select;
<span class="p_chunk">@@ -203,7 +205,7 @@</span> <span class="p_context"> void i2c_del_mux_adapter(struct i2c_adapter *adap)</span>
 	char symlink_name[20];
 
 	snprintf(symlink_name, sizeof(symlink_name), &quot;channel-%u&quot;, priv-&gt;chan_id);
<span class="p_del">-	sysfs_remove_link(&amp;adap-&gt;dev.parent-&gt;kobj, symlink_name);</span>
<span class="p_add">+	sysfs_remove_link(&amp;priv-&gt;mux_dev-&gt;kobj, symlink_name);</span>
 
 	sysfs_remove_link(&amp;priv-&gt;adap.dev.kobj, &quot;mux_device&quot;);
 	i2c_del_adapter(adap);
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 8c014b5dab4c..38acb3cfc545 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -99,12 +99,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index c880329b4d64..51722be3e5e9 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2564,8 +2564,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">index 20e859a6f1a6..76eb57b31a59 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iser_initiator.c</span>
<span class="p_chunk">@@ -409,8 +409,8 @@</span> <span class="p_context"> int iser_send_command(struct iscsi_conn *conn,</span>
 	if (scsi_prot_sg_count(sc)) {
 		prot_buf-&gt;buf  = scsi_prot_sglist(sc);
 		prot_buf-&gt;size = scsi_prot_sg_count(sc);
<span class="p_del">-		prot_buf-&gt;data_len = data_buf-&gt;data_len &gt;&gt;</span>
<span class="p_del">-				     ilog2(sc-&gt;device-&gt;sector_size) * 8;</span>
<span class="p_add">+		prot_buf-&gt;data_len = (data_buf-&gt;data_len &gt;&gt;</span>
<span class="p_add">+				     ilog2(sc-&gt;device-&gt;sector_size)) * 8;</span>
 	}
 
 	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index dafb3c531f96..0b57ba2c22cb 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> fail:</span>
 static void
 isert_free_rx_descriptors(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;conn_device-&gt;ib_device;</span>
 	struct iser_rx_desc *rx_desc;
 	int i;
 
<span class="p_chunk">@@ -719,8 +719,8 @@</span> <span class="p_context"> out:</span>
 static void
 isert_connect_release(struct isert_conn *isert_conn)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;conn_cm_id-&gt;device;</span>
 	struct isert_device *device = isert_conn-&gt;conn_device;
<span class="p_add">+	struct ib_device *ib_dev = device-&gt;ib_device;</span>
 
 	isert_dbg(&quot;conn %p\n&quot;, isert_conn);
 
<span class="p_chunk">@@ -728,7 +728,8 @@</span> <span class="p_context"> isert_connect_release(struct isert_conn *isert_conn)</span>
 		isert_conn_free_fastreg_pool(isert_conn);
 
 	isert_free_rx_descriptors(isert_conn);
<span class="p_del">-	rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
<span class="p_add">+	if (isert_conn-&gt;conn_cm_id)</span>
<span class="p_add">+		rdma_destroy_id(isert_conn-&gt;conn_cm_id);</span>
 
 	if (isert_conn-&gt;conn_qp) {
 		struct isert_comp *comp = isert_conn-&gt;conn_qp-&gt;recv_cq-&gt;cq_context;
<span class="p_chunk">@@ -878,12 +879,15 @@</span> <span class="p_context"> isert_disconnected_handler(struct rdma_cm_id *cma_id,</span>
 	return 0;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static int</span>
 isert_connect_error(struct rdma_cm_id *cma_id)
 {
 	struct isert_conn *isert_conn = cma_id-&gt;qp-&gt;qp_context;
 
<span class="p_add">+	isert_conn-&gt;conn_cm_id = NULL;</span>
 	isert_put_conn(isert_conn);
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
 }
 
 static int
<span class="p_chunk">@@ -912,7 +916,7 @@</span> <span class="p_context"> isert_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)</span>
 	case RDMA_CM_EVENT_REJECTED:       /* FALLTHRU */
 	case RDMA_CM_EVENT_UNREACHABLE:    /* FALLTHRU */
 	case RDMA_CM_EVENT_CONNECT_ERROR:
<span class="p_del">-		isert_connect_error(cma_id);</span>
<span class="p_add">+		ret = isert_connect_error(cma_id);</span>
 		break;
 	default:
 		isert_err(&quot;Unhandled RDMA CMA event: %d\n&quot;, event-&gt;event);
<span class="p_chunk">@@ -1848,11 +1852,13 @@</span> <span class="p_context"> isert_completion_rdma_read(struct iser_tx_desc *tx_desc,</span>
 	cmd-&gt;i_state = ISTATE_RECEIVED_LAST_DATAOUT;
 	spin_unlock_bh(&amp;cmd-&gt;istate_lock);
 
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		target_put_sess_cmd(se_cmd-&gt;se_sess, se_cmd);</span>
 		transport_send_check_condition_and_sense(se_cmd,
 							 se_cmd-&gt;pi_err, 0);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		target_execute_cmd(se_cmd);
<span class="p_add">+	}</span>
 }
 
 static void
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 6e22682c8255..991dc6b20a58 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -893,6 +893,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -1094,6 +1109,8 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_chunk">@@ -1635,6 +1652,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index 6f3afec02f03..f965d1569cc3 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 08981be7baa1..a9f2266049af 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -920,11 +920,10 @@</span> <span class="p_context"> static int crypt_convert(struct crypt_config *cc,</span>
 
 		switch (r) {
 		/* async */
<span class="p_add">+		case -EINPROGRESS:</span>
 		case -EBUSY:
 			wait_for_completion(&amp;ctx-&gt;restart);
 			reinit_completion(&amp;ctx-&gt;restart);
<span class="p_del">-			/* fall through*/</span>
<span class="p_del">-		case -EINPROGRESS:</span>
 			ctx-&gt;req = NULL;
 			ctx-&gt;cc_sector++;
 			continue;
<span class="p_chunk">@@ -1315,10 +1314,8 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io-&gt;cc;
 
<span class="p_del">-	if (error == -EINPROGRESS) {</span>
<span class="p_del">-		complete(&amp;ctx-&gt;restart);</span>
<span class="p_add">+	if (error == -EINPROGRESS)</span>
 		return;
<span class="p_del">-	}</span>
 
 	if (!error &amp;&amp; cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;post)
 		error = cc-&gt;iv_gen_ops-&gt;post(cc, iv_of_dmreq(cc, dmreq), dmreq);
<span class="p_chunk">@@ -1329,12 +1326,15 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	crypt_free_req(cc, req_of_dmreq(cc, dmreq), io-&gt;base_bio);
 
 	if (!atomic_dec_and_test(&amp;ctx-&gt;cc_pending))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto done;</span>
 
 	if (bio_data_dir(io-&gt;base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
<span class="p_add">+done:</span>
<span class="p_add">+	if (!completion_done(&amp;ctx-&gt;restart))</span>
<span class="p_add">+		complete(&amp;ctx-&gt;restart);</span>
 }
 
 static void kcryptd_crypt(struct work_struct *work)
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 709755fb6d7b..193feb92c320 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -248,6 +248,7 @@</span> <span class="p_context"> static void md_make_request(struct request_queue *q, struct bio *bio)</span>
 	const int rw = bio_data_dir(bio);
 	struct mddev *mddev = q-&gt;queuedata;
 	unsigned int sectors;
<span class="p_add">+	int cpu;</span>
 
 	if (mddev == NULL || mddev-&gt;pers == NULL
 	    || !mddev-&gt;ready) {
<span class="p_chunk">@@ -283,7 +284,10 @@</span> <span class="p_context"> static void md_make_request(struct request_queue *q, struct bio *bio)</span>
 	sectors = bio_sectors(bio);
 	mddev-&gt;pers-&gt;make_request(mddev, bio);
 
<span class="p_del">-	generic_start_io_acct(rw, sectors, &amp;mddev-&gt;gendisk-&gt;part0);</span>
<span class="p_add">+	cpu = part_stat_lock();</span>
<span class="p_add">+	part_stat_inc(cpu, &amp;mddev-&gt;gendisk-&gt;part0, ios[rw]);</span>
<span class="p_add">+	part_stat_add(cpu, &amp;mddev-&gt;gendisk-&gt;part0, sectors[rw], sectors);</span>
<span class="p_add">+	part_stat_unlock();</span>
 
 	if (atomic_dec_and_test(&amp;mddev-&gt;active_io) &amp;&amp; mddev-&gt;suspended)
 		wake_up(&amp;mddev-&gt;sb_wait);
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index ba6b85de96d2..d5c12e5b6125 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -319,7 +319,7 @@</span> <span class="p_context"> static struct strip_zone *find_zone(struct r0conf *conf,</span>
 
 /*
  * remaps the bio to the target device. we separate two flows.
<span class="p_del">- * power 2 flow and a general flow for the sake of perfromance</span>
<span class="p_add">+ * power 2 flow and a general flow for the sake of performance</span>
 */
 static struct md_rdev *map_sector(struct mddev *mddev, struct strip_zone *zone,
 				sector_t sector, sector_t *sector_offset)
<span class="p_chunk">@@ -537,6 +537,7 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/media/rc/img-ir/img-ir-core.c b/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_header">index 77c78de4f5bf..7020659f23c2 100644</span>
<span class="p_header">--- a/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_header">+++ b/drivers/media/rc/img-ir/img-ir-core.c</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> static int img_ir_remove(struct platform_device *pdev)</span>
 {
 	struct img_ir_priv *priv = platform_get_drvdata(pdev);
 
<span class="p_del">-	free_irq(priv-&gt;irq, img_ir_isr);</span>
<span class="p_add">+	free_irq(priv-&gt;irq, priv);</span>
 	img_ir_remove_hw(priv);
 	img_ir_remove_raw(priv);
 
<span class="p_header">diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">index a47629108c1b..5bd940fd7a50 100644</span>
<span class="p_header">--- a/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">+++ b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_chunk">@@ -244,6 +244,11 @@</span> <span class="p_context"> static int stk1160_stop_streaming(struct stk1160 *dev)</span>
 	if (mutex_lock_interruptible(&amp;dev-&gt;v4l_lock))
 		return -ERESTARTSYS;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once URBs are cancelled, the URB complete handler</span>
<span class="p_add">+	 * won&#39;t be running. This is required to safely release the</span>
<span class="p_add">+	 * current buffer (dev-&gt;isoc_ctl.buf).</span>
<span class="p_add">+	 */</span>
 	stk1160_cancel_isoc(dev);
 
 	/*
<span class="p_chunk">@@ -624,8 +629,16 @@</span> <span class="p_context"> void stk1160_clear_queue(struct stk1160 *dev)</span>
 		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,
 				buf, buf-&gt;vb.v4l2_buf.index);
 	}
<span class="p_del">-	/* It&#39;s important to clear current buffer */</span>
<span class="p_del">-	dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s important to release the current buffer */</span>
<span class="p_add">+	if (dev-&gt;isoc_ctl.buf) {</span>
<span class="p_add">+		buf = dev-&gt;isoc_ctl.buf;</span>
<span class="p_add">+		dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		vb2_buffer_done(&amp;buf-&gt;vb, VB2_BUF_STATE_ERROR);</span>
<span class="p_add">+		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,</span>
<span class="p_add">+				buf, buf-&gt;vb.v4l2_buf.index);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;buf_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index fc145d202c46..922a750640e8 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c</span>
<span class="p_header">index 2a87f69be53d..1aed3b7b8d9b 100644</span>
<span class="p_header">--- a/drivers/mfd/mfd-core.c</span>
<span class="p_header">+++ b/drivers/mfd/mfd-core.c</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> static int mfd_add_device(struct device *parent, int id,</span>
 	int platform_id;
 	int r;
 
<span class="p_del">-	if (id &lt; 0)</span>
<span class="p_add">+	if (id == PLATFORM_DEVID_AUTO)</span>
 		platform_id = id;
 	else
 		platform_id = id + cell-&gt;id;
<span class="p_header">diff --git a/drivers/mmc/host/sunxi-mmc.c b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">index 15cb8b7ffc34..9bad746425cb 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_chunk">@@ -908,7 +908,9 @@</span> <span class="p_context"> static int sunxi_mmc_resource_request(struct sunxi_mmc_host *host,</span>
 		return PTR_ERR(host-&gt;clk_mmc);
 	}
 
<span class="p_del">-	host-&gt;reset = devm_reset_control_get(&amp;pdev-&gt;dev, &quot;ahb&quot;);</span>
<span class="p_add">+	host-&gt;reset = devm_reset_control_get_optional(&amp;pdev-&gt;dev, &quot;ahb&quot;);</span>
<span class="p_add">+	if (PTR_ERR(host-&gt;reset) == -EPROBE_DEFER)</span>
<span class="p_add">+		return PTR_ERR(host-&gt;reset);</span>
 
 	ret = clk_prepare_enable(host-&gt;clk_ahb);
 	if (ret) {
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index 9d2e16f3150a..b5e154856994 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -410,7 +410,7 @@</span> <span class="p_context"> int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
 
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index 3410ea8109f8..d347ecf1d27c 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -454,7 +454,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 
 		err = get_exclusive(ubi, desc);
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index a40020cf0923..8c74076efb9e 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1362,7 +1362,8 @@</span> <span class="p_context"> int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 834f6fe1f5fa..4e07f81094ae 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -1005,7 +1005,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int shutdown)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 83140cbb5f01..82f9c554021d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3548,8 +3553,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c</span>
<span class="p_header">index af829c578400..7ace07dad6a3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/pxa168_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/pxa168_eth.c</span>
<span class="p_chunk">@@ -1508,7 +1508,8 @@</span> <span class="p_context"> static int pxa168_eth_probe(struct platform_device *pdev)</span>
 		np = of_parse_phandle(pdev-&gt;dev.of_node, &quot;phy-handle&quot;, 0);
 		if (!np) {
 			dev_err(&amp;pdev-&gt;dev, &quot;missing phy-handle\n&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto err_netdev;</span>
 		}
 		of_property_read_u32(np, &quot;reg&quot;, &amp;pep-&gt;phy_addr);
 		pep-&gt;phy_intf = of_get_phy_mode(pdev-&gt;dev.of_node);
<span class="p_chunk">@@ -1526,7 +1527,7 @@</span> <span class="p_context"> static int pxa168_eth_probe(struct platform_device *pdev)</span>
 	pep-&gt;smi_bus = mdiobus_alloc();
 	if (pep-&gt;smi_bus == NULL) {
 		err = -ENOMEM;
<span class="p_del">-		goto err_base;</span>
<span class="p_add">+		goto err_netdev;</span>
 	}
 	pep-&gt;smi_bus-&gt;priv = pep;
 	pep-&gt;smi_bus-&gt;name = &quot;pxa168_eth smi&quot;;
<span class="p_chunk">@@ -1551,13 +1552,10 @@</span> <span class="p_context"> err_mdiobus:</span>
 	mdiobus_unregister(pep-&gt;smi_bus);
 err_free_mdio:
 	mdiobus_free(pep-&gt;smi_bus);
<span class="p_del">-err_base:</span>
<span class="p_del">-	iounmap(pep-&gt;base);</span>
 err_netdev:
 	free_netdev(dev);
 err_clk:
<span class="p_del">-	clk_disable(clk);</span>
<span class="p_del">-	clk_put(clk);</span>
<span class="p_add">+	clk_disable_unprepare(clk);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1574,13 +1572,9 @@</span> <span class="p_context"> static int pxa168_eth_remove(struct platform_device *pdev)</span>
 	if (pep-&gt;phy)
 		phy_disconnect(pep-&gt;phy);
 	if (pep-&gt;clk) {
<span class="p_del">-		clk_disable(pep-&gt;clk);</span>
<span class="p_del">-		clk_put(pep-&gt;clk);</span>
<span class="p_del">-		pep-&gt;clk = NULL;</span>
<span class="p_add">+		clk_disable_unprepare(pep-&gt;clk);</span>
 	}
 
<span class="p_del">-	iounmap(pep-&gt;base);</span>
<span class="p_del">-	pep-&gt;base = NULL;</span>
 	mdiobus_unregister(pep-&gt;smi_bus);
 	mdiobus_free(pep-&gt;smi_bus);
 	unregister_netdev(dev);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">index 90e0f045a6bc..33637eb16ca0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_chunk">@@ -983,20 +983,21 @@</span> <span class="p_context"> static int mlx4_en_check_rxfh_func(struct net_device *dev, u8 hfunc)</span>
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 
 	/* check if requested function is supported by the device */
<span class="p_del">-	if ((hfunc == ETH_RSS_HASH_TOP &amp;&amp;</span>
<span class="p_del">-	     !(priv-&gt;mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_RSS_TOP)) ||</span>
<span class="p_del">-	    (hfunc == ETH_RSS_HASH_XOR &amp;&amp;</span>
<span class="p_del">-	     !(priv-&gt;mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_RSS_XOR)))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (hfunc == ETH_RSS_HASH_TOP) {</span>
<span class="p_add">+		if (!(priv-&gt;mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_RSS_TOP))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (!(dev-&gt;features &amp; NETIF_F_RXHASH))</span>
<span class="p_add">+			en_warn(priv, &quot;Toeplitz hash function should be used in conjunction with RX hashing for optimal performance\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	} else if (hfunc == ETH_RSS_HASH_XOR) {</span>
<span class="p_add">+		if (!(priv-&gt;mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_RSS_XOR))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (dev-&gt;features &amp; NETIF_F_RXHASH)</span>
<span class="p_add">+			en_warn(priv, &quot;Enabling both XOR Hash function and RX Hashing can limit RPS functionality\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	priv-&gt;rss_hash_fn = hfunc;</span>
<span class="p_del">-	if (hfunc == ETH_RSS_HASH_TOP &amp;&amp; !(dev-&gt;features &amp; NETIF_F_RXHASH))</span>
<span class="p_del">-		en_warn(priv,</span>
<span class="p_del">-			&quot;Toeplitz hash function should be used in conjunction with RX hashing for optimal performance\n&quot;);</span>
<span class="p_del">-	if (hfunc == ETH_RSS_HASH_XOR &amp;&amp; (dev-&gt;features &amp; NETIF_F_RXHASH))</span>
<span class="p_del">-		en_warn(priv,</span>
<span class="p_del">-			&quot;Enabling both XOR Hash function and RX Hashing can limit RPS functionality\n&quot;);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int mlx4_en_get_rxfh(struct net_device *dev, u32 *ring_index, u8 *key,
<span class="p_chunk">@@ -1070,6 +1071,8 @@</span> <span class="p_context"> static int mlx4_en_set_rxfh(struct net_device *dev, const u32 *ring_index,</span>
 		priv-&gt;prof-&gt;rss_rings = rss_rings;
 	if (key)
 		memcpy(priv-&gt;rss_key, key, MLX4_EN_RSS_KEY_SIZE);
<span class="p_add">+	if (hfunc !=  ETH_RSS_HASH_NO_CHANGE)</span>
<span class="p_add">+		priv-&gt;rss_hash_fn = hfunc;</span>
 
 	if (port_up) {
 		err = mlx4_en_start_port(dev);
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index af034dba9bd6..9d15566521a7 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -1716,6 +1716,7 @@</span> <span class="p_context"> ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb, struct channel *pch)</span>
 {
 	/* note: a 0-length skb is used as an error indication */
 	if (skb-&gt;len &gt; 0) {
<span class="p_add">+		skb_checksum_complete_unset(skb);</span>
 #ifdef CONFIG_PPP_MULTILINK
 		/* XXX do channel-level decompression here */
 		if (PPP_PROTO(skb) == PPP_MP)
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index e06bafee37f9..5034660bf411 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/</span>
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_chunk">@@ -377,6 +378,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">index 7f1669cdea09..779dc2b2ca75 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, &quot;%u&quot;);</span>
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, &quot;%u&quot;);
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, &quot;%u&quot;);
 
<span class="p_del">-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, &quot;%u&quot;);</span>
<span class="p_add">+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);</span>
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">index 0f2cfb0d2a9e..bf14676e6515 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"></span>
 
 #include &quot;wlcore.h&quot;
 
<span class="p_del">-int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_del">-			 loff_t *ppos, char *fmt, ...);</span>
<span class="p_add">+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_add">+					loff_t *ppos, char *fmt, ...);</span>
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
<span class="p_header">diff --git a/drivers/nfc/st21nfcb/i2c.c b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">index 01ba865863ee..b5eb3754578c 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_write(void *phy_id, struct sk_buff *skb)</span>
 		return phy-&gt;ndlc-&gt;hard_fault;
 
 	r = i2c_master_send(client, skb-&gt;data, skb-&gt;len);
<span class="p_del">-	if (r == -EREMOTEIO) {  /* Retry, chip was in standby */</span>
<span class="p_add">+	if (r &lt; 0) {  /* Retry, chip was in standby */</span>
 		usleep_range(1000, 4000);
 		r = i2c_master_send(client, skb-&gt;data, skb-&gt;len);
 	}
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_read(struct st21nfcb_i2c_phy *phy,</span>
 	struct i2c_client *client = phy-&gt;i2c_dev;
 
 	r = i2c_master_recv(client, buf, ST21NFCB_NCI_I2C_MIN_SIZE);
<span class="p_del">-	if (r == -EREMOTEIO) {  /* Retry, chip was in standby */</span>
<span class="p_add">+	if (r &lt; 0) {  /* Retry, chip was in standby */</span>
 		usleep_range(1000, 4000);
 		r = i2c_master_recv(client, buf, ST21NFCB_NCI_I2C_MIN_SIZE);
 	}
<span class="p_header">diff --git a/drivers/platform/x86/compal-laptop.c b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">index 15c0fab2bfa1..bceb30b539f3 100644</span>
<span class="p_header">--- a/drivers/platform/x86/compal-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/compal-laptop.c</span>
<span class="p_chunk">@@ -1026,9 +1026,9 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 	if (err)
 		return err;
 
<span class="p_del">-	hwmon_dev = hwmon_device_register_with_groups(&amp;pdev-&gt;dev,</span>
<span class="p_del">-						      &quot;compal&quot;, data,</span>
<span class="p_del">-						      compal_hwmon_groups);</span>
<span class="p_add">+	hwmon_dev = devm_hwmon_device_register_with_groups(&amp;pdev-&gt;dev,</span>
<span class="p_add">+							   &quot;compal&quot;, data,</span>
<span class="p_add">+							   compal_hwmon_groups);</span>
 	if (IS_ERR(hwmon_dev)) {
 		err = PTR_ERR(hwmon_dev);
 		goto remove;
<span class="p_chunk">@@ -1036,7 +1036,9 @@</span> <span class="p_context"> static int compal_probe(struct platform_device *pdev)</span>
 
 	/* Power supply */
 	initialize_power_supply_data(data);
<span class="p_del">-	power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	err = power_supply_register(&amp;compal_device-&gt;dev, &amp;data-&gt;psy);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto remove;</span>
 
 	platform_set_drvdata(pdev, data);
 
<span class="p_header">diff --git a/drivers/power/ipaq_micro_battery.c b/drivers/power/ipaq_micro_battery.c</span>
<span class="p_header">index 9d694605cdb7..96b15e003f3f 100644</span>
<span class="p_header">--- a/drivers/power/ipaq_micro_battery.c</span>
<span class="p_header">+++ b/drivers/power/ipaq_micro_battery.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> static struct power_supply micro_ac_power = {</span>
 static int micro_batt_probe(struct platform_device *pdev)
 {
 	struct micro_battery *mb;
<span class="p_add">+	int ret;</span>
 
 	mb = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*mb), GFP_KERNEL);
 	if (!mb)
<span class="p_chunk">@@ -233,14 +234,30 @@</span> <span class="p_context"> static int micro_batt_probe(struct platform_device *pdev)</span>
 
 	mb-&gt;micro = dev_get_drvdata(pdev-&gt;dev.parent);
 	mb-&gt;wq = create_singlethread_workqueue(&quot;ipaq-battery-wq&quot;);
<span class="p_add">+	if (!mb-&gt;wq)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	INIT_DELAYED_WORK(&amp;mb-&gt;update, micro_battery_work);
 	platform_set_drvdata(pdev, mb);
 	queue_delayed_work(mb-&gt;wq, &amp;mb-&gt;update, 1);
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;micro_batt_power);</span>
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;micro_ac_power);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;micro_batt_power);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto batt_err;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;micro_ac_power);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto ac_err;</span>
 
 	dev_info(&amp;pdev-&gt;dev, &quot;iPAQ micro battery driver\n&quot;);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ac_err:</span>
<span class="p_add">+	power_supply_unregister(&amp;micro_ac_power);</span>
<span class="p_add">+batt_err:</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;mb-&gt;update);</span>
<span class="p_add">+	destroy_workqueue(mb-&gt;wq);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int micro_batt_remove(struct platform_device *pdev)
<span class="p_chunk">@@ -251,6 +268,7 @@</span> <span class="p_context"> static int micro_batt_remove(struct platform_device *pdev)</span>
 	power_supply_unregister(&amp;micro_ac_power);
 	power_supply_unregister(&amp;micro_batt_power);
 	cancel_delayed_work_sync(&amp;mb-&gt;update);
<span class="p_add">+	destroy_workqueue(mb-&gt;wq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index 21fc233c7d61..176dab2e4c16 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> static int lp8788_psy_register(struct platform_device *pdev,</span>
 	pchg-&gt;battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg-&gt;battery.get_property = lp8788_battery_get_property;
 
<span class="p_del">-	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery))</span>
<span class="p_add">+	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery)) {</span>
<span class="p_add">+		power_supply_unregister(&amp;pchg-&gt;charger);</span>
 		return -EPERM;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/power/twl4030_madc_battery.c b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">index 7ef445a6cfa6..cf907609ec49 100644</span>
<span class="p_header">--- a/drivers/power/twl4030_madc_battery.c</span>
<span class="p_header">+++ b/drivers/power/twl4030_madc_battery.c</span>
<span class="p_chunk">@@ -192,6 +192,7 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 {
 	struct twl4030_madc_battery *twl4030_madc_bat;
 	struct twl4030_madc_bat_platform_data *pdata = pdev-&gt;dev.platform_data;
<span class="p_add">+	int ret = 0;</span>
 
 	twl4030_madc_bat = kzalloc(sizeof(*twl4030_madc_bat), GFP_KERNEL);
 	if (!twl4030_madc_bat)
<span class="p_chunk">@@ -216,9 +217,11 @@</span> <span class="p_context"> static int twl4030_madc_battery_probe(struct platform_device *pdev)</span>
 
 	twl4030_madc_bat-&gt;pdata = pdata;
 	platform_set_drvdata(pdev, twl4030_madc_bat);
<span class="p_del">-	power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	ret = power_supply_register(&amp;pdev-&gt;dev, &amp;twl4030_madc_bat-&gt;psy);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		kfree(twl4030_madc_bat);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int twl4030_madc_battery_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 2d5ab6d969ec..454536c49315 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -441,14 +441,11 @@</span> <span class="p_context"> static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)</span>
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
<span class="p_del">-	struct sas_ha_struct *sha = mvi-&gt;sas;</span>
 	struct sas_task *task = tei-&gt;task;
 	struct domain_device *dev = task-&gt;dev;
 	struct mvs_device *mvi_dev = dev-&gt;lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei-&gt;hdr;
 	struct asd_sas_port *sas_port = dev-&gt;port;
<span class="p_del">-	struct sas_phy *sphy = dev-&gt;phy;</span>
<span class="p_del">-	struct asd_sas_phy *sas_phy = sha-&gt;sas_phy[sphy-&gt;number];</span>
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei-&gt;tag, hdr_tag;
<span class="p_chunk">@@ -468,7 +465,7 @@</span> <span class="p_context"> static int mvs_task_prep_ata(struct mvs_info *mvi,</span>
 	slot-&gt;tx = mvi-&gt;tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP &lt;&lt; TXQ_CMD_SHIFT) |
<span class="p_del">-		(MVS_PHY_ID &lt;&lt; TXQ_PHY_SHIFT) |</span>
<span class="p_add">+		((sas_port-&gt;phy_mask &amp; TXQ_PHY_MASK) &lt;&lt; TXQ_PHY_SHIFT) |</span>
 		(mvi_dev-&gt;taskfileset &lt;&lt; TXQ_SRS_SHIFT);
 	mvi-&gt;tx[mvi-&gt;tx_prod] = cpu_to_le32(del_q);
 
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 05ea0d49a3a3..ad35ccdb92a2 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -3100,6 +3100,7 @@</span> <span class="p_context"> static void scsi_disk_release(struct device *dev)</span>
 	ida_remove(&amp;sd_index_ida, sdkp-&gt;index);
 	spin_unlock(&amp;sd_index_lock);
 
<span class="p_add">+	blk_integrity_unregister(disk);</span>
 	disk-&gt;private_data = NULL;
 	put_disk(disk);
 	put_device(&amp;sdkp-&gt;device-&gt;sdev_gendev);
<span class="p_header">diff --git a/drivers/scsi/sd_dif.c b/drivers/scsi/sd_dif.c</span>
<span class="p_header">index 14c7d42a11c2..5c06d292b94c 100644</span>
<span class="p_header">--- a/drivers/scsi/sd_dif.c</span>
<span class="p_header">+++ b/drivers/scsi/sd_dif.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> void sd_dif_config_host(struct scsi_disk *sdkp)</span>
 
 		disk-&gt;integrity-&gt;flags |= BLK_INTEGRITY_DEVICE_CAPABLE;
 
<span class="p_del">-		if (!sdkp)</span>
<span class="p_add">+		if (!sdkp-&gt;ATO)</span>
 			return;
 
 		if (type == SD_DIF_TYPE3_PROTECTION)
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 4cff0ddc2c25..3483b1d21681 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -741,21 +741,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/spi/spi-imx.c b/drivers/spi/spi-imx.c</span>
<span class="p_header">index fe1b7699fab6..308c2d39b7ce 100644</span>
<span class="p_header">--- a/drivers/spi/spi-imx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-imx.c</span>
<span class="p_chunk">@@ -371,8 +371,6 @@</span> <span class="p_context"> static int __maybe_unused mx51_ecspi_config(struct spi_imx_data *spi_imx,</span>
 	if (spi_imx-&gt;dma_is_inited) {
 		dma = readl(spi_imx-&gt;base + MX51_ECSPI_DMA);
 
<span class="p_del">-		spi_imx-&gt;tx_wml = spi_imx_get_fifosize(spi_imx) / 2;</span>
<span class="p_del">-		spi_imx-&gt;rx_wml = spi_imx_get_fifosize(spi_imx) / 2;</span>
 		spi_imx-&gt;rxt_wml = spi_imx_get_fifosize(spi_imx) / 2;
 		rx_wml_cfg = spi_imx-&gt;rx_wml &lt;&lt; MX51_ECSPI_DMA_RX_WML_OFFSET;
 		tx_wml_cfg = spi_imx-&gt;tx_wml &lt;&lt; MX51_ECSPI_DMA_TX_WML_OFFSET;
<span class="p_chunk">@@ -869,6 +867,8 @@</span> <span class="p_context"> static int spi_imx_sdma_init(struct device *dev, struct spi_imx_data *spi_imx,</span>
 	master-&gt;max_dma_len = MAX_SDMA_BD_BYTES;
 	spi_imx-&gt;bitbang.master-&gt;flags = SPI_MASTER_MUST_RX |
 					 SPI_MASTER_MUST_TX;
<span class="p_add">+	spi_imx-&gt;tx_wml = spi_imx_get_fifosize(spi_imx) / 2;</span>
<span class="p_add">+	spi_imx-&gt;rx_wml = spi_imx_get_fifosize(spi_imx) / 2;</span>
 	spi_imx-&gt;dma_is_inited = 1;
 
 	return 0;
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index 6941e04afb8c..5c854355f621 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -249,7 +249,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/staging/android/sync.c b/drivers/staging/android/sync.c</span>
<span class="p_header">index 7bdb62bf6b40..f83e00c78051 100644</span>
<span class="p_header">--- a/drivers/staging/android/sync.c</span>
<span class="p_header">+++ b/drivers/staging/android/sync.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> void sync_timeline_signal(struct sync_timeline *obj)</span>
 	list_for_each_entry_safe(pt, next, &amp;obj-&gt;active_list_head,
 				 active_list) {
 		if (fence_is_signaled_locked(&amp;pt-&gt;base))
<span class="p_del">-			list_del(&amp;pt-&gt;active_list);</span>
<span class="p_add">+			list_del_init(&amp;pt-&gt;active_list);</span>
 	}
 
 	spin_unlock_irqrestore(&amp;obj-&gt;child_list_lock, flags);
<span class="p_header">diff --git a/drivers/staging/panel/panel.c b/drivers/staging/panel/panel.c</span>
<span class="p_header">index 98325b7b4462..47de68b6334f 100644</span>
<span class="p_header">--- a/drivers/staging/panel/panel.c</span>
<span class="p_header">+++ b/drivers/staging/panel/panel.c</span>
<span class="p_chunk">@@ -314,11 +314,11 @@</span> <span class="p_context"> static unsigned char lcd_bits[LCD_PORTS][LCD_BITS][BIT_STATES];</span>
  * LCD types
  */
 #define LCD_TYPE_NONE		0
<span class="p_del">-#define LCD_TYPE_OLD		1</span>
<span class="p_del">-#define LCD_TYPE_KS0074		2</span>
<span class="p_del">-#define LCD_TYPE_HANTRONIX	3</span>
<span class="p_del">-#define LCD_TYPE_NEXCOM		4</span>
<span class="p_del">-#define LCD_TYPE_CUSTOM		5</span>
<span class="p_add">+#define LCD_TYPE_CUSTOM		1</span>
<span class="p_add">+#define LCD_TYPE_OLD		2</span>
<span class="p_add">+#define LCD_TYPE_KS0074		3</span>
<span class="p_add">+#define LCD_TYPE_HANTRONIX	4</span>
<span class="p_add">+#define LCD_TYPE_NEXCOM		5</span>
 
 /*
  * keypad types
<span class="p_chunk">@@ -481,7 +481,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(keypad_type,</span>
 static int lcd_type = NOT_SET;
 module_param(lcd_type, int, 0000);
 MODULE_PARM_DESC(lcd_type,
<span class="p_del">-		 &quot;LCD type: 0=none, 1=old //, 2=serial ks0074, 3=hantronix //, 4=nexcom //, 5=compiled-in&quot;);</span>
<span class="p_add">+		 &quot;LCD type: 0=none, 1=compiled-in, 2=old, 3=serial ks0074, 4=hantronix, 5=nexcom&quot;);</span>
 
 static int lcd_height = NOT_SET;
 module_param(lcd_height, int, 0000);
<span class="p_header">diff --git a/drivers/staging/vt6655/rxtx.c b/drivers/staging/vt6655/rxtx.c</span>
<span class="p_header">index b5b0155961f2..baaab3fcae8f 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/rxtx.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/rxtx.c</span>
<span class="p_chunk">@@ -1309,10 +1309,18 @@</span> <span class="p_context"> int vnt_generate_fifo_header(struct vnt_private *priv, u32 dma_idx,</span>
 			    priv-&gt;hw-&gt;conf.chandef.chan-&gt;hw_value);
 	}
 
<span class="p_del">-	if (current_rate &gt; RATE_11M)</span>
<span class="p_del">-		pkt_type = (u8)priv-&gt;byPacketType;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (current_rate &gt; RATE_11M) {</span>
<span class="p_add">+		if (info-&gt;band == IEEE80211_BAND_5GHZ) {</span>
<span class="p_add">+			pkt_type = PK_TYPE_11A;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (tx_rate-&gt;flags &amp; IEEE80211_TX_RC_USE_CTS_PROTECT)</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GB;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GA;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
 		pkt_type = PK_TYPE_11B;
<span class="p_add">+	}</span>
 
 	/*Set fifo controls */
 	if (pkt_type == PK_TYPE_11A)
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index d836de200a03..15cfcd6b9343 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -264,40 +264,32 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 	struct se_device *se_dev = cmd-&gt;se_dev;
 	struct fd_dev *dev = FD_DEV(se_dev);
 	struct file *prot_fd = dev-&gt;fd_prot_file;
<span class="p_del">-	struct scatterlist *sg;</span>
 	loff_t pos = (cmd-&gt;t_task_lba * se_dev-&gt;prot_length);
 	unsigned char *buf;
<span class="p_del">-	u32 prot_size, len, size;</span>
<span class="p_del">-	int rc, ret = 1, i;</span>
<span class="p_add">+	u32 prot_size;</span>
<span class="p_add">+	int rc, ret = 1;</span>
 
 	prot_size = (cmd-&gt;data_length / se_dev-&gt;dev_attrib.block_size) *
 		     se_dev-&gt;prot_length;
 
 	if (!is_write) {
<span class="p_del">-		fd_prot-&gt;prot_buf = vzalloc(prot_size);</span>
<span class="p_add">+		fd_prot-&gt;prot_buf = kzalloc(prot_size, GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_buf) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_buf\n&quot;);
 			return -ENOMEM;
 		}
 		buf = fd_prot-&gt;prot_buf;
 
<span class="p_del">-		fd_prot-&gt;prot_sg_nents = cmd-&gt;t_prot_nents;</span>
<span class="p_del">-		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist) *</span>
<span class="p_del">-					   fd_prot-&gt;prot_sg_nents, GFP_KERNEL);</span>
<span class="p_add">+		fd_prot-&gt;prot_sg_nents = 1;</span>
<span class="p_add">+		fd_prot-&gt;prot_sg = kzalloc(sizeof(struct scatterlist),</span>
<span class="p_add">+					   GFP_KERNEL);</span>
 		if (!fd_prot-&gt;prot_sg) {
 			pr_err(&quot;Unable to allocate fd_prot-&gt;prot_sg\n&quot;);
<span class="p_del">-			vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+			kfree(fd_prot-&gt;prot_buf);</span>
 			return -ENOMEM;
 		}
<span class="p_del">-		size = prot_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_sg(fd_prot-&gt;prot_sg, sg, fd_prot-&gt;prot_sg_nents, i) {</span>
<span class="p_del">-</span>
<span class="p_del">-			len = min_t(u32, PAGE_SIZE, size);</span>
<span class="p_del">-			sg_set_buf(sg, buf, len);</span>
<span class="p_del">-			size -= len;</span>
<span class="p_del">-			buf += len;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		sg_init_table(fd_prot-&gt;prot_sg, fd_prot-&gt;prot_sg_nents);</span>
<span class="p_add">+		sg_set_buf(fd_prot-&gt;prot_sg, buf, prot_size);</span>
 	}
 
 	if (is_write) {
<span class="p_chunk">@@ -318,7 +310,7 @@</span> <span class="p_context"> static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,</span>
 
 	if (is_write || ret &lt; 0) {
 		kfree(fd_prot-&gt;prot_sg);
<span class="p_del">-		vfree(fd_prot-&gt;prot_buf);</span>
<span class="p_add">+		kfree(fd_prot-&gt;prot_buf);</span>
 	}
 
 	return ret;
<span class="p_chunk">@@ -544,6 +536,56 @@</span> <span class="p_context"> fd_execute_write_same(struct se_cmd *cmd)</span>
 	return 0;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+fd_do_prot_fill(struct se_device *se_dev, sector_t lba, sector_t nolb,</span>
<span class="p_add">+		void *buf, size_t bufsize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fd_dev *fd_dev = FD_DEV(se_dev);</span>
<span class="p_add">+	struct file *prot_fd = fd_dev-&gt;fd_prot_file;</span>
<span class="p_add">+	sector_t prot_length, prot;</span>
<span class="p_add">+	loff_t pos = lba * se_dev-&gt;prot_length;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!prot_fd) {</span>
<span class="p_add">+		pr_err(&quot;Unable to locate fd_dev-&gt;fd_prot_file\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	prot_length = nolb * se_dev-&gt;prot_length;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (prot = 0; prot &lt; prot_length;) {</span>
<span class="p_add">+		sector_t len = min_t(sector_t, bufsize, prot_length - prot);</span>
<span class="p_add">+		ssize_t ret = kernel_write(prot_fd, buf, len, pos + prot);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret != len) {</span>
<span class="p_add">+			pr_err(&quot;vfs_write to prot file failed: %zd\n&quot;, ret);</span>
<span class="p_add">+			return ret &lt; 0 ? ret : -ENODEV;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		prot += ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+fd_do_prot_unmap(struct se_cmd *cmd, sector_t lba, sector_t nolb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = (void *)__get_free_page(GFP_KERNEL);</span>
<span class="p_add">+	if (!buf) {</span>
<span class="p_add">+		pr_err(&quot;Unable to allocate FILEIO prot buf\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(buf, 0xff, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = fd_do_prot_fill(cmd-&gt;se_dev, lba, nolb, buf, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	free_page((unsigned long)buf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static sense_reason_t
 fd_do_unmap(struct se_cmd *cmd, void *priv, sector_t lba, sector_t nolb)
 {
<span class="p_chunk">@@ -551,6 +593,12 @@</span> <span class="p_context"> fd_do_unmap(struct se_cmd *cmd, void *priv, sector_t lba, sector_t nolb)</span>
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
 	int ret;
 
<span class="p_add">+	if (cmd-&gt;se_dev-&gt;dev_attrib.pi_prot_type) {</span>
<span class="p_add">+		ret = fd_do_prot_unmap(cmd, lba, nolb);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (S_ISBLK(inode-&gt;i_mode)) {
 		/* The backend is block device, use discard */
 		struct block_device *bdev = inode-&gt;i_bdev;
<span class="p_chunk">@@ -653,11 +701,11 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						 0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 			kfree(fd_prot.prot_sg);
<span class="p_del">-			vfree(fd_prot.prot_buf);</span>
<span class="p_add">+			kfree(fd_prot.prot_buf);</span>
 		}
 	} else {
 		memset(&amp;fd_prot, 0, sizeof(struct fd_prot));
<span class="p_chunk">@@ -673,7 +721,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 						  0, fd_prot.prot_sg, 0);
 			if (rc) {
 				kfree(fd_prot.prot_sg);
<span class="p_del">-				vfree(fd_prot.prot_buf);</span>
<span class="p_add">+				kfree(fd_prot.prot_buf);</span>
 				return rc;
 			}
 		}
<span class="p_chunk">@@ -709,7 +757,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 
 	if (ret &lt; 0) {
 		kfree(fd_prot.prot_sg);
<span class="p_del">-		vfree(fd_prot.prot_buf);</span>
<span class="p_add">+		kfree(fd_prot.prot_buf);</span>
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	}
 
<span class="p_chunk">@@ -873,48 +921,28 @@</span> <span class="p_context"> static int fd_init_prot(struct se_device *dev)</span>
 
 static int fd_format_prot(struct se_device *dev)
 {
<span class="p_del">-	struct fd_dev *fd_dev = FD_DEV(dev);</span>
<span class="p_del">-	struct file *prot_fd = fd_dev-&gt;fd_prot_file;</span>
<span class="p_del">-	sector_t prot_length, prot;</span>
 	unsigned char *buf;
<span class="p_del">-	loff_t pos = 0;</span>
 	int unit_size = FDBD_FORMAT_UNIT_SIZE * dev-&gt;dev_attrib.block_size;
<span class="p_del">-	int rc, ret = 0, size, len;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!dev-&gt;dev_attrib.pi_prot_type) {
 		pr_err(&quot;Unable to format_prot while pi_prot_type == 0\n&quot;);
 		return -ENODEV;
 	}
<span class="p_del">-	if (!prot_fd) {</span>
<span class="p_del">-		pr_err(&quot;Unable to locate fd_dev-&gt;fd_prot_file\n&quot;);</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-	}</span>
 
 	buf = vzalloc(unit_size);
 	if (!buf) {
 		pr_err(&quot;Unable to allocate FILEIO prot buf\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	prot_length = (dev-&gt;transport-&gt;get_blocks(dev) + 1) * dev-&gt;prot_length;</span>
<span class="p_del">-	size = prot_length;</span>
 
 	pr_debug(&quot;Using FILEIO prot_length: %llu\n&quot;,
<span class="p_del">-		 (unsigned long long)prot_length);</span>
<span class="p_add">+		 (unsigned long long)(dev-&gt;transport-&gt;get_blocks(dev) + 1) *</span>
<span class="p_add">+					dev-&gt;prot_length);</span>
 
 	memset(buf, 0xff, unit_size);
<span class="p_del">-	for (prot = 0; prot &lt; prot_length; prot += unit_size) {</span>
<span class="p_del">-		len = min(unit_size, size);</span>
<span class="p_del">-		rc = kernel_write(prot_fd, buf, len, pos);</span>
<span class="p_del">-		if (rc != len) {</span>
<span class="p_del">-			pr_err(&quot;vfs_write to prot file failed: %d\n&quot;, rc);</span>
<span class="p_del">-			ret = -ENODEV;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		pos += len;</span>
<span class="p_del">-		size -= len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_add">+	ret = fd_do_prot_fill(dev, 0, dev-&gt;transport-&gt;get_blocks(dev) + 1,</span>
<span class="p_add">+			      buf, unit_size);</span>
 	vfree(buf);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index 36b471389169..48de05366645 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -299,7 +299,7 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -401,11 +401,16 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd)</span>
 
 	/*
 	 * Handle early failure in transport_generic_request_failure(),
<span class="p_del">-	 * which will not have taken -&gt;caw_mutex yet..</span>
<span class="p_add">+	 * which will not have taken -&gt;caw_sem yet..</span>
 	 */
<span class="p_del">-	if (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg)</span>
<span class="p_add">+	if (!success &amp;&amp; (!cmd-&gt;t_data_sg || !cmd-&gt;t_bidi_data_sg))</span>
 		return TCM_NO_SENSE;
 	/*
<span class="p_add">+	 * Handle special case for zero-length COMPARE_AND_WRITE</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cmd-&gt;data_length)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/*</span>
 	 * Immediately exit + release dev-&gt;caw_sem if command has already
 	 * been failed with a non-zero SCSI status.
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index ac3cbabdbdf0..f786de0290db 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1615,11 +1615,11 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	transport_complete_task_attr(cmd);
 	/*
 	 * Handle special case for COMPARE_AND_WRITE failure, where the
<span class="p_del">-	 * callback is expected to drop the per device -&gt;caw_mutex.</span>
<span class="p_add">+	 * callback is expected to drop the per device -&gt;caw_sem.</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1975,8 +1975,12 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd);</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
 		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {
<span class="p_add">+			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+			    !cmd-&gt;data_length)</span>
<span class="p_add">+				goto queue_rsp;</span>
<span class="p_add">+</span>
 			return;
 		} else if (rc) {
 			ret = transport_send_check_condition_and_sense(cmd,
<span class="p_chunk">@@ -1990,6 +1994,7 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 		}
 	}
 
<span class="p_add">+queue_rsp:</span>
 	switch (cmd-&gt;data_direction) {
 	case DMA_FROM_DEVICE:
 		spin_lock(&amp;cmd-&gt;se_lun-&gt;lun_sep_lock);
<span class="p_chunk">@@ -2094,6 +2099,16 @@</span> <span class="p_context"> static inline void transport_reset_sgl_orig(struct se_cmd *cmd)</span>
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
 	if (cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Release special case READ buffer payload required for</span>
<span class="p_add">+		 * SG_TO_MEM_NOALLOC to function with COMPARE_AND_WRITE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) {</span>
<span class="p_add">+			transport_free_sgl(cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+					   cmd-&gt;t_bidi_data_nents);</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_sg = NULL;</span>
<span class="p_add">+			cmd-&gt;t_bidi_data_nents = 0;</span>
<span class="p_add">+		}</span>
 		transport_reset_sgl_orig(cmd);
 		return;
 	}
<span class="p_chunk">@@ -2246,6 +2261,7 @@</span> <span class="p_context"> sense_reason_t</span>
 transport_generic_new_cmd(struct se_cmd *cmd)
 {
 	int ret = 0;
<span class="p_add">+	bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
<span class="p_chunk">@@ -2254,7 +2270,6 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 	 */
 	if (!(cmd-&gt;se_cmd_flags &amp; SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &amp;&amp;
 	    cmd-&gt;data_length) {
<span class="p_del">-		bool zero_flag = !(cmd-&gt;se_cmd_flags &amp; SCF_SCSI_DATA_CDB);</span>
 
 		if ((cmd-&gt;se_cmd_flags &amp; SCF_BIDI) ||
 		    (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE)) {
<span class="p_chunk">@@ -2285,6 +2300,20 @@</span> <span class="p_context"> transport_generic_new_cmd(struct se_cmd *cmd)</span>
 				       cmd-&gt;data_length, zero_flag);
 		if (ret &lt; 0)
 			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_add">+	} else if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_add">+		    cmd-&gt;data_length) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Special case for COMPARE_AND_WRITE with fabrics</span>
<span class="p_add">+		 * using SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u32 caw_length = cmd-&gt;t_task_nolb *</span>
<span class="p_add">+				 cmd-&gt;se_dev-&gt;dev_attrib.block_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alloc_sgl(&amp;cmd-&gt;t_bidi_data_sg,</span>
<span class="p_add">+				       &amp;cmd-&gt;t_bidi_data_nents,</span>
<span class="p_add">+				       caw_length, zero_flag);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
 	}
 	/*
 	 * If this command is not a write we can execute it right here,
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index a051a7a2b1bd..a81f9dd7ee97 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -262,7 +262,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -408,7 +410,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -422,7 +424,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -820,7 +822,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index b4bfa3ac4b12..95409aacc076 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3397,10 +3397,10 @@</span> <span class="p_context"> int usb_port_resume(struct usb_device *udev, pm_message_t msg)</span>
 	if (status) {
 		dev_dbg(&amp;port_dev-&gt;dev, &quot;can&#39;t resume, status %d\n&quot;, status);
 	} else {
<span class="p_del">-		/* drive resume for at least 20 msec */</span>
<span class="p_add">+		/* drive resume for USB_RESUME_TIMEOUT msec */</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;usb %sresume\n&quot;,
 				(PMSG_IS_AUTO(msg) ? &quot;auto-&quot; : &quot;&quot;));
<span class="p_del">-		msleep(25);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/printer.c b/drivers/usb/gadget/legacy/printer.c</span>
<span class="p_header">index 90545980542f..6385c198c134 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/printer.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/printer.c</span>
<span class="p_chunk">@@ -1031,6 +1031,15 @@</span> <span class="p_context"> unknown:</span>
 		break;
 	}
 	/* host either stalls (value &lt; 0) or reports success */
<span class="p_add">+	if (value &gt;= 0) {</span>
<span class="p_add">+		req-&gt;length = value;</span>
<span class="p_add">+		req-&gt;zero = value &lt; wLength;</span>
<span class="p_add">+		value = usb_ep_queue(cdev-&gt;gadget-&gt;ep0, req, GFP_ATOMIC);</span>
<span class="p_add">+		if (value &lt; 0) {</span>
<span class="p_add">+			ERROR(dev, &quot;%s:%d Error!\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+			req-&gt;status = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return value;
 }
 
<span class="p_header">diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">index 38bfeedae1d0..002ac2944d24 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_chunk">@@ -792,12 +792,12 @@</span> <span class="p_context"> static irqreturn_t ehci_irq (struct usb_hcd *hcd)</span>
 					ehci-&gt;reset_done[i] == 0))
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make hub_wq collect PORT_STAT_C_SUSPEND to</span>
<span class="p_del">-			 * stop that signaling.  Use 5 ms extra for safety,</span>
<span class="p_del">-			 * like usb_port_resume() does.</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT msec resume signaling from</span>
<span class="p_add">+			 * this port, and make hub_wq collect</span>
<span class="p_add">+			 * PORT_STAT_C_SUSPEND to stop that signaling.</span>
 			 */
<span class="p_del">-			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);</span>
<span class="p_add">+			ehci-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, &quot;port %d remote wakeup\n&quot;, i + 1);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, i);
<span class="p_header">diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">index 118edb7bdca2..d96d69f805ea 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hub.c</span>
<span class="p_chunk">@@ -471,10 +471,13 @@</span> <span class="p_context"> static int ehci_bus_resume (struct usb_hcd *hcd)</span>
 		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 	}
 
<span class="p_del">-	/* msleep for 20ms only if code is trying to resume port */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * msleep for USB_RESUME_TIMEOUT ms only if code is trying to resume</span>
<span class="p_add">+	 * port</span>
<span class="p_add">+	 */</span>
 	if (resume_needed) {
 		spin_unlock_irq(&amp;ehci-&gt;lock);
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		spin_lock_irq(&amp;ehci-&gt;lock);
 		if (ehci-&gt;shutdown)
 			goto shutdown;
<span class="p_chunk">@@ -942,7 +945,7 @@</span> <span class="p_context"> int ehci_hub_control(</span>
 			temp &amp;= ~PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 			usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 			break;
<span class="p_header">diff --git a/drivers/usb/host/fotg210-hcd.c b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">index ecf02b2623e8..c4794e378ea7 100644</span>
<span class="p_header">--- a/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fotg210-hcd.c</span>
<span class="p_chunk">@@ -1595,7 +1595,7 @@</span> <span class="p_context"> static int fotg210_hub_control(</span>
 			/* resume signaling for 20 msec */
 			fotg210_writel(fotg210, temp | PORT_RESUME, status_reg);
 			fotg210-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fotg210-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/fusbh200-hcd.c b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">index 664d2aa1239c..c9eb18b9973c 100644</span>
<span class="p_header">--- a/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/fusbh200-hcd.c</span>
<span class="p_chunk">@@ -1550,10 +1550,9 @@</span> <span class="p_context"> static int fusbh200_hub_control (</span>
 			if ((temp &amp; PORT_PE) == 0)
 				goto error;
 
<span class="p_del">-			/* resume signaling for 20 msec */</span>
 			fusbh200_writel(fusbh200, temp | PORT_RESUME, status_reg);
 			fusbh200-&gt;reset_done[wIndex] = jiffies
<span class="p_del">-					+ msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;fusbh200-&gt;port_c_suspend);
<span class="p_header">diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">index 31c9c4d0fa0b..1613a1f69480 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_chunk">@@ -1487,7 +1487,7 @@</span> <span class="p_context"> static int isp116x_bus_resume(struct usb_hcd *hcd)</span>
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
 
 	hcd-&gt;state = HC_STATE_RESUMING;
<span class="p_del">-	msleep(20);</span>
<span class="p_add">+	msleep(USB_RESUME_TIMEOUT);</span>
 
 	/* Go operational */
 	spin_lock_irq(&amp;isp116x-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">index 036924e640f5..3fc560c30d08 100644</span>
<span class="p_header">--- a/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/oxu210hp-hcd.c</span>
<span class="p_chunk">@@ -2500,11 +2500,12 @@</span> <span class="p_context"> static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)</span>
 					|| oxu-&gt;reset_done[i] != 0)
 				continue;
 
<span class="p_del">-			/* start 20 msec resume signaling from this port,</span>
<span class="p_del">-			 * and make hub_wq collect PORT_STAT_C_SUSPEND to</span>
<span class="p_add">+			/* start USB_RESUME_TIMEOUT resume signaling from this</span>
<span class="p_add">+			 * port, and make hub_wq collect PORT_STAT_C_SUSPEND to</span>
 			 * stop that signaling.
 			 */
<span class="p_del">-			oxu-&gt;reset_done[i] = jiffies + msecs_to_jiffies(20);</span>
<span class="p_add">+			oxu-&gt;reset_done[i] = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			oxu_dbg(oxu, &quot;port %d remote wakeup\n&quot;, i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, oxu-&gt;reset_done[i]);
 		}
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index c4bcfaedeec9..2dcf197d304c 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -2300,7 +2300,7 @@</span> <span class="p_context"> static int r8a66597_bus_resume(struct usb_hcd *hcd)</span>
 		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
 		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
<span class="p_del">-		msleep(50);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">index 25fb1da8d3d7..573355498193 100644</span>
<span class="p_header">--- a/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_chunk">@@ -1259,7 +1259,7 @@</span> <span class="p_context"> sl811h_hub_control(</span>
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 
 			mod_timer(&amp;sl811-&gt;timer, jiffies
<span class="p_del">-					+ msecs_to_jiffies(20));</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
<span class="p_header">diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">index 93e17b12fb33..98c66d88ebde 100644</span>
<span class="p_header">--- a/drivers/usb/host/uhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/uhci-hub.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void uhci_check_ports(struct uhci_hcd *uhci)</span>
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
<span class="p_del">-						msecs_to_jiffies(25);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				usb_hcd_start_port_resume(
 						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
<span class="p_chunk">@@ -337,7 +337,8 @@</span> <span class="p_context"> static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 			uhci_finish_suspend(uhci, port, port_addr);
 
 			/* USB v2.0 7.1.7.5 */
<span class="p_del">-			uhci-&gt;ports_timeout = jiffies + msecs_to_jiffies(50);</span>
<span class="p_add">+			uhci-&gt;ports_timeout = jiffies +</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			/* UHCI has no power switching */
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 2a924d500d8a..7dd25cedef94 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1574,7 +1574,7 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		} else {
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
<span class="p_del">-				msecs_to_jiffies(20);</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(faked_port_index, &amp;bus_state-&gt;resuming_ports);
 			mod_timer(&amp;hcd-&gt;rh_timer,
 				  bus_state-&gt;resume_done[faked_port_index]);
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index 34cce3e38c49..fa5185868c05 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -99,6 +99,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/io.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/usb.h&gt;</span>
 
 #include &quot;musb_core.h&quot;
 
<span class="p_chunk">@@ -562,7 +563,7 @@</span> <span class="p_context"> static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,</span>
 						(USB_PORT_STAT_C_SUSPEND &lt;&lt; 16)
 						| MUSB_PORT_STAT_RESUME;
 				musb-&gt;rh_timer = jiffies
<span class="p_del">-						 + msecs_to_jiffies(20);</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 				musb-&gt;need_finish_resume = 1;
 
 				musb-&gt;xceiv-&gt;otg-&gt;state = OTG_STATE_A_HOST;
<span class="p_chunk">@@ -1596,16 +1597,30 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 		is_host_active(musb) ? &quot;host&quot; : &quot;peripheral&quot;,
 		musb-&gt;int_usb, musb-&gt;int_tx, musb-&gt;int_rx);
 
<span class="p_del">-	/* the core can interrupt us for multiple reasons; docs have</span>
<span class="p_del">-	 * a generic interrupt flowchart to follow</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * According to Mentor Graphics&#39; documentation, flowchart on page 98,</span>
<span class="p_add">+	 * IRQ should be handled as follows:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * . Resume IRQ</span>
<span class="p_add">+	 * . Session Request IRQ</span>
<span class="p_add">+	 * . VBUS Error IRQ</span>
<span class="p_add">+	 * . Suspend IRQ</span>
<span class="p_add">+	 * . Connect IRQ</span>
<span class="p_add">+	 * . Disconnect IRQ</span>
<span class="p_add">+	 * . Reset/Babble IRQ</span>
<span class="p_add">+	 * . SOF IRQ (we&#39;re not using this one)</span>
<span class="p_add">+	 * . Endpoint 0 IRQ</span>
<span class="p_add">+	 * . TX Endpoints</span>
<span class="p_add">+	 * . RX Endpoints</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We will be following that flowchart in order to avoid any problems</span>
<span class="p_add">+	 * that might arise with internal Finite State Machine.</span>
 	 */
<span class="p_add">+</span>
 	if (musb-&gt;int_usb)
 		retval |= musb_stage0_irq(musb, musb-&gt;int_usb,
 				devctl);
 
<span class="p_del">-	/* &quot;stage 1&quot; is handling endpoint irqs */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* handle endpoint 0 first */</span>
 	if (musb-&gt;int_tx &amp; 1) {
 		if (is_host_active(musb))
 			retval |= musb_h_ep0_irq(musb);
<span class="p_chunk">@@ -1613,37 +1628,31 @@</span> <span class="p_context"> irqreturn_t musb_interrupt(struct musb *musb)</span>
 			retval |= musb_g_ep0_irq(musb);
 	}
 
<span class="p_del">-	/* RX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval = ep-&gt;rx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (is_host_active(musb))
<span class="p_del">-				musb_host_rx(musb, ep_num);</span>
<span class="p_add">+				musb_host_tx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_rx(musb, ep_num);</span>
<span class="p_add">+				musb_g_tx(musb, ep_num);</span>
 		}
<span class="p_del">-</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
 
<span class="p_del">-	/* TX on endpoints 1-15 */</span>
<span class="p_del">-	reg = musb-&gt;int_tx &gt;&gt; 1;</span>
<span class="p_add">+	reg = musb-&gt;int_rx &gt;&gt; 1;</span>
 	ep_num = 1;
 	while (reg) {
 		if (reg &amp; 1) {
<span class="p_del">-			/* musb_ep_select(musb-&gt;mregs, ep_num); */</span>
<span class="p_del">-			/* REVISIT just retval |= ep-&gt;tx_irq(...) */</span>
 			retval = IRQ_HANDLED;
 			if (is_host_active(musb))
<span class="p_del">-				musb_host_tx(musb, ep_num);</span>
<span class="p_add">+				musb_host_rx(musb, ep_num);</span>
 			else
<span class="p_del">-				musb_g_tx(musb, ep_num);</span>
<span class="p_add">+				musb_g_rx(musb, ep_num);</span>
 		}
<span class="p_add">+</span>
 		reg &gt;&gt;= 1;
 		ep_num++;
 	}
<span class="p_chunk">@@ -2460,7 +2469,7 @@</span> <span class="p_context"> static int musb_resume(struct device *dev)</span>
 	if (musb-&gt;need_finish_resume) {
 		musb-&gt;need_finish_resume = 0;
 		schedule_delayed_work(&amp;musb-&gt;finish_resume_work,
<span class="p_del">-				      msecs_to_jiffies(20));</span>
<span class="p_add">+				      msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index b072420e44f5..a9c47315f06b 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> void musb_port_suspend(struct musb *musb, bool do_suspend)</span>
 		/* later, GetPortStatus will stop RESUME signaling */
 		musb-&gt;port1_status |= MUSB_PORT_STAT_RESUME;
 		schedule_delayed_work(&amp;musb-&gt;finish_resume_work,
<span class="p_del">-				      msecs_to_jiffies(20));</span>
<span class="p_add">+				      msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c</span>
<span class="p_header">index 2f9735b35338..d1cd6b50f520 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy.c</span>
<span class="p_chunk">@@ -81,7 +81,9 @@</span> <span class="p_context"> static void devm_usb_phy_release(struct device *dev, void *res)</span>
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
<span class="p_del">-	return res == match_data;</span>
<span class="p_add">+	struct usb_phy **phy = res;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *phy == match_data;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 995986b8e36b..d925f55e4857 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -862,6 +862,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -924,10 +925,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			retval = IS_ERR((void *)error) ?
 				PTR_ERR((void*)error) : -EINVAL;
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index a684086c3c81..4623a55d9c5b 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -6967,12 +6967,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE, delalloc);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index d49fe8a0f6b5..09a566acc10f 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2897,6 +2897,9 @@</span> <span class="p_context"> static int btrfs_extent_same(struct inode *src, u64 loff, u64 len,</span>
 	if (src == dst)
 		return -EINVAL;
 
<span class="p_add">+	if (len == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	btrfs_double_lock(src, loff, dst, dst_loff, len);
 
 	ret = extent_same_check_offsets(src, loff, len);
<span class="p_chunk">@@ -3626,6 +3629,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/btrfs/xattr.c b/fs/btrfs/xattr.c</span>
<span class="p_header">index 47b19465f0dc..01bad724b5f7 100644</span>
<span class="p_header">--- a/fs/btrfs/xattr.c</span>
<span class="p_header">+++ b/fs/btrfs/xattr.c</span>
<span class="p_chunk">@@ -360,22 +360,42 @@</span> <span class="p_context"> const struct xattr_handler *btrfs_xattr_handlers[] = {</span>
 /*
  * Check if the attribute is in a supported namespace.
  *
<span class="p_del">- * This applied after the check for the synthetic attributes in the system</span>
<span class="p_add">+ * This is applied after the check for the synthetic attributes in the system</span>
  * namespace.
  */
<span class="p_del">-static bool btrfs_is_valid_xattr(const char *name)</span>
<span class="p_add">+static int btrfs_is_valid_xattr(const char *name)</span>
 {
<span class="p_del">-	return !strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_del">-			XATTR_SECURITY_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN) ||</span>
<span class="p_del">-	       !strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN) ||</span>
<span class="p_del">-		!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN);</span>
<span class="p_add">+	int len = strlen(name);</span>
<span class="p_add">+	int prefixlen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strncmp(name, XATTR_SECURITY_PREFIX,</span>
<span class="p_add">+			XATTR_SECURITY_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SECURITY_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_SYSTEM_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_TRUSTED_PREFIX, XATTR_TRUSTED_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_TRUSTED_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_USER_PREFIX, XATTR_USER_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_USER_PREFIX_LEN;</span>
<span class="p_add">+	else if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))</span>
<span class="p_add">+		prefixlen = XATTR_BTRFS_PREFIX_LEN;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The name cannot consist of just prefix</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (len &lt;= prefixlen)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,
 		       void *buffer, size_t size)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	/*
 	 * If this is a request for a synthetic attribute in the system.*
 	 * namespace use the generic infrastructure to resolve a handler
<span class="p_chunk">@@ -384,8 +404,9 @@</span> <span class="p_context"> ssize_t btrfs_getxattr(struct dentry *dentry, const char *name,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_getxattr(dentry, name, buffer, size);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	return __btrfs_getxattr(dentry-&gt;d_inode, name, buffer, size);
 }
 
<span class="p_chunk">@@ -393,6 +414,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 		   size_t size, int flags)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -409,8 +431,9 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_setxattr(dentry, name, value, size, flags);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_chunk">@@ -426,6 +449,7 @@</span> <span class="p_context"> int btrfs_setxattr(struct dentry *dentry, const char *name, const void *value,</span>
 int btrfs_removexattr(struct dentry *dentry, const char *name)
 {
 	struct btrfs_root *root = BTRFS_I(dentry-&gt;d_inode)-&gt;root;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The permission on security.* and system.* is not checked
<span class="p_chunk">@@ -442,8 +466,9 @@</span> <span class="p_context"> int btrfs_removexattr(struct dentry *dentry, const char *name)</span>
 	if (!strncmp(name, XATTR_SYSTEM_PREFIX, XATTR_SYSTEM_PREFIX_LEN))
 		return generic_removexattr(dentry, name);
 
<span class="p_del">-	if (!btrfs_is_valid_xattr(name))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+	ret = btrfs_is_valid_xattr(name);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!strncmp(name, XATTR_BTRFS_PREFIX, XATTR_BTRFS_PREFIX_LEN))
 		return btrfs_set_prop(dentry-&gt;d_inode, name,
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 2291923dae4e..5e8ae7811220 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1865,7 +1865,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
<span class="p_chunk">@@ -1889,14 +1889,14 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return retval;
 		if (retval == 1) {
 			retval = 0;
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1908,14 +1908,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
<span class="p_chunk">@@ -1931,6 +1932,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/lockd/svcsubs.c b/fs/lockd/svcsubs.c</span>
<span class="p_header">index d12ff4e2dbe7..251a1f04be2f 100644</span>
<span class="p_header">--- a/fs/lockd/svcsubs.c</span>
<span class="p_header">+++ b/fs/lockd/svcsubs.c</span>
<span class="p_chunk">@@ -31,7 +31,7 @@</span> <span class="p_context"></span>
 static struct hlist_head	nlm_files[FILE_NRHASH];
 static DEFINE_MUTEX(nlm_file_mutex);
 
<span class="p_del">-#ifdef NFSD_DEBUG</span>
<span class="p_add">+#ifdef CONFIG_SUNRPC_DEBUG</span>
 static inline void nlm_debug_print_fh(char *msg, struct nfs_fh *f)
 {
 	u32 *fhp = (u32*)f-&gt;data;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index bc35b02883bb..3abfbda53574 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1585,7 +1585,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 
 	if (should_follow_link(path-&gt;dentry, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				err = -ECHILD;
 				goto out_err;
 			}
<span class="p_chunk">@@ -3028,7 +3029,8 @@</span> <span class="p_context"> finish_lookup:</span>
 
 	if (should_follow_link(path-&gt;dentry, !symlink_ok)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				error = -ECHILD;
 				goto out;
 			}
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index cd1e9681a0cf..07d0562290a5 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1323,14 +1323,15 @@</span> <span class="p_context"> static inline void namespace_lock(void)</span>
 	down_write(&amp;namespace_sem);
 }
 
<span class="p_add">+enum umount_tree_flags {</span>
<span class="p_add">+	UMOUNT_SYNC = 1,</span>
<span class="p_add">+	UMOUNT_PROPAGATE = 2,</span>
<span class="p_add">+};</span>
 /*
  * mount_lock must be held
  * namespace_sem must be held for write
<span class="p_del">- * how = 0 =&gt; just this tree, don&#39;t propagate</span>
<span class="p_del">- * how = 1 =&gt; propagate; we know that nobody else has reference to any victims</span>
<span class="p_del">- * how = 2 =&gt; lazy umount</span>
  */
<span class="p_del">-void umount_tree(struct mount *mnt, int how)</span>
<span class="p_add">+static void umount_tree(struct mount *mnt, enum umount_tree_flags how)</span>
 {
 	HLIST_HEAD(tmp_list);
 	struct mount *p;
<span class="p_chunk">@@ -1344,7 +1345,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash)
 		list_del_init(&amp;p-&gt;mnt_child);
 
<span class="p_del">-	if (how)</span>
<span class="p_add">+	if (how &amp; UMOUNT_PROPAGATE)</span>
 		propagate_umount(&amp;tmp_list);
 
 	hlist_for_each_entry(p, &amp;tmp_list, mnt_hash) {
<span class="p_chunk">@@ -1352,7 +1353,7 @@</span> <span class="p_context"> void umount_tree(struct mount *mnt, int how)</span>
 		list_del_init(&amp;p-&gt;mnt_list);
 		__touch_mnt_namespace(p-&gt;mnt_ns);
 		p-&gt;mnt_ns = NULL;
<span class="p_del">-		if (how &lt; 2)</span>
<span class="p_add">+		if (how &amp; UMOUNT_SYNC)</span>
 			p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT;
 		if (mnt_has_parent(p)) {
 			hlist_del_init(&amp;p-&gt;mnt_mp_list);
<span class="p_chunk">@@ -1457,14 +1458,14 @@</span> <span class="p_context"> static int do_umount(struct mount *mnt, int flags)</span>
 
 	if (flags &amp; MNT_DETACH) {
 		if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-			umount_tree(mnt, 2);</span>
<span class="p_add">+			umount_tree(mnt, UMOUNT_PROPAGATE);</span>
 		retval = 0;
 	} else {
 		shrink_submounts(mnt);
 		retval = -EBUSY;
 		if (!propagate_mount_busy(mnt, 2)) {
 			if (!list_empty(&amp;mnt-&gt;mnt_list))
<span class="p_del">-				umount_tree(mnt, 1);</span>
<span class="p_add">+				umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 			retval = 0;
 		}
 	}
<span class="p_chunk">@@ -1496,7 +1497,7 @@</span> <span class="p_context"> void __detach_mounts(struct dentry *dentry)</span>
 	lock_mount_hash();
 	while (!hlist_empty(&amp;mp-&gt;m_list)) {
 		mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list);
<span class="p_del">-		umount_tree(mnt, 2);</span>
<span class="p_add">+		umount_tree(mnt, 0);</span>
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
<span class="p_chunk">@@ -1658,7 +1659,7 @@</span> <span class="p_context"> struct mount *copy_tree(struct mount *mnt, struct dentry *dentry,</span>
 out:
 	if (res) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(res, 0);</span>
<span class="p_add">+		umount_tree(res, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 	return q;
<span class="p_chunk">@@ -1682,7 +1683,7 @@</span> <span class="p_context"> void drop_collected_mounts(struct vfsmount *mnt)</span>
 {
 	namespace_lock();
 	lock_mount_hash();
<span class="p_del">-	umount_tree(real_mount(mnt), 0);</span>
<span class="p_add">+	umount_tree(real_mount(mnt), UMOUNT_SYNC);</span>
 	unlock_mount_hash();
 	namespace_unlock();
 }
<span class="p_chunk">@@ -1865,7 +1866,7 @@</span> <span class="p_context"> static int attach_recursive_mnt(struct mount *source_mnt,</span>
  out_cleanup_ids:
 	while (!hlist_empty(&amp;tree_list)) {
 		child = hlist_entry(tree_list.first, struct mount, mnt_hash);
<span class="p_del">-		umount_tree(child, 0);</span>
<span class="p_add">+		umount_tree(child, UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	cleanup_group_ids(source_mnt, NULL);
<span class="p_chunk">@@ -2045,7 +2046,7 @@</span> <span class="p_context"> static int do_loopback(struct path *path, const char *old_name,</span>
 	err = graft_tree(mnt, parent, mp);
 	if (err) {
 		lock_mount_hash();
<span class="p_del">-		umount_tree(mnt, 0);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_SYNC);</span>
 		unlock_mount_hash();
 	}
 out2:
<span class="p_chunk">@@ -2416,7 +2417,7 @@</span> <span class="p_context"> void mark_mounts_for_expiry(struct list_head *mounts)</span>
 	while (!list_empty(&amp;graveyard)) {
 		mnt = list_first_entry(&amp;graveyard, struct mount, mnt_expire);
 		touch_mnt_namespace(mnt-&gt;mnt_ns);
<span class="p_del">-		umount_tree(mnt, 1);</span>
<span class="p_add">+		umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 	}
 	unlock_mount_hash();
 	namespace_unlock();
<span class="p_chunk">@@ -2487,7 +2488,7 @@</span> <span class="p_context"> static void shrink_submounts(struct mount *mnt)</span>
 			m = list_first_entry(&amp;graveyard, struct mount,
 						mnt_expire);
 			touch_mnt_namespace(m-&gt;mnt_ns);
<span class="p_del">-			umount_tree(m, 1);</span>
<span class="p_add">+			umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span>
 		}
 	}
 }
<span class="p_header">diff --git a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c</span>
<span class="p_header">index cb4376b78ed9..5303646f1e7a 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4xdr.c</span>
<span class="p_chunk">@@ -7338,6 +7338,11 @@</span> <span class="p_context"> nfs4_stat_to_errno(int stat)</span>
 	.p_name   = #proc,					\
 }
 
<span class="p_add">+#define STUB(proc)		\</span>
<span class="p_add">+[NFSPROC4_CLNT_##proc] = {	\</span>
<span class="p_add">+	.p_name = #proc,	\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct rpc_procinfo	nfs4_procedures[] = {
 	PROC(READ,		enc_read,		dec_read),
 	PROC(WRITE,		enc_write,		dec_write),
<span class="p_chunk">@@ -7390,6 +7395,7 @@</span> <span class="p_context"> struct rpc_procinfo	nfs4_procedures[] = {</span>
 	PROC(SECINFO_NO_NAME,	enc_secinfo_no_name,	dec_secinfo_no_name),
 	PROC(TEST_STATEID,	enc_test_stateid,	dec_test_stateid),
 	PROC(FREE_STATEID,	enc_free_stateid,	dec_free_stateid),
<span class="p_add">+	STUB(GETDEVICELIST),</span>
 	PROC(BIND_CONN_TO_SESSION,
 			enc_bind_conn_to_session, dec_bind_conn_to_session),
 	PROC(DESTROY_CLIENTID,	enc_destroy_clientid,	dec_destroy_clientid),
<span class="p_header">diff --git a/fs/nfs/read.c b/fs/nfs/read.c</span>
<span class="p_header">index c91a4799c562..beff2769c5c5 100644</span>
<span class="p_header">--- a/fs/nfs/read.c</span>
<span class="p_header">+++ b/fs/nfs/read.c</span>
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> int nfs_readpage(struct file *file, struct page *page)</span>
 	dprintk(&quot;NFS: nfs_readpage (%p %ld@%lu)\n&quot;,
 		page, PAGE_CACHE_SIZE, page_file_index(page));
 	nfs_inc_stats(inode, NFSIOS_VFSREADPAGE);
<span class="p_del">-	nfs_inc_stats(inode, NFSIOS_READPAGES);</span>
<span class="p_add">+	nfs_add_stats(inode, NFSIOS_READPAGES, 1);</span>
 
 	/*
 	 * Try to flush any pending writes to the file..
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index af3af685a9e3..d489ff3f438f 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> static int nfs_do_writepage(struct page *page, struct writeback_control *wbc, st</span>
 	int ret;
 
 	nfs_inc_stats(inode, NFSIOS_VFSWRITEPAGE);
<span class="p_del">-	nfs_inc_stats(inode, NFSIOS_WRITEPAGES);</span>
<span class="p_add">+	nfs_add_stats(inode, NFSIOS_WRITEPAGES, 1);</span>
 
 	nfs_pageio_cond_complete(pgio, page_file_index(page));
 	ret = nfs_page_async_flush(pgio, page, wbc-&gt;sync_mode == WB_SYNC_NONE);
<span class="p_header">diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c</span>
<span class="p_header">index ac71d13c69ef..2cd2d64ff1e8 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4proc.c</span>
<span class="p_chunk">@@ -1028,6 +1028,8 @@</span> <span class="p_context"> nfsd4_fallocate(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 		dprintk(&quot;NFSD: nfsd4_fallocate: couldn&#39;t process stateid!\n&quot;);
 		return status;
 	}
<span class="p_add">+	if (!file)</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
 
 	status = nfsd4_vfs_fallocate(rqstp, &amp;cstate-&gt;current_fh, file,
 				     fallocate-&gt;falloc_offset,
<span class="p_chunk">@@ -1067,6 +1069,8 @@</span> <span class="p_context"> nfsd4_seek(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 		dprintk(&quot;NFSD: nfsd4_seek: couldn&#39;t process stateid!\n&quot;);
 		return status;
 	}
<span class="p_add">+	if (!file)</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
 
 	switch (seek-&gt;seek_whence) {
 	case NFS4_CONTENT_DATA:
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 7cfb905a1e90..ddacc436a77a 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -1162,7 +1162,7 @@</span> <span class="p_context"> hash_sessionid(struct nfs4_sessionid *sessionid)</span>
 	return sid-&gt;sequence % SESSION_HASH_SIZE;
 }
 
<span class="p_del">-#ifdef NFSD_DEBUG</span>
<span class="p_add">+#ifdef CONFIG_SUNRPC_DEBUG</span>
 static inline void
 dump_sessionid(const char *fn, struct nfs4_sessionid *sessionid)
 {
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index 15f7b73e0c0f..281d12640c0b 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -3246,6 +3246,7 @@</span> <span class="p_context"> nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,</span>
 	unsigned long maxcount;
 	struct xdr_stream *xdr = &amp;resp-&gt;xdr;
 	struct file *file = read-&gt;rd_filp;
<span class="p_add">+	struct svc_fh *fhp = read-&gt;rd_fhp;</span>
 	int starting_len = xdr-&gt;buf-&gt;len;
 	struct raparms *ra;
 	__be32 *p;
<span class="p_chunk">@@ -3269,12 +3270,15 @@</span> <span class="p_context"> nfsd4_encode_read(struct nfsd4_compoundres *resp, __be32 nfserr,</span>
 	maxcount = min_t(unsigned long, maxcount, (xdr-&gt;buf-&gt;buflen - xdr-&gt;buf-&gt;len));
 	maxcount = min_t(unsigned long, maxcount, read-&gt;rd_length);
 
<span class="p_del">-	if (!read-&gt;rd_filp) {</span>
<span class="p_add">+	if (read-&gt;rd_filp)</span>
<span class="p_add">+		err = nfsd_permission(resp-&gt;rqstp, fhp-&gt;fh_export,</span>
<span class="p_add">+				fhp-&gt;fh_dentry,</span>
<span class="p_add">+				NFSD_MAY_READ|NFSD_MAY_OWNER_OVERRIDE);</span>
<span class="p_add">+	else</span>
 		err = nfsd_get_tmp_read_open(resp-&gt;rqstp, read-&gt;rd_fhp,
 						&amp;file, &amp;ra);
<span class="p_del">-		if (err)</span>
<span class="p_del">-			goto err_truncate;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto err_truncate;</span>
 
 	if (file-&gt;f_op-&gt;splice_read &amp;&amp; test_bit(RQ_SPLICE_OK, &amp;resp-&gt;rqstp-&gt;rq_flags))
 		err = nfsd4_encode_splice_read(resp, read, file, maxcount);
<span class="p_header">diff --git a/fs/nfsd/nfsd.h b/fs/nfsd/nfsd.h</span>
<span class="p_header">index 33a46a8dfaf7..403d8e14fcaf 100644</span>
<span class="p_header">--- a/fs/nfsd/nfsd.h</span>
<span class="p_header">+++ b/fs/nfsd/nfsd.h</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
 #include &quot;export.h&quot;
 
 #undef ifdebug
<span class="p_del">-#ifdef NFSD_DEBUG</span>
<span class="p_add">+#ifdef CONFIG_SUNRPC_DEBUG</span>
 # define ifdebug(flag)		if (nfsd_debug &amp; NFSDDBG_##flag)
 #else
 # define ifdebug(flag)		if (0)
<span class="p_header">diff --git a/fs/open.c b/fs/open.c</span>
<span class="p_header">index 813be037b412..d45a7b919504 100644</span>
<span class="p_header">--- a/fs/open.c</span>
<span class="p_header">+++ b/fs/open.c</span>
<span class="p_chunk">@@ -570,6 +570,7 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	uid = make_kuid(current_user_ns(), user);
 	gid = make_kgid(current_user_ns(), group);
 
<span class="p_add">+retry_deleg:</span>
 	newattrs.ia_valid =  ATTR_CTIME;
 	if (user != (uid_t) -1) {
 		if (!uid_valid(uid))
<span class="p_chunk">@@ -586,7 +587,6 @@</span> <span class="p_context"> static int chown_common(struct path *path, uid_t user, gid_t group)</span>
 	if (!S_ISDIR(inode-&gt;i_mode))
 		newattrs.ia_valid |=
 			ATTR_KILL_SUID | ATTR_KILL_SGID | ATTR_KILL_PRIV;
<span class="p_del">-retry_deleg:</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	error = security_path_chown(path, uid, gid);
 	if (!error)
<span class="p_header">diff --git a/fs/pnode.h b/fs/pnode.h</span>
<span class="p_header">index 4a246358b031..16afc3d6d2f2 100644</span>
<span class="p_header">--- a/fs/pnode.h</span>
<span class="p_header">+++ b/fs/pnode.h</span>
<span class="p_chunk">@@ -47,7 +47,6 @@</span> <span class="p_context"> int get_dominating_id(struct mount *mnt, const struct path *root);</span>
 unsigned int mnt_get_count(struct mount *mnt);
 void mnt_set_mountpoint(struct mount *, struct mountpoint *,
 			struct mount *);
<span class="p_del">-void umount_tree(struct mount *, int);</span>
 struct mount *copy_tree(struct mount *, struct dentry *, int);
 bool is_path_reachable(struct mount *, struct dentry *,
 			 const struct path *root);
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index bbef17368e49..9f2847cdf3ce 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -199,9 +199,29 @@</span> <span class="p_context"> typedef int s32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index 5f8cc1fa3278..9e1ed2e380b6 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"></span>
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
<span class="p_header">diff --git a/include/kvm/arm_vgic.h b/include/kvm/arm_vgic.h</span>
<span class="p_header">index ac4888dc86bc..36e0f219e507 100644</span>
<span class="p_header">--- a/include/kvm/arm_vgic.h</span>
<span class="p_header">+++ b/include/kvm/arm_vgic.h</span>
<span class="p_chunk">@@ -113,6 +113,7 @@</span> <span class="p_context"> struct vgic_ops {</span>
 	void	(*sync_lr_elrsr)(struct kvm_vcpu *, int, struct vgic_lr);
 	u64	(*get_elrsr)(const struct kvm_vcpu *vcpu);
 	u64	(*get_eisr)(const struct kvm_vcpu *vcpu);
<span class="p_add">+	void	(*clear_eisr)(struct kvm_vcpu *vcpu);</span>
 	u32	(*get_interrupt_status)(const struct kvm_vcpu *vcpu);
 	void	(*enable_underflow)(struct kvm_vcpu *vcpu);
 	void	(*disable_underflow)(struct kvm_vcpu *vcpu);
<span class="p_header">diff --git a/include/linux/bpf.h b/include/linux/bpf.h</span>
<span class="p_header">index bbfceb756452..33b52fb0e20f 100644</span>
<span class="p_header">--- a/include/linux/bpf.h</span>
<span class="p_header">+++ b/include/linux/bpf.h</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> struct bpf_map *bpf_map_get(struct fd f);</span>
 
 /* function argument constraints */
 enum bpf_arg_type {
<span class="p_del">-	ARG_ANYTHING = 0,	/* any argument is ok */</span>
<span class="p_add">+	ARG_DONTCARE = 0,	/* unused argument in helper function */</span>
 
 	/* the following constraints used to prototype
 	 * bpf_map_lookup/update/delete_elem() functions
<span class="p_chunk">@@ -62,6 +62,8 @@</span> <span class="p_context"> enum bpf_arg_type {</span>
 	 */
 	ARG_PTR_TO_STACK,	/* any pointer to eBPF program stack */
 	ARG_CONST_STACK_SIZE,	/* number of bytes accessed from stack */
<span class="p_add">+</span>
<span class="p_add">+	ARG_ANYTHING,		/* any (initialized) argument is ok */</span>
 };
 
 /* type of values returned from helper functions */
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 85ab7d72b54c..5fcc6064247b 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -762,6 +762,7 @@</span> <span class="p_context"> bool skb_try_coalesce(struct sk_buff *to, struct sk_buff *from,</span>
 
 struct sk_buff *__alloc_skb(unsigned int size, gfp_t priority, int flags,
 			    int node);
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size);</span>
 struct sk_buff *build_skb(void *data, unsigned int frag_size);
 static inline struct sk_buff *alloc_skb(unsigned int size,
 					gfp_t priority)
<span class="p_chunk">@@ -2998,6 +2999,18 @@</span> <span class="p_context"> static inline bool __skb_checksum_validate_needed(struct sk_buff *skb,</span>
  */
 #define CHECKSUM_BREAK 76
 
<span class="p_add">+/* Unset checksum-complete</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Unset checksum complete can be done when packet is being modified</span>
<span class="p_add">+ * (uncompressed for instance) and checksum-complete value is</span>
<span class="p_add">+ * invalidated.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void skb_checksum_complete_unset(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_add">+		skb-&gt;ip_summed = CHECKSUM_NONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Validate (init) checksum based on checksum complete.
  *
  * Return values:
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index 058a7698d7e3..335b413e5980 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -205,6 +205,32 @@</span> <span class="p_context"> void usb_put_intf(struct usb_interface *intf);</span>
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB Resume Timer: Every Host controller driver should drive the resume</span>
<span class="p_add">+ * signalling on the bus for the amount of time defined by this macro.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * That way we will have a &#39;stable&#39; behavior among all HCDs supported by Linux.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that the USB Specification states we should drive resume for *at least*</span>
<span class="p_add">+ * 20 ms, but it doesn&#39;t give an upper bound. This creates two possible</span>
<span class="p_add">+ * situations which we want to avoid:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes</span>
<span class="p_add">+ * us to fail USB Electrical Tests, thus failing Certification</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,</span>
<span class="p_add">+ * and while we can argue that&#39;s against the USB Specification, we don&#39;t have</span>
<span class="p_add">+ * control over which devices a certification laboratory will be using for</span>
<span class="p_add">+ * certification. If CertLab uses a device which was tested against Windows and</span>
<span class="p_add">+ * that happens to have relaxed resume signalling rules, we might fall into</span>
<span class="p_add">+ * situations where we fail interoperability and electrical tests.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to avoid both conditions, we&#39;re using a 40 ms resume timeout, which</span>
<span class="p_add">+ * should cope with both LPJ calibration errors and devices not following every</span>
<span class="p_add">+ * detail of the USB Specification.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_RESUME_TIMEOUT	40 /* ms */</span>
<span class="p_add">+</span>
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 672150b6aaf5..985ca4c907fe 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -524,7 +524,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/include/uapi/linux/nfsd/debug.h b/include/uapi/linux/nfsd/debug.h</span>
<span class="p_header">index 1fdc95bb2375..c021bbaf21b7 100644</span>
<span class="p_header">--- a/include/uapi/linux/nfsd/debug.h</span>
<span class="p_header">+++ b/include/uapi/linux/nfsd/debug.h</span>
<span class="p_chunk">@@ -12,14 +12,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/sunrpc/debug.h&gt;
 
 /*
<span class="p_del">- * Enable debugging for nfsd.</span>
<span class="p_del">- * Requires RPC_DEBUG.</span>
<span class="p_del">- */</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_SUNRPC_DEBUG)</span>
<span class="p_del">-# define NFSD_DEBUG		1</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * knfsd debug flags
  */
 #define NFSDDBG_SOCK		0x0001
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 36508e69e92a..5d8ea3d8a897 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -755,7 +755,7 @@</span> <span class="p_context"> static int check_func_arg(struct verifier_env *env, u32 regno,</span>
 	enum bpf_reg_type expected_type;
 	int err = 0;
 
<span class="p_del">-	if (arg_type == ARG_ANYTHING)</span>
<span class="p_add">+	if (arg_type == ARG_DONTCARE)</span>
 		return 0;
 
 	if (reg-&gt;type == NOT_INIT) {
<span class="p_chunk">@@ -763,6 +763,9 @@</span> <span class="p_context"> static int check_func_arg(struct verifier_env *env, u32 regno,</span>
 		return -EACCES;
 	}
 
<span class="p_add">+	if (arg_type == ARG_ANYTHING)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (arg_type == ARG_PTR_TO_STACK || arg_type == ARG_PTR_TO_MAP_KEY ||
 	    arg_type == ARG_PTR_TO_MAP_VALUE) {
 		expected_type = PTR_TO_STACK;
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 1eb9d90c3af9..5009263eba97 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -697,6 +697,8 @@</span> <span class="p_context"> static int ptrace_peek_siginfo(struct task_struct *child,</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -724,8 +726,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index d2e151c83bd5..e896a58e18d8 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2681,7 +2681,7 @@</span> <span class="p_context"> static DEFINE_PER_CPU(unsigned int, current_context);</span>
 
 static __always_inline int trace_recursive_lock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 	int bit;
 
 	if (in_interrupt()) {
<span class="p_chunk">@@ -2698,18 +2698,17 @@</span> <span class="p_context"> static __always_inline int trace_recursive_lock(void)</span>
 		return 1;
 
 	val |= (1 &lt;&lt; bit);
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 
<span class="p_del">-	val--;</span>
<span class="p_del">-	val &amp;= this_cpu_read(current_context);</span>
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	val &amp;= val &amp; (val - 1);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 }
 
 #else
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index b03a0ea77b99..6f7e40d6fdec 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -565,6 +565,7 @@</span> <span class="p_context"> static int __ftrace_set_clr_event(struct trace_array *tr, const char *match,</span>
 static int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)
 {
 	char *event = NULL, *sub = NULL, *match;
<span class="p_add">+	int ret;</span>
 
 	/*
 	 * The buf format can be &lt;subsystem&gt;:&lt;event-name&gt;
<span class="p_chunk">@@ -590,7 +591,13 @@</span> <span class="p_context"> static int ftrace_set_clr_event(struct trace_array *tr, char *buf, int set)</span>
 			event = NULL;
 	}
 
<span class="p_del">-	return __ftrace_set_clr_event(tr, match, sub, event, set);</span>
<span class="p_add">+	ret = __ftrace_set_clr_event(tr, match, sub, event, set);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Put back the colon to allow this to be called again */</span>
<span class="p_add">+	if (buf)</span>
<span class="p_add">+		*(buf - 1) = &#39;:&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_header">diff --git a/kernel/trace/trace_functions_graph.c b/kernel/trace/trace_functions_graph.c</span>
<span class="p_header">index ba476009e5de..224af0a51803 100644</span>
<span class="p_header">--- a/kernel/trace/trace_functions_graph.c</span>
<span class="p_header">+++ b/kernel/trace/trace_functions_graph.c</span>
<span class="p_chunk">@@ -1309,15 +1309,19 @@</span> <span class="p_context"> void graph_trace_open(struct trace_iterator *iter)</span>
 {
 	/* pid and depth on the last trace processed */
 	struct fgraph_data *data;
<span class="p_add">+	gfp_t gfpflags;</span>
 	int cpu;
 
 	iter-&gt;private = NULL;
 
<span class="p_del">-	data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	/* We can be called in atomic context via ftrace_dump() */</span>
<span class="p_add">+	gfpflags = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kzalloc(sizeof(*data), gfpflags);</span>
 	if (!data)
 		goto out_err;
 
<span class="p_del">-	data-&gt;cpu_data = alloc_percpu(struct fgraph_cpu_data);</span>
<span class="p_add">+	data-&gt;cpu_data = alloc_percpu_gfp(struct fgraph_cpu_data, gfpflags);</span>
 	if (!data-&gt;cpu_data)
 		goto out_err_free;
 
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 10063300b830..643b0a90802c 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -610,7 +610,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c</span>
<span class="p_header">index c190d22b6b3d..ba2bd0a9a285 100644</span>
<span class="p_header">--- a/net/bridge/br_netfilter.c</span>
<span class="p_header">+++ b/net/bridge/br_netfilter.c</span>
<span class="p_chunk">@@ -651,6 +651,13 @@</span> <span class="p_context"> static int br_nf_forward_finish(struct sk_buff *skb)</span>
 	struct net_device *in;
 
 	if (!IS_ARP(skb) &amp;&amp; !IS_VLAN_ARP(skb)) {
<span class="p_add">+		int frag_max_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (skb-&gt;protocol == htons(ETH_P_IP)) {</span>
<span class="p_add">+			frag_max_size = IPCB(skb)-&gt;frag_max_size;</span>
<span class="p_add">+			BR_INPUT_SKB_CB(skb)-&gt;frag_max_size = frag_max_size;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		in = nf_bridge-&gt;physindev;
 		if (nf_bridge-&gt;mask &amp; BRNF_PKT_TYPE) {
 			skb-&gt;pkt_type = PACKET_OTHERHOST;
<span class="p_chunk">@@ -710,8 +717,14 @@</span> <span class="p_context"> static unsigned int br_nf_forward_ip(const struct nf_hook_ops *ops,</span>
 		nf_bridge-&gt;mask |= BRNF_PKT_TYPE;
 	}
 
<span class="p_del">-	if (pf == NFPROTO_IPV4 &amp;&amp; br_parse_ip_options(skb))</span>
<span class="p_del">-		return NF_DROP;</span>
<span class="p_add">+	if (pf == NFPROTO_IPV4) {</span>
<span class="p_add">+		int frag_max = BR_INPUT_SKB_CB(skb)-&gt;frag_max_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (br_parse_ip_options(skb))</span>
<span class="p_add">+			return NF_DROP;</span>
<span class="p_add">+</span>
<span class="p_add">+		IPCB(skb)-&gt;frag_max_size = frag_max;</span>
<span class="p_add">+	}</span>
 
 	/* The physdev module checks on this */
 	nf_bridge-&gt;mask |= BRNF_BRIDGED;
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 39c444c1206d..3b0a8b0442b3 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -278,13 +278,14 @@</span> <span class="p_context"> nodata:</span>
 EXPORT_SYMBOL(__alloc_skb);
 
 /**
<span class="p_del">- * build_skb - build a network buffer</span>
<span class="p_add">+ * __build_skb - build a network buffer</span>
  * @data: data buffer provided by caller
<span class="p_del">- * @frag_size: size of fragment, or 0 if head was kmalloced</span>
<span class="p_add">+ * @frag_size: size of data, or 0 if head was kmalloced</span>
  *
  * Allocate a new &amp;sk_buff. Caller provides space holding head and
  * skb_shared_info. @data must have been allocated by kmalloc() only if
<span class="p_del">- * @frag_size is 0, otherwise data should come from the page allocator.</span>
<span class="p_add">+ * @frag_size is 0, otherwise data should come from the page allocator</span>
<span class="p_add">+ *  or vmalloc()</span>
  * The return is the new skb buffer.
  * On a failure the return is %NULL, and @data is not freed.
  * Notes :
<span class="p_chunk">@@ -295,7 +296,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__alloc_skb);</span>
  *  before giving packet to stack.
  *  RX rings only contains data buffers, not full skbs.
  */
<span class="p_del">-struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+struct sk_buff *__build_skb(void *data, unsigned int frag_size)</span>
 {
 	struct skb_shared_info *shinfo;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -309,7 +310,6 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	memset(skb, 0, offsetof(struct sk_buff, tail));
 	skb-&gt;truesize = SKB_TRUESIZE(size);
<span class="p_del">-	skb-&gt;head_frag = frag_size != 0;</span>
 	atomic_set(&amp;skb-&gt;users, 1);
 	skb-&gt;head = data;
 	skb-&gt;data = data;
<span class="p_chunk">@@ -326,6 +326,23 @@</span> <span class="p_context"> struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
 
 	return skb;
 }
<span class="p_add">+</span>
<span class="p_add">+/* build_skb() is wrapper over __build_skb(), that specifically</span>
<span class="p_add">+ * takes care of skb-&gt;head and skb-&gt;pfmemalloc</span>
<span class="p_add">+ * This means that if @frag_size is not zero, then @data must be backed</span>
<span class="p_add">+ * by a page fragment, not kmalloc() or vmalloc()</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct sk_buff *build_skb(void *data, unsigned int frag_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb = __build_skb(data, frag_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb &amp;&amp; frag_size) {</span>
<span class="p_add">+		skb-&gt;head_frag = 1;</span>
<span class="p_add">+		if (virt_to_head_page(data)-&gt;pfmemalloc)</span>
<span class="p_add">+			skb-&gt;pfmemalloc = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(build_skb);
 
 struct netdev_alloc_cache {
<span class="p_chunk">@@ -346,7 +363,8 @@</span> <span class="p_context"> static struct page *__page_frag_refill(struct netdev_alloc_cache *nc,</span>
 	gfp_t gfp = gfp_mask;
 
 	if (order) {
<span class="p_del">-		gfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY;</span>
<span class="p_add">+		gfp_mask |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY |</span>
<span class="p_add">+			    __GFP_NOMEMALLOC;</span>
 		page = alloc_pages_node(NUMA_NO_NODE, gfp_mask, order);
 		nc-&gt;frag.size = PAGE_SIZE &lt;&lt; (page ? order : 0);
 	}
<span class="p_header">diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c</span>
<span class="p_header">index 787b3c294ce6..d5410b57da19 100644</span>
<span class="p_header">--- a/net/ipv4/ip_forward.c</span>
<span class="p_header">+++ b/net/ipv4/ip_forward.c</span>
<span class="p_chunk">@@ -81,6 +81,9 @@</span> <span class="p_context"> int ip_forward(struct sk_buff *skb)</span>
 	if (skb-&gt;pkt_type != PACKET_HOST)
 		goto drop;
 
<span class="p_add">+	if (unlikely(skb-&gt;sk))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 9f29453049dc..e625be562d3c 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2753,39 +2753,65 @@</span> <span class="p_context"> begin_fwd:</span>
 	}
 }
 
<span class="p_del">-/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="p_del">- * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="p_add">+/* We allow to exceed memory limits for FIN packets to expedite</span>
<span class="p_add">+ * connection tear down and (memory) recovery.</span>
<span class="p_add">+ * Otherwise tcp_send_fin() could be tempted to either delay FIN</span>
<span class="p_add">+ * or even be forced to close flow without any FIN.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sk_forced_wmem_schedule(struct sock *sk, int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int amt, status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= sk-&gt;sk_forward_alloc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	amt = sk_mem_pages(size);</span>
<span class="p_add">+	sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;</span>
<span class="p_add">+	sk_memory_allocated_add(sk, amt, &amp;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Send a FIN. The caller locks the socket for us.</span>
<span class="p_add">+ * We should try to send a FIN packet really hard, but eventually give up.</span>
  */
 void tcp_send_fin(struct sock *sk)
 {
<span class="p_add">+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);</span>
 	struct tcp_sock *tp = tcp_sk(sk);
<span class="p_del">-	struct sk_buff *skb = tcp_write_queue_tail(sk);</span>
<span class="p_del">-	int mss_now;</span>
 
<span class="p_del">-	/* Optimization, tack on the FIN if we have a queue of</span>
<span class="p_del">-	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="p_del">-	 * and IP options.</span>
<span class="p_add">+	/* Optimization, tack on the FIN if we have one skb in write queue and</span>
<span class="p_add">+	 * this skb was not yet sent, or we are under memory pressure.</span>
<span class="p_add">+	 * Note: in the latter case, FIN packet will be sent after a timeout,</span>
<span class="p_add">+	 * as TCP stack thinks it has already been transmitted.</span>
 	 */
<span class="p_del">-	mss_now = tcp_current_mss(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_send_head(sk) != NULL) {</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;end_seq++;</span>
<span class="p_add">+	if (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {</span>
<span class="p_add">+coalesce:</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;end_seq++;</span>
 		tp-&gt;write_seq++;
<span class="p_add">+		if (!tcp_send_head(sk)) {</span>
<span class="p_add">+			/* This means tskb was already sent.</span>
<span class="p_add">+			 * Pretend we included the FIN on previous transmit.</span>
<span class="p_add">+			 * We need to set tp-&gt;snd_nxt to the value it would have</span>
<span class="p_add">+			 * if FIN had been sent. This is because retransmit path</span>
<span class="p_add">+			 * does not change tp-&gt;snd_nxt.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tp-&gt;snd_nxt++;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		/* Socket is locked, keep trying until memory is available. */</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			skb = sk_stream_alloc_skb(sk, 0, sk-&gt;sk_allocation);</span>
<span class="p_del">-			if (skb)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			yield();</span>
<span class="p_add">+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			if (tskb)</span>
<span class="p_add">+				goto coalesce;</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_add">+		skb_reserve(skb, MAX_TCP_HEADER);</span>
<span class="p_add">+		sk_forced_wmem_schedule(sk, skb-&gt;truesize);</span>
 		/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
 		tcp_init_nondata_skb(skb, tp-&gt;write_seq,
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
<span class="p_del">-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);</span>
<span class="p_add">+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span>
 }
 
 /* We get here when a process closes a file descriptor (either due to
<span class="p_header">diff --git a/net/mac80211/mlme.c b/net/mac80211/mlme.c</span>
<span class="p_header">index bf4b84ff1c70..6e565ec5cfa4 100644</span>
<span class="p_header">--- a/net/mac80211/mlme.c</span>
<span class="p_header">+++ b/net/mac80211/mlme.c</span>
<span class="p_chunk">@@ -2231,7 +2231,7 @@</span> <span class="p_context"> static void ieee80211_mgd_probe_ap_send(struct ieee80211_sub_if_data *sdata)</span>
 		else
 			ssid_len = ssid[1];
 
<span class="p_del">-		ieee80211_send_probe_req(sdata, sdata-&gt;vif.addr, NULL,</span>
<span class="p_add">+		ieee80211_send_probe_req(sdata, sdata-&gt;vif.addr, dst,</span>
 					 ssid + 2, ssid_len, NULL,
 					 0, (u32) -1, true, 0,
 					 ifmgd-&gt;associated-&gt;channel, false);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 75532efa51cd..4b4a2a4418e4 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -1616,13 +1616,11 @@</span> <span class="p_context"> static struct sk_buff *netlink_alloc_large_skb(unsigned int size,</span>
 	if (data == NULL)
 		return NULL;
 
<span class="p_del">-	skb = build_skb(data, size);</span>
<span class="p_add">+	skb = __build_skb(data, size);</span>
 	if (skb == NULL)
 		vfree(data);
<span class="p_del">-	else {</span>
<span class="p_del">-		skb-&gt;head_frag = 0;</span>
<span class="p_add">+	else</span>
 		skb-&gt;destructor = netlink_skb_destructor;
<span class="p_del">-	}</span>
 
 	return skb;
 }
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index 2ca9f2e93139..53745f4c2bf5 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 172c89996d74..39e3640e30eb 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4946,12 +4946,14 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2212, &quot;Thinkpad T440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, &quot;Thinkpad X240&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
 	SND_PCI_QUIRK(0x17aa, 0x5013, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x501a, &quot;Thinkpad&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x501e, &quot;Thinkpad L440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5026, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
<span class="p_chunk">@@ -5452,6 +5454,8 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 		break;
 	case 0x10ec0256:
 		spec-&gt;codec_variant = ALC269_TYPE_ALC256;
<span class="p_add">+		spec-&gt;gen.mixer_nid = 0; /* ALC256 does not have any loopback mixer path */</span>
<span class="p_add">+		alc_update_coef_idx(codec, 0x36, 1 &lt;&lt; 13, 1 &lt;&lt; 5); /* Switch pcbeep path to Line in path*/</span>
 		break;
 	}
 
<span class="p_chunk">@@ -5465,8 +5469,8 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 	if (err &lt; 0)
 		goto error;
 
<span class="p_del">-	if (!spec-&gt;gen.no_analog &amp;&amp; spec-&gt;gen.beep_nid)</span>
<span class="p_del">-		set_beep_amp(spec, 0x0b, 0x04, HDA_INPUT);</span>
<span class="p_add">+	if (!spec-&gt;gen.no_analog &amp;&amp; spec-&gt;gen.beep_nid &amp;&amp; spec-&gt;gen.mixer_nid)</span>
<span class="p_add">+		set_beep_amp(spec, spec-&gt;gen.mixer_nid, 0x04, HDA_INPUT);</span>
 
 	codec-&gt;patch_ops = alc_patch_ops;
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index 7d3a6accaf9a..e770ee6f36da 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -561,10 +561,10 @@</span> <span class="p_context"> static int cs4271_codec_probe(struct snd_soc_codec *codec)</span>
 	if (gpio_is_valid(cs4271-&gt;gpio_nreset)) {
 		/* Reset codec */
 		gpio_direction_output(cs4271-&gt;gpio_nreset, 0);
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 		gpio_set_value(cs4271-&gt;gpio_nreset, 1);
 		/* Give the codec time to wake up */
<span class="p_del">-		udelay(1);</span>
<span class="p_add">+		mdelay(1);</span>
 	}
 
 	ret = regmap_update_bits(cs4271-&gt;regmap, CS4271_MODE2,
<span class="p_header">diff --git a/sound/soc/codecs/pcm512x.c b/sound/soc/codecs/pcm512x.c</span>
<span class="p_header">index 30c673cdc12e..d043797b7979 100644</span>
<span class="p_header">--- a/sound/soc/codecs/pcm512x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/pcm512x.c</span>
<span class="p_chunk">@@ -261,9 +261,9 @@</span> <span class="p_context"> static const struct soc_enum pcm512x_veds =</span>
 static const struct snd_kcontrol_new pcm512x_controls[] = {
 SOC_DOUBLE_R_TLV(&quot;Digital Playback Volume&quot;, PCM512x_DIGITAL_VOLUME_2,
 		 PCM512x_DIGITAL_VOLUME_3, 0, 255, 1, digital_tlv),
<span class="p_del">-SOC_DOUBLE_TLV(&quot;Playback Volume&quot;, PCM512x_ANALOG_GAIN_CTRL,</span>
<span class="p_add">+SOC_DOUBLE_TLV(&quot;Analogue Playback Volume&quot;, PCM512x_ANALOG_GAIN_CTRL,</span>
 	       PCM512x_LAGN_SHIFT, PCM512x_RAGN_SHIFT, 1, 1, analog_tlv),
<span class="p_del">-SOC_DOUBLE_TLV(&quot;Playback Boost Volume&quot;, PCM512x_ANALOG_GAIN_BOOST,</span>
<span class="p_add">+SOC_DOUBLE_TLV(&quot;Analogue Playback Boost Volume&quot;, PCM512x_ANALOG_GAIN_BOOST,</span>
 	       PCM512x_AGBL_SHIFT, PCM512x_AGBR_SHIFT, 1, 0, boost_tlv),
 SOC_DOUBLE(&quot;Digital Playback Switch&quot;, PCM512x_MUTE, PCM512x_RQML_SHIFT,
 	   PCM512x_RQMR_SHIFT, 1, 1),
<span class="p_header">diff --git a/sound/soc/codecs/wm8741.c b/sound/soc/codecs/wm8741.c</span>
<span class="p_header">index 31bb4801a005..9e71c768966f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8741.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8741.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static const unsigned int rates_11289[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_11289 = {
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_16384 = {</span>
 };
 
 static const unsigned int rates_16934[] = {
<span class="p_del">-	44100, 88235,</span>
<span class="p_add">+	44100, 88200,</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_16934 = {
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_18432 = {</span>
 };
 
 static const unsigned int rates_22579[] = {
<span class="p_del">-	44100, 88235, 1764000</span>
<span class="p_add">+	44100, 88200, 176400</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_22579 = {
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> static const struct snd_pcm_hw_constraint_list constraints_24576 = {</span>
 };
 
 static const unsigned int rates_36864[] = {
<span class="p_del">-	48000, 96000, 19200</span>
<span class="p_add">+	48000, 96000, 192000</span>
 };
 
 static const struct snd_pcm_hw_constraint_list constraints_36864 = {
<span class="p_header">diff --git a/sound/soc/davinci/davinci-evm.c b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">index 158cb3d1db70..f33143f917a3 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-evm.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-evm.c</span>
<span class="p_chunk">@@ -431,18 +431,8 @@</span> <span class="p_context"> static int davinci_evm_probe(struct platform_device *pdev)</span>
 	return ret;
 }
 
<span class="p_del">-static int davinci_evm_remove(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_soc_unregister_card(card);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct platform_driver davinci_evm_driver = {
 	.probe		= davinci_evm_probe,
<span class="p_del">-	.remove		= davinci_evm_remove,</span>
 	.driver		= {
 		.name	= &quot;davinci_evm&quot;,
 		.pm	= &amp;snd_soc_pm_ops,
<span class="p_header">diff --git a/tools/lib/traceevent/kbuffer-parse.c b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">index dcc665228c71..deb3569ab004 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/kbuffer-parse.c</span>
<span class="p_chunk">@@ -372,7 +372,6 @@</span> <span class="p_context"> translate_data(struct kbuffer *kbuf, void *data, void **rptr,</span>
 	switch (type_len) {
 	case KBUFFER_TYPE_PADDING:
 		*length = read_4(kbuf, data);
<span class="p_del">-		data += *length;</span>
 		break;
 
 	case KBUFFER_TYPE_TIME_EXTEND:
<span class="p_header">diff --git a/tools/perf/config/Makefile b/tools/perf/config/Makefile</span>
<span class="p_header">index 648e31ff4021..f97de8ee9a09 100644</span>
<span class="p_header">--- a/tools/perf/config/Makefile</span>
<span class="p_header">+++ b/tools/perf/config/Makefile</span>
<span class="p_chunk">@@ -645,7 +645,7 @@</span> <span class="p_context"> ifeq (${IS_64_BIT}, 1)</span>
       NO_PERF_READ_VDSO32 := 1
     endif
   endif
<span class="p_del">-  ifneq (${IS_X86_64}, 1)</span>
<span class="p_add">+  ifneq ($(ARCH), x86)</span>
     NO_PERF_READ_VDSOX32 := 1
   endif
   ifndef NO_PERF_READ_VDSOX32
<span class="p_chunk">@@ -693,7 +693,7 @@</span> <span class="p_context"> sysconfdir = $(prefix)/etc</span>
 ETC_PERFCONFIG = etc/perfconfig
 endif
 ifndef lib
<span class="p_del">-ifeq ($(IS_X86_64),1)</span>
<span class="p_add">+ifeq ($(ARCH)$(IS_64_BIT), x861)</span>
 lib = lib64
 else
 lib = lib
<span class="p_header">diff --git a/tools/perf/tests/make b/tools/perf/tests/make</span>
<span class="p_header">index 69a71ff84e01..f8b24a2c5a96 100644</span>
<span class="p_header">--- a/tools/perf/tests/make</span>
<span class="p_header">+++ b/tools/perf/tests/make</span>
<span class="p_chunk">@@ -5,7 +5,7 @@</span> <span class="p_context"> include config/Makefile.arch</span>
 
 # FIXME looks like x86 is the only arch running tests ;-)
 # we need some IS_(32/64) flag to make this generic
<span class="p_del">-ifeq ($(IS_X86_64),1)</span>
<span class="p_add">+ifeq ($(ARCH)$(IS_64_BIT), x861)</span>
 lib = lib64
 else
 lib = lib
<span class="p_header">diff --git a/tools/perf/util/cloexec.c b/tools/perf/util/cloexec.c</span>
<span class="p_header">index 6da965bdbc2c..85b523885f9d 100644</span>
<span class="p_header">--- a/tools/perf/util/cloexec.c</span>
<span class="p_header">+++ b/tools/perf/util/cloexec.c</span>
<span class="p_chunk">@@ -7,6 +7,12 @@</span> <span class="p_context"></span>
 
 static unsigned long flag = PERF_FLAG_FD_CLOEXEC;
 
<span class="p_add">+int __weak sched_getcpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	errno = ENOSYS;</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int perf_flag_probe(void)
 {
 	/* use &#39;safest&#39; configuration as used in perf_evsel__fallback() */
<span class="p_header">diff --git a/tools/perf/util/cloexec.h b/tools/perf/util/cloexec.h</span>
<span class="p_header">index 94a5a7d829d5..68888c29b04a 100644</span>
<span class="p_header">--- a/tools/perf/util/cloexec.h</span>
<span class="p_header">+++ b/tools/perf/util/cloexec.h</span>
<span class="p_chunk">@@ -3,4 +3,10 @@</span> <span class="p_context"></span>
 
 unsigned long perf_event_open_cloexec_flag(void);
 
<span class="p_add">+#ifdef __GLIBC_PREREQ</span>
<span class="p_add">+#if !__GLIBC_PREREQ(2, 6)</span>
<span class="p_add">+extern int sched_getcpu(void) __THROW;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* __PERF_CLOEXEC_H */
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index 06fcd1bf98b6..eafee111563b 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -69,6 +69,10 @@</span> <span class="p_context"> static inline uint8_t elf_sym__type(const GElf_Sym *sym)</span>
 	return GELF_ST_TYPE(sym-&gt;st_info);
 }
 
<span class="p_add">+#ifndef STT_GNU_IFUNC</span>
<span class="p_add">+#define STT_GNU_IFUNC 10</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static inline int elf_sym__is_function(const GElf_Sym *sym)
 {
 	return (elf_sym__type(sym) == STT_FUNC ||
<span class="p_header">diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">index d1b3a361e526..4039854560d0 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,12 @@</span> <span class="p_context"></span>
 CC		= $(CROSS_COMPILE)gcc
<span class="p_del">-BUILD_OUTPUT	:= $(PWD)</span>
<span class="p_add">+BUILD_OUTPUT	:= $(CURDIR)</span>
 PREFIX		:= /usr
 DESTDIR		:=
 
<span class="p_add">+ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)</span>
<span class="p_add">+	BUILD_OUTPUT := $(O)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER=&#39;&quot;../../../../arch/x86/include/uapi/asm/msr-index.h&quot;&#39;
<span class="p_header">diff --git a/virt/kvm/arm/vgic-v2.c b/virt/kvm/arm/vgic-v2.c</span>
<span class="p_header">index 2935405ad22f..b9d48e8e1eb4 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic-v2.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic-v2.c</span>
<span class="p_chunk">@@ -72,6 +72,8 @@</span> <span class="p_context"> static void vgic_v2_sync_lr_elrsr(struct kvm_vcpu *vcpu, int lr,</span>
 {
 	if (!(lr_desc.state &amp; LR_STATE_MASK))
 		vcpu-&gt;arch.vgic_cpu.vgic_v2.vgic_elrsr |= (1ULL &lt;&lt; lr);
<span class="p_add">+	else</span>
<span class="p_add">+		vcpu-&gt;arch.vgic_cpu.vgic_v2.vgic_elrsr &amp;= ~(1ULL &lt;&lt; lr);</span>
 }
 
 static u64 vgic_v2_get_elrsr(const struct kvm_vcpu *vcpu)
<span class="p_chunk">@@ -84,6 +86,11 @@</span> <span class="p_context"> static u64 vgic_v2_get_eisr(const struct kvm_vcpu *vcpu)</span>
 	return vcpu-&gt;arch.vgic_cpu.vgic_v2.vgic_eisr;
 }
 
<span class="p_add">+static void vgic_v2_clear_eisr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu-&gt;arch.vgic_cpu.vgic_v2.vgic_eisr = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 vgic_v2_get_interrupt_status(const struct kvm_vcpu *vcpu)
 {
 	u32 misr = vcpu-&gt;arch.vgic_cpu.vgic_v2.vgic_misr;
<span class="p_chunk">@@ -148,6 +155,7 @@</span> <span class="p_context"> static const struct vgic_ops vgic_v2_ops = {</span>
 	.sync_lr_elrsr		= vgic_v2_sync_lr_elrsr,
 	.get_elrsr		= vgic_v2_get_elrsr,
 	.get_eisr		= vgic_v2_get_eisr,
<span class="p_add">+	.clear_eisr		= vgic_v2_clear_eisr,</span>
 	.get_interrupt_status	= vgic_v2_get_interrupt_status,
 	.enable_underflow	= vgic_v2_enable_underflow,
 	.disable_underflow	= vgic_v2_disable_underflow,
<span class="p_header">diff --git a/virt/kvm/arm/vgic-v3.c b/virt/kvm/arm/vgic-v3.c</span>
<span class="p_header">index 1c2c8eef0599..58b8af00ee4c 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic-v3.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic-v3.c</span>
<span class="p_chunk">@@ -86,6 +86,8 @@</span> <span class="p_context"> static void vgic_v3_sync_lr_elrsr(struct kvm_vcpu *vcpu, int lr,</span>
 {
 	if (!(lr_desc.state &amp; LR_STATE_MASK))
 		vcpu-&gt;arch.vgic_cpu.vgic_v3.vgic_elrsr |= (1U &lt;&lt; lr);
<span class="p_add">+	else</span>
<span class="p_add">+		vcpu-&gt;arch.vgic_cpu.vgic_v3.vgic_elrsr &amp;= ~(1U &lt;&lt; lr);</span>
 }
 
 static u64 vgic_v3_get_elrsr(const struct kvm_vcpu *vcpu)
<span class="p_chunk">@@ -98,6 +100,11 @@</span> <span class="p_context"> static u64 vgic_v3_get_eisr(const struct kvm_vcpu *vcpu)</span>
 	return vcpu-&gt;arch.vgic_cpu.vgic_v3.vgic_eisr;
 }
 
<span class="p_add">+static void vgic_v3_clear_eisr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu-&gt;arch.vgic_cpu.vgic_v3.vgic_eisr = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 vgic_v3_get_interrupt_status(const struct kvm_vcpu *vcpu)
 {
 	u32 misr = vcpu-&gt;arch.vgic_cpu.vgic_v3.vgic_misr;
<span class="p_chunk">@@ -162,6 +169,7 @@</span> <span class="p_context"> static const struct vgic_ops vgic_v3_ops = {</span>
 	.sync_lr_elrsr		= vgic_v3_sync_lr_elrsr,
 	.get_elrsr		= vgic_v3_get_elrsr,
 	.get_eisr		= vgic_v3_get_eisr,
<span class="p_add">+	.clear_eisr		= vgic_v3_clear_eisr,</span>
 	.get_interrupt_status	= vgic_v3_get_interrupt_status,
 	.enable_underflow	= vgic_v3_enable_underflow,
 	.disable_underflow	= vgic_v3_disable_underflow,
<span class="p_header">diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c</span>
<span class="p_header">index 03affc7bf453..57a16f4836d0 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic.c</span>
<span class="p_chunk">@@ -1219,6 +1219,11 @@</span> <span class="p_context"> static inline u64 vgic_get_eisr(struct kvm_vcpu *vcpu)</span>
 	return vgic_ops-&gt;get_eisr(vcpu);
 }
 
<span class="p_add">+static inline void vgic_clear_eisr(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vgic_ops-&gt;clear_eisr(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 vgic_get_interrupt_status(struct kvm_vcpu *vcpu)
 {
 	return vgic_ops-&gt;get_interrupt_status(vcpu);
<span class="p_chunk">@@ -1258,6 +1263,7 @@</span> <span class="p_context"> static void vgic_retire_lr(int lr_nr, int irq, struct kvm_vcpu *vcpu)</span>
 	vgic_set_lr(vcpu, lr_nr, vlr);
 	clear_bit(lr_nr, vgic_cpu-&gt;lr_used);
 	vgic_cpu-&gt;vgic_irq_lr_map[irq] = LR_EMPTY;
<span class="p_add">+	vgic_sync_lr_elrsr(vcpu, lr_nr, vlr);</span>
 }
 
 /*
<span class="p_chunk">@@ -1313,6 +1319,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 			BUG_ON(!test_bit(lr, vgic_cpu-&gt;lr_used));
 			vlr.state |= LR_STATE_PENDING;
 			vgic_set_lr(vcpu, lr, vlr);
<span class="p_add">+			vgic_sync_lr_elrsr(vcpu, lr, vlr);</span>
 			return true;
 		}
 	}
<span class="p_chunk">@@ -1334,6 +1341,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 		vlr.state |= LR_EOI_INT;
 
 	vgic_set_lr(vcpu, lr, vlr);
<span class="p_add">+	vgic_sync_lr_elrsr(vcpu, lr, vlr);</span>
 
 	return true;
 }
<span class="p_chunk">@@ -1502,6 +1510,14 @@</span> <span class="p_context"> static bool vgic_process_maintenance(struct kvm_vcpu *vcpu)</span>
 	if (status &amp; INT_STATUS_UNDERFLOW)
 		vgic_disable_underflow(vcpu);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In the next iterations of the vcpu loop, if we sync the vgic state</span>
<span class="p_add">+	 * after flushing it, but before entering the guest (this happens for</span>
<span class="p_add">+	 * pending signals and vmid rollovers), then make sure we don&#39;t pick</span>
<span class="p_add">+	 * up any old maintenance interrupts here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vgic_clear_eisr(vcpu);</span>
<span class="p_add">+</span>
 	return level_pending;
 }
 
<span class="p_chunk">@@ -1706,6 +1722,9 @@</span> <span class="p_context"> int kvm_vgic_inject_irq(struct kvm *kvm, int cpuid, unsigned int irq_num,</span>
 			goto out;
 	}
 
<span class="p_add">+	if (irq_num &gt;= kvm-&gt;arch.vgic.nr_irqs)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	vcpu_id = vgic_update_irq_pending(kvm, cpuid, irq_num, level);
 	if (vcpu_id &gt;= 0) {
 		/* kick the specified vcpu */
<span class="p_chunk">@@ -1809,7 +1828,7 @@</span> <span class="p_context"> static int vgic_init(struct kvm *kvm)</span>
 
 	nr_cpus = dist-&gt;nr_cpus = atomic_read(&amp;kvm-&gt;online_vcpus);
 	if (!nr_cpus)		/* No vcpus? Can&#39;t be good... */
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	/*
 	 * If nobody configured the number of interrupts, use the
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 0fba701bc518..0edccc8f6ffb 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1608,8 +1608,8 @@</span> <span class="p_context"> int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,</span>
 	ghc-&gt;generation = slots-&gt;generation;
 	ghc-&gt;len = len;
 	ghc-&gt;memslot = gfn_to_memslot(kvm, start_gfn);
<span class="p_del">-	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, &amp;nr_pages_avail);</span>
<span class="p_del">-	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_avail &gt;= nr_pages_needed) {</span>
<span class="p_add">+	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, NULL);</span>
<span class="p_add">+	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_needed &lt;= 1) {</span>
 		ghc-&gt;hva += offset;
 	} else {
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



