
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,03/16] iommu: introduce iommu invalidate API function - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,03/16] iommu: introduce iommu invalidate API function</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 5, 2017, 11:03 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1507244624-39189-4-git-send-email-jacob.jun.pan@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9988077/mbox/"
   >mbox</a>
|
   <a href="/patch/9988077/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9988077/">/patch/9988077/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	EFAFF6029B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 23:01:26 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DFF8628D56
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 23:01:26 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D420428D58; Thu,  5 Oct 2017 23:01:26 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 24BDD28D56
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  5 Oct 2017 23:01:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752205AbdJEXBY (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 5 Oct 2017 19:01:24 -0400
Received: from mga05.intel.com ([192.55.52.43]:56372 &quot;EHLO mga05.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751495AbdJEXBV (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 5 Oct 2017 19:01:21 -0400
Received: from orsmga004.jf.intel.com ([10.7.209.38])
	by fmsmga105.fm.intel.com with ESMTP; 05 Oct 2017 16:01:20 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.42,482,1500966000&quot;; d=&quot;scan&#39;208&quot;;a=&quot;135681885&quot;
Received: from jacob-builder.jf.intel.com ([10.7.199.158])
	by orsmga004.jf.intel.com with ESMTP; 05 Oct 2017 16:01:20 -0700
From: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
To: iommu@lists.linux-foundation.org, LKML &lt;linux-kernel@vger.kernel.org&gt;,
	Joerg Roedel &lt;joro@8bytes.org&gt;, David Woodhouse &lt;dwmw2@infradead.org&gt;,
	Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;,
	Rafael Wysocki &lt;rafael.j.wysocki@intel.com&gt;,
	Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;
Cc: &quot;Liu, Yi L&quot; &lt;yi.l.liu@intel.com&gt;, Lan Tianyu &lt;tianyu.lan@intel.com&gt;,
	&quot;Tian, Kevin&quot; &lt;kevin.tian@intel.com&gt;, Raj Ashok &lt;ashok.raj@intel.com&gt;,
	Alex Williamson &lt;alex.williamson@redhat.com&gt;,
	&quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;, Liu@vger.kernel.org,
	Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
Subject: [PATCH v2 03/16] iommu: introduce iommu invalidate API function
Date: Thu,  5 Oct 2017 16:03:31 -0700
Message-Id: &lt;1507244624-39189-4-git-send-email-jacob.jun.pan@linux.intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1507244624-39189-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
References: &lt;1507244624-39189-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Oct. 5, 2017, 11:03 p.m.</div>
<pre class="content">
<span class="from">From: &quot;Liu, Yi L&quot; &lt;yi.l.liu@linux.intel.com&gt;</span>

When an SVM capable device is assigned to a guest, the first level page
tables are owned by the guest and the guest PASID table pointer is
linked to the device context entry of the physical IOMMU.

Host IOMMU driver has no knowledge of caching structure updates unless
the guest invalidation activities are passed down to the host. The
primary usage is derived from emulated IOMMU in the guest, where QEMU
can trap invalidation activities before passing them down to the
host/physical IOMMU.
Since the invalidation data are obtained from user space and will be
written into physical IOMMU, we must allow security check at various
layers. Therefore, generic invalidation data format are proposed here,
model specific IOMMU drivers need to convert them into their own format.
<span class="signed-off-by">
Signed-off-by: Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
---
 drivers/iommu/iommu.c      | 14 +++++++++++
 include/linux/iommu.h      | 12 +++++++++
 include/uapi/linux/iommu.h | 62 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 88 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Oct. 10, 2017, 1:35 p.m.</div>
<pre class="content">
On Thu, Oct 05, 2017 at 04:03:31PM -0700, Jacob Pan wrote:
<span class="quote">&gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; +		struct device *dev, struct tlb_invalidate_info *inv_info)</span>

This name is way too generic, it should at least be called
iommu_svm_invalidate() or something like that. With the name above it is
easily confused with the other TLB invalidation functions of the
IOMMU-API.
<span class="quote">
&gt; +enum iommu_inv_granularity {</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_GLOBAL,		/* all TLBs invalidated */</span>

Is that needed? We certainly don&#39;t want to give userspace/guests that
fine-grained control about IOMMU cache invalidations.

In the end a guest issues flush-global command does not translate to a
flush-global on the host, but to separate flushes for the domains the
guest uses.
<span class="quote">
&gt; +	IOMMU_INV_GRANU_DOMAIN,		/* all TLBs associated with a domain */</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_DEVICE,		/* caching structure associated with a</span>
<span class="quote">&gt; +					 * device ID</span>

What is the difference between a DOMAIN and a DEVICE flush?
<span class="quote">
&gt; +	IOMMU_INV_GRANU_DOMAN_PAGE,	/* address range with a domain */</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_ALL_PASID,	/* cache of a given PASID */</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_PASID_SEL,	/* only invalidate specified PASID */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_NG_ALL_PASID,	/* non-global within all PASIDs */</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_NG_PASID,	/* non-global within a PASIDs */</span>
<span class="quote">&gt; +	IOMMU_INV_GRANU_PAGE_PASID,	/* page-selective within a PASID */</span>
<span class="quote">&gt; +	IOMMU_INV_NR_GRANU,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +enum iommu_inv_type {</span>
<span class="quote">&gt; +	IOMMU_INV_TYPE_DTLB,	/* device IOTLB */</span>
<span class="quote">&gt; +	IOMMU_INV_TYPE_TLB,	/* IOMMU paging structure cache */</span>
<span class="quote">&gt; +	IOMMU_INV_TYPE_PASID,	/* PASID cache */</span>
<span class="quote">&gt; +	IOMMU_INV_TYPE_CONTEXT,	/* device context entry cache */</span>

Is that really needed? When the guest updates it context-entry
equivalent it translates to bind_pasid_table/unbind_pasid_table calls,
no?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Oct. 10, 2017, 10:09 p.m.</div>
<pre class="content">
On Tue, 10 Oct 2017 15:35:42 +0200
Joerg Roedel &lt;joro@8bytes.org&gt; wrote:
<span class="quote">
&gt; On Thu, Oct 05, 2017 at 04:03:31PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt; *inv_info)  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This name is way too generic, it should at least be called</span>
<span class="quote">&gt; iommu_svm_invalidate() or something like that. With the name above it</span>
<span class="quote">&gt; is easily confused with the other TLB invalidation functions of the</span>
<span class="quote">&gt; IOMMU-API.</span>
<span class="quote">&gt; </span>
Good point. I was calling it iommu_passdown_invalidate() originally.
The invalidation request comes from guest or user space instead of
in-kernel unmap kind of calls.
<span class="quote">&gt; &gt; +enum iommu_inv_granularity {</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_GLOBAL,		/* all TLBs</span>
<span class="quote">&gt; &gt; invalidated */  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is that needed? We certainly don&#39;t want to give userspace/guests that</span>
<span class="quote">&gt; fine-grained control about IOMMU cache invalidations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In the end a guest issues flush-global command does not translate to a</span>
<span class="quote">&gt; flush-global on the host, but to separate flushes for the domains the</span>
<span class="quote">&gt; guest uses.</span>
<span class="quote">&gt; </span>
Right, guest should not go beyond its own domain.
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_DOMAIN,		/* all TLBs</span>
<span class="quote">&gt; &gt; associated with a domain */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_DEVICE,		/* caching</span>
<span class="quote">&gt; &gt; structure associated with a</span>
<span class="quote">&gt; &gt; +					 * device ID  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is the difference between a DOMAIN and a DEVICE flush?</span>
<span class="quote">&gt; </span>
Those are based on vt-d context cache flush granularity, domain
selective flushes all context caches associated with a domain ID.
Device selective flush flushes context caches of a source ID.
But like you pointed out below, since context cache flush will come in
as unbind call, there is no need to do passdown invalidate. I can
remove that.

Here I am trying to use all generic definitions, which is a superset of
all vendor models. I am likely missing out some non-vt-d cases.
<span class="quote">
&gt; &gt; +	IOMMU_INV_GRANU_DOMAN_PAGE,	/* address range with a</span>
<span class="quote">&gt; &gt; domain */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_ALL_PASID,	/* cache of a given</span>
<span class="quote">&gt; &gt; PASID */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_PASID_SEL,	/* only invalidate</span>
<span class="quote">&gt; &gt; specified PASID */ +</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_NG_ALL_PASID,	/* non-global within</span>
<span class="quote">&gt; &gt; all PASIDs */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_NG_PASID,	/* non-global within a</span>
<span class="quote">&gt; &gt; PASIDs */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_GRANU_PAGE_PASID,	/* page-selective</span>
<span class="quote">&gt; &gt; within a PASID */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_NR_GRANU,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +enum iommu_inv_type {</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_TYPE_DTLB,	/* device IOTLB */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_TYPE_TLB,	/* IOMMU paging structure cache</span>
<span class="quote">&gt; &gt; */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_TYPE_PASID,	/* PASID cache */</span>
<span class="quote">&gt; &gt; +	IOMMU_INV_TYPE_CONTEXT,	/* device context entry</span>
<span class="quote">&gt; &gt; cache */  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is that really needed? When the guest updates it context-entry</span>
<span class="quote">&gt; equivalent it translates to bind_pasid_table/unbind_pasid_table calls,</span>
<span class="quote">&gt; no?</span>
<span class="quote">&gt; </span>
Right no need to passdown context cache invalidation for VT-d. I just
wasn&#39;t sure it is the same for all models. Again, trying to have a
superset of generic fields.

Thanks!

Jacob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170615">Liu, Yi L</a> - Oct. 11, 2017, 7:54 a.m.</div>
<pre class="content">
<span class="quote">&gt; On Tue, 10 Oct 2017 15:35:42 +0200</span>
<span class="quote">&gt; Joerg Roedel &lt;joro@8bytes.org&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Thu, Oct 05, 2017 at 04:03:31PM -0700, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; &gt; +int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; &gt; +		struct device *dev, struct tlb_invalidate_info</span>
<span class="quote">&gt; &gt; &gt; *inv_info)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This name is way too generic, it should at least be called</span>
<span class="quote">&gt; &gt; iommu_svm_invalidate() or something like that. With the name above it</span>
<span class="quote">&gt; &gt; is easily confused with the other TLB invalidation functions of the</span>
<span class="quote">&gt; &gt; IOMMU-API.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; Good point. I was calling it iommu_passdown_invalidate() originally.</span>
<span class="quote">&gt; The invalidation request comes from guest or user space instead of in-kernel unmap</span>
<span class="quote">&gt; kind of calls.</span>

[Liu, Yi L] I agree that iommu_invalidate() is too generic. Additionally, also better to avoid
making it svm specific.

The reason we introduce this API is in vSVM case is that guest owns the first level page
table(vtd). If we use similar mechanism for vIOVA, then we also need to passdown guest&#39;s
vIOVA tlb flush.

Since it is to expose an API for iommu tlb flushes requests from userspace/guest which is out
of iommu. How about naming it as iommu_tlb_external_invalidate()?
<span class="quote">
&gt; &gt; &gt; +enum iommu_inv_granularity {</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_GLOBAL,		/* all TLBs</span>
<span class="quote">&gt; &gt; &gt; invalidated */</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Is that needed? We certainly don&#39;t want to give userspace/guests that</span>
<span class="quote">&gt; &gt; fine-grained control about IOMMU cache invalidations.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; In the end a guest issues flush-global command does not translate to a</span>
<span class="quote">&gt; &gt; flush-global on the host, but to separate flushes for the domains the</span>
<span class="quote">&gt; &gt; guest uses.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; Right, guest should not go beyond its own domain.</span>

[Liu, Yi L] So far, for virtualization, we would not allow any guest to flush all the
physical iommu tlb. Hypervisor will limit it even if guest issues invalidate with global
granularity. Jacob just wants to show all the possible granularity. Actually, global gran
can be a big hammer to clear cache, maybe there is usage somehow. For now, I think
we may just remove it.	

Thanks,
Yi L
<span class="quote">
&gt; &gt; &gt; +	IOMMU_INV_GRANU_DOMAIN,		/* all TLBs</span>
<span class="quote">&gt; &gt; &gt; associated with a domain */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_DEVICE,		/* caching</span>
<span class="quote">&gt; &gt; &gt; structure associated with a</span>
<span class="quote">&gt; &gt; &gt; +					 * device ID</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; What is the difference between a DOMAIN and a DEVICE flush?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; Those are based on vt-d context cache flush granularity, domain selective flushes all</span>
<span class="quote">&gt; context caches associated with a domain ID.</span>
<span class="quote">&gt; Device selective flush flushes context caches of a source ID.</span>
<span class="quote">&gt; But like you pointed out below, since context cache flush will come in as unbind call,</span>
<span class="quote">&gt; there is no need to do passdown invalidate. I can remove that.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here I am trying to use all generic definitions, which is a superset of all vendor</span>
<span class="quote">&gt; models. I am likely missing out some non-vt-d cases.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_DOMAN_PAGE,	/* address range with a</span>
<span class="quote">&gt; &gt; &gt; domain */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_ALL_PASID,	/* cache of a given</span>
<span class="quote">&gt; &gt; &gt; PASID */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_PASID_SEL,	/* only invalidate</span>
<span class="quote">&gt; &gt; &gt; specified PASID */ +</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_NG_ALL_PASID,	/* non-global within</span>
<span class="quote">&gt; &gt; &gt; all PASIDs */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_NG_PASID,	/* non-global within a</span>
<span class="quote">&gt; &gt; &gt; PASIDs */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_GRANU_PAGE_PASID,	/* page-selective</span>
<span class="quote">&gt; &gt; &gt; within a PASID */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_NR_GRANU,</span>
<span class="quote">&gt; &gt; &gt; +};</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +enum iommu_inv_type {</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_TYPE_DTLB,	/* device IOTLB */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_TYPE_TLB,	/* IOMMU paging structure cache</span>
<span class="quote">&gt; &gt; &gt; */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_TYPE_PASID,	/* PASID cache */</span>
<span class="quote">&gt; &gt; &gt; +	IOMMU_INV_TYPE_CONTEXT,	/* device context entry</span>
<span class="quote">&gt; &gt; &gt; cache */</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Is that really needed? When the guest updates it context-entry</span>
<span class="quote">&gt; &gt; equivalent it translates to bind_pasid_table/unbind_pasid_table calls,</span>
<span class="quote">&gt; &gt; no?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; Right no need to passdown context cache invalidation for VT-d. I just wasn&#39;t sure it is</span>
<span class="quote">&gt; the same for all models. Again, trying to have a superset of generic fields.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Jacob</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Oct. 11, 2017, 9:51 a.m.</div>
<pre class="content">
On Wed, Oct 11, 2017 at 07:54:32AM +0000, Liu, Yi L wrote:
<span class="quote">&gt; I agree that iommu_invalidate() is too generic. Additionally, also</span>
<span class="quote">&gt; better to avoid making it svm specific.</span>

I also don&#39;t like to name the functions after the Intel feature, but I
failed to come up with a better alternative so far. The only one I can
come up with for now would be &#39;iovm&#39;, so the function name would be
iommu_iovm_invalidate().

On the other side, the ARM guys also already call the feature set
&#39;SVM&#39;, despite it being ambiguous and Intel specific. I don&#39;t have a
strong opinion on the naming.
<span class="quote">
&gt; The reason we introduce this API is in vSVM case is that guest owns</span>
<span class="quote">&gt; the first level page table(vtd). If we use similar mechanism for</span>
<span class="quote">&gt; vIOVA, then we also need to passdown guest&#39;s vIOVA tlb flush.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Since it is to expose an API for iommu tlb flushes requests from</span>
<span class="quote">&gt; userspace/guest which is out of iommu. How about naming it as</span>
<span class="quote">&gt; iommu_tlb_external_invalidate()?</span>

If you only read the function name, &#39;external&#39; could mean everything. It
is not clear from the name when to use this function. So something like
iommu_iovm_invalidate() is better.


	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170615">Liu, Yi L</a> - Oct. 11, 2017, 11:54 a.m.</div>
<pre class="content">
<span class="quote">&gt; On Wed, Oct 11, 2017 at 07:54:32AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt; &gt; I agree that iommu_invalidate() is too generic. Additionally, also</span>
<span class="quote">&gt; &gt; better to avoid making it svm specific.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I also don&#39;t like to name the functions after the Intel feature, but I failed to come up</span>
<span class="quote">&gt; with a better alternative so far. The only one I can come up with for now would be</span>
<span class="quote">&gt; &#39;iovm&#39;, so the function name would be iommu_iovm_invalidate().</span>

[Liu, Yi L] Actually, I&#39;m not against &#39;SVM&#39; terms. Just want to make it be compatible
with future usage in non-SVM scenario.
<span class="quote">
&gt; On the other side, the ARM guys also already call the feature set &#39;SVM&#39;, despite it</span>
<span class="quote">&gt; being ambiguous and Intel specific. I don&#39;t have a strong opinion on the naming.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; The reason we introduce this API is in vSVM case is that guest owns</span>
<span class="quote">&gt; &gt; the first level page table(vtd). If we use similar mechanism for</span>
<span class="quote">&gt; &gt; vIOVA, then we also need to passdown guest&#39;s vIOVA tlb flush.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Since it is to expose an API for iommu tlb flushes requests from</span>
<span class="quote">&gt; &gt; userspace/guest which is out of iommu. How about naming it as</span>
<span class="quote">&gt; &gt; iommu_tlb_external_invalidate()?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you only read the function name, &#39;external&#39; could mean everything. It is not clear</span>

[Liu, Yi L] Agree, &#39;external&#39; is also unclear.
<span class="quote">
&gt; from the name when to use this function. So something like</span>
<span class="quote">&gt; iommu_iovm_invalidate() is better.</span>
<span class="quote">&gt; </span>

[Liu, Yi L] I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?

Thanks,
Yi L
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Oct. 11, 2017, 12:15 p.m.</div>
<pre class="content">
On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:
<span class="quote">&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>

It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;
that is not ambiguous (afaik) and not specific to Intel.


	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Oct. 11, 2017, 12:48 p.m.</div>
<pre class="content">
On 11/10/17 13:15, Joerg Roedel wrote:
<span class="quote">&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt; that is not ambiguous (afaik) and not specific to Intel.</span>

I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s why
I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise enough
though, since the name could as well be used without shared tables, for
classical map/unmap and IOVAs. Kevin Tian suggested SVA &quot;Shared Virtual
Addressing&quot; last time, which is a little more clear than SVM and isn&#39;t
used elsewhere in the kernel either.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Oct. 12, 2017, 7:43 a.m.</div>
<pre class="content">
On Wed, Oct 11, 2017 at 01:48:00PM +0100, Jean-Philippe Brucker wrote:
<span class="quote">&gt; I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s why</span>
<span class="quote">&gt; I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise enough</span>
<span class="quote">&gt; though, since the name could as well be used without shared tables, for</span>
<span class="quote">&gt; classical map/unmap and IOVAs. Kevin Tian suggested SVA &quot;Shared Virtual</span>
<span class="quote">&gt; Addressing&quot; last time, which is a little more clear than SVM and isn&#39;t</span>
<span class="quote">&gt; used elsewhere in the kernel either.</span>

SVA sounds even better. Feel free to use that for all the PRI/PASID
related code.


Regards,

	Joerg
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173273">Bob Liu</a> - Oct. 12, 2017, 9:38 a.m.</div>
<pre class="content">
On 2017/10/11 20:48, Jean-Philippe Brucker wrote:
<span class="quote">&gt; On 11/10/17 13:15, Joerg Roedel wrote:</span>
<span class="quote">&gt;&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt;&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt;&gt; that is not ambiguous (afaik) and not specific to Intel.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s why</span>
<span class="quote">&gt; I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise enough</span>
<span class="quote">&gt; though, since the name could as well be used without shared tables, for</span>
<span class="quote">&gt; classical map/unmap and IOVAs. Kevin Tian suggested SVA &quot;Shared Virtual</span>
<span class="quote">&gt; Addressing&quot; last time, which is a little more clear than SVM and isn&#39;t</span>
<span class="quote">&gt; used elsewhere in the kernel either.</span>
<span class="quote">&gt; </span>

The process &quot;vaddr&quot; can be the same as &quot;IOVA&quot; by using the classical map/unmap way.
This is also a kind of share virtual memory/address(except have to pin physical memory).
How to distinguish these two different implementation of &quot;share virtual memory/address&quot;?

--
Regards,
Liubo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170615">Liu, Yi L</a> - Oct. 12, 2017, 9:50 a.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Bob Liu [mailto:liubo95@huawei.com]</span>
<span class="quote">&gt; Sent: Thursday, October 12, 2017 5:39 PM</span>
<span class="quote">&gt; To: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;; Joerg Roedel</span>
<span class="quote">&gt; &lt;joro@8bytes.org&gt;; Liu, Yi L &lt;yi.l.liu@intel.com&gt;</span>
<span class="quote">&gt; Cc: Lan, Tianyu &lt;tianyu.lan@intel.com&gt;; Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;; Greg</span>
<span class="quote">&gt; Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; Wysocki, Rafael J</span>
<span class="quote">&gt; &lt;rafael.j.wysocki@intel.com&gt;; LKML &lt;linux-kernel@vger.kernel.org&gt;;</span>
<span class="quote">&gt; iommu@lists.linux-foundation.org; David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="quote">&gt; Subject: Re: [PATCH v2 03/16] iommu: introduce iommu invalidate API function</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2017/10/11 20:48, Jean-Philippe Brucker wrote:</span>
<span class="quote">&gt; &gt; On 11/10/17 13:15, Joerg Roedel wrote:</span>
<span class="quote">&gt; &gt;&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt; &gt;&gt; that is not ambiguous (afaik) and not specific to Intel.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s</span>
<span class="quote">&gt; &gt; why I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise</span>
<span class="quote">&gt; &gt; enough though, since the name could as well be used without shared</span>
<span class="quote">&gt; &gt; tables, for classical map/unmap and IOVAs. Kevin Tian suggested SVA</span>
<span class="quote">&gt; &gt; &quot;Shared Virtual Addressing&quot; last time, which is a little more clear</span>
<span class="quote">&gt; &gt; than SVM and isn&#39;t used elsewhere in the kernel either.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The process &quot;vaddr&quot; can be the same as &quot;IOVA&quot; by using the classical map/unmap</span>
<span class="quote">&gt; way.</span>
<span class="quote">&gt; This is also a kind of share virtual memory/address(except have to pin physical</span>
<span class="quote">&gt; memory).</span>
<span class="quote">&gt; How to distinguish these two different implementation of &quot;share virtual</span>
<span class="quote">&gt; memory/address&quot;?</span>
<span class="quote">&gt; </span>
[Liu, Yi L] Not sure if I get your idea well. Process &quot;vaddr&quot; is owned by process and
maintained by mmu, while &quot;IOVA&quot; is maintained by iommu. So they are different in the
way they are maintained. Since process &quot;vaddr&quot; is maintained by mmu and then used by
iommu, so we call it shared virtual memory/address. This is how &quot;shared&quot; term comes.
I didn&#39;t quite get &quot; two different implementation of &quot;share virtual memory/address&quot;&quot;.
Maybe you can explain further more.

Regards,
Yi L
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173273">Bob Liu</a> - Oct. 12, 2017, 10:07 a.m.</div>
<pre class="content">
On 2017/10/12 17:50, Liu, Yi L wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; -----Original Message-----</span>
<span class="quote">&gt;&gt; From: Bob Liu [mailto:liubo95@huawei.com]</span>
<span class="quote">&gt;&gt; Sent: Thursday, October 12, 2017 5:39 PM</span>
<span class="quote">&gt;&gt; To: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;; Joerg Roedel</span>
<span class="quote">&gt;&gt; &lt;joro@8bytes.org&gt;; Liu, Yi L &lt;yi.l.liu@intel.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Lan, Tianyu &lt;tianyu.lan@intel.com&gt;; Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;; Greg</span>
<span class="quote">&gt;&gt; Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; Wysocki, Rafael J</span>
<span class="quote">&gt;&gt; &lt;rafael.j.wysocki@intel.com&gt;; LKML &lt;linux-kernel@vger.kernel.org&gt;;</span>
<span class="quote">&gt;&gt; iommu@lists.linux-foundation.org; David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="quote">&gt;&gt; Subject: Re: [PATCH v2 03/16] iommu: introduce iommu invalidate API function</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 2017/10/11 20:48, Jean-Philippe Brucker wrote:</span>
<span class="quote">&gt;&gt;&gt; On 11/10/17 13:15, Joerg Roedel wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt;&gt;&gt;&gt; that is not ambiguous (afaik) and not specific to Intel.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s</span>
<span class="quote">&gt;&gt;&gt; why I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise</span>
<span class="quote">&gt;&gt;&gt; enough though, since the name could as well be used without shared</span>
<span class="quote">&gt;&gt;&gt; tables, for classical map/unmap and IOVAs. Kevin Tian suggested SVA</span>
<span class="quote">&gt;&gt;&gt; &quot;Shared Virtual Addressing&quot; last time, which is a little more clear</span>
<span class="quote">&gt;&gt;&gt; than SVM and isn&#39;t used elsewhere in the kernel either.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The process &quot;vaddr&quot; can be the same as &quot;IOVA&quot; by using the classical map/unmap</span>
<span class="quote">&gt;&gt; way.</span>
<span class="quote">&gt;&gt; This is also a kind of share virtual memory/address(except have to pin physical</span>
<span class="quote">&gt;&gt; memory).</span>
<span class="quote">&gt;&gt; How to distinguish these two different implementation of &quot;share virtual</span>
<span class="quote">&gt;&gt; memory/address&quot;?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; [Liu, Yi L] Not sure if I get your idea well. Process &quot;vaddr&quot; is owned by process and</span>
<span class="quote">&gt; maintained by mmu, while &quot;IOVA&quot; is maintained by iommu. So they are different in the</span>
<span class="quote">&gt; way they are maintained. Since process &quot;vaddr&quot; is maintained by mmu and then used by</span>
<span class="quote">&gt; iommu, so we call it shared virtual memory/address. This is how &quot;shared&quot; term comes.</span>

I think from the view of application, the share virtual memory/address(or Nvidia-CUDA unify virtual address) is like this:

1. vaddr = malloc(); e.g vaddr=0x10000
2. device can get the same data(accessing the same physical memory) through same address e.g 0x10000, and don&#39;t care about it&#39;s a vaddr or IOVA..
(actually in Nvidia-cuda case, the data will be migrated between system-ddr and gpu-memory, but the vaddr is always the same for CPU and GPU).

So there are two ways(beside Nvidia way) to implement this requirement:
1)
get the physical memory of vaddr;
dma_map the paddr to iova;
If we appoint iova = vaddr (e.g iova can be controlled by the user space driver through vfio DMA_MAP), 
This can also be called share virtual address between CPU process and device..

2) 
The second way is what this RFC did.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Oct. 12, 2017, 10:26 a.m.</div>
<pre class="content">
On 12/10/17 11:07, Bob Liu wrote:
<span class="quote">&gt; On 2017/10/12 17:50, Liu, Yi L wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; -----Original Message-----</span>
<span class="quote">&gt;&gt;&gt; From: Bob Liu [mailto:liubo95@huawei.com]</span>
<span class="quote">&gt;&gt;&gt; Sent: Thursday, October 12, 2017 5:39 PM</span>
<span class="quote">&gt;&gt;&gt; To: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;; Joerg Roedel</span>
<span class="quote">&gt;&gt;&gt; &lt;joro@8bytes.org&gt;; Liu, Yi L &lt;yi.l.liu@intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Lan, Tianyu &lt;tianyu.lan@intel.com&gt;; Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;; Greg</span>
<span class="quote">&gt;&gt;&gt; Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; Wysocki, Rafael J</span>
<span class="quote">&gt;&gt;&gt; &lt;rafael.j.wysocki@intel.com&gt;; LKML &lt;linux-kernel@vger.kernel.org&gt;;</span>
<span class="quote">&gt;&gt;&gt; iommu@lists.linux-foundation.org; David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="quote">&gt;&gt;&gt; Subject: Re: [PATCH v2 03/16] iommu: introduce iommu invalidate API function</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 2017/10/11 20:48, Jean-Philippe Brucker wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On 11/10/17 13:15, Joerg Roedel wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; that is not ambiguous (afaik) and not specific to Intel.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I wonder if SVM originated in OpenCL first, rather than intel? That&#39;s</span>
<span class="quote">&gt;&gt;&gt;&gt; why I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is precise</span>
<span class="quote">&gt;&gt;&gt;&gt; enough though, since the name could as well be used without shared</span>
<span class="quote">&gt;&gt;&gt;&gt; tables, for classical map/unmap and IOVAs. Kevin Tian suggested SVA</span>
<span class="quote">&gt;&gt;&gt;&gt; &quot;Shared Virtual Addressing&quot; last time, which is a little more clear</span>
<span class="quote">&gt;&gt;&gt;&gt; than SVM and isn&#39;t used elsewhere in the kernel either.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The process &quot;vaddr&quot; can be the same as &quot;IOVA&quot; by using the classical map/unmap</span>
<span class="quote">&gt;&gt;&gt; way.</span>
<span class="quote">&gt;&gt;&gt; This is also a kind of share virtual memory/address(except have to pin physical</span>
<span class="quote">&gt;&gt;&gt; memory).</span>
<span class="quote">&gt;&gt;&gt; How to distinguish these two different implementation of &quot;share virtual</span>
<span class="quote">&gt;&gt;&gt; memory/address&quot;?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; [Liu, Yi L] Not sure if I get your idea well. Process &quot;vaddr&quot; is owned by process and</span>
<span class="quote">&gt;&gt; maintained by mmu, while &quot;IOVA&quot; is maintained by iommu. So they are different in the</span>
<span class="quote">&gt;&gt; way they are maintained. Since process &quot;vaddr&quot; is maintained by mmu and then used by</span>
<span class="quote">&gt;&gt; iommu, so we call it shared virtual memory/address. This is how &quot;shared&quot; term comes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think from the view of application, the share virtual memory/address(or Nvidia-CUDA unify virtual address) is like this:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1. vaddr = malloc(); e.g vaddr=0x10000</span>
<span class="quote">&gt; 2. device can get the same data(accessing the same physical memory) through same address e.g 0x10000, and don&#39;t care about it&#39;s a vaddr or IOVA..</span>
<span class="quote">&gt; (actually in Nvidia-cuda case, the data will be migrated between system-ddr and gpu-memory, but the vaddr is always the same for CPU and GPU).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So there are two ways(beside Nvidia way) to implement this requirement:</span>
<span class="quote">&gt; 1)</span>
<span class="quote">&gt; get the physical memory of vaddr;</span>
<span class="quote">&gt; dma_map the paddr to iova;</span>
<span class="quote">&gt; If we appoint iova = vaddr (e.g iova can be controlled by the user space driver through vfio DMA_MAP), </span>
<span class="quote">&gt; This can also be called share virtual address between CPU process and device..</span>

This could probably be implemented by augmenting the iommu_map/unmap API
to take a PASID, as the mm subsystem isn&#39;t really involved and there isn&#39;t
any need for bind/unbind.

Maybe we should continue the conversation on the other thread though,
since this one is about sharing PASID tables with a guest.

Thanks,
Jean
<span class="quote">
&gt; 2) </span>
<span class="quote">&gt; The second way is what this RFC did.</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170615">Liu, Yi L</a> - Oct. 12, 2017, 10:33 a.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Bob Liu [mailto:liubo95@huawei.com]</span>
<span class="quote">&gt; Sent: Thursday, October 12, 2017 6:08 PM</span>
<span class="quote">&gt; To: Liu, Yi L &lt;yi.l.liu@intel.com&gt;; Jean-Philippe Brucker &lt;jean-</span>
<span class="quote">&gt; philippe.brucker@arm.com&gt;; Joerg Roedel &lt;joro@8bytes.org&gt;</span>
<span class="quote">&gt; Cc: Lan, Tianyu &lt;tianyu.lan@intel.com&gt;; Liu, Yi L &lt;yi.l.liu@linux.intel.com&gt;; Greg</span>
<span class="quote">&gt; Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;; Wysocki, Rafael J</span>
<span class="quote">&gt; &lt;rafael.j.wysocki@intel.com&gt;; LKML &lt;linux-kernel@vger.kernel.org&gt;;</span>
<span class="quote">&gt; iommu@lists.linux-foundation.org; David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="quote">&gt; Subject: Re: [PATCH v2 03/16] iommu: introduce iommu invalidate API function</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2017/10/12 17:50, Liu, Yi L wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; -----Original Message-----</span>
<span class="quote">&gt; &gt;&gt; From: Bob Liu [mailto:liubo95@huawei.com]</span>
<span class="quote">&gt; &gt;&gt; Sent: Thursday, October 12, 2017 5:39 PM</span>
<span class="quote">&gt; &gt;&gt; To: Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt;; Joerg</span>
<span class="quote">&gt; &gt;&gt; Roedel &lt;joro@8bytes.org&gt;; Liu, Yi L &lt;yi.l.liu@intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; Cc: Lan, Tianyu &lt;tianyu.lan@intel.com&gt;; Liu, Yi L</span>
<span class="quote">&gt; &gt;&gt; &lt;yi.l.liu@linux.intel.com&gt;; Greg Kroah-Hartman</span>
<span class="quote">&gt; &gt;&gt; &lt;gregkh@linuxfoundation.org&gt;; Wysocki, Rafael J</span>
<span class="quote">&gt; &gt;&gt; &lt;rafael.j.wysocki@intel.com&gt;; LKML &lt;linux-kernel@vger.kernel.org&gt;;</span>
<span class="quote">&gt; &gt;&gt; iommu@lists.linux-foundation.org; David Woodhouse</span>
<span class="quote">&gt; &gt;&gt; &lt;dwmw2@infradead.org&gt;</span>
<span class="quote">&gt; &gt;&gt; Subject: Re: [PATCH v2 03/16] iommu: introduce iommu invalidate API</span>
<span class="quote">&gt; &gt;&gt; function</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On 2017/10/11 20:48, Jean-Philippe Brucker wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; On 11/10/17 13:15, Joerg Roedel wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Wed, Oct 11, 2017 at 11:54:52AM +0000, Liu, Yi L wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; I didn&#39;t quite get &#39;iovm&#39; mean. Can you explain a bit about the idea?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; It&#39;s short for IO Virtual Memory, basically a replacement term for &#39;svm&#39;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; that is not ambiguous (afaik) and not specific to Intel.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I wonder if SVM originated in OpenCL first, rather than intel?</span>
<span class="quote">&gt; &gt;&gt;&gt; That&#39;s why I&#39;m using it, but it is ambiguous. I&#39;m not sure IOVM is</span>
<span class="quote">&gt; &gt;&gt;&gt; precise enough though, since the name could as well be used without</span>
<span class="quote">&gt; &gt;&gt;&gt; shared tables, for classical map/unmap and IOVAs. Kevin Tian</span>
<span class="quote">&gt; &gt;&gt;&gt; suggested SVA &quot;Shared Virtual Addressing&quot; last time, which is a</span>
<span class="quote">&gt; &gt;&gt;&gt; little more clear than SVM and isn&#39;t used elsewhere in the kernel either.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; The process &quot;vaddr&quot; can be the same as &quot;IOVA&quot; by using the classical</span>
<span class="quote">&gt; &gt;&gt; map/unmap way.</span>
<span class="quote">&gt; &gt;&gt; This is also a kind of share virtual memory/address(except have to</span>
<span class="quote">&gt; &gt;&gt; pin physical memory).</span>
<span class="quote">&gt; &gt;&gt; How to distinguish these two different implementation of &quot;share</span>
<span class="quote">&gt; &gt;&gt; virtual memory/address&quot;?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; [Liu, Yi L] Not sure if I get your idea well. Process &quot;vaddr&quot; is owned</span>
<span class="quote">&gt; &gt; by process and maintained by mmu, while &quot;IOVA&quot; is maintained by iommu.</span>
<span class="quote">&gt; &gt; So they are different in the way they are maintained. Since process</span>
<span class="quote">&gt; &gt; &quot;vaddr&quot; is maintained by mmu and then used by iommu, so we call it shared virtual</span>
<span class="quote">&gt; memory/address. This is how &quot;shared&quot; term comes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think from the view of application, the share virtual memory/address(or Nvidia-</span>
<span class="quote">&gt; CUDA unify virtual address) is like this:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1. vaddr = malloc(); e.g vaddr=0x10000</span>
<span class="quote">&gt; 2. device can get the same data(accessing the same physical memory) through same</span>
<span class="quote">&gt; address e.g 0x10000, and don&#39;t care about it&#39;s a vaddr or IOVA..</span>
<span class="quote">&gt; (actually in Nvidia-cuda case, the data will be migrated between system-ddr and gpu-</span>
<span class="quote">&gt; memory, but the vaddr is always the same for CPU and GPU).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So there are two ways(beside Nvidia way) to implement this requirement:</span>
<span class="quote">&gt; 1)</span>
<span class="quote">&gt; get the physical memory of vaddr;</span>
<span class="quote">&gt; dma_map the paddr to iova;</span>
<span class="quote">&gt; If we appoint iova = vaddr (e.g iova can be controlled by the user space driver</span>
<span class="quote">&gt; through vfio DMA_MAP), This can also be called share virtual address between CPU</span>
<span class="quote">&gt; process and device..</span>

[Liu, Yi L] I see. Thx for raising it. I think this is a software way to get data shared between
process and device. However, it&#39;s not sharing the virtual address space since device would
still use iova to do access memory. So it should be another story.

Regards,
Yi L
<span class="quote">
&gt; 2)</span>
<span class="quote">&gt; The second way is what this RFC did.</span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 761cf50..5a14154 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -1341,6 +1341,20 @@</span> <span class="p_context"> int iommu_unbind_pasid_table(struct iommu_domain *domain, struct device *dev)</span>
 }
 EXPORT_SYMBOL_GPL(iommu_unbind_pasid_table);
 
<span class="p_add">+int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!domain-&gt;ops-&gt;invalidate))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = domain-&gt;ops-&gt;invalidate(domain, dev, inv_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_invalidate);</span>
<span class="p_add">+</span>
 static void __iommu_detach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
<span class="p_header">diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="p_header">index 672cc06..4af1820 100644</span>
<span class="p_header">--- a/include/linux/iommu.h</span>
<span class="p_header">+++ b/include/linux/iommu.h</span>
<span class="p_chunk">@@ -190,6 +190,7 @@</span> <span class="p_context"> struct iommu_resv_region {</span>
  * @pgsize_bitmap: bitmap of all possible supported page sizes
  * @bind_pasid_table: bind pasid table pointer for guest SVM
  * @unbind_pasid_table: unbind pasid table pointer and restore defaults
<span class="p_add">+ * @invalidate: invalidate translation caches</span>
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
<span class="p_chunk">@@ -243,6 +244,8 @@</span> <span class="p_context"> struct iommu_ops {</span>
 				struct pasid_table_config *pasidt_binfo);
 	int (*unbind_pasid_table)(struct iommu_domain *domain,
 				struct device *dev);
<span class="p_add">+	int (*invalidate)(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info);</span>
 
 	unsigned long pgsize_bitmap;
 };
<span class="p_chunk">@@ -309,6 +312,9 @@</span> <span class="p_context"> extern int iommu_bind_pasid_table(struct iommu_domain *domain,</span>
 		struct device *dev, struct pasid_table_config *pasidt_binfo);
 extern int iommu_unbind_pasid_table(struct iommu_domain *domain,
 				struct device *dev);
<span class="p_add">+extern int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info);</span>
<span class="p_add">+</span>
 extern struct iommu_domain *iommu_get_domain_for_dev(struct device *dev);
 extern int iommu_map(struct iommu_domain *domain, unsigned long iova,
 		     phys_addr_t paddr, size_t size, int prot);
<span class="p_chunk">@@ -721,6 +727,12 @@</span> <span class="p_context"> int iommu_unbind_pasid_table(struct iommu_domain *domain, struct device *dev)</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static inline int iommu_invalidate(struct iommu_domain *domain,</span>
<span class="p_add">+		struct device *dev, struct tlb_invalidate_info *inv_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_IOMMU_API */
 
 #endif /* __LINUX_IOMMU_H */
<span class="p_header">diff --git a/include/uapi/linux/iommu.h b/include/uapi/linux/iommu.h</span>
<span class="p_header">index aeeaf0e..ee11aae 100644</span>
<span class="p_header">--- a/include/uapi/linux/iommu.h</span>
<span class="p_header">+++ b/include/uapi/linux/iommu.h</span>
<span class="p_chunk">@@ -52,4 +52,66 @@</span> <span class="p_context"> struct pasid_table_config {</span>
 	};
 };
 
<span class="p_add">+enum iommu_inv_granularity {</span>
<span class="p_add">+	IOMMU_INV_GRANU_GLOBAL,		/* all TLBs invalidated */</span>
<span class="p_add">+	IOMMU_INV_GRANU_DOMAIN,		/* all TLBs associated with a domain */</span>
<span class="p_add">+	IOMMU_INV_GRANU_DEVICE,		/* caching structure associated with a</span>
<span class="p_add">+					 * device ID</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	IOMMU_INV_GRANU_DOMAN_PAGE,	/* address range with a domain */</span>
<span class="p_add">+	IOMMU_INV_GRANU_ALL_PASID,	/* cache of a given PASID */</span>
<span class="p_add">+	IOMMU_INV_GRANU_PASID_SEL,	/* only invalidate specified PASID */</span>
<span class="p_add">+</span>
<span class="p_add">+	IOMMU_INV_GRANU_NG_ALL_PASID,	/* non-global within all PASIDs */</span>
<span class="p_add">+	IOMMU_INV_GRANU_NG_PASID,	/* non-global within a PASIDs */</span>
<span class="p_add">+	IOMMU_INV_GRANU_PAGE_PASID,	/* page-selective within a PASID */</span>
<span class="p_add">+	IOMMU_INV_NR_GRANU,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum iommu_inv_type {</span>
<span class="p_add">+	IOMMU_INV_TYPE_DTLB,	/* device IOTLB */</span>
<span class="p_add">+	IOMMU_INV_TYPE_TLB,	/* IOMMU paging structure cache */</span>
<span class="p_add">+	IOMMU_INV_TYPE_PASID,	/* PASID cache */</span>
<span class="p_add">+	IOMMU_INV_TYPE_CONTEXT,	/* device context entry cache */</span>
<span class="p_add">+	IOMMU_INV_NR_TYPE</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * Translation cache invalidation header that contains mandatory meta data.</span>
<span class="p_add">+ * @version:	info format version, expecting future extesions</span>
<span class="p_add">+ * @type:	type of translation cache to be invalidated</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct tlb_invalidate_hdr {</span>
<span class="p_add">+	__u32 version;</span>
<span class="p_add">+#define TLB_INV_HDR_VERSION_1 1</span>
<span class="p_add">+	enum iommu_inv_type type;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * Translation cache invalidation information, contains generic IOMMU</span>
<span class="p_add">+ * data which can be parsed based on model ID by model specific drivers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @granularity:	requested invalidation granularity, type dependent</span>
<span class="p_add">+ * @size:		2^size of 4K pages, 0 for 4k, 9 for 2MB, etc.</span>
<span class="p_add">+ * @pasid:		processor address space ID value per PCI spec.</span>
<span class="p_add">+ * @addr:		page address to be invalidated</span>
<span class="p_add">+ * @flags	IOMMU_INVALIDATE_NO_PASID: targets non-pasid mappings,</span>
<span class="p_add">+ *					@pasid is not valid</span>
<span class="p_add">+ *		IOMMU_INVALIDATE_ADDR_LEAF: indicating that the pIOMMU</span>
<span class="p_add">+ *		IOMMU_INVALIDATE_GLOBAL_PAGE: global pages</span>
<span class="p_add">+ *		IOMMU_INVALIDATE_DMA_PASID: DMA request with PASID</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct tlb_invalidate_info {</span>
<span class="p_add">+	struct tlb_invalidate_hdr	hdr;</span>
<span class="p_add">+	enum iommu_inv_granularity	granularity;</span>
<span class="p_add">+	__u32		flags;</span>
<span class="p_add">+#define IOMMU_INVALIDATE_NO_PASID	(1 &lt;&lt; 0)</span>
<span class="p_add">+#define IOMMU_INVALIDATE_ADDR_LEAF	(1 &lt;&lt; 1)</span>
<span class="p_add">+#define IOMMU_INVALIDATE_GLOBAL_PAGE	(1 &lt;&lt; 2)</span>
<span class="p_add">+#define IOMMU_INVALIDATE_DMA_PASID	(1 &lt;&lt; 3)</span>
<span class="p_add">+	__u8		size;</span>
<span class="p_add">+	__u32		pasid;</span>
<span class="p_add">+	__u64		addr;</span>
<span class="p_add">+};</span>
 #endif /* _UAPI_IOMMU_H */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



