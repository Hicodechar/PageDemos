
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.2.95 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.2.95</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 13, 2017, 1:06 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171113130649.GK2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10055907/mbox/"
   >mbox</a>
|
   <a href="/patch/10055907/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10055907/">/patch/10055907/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A627160586 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:07:35 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7C12A2950B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:07:35 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6F8F82951A; Mon, 13 Nov 2017 13:07:35 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9C0F92950B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:07:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932290AbdKMNHZ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 13 Nov 2017 08:07:25 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:46839 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752780AbdKMNHE (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 13 Nov 2017 08:07:04 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1eEERu-0001q0-08; Mon, 13 Nov 2017 13:06:58 +0000
Date: Mon, 13 Nov 2017 13:06:49 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20171113130649.GK2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;ztcJpsdPpsnnlAp8&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.2.95
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Nov. 13, 2017, 1:06 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.2.95 kernel.

All users of the 3.2 kernel series should upgrade.

The updated 3.2.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.2.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.2.94 is attached to this message.

Ben.

------------

 Makefile                                        |   2 +-
 arch/alpha/include/asm/types.h                  |  14 ++-
 arch/arm/kernel/return_address.c                |   4 -
 arch/arm/mach-pxa/Kconfig                       |   1 +
 arch/x86/kernel/acpi/boot.c                     |   8 ++
 arch/xtensa/kernel/pci-dma.c                    |   4 +
 arch/xtensa/kernel/xtensa_ksyms.c               |   7 +-
 arch/xtensa/mm/cache.c                          |  12 +-
 drivers/acpi/acpica/nsrepair.c                  |   2 +-
 drivers/ata/libata-scsi.c                       |   6 +-
 drivers/block/DAC960.c                          |  18 +--
 drivers/block/drbd/drbd_main.c                  |   9 +-
 drivers/edac/i7300_edac.c                       |   1 +
 drivers/gpio/gpio-tegra.c                       |   6 +-
 drivers/gpu/drm/i915/i915_drv.c                 |   7 --
 drivers/gpu/drm/i915/i915_drv.h                 |   5 +-
 drivers/gpu/drm/i915/intel_display.c            |   8 +-
 drivers/hid/usbhid/hid-core.c                   |  12 +-
 drivers/hwmon/w83781d.c                         |   6 +-
 drivers/idle/intel_idle.c                       |   2 +-
 drivers/infiniband/core/cma.c                   |   2 +
 drivers/infiniband/core/uverbs_cmd.c            |   5 +-
 drivers/infiniband/core/uverbs_main.c           |   3 +-
 drivers/infiniband/hw/cxgb3/iwch_provider.c     |   5 +-
 drivers/infiniband/hw/cxgb4/cq.c                |   1 +
 drivers/infiniband/hw/mlx4/qp.c                 |   2 +-
 drivers/infiniband/ulp/ipoib/ipoib_cm.c         |   1 -
 drivers/infiniband/ulp/ipoib/ipoib_main.c       |   1 +
 drivers/input/mouse/trackpoint.c                |   3 +-
 drivers/input/mouse/trackpoint.h                |   3 +-
 drivers/isdn/gigaset/capi.c                     |   2 +
 drivers/isdn/hardware/eicon/capi20.h            |  60 ++++-----
 drivers/isdn/hardware/mISDN/hfcpci.c            |   4 +-
 drivers/md/dm.c                                 |  10 --
 drivers/media/common/tuners/tda18212.c          |   2 +-
 drivers/media/common/tuners/tda18218.c          |   2 +-
 drivers/media/common/tuners/xc4000.c            |   2 +-
 drivers/media/dvb/dvb-usb/mxl111sf.c            |   1 -
 drivers/media/rc/redrat3.c                      |  52 +++-----
 drivers/misc/vmw_balloon.c                      |  14 +--
 drivers/mtd/devices/sst25l.c                    |   2 +-
 drivers/net/ethernet/amd/nmclan_cs.c            |   4 +-
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |  15 +--
 drivers/net/ethernet/mellanox/mlx4/fw.c         |   4 +
 drivers/net/ethernet/mellanox/mlx4/fw.h         |   1 +
 drivers/net/ethernet/mellanox/mlx4/main.c       |   2 +
 drivers/net/ethernet/qlogic/qlge/qlge_dbg.c     |   2 +-
 drivers/net/ethernet/realtek/r8169.c            |   1 -
 drivers/net/ethernet/sfc/mcdi_mac.c             |  25 ++--
 drivers/net/wireless/ray_cs.c                   |   4 +-
 drivers/net/wireless/rayctl.h                   |   4 +-
 drivers/net/wireless/wl1251/main.c              |   1 +
 drivers/parisc/dino.c                           |   2 +-
 drivers/platform/x86/samsung-laptop.c           |   2 +-
 drivers/rtc/rtc-m41t80.c                        | 157 +-----------------------
 drivers/scsi/advansys.c                         |   3 +-
 drivers/scsi/aic94xx/aic94xx_sds.c              |   5 +-
 drivers/scsi/libsas/sas_scsi_host.c             |  61 ++++-----
 drivers/scsi/mpt2sas/mpt2sas_scsih.c            |   7 +-
 drivers/staging/bcm/Kconfig                     |   1 +
 drivers/staging/comedi/drivers/vmk80xx.c        |   2 +
 drivers/staging/cxt1e1/functions.c              |   9 --
 drivers/staging/cxt1e1/pmcc4.h                  |   1 -
 drivers/staging/iio/accel/lis3l02dq_core.c      |   2 +-
 drivers/staging/iio/adc/ad7298_ring.c           |   2 +-
 drivers/staging/iio/gyro/adis16080_core.c       |   2 +-
 drivers/staging/iio/light/tsl2563.c             |   2 +-
 drivers/staging/iio/resolver/ad2s1210.c         |   2 +-
 drivers/staging/slicoss/slicoss.c               |   2 +-
 drivers/staging/vt6655/device_main.c            |   8 +-
 drivers/staging/wlan-ng/prism2fw.c              | 157 +++++++++++++-----------
 drivers/usb/class/cdc-acm.c                     |   3 +
 drivers/usb/core/config.c                       |  20 ++-
 drivers/usb/core/hcd.c                          |   2 +
 drivers/usb/misc/usbtest.c                      |   5 +-
 drivers/usb/renesas_usbhs/common.c              |  10 +-
 drivers/usb/serial/cp210x.c                     |   1 +
 drivers/usb/serial/mct_u232.c                   |   2 +-
 drivers/usb/storage/isd200.c                    |   5 +-
 fs/bio.c                                        |   8 ++
 fs/cifs/cifssmb.c                               |  24 ++--
 fs/cifs/dir.c                                   |   8 ++
 fs/ecryptfs/keystore.c                          |   2 +-
 fs/eventpoll.c                                  |  38 ++++--
 fs/fuse/cuse.c                                  |   2 +-
 fs/fuse/file.c                                  |   2 +-
 fs/nfs/client.c                                 |   1 +
 fs/nilfs2/btree.c                               |   2 +-
 fs/nilfs2/recovery.c                            |   4 +-
 fs/nilfs2/super.c                               |   5 +-
 fs/ocfs2/acl.c                                  |  24 ++--
 fs/xfs/xfs_ialloc.c                             |   2 +-
 include/asm-generic/topology.h                  |   6 +-
 include/linux/device-mapper.h                   |  70 ++++-------
 include/linux/mlx4/device.h                     |   1 +
 include/linux/mtd/map.h                         |   2 +-
 include/linux/perf_event.h                      |   6 -
 include/linux/usb/ch9.h                         |   1 +
 include/net/ip6_fib.h                           |  35 +++++-
 include/net/ip6_route.h                         |   2 +-
 include/net/sctp/sctp.h                         |   4 +
 include/scsi/libsas.h                           |   5 +-
 kernel/audit_watch.c                            |  12 +-
 kernel/events/core.c                            | 103 +++++++++++-----
 mm/huge_memory.c                                |   1 -
 mm/mempolicy.c                                  |   5 -
 mm/page_alloc.c                                 |  20 ++-
 net/dccp/probe.c                                |  14 ++-
 net/ipv4/fib_frontend.c                         |   9 +-
 net/ipv6/addrconf.c                             |   2 +-
 net/ipv6/ip6_fib.c                              |  30 +++--
 net/ipv6/ip6_output.c                           |   6 +-
 net/ipv6/ip6_tunnel.c                           |   2 +-
 net/ipv6/route.c                                |  14 ++-
 net/ipv6/xfrm6_policy.c                         |   6 +-
 net/key/af_key.c                                |  48 ++++----
 net/l2tp/l2tp_core.c                            |  65 +++++-----
 net/l2tp/l2tp_core.h                            |  19 ++-
 net/l2tp/l2tp_netlink.c                         |  72 ++++++-----
 net/mac80211/key.c                              |  20 ++-
 net/netfilter/ipvs/ip_vs_xmit.c                 |   2 +-
 net/netfilter/xt_socket.c                       |  12 +-
 net/packet/af_packet.c                          | 104 ++++++++++------
 net/sched/sch_api.c                             |   2 +
 net/sched/sch_cbq.c                             |  10 +-
 net/sched/sch_drr.c                             |   2 +-
 net/sched/sch_hfsc.c                            |   4 +-
 net/sched/sch_htb.c                             |   5 +-
 net/sched/sch_mq.c                              |  10 +-
 net/sched/sch_mqprio.c                          |  19 +--
 net/sched/sch_multiq.c                          |   9 +-
 net/sched/sch_netem.c                           |   4 +-
 net/sched/sch_qfq.c                             |   2 +-
 net/sched/sch_tbf.c                             |   5 +-
 net/xfrm/xfrm_user.c                            |   2 +
 security/keys/key.c                             |  10 ++
 sound/core/control.c                            |   2 +-
 sound/core/seq/seq_clientmgr.c                  |   6 +-
 sound/core/seq/seq_lock.c                       |   4 -
 sound/core/seq/seq_lock.h                       |  12 --
 sound/core/seq/seq_ports.c                      |   7 +-
 sound/pci/hda/patch_conexant.c                  |   1 +
 sound/soc/codecs/adau1373.c                     |   5 +-
 sound/soc/codecs/wm8983.c                       |  41 ++++---
 sound/soc/codecs/wm8985.c                       |  43 +++----
 sound/soc/codecs/wm_hubs.c                      |   2 +-
 sound/usb/caiaq/device.c                        |   2 +-
 sound/usb/card.c                                |  20 +++
 sound/usb/mixer.c                               |  14 ++-
 sound/usb/mixer.h                               |   3 +
 sound/usb/mixer_quirks.c                        |   6 +
 151 files changed, 1028 insertions(+), 893 deletions(-)

A Raghavendra Rao (1):
      Staging: wlan-ng: fix sparse warning in prism2fw.c

Aaron Ma (1):
      Input: trackpoint - add new trackpoint firmware ID

Akinobu Mita (1):
      iio: light: tsl2563: use correct event code

Alan Stern (2):
      usb: usbtest: fix NULL pointer dereference
      USB: core: fix out-of-bounds access bug in usb_get_bos_descriptor()

Alex Vesker (1):
      IB/ipoib: Prevent setting negative values to max_nonsrq_conn_qp

Alexander Potapenko (1):
      sctp: don&#39;t dereference ptr before leaving _sctp_walk_{params, errors}()

Andreas Ruprecht (1):
      Staging: iio/accel: Changed return type of lis3l02dq_read_event_config() to int

Andrew Vincer (1):
      rc: Fix input deadlock and transmit error in redrat3 driver

Andy Shevchenko (1):
      platform/x86: samsung-laptop: Initialize loca variable

Antonio Alecrim Jr (1):
      isdn: hfcpci_softirq: get func return to suppress compiler warning

Antti Palosaari (2):
      tda18218: silence compiler warning
      tda18212: silence compiler warning

Arnd Bergmann (7):
      staging:iio:resolver:ad2s1210 fix negative IIO_ANGL_VEL read
      ARM: pxa: select both FB and FB_W100 for eseries
      qlge: avoid memcpy buffer overflow
      scsi: advansys: remove #warning message
      net: am2150: fix nmclan_cs.c shared interrupt handling
      staging: bcm: add 32-bit host dependency
      staging: vt6655: fix overly large stack usage

Artem Bityutskiy (1):
      mtd: sst25l: kill unused variable

Bart Van Assche (1):
      dm: fix printk() rate limiting code

Ben Hutchings (8):
      alpha: uapi: Add support for __SANE_USERSPACE_TYPES__
      ALSA: seq: Enable &#39;use&#39; locking in all configurations
      mm/huge_memory: Fix unused label warning
      ACPICA: Fix &#39;may be used uninitialized&#39; warning in acpi_ns_repair_object()
      edac: i7300_edac: Fix &#39;may be used uninitialized&#39; warning
      sfc: Merge efx_mcdi_mac_check_fault() and efx_mcdi_get_mac_faults()
      mct_u232: Fix use of uninitialized pointer in mct_u323_startup()
      Linux 3.2.95

Chen Yu (1):
      PM/hibernate: touch NMI watchdog when creating snapshot

Colin Ian King (1):
      usb: storage: return on error to avoid a null pointer dereference

Cong Wang (2):
      wl1251: add a missing spin_lock_init()
      drbd: check MODULE for THIS_MODULE

Dan Carpenter (4):
      libata: array underflow in ata_find_dev()
      cxgb4: Fix error codes in c4iw_create_cq()
      IB/cxgb3: Fix error codes in iwch_alloc_mr()
      mxl111sf: remove an unused variable

Dan Williams (1):
      libsas: prevent double completion of scmds from eh

Daniel Mack (1):
      ALSA: snd-usb-caiaq: initialize card pointer

Danny Kukawka (4):
      drivers/block/DAC960: fix DAC960_V2_IOCTL_Opcode_T -Wenum-compare warning
      drivers/block/DAC960: fix -Wuninitialized warning
      eicon: fix -Warray-bounds warning
      vmw_balloon: fix for a -Wuninitialized warning

David Howells (2):
      KEYS: don&#39;t let add_key() update an uninstantiated key
      intel_idle: Fix a cast to pointer from integer of different size warning in intel_idle

David S. Miller (3):
      dccp: Fix compile warning in probe code.
      pkt_sched: Fix warning false positives.
      ray_cs: Fix array bounds warnings.

Eric Dumazet (2):
      af_key: do not use GFP_KERNEL in atomic contexts
      net_sched: fix error recovery at qdisc creation

Fabio Estevam (2):
      ASoC: wm8993: Refactor set_pll code to avoid GCC warnings
      ASoC: wm8985: Refactor set_pll code to avoid gcc warnings

Florian Fainelli (1):
      r8169: Do not increment tx_dropped in TX ring cleaning

Francesco Ruggeri (1):
      packet: race condition in packet_bind

Greg Kroah-Hartman (2):
      USB: fix out-of-bounds in usb_set_configuration
      staging: comedi: vmk80xx: fix compiler warning

Guenter Roeck (1):
      hwmon: (w83781d) Fix compile warning

Guillaume Nault (8):
      l2tp: initialise session&#39;s refcount before making it reachable
      l2tp: define parameters of l2tp_session_get*() as &quot;const&quot;
      l2tp: hold tunnel while looking up sessions in l2tp_netlink
      l2tp: hold tunnel while processing genl delete command
      l2tp: hold tunnel while handling genl tunnel updates
      l2tp: hold tunnel while handling genl TUNNEL_GET commands
      l2tp: remove useless duplicate session detection in l2tp_netlink
      l2tp: hold tunnel used while creating sessions with netlink

Hannes Reinecke (1):
      aic94xx: Skip reading user settings if flash is not found

Inbar Karmy (1):
      net/mlx4_en: Fix wrong indication of Wake-on-LAN (WoL) support

Ismail, Mustafa (2):
      RDMA/uverbs: Fix the check for port number
      RDMA/core: Initialize port_num in qp_attr

Jaejoong Kim (1):
      HID: usbhid: fix out-of-bounds bug

Jan Kara (2):
      ocfs2: don&#39;t clear SGID when inheriting ACLs
      audit: Fix use after free in audit_remove_watch_rule()

Jeff Kirsher (1):
      am2150: Update nmclan_cs.c to use update PCMCIA API

Jeff Layton (1):
      cifs: silence compiler warnings showing up with gcc-4.7.0

Jiri Olsa (1):
      perf/core: Fix locking for children siblings group read

Joe Perches (1):
      dm: convert DM printk macros to pr_&lt;level&gt; macros

Johan Hovold (1):
      USB: cdc-acm: add device-id for quirky printer

Johannes Berg (1):
      mac80211: accept key reinstall without changing anything

Keith Packard (1):
      drm/i915: Clean up multi-threaded forcewake patch

Kuninori Morimoto (1):
      usb: renesas_usbhs: fixup resume method for autonomy mode

Leed Aguilar (1):
      staging:iio:gyro:adis16080: remove sparse warnings

Leon Romanovsky (2):
      IB/ipoib: Remove double pointer assigning
      RDMA/uverbs: Prevent leak of reserved field

Mahesh Bandewar (1):
      ipv4: initialize fib_trie prior to register_netdev_notifier call.

Mark Rutland (1):
      perf/core: Fix group {cpu,task} validation

Martin KaFai Lau (1):
      ipv6: Add rt6_get_cookie() function

Mateusz Jurczyk (1):
      fuse: initialize the flock flag in fuse_file on allocation

Mathias Krause (2):
      xfrm_user: fix info leak in xfrm_notify_sa()
      xfrm_user: fix info leak in build_aevent()

Mauro Carvalho Chehab (1):
      xc4000: Fix a few warnings

Max Filippov (4):
      xtensa: fix cache aliasing handling code for WT cache
      xtensa: add missing symbol exports
      xtensa: don&#39;t limit csum_partial export by CONFIG_NET
      xtensa: mm/cache: add missing EXPORT_SYMBOLs

Michael Hennerich (1):
      iio: staging: ad7298_ring: Fix maybe-uninitialized warning

Michał Mirosław (1):
      gpio: tegra: fix unbalanced chained_irq_enter/exit

Miklos Szeredi (1):
      cuse: fix uninitialized variable warnings

Nikolay Aleksandrov (6):
      sch_htb: fix crash on init failure
      sch_multiq: fix double free on init failure
      sch_hfsc: fix null pointer deref and double free on init failure
      sch_cbq: fix null pointer dereferences on init failure
      sch_netem: avoid null pointer deref on init failure
      sch_tbf: fix two null pointer dereferences on init failure

Oleg Nesterov (1):
      epoll: fix race between ep_poll_callback(POLLFREE) and ep_free()/ep_remove()

Omar Sandoval (1):
      xfs: fix inobt inode allocation search optimization

Pablo Neira Ayuso (1):
      netfilter: xt_socket: fix compilation warnings with gcc 4.7

Paul Bolle (3):
      IB/mlx4: Fix compiler warning about uninitialized &#39;vlan&#39; variable
      gigaset: silence GCC warning for unused &#39;format_ie&#39;
      drivers/rtc/rtc-m41t80.c: remove disabled alarm functionality

Peter Huewe (1):
      staging/slicoss: Fix operation may be undefined warning

Peter Zijlstra (2):
      perf/core: Invert perf_read_group() loops
      perf: Tighten (and fix) the grouping condition

Rafael J. Wysocki (1):
      USB: hcd: Mark secondary HCD as dead if the primary one died

Randy Dunlap (1):
      staging: reduce stack usage in prism2fw.c

Reddy, Sreekanth (1):
      mpt2sas: fix for unused variable &#39;event_data&#39; warning

Ronnie Sahlberg (2):
      cifs: return ENAMETOOLONG for overlong names in cifs_open()/cifs_lookup()
      cifs: check MaxPathNameComponentLength != 0 before using it

Ryusuke Konishi (1):
      nilfs2: fix gcc uninitialized-variable warnings in powerpc build

SeongJae Park (1):
      staging: cxt1e1: remove unnecessary function, VMETRO_TRACE

Seunghun Han (1):
      x86/acpi: Prevent out of bound access caused by broken ACPI tables

Simon Que (1):
      eCryptfs: initialize payload_len in keystore.c

Stefan Triller (1):
      USB: serial: cp210x: add support for Qivicon USB ZigBee dongle

Stefano Brivio (1):
      ipv6: accept 64k - 1 packet length in ip6_find_1stfragopt()

Steffen Klassert (1):
      ipv6: Fix may be used uninitialized warning in rt6_check

Steve Dickson (1):
      mount: copy the port field into the cloned nfs_server structure.

Steve French (1):
      CIFS: remove endian related sparse warning

Takashi Iwai (6):
      ALSA: usb-audio: Add mute TLV for playback volumes on C-Media devices
      ALSA: core: Fix unexpected error at replacing user TLV
      ALSA: hda - Add stereo mic quirk for Lenovo G50-70 (17aa:3978)
      ALSA: seq: Fix use-after-free at creating a port
      ALSA: usb-audio: Kill stray URB at exiting
      ALSA: usb-audio: Check out-of-bounds access by corrupted buffer descriptor

Tejun Heo (1):
      cpumask: fix spurious cpumask_of_node() on non-NUMA multi-node configs

Thomas Bogendoerfer (1):
      parisc: pci memory bar assignment fails with 64bit kernels on dino/cujo

Tim Gardner (2):
      ASoC: adau1373: adau1373_hw_params: Silence overflow warning
      ASoC: wm_hubs: Silence reg_r and reg_l &#39;may be used uninitialized&#39; warnings

Uwe Kleine-König (1):
      ARM: 8160/1: drop warning about return_address not using unwind tables

Viresh Kumar (1):
      mtd: map: Fix compilation warning

Vitaly Mayatskikh (1):
      fix unbalanced page refcounting in bio_map_user_iov

Wei Wang (2):
      ipv6: add rcu grace period before freeing fib6_node
      ipv6: fix sparse warning on rt6i_node

Willem de Bruijn (2):
      packet: hold bind lock when rebinding to fanout hook
      packet: in packet_do_bind, test fanout with bind_lock held

Xin Long (1):
      sctp: fix the check for _sctp_walk_params and _sctp_walk_errors

Yishai Hadas (1):
      IB/uverbs: Fix device cleanup

Yoshihiro Shimoda (1):
      usb: renesas_usbhs: fix usbhsc_resume() for !USBHSF_RUNTIME_PWCTRL

zhong jiang (1):
      mm/mempolicy: fix use after free when calling get_mempolicy
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f86a857ae320..d31fe7b0826b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 94</span>
<span class="p_add">+SUBLEVEL = 95</span>
 EXTRAVERSION =
 NAME = Saber-toothed Squirrel
 
<span class="p_header">diff --git a/arch/alpha/include/asm/types.h b/arch/alpha/include/asm/types.h</span>
<span class="p_header">index 881544339c21..5993b2a00471 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/types.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/types.h</span>
<span class="p_chunk">@@ -9,10 +9,18 @@</span> <span class="p_context"></span>
  * need to be careful to avoid a name clashes.
  */
 
<span class="p_del">-#ifdef __KERNEL__</span>
<span class="p_del">-#include &lt;asm-generic/int-ll64.h&gt;</span>
<span class="p_del">-#else</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is here because we used to use l64 for alpha</span>
<span class="p_add">+ * and we don&#39;t want to impact user mode with our change to ll64</span>
<span class="p_add">+ * in the kernel.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * However, some user programs are fine with this.  They can</span>
<span class="p_add">+ * flag __SANE_USERSPACE_TYPES__ to get int-ll64.h here.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#if !defined(__SANE_USERSPACE_TYPES__) &amp;&amp; !defined(__KERNEL__)</span>
 #include &lt;asm-generic/int-l64.h&gt;
<span class="p_add">+#else</span>
<span class="p_add">+#include &lt;asm-generic/int-ll64.h&gt;</span>
 #endif
 
 #ifndef __ASSEMBLY__
<span class="p_header">diff --git a/arch/arm/kernel/return_address.c b/arch/arm/kernel/return_address.c</span>
<span class="p_header">index 8085417555dd..0697db65efaa 100644</span>
<span class="p_header">--- a/arch/arm/kernel/return_address.c</span>
<span class="p_header">+++ b/arch/arm/kernel/return_address.c</span>
<span class="p_chunk">@@ -58,10 +58,6 @@</span> <span class="p_context"> void *return_address(unsigned int level)</span>
 
 #else /* if defined(CONFIG_FRAME_POINTER) &amp;&amp; !defined(CONFIG_ARM_UNWIND) */
 
<span class="p_del">-#if defined(CONFIG_ARM_UNWIND)</span>
<span class="p_del">-#warning &quot;TODO: return_address should use unwind tables&quot;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void *return_address(unsigned int level)
 {
 	return NULL;
<span class="p_header">diff --git a/arch/arm/mach-pxa/Kconfig b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">index 61d3c72ded84..c4100aa4fda8 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_chunk">@@ -563,6 +563,7 @@</span> <span class="p_context"> config ARCH_PXA_ESERIES</span>
 	bool &quot;PXA based Toshiba e-series PDAs&quot;
 	select PXA25x
 	select FB_W100
<span class="p_add">+	select FB</span>
 
 config MACH_E330
 	bool &quot;Toshiba e330&quot;
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index 479d03c9c4c3..6532d9140a0e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -951,6 +951,14 @@</span> <span class="p_context"> void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger, u32 gsi)</span>
 	int pin;
 	struct mpc_intsrc mp_irq;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check bus_irq boundary.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bus_irq &gt;= NR_IRQS_LEGACY) {</span>
<span class="p_add">+		pr_warn(&quot;Invalid bus_irq %u for legacy override\n&quot;, bus_irq);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Convert &#39;gsi&#39; to &#39;ioapic.pin&#39;.
 	 */
<span class="p_header">diff --git a/arch/xtensa/kernel/pci-dma.c b/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_header">index 2783fda76ddc..2d9cc6dbfd78 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/gfp.h&gt;
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
 #include &lt;asm/io.h&gt;
 #include &lt;asm/cacheflush.h&gt;
 
<span class="p_chunk">@@ -62,6 +63,7 @@</span> <span class="p_context"> dma_alloc_coherent(struct device *dev,size_t size,dma_addr_t *handle,gfp_t flag)</span>
 
 	return (void*)uncached;
 }
<span class="p_add">+EXPORT_SYMBOL(dma_alloc_coherent);</span>
 
 void dma_free_coherent(struct device *hwdev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle)
<span class="p_chunk">@@ -73,6 +75,7 @@</span> <span class="p_context"> void dma_free_coherent(struct device *hwdev, size_t size,</span>
 
 	free_pages(addr, get_order(size));
 }
<span class="p_add">+EXPORT_SYMBOL(dma_free_coherent);</span>
 
 
 void consistent_sync(void *vaddr, size_t size, int direction)
<span class="p_chunk">@@ -92,3 +95,4 @@</span> <span class="p_context"> void consistent_sync(void *vaddr, size_t size, int direction)</span>
 		break;
 	}
 }
<span class="p_add">+EXPORT_SYMBOL(consistent_sync);</span>
<span class="p_header">diff --git a/arch/xtensa/kernel/xtensa_ksyms.c b/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_header">index c9a7c5b74a0d..20425ef3b7f0 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_chunk">@@ -39,8 +39,12 @@</span> <span class="p_context"></span>
 EXPORT_SYMBOL(memset);
 EXPORT_SYMBOL(memcpy);
 EXPORT_SYMBOL(memmove);
<span class="p_add">+EXPORT_SYMBOL(__strncpy_user);</span>
<span class="p_add">+EXPORT_SYMBOL(clear_page);</span>
<span class="p_add">+EXPORT_SYMBOL(copy_page);</span>
 
 EXPORT_SYMBOL(kernel_thread);
<span class="p_add">+EXPORT_SYMBOL(empty_zero_page);</span>
 
 /*
  * gcc internal math functions
<span class="p_chunk">@@ -69,12 +73,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(__umodsi3);</span>
 EXPORT_SYMBOL(__udivdi3);
 EXPORT_SYMBOL(__umoddi3);
 
<span class="p_del">-#ifdef CONFIG_NET</span>
 /*
  * Networking support
  */
<span class="p_add">+EXPORT_SYMBOL(csum_partial);</span>
 EXPORT_SYMBOL(csum_partial_copy_generic);
<span class="p_del">-#endif /* CONFIG_NET */</span>
 
 /*
  * Architecture-specific symbols
<span class="p_header">diff --git a/arch/xtensa/mm/cache.c b/arch/xtensa/mm/cache.c</span>
<span class="p_header">index 85df4655d326..1b6246108b3c 100644</span>
<span class="p_header">--- a/arch/xtensa/mm/cache.c</span>
<span class="p_header">+++ b/arch/xtensa/mm/cache.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 /*
  * Any time the kernel writes to a user page cache page, or it is about to
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> void flush_dcache_page(struct page *page)</span>
 
 	/* There shouldn&#39;t be an entry in the cache for this page anymore. */
 }
<span class="p_del">-</span>
<span class="p_add">+EXPORT_SYMBOL(flush_dcache_page);</span>
 
 /*
  * For now, flush the whole cache. FIXME??
<span class="p_chunk">@@ -124,6 +124,7 @@</span> <span class="p_context"> void flush_cache_range(struct vm_area_struct* vma,</span>
 	__flush_invalidate_dcache_all();
 	__invalidate_icache_all();
 }
<span class="p_add">+EXPORT_SYMBOL(local_flush_cache_range);</span>
 
 /* 
  * Remove any entry in the cache for this page. 
<span class="p_chunk">@@ -143,8 +144,9 @@</span> <span class="p_context"> void flush_cache_page(struct vm_area_struct* vma, unsigned long address,</span>
 	__flush_invalidate_dcache_page_alias(virt, phys);
 	__invalidate_icache_page_alias(virt, phys);
 }
<span class="p_add">+EXPORT_SYMBOL(local_flush_cache_page);</span>
 
<span class="p_del">-#endif</span>
<span class="p_add">+#endif /* DCACHE_WAY_SIZE &gt; PAGE_SIZE */</span>
 
 void
 update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)
<span class="p_chunk">@@ -162,7 +164,7 @@</span> <span class="p_context"> update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)</span>
 	invalidate_itlb_mapping(addr);
 	invalidate_dtlb_mapping(addr);
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 	if (!PageReserved(page) &amp;&amp; test_bit(PG_arch_1, &amp;page-&gt;flags)) {
 
<span class="p_chunk">@@ -193,7 +195,7 @@</span> <span class="p_context"> update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)</span>
  * flush_dcache_page() on the page.
  */
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 void copy_to_user_page(struct vm_area_struct *vma, struct page *page, 
 		unsigned long vaddr, void *dst, const void *src,
<span class="p_header">diff --git a/drivers/acpi/acpica/nsrepair.c b/drivers/acpi/acpica/nsrepair.c</span>
<span class="p_header">index ac7b854b0bd7..9d1a5da7ffb4 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/nsrepair.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/nsrepair.c</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> acpi_ns_repair_object(struct acpi_predefined_data *data,</span>
 		      union acpi_operand_object **return_object_ptr)
 {
 	union acpi_operand_object *return_object = *return_object_ptr;
<span class="p_del">-	union acpi_operand_object *new_object;</span>
<span class="p_add">+	union acpi_operand_object *new_object = NULL;</span>
 	acpi_status status;
 
 	ACPI_FUNCTION_NAME(ns_repair_object);
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 01a019eaf30a..c6f7fa440f12 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2755,10 +2755,12 @@</span> <span class="p_context"> static unsigned int atapi_xlat(struct ata_queued_cmd *qc)</span>
 static struct ata_device *ata_find_dev(struct ata_port *ap, int devno)
 {
 	if (!sata_pmp_attached(ap)) {
<span class="p_del">-		if (likely(devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
 			return &amp;ap-&gt;link.device[devno];
 	} else {
<span class="p_del">-		if (likely(devno &lt; ap-&gt;nr_pmp_links))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ap-&gt;nr_pmp_links))</span>
 			return &amp;ap-&gt;pmp_link[devno].device[0];
 	}
 
<span class="p_header">diff --git a/drivers/block/DAC960.c b/drivers/block/DAC960.c</span>
<span class="p_header">index e086fbbbe853..8db9089127c5 100644</span>
<span class="p_header">--- a/drivers/block/DAC960.c</span>
<span class="p_header">+++ b/drivers/block/DAC960.c</span>
<span class="p_chunk">@@ -1177,7 +1177,8 @@</span> <span class="p_context"> static bool DAC960_V1_EnableMemoryMailboxInterface(DAC960_Controller_T</span>
   int TimeoutCounter;
   int i;
 
<span class="p_del">-  </span>
<span class="p_add">+  memset(&amp;CommandMailbox, 0, sizeof(DAC960_V1_CommandMailbox_T));</span>
<span class="p_add">+</span>
   if (pci_set_dma_mask(Controller-&gt;PCIDevice, DMA_BIT_MASK(32)))
 	return DAC960_Failure(Controller, &quot;DMA mask out of range&quot;);
   Controller-&gt;BounceBufferLimit = DMA_BIT_MASK(32);
<span class="p_chunk">@@ -4627,7 +4628,8 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
   DAC960_Controller_T *Controller = Command-&gt;Controller;
   DAC960_CommandType_T CommandType = Command-&gt;CommandType;
   DAC960_V2_CommandMailbox_T *CommandMailbox = &amp;Command-&gt;V2.CommandMailbox;
<span class="p_del">-  DAC960_V2_IOCTL_Opcode_T CommandOpcode = CommandMailbox-&gt;Common.IOCTL_Opcode;</span>
<span class="p_add">+  DAC960_V2_IOCTL_Opcode_T IOCTLOpcode = CommandMailbox-&gt;Common.IOCTL_Opcode;</span>
<span class="p_add">+  DAC960_V2_CommandOpcode_T CommandOpcode = CommandMailbox-&gt;SCSI_10.CommandOpcode;</span>
   DAC960_V2_CommandStatus_T CommandStatus = Command-&gt;V2.CommandStatus;
 
   if (CommandType == DAC960_ReadCommand ||
<span class="p_chunk">@@ -4699,7 +4701,7 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
     {
       if (Controller-&gt;ShutdownMonitoringTimer)
 	      return;
<span class="p_del">-      if (CommandOpcode == DAC960_V2_GetControllerInfo)</span>
<span class="p_add">+      if (IOCTLOpcode == DAC960_V2_GetControllerInfo)</span>
 	{
 	  DAC960_V2_ControllerInfo_T *NewControllerInfo =
 	    Controller-&gt;V2.NewControllerInformation;
<span class="p_chunk">@@ -4719,14 +4721,14 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
 	  memcpy(ControllerInfo, NewControllerInfo,
 		 sizeof(DAC960_V2_ControllerInfo_T));
 	}
<span class="p_del">-      else if (CommandOpcode == DAC960_V2_GetEvent)</span>
<span class="p_add">+      else if (IOCTLOpcode == DAC960_V2_GetEvent)</span>
 	{
 	  if (CommandStatus == DAC960_V2_NormalCompletion) {
 	    DAC960_V2_ReportEvent(Controller, Controller-&gt;V2.Event);
 	  }
 	  Controller-&gt;V2.NextEventSequenceNumber++;
 	}
<span class="p_del">-      else if (CommandOpcode == DAC960_V2_GetPhysicalDeviceInfoValid &amp;&amp;</span>
<span class="p_add">+      else if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid &amp;&amp;</span>
 	       CommandStatus == DAC960_V2_NormalCompletion)
 	{
 	  DAC960_V2_PhysicalDeviceInfo_T *NewPhysicalDeviceInfo =
<span class="p_chunk">@@ -4915,7 +4917,7 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
 	  NewPhysicalDeviceInfo-&gt;LogicalUnit++;
 	  Controller-&gt;V2.PhysicalDeviceIndex++;
 	}
<span class="p_del">-      else if (CommandOpcode == DAC960_V2_GetPhysicalDeviceInfoValid)</span>
<span class="p_add">+      else if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid)</span>
 	{
 	  unsigned int DeviceIndex;
 	  for (DeviceIndex = Controller-&gt;V2.PhysicalDeviceIndex;
<span class="p_chunk">@@ -4938,7 +4940,7 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
 	    }
 	  Controller-&gt;V2.NeedPhysicalDeviceInformation = false;
 	}
<span class="p_del">-      else if (CommandOpcode == DAC960_V2_GetLogicalDeviceInfoValid &amp;&amp;</span>
<span class="p_add">+      else if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid &amp;&amp;</span>
 	       CommandStatus == DAC960_V2_NormalCompletion)
 	{
 	  DAC960_V2_LogicalDeviceInfo_T *NewLogicalDeviceInfo =
<span class="p_chunk">@@ -5065,7 +5067,7 @@</span> <span class="p_context"> static void DAC960_V2_ProcessCompletedCommand(DAC960_Command_T *Command)</span>
 			 [LogicalDeviceNumber] = true;
 	  NewLogicalDeviceInfo-&gt;LogicalDeviceNumber++;
 	}
<span class="p_del">-      else if (CommandOpcode == DAC960_V2_GetLogicalDeviceInfoValid)</span>
<span class="p_add">+      else if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid)</span>
 	{
 	  int LogicalDriveNumber;
 	  for (LogicalDriveNumber = 0;
<span class="p_header">diff --git a/drivers/block/drbd/drbd_main.c b/drivers/block/drbd/drbd_main.c</span>
<span class="p_header">index 0358e55356c8..a6ad652ddfdd 100644</span>
<span class="p_header">--- a/drivers/block/drbd/drbd_main.c</span>
<span class="p_header">+++ b/drivers/block/drbd/drbd_main.c</span>
<span class="p_chunk">@@ -4183,12 +4183,11 @@</span> <span class="p_context"> const char *drbd_buildtag(void)</span>
 	static char buildtag[38] = &quot;\0uilt-in&quot;;
 
 	if (buildtag[0] == 0) {
<span class="p_del">-#ifdef CONFIG_MODULES</span>
<span class="p_del">-		if (THIS_MODULE != NULL)</span>
<span class="p_del">-			sprintf(buildtag, &quot;srcversion: %-24s&quot;, THIS_MODULE-&gt;srcversion);</span>
<span class="p_del">-		else</span>
<span class="p_add">+#ifdef MODULE</span>
<span class="p_add">+		sprintf(buildtag, &quot;srcversion: %-24s&quot;, THIS_MODULE-&gt;srcversion);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		buildtag[0] = &#39;b&#39;;</span>
 #endif
<span class="p_del">-			buildtag[0] = &#39;b&#39;;</span>
 	}
 
 	return buildtag;
<span class="p_header">diff --git a/drivers/edac/i7300_edac.c b/drivers/edac/i7300_edac.c</span>
<span class="p_header">index 1e084260c9c0..9afb59890c65 100644</span>
<span class="p_header">--- a/drivers/edac/i7300_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i7300_edac.c</span>
<span class="p_chunk">@@ -803,6 +803,7 @@</span> <span class="p_context"> static int i7300_init_csrows(struct mem_ctl_info *mci)</span>
 	}
 
 	/* Get the set of MTR[0-7] regs by each branch */
<span class="p_add">+	nr_pages = 0;</span>
 	for (slot = 0; slot &lt; MAX_SLOTS; slot++) {
 		int where = mtr_regs[slot];
 		for (branch = 0; branch &lt; MAX_BRANCHES; branch++) {
<span class="p_header">diff --git a/drivers/gpio/gpio-tegra.c b/drivers/gpio/gpio-tegra.c</span>
<span class="p_header">index 61044c889f7f..9c84ad5ebd60 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-tegra.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-tegra.c</span>
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> static void tegra_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
 	struct tegra_gpio_bank *bank;
 	int port;
 	int pin;
<span class="p_del">-	int unmasked = 0;</span>
<span class="p_add">+	bool unmasked = false;</span>
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 
 	chained_irq_enter(chip, desc);
<span class="p_chunk">@@ -250,8 +250,8 @@</span> <span class="p_context"> static void tegra_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
 			 * before executing the hander so that we don&#39;t
 			 * miss edges
 			 */
<span class="p_del">-			if (lvl &amp; (0x100 &lt;&lt; pin)) {</span>
<span class="p_del">-				unmasked = 1;</span>
<span class="p_add">+			if (!unmasked &amp;&amp; lvl &amp; (0x100 &lt;&lt; pin)) {</span>
<span class="p_add">+				unmasked = true;</span>
 				chained_irq_exit(chip, desc);
 			}
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index e216c21110e4..ba62adaebda2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -971,13 +971,6 @@</span> <span class="p_context"> MODULE_AUTHOR(DRIVER_AUTHOR);</span>
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE(&quot;GPL and additional rights&quot;);
 
<span class="p_del">-/* We give fast paths for the really cool registers */</span>
<span class="p_del">-#define NEEDS_FORCE_WAKE(dev_priv, reg) \</span>
<span class="p_del">-	((HAS_FORCE_WAKE((dev_priv)-&gt;dev)) &amp;&amp; \</span>
<span class="p_del">-	 ((reg) &lt; 0x40000) &amp;&amp;		 \</span>
<span class="p_del">-	 ((reg) != FORCEWAKE) &amp;&amp;	 \</span>
<span class="p_del">-	 ((reg) != ECOBUS))</span>
<span class="p_del">-</span>
 #define __i915_read(x, y) \
 u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg) { \
 	u##x val = 0; \
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 61274bf52e5a..783153a6b98a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -1369,10 +1369,9 @@</span> <span class="p_context"> void __gen6_gt_wait_for_fifo(struct drm_i915_private *dev_priv);</span>
 
 /* We give fast paths for the really cool registers */
 #define NEEDS_FORCE_WAKE(dev_priv, reg) \
<span class="p_del">-	(((dev_priv)-&gt;info-&gt;gen &gt;= 6) &amp;&amp; \</span>
<span class="p_add">+	((HAS_FORCE_WAKE((dev_priv)-&gt;dev)) &amp;&amp; \</span>
 	 ((reg) &lt; 0x40000) &amp;&amp;		 \
<span class="p_del">-	 ((reg) != FORCEWAKE) &amp;&amp;	 \</span>
<span class="p_del">-	 ((reg) != ECOBUS))</span>
<span class="p_add">+	 ((reg) != FORCEWAKE))</span>
 
 #define __i915_read(x, y) \
 	u##x i915_read##x(struct drm_i915_private *dev_priv, u32 reg);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index c7b54280e2b7..4a7d597ca80c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -8699,9 +8699,15 @@</span> <span class="p_context"> static void intel_init_display(struct drm_device *dev)</span>
 		if (IS_IVYBRIDGE(dev)) {
 			u32	ecobus;
 
<span class="p_add">+			/* A small trick here - if the bios hasn&#39;t configured MT forcewake,</span>
<span class="p_add">+			 * and if the device is in RC6, then force_wake_mt_get will not wake</span>
<span class="p_add">+			 * the device and the ECOBUS read will return zero. Which will be</span>
<span class="p_add">+			 * (correctly) interpreted by the test below as MT forcewake being</span>
<span class="p_add">+			 * disabled.</span>
<span class="p_add">+			 */</span>
 			mutex_lock(&amp;dev-&gt;struct_mutex);
 			__gen6_gt_force_wake_mt_get(dev_priv);
<span class="p_del">-			ecobus = I915_READ(ECOBUS);</span>
<span class="p_add">+			ecobus = I915_READ_NOTRACE(ECOBUS);</span>
 			__gen6_gt_force_wake_mt_put(dev_priv);
 			mutex_unlock(&amp;dev-&gt;struct_mutex);
 
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index 831e20dd77a5..e873c0b9e126 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -912,6 +912,8 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
<span class="p_add">+	int num_descriptors;</span>
<span class="p_add">+	size_t offset = offsetof(struct hid_descriptor, desc);</span>
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev-&gt;descriptor.idVendor),
 			le16_to_cpu(dev-&gt;descriptor.idProduct));
<span class="p_chunk">@@ -934,10 +936,18 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	if (hdesc-&gt;bLength &lt; sizeof(struct hid_descriptor)) {</span>
<span class="p_add">+		dbg_hid(&quot;hid descriptor is too short\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hid-&gt;version = le16_to_cpu(hdesc-&gt;bcdHID);
 	hid-&gt;country = hdesc-&gt;bCountryCode;
 
<span class="p_del">-	for (n = 0; n &lt; hdesc-&gt;bNumDescriptors; n++)</span>
<span class="p_add">+	num_descriptors = min_t(int, hdesc-&gt;bNumDescriptors,</span>
<span class="p_add">+	       (hdesc-&gt;bLength - offset) / sizeof(struct hid_class_descriptor));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; n &lt; num_descriptors; n++)</span>
 		if (hdesc-&gt;desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc-&gt;desc[n].wDescriptorLength);
 
<span class="p_header">diff --git a/drivers/hwmon/w83781d.c b/drivers/hwmon/w83781d.c</span>
<span class="p_header">index 65b685e2c7b7..56a69c1a2bb8 100644</span>
<span class="p_header">--- a/drivers/hwmon/w83781d.c</span>
<span class="p_header">+++ b/drivers/hwmon/w83781d.c</span>
<span class="p_chunk">@@ -826,6 +826,7 @@</span> <span class="p_context"> w83781d_detect_subclients(struct i2c_client *new_client)</span>
 	struct i2c_adapter *adapter = new_client-&gt;adapter;
 	struct w83781d_data *data = i2c_get_clientdata(new_client);
 	enum chips kind = data-&gt;type;
<span class="p_add">+	int num_sc = 1;</span>
 
 	id = i2c_adapter_id(adapter);
 
<span class="p_chunk">@@ -850,6 +851,7 @@</span> <span class="p_context"> w83781d_detect_subclients(struct i2c_client *new_client)</span>
 	}
 
 	if (kind != w83783s) {
<span class="p_add">+		num_sc = 2;</span>
 		if (force_subclients[0] == id &amp;&amp;
 		    force_subclients[1] == address) {
 			sc_addr[1] = force_subclients[3];
<span class="p_chunk">@@ -865,7 +867,7 @@</span> <span class="p_context"> w83781d_detect_subclients(struct i2c_client *new_client)</span>
 		}
 	}
 
<span class="p_del">-	for (i = 0; i &lt;= 1; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; num_sc; i++) {</span>
 		data-&gt;lm75[i] = i2c_new_dummy(adapter, sc_addr[i]);
 		if (!data-&gt;lm75[i]) {
 			dev_err(&amp;new_client-&gt;dev, &quot;Subclient %d &quot;
<span class="p_chunk">@@ -876,8 +878,6 @@</span> <span class="p_context"> w83781d_detect_subclients(struct i2c_client *new_client)</span>
 				goto ERROR_SC_3;
 			goto ERROR_SC_2;
 		}
<span class="p_del">-		if (kind == w83783s)</span>
<span class="p_del">-			break;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/idle/intel_idle.c b/drivers/idle/intel_idle.c</span>
<span class="p_header">index 44fde43c9bc6..2a81c8878a53 100644</span>
<span class="p_header">--- a/drivers/idle/intel_idle.c</span>
<span class="p_header">+++ b/drivers/idle/intel_idle.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static struct cpuidle_state atom_cstates[MWAIT_MAX_NUM_CSTATES] = {</span>
 		.enter = &amp;intel_idle },
 };
 
<span class="p_del">-static int get_driver_data(int cstate)</span>
<span class="p_add">+static long get_driver_data(int cstate)</span>
 {
 	int driver_data;
 	switch (cstate) {
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index 09cc0fc7d423..87c1e055ac7e 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -661,6 +661,8 @@</span> <span class="p_context"> int rdma_init_qp_attr(struct rdma_cm_id *id, struct ib_qp_attr *qp_attr,</span>
 		} else
 			ret = iw_cm_init_qp_attr(id_priv-&gt;cm_id.iw, qp_attr,
 						 qp_attr_mask);
<span class="p_add">+		qp_attr-&gt;port_num = id_priv-&gt;id.port_num;</span>
<span class="p_add">+		*qp_attr_mask |= IB_QP_PORT;</span>
 		break;
 	default:
 		ret = -ENOSYS;
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index a5a7f4707d19..29c01fc0c4cc 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -1192,7 +1192,7 @@</span> <span class="p_context"> ssize_t ib_uverbs_resize_cq(struct ib_uverbs_file *file,</span>
 			    int out_len)
 {
 	struct ib_uverbs_resize_cq	cmd;
<span class="p_del">-	struct ib_uverbs_resize_cq_resp	resp;</span>
<span class="p_add">+	struct ib_uverbs_resize_cq_resp	resp = {};</span>
 	struct ib_udata                 udata;
 	struct ib_cq			*cq;
 	int				ret = -EINVAL;
<span class="p_chunk">@@ -1790,7 +1790,8 @@</span> <span class="p_context"> ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (!rdma_is_port_valid(qp-&gt;device, cmd.port_num)) {</span>
<span class="p_add">+	if ((cmd.attr_mask &amp; IB_QP_PORT) &amp;&amp;</span>
<span class="p_add">+	    !rdma_is_port_valid(qp-&gt;device, cmd.port_num)) {</span>
 		ret = -EINVAL;
 		goto release_qp;
 	}
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 16616504defb..a17f0fab8e6f 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -290,6 +290,7 @@</span> <span class="p_context"> static void ib_uverbs_release_file(struct kref *ref)</span>
 	if (atomic_dec_and_test(&amp;file-&gt;device-&gt;refcount))
 		ib_uverbs_comp_dev(file-&gt;device);
 
<span class="p_add">+	kobject_put(&amp;file-&gt;device-&gt;kobj);</span>
 	kfree(file);
 }
 
<span class="p_chunk">@@ -671,7 +672,6 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 static int ib_uverbs_close(struct inode *inode, struct file *filp)
 {
 	struct ib_uverbs_file *file = filp-&gt;private_data;
<span class="p_del">-	struct ib_uverbs_device *dev = file-&gt;device;</span>
 
 	ib_uverbs_cleanup_ucontext(file, file-&gt;ucontext);
 
<span class="p_chunk">@@ -679,7 +679,6 @@</span> <span class="p_context"> static int ib_uverbs_close(struct inode *inode, struct file *filp)</span>
 		kref_put(&amp;file-&gt;async_file-&gt;ref, ib_uverbs_release_event_file);
 
 	kref_put(&amp;file-&gt;ref, ib_uverbs_release_file);
<span class="p_del">-	kobject_put(&amp;dev-&gt;kobj);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/iwch_provider.c b/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_header">index 37c224fc3ad9..35fa4e74b824 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_chunk">@@ -795,7 +795,7 @@</span> <span class="p_context"> static struct ib_mr *iwch_alloc_fast_reg_mr(struct ib_pd *pd, int pbl_depth)</span>
 	struct iwch_mr *mhp;
 	u32 mmid;
 	u32 stag = 0;
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = -ENOMEM;</span>
 
 	php = to_iwch_pd(pd);
 	rhp = php-&gt;rhp;
<span class="p_chunk">@@ -818,7 +818,8 @@</span> <span class="p_context"> static struct ib_mr *iwch_alloc_fast_reg_mr(struct ib_pd *pd, int pbl_depth)</span>
 	mhp-&gt;attr.state = 1;
 	mmid = (stag) &gt;&gt; 8;
 	mhp-&gt;ibmr.rkey = mhp-&gt;ibmr.lkey = stag;
<span class="p_del">-	if (insert_handle(rhp, &amp;rhp-&gt;mmidr, mhp, mmid))</span>
<span class="p_add">+	ret = insert_handle(rhp, &amp;rhp-&gt;mmidr, mhp, mmid);</span>
<span class="p_add">+	if (ret)</span>
 		goto err3;
 
 	PDBG(&quot;%s mmid 0x%x mhp %p stag 0x%x\n&quot;, __func__, mmid, mhp, stag);
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">index 3bd6b698c236..3e5f5763c666 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_chunk">@@ -826,6 +826,7 @@</span> <span class="p_context"> struct ib_cq *c4iw_create_cq(struct ib_device *ibdev, int entries,</span>
 		goto err2;
 
 	if (ucontext) {
<span class="p_add">+		ret = -ENOMEM;</span>
 		mm = kmalloc(sizeof *mm, GFP_KERNEL);
 		if (!mm)
 			goto err3;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 1165949d5c43..df1a2def6379 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1363,7 +1363,7 @@</span> <span class="p_context"> static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_send_wr *wr,</span>
 	int is_eth;
 	int is_vlan = 0;
 	int is_grh;
<span class="p_del">-	u16 vlan;</span>
<span class="p_add">+	u16 vlan = 0xffff;</span>
 
 	send_size = 0;
 	for (i = 0; i &lt; wr-&gt;num_sge; ++i)
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 74aa1310449e..80c9a299dba4 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -506,7 +506,6 @@</span> <span class="p_context"> static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,</span>
 	case IB_CM_REQ_RECEIVED:
 		return ipoib_cm_req_handler(cm_id, event);
 	case IB_CM_DREQ_RECEIVED:
<span class="p_del">-		p = cm_id-&gt;context;</span>
 		ib_send_cm_drep(cm_id, NULL, 0);
 		/* Fall through */
 	case IB_CM_REJ_RECEIVED:
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index ae3b1d21e9eb..c3d96e8c200b 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -1366,6 +1366,7 @@</span> <span class="p_context"> static int __init ipoib_init_module(void)</span>
 	ipoib_sendq_size = max3(ipoib_sendq_size, 2 * MAX_SEND_CQE, IPOIB_MIN_QUEUE_SIZE);
 #ifdef CONFIG_INFINIBAND_IPOIB_CM
 	ipoib_max_conn_qp = min(ipoib_max_conn_qp, IPOIB_CM_MAX_CONN_QP);
<span class="p_add">+	ipoib_max_conn_qp = max(ipoib_max_conn_qp, 0);</span>
 #endif
 
 	/*
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.c b/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">index 54b2fa892e19..7836450b3465 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.c</span>
<span class="p_chunk">@@ -186,7 +186,8 @@</span> <span class="p_context"> static int trackpoint_start_protocol(struct psmouse *psmouse, unsigned char *fir</span>
 	if (ps2_command(&amp;psmouse-&gt;ps2dev, param, MAKE_PS2_CMD(0, 2, TP_READ_ID)))
 		return -1;
 
<span class="p_del">-	if (param[0] != TP_MAGIC_IDENT)</span>
<span class="p_add">+	/* add new TP ID. */</span>
<span class="p_add">+	if (!(param[0] &amp; TP_MAGIC_IDENT))</span>
 		return -1;
 
 	if (firmware_id)
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.h b/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">index e558a7096618..bdee1319c3d1 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.h</span>
<span class="p_chunk">@@ -21,8 +21,9 @@</span> <span class="p_context"></span>
 #define TP_COMMAND		0xE2	/* Commands start with this */
 
 #define TP_READ_ID		0xE1	/* Sent for device identification */
<span class="p_del">-#define TP_MAGIC_IDENT		0x01	/* Sent after a TP_READ_ID followed */</span>
<span class="p_add">+#define TP_MAGIC_IDENT		0x03	/* Sent after a TP_READ_ID followed */</span>
 					/* by the firmware ID */
<span class="p_add">+					/* Firmware ID includes 0x1, 0x2, 0x3 */</span>
 
 
 /*
<span class="p_header">diff --git a/drivers/isdn/gigaset/capi.c b/drivers/isdn/gigaset/capi.c</span>
<span class="p_header">index 08c2329ffac8..ba45c77efc94 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/capi.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/capi.c</span>
<span class="p_chunk">@@ -306,6 +306,7 @@</span> <span class="p_context"> static inline void dump_rawmsg(enum debuglevel level, const char *tag,</span>
  * format CAPI IE as string
  */
 
<span class="p_add">+#ifdef CONFIG_GIGASET_DEBUG</span>
 static const char *format_ie(const char *ie)
 {
 	static char result[3*MAX_FMT_IE_LEN];
<span class="p_chunk">@@ -331,6 +332,7 @@</span> <span class="p_context"> static const char *format_ie(const char *ie)</span>
 	*--pout = 0;
 	return result;
 }
<span class="p_add">+#endif</span>
 
 /*
  * emit DATA_B3_CONF message
<span class="p_header">diff --git a/drivers/isdn/hardware/eicon/capi20.h b/drivers/isdn/hardware/eicon/capi20.h</span>
<span class="p_header">index 7ebcccda74d8..27ecd61888de 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/eicon/capi20.h</span>
<span class="p_header">+++ b/drivers/isdn/hardware/eicon/capi20.h</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> typedef struct api_profile_s {</span>
 /*------------------------------------------------------------------*/
         /* ALERT-REQUEST                                            */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* Additional Info */</span>
<span class="p_add">+  byte structs[0];      /* Additional Info */</span>
 } _ALT_REQP;
         /* ALERT-CONFIRM                                            */
 typedef struct {
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> typedef struct {</span>
         /* CONNECT-REQUEST                                          */
 typedef struct {
   word CIP_Value;
<span class="p_del">-  byte structs[1];      /* Called party number,</span>
<span class="p_add">+  byte structs[0];      /* Called party number,</span>
                            Called party subaddress,
                            Calling party number,
                            Calling party subaddress,
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> typedef struct {</span>
         /* CONNECT-INDICATION                                       */
 typedef struct {
   word CIP_Value;
<span class="p_del">-  byte structs[1];      /* Called party number,</span>
<span class="p_add">+  byte structs[0];      /* Called party number,</span>
                            Called party subaddress,
                            Calling party number,
                            Calling party subaddress,
<span class="p_chunk">@@ -155,24 +155,24 @@</span> <span class="p_context"> typedef struct {</span>
         /* CONNECT-RESPONSE                                         */
 typedef struct {
   word Accept;
<span class="p_del">-  byte structs[1];      /* B_protocol,</span>
<span class="p_add">+  byte structs[0];      /* B_protocol,</span>
                            Connected party number,
                            Connected party subaddress,
                            LLC */
 } _CON_RESP;
         /* CONNECT-ACTIVE-INDICATION                                */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* Connected party number,</span>
<span class="p_add">+  byte structs[0];      /* Connected party number,</span>
                            Connected party subaddress,
                            LLC */
 } _CON_A_INDP;
         /* CONNECT-ACTIVE-RESPONSE                                  */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _CON_A_RESP;
         /* DISCONNECT-REQUEST                                       */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* Additional Info */</span>
<span class="p_add">+  byte structs[0];      /* Additional Info */</span>
 } _DIS_REQP;
         /* DISCONNECT-CONFIRM                                       */
 typedef struct {
<span class="p_chunk">@@ -184,13 +184,13 @@</span> <span class="p_context"> typedef struct {</span>
 } _DIS_INDP;
         /* DISCONNECT-RESPONSE                                      */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _DIS_RESP;
         /* LISTEN-REQUEST                                           */
 typedef struct {
   dword Info_Mask;
   dword CIP_Mask;
<span class="p_del">-  byte structs[1];      /* Calling party number,</span>
<span class="p_add">+  byte structs[0];      /* Calling party number,</span>
                            Calling party subaddress */
 } _LIS_REQP;
         /* LISTEN-CONFIRM                                           */
<span class="p_chunk">@@ -199,7 +199,7 @@</span> <span class="p_context"> typedef struct {</span>
 } _LIS_CONP;
         /* INFO-REQUEST                                             */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* Called party number,</span>
<span class="p_add">+  byte structs[0];      /* Called party number,</span>
                            Additional Info */
 } _INF_REQP;
         /* INFO-CONFIRM                                             */
<span class="p_chunk">@@ -209,15 +209,15 @@</span> <span class="p_context"> typedef struct {</span>
         /* INFO-INDICATION                                          */
 typedef struct {
   word Number;
<span class="p_del">-  byte structs[1];      /* Info element */</span>
<span class="p_add">+  byte structs[0];      /* Info element */</span>
 } _INF_INDP;
         /* INFO-RESPONSE                                            */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _INF_RESP;
         /* SELECT-B-REQUEST                                         */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* B-protocol */</span>
<span class="p_add">+  byte structs[0];      /* B-protocol */</span>
 } _SEL_B_REQP;
         /* SELECT-B-CONFIRM                                         */
 typedef struct {
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> typedef struct {</span>
         /* FACILITY-REQUEST */
 typedef struct {
   word Selector;
<span class="p_del">-  byte structs[1];      /* Facility parameters */</span>
<span class="p_add">+  byte structs[0];      /* Facility parameters */</span>
 } _FAC_REQP;
         /* FACILITY-CONFIRM STRUCT FOR SUPPLEMENT. SERVICES */
 typedef struct {
<span class="p_chunk">@@ -240,21 +240,21 @@</span> <span class="p_context"> typedef struct {</span>
 typedef struct {
   word Info;
   word Selector;
<span class="p_del">-  byte structs[1];      /* Facility parameters */</span>
<span class="p_add">+  byte structs[0];      /* Facility parameters */</span>
 } _FAC_CONP;
         /* FACILITY-INDICATION */
 typedef struct {
   word Selector;
<span class="p_del">-  byte structs[1];      /* Facility parameters */</span>
<span class="p_add">+  byte structs[0];      /* Facility parameters */</span>
 } _FAC_INDP;
         /* FACILITY-RESPONSE */
 typedef struct {
   word Selector;
<span class="p_del">-  byte structs[1];      /* Facility parameters */</span>
<span class="p_add">+  byte structs[0];      /* Facility parameters */</span>
 } _FAC_RESP;
         /* CONNECT-B3-REQUEST                                       */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_REQP;
         /* CONNECT-B3-CONFIRM                                       */
 typedef struct {
<span class="p_chunk">@@ -262,24 +262,24 @@</span> <span class="p_context"> typedef struct {</span>
 } _CON_B3_CONP;
         /* CONNECT-B3-INDICATION                                    */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_INDP;
         /* CONNECT-B3-RESPONSE                                      */
 typedef struct {
   word Accept;
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_RESP;
         /* CONNECT-B3-ACTIVE-INDICATION                             */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_A_INDP;
         /* CONNECT-B3-ACTIVE-RESPONSE                               */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _CON_B3_A_RESP;
         /* DISCONNECT-B3-REQUEST                                    */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _DIS_B3_REQP;
         /* DISCONNECT-B3-CONFIRM                                    */
 typedef struct {
<span class="p_chunk">@@ -288,11 +288,11 @@</span> <span class="p_context"> typedef struct {</span>
         /* DISCONNECT-B3-INDICATION                                 */
 typedef struct {
   word Info;
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _DIS_B3_INDP;
         /* DISCONNECT-B3-RESPONSE                                   */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _DIS_B3_RESP;
         /* DATA-B3-REQUEST                                          */
 typedef struct {
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> typedef struct {</span>
 } _DAT_B3_RESP;
         /* RESET-B3-REQUEST                                         */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _RES_B3_REQP;
         /* RESET-B3-CONFIRM                                         */
 typedef struct {
<span class="p_chunk">@@ -343,20 +343,20 @@</span> <span class="p_context"> typedef struct {</span>
 } _RES_B3_CONP;
         /* RESET-B3-INDICATION                                      */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _RES_B3_INDP;
         /* RESET-B3-RESPONSE                                        */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* empty */</span>
<span class="p_add">+  byte structs[0];      /* empty */</span>
 } _RES_B3_RESP;
         /* CONNECT-B3-T90-ACTIVE-INDICATION                         */
 typedef struct {
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_T90_A_INDP;
         /* CONNECT-B3-T90-ACTIVE-RESPONSE                           */
 typedef struct {
   word Reject;
<span class="p_del">-  byte structs[1];      /* NCPI */</span>
<span class="p_add">+  byte structs[0];      /* NCPI */</span>
 } _CON_B3_T90_A_RESP;
 /*------------------------------------------------------------------*/
 /* message structure                                                */
<span class="p_header">diff --git a/drivers/isdn/hardware/mISDN/hfcpci.c b/drivers/isdn/hardware/mISDN/hfcpci.c</span>
<span class="p_header">index 3261de18a91e..d5db9ace8906 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/mISDN/hfcpci.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/mISDN/hfcpci.c</span>
<span class="p_chunk">@@ -2316,8 +2316,8 @@</span> <span class="p_context"> _hfcpci_softirq(struct device *dev, void *arg)</span>
 static void
 hfcpci_softirq(void *arg)
 {
<span class="p_del">-	(void) driver_for_each_device(&amp;hfc_driver.driver, NULL, arg,</span>
<span class="p_del">-					_hfcpci_softirq);</span>
<span class="p_add">+	WARN_ON_ONCE(driver_for_each_device(&amp;hfc_driver.driver, NULL, arg,</span>
<span class="p_add">+				      _hfcpci_softirq) != 0);</span>
 
 	/* if next event would be in the past ... */
 	if ((s32)(hfc_jiffies + tics - jiffies) &lt;= 0)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index c00bcdcd36de..ca688a28e219 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -25,16 +25,6 @@</span> <span class="p_context"></span>
 
 #define DM_MSG_PREFIX &quot;core&quot;
 
<span class="p_del">-#ifdef CONFIG_PRINTK</span>
<span class="p_del">-/*</span>
<span class="p_del">- * ratelimit state to be used in DMXXX_LIMIT().</span>
<span class="p_del">- */</span>
<span class="p_del">-DEFINE_RATELIMIT_STATE(dm_ratelimit_state,</span>
<span class="p_del">-		       DEFAULT_RATELIMIT_INTERVAL,</span>
<span class="p_del">-		       DEFAULT_RATELIMIT_BURST);</span>
<span class="p_del">-EXPORT_SYMBOL(dm_ratelimit_state);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * Cookies are numeric values sent with CHANGE and REMOVE
  * uevents while resuming, removing or renaming the device.
<span class="p_header">diff --git a/drivers/media/common/tuners/tda18212.c b/drivers/media/common/tuners/tda18212.c</span>
<span class="p_header">index e29cc2bc113a..27c1861d2420 100644</span>
<span class="p_header">--- a/drivers/media/common/tuners/tda18212.c</span>
<span class="p_header">+++ b/drivers/media/common/tuners/tda18212.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> struct dvb_frontend *tda18212_attach(struct dvb_frontend *fe,</span>
 {
 	struct tda18212_priv *priv = NULL;
 	int ret;
<span class="p_del">-	u8 val;</span>
<span class="p_add">+	u8 uninitialized_var(val);</span>
 
 	priv = kzalloc(sizeof(struct tda18212_priv), GFP_KERNEL);
 	if (priv == NULL)
<span class="p_header">diff --git a/drivers/media/common/tuners/tda18218.c b/drivers/media/common/tuners/tda18218.c</span>
<span class="p_header">index 4fc29730a12c..361a31f1f124 100644</span>
<span class="p_header">--- a/drivers/media/common/tuners/tda18218.c</span>
<span class="p_header">+++ b/drivers/media/common/tuners/tda18218.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> struct dvb_frontend *tda18218_attach(struct dvb_frontend *fe,</span>
 	struct i2c_adapter *i2c, struct tda18218_config *cfg)
 {
 	struct tda18218_priv *priv = NULL;
<span class="p_del">-	u8 val;</span>
<span class="p_add">+	u8 uninitialized_var(val);</span>
 	int ret;
 	/* chip default registers values */
 	static u8 def_regs[] = {
<span class="p_header">diff --git a/drivers/media/common/tuners/xc4000.c b/drivers/media/common/tuners/xc4000.c</span>
<span class="p_header">index 634f4d9b6c63..3b9fdba8880f 100644</span>
<span class="p_header">--- a/drivers/media/common/tuners/xc4000.c</span>
<span class="p_header">+++ b/drivers/media/common/tuners/xc4000.c</span>
<span class="p_chunk">@@ -923,7 +923,7 @@</span> <span class="p_context"> static int check_firmware(struct dvb_frontend *fe, unsigned int type,</span>
 	int			   rc = 0, is_retry = 0;
 	u16			   hwmodel;
 	v4l2_std_id		   std0;
<span class="p_del">-	u8			   hw_major, hw_minor, fw_major, fw_minor;</span>
<span class="p_add">+	u8			   hw_major = 0, hw_minor = 0, fw_major = 0, fw_minor = 0;</span>
 
 	dprintk(1, &quot;%s called\n&quot;, __func__);
 
<span class="p_header">diff --git a/drivers/media/dvb/dvb-usb/mxl111sf.c b/drivers/media/dvb/dvb-usb/mxl111sf.c</span>
<span class="p_header">index bc6ea9fadb18..738f7b026aff 100644</span>
<span class="p_header">--- a/drivers/media/dvb/dvb-usb/mxl111sf.c</span>
<span class="p_header">+++ b/drivers/media/dvb/dvb-usb/mxl111sf.c</span>
<span class="p_chunk">@@ -340,7 +340,6 @@</span> <span class="p_context"> static int mxl111sf_ep6_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)</span>
 	struct mxl111sf_state *state = d-&gt;priv;
 	struct mxl111sf_adap_state *adap_state = adap-&gt;fe_adap[adap-&gt;active_fe].priv;
 	int ret = 0;
<span class="p_del">-	u8 tmp;</span>
 
 	deb_info(&quot;%s(%d)\n&quot;, __func__, onoff);
 
<span class="p_header">diff --git a/drivers/media/rc/redrat3.c b/drivers/media/rc/redrat3.c</span>
<span class="p_header">index 61287fcca61a..9bff23cb0a5b 100644</span>
<span class="p_header">--- a/drivers/media/rc/redrat3.c</span>
<span class="p_header">+++ b/drivers/media/rc/redrat3.c</span>
<span class="p_chunk">@@ -286,12 +286,6 @@</span> <span class="p_context"> static void redrat3_issue_async(struct redrat3_dev *rr3)</span>
 
 	rr3_ftr(rr3-&gt;dev, &quot;Entering %s\n&quot;, __func__);
 
<span class="p_del">-	if (!rr3-&gt;det_enabled) {</span>
<span class="p_del">-		dev_warn(rr3-&gt;dev, &quot;not issuing async read, &quot;</span>
<span class="p_del">-			 &quot;detector not enabled\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	memset(rr3-&gt;bulk_in_buf, 0, rr3-&gt;ep_in-&gt;wMaxPacketSize);
 	res = usb_submit_urb(rr3-&gt;read_urb, GFP_ATOMIC);
 	if (res)
<span class="p_chunk">@@ -827,6 +821,7 @@</span> <span class="p_context"> static int redrat3_get_ir_data(struct redrat3_dev *rr3, int len)</span>
 static void redrat3_handle_async(struct urb *urb, struct pt_regs *regs)
 {
 	struct redrat3_dev *rr3;
<span class="p_add">+	int ret;</span>
 
 	if (!urb)
 		return;
<span class="p_chunk">@@ -840,15 +835,13 @@</span> <span class="p_context"> static void redrat3_handle_async(struct urb *urb, struct pt_regs *regs)</span>
 
 	rr3_ftr(rr3-&gt;dev, &quot;Entering %s\n&quot;, __func__);
 
<span class="p_del">-	if (!rr3-&gt;det_enabled) {</span>
<span class="p_del">-		rr3_dbg(rr3-&gt;dev, &quot;received a read callback but detector &quot;</span>
<span class="p_del">-			&quot;disabled - ignoring\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	switch (urb-&gt;status) {
 	case 0:
<span class="p_del">-		redrat3_get_ir_data(rr3, urb-&gt;actual_length);</span>
<span class="p_add">+		ret = redrat3_get_ir_data(rr3, urb-&gt;actual_length);</span>
<span class="p_add">+		if (!ret) {</span>
<span class="p_add">+			/* no error, prepare to read more */</span>
<span class="p_add">+			redrat3_issue_async(rr3);</span>
<span class="p_add">+		}</span>
 		break;
 
 	case -ECONNRESET:
<span class="p_chunk">@@ -865,11 +858,6 @@</span> <span class="p_context"> static void redrat3_handle_async(struct urb *urb, struct pt_regs *regs)</span>
 		rr3-&gt;pkttype = 0;
 		break;
 	}
<span class="p_del">-</span>
<span class="p_del">-	if (!rr3-&gt;transmitting)</span>
<span class="p_del">-		redrat3_issue_async(rr3);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		rr3_dbg(rr3-&gt;dev, &quot;IR transmit in progress\n&quot;);</span>
 }
 
 static void redrat3_write_bulk_callback(struct urb *urb, struct pt_regs *regs)
<span class="p_chunk">@@ -896,21 +884,24 @@</span> <span class="p_context"> static u16 mod_freq_to_val(unsigned int mod_freq)</span>
 	return (u16)(65536 - (mult / mod_freq));
 }
 
<span class="p_del">-static int redrat3_set_tx_carrier(struct rc_dev *dev, u32 carrier)</span>
<span class="p_add">+static int redrat3_set_tx_carrier(struct rc_dev *rcdev, u32 carrier)</span>
 {
<span class="p_del">-	struct redrat3_dev *rr3 = dev-&gt;priv;</span>
<span class="p_add">+	struct redrat3_dev *rr3 = rcdev-&gt;priv;</span>
<span class="p_add">+	struct device *dev = rr3-&gt;dev;</span>
 
<span class="p_add">+	rr3_dbg(dev, &quot;Setting modulation frequency to %u&quot;, carrier);</span>
 	rr3-&gt;carrier = carrier;
 
 	return carrier;
 }
 
<span class="p_del">-static int redrat3_transmit_ir(struct rc_dev *rcdev, int *txbuf, u32 n)</span>
<span class="p_add">+static int redrat3_transmit_ir(struct rc_dev *rcdev, unsigned *txbuf,</span>
<span class="p_add">+				unsigned count)</span>
 {
 	struct redrat3_dev *rr3 = rcdev-&gt;priv;
 	struct device *dev = rr3-&gt;dev;
 	struct redrat3_signal_header header;
<span class="p_del">-	int i, j, count, ret, ret_len, offset;</span>
<span class="p_add">+	int i, j, ret, ret_len, offset;</span>
 	int lencheck, cur_sample_len, pipe;
 	char *buffer = NULL, *sigdata = NULL;
 	int *sample_lens = NULL;
<span class="p_chunk">@@ -928,20 +919,13 @@</span> <span class="p_context"> static int redrat3_transmit_ir(struct rc_dev *rcdev, int *txbuf, u32 n)</span>
 		return -EAGAIN;
 	}
 
<span class="p_del">-	count = n / sizeof(int);</span>
 	if (count &gt; (RR3_DRIVER_MAXLENS * 2))
 		return -EINVAL;
 
<span class="p_add">+	/* rr3 will disable rc detector on transmit */</span>
<span class="p_add">+	rr3-&gt;det_enabled = false;</span>
 	rr3-&gt;transmitting = true;
 
<span class="p_del">-	redrat3_disable_detector(rr3);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (rr3-&gt;det_enabled) {</span>
<span class="p_del">-		dev_err(dev, &quot;%s: cannot tx while rx is enabled\n&quot;, __func__);</span>
<span class="p_del">-		ret = -EIO;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sample_lens = kzalloc(sizeof(int) * RR3_DRIVER_MAXLENS, GFP_KERNEL);
 	if (!sample_lens) {
 		ret = -ENOMEM;
<span class="p_chunk">@@ -1055,7 +1039,7 @@</span> <span class="p_context"> static int redrat3_transmit_ir(struct rc_dev *rcdev, int *txbuf, u32 n)</span>
 	if (ret &lt; 0)
 		dev_err(dev, &quot;Error: control msg send failed, rc %d\n&quot;, ret);
 	else
<span class="p_del">-		ret = n;</span>
<span class="p_add">+		ret = count;</span>
 
 out:
 	kfree(sample_lens);
<span class="p_chunk">@@ -1063,8 +1047,8 @@</span> <span class="p_context"> static int redrat3_transmit_ir(struct rc_dev *rcdev, int *txbuf, u32 n)</span>
 	kfree(sigdata);
 
 	rr3-&gt;transmitting = false;
<span class="p_del">-</span>
<span class="p_del">-	redrat3_enable_detector(rr3);</span>
<span class="p_add">+	/* rr3 re-enables rc detector because it was enabled before */</span>
<span class="p_add">+	rr3-&gt;det_enabled = true;</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/misc/vmw_balloon.c b/drivers/misc/vmw_balloon.c</span>
<span class="p_header">index cd41d403c9df..cb56e270da11 100644</span>
<span class="p_header">--- a/drivers/misc/vmw_balloon.c</span>
<span class="p_header">+++ b/drivers/misc/vmw_balloon.c</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> static bool vmballoon_send_get_target(struct vmballoon *b, u32 *new_target)</span>
  * fear that guest will need it. Host may reject some pages, we need to
  * check the return value and maybe submit a different page.
  */
<span class="p_del">-static bool vmballoon_send_lock_page(struct vmballoon *b, unsigned long pfn,</span>
<span class="p_add">+static int vmballoon_send_lock_page(struct vmballoon *b, unsigned long pfn,</span>
 				     unsigned int *hv_status)
 {
 	unsigned long status, dummy;
<span class="p_chunk">@@ -322,17 +322,17 @@</span> <span class="p_context"> static bool vmballoon_send_lock_page(struct vmballoon *b, unsigned long pfn,</span>
 
 	pfn32 = (u32)pfn;
 	if (pfn32 != pfn)
<span class="p_del">-		return false;</span>
<span class="p_add">+		return -1;</span>
 
 	STATS_INC(b-&gt;stats.lock);
 
 	*hv_status = status = VMWARE_BALLOON_CMD(LOCK, pfn, dummy);
 	if (vmballoon_check_status(b, status))
<span class="p_del">-		return true;</span>
<span class="p_add">+		return 0;</span>
 
 	pr_debug(&quot;%s - ppn %lx, hv returns %ld\n&quot;, __func__, pfn, status);
 	STATS_INC(b-&gt;stats.lock_fail);
<span class="p_del">-	return false;</span>
<span class="p_add">+	return 1;</span>
 }
 
 /*
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> static int vmballoon_reserve_page(struct vmballoon *b, bool can_sleep)</span>
 	struct page *page;
 	gfp_t flags;
 	unsigned int hv_status;
<span class="p_del">-	bool locked = false;</span>
<span class="p_add">+	int locked;</span>
 	flags = can_sleep ? VMW_PAGE_ALLOC_CANSLEEP : VMW_PAGE_ALLOC_NOSLEEP;
 
 	do {
<span class="p_chunk">@@ -431,7 +431,7 @@</span> <span class="p_context"> static int vmballoon_reserve_page(struct vmballoon *b, bool can_sleep)</span>
 
 		/* inform monitor */
 		locked = vmballoon_send_lock_page(b, page_to_pfn(page), &amp;hv_status);
<span class="p_del">-		if (!locked) {</span>
<span class="p_add">+		if (locked &gt; 0) {</span>
 			STATS_INC(b-&gt;stats.refused_alloc);
 
 			if (hv_status == VMW_BALLOON_ERROR_RESET ||
<span class="p_chunk">@@ -449,7 +449,7 @@</span> <span class="p_context"> static int vmballoon_reserve_page(struct vmballoon *b, bool can_sleep)</span>
 			if (++b-&gt;n_refused_pages &gt;= VMW_BALLOON_MAX_REFUSED)
 				return -EIO;
 		}
<span class="p_del">-	} while (!locked);</span>
<span class="p_add">+	} while (locked != 0);</span>
 
 	/* track allocated page */
 	list_add(&amp;page-&gt;lru, &amp;b-&gt;pages);
<span class="p_header">diff --git a/drivers/mtd/devices/sst25l.c b/drivers/mtd/devices/sst25l.c</span>
<span class="p_header">index 9c35250620e1..077d88a204ae 100644</span>
<span class="p_header">--- a/drivers/mtd/devices/sst25l.c</span>
<span class="p_header">+++ b/drivers/mtd/devices/sst25l.c</span>
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> static int __devinit sst25l_probe(struct spi_device *spi)</span>
 	struct flash_info *flash_info;
 	struct sst25l_flash *flash;
 	struct flash_platform_data *data;
<span class="p_del">-	int ret, i;</span>
<span class="p_add">+	int ret;</span>
 
 	flash_info = sst25l_match_device(spi);
 	if (!flash_info)
<span class="p_header">diff --git a/drivers/net/ethernet/amd/nmclan_cs.c b/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_header">index 3accd5d21b08..3279a1ad79b4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_chunk">@@ -625,7 +625,7 @@</span> <span class="p_context"> static int nmclan_config(struct pcmcia_device *link)</span>
   ret = pcmcia_request_io(link);
   if (ret)
 	  goto failed;
<span class="p_del">-  ret = pcmcia_request_exclusive_irq(link, mace_interrupt);</span>
<span class="p_add">+  ret = pcmcia_request_irq(link, mace_interrupt);</span>
   if (ret)
 	  goto failed;
   ret = pcmcia_enable_device(link);
<span class="p_chunk">@@ -955,6 +955,8 @@</span> <span class="p_context"> static irqreturn_t mace_interrupt(int irq, void *dev_id)</span>
   do {
     /* WARNING: MACE_IR is a READ/CLEAR port! */
     status = inb(ioaddr + AM2150_MACE_BASE + MACE_IR);
<span class="p_add">+    if (!(status &amp; ~MACE_IMR_DEFAULT) &amp;&amp; IntrCnt == MACE_MAX_IR_ITERATIONS)</span>
<span class="p_add">+      return IRQ_NONE;</span>
 
     pr_debug(&quot;mace_interrupt: irq 0x%X status 0x%X.\n&quot;, irq, status);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">index 74e2a2a8a02b..26d080a87cd8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_chunk">@@ -101,27 +101,28 @@</span> <span class="p_context"> static void mlx4_en_get_wol(struct net_device *netdev,</span>
 			    struct ethtool_wolinfo *wol)
 {
 	struct mlx4_en_priv *priv = netdev_priv(netdev);
<span class="p_add">+	struct mlx4_caps *caps = &amp;priv-&gt;mdev-&gt;dev-&gt;caps;</span>
 	int err = 0;
 	u64 config = 0;
 
<span class="p_del">-	if (!(priv-&gt;mdev-&gt;dev-&gt;caps.flags &amp; MLX4_DEV_CAP_FLAG_WOL)) {</span>
<span class="p_add">+	if (!(caps-&gt;flags &amp; MLX4_DEV_CAP_FLAG_WOL)) {</span>
 		wol-&gt;supported = 0;
 		wol-&gt;wolopts = 0;
 		return;
 	}
 
<span class="p_add">+	if (caps-&gt;wol_port[priv-&gt;port])</span>
<span class="p_add">+		wol-&gt;supported = WAKE_MAGIC;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		wol-&gt;supported = 0;</span>
<span class="p_add">+</span>
 	err = mlx4_wol_read(priv-&gt;mdev-&gt;dev, &amp;config, priv-&gt;port);
 	if (err) {
 		en_err(priv, &quot;Failed to get WoL information\n&quot;);
 		return;
 	}
 
<span class="p_del">-	if (config &amp; MLX4_EN_WOL_MAGIC)</span>
<span class="p_del">-		wol-&gt;supported = WAKE_MAGIC;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		wol-&gt;supported = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (config &amp; MLX4_EN_WOL_ENABLED)</span>
<span class="p_add">+	if ((config &amp; MLX4_EN_WOL_ENABLED) &amp;&amp; (config &amp; MLX4_EN_WOL_MAGIC))</span>
 		wol-&gt;wolopts = WAKE_MAGIC;
 	else
 		wol-&gt;wolopts = 0;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/fw.c b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">index 435ca6e49734..88923480b370 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> int mlx4_QUERY_DEV_CAP(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 #define QUERY_DEV_CAP_RATE_SUPPORT_OFFSET	0x3c
 #define QUERY_DEV_CAP_MAX_PKEY_OFFSET		0x3f
 #define QUERY_DEV_CAP_EXT_FLAGS_OFFSET		0x40
<span class="p_add">+#define QUERY_DEV_CAP_WOL_OFFSET		0x43</span>
 #define QUERY_DEV_CAP_FLAGS_OFFSET		0x44
 #define QUERY_DEV_CAP_RSVD_UAR_OFFSET		0x48
 #define QUERY_DEV_CAP_UAR_SZ_OFFSET		0x49
<span class="p_chunk">@@ -285,6 +286,9 @@</span> <span class="p_context"> int mlx4_QUERY_DEV_CAP(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 	MLX4_GET(ext_flags, outbox, QUERY_DEV_CAP_EXT_FLAGS_OFFSET);
 	MLX4_GET(flags, outbox, QUERY_DEV_CAP_FLAGS_OFFSET);
 	dev_cap-&gt;flags = flags | (u64)ext_flags &lt;&lt; 32;
<span class="p_add">+	MLX4_GET(field, outbox, QUERY_DEV_CAP_WOL_OFFSET);</span>
<span class="p_add">+	dev_cap-&gt;wol_port[1] = !!(field &amp; 0x20);</span>
<span class="p_add">+	dev_cap-&gt;wol_port[2] = !!(field &amp; 0x40);</span>
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_RSVD_UAR_OFFSET);
 	dev_cap-&gt;reserved_uars = field &gt;&gt; 4;
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_UAR_SZ_OFFSET);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/fw.h b/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_header">index bf5ec2286528..bd6e404812fd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> struct mlx4_dev_cap {</span>
 	u8  log_max_macs[MLX4_MAX_PORTS + 1];
 	u8  log_max_vlans[MLX4_MAX_PORTS + 1];
 	u32 max_counters;
<span class="p_add">+	bool wol_port[MLX4_MAX_PORTS + 1];</span>
 };
 
 struct mlx4_adapter {
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index b02adbc95575..ca46ea3db645 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -234,6 +234,8 @@</span> <span class="p_context"> static int mlx4_dev_cap(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 	dev-&gt;caps.reserved_lkey	     = dev_cap-&gt;reserved_lkey;
 	dev-&gt;caps.stat_rate_support  = dev_cap-&gt;stat_rate_support;
 	dev-&gt;caps.max_gso_sz	     = dev_cap-&gt;max_gso_sz;
<span class="p_add">+	dev-&gt;caps.wol_port[1]          = dev_cap-&gt;wol_port[1];</span>
<span class="p_add">+	dev-&gt;caps.wol_port[2]          = dev_cap-&gt;wol_port[2];</span>
 
 	dev-&gt;caps.log_num_macs  = log_num_mac;
 	dev-&gt;caps.log_num_vlans = MLX4_LOG_NUM_VLANS;
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">index fca804f36d61..a11195f0958b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_chunk">@@ -724,7 +724,7 @@</span> <span class="p_context"> static void ql_build_coredump_seg_header(</span>
 	seg_hdr-&gt;cookie = MPI_COREDUMP_COOKIE;
 	seg_hdr-&gt;segNum = seg_number;
 	seg_hdr-&gt;segSize = seg_size;
<span class="p_del">-	memcpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
<span class="p_add">+	strncpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">index 0c2678782b46..356b7d4c104f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_chunk">@@ -5371,7 +5371,6 @@</span> <span class="p_context"> static void rtl8169_tx_clear_range(struct rtl8169_private *tp, u32 start,</span>
 			rtl8169_unmap_tx_skb(&amp;tp-&gt;pci_dev-&gt;dev, tx_skb,
 					     tp-&gt;TxDescArray + entry);
 			if (skb) {
<span class="p_del">-				tp-&gt;dev-&gt;stats.tx_dropped++;</span>
 				dev_kfree_skb_any(skb);
 				tx_skb-&gt;skb = NULL;
 			}
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/mcdi_mac.c b/drivers/net/ethernet/sfc/mcdi_mac.c</span>
<span class="p_header">index da269d7076ce..738589fccd42 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/mcdi_mac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/mcdi_mac.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> int efx_mcdi_set_mac(struct efx_nic *efx)</span>
 			    NULL, 0, NULL);
 }
 
<span class="p_del">-static int efx_mcdi_get_mac_faults(struct efx_nic *efx, u32 *faults)</span>
<span class="p_add">+static bool efx_mcdi_mac_check_fault(struct efx_nic *efx)</span>
 {
 	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
 	size_t outlength;
<span class="p_chunk">@@ -64,16 +64,13 @@</span> <span class="p_context"> static int efx_mcdi_get_mac_faults(struct efx_nic *efx, u32 *faults)</span>
 
 	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
 			  outbuf, sizeof(outbuf), &amp;outlength);
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-</span>
<span class="p_del">-	*faults = MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		netif_err(efx, hw, efx-&gt;net_dev, &quot;%s: failed rc=%d\n&quot;,</span>
<span class="p_add">+			  __func__, rc);</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-fail:</span>
<span class="p_del">-	netif_err(efx, hw, efx-&gt;net_dev, &quot;%s: failed rc=%d\n&quot;,</span>
<span class="p_del">-		  __func__, rc);</span>
<span class="p_del">-	return rc;</span>
<span class="p_add">+	return MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT) != 0;</span>
 }
 
 int efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,
<span class="p_chunk">@@ -132,14 +129,6 @@</span> <span class="p_context"> static int efx_mcdi_mac_reconfigure(struct efx_nic *efx)</span>
 }
 
 
<span class="p_del">-static bool efx_mcdi_mac_check_fault(struct efx_nic *efx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 faults;</span>
<span class="p_del">-	int rc = efx_mcdi_get_mac_faults(efx, &amp;faults);</span>
<span class="p_del">-	return (rc != 0) || (faults != 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 const struct efx_mac_operations efx_mcdi_mac_operations = {
 	.reconfigure	= efx_mcdi_mac_reconfigure,
 	.update_stats	= efx_port_dummy_op_void,
<span class="p_header">diff --git a/drivers/net/wireless/ray_cs.c b/drivers/net/wireless/ray_cs.c</span>
<span class="p_header">index 0021e4948512..04fec1fa6e0b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ray_cs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ray_cs.c</span>
<span class="p_chunk">@@ -2426,7 +2426,7 @@</span> <span class="p_context"> static void rx_authenticate(ray_dev_t *local, struct rcs __iomem *prcs,</span>
 			    unsigned int pkt_addr, int rx_len)
 {
 	UCHAR buff[256];
<span class="p_del">-	struct rx_msg *msg = (struct rx_msg *)buff;</span>
<span class="p_add">+	struct ray_rx_msg *msg = (struct ray_rx_msg *) buff;</span>
 
 	del_timer(&amp;local-&gt;timer);
 
<span class="p_chunk">@@ -2513,7 +2513,7 @@</span> <span class="p_context"> static void rx_deauthenticate(ray_dev_t *local, struct rcs __iomem *prcs,</span>
 			      unsigned int pkt_addr, int rx_len)
 {
 /*  UCHAR buff[256];
<span class="p_del">-    struct rx_msg *msg = (struct rx_msg *)buff;</span>
<span class="p_add">+    struct ray_rx_msg *msg = (struct ray_rx_msg *) buff;</span>
 */
 	pr_debug(&quot;Deauthentication frame received\n&quot;);
 	local-&gt;authentication_state = UNAUTHENTICATED;
<span class="p_header">diff --git a/drivers/net/wireless/rayctl.h b/drivers/net/wireless/rayctl.h</span>
<span class="p_header">index d7646f299bd3..3c3b98b152c3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rayctl.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rayctl.h</span>
<span class="p_chunk">@@ -566,9 +566,9 @@</span> <span class="p_context"> struct phy_header {</span>
     UCHAR hdr_3;
     UCHAR hdr_4;
 };
<span class="p_del">-struct rx_msg {</span>
<span class="p_add">+struct ray_rx_msg {</span>
     struct mac_header mac;
<span class="p_del">-    UCHAR  var[1];</span>
<span class="p_add">+    UCHAR  var[0];</span>
 };
 
 struct tx_msg {
<span class="p_header">diff --git a/drivers/net/wireless/wl1251/main.c b/drivers/net/wireless/wl1251/main.c</span>
<span class="p_header">index 40c1574ce1df..456389178d7b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/wl1251/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/wl1251/main.c</span>
<span class="p_chunk">@@ -1428,6 +1428,7 @@</span> <span class="p_context"> struct ieee80211_hw *wl1251_alloc_hw(void)</span>
 
 	wl-&gt;state = WL1251_STATE_OFF;
 	mutex_init(&amp;wl-&gt;mutex);
<span class="p_add">+	spin_lock_init(&amp;wl-&gt;wl_lock);</span>
 
 	wl-&gt;tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;
 	wl-&gt;tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;
<span class="p_header">diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c</span>
<span class="p_header">index bcd5d54b7d4d..d12d2728d5dd 100644</span>
<span class="p_header">--- a/drivers/parisc/dino.c</span>
<span class="p_header">+++ b/drivers/parisc/dino.c</span>
<span class="p_chunk">@@ -988,7 +988,7 @@</span> <span class="p_context"> static int __init dino_probe(struct parisc_device *dev)</span>
 
 	dino_dev-&gt;hba.dev = dev;
 	dino_dev-&gt;hba.base_addr = ioremap_nocache(hpa, 4096);
<span class="p_del">-	dino_dev-&gt;hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */</span>
<span class="p_add">+	dino_dev-&gt;hba.lmmio_space_offset = PCI_F_EXTEND;</span>
 	spin_lock_init(&amp;dino_dev-&gt;dinosaur_pen);
 	dino_dev-&gt;hba.iommu = ccio_get_iommu(dev);
 
<span class="p_header">diff --git a/drivers/platform/x86/samsung-laptop.c b/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_header">index 64e1f2d104ad..7ec43a51f138 100644</span>
<span class="p_header">--- a/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> static int __init samsung_init(void)</span>
 	struct sabi_retval sretval;
 	unsigned int ifaceP;
 	int i;
<span class="p_del">-	int loca;</span>
<span class="p_add">+	int loca = 0xffff;</span>
 	int retval;
 
 	if (efi_enabled(EFI_BOOT))
<span class="p_header">diff --git a/drivers/rtc/rtc-m41t80.c b/drivers/rtc/rtc-m41t80.c</span>
<span class="p_header">index 64aedd8cc095..a3511e76dd60 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-m41t80.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-m41t80.c</span>
<span class="p_chunk">@@ -213,163 +213,14 @@</span> <span class="p_context"> static int m41t80_rtc_set_time(struct device *dev, struct rtc_time *tm)</span>
 	return m41t80_set_datetime(to_i2c_client(dev), tm);
 }
 
<span class="p_del">-static int m41t80_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct i2c_client *client = to_i2c_client(dev);</span>
<span class="p_del">-	int rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = i2c_smbus_read_byte_data(client, M41T80_REG_ALARM_MON);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (enabled)</span>
<span class="p_del">-		rc |= M41T80_ALMON_AFE;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		rc &amp;= ~M41T80_ALMON_AFE;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON, rc) &lt; 0)</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-err:</span>
<span class="p_del">-	return -EIO;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int m41t80_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *t)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct i2c_client *client = to_i2c_client(dev);</span>
<span class="p_del">-	u8 wbuf[1 + M41T80_ALARM_REG_SIZE];</span>
<span class="p_del">-	u8 *buf = &amp;wbuf[1];</span>
<span class="p_del">-	u8 *reg = buf - M41T80_REG_ALARM_MON;</span>
<span class="p_del">-	u8 dt_addr[1] = { M41T80_REG_ALARM_MON };</span>
<span class="p_del">-	struct i2c_msg msgs_in[] = {</span>
<span class="p_del">-		{</span>
<span class="p_del">-			.addr	= client-&gt;addr,</span>
<span class="p_del">-			.flags	= 0,</span>
<span class="p_del">-			.len	= 1,</span>
<span class="p_del">-			.buf	= dt_addr,</span>
<span class="p_del">-		},</span>
<span class="p_del">-		{</span>
<span class="p_del">-			.addr	= client-&gt;addr,</span>
<span class="p_del">-			.flags	= I2C_M_RD,</span>
<span class="p_del">-			.len	= M41T80_ALARM_REG_SIZE,</span>
<span class="p_del">-			.buf	= buf,</span>
<span class="p_del">-		},</span>
<span class="p_del">-	};</span>
<span class="p_del">-	struct i2c_msg msgs[] = {</span>
<span class="p_del">-		{</span>
<span class="p_del">-			.addr	= client-&gt;addr,</span>
<span class="p_del">-			.flags	= 0,</span>
<span class="p_del">-			.len	= 1 + M41T80_ALARM_REG_SIZE,</span>
<span class="p_del">-			.buf	= wbuf,</span>
<span class="p_del">-		 },</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i2c_transfer(client-&gt;adapter, msgs_in, 2) &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;read error\n&quot;);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_MON] &amp;= ~(0x1f | M41T80_ALMON_AFE);</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_DAY] = 0;</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_HOUR] &amp;= ~(0x3f | 0x80);</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_MIN] = 0;</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_SEC] = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	wbuf[0] = M41T80_REG_ALARM_MON; /* offset into rtc&#39;s regs */</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_SEC] |= t-&gt;time.tm_sec &gt;= 0 ?</span>
<span class="p_del">-		bin2bcd(t-&gt;time.tm_sec) : 0x80;</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_MIN] |= t-&gt;time.tm_min &gt;= 0 ?</span>
<span class="p_del">-		bin2bcd(t-&gt;time.tm_min) : 0x80;</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_HOUR] |= t-&gt;time.tm_hour &gt;= 0 ?</span>
<span class="p_del">-		bin2bcd(t-&gt;time.tm_hour) : 0x80;</span>
<span class="p_del">-	reg[M41T80_REG_ALARM_DAY] |= t-&gt;time.tm_mday &gt;= 0 ?</span>
<span class="p_del">-		bin2bcd(t-&gt;time.tm_mday) : 0x80;</span>
<span class="p_del">-	if (t-&gt;time.tm_mon &gt;= 0)</span>
<span class="p_del">-		reg[M41T80_REG_ALARM_MON] |= bin2bcd(t-&gt;time.tm_mon + 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		reg[M41T80_REG_ALARM_DAY] |= 0x40;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i2c_transfer(client-&gt;adapter, msgs, 1) != 1) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;write error\n&quot;);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (t-&gt;enabled) {</span>
<span class="p_del">-		reg[M41T80_REG_ALARM_MON] |= M41T80_ALMON_AFE;</span>
<span class="p_del">-		if (i2c_smbus_write_byte_data(client, M41T80_REG_ALARM_MON,</span>
<span class="p_del">-					      reg[M41T80_REG_ALARM_MON]) &lt; 0) {</span>
<span class="p_del">-			dev_err(&amp;client-&gt;dev, &quot;write error\n&quot;);</span>
<span class="p_del">-			return -EIO;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int m41t80_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *t)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct i2c_client *client = to_i2c_client(dev);</span>
<span class="p_del">-	u8 buf[M41T80_ALARM_REG_SIZE + 1]; /* all alarm regs and flags */</span>
<span class="p_del">-	u8 dt_addr[1] = { M41T80_REG_ALARM_MON };</span>
<span class="p_del">-	u8 *reg = buf - M41T80_REG_ALARM_MON;</span>
<span class="p_del">-	struct i2c_msg msgs[] = {</span>
<span class="p_del">-		{</span>
<span class="p_del">-			.addr	= client-&gt;addr,</span>
<span class="p_del">-			.flags	= 0,</span>
<span class="p_del">-			.len	= 1,</span>
<span class="p_del">-			.buf	= dt_addr,</span>
<span class="p_del">-		},</span>
<span class="p_del">-		{</span>
<span class="p_del">-			.addr	= client-&gt;addr,</span>
<span class="p_del">-			.flags	= I2C_M_RD,</span>
<span class="p_del">-			.len	= M41T80_ALARM_REG_SIZE + 1,</span>
<span class="p_del">-			.buf	= buf,</span>
<span class="p_del">-		},</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i2c_transfer(client-&gt;adapter, msgs, 2) &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;read error\n&quot;);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	t-&gt;time.tm_sec = -1;</span>
<span class="p_del">-	t-&gt;time.tm_min = -1;</span>
<span class="p_del">-	t-&gt;time.tm_hour = -1;</span>
<span class="p_del">-	t-&gt;time.tm_mday = -1;</span>
<span class="p_del">-	t-&gt;time.tm_mon = -1;</span>
<span class="p_del">-	if (!(reg[M41T80_REG_ALARM_SEC] &amp; 0x80))</span>
<span class="p_del">-		t-&gt;time.tm_sec = bcd2bin(reg[M41T80_REG_ALARM_SEC] &amp; 0x7f);</span>
<span class="p_del">-	if (!(reg[M41T80_REG_ALARM_MIN] &amp; 0x80))</span>
<span class="p_del">-		t-&gt;time.tm_min = bcd2bin(reg[M41T80_REG_ALARM_MIN] &amp; 0x7f);</span>
<span class="p_del">-	if (!(reg[M41T80_REG_ALARM_HOUR] &amp; 0x80))</span>
<span class="p_del">-		t-&gt;time.tm_hour = bcd2bin(reg[M41T80_REG_ALARM_HOUR] &amp; 0x3f);</span>
<span class="p_del">-	if (!(reg[M41T80_REG_ALARM_DAY] &amp; 0x80))</span>
<span class="p_del">-		t-&gt;time.tm_mday = bcd2bin(reg[M41T80_REG_ALARM_DAY] &amp; 0x3f);</span>
<span class="p_del">-	if (!(reg[M41T80_REG_ALARM_DAY] &amp; 0x40))</span>
<span class="p_del">-		t-&gt;time.tm_mon = bcd2bin(reg[M41T80_REG_ALARM_MON] &amp; 0x1f) - 1;</span>
<span class="p_del">-	t-&gt;time.tm_year = -1;</span>
<span class="p_del">-	t-&gt;time.tm_wday = -1;</span>
<span class="p_del">-	t-&gt;time.tm_yday = -1;</span>
<span class="p_del">-	t-&gt;time.tm_isdst = -1;</span>
<span class="p_del">-	t-&gt;enabled = !!(reg[M41T80_REG_ALARM_MON] &amp; M41T80_ALMON_AFE);</span>
<span class="p_del">-	t-&gt;pending = !!(reg[M41T80_REG_FLAGS] &amp; M41T80_FLAGS_AF);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * XXX - m41t80 alarm functionality is reported broken.</span>
<span class="p_add">+ * until it is fixed, don&#39;t register alarm functions.</span>
<span class="p_add">+ */</span>
 static struct rtc_class_ops m41t80_rtc_ops = {
 	.read_time = m41t80_rtc_read_time,
 	.set_time = m41t80_rtc_set_time,
<span class="p_del">-	/*</span>
<span class="p_del">-	 * XXX - m41t80 alarm functionality is reported broken.</span>
<span class="p_del">-	 * until it is fixed, don&#39;t register alarm functions.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	.read_alarm = m41t80_rtc_read_alarm,</span>
<span class="p_del">-	.set_alarm = m41t80_rtc_set_alarm,</span>
<span class="p_del">-	*/</span>
 	.proc = m41t80_rtc_proc,
<span class="p_del">-	/*</span>
<span class="p_del">-	 * See above comment on broken alarm</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	.alarm_irq_enable = m41t80_rtc_alarm_irq_enable,</span>
<span class="p_del">-	*/</span>
 };
 
 #if defined(CONFIG_RTC_INTF_SYSFS) || defined(CONFIG_RTC_INTF_SYSFS_MODULE)
<span class="p_header">diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c</span>
<span class="p_header">index bfd618a69499..52f7f3a5ae1f 100644</span>
<span class="p_header">--- a/drivers/scsi/advansys.c</span>
<span class="p_header">+++ b/drivers/scsi/advansys.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"></span>
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 
<span class="p_del">-/* FIXME:</span>
<span class="p_add">+/* Fixed in linux-4.2, not backported to 3.2:</span>
  *
  *  1. Although all of the necessary command mapping places have the
  *     appropriate dma_map.. APIs, the driver still processes its internal
<span class="p_chunk">@@ -69,7 +69,6 @@</span> <span class="p_context"></span>
  *  7. advansys_info is not safe against multiple simultaneous callers
  *  8. Add module_param to override ISA/VLB ioport array
  */
<span class="p_del">-#warning this driver is still not properly converted to the DMA API</span>
 
 /* Enable driver /proc statistics. */
 #define ADVANSYS_STATS
<span class="p_header">diff --git a/drivers/scsi/aic94xx/aic94xx_sds.c b/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_header">index edb43fda9f36..c831e30411fa 100644</span>
<span class="p_header">--- a/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_header">+++ b/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_chunk">@@ -983,7 +983,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 {
 	int err, i;
 	u32 offs, size;
<span class="p_del">-	struct asd_ll_el *el;</span>
<span class="p_add">+	struct asd_ll_el *el = NULL;</span>
 	struct asd_ctrla_phy_settings *ps;
 	struct asd_ctrla_phy_settings dflt_ps;
 
<span class="p_chunk">@@ -1004,6 +1004,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 
 		size = sizeof(struct asd_ctrla_phy_settings);
 		ps = &amp;dflt_ps;
<span class="p_add">+		goto out_process;</span>
 	}
 
 	if (size == 0)
<span class="p_chunk">@@ -1028,7 +1029,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 		ASD_DPRINTK(&quot;couldn&#39;t find ctrla phy settings struct\n&quot;);
 		goto out2;
 	}
<span class="p_del">-</span>
<span class="p_add">+out_process:</span>
 	err = asd_process_ctrla_phy_settings(asd_ha, ps);
 	if (err) {
 		ASD_DPRINTK(&quot;couldn&#39;t process ctrla phy settings\n&quot;);
<span class="p_header">diff --git a/drivers/scsi/libsas/sas_scsi_host.c b/drivers/scsi/libsas/sas_scsi_host.c</span>
<span class="p_header">index b6e233d9a0a1..e6f0a48eed2b 100644</span>
<span class="p_header">--- a/drivers/scsi/libsas/sas_scsi_host.c</span>
<span class="p_header">+++ b/drivers/scsi/libsas/sas_scsi_host.c</span>
<span class="p_chunk">@@ -49,27 +49,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/scatterlist.h&gt;
 #include &lt;linux/libata.h&gt;
 
<span class="p_del">-/* ---------- SCSI Host glue ---------- */</span>
<span class="p_del">-</span>
<span class="p_del">-static void sas_scsi_task_done(struct sas_task *task)</span>
<span class="p_add">+/* record final status and free the task */</span>
<span class="p_add">+static void sas_end_task(struct scsi_cmnd *sc, struct sas_task *task)</span>
 {
 	struct task_status_struct *ts = &amp;task-&gt;task_status;
<span class="p_del">-	struct scsi_cmnd *sc = task-&gt;uldd_task;</span>
 	int hs = 0, stat = 0;
 
<span class="p_del">-	if (unlikely(task-&gt;task_state_flags &amp; SAS_TASK_STATE_ABORTED)) {</span>
<span class="p_del">-		/* Aborted tasks will be completed by the error handler */</span>
<span class="p_del">-		SAS_DPRINTK(&quot;task done but aborted\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(!sc)) {</span>
<span class="p_del">-		SAS_DPRINTK(&quot;task_done called with non existing SCSI cmnd!\n&quot;);</span>
<span class="p_del">-		list_del_init(&amp;task-&gt;list);</span>
<span class="p_del">-		sas_free_task(task);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (ts-&gt;resp == SAS_TASK_UNDELIVERED) {
 		/* transport error */
 		hs = DID_NO_CONNECT;
<span class="p_chunk">@@ -124,10 +109,32 @@</span> <span class="p_context"> static void sas_scsi_task_done(struct sas_task *task)</span>
 			break;
 		}
 	}
<span class="p_del">-	ASSIGN_SAS_TASK(sc, NULL);</span>
<span class="p_add">+</span>
 	sc-&gt;result = (hs &lt;&lt; 16) | stat;
<span class="p_add">+	ASSIGN_SAS_TASK(sc, NULL);</span>
 	list_del_init(&amp;task-&gt;list);
 	sas_free_task(task);
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void sas_scsi_task_done(struct sas_task *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_cmnd *sc = task-&gt;uldd_task;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(task-&gt;task_state_flags &amp; SAS_TASK_STATE_ABORTED)) {</span>
<span class="p_add">+		/* Aborted tasks will be completed by the error handler */</span>
<span class="p_add">+		SAS_DPRINTK(&quot;task done but aborted\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!sc)) {</span>
<span class="p_add">+		SAS_DPRINTK(&quot;task_done called with non existing SCSI cmnd!\n&quot;);</span>
<span class="p_add">+		list_del_init(&amp;task-&gt;list);</span>
<span class="p_add">+		sas_free_task(task);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ASSIGN_SAS_TASK(sc, NULL);</span>
<span class="p_add">+	sas_end_task(sc, task);</span>
 	sc-&gt;scsi_done(sc);
 }
 
<span class="p_chunk">@@ -238,18 +245,16 @@</span> <span class="p_context"> static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)</span>
 	struct sas_task *task = TO_SAS_TASK(cmd);
 	struct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd-&gt;device-&gt;host);
 
<span class="p_del">-	/* remove the aborted task flag to allow the task to be</span>
<span class="p_del">-	 * completed now. At this point, we only get called following</span>
<span class="p_del">-	 * an actual abort of the task, so we should be guaranteed not</span>
<span class="p_del">-	 * to be racing with any completions from the LLD (hence we</span>
<span class="p_del">-	 * don&#39;t need the task state lock to clear the flag) */</span>
<span class="p_del">-	task-&gt;task_state_flags &amp;= ~SAS_TASK_STATE_ABORTED;</span>
<span class="p_del">-	/* Now call task_done.  However, task will be free&#39;d after</span>
<span class="p_del">-	 * this */</span>
<span class="p_del">-	task-&gt;task_done(task);</span>
<span class="p_add">+	/* At this point, we only get called following an actual abort</span>
<span class="p_add">+	 * of the task, so we should be guaranteed not to be racing with</span>
<span class="p_add">+	 * any completions from the LLD.  Task is freed after this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sas_end_task(cmd, task);</span>
<span class="p_add">+</span>
 	/* now finish the command and move it on to the error
 	 * handler done list, this also takes it off the
<span class="p_del">-	 * error handler pending list */</span>
<span class="p_add">+	 * error handler pending list.</span>
<span class="p_add">+	 */</span>
 	scsi_eh_finish_cmd(cmd, &amp;sas_ha-&gt;eh_done_q);
 }
 
<span class="p_header">diff --git a/drivers/scsi/mpt2sas/mpt2sas_scsih.c b/drivers/scsi/mpt2sas/mpt2sas_scsih.c</span>
<span class="p_header">index 01780a963181..044c70275002 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt2sas/mpt2sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt2sas/mpt2sas_scsih.c</span>
<span class="p_chunk">@@ -5734,9 +5734,10 @@</span> <span class="p_context"> _scsih_sas_broadcast_primative_event(struct MPT2SAS_ADAPTER *ioc,</span>
 	u8 task_abort_retries;
 
 	mutex_lock(&amp;ioc-&gt;tm_cmds.mutex);
<span class="p_del">-	dewtprintk(ioc, printk(MPT2SAS_INFO_FMT &quot;%s: enter: phy number(%d), &quot;</span>
<span class="p_del">-	    &quot;width(%d)\n&quot;, ioc-&gt;name, __func__, event_data-&gt;PhyNum,</span>
<span class="p_del">-	     event_data-&gt;PortWidth));</span>
<span class="p_add">+	pr_info(MPT2SAS_FMT</span>
<span class="p_add">+		&quot;%s: enter: phy number(%d), width(%d)\n&quot;,</span>
<span class="p_add">+		ioc-&gt;name, __func__, event_data-&gt;PhyNum,</span>
<span class="p_add">+		event_data-&gt;PortWidth);</span>
 
 	_scsih_block_io_all_device(ioc);
 
<span class="p_header">diff --git a/drivers/staging/bcm/Kconfig b/drivers/staging/bcm/Kconfig</span>
<span class="p_header">index 96adb1026c4f..22f5aa418dd6 100644</span>
<span class="p_header">--- a/drivers/staging/bcm/Kconfig</span>
<span class="p_header">+++ b/drivers/staging/bcm/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 config BCM_WIMAX
        tristate &quot;Beceem BCS200/BCS220-3 and BCSM250 wimax support&quot;
        depends on USB &amp;&amp; NET &amp;&amp; EXPERIMENTAL
<span class="p_add">+	depends on !64BIT</span>
        default N
        help
          This is an experimental driver for the Beceem WIMAX chipset used
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/vmk80xx.c b/drivers/staging/comedi/drivers/vmk80xx.c</span>
<span class="p_header">index 3d13ca6e1670..c7ff0cc40557 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/vmk80xx.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/vmk80xx.c</span>
<span class="p_chunk">@@ -605,6 +605,7 @@</span> <span class="p_context"> static int vmk80xx_ai_rinsn(struct comedi_device *cdev,</span>
 			reg[0] = VMK8055_AI2_REG;
 		break;
 	case VMK8061_MODEL:
<span class="p_add">+	default:</span>
 		reg[0] = VMK8061_AI_REG1;
 		reg[1] = VMK8061_AI_REG2;
 		dev-&gt;usb_tx_buf[0] = VMK8061_CMD_RD_AI;
<span class="p_chunk">@@ -979,6 +980,7 @@</span> <span class="p_context"> static int vmk80xx_cnt_rinsn(struct comedi_device *cdev,</span>
 			reg[0] = VMK8055_CNT2_REG;
 		break;
 	case VMK8061_MODEL:
<span class="p_add">+	default:</span>
 		reg[0] = VMK8061_CNT_REG;
 		reg[1] = VMK8061_CNT_REG;
 		dev-&gt;usb_tx_buf[0] = VMK8061_CMD_RD_CNT;
<span class="p_header">diff --git a/drivers/staging/cxt1e1/functions.c b/drivers/staging/cxt1e1/functions.c</span>
<span class="p_header">index d9a9aa3571d9..a98729e85e24 100644</span>
<span class="p_header">--- a/drivers/staging/cxt1e1/functions.c</span>
<span class="p_header">+++ b/drivers/staging/cxt1e1/functions.c</span>
<span class="p_chunk">@@ -269,15 +269,6 @@</span> <span class="p_context"> void sd_recv_consume(void *token, size_t len, void *user)</span>
 #include &quot;comet.h&quot;
 
 extern ci_t *CI;                /* dummy pointer to board ZERO&#39;s data */
<span class="p_del">-void</span>
<span class="p_del">-VMETRO_TRACE (void *x)</span>
<span class="p_del">-{</span>
<span class="p_del">-    u_int32_t   y = (u_int32_t) x;</span>
<span class="p_del">-</span>
<span class="p_del">-    pci_write_32 ((u_int32_t *) &amp;CI-&gt;cpldbase-&gt;leds, y);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 void
 VMETRO_TRIGGER (ci_t * ci, int x)
 {
<span class="p_header">diff --git a/drivers/staging/cxt1e1/pmcc4.h b/drivers/staging/cxt1e1/pmcc4.h</span>
<span class="p_header">index e046b87763a2..d92ea7d2f5d2 100644</span>
<span class="p_header">--- a/drivers/staging/cxt1e1/pmcc4.h</span>
<span class="p_header">+++ b/drivers/staging/cxt1e1/pmcc4.h</span>
<span class="p_chunk">@@ -138,7 +138,6 @@</span> <span class="p_context"> void        sbeid_set_bdtype (ci_t * ci);</span>
 void        sbeid_set_hdwbid (ci_t * ci);
 u_int32_t   sbeCrc (u_int8_t *, u_int32_t, u_int32_t, u_int32_t *);
 
<span class="p_del">-void        VMETRO_TRACE (void *);       /* put data into 8 LEDs */</span>
 void        VMETRO_TRIGGER (ci_t *, int);       /* Note: int = 0(default)
                                                  * thru 15 */
 
<span class="p_header">diff --git a/drivers/staging/iio/accel/lis3l02dq_core.c b/drivers/staging/iio/accel/lis3l02dq_core.c</span>
<span class="p_header">index 559545a42333..84145a4fee9f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/accel/lis3l02dq_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/accel/lis3l02dq_core.c</span>
<span class="p_chunk">@@ -534,7 +534,7 @@</span> <span class="p_context"> static struct iio_chan_spec lis3l02dq_channels[] = {</span>
 };
 
 
<span class="p_del">-static ssize_t lis3l02dq_read_event_config(struct iio_dev *indio_dev,</span>
<span class="p_add">+static int lis3l02dq_read_event_config(struct iio_dev *indio_dev,</span>
 					   u64 event_code)
 {
 
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7298_ring.c b/drivers/staging/iio/adc/ad7298_ring.c</span>
<span class="p_header">index 47630d506a63..76dad99a6d2f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7298_ring.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7298_ring.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static irqreturn_t ad7298_trigger_handler(int irq, void *p)</span>
 	struct iio_dev *indio_dev = pf-&gt;indio_dev;
 	struct ad7298_state *st = iio_priv(indio_dev);
 	struct iio_buffer *ring = indio_dev-&gt;buffer;
<span class="p_del">-	s64 time_ns;</span>
<span class="p_add">+	s64 time_ns = 0;</span>
 	__u16 buf[16];
 	int b_sent, i;
 
<span class="p_header">diff --git a/drivers/staging/iio/gyro/adis16080_core.c b/drivers/staging/iio/gyro/adis16080_core.c</span>
<span class="p_header">index 5d7a906fec78..b9dc422e5f22 100644</span>
<span class="p_header">--- a/drivers/staging/iio/gyro/adis16080_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/gyro/adis16080_core.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static int adis16080_read_raw(struct iio_dev *indio_dev,</span>
 			     long mask)
 {
 	int ret = -EINVAL;
<span class="p_del">-	u16 ut;</span>
<span class="p_add">+	u16 ut = 0;</span>
 	/* Take the iio_dev status lock */
 
 	mutex_lock(&amp;indio_dev-&gt;mlock);
<span class="p_header">diff --git a/drivers/staging/iio/light/tsl2563.c b/drivers/staging/iio/light/tsl2563.c</span>
<span class="p_header">index 7e984bcf8d7e..ee83ccb93af1 100644</span>
<span class="p_header">--- a/drivers/staging/iio/light/tsl2563.c</span>
<span class="p_header">+++ b/drivers/staging/iio/light/tsl2563.c</span>
<span class="p_chunk">@@ -606,7 +606,7 @@</span> <span class="p_context"> static irqreturn_t tsl2563_event_handler(int irq, void *private)</span>
 	struct tsl2563_chip *chip = iio_priv(dev_info);
 
 	iio_push_event(dev_info,
<span class="p_del">-		       IIO_UNMOD_EVENT_CODE(IIO_LIGHT,</span>
<span class="p_add">+		       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY,</span>
 					    0,
 					    IIO_EV_TYPE_THRESH,
 					    IIO_EV_DIR_EITHER),
<span class="p_header">diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_header">index 6401a6273625..0ed8c0b78ae0 100644</span>
<span class="p_header">--- a/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_header">+++ b/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_chunk">@@ -480,7 +480,7 @@</span> <span class="p_context"> static int ad2s1210_read_raw(struct iio_dev *indio_dev,</span>
 			     long m)
 {
 	struct ad2s1210_state *st = iio_priv(indio_dev);
<span class="p_del">-	bool negative;</span>
<span class="p_add">+	u16 negative;</span>
 	int ret = 0;
 	u16 pos;
 	s16 vel;
<span class="p_header">diff --git a/drivers/staging/slicoss/slicoss.c b/drivers/staging/slicoss/slicoss.c</span>
<span class="p_header">index 77a0751a31ad..f54057b3a6e5 100644</span>
<span class="p_header">--- a/drivers/staging/slicoss/slicoss.c</span>
<span class="p_header">+++ b/drivers/staging/slicoss/slicoss.c</span>
<span class="p_chunk">@@ -1490,7 +1490,7 @@</span> <span class="p_context"> static struct slic_rspbuf *slic_rspqueue_getnext(struct adapter *adapter)</span>
 		slic_reg64_write(adapter, &amp;adapter-&gt;slic_regs-&gt;slic_rbar64,
 			(rspq-&gt;paddr[rspq-&gt;pageindex] | SLIC_RSPQ_BUFSINPAGE),
 			&amp;adapter-&gt;slic_regs-&gt;slic_addr_upper, 0, DONT_FLUSH);
<span class="p_del">-		rspq-&gt;pageindex = (++rspq-&gt;pageindex) % rspq-&gt;num_pages;</span>
<span class="p_add">+		rspq-&gt;pageindex = (rspq-&gt;pageindex + 1) % rspq-&gt;num_pages;</span>
 		rspq-&gt;offset = 0;
 		rspq-&gt;rspbuf = (struct slic_rspbuf *)
 						rspq-&gt;vaddr[rspq-&gt;pageindex];
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index 077c5062b91f..5765bb96e9fe 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -3387,9 +3387,12 @@</span> <span class="p_context"> static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {</span>
 
 	case SIOCGIWAPLIST:
 	    {
<span class="p_del">-            char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];</span>
<span class="p_add">+		char *buffer = kzalloc(IW_MAX_AP * (sizeof(struct sockaddr) +</span>
<span class="p_add">+				       sizeof(struct iw_quality)), GFP_KERNEL);</span>
 
<span class="p_del">-		    if (wrq-&gt;u.data.pointer) {</span>
<span class="p_add">+		if (!buffer) {</span>
<span class="p_add">+			rc = -ENOMEM;</span>
<span class="p_add">+		} else if (wrq-&gt;u.data.pointer) {</span>
 		        rc = iwctl_giwaplist(dev, NULL, &amp;(wrq-&gt;u.data), buffer);
 		        if (rc == 0) {
                     if (copy_to_user(wrq-&gt;u.data.pointer,
<span class="p_chunk">@@ -3399,6 +3402,7 @@</span> <span class="p_context"> static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {</span>
 				    rc = -EFAULT;
 		        }
             }
<span class="p_add">+		kfree(buffer);</span>
         }
 		break;
 
<span class="p_header">diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_header">index 3c40096f0c05..80e959df7cd4 100644</span>
<span class="p_header">--- a/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_header">+++ b/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_chunk">@@ -765,30 +765,35 @@</span> <span class="p_context"> int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,</span>
 int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
<span class="p_del">-	struct p80211msg_p2req_readpda msg;</span>
<span class="p_add">+	struct p80211msg_p2req_readpda *msg;</span>
<span class="p_add">+</span>
<span class="p_add">+	msg = kzalloc(sizeof(*msg), GFP_KERNEL);</span>
<span class="p_add">+	if (!msg)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* set up the msg */
<span class="p_del">-	msg.msgcode = DIDmsg_p2req_readpda;</span>
<span class="p_del">-	msg.msglen = sizeof(msg);</span>
<span class="p_del">-	strcpy(msg.devname, wlandev-&gt;name);</span>
<span class="p_del">-	msg.pda.did = DIDmsg_p2req_readpda_pda;</span>
<span class="p_del">-	msg.pda.len = HFA384x_PDA_LEN_MAX;</span>
<span class="p_del">-	msg.pda.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-	msg.resultcode.did = DIDmsg_p2req_readpda_resultcode;</span>
<span class="p_del">-	msg.resultcode.len = sizeof(u32);</span>
<span class="p_del">-	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (prism2mgmt_readpda(wlandev, &amp;msg) != 0) {</span>
<span class="p_add">+	msg-&gt;msgcode = DIDmsg_p2req_readpda;</span>
<span class="p_add">+	msg-&gt;msglen = sizeof(msg);</span>
<span class="p_add">+	strcpy(msg-&gt;devname, wlandev-&gt;name);</span>
<span class="p_add">+	msg-&gt;pda.did = DIDmsg_p2req_readpda_pda;</span>
<span class="p_add">+	msg-&gt;pda.len = HFA384x_PDA_LEN_MAX;</span>
<span class="p_add">+	msg-&gt;pda.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+	msg-&gt;resultcode.did = DIDmsg_p2req_readpda_resultcode;</span>
<span class="p_add">+	msg-&gt;resultcode.len = sizeof(u32);</span>
<span class="p_add">+	msg-&gt;resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prism2mgmt_readpda(wlandev, msg) != 0) {</span>
 		/* prism2mgmt_readpda prints an errno if appropriate */
 		result = -1;
<span class="p_del">-	} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {</span>
<span class="p_del">-		memcpy(pda-&gt;buf, msg.pda.data, HFA384x_PDA_LEN_MAX);</span>
<span class="p_add">+	} else if (msg-&gt;resultcode.data == P80211ENUM_resultcode_success) {</span>
<span class="p_add">+		memcpy(pda-&gt;buf, msg-&gt;pda.data, HFA384x_PDA_LEN_MAX);</span>
 		result = mkpdrlist(pda);
 	} else {
 		/* resultcode must&#39;ve been something other than success */
 		result = -1;
 	}
 
<span class="p_add">+	kfree(msg);</span>
 	return result;
 }
 
<span class="p_chunk">@@ -980,9 +985,8 @@</span> <span class="p_context"> int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,</span>
 	       unsigned int nfchunks)
 {
 	int result = 0;
<span class="p_del">-	struct p80211msg_p2req_ramdl_state rstatemsg;</span>
<span class="p_del">-	struct p80211msg_p2req_ramdl_write rwritemsg;</span>
<span class="p_del">-	struct p80211msg *msgp;</span>
<span class="p_add">+	struct p80211msg_p2req_ramdl_state *rstmsg;</span>
<span class="p_add">+	struct p80211msg_p2req_ramdl_write *rwrmsg;</span>
 	u32 resultcode;
 	int i;
 	int j;
<span class="p_chunk">@@ -991,57 +995,68 @@</span> <span class="p_context"> int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,</span>
 	u32 currlen;
 	u32 currdaddr;
 
<span class="p_add">+	rstmsg = kmalloc(sizeof(*rstmsg), GFP_KERNEL);</span>
<span class="p_add">+	rwrmsg = kmalloc(sizeof(*rwrmsg), GFP_KERNEL);</span>
<span class="p_add">+	if (!rstmsg || !rwrmsg) {</span>
<span class="p_add">+		kfree(rstmsg);</span>
<span class="p_add">+		kfree(rwrmsg);</span>
<span class="p_add">+		printk(KERN_ERR</span>
<span class="p_add">+		       &quot;writeimage: no memory for firmware download, &quot;</span>
<span class="p_add">+		       &quot;aborting download\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Initialize the messages */
<span class="p_del">-	memset(&amp;rstatemsg, 0, sizeof(rstatemsg));</span>
<span class="p_del">-	strcpy(rstatemsg.devname, wlandev-&gt;name);</span>
<span class="p_del">-	rstatemsg.msgcode = DIDmsg_p2req_ramdl_state;</span>
<span class="p_del">-	rstatemsg.msglen = sizeof(rstatemsg);</span>
<span class="p_del">-	rstatemsg.enable.did = DIDmsg_p2req_ramdl_state_enable;</span>
<span class="p_del">-	rstatemsg.exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;</span>
<span class="p_del">-	rstatemsg.resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;</span>
<span class="p_del">-	rstatemsg.enable.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_del">-	rstatemsg.exeaddr.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_del">-	rstatemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-	rstatemsg.enable.len = sizeof(u32);</span>
<span class="p_del">-	rstatemsg.exeaddr.len = sizeof(u32);</span>
<span class="p_del">-	rstatemsg.resultcode.len = sizeof(u32);</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(&amp;rwritemsg, 0, sizeof(rwritemsg));</span>
<span class="p_del">-	strcpy(rwritemsg.devname, wlandev-&gt;name);</span>
<span class="p_del">-	rwritemsg.msgcode = DIDmsg_p2req_ramdl_write;</span>
<span class="p_del">-	rwritemsg.msglen = sizeof(rwritemsg);</span>
<span class="p_del">-	rwritemsg.addr.did = DIDmsg_p2req_ramdl_write_addr;</span>
<span class="p_del">-	rwritemsg.len.did = DIDmsg_p2req_ramdl_write_len;</span>
<span class="p_del">-	rwritemsg.data.did = DIDmsg_p2req_ramdl_write_data;</span>
<span class="p_del">-	rwritemsg.resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;</span>
<span class="p_del">-	rwritemsg.addr.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_del">-	rwritemsg.len.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_del">-	rwritemsg.data.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_del">-	rwritemsg.resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-	rwritemsg.addr.len = sizeof(u32);</span>
<span class="p_del">-	rwritemsg.len.len = sizeof(u32);</span>
<span class="p_del">-	rwritemsg.data.len = WRITESIZE_MAX;</span>
<span class="p_del">-	rwritemsg.resultcode.len = sizeof(u32);</span>
<span class="p_add">+	memset(rstmsg, 0, sizeof(*rstmsg));</span>
<span class="p_add">+	strcpy(rstmsg-&gt;devname, wlandev-&gt;name);</span>
<span class="p_add">+	rstmsg-&gt;msgcode = DIDmsg_p2req_ramdl_state;</span>
<span class="p_add">+	rstmsg-&gt;msglen = sizeof(*rstmsg);</span>
<span class="p_add">+	rstmsg-&gt;enable.did = DIDmsg_p2req_ramdl_state_enable;</span>
<span class="p_add">+	rstmsg-&gt;exeaddr.did = DIDmsg_p2req_ramdl_state_exeaddr;</span>
<span class="p_add">+	rstmsg-&gt;resultcode.did = DIDmsg_p2req_ramdl_state_resultcode;</span>
<span class="p_add">+	rstmsg-&gt;enable.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_add">+	rstmsg-&gt;exeaddr.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_add">+	rstmsg-&gt;resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+	rstmsg-&gt;enable.len = sizeof(u32);</span>
<span class="p_add">+	rstmsg-&gt;exeaddr.len = sizeof(u32);</span>
<span class="p_add">+	rstmsg-&gt;resultcode.len = sizeof(u32);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(rwrmsg, 0, sizeof(*rwrmsg));</span>
<span class="p_add">+	strcpy(rwrmsg-&gt;devname, wlandev-&gt;name);</span>
<span class="p_add">+	rwrmsg-&gt;msgcode = DIDmsg_p2req_ramdl_write;</span>
<span class="p_add">+	rwrmsg-&gt;msglen = sizeof(*rwrmsg);</span>
<span class="p_add">+	rwrmsg-&gt;addr.did = DIDmsg_p2req_ramdl_write_addr;</span>
<span class="p_add">+	rwrmsg-&gt;len.did = DIDmsg_p2req_ramdl_write_len;</span>
<span class="p_add">+	rwrmsg-&gt;data.did = DIDmsg_p2req_ramdl_write_data;</span>
<span class="p_add">+	rwrmsg-&gt;resultcode.did = DIDmsg_p2req_ramdl_write_resultcode;</span>
<span class="p_add">+	rwrmsg-&gt;addr.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_add">+	rwrmsg-&gt;len.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_add">+	rwrmsg-&gt;data.status = P80211ENUM_msgitem_status_data_ok;</span>
<span class="p_add">+	rwrmsg-&gt;resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+	rwrmsg-&gt;addr.len = sizeof(u32);</span>
<span class="p_add">+	rwrmsg-&gt;len.len = sizeof(u32);</span>
<span class="p_add">+	rwrmsg-&gt;data.len = WRITESIZE_MAX;</span>
<span class="p_add">+	rwrmsg-&gt;resultcode.len = sizeof(u32);</span>
 
 	/* Send xxx_state(enable) */
 	pr_debug(&quot;Sending dl_state(enable) message.\n&quot;);
<span class="p_del">-	rstatemsg.enable.data = P80211ENUM_truth_true;</span>
<span class="p_del">-	rstatemsg.exeaddr.data = startaddr;</span>
<span class="p_add">+	rstmsg-&gt;enable.data = P80211ENUM_truth_true;</span>
<span class="p_add">+	rstmsg-&gt;exeaddr.data = startaddr;</span>
 
<span class="p_del">-	msgp = (struct p80211msg *) &amp;rstatemsg;</span>
<span class="p_del">-	result = prism2mgmt_ramdl_state(wlandev, msgp);</span>
<span class="p_add">+	result = prism2mgmt_ramdl_state(wlandev, rstmsg);</span>
 	if (result) {
 		printk(KERN_ERR
 		       &quot;writeimage state enable failed w/ result=%d, &quot;
 		       &quot;aborting download\n&quot;, result);
<span class="p_del">-		return result;</span>
<span class="p_add">+		goto free_result;</span>
 	}
<span class="p_del">-	resultcode = rstatemsg.resultcode.data;</span>
<span class="p_add">+	resultcode = rstmsg-&gt;resultcode.data;</span>
 	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
 		       &quot;writeimage()-&gt;xxxdl_state msg indicates failure, &quot;
 		       &quot;w/ resultcode=%d, aborting download.\n&quot;, resultcode);
<span class="p_del">-		return 1;</span>
<span class="p_add">+		result = 1;</span>
<span class="p_add">+		goto free_result;</span>
 	}
 
 	/* Now, loop through the data chunks and send WRITESIZE_MAX data */
<span class="p_chunk">@@ -1059,9 +1074,9 @@</span> <span class="p_context"> int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,</span>
 			curroff = j * WRITESIZE_MAX;
 			currdaddr = fchunk[i].addr + curroff;
 			/* Setup the message */
<span class="p_del">-			rwritemsg.addr.data = currdaddr;</span>
<span class="p_del">-			rwritemsg.len.data = currlen;</span>
<span class="p_del">-			memcpy(rwritemsg.data.data,</span>
<span class="p_add">+			rwrmsg-&gt;addr.data = currdaddr;</span>
<span class="p_add">+			rwrmsg-&gt;len.data = currlen;</span>
<span class="p_add">+			memcpy(rwrmsg-&gt;data.data,</span>
 			       fchunk[i].data + curroff, currlen);
 
 			/* Send flashdl_write(pda) */
<span class="p_chunk">@@ -1069,23 +1084,23 @@</span> <span class="p_context"> int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,</span>
 			    (&quot;Sending xxxdl_write message addr=%06x len=%d.\n&quot;,
 			     currdaddr, currlen);
 
<span class="p_del">-			msgp = (struct p80211msg *) &amp;rwritemsg;</span>
<span class="p_del">-			result = prism2mgmt_ramdl_write(wlandev, msgp);</span>
<span class="p_add">+			result = prism2mgmt_ramdl_write(wlandev, rwrmsg);</span>
 
 			/* Check the results */
 			if (result) {
 				printk(KERN_ERR
 				       &quot;writeimage chunk write failed w/ result=%d, &quot;
 				       &quot;aborting download\n&quot;, result);
<span class="p_del">-				return result;</span>
<span class="p_add">+				goto free_result;</span>
 			}
<span class="p_del">-			resultcode = rstatemsg.resultcode.data;</span>
<span class="p_add">+			resultcode = rstmsg-&gt;resultcode.data;</span>
 			if (resultcode != P80211ENUM_resultcode_success) {
 				printk(KERN_ERR
 				       &quot;writeimage()-&gt;xxxdl_write msg indicates failure, &quot;
 				       &quot;w/ resultcode=%d, aborting download.\n&quot;,
 				       resultcode);
<span class="p_del">-				return 1;</span>
<span class="p_add">+				result = 1;</span>
<span class="p_add">+				goto free_result;</span>
 			}
 
 		}
<span class="p_chunk">@@ -1093,24 +1108,28 @@</span> <span class="p_context"> int writeimage(wlandevice_t *wlandev, struct imgchunk *fchunk,</span>
 
 	/* Send xxx_state(disable) */
 	pr_debug(&quot;Sending dl_state(disable) message.\n&quot;);
<span class="p_del">-	rstatemsg.enable.data = P80211ENUM_truth_false;</span>
<span class="p_del">-	rstatemsg.exeaddr.data = 0;</span>
<span class="p_add">+	rstmsg-&gt;enable.data = P80211ENUM_truth_false;</span>
<span class="p_add">+	rstmsg-&gt;exeaddr.data = 0;</span>
 
<span class="p_del">-	msgp = (struct p80211msg *) &amp;rstatemsg;</span>
<span class="p_del">-	result = prism2mgmt_ramdl_state(wlandev, msgp);</span>
<span class="p_add">+	result = prism2mgmt_ramdl_state(wlandev, rstmsg);</span>
 	if (result) {
 		printk(KERN_ERR
 		       &quot;writeimage state disable failed w/ result=%d, &quot;
 		       &quot;aborting download\n&quot;, result);
<span class="p_del">-		return result;</span>
<span class="p_add">+		goto free_result;</span>
 	}
<span class="p_del">-	resultcode = rstatemsg.resultcode.data;</span>
<span class="p_add">+	resultcode = rstmsg-&gt;resultcode.data;</span>
 	if (resultcode != P80211ENUM_resultcode_success) {
 		printk(KERN_ERR
 		       &quot;writeimage()-&gt;xxxdl_state msg indicates failure, &quot;
 		       &quot;w/ resultcode=%d, aborting download.\n&quot;, resultcode);
<span class="p_del">-		return 1;</span>
<span class="p_add">+		result = 1;</span>
<span class="p_add">+		goto free_result;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+free_result:</span>
<span class="p_add">+	kfree(rstmsg);</span>
<span class="p_add">+	kfree(rwrmsg);</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 210b533de7d7..bcadc2e3cacc 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1592,6 +1592,9 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_DEVICE(0x1576, 0x03b1), /* Maretron USB100 */
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
<span class="p_add">+	{ USB_DEVICE(0xfff0, 0x0100), /* DATECS FP-2000 */</span>
<span class="p_add">+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */</span>
<span class="p_add">+	},</span>
 
 	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */
 	.driver_info = CLEAR_HALT_CONDITIONS,
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 989256e8a105..ea15bccf30a7 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -609,15 +609,23 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 
 		} else if (header-&gt;bDescriptorType ==
 				USB_DT_INTERFACE_ASSOCIATION) {
<span class="p_add">+			struct usb_interface_assoc_descriptor *d;</span>
<span class="p_add">+</span>
<span class="p_add">+			d = (struct usb_interface_assoc_descriptor *)header;</span>
<span class="p_add">+			if (d-&gt;bLength &lt; USB_DT_INTERFACE_ASSOCIATION_SIZE) {</span>
<span class="p_add">+				dev_warn(ddev,</span>
<span class="p_add">+					 &quot;config %d has an invalid interface association descriptor of length %d, skipping\n&quot;,</span>
<span class="p_add">+					 cfgno, d-&gt;bLength);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (iad_num == USB_MAXIADS) {
 				dev_warn(ddev, &quot;found more Interface &quot;
 					       &quot;Association Descriptors &quot;
 					       &quot;than allocated for in &quot;
 					       &quot;configuration %d\n&quot;, cfgno);
 			} else {
<span class="p_del">-				config-&gt;intf_assoc[iad_num] =</span>
<span class="p_del">-					(struct usb_interface_assoc_descriptor</span>
<span class="p_del">-					*)header;</span>
<span class="p_add">+				config-&gt;intf_assoc[iad_num] = d;</span>
 				iad_num++;
 			}
 
<span class="p_chunk">@@ -923,10 +931,12 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 	for (i = 0; i &lt; num; i++) {
 		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
<span class="p_del">-		length = cap-&gt;bLength;</span>
 
<span class="p_del">-		if (total_len &lt; length)</span>
<span class="p_add">+		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {</span>
<span class="p_add">+			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;</span>
 			break;
<span class="p_add">+		}</span>
<span class="p_add">+		length = cap-&gt;bLength;</span>
 		total_len -= length;
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 3cedf914bbab..aab9b1a1d445 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2194,6 +2194,8 @@</span> <span class="p_context"> void usb_hc_died (struct usb_hcd *hcd)</span>
 	}
 	if (usb_hcd_is_primary_hcd(hcd) &amp;&amp; hcd-&gt;shared_hcd) {
 		hcd = hcd-&gt;shared_hcd;
<span class="p_add">+		clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);</span>
<span class="p_add">+		set_bit(HCD_FLAG_DEAD, &amp;hcd-&gt;flags);</span>
 		if (hcd-&gt;rh_registered) {
 			clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 2a38a1740a21..9e387ec88ccb 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -152,12 +152,13 @@</span> <span class="p_context"> get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)</span>
 			return tmp;
 	}
 
<span class="p_del">-	if (in) {</span>
<span class="p_add">+	if (in)</span>
 		dev-&gt;in_pipe = usb_rcvbulkpipe(udev,
 			in-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
<span class="p_add">+	if (out)</span>
 		dev-&gt;out_pipe = usb_sndbulkpipe(udev,
 			out-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	if (iso_in) {
 		dev-&gt;iso_in = &amp;iso_in-&gt;desc;
 		dev-&gt;in_iso_pipe = usb_rcvisocpipe(udev,
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/common.c b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">index 08c679c0dde5..71f4dae80d19 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_chunk">@@ -599,12 +599,14 @@</span> <span class="p_context"> static int usbhsc_resume(struct device *dev)</span>
 	struct usbhs_priv *priv = dev_get_drvdata(dev);
 	struct platform_device *pdev = usbhs_priv_to_pdev(priv);
 
<span class="p_del">-	usbhs_platform_call(priv, phy_reset, pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!usbhsc_flags_has(priv, USBHSF_RUNTIME_PWCTRL))</span>
<span class="p_add">+	if (!usbhsc_flags_has(priv, USBHSF_RUNTIME_PWCTRL)) {</span>
 		usbhsc_power_ctrl(priv, 1);
<span class="p_add">+		usbhs_mod_autonomy_mode(priv);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	usbhsc_hotplug(priv);</span>
<span class="p_add">+	usbhs_platform_call(priv, phy_reset, pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhsc_drvcllbck_notify_hotplug(pdev);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index fe2c410c5c67..2de2053f2cde 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
 	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
 	{ USB_DEVICE(0x10C4, 0x8A5E) }, /* CEL EM3588 ZigBee USB Stick Long Range */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8B34) }, /* Qivicon ZigBee USB Radio Stick */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/mct_u232.c b/drivers/usb/serial/mct_u232.c</span>
<span class="p_header">index ed8694b1a0f4..8901b8d1bbe0 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mct_u232.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mct_u232.c</span>
<span class="p_chunk">@@ -449,7 +449,7 @@</span> <span class="p_context"> static int mct_u232_startup(struct usb_serial *serial)</span>
 
 	/* check first to simplify error handling */
 	if (!serial-&gt;port[1] || !serial-&gt;port[1]-&gt;interrupt_in_urb) {
<span class="p_del">-		dev_err(&amp;port-&gt;dev, &quot;expected endpoint missing\n&quot;);</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;dev-&gt;dev, &quot;expected endpoint missing\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c</span>
<span class="p_header">index ffc4193e9505..36f18b55f2c9 100644</span>
<span class="p_header">--- a/drivers/usb/storage/isd200.c</span>
<span class="p_header">+++ b/drivers/usb/storage/isd200.c</span>
<span class="p_chunk">@@ -1522,8 +1522,11 @@</span> <span class="p_context"> static void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us)</span>
 
 	/* Make sure driver was initialized */
 
<span class="p_del">-	if (us-&gt;extra == NULL)</span>
<span class="p_add">+	if (us-&gt;extra == NULL) {</span>
 		US_DEBUGP(&quot;ERROR Driver not initialized\n&quot;);
<span class="p_add">+		srb-&gt;result = DID_ERROR &lt;&lt; 16;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 	scsi_set_resid(srb, 0);
 	/* scsi_bufflen might change in protocol translation to ata */
<span class="p_header">diff --git a/fs/bio.c b/fs/bio.c</span>
<span class="p_header">index 55b51881e751..1fa6b825240d 100644</span>
<span class="p_header">--- a/fs/bio.c</span>
<span class="p_header">+++ b/fs/bio.c</span>
<span class="p_chunk">@@ -1027,6 +1027,7 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 		offset = uaddr &amp; ~PAGE_MASK;
 		for (j = cur_page; j &lt; page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
<span class="p_add">+			unsigned short prev_bi_vcnt = bio-&gt;bi_vcnt;</span>
 
 			if (len &lt;= 0)
 				break;
<span class="p_chunk">@@ -1041,6 +1042,13 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 					    bytes)
 				break;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * check if vector was merged with previous</span>
<span class="p_add">+			 * drop page reference if needed</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (bio-&gt;bi_vcnt == prev_bi_vcnt)</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+</span>
 			len -= bytes;
 			offset = 0;
 		}
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index 48db02de0330..c6b8cbcb8e9f 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -3909,13 +3909,12 @@</span> <span class="p_context"> CIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,</span>
 	int rc = 0;
 	int bytes_returned = 0;
 	SET_SEC_DESC_REQ *pSMB = NULL;
<span class="p_del">-	NTRANSACT_RSP *pSMBr = NULL;</span>
<span class="p_add">+	void *pSMBr;</span>
 
 setCifsAclRetry:
<span class="p_del">-	rc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &amp;pSMB,</span>
<span class="p_del">-			(void **) &amp;pSMBr);</span>
<span class="p_add">+	rc = smb_init(SMB_COM_NT_TRANSACT, 19, tcon, (void **) &amp;pSMB, &amp;pSMBr);</span>
 	if (rc)
<span class="p_del">-			return (rc);</span>
<span class="p_add">+		return rc;</span>
 
 	pSMB-&gt;MaxSetupCount = 0;
 	pSMB-&gt;Reserved = 0;
<span class="p_chunk">@@ -3943,9 +3942,8 @@</span> <span class="p_context"> CIFSSMBSetCIFSACL(const int xid, struct cifs_tcon *tcon, __u16 fid,</span>
 	pSMB-&gt;AclFlags = cpu_to_le32(aclflag);
 
 	if (pntsd &amp;&amp; acllen) {
<span class="p_del">-		memcpy((char *) &amp;pSMBr-&gt;hdr.Protocol + data_offset,</span>
<span class="p_del">-			(char *) pntsd,</span>
<span class="p_del">-			acllen);</span>
<span class="p_add">+		memcpy((char *)pSMBr + offsetof(struct smb_hdr, Protocol) +</span>
<span class="p_add">+				data_offset, pntsd, acllen);</span>
 		inc_rfc1001_len(pSMB, byte_count + data_count);
 	} else
 		inc_rfc1001_len(pSMB, byte_count);
<span class="p_chunk">@@ -5724,7 +5722,8 @@</span> <span class="p_context"> CIFSSMBSetFileInfo(const int xid, struct cifs_tcon *tcon,</span>
 	param_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;
 	offset = param_offset + params;
 
<span class="p_del">-	data_offset = (char *) (&amp;pSMB-&gt;hdr.Protocol) + offset;</span>
<span class="p_add">+	data_offset = (char *)pSMB +</span>
<span class="p_add">+			offsetof(struct smb_hdr, Protocol) + offset;</span>
 
 	count = sizeof(FILE_BASIC_INFO);
 	pSMB-&gt;MaxParameterCount = cpu_to_le16(2);
<span class="p_chunk">@@ -5993,7 +5992,7 @@</span> <span class="p_context"> CIFSSMBUnixSetFileInfo(const int xid, struct cifs_tcon *tcon,</span>
 		       u16 fid, u32 pid_of_opener)
 {
 	struct smb_com_transaction2_sfi_req *pSMB  = NULL;
<span class="p_del">-	FILE_UNIX_BASIC_INFO *data_offset;</span>
<span class="p_add">+	char *data_offset;</span>
 	int rc = 0;
 	u16 params, param_offset, offset, byte_count, count;
 
<span class="p_chunk">@@ -6015,8 +6014,9 @@</span> <span class="p_context"> CIFSSMBUnixSetFileInfo(const int xid, struct cifs_tcon *tcon,</span>
 	param_offset = offsetof(struct smb_com_transaction2_sfi_req, Fid) - 4;
 	offset = param_offset + params;
 
<span class="p_del">-	data_offset = (FILE_UNIX_BASIC_INFO *)</span>
<span class="p_del">-				((char *)(&amp;pSMB-&gt;hdr.Protocol) + offset);</span>
<span class="p_add">+	data_offset = (char *)pSMB +</span>
<span class="p_add">+			offsetof(struct smb_hdr, Protocol) + offset;</span>
<span class="p_add">+</span>
 	count = sizeof(FILE_UNIX_BASIC_INFO);
 
 	pSMB-&gt;MaxParameterCount = cpu_to_le16(2);
<span class="p_chunk">@@ -6038,7 +6038,7 @@</span> <span class="p_context"> CIFSSMBUnixSetFileInfo(const int xid, struct cifs_tcon *tcon,</span>
 	inc_rfc1001_len(pSMB, byte_count);
 	pSMB-&gt;ByteCount = cpu_to_le16(byte_count);
 
<span class="p_del">-	cifs_fill_unix_set_info(data_offset, args);</span>
<span class="p_add">+	cifs_fill_unix_set_info((FILE_UNIX_BASIC_INFO *)data_offset, args);</span>
 
 	rc = SendReceiveNoRsp(xid, tcon-&gt;ses, (struct smb_hdr *) pSMB, 0);
 	if (rc)
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 6937e7c19ee3..22758b1c1426 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -520,6 +520,14 @@</span> <span class="p_context"> cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,</span>
 
 	oplock = pTcon-&gt;ses-&gt;server-&gt;oplocks ? REQ_OPLOCK : 0;
 
<span class="p_add">+	/* Don&#39;t allow path components longer than the server max. */</span>
<span class="p_add">+	if (unlikely(pTcon-&gt;fsAttrInfo.MaxPathNameComponentLength &amp;&amp;</span>
<span class="p_add">+		     direntry-&gt;d_name.len &gt;</span>
<span class="p_add">+		     le32_to_cpu(pTcon-&gt;fsAttrInfo.MaxPathNameComponentLength))) {</span>
<span class="p_add">+		rc = -ENAMETOOLONG;</span>
<span class="p_add">+		goto lookup_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Don&#39;t allow the separator character in a path component.
 	 * The VFS will not allow &quot;/&quot;, but &quot;\&quot; is allowed by posix.
<span class="p_header">diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c</span>
<span class="p_header">index 5ce56e7598b1..848b3031c908 100644</span>
<span class="p_header">--- a/fs/ecryptfs/keystore.c</span>
<span class="p_header">+++ b/fs/ecryptfs/keystore.c</span>
<span class="p_chunk">@@ -1152,7 +1152,7 @@</span> <span class="p_context"> decrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,</span>
 	struct ecryptfs_message *msg = NULL;
 	char *auth_tok_sig;
 	char *payload = NULL;
<span class="p_del">-	size_t payload_len;</span>
<span class="p_add">+	size_t payload_len = 0;</span>
 	int rc;
 
 	rc = ecryptfs_get_auth_tok_sig(&amp;auth_tok_sig, auth_tok);
<span class="p_header">diff --git a/fs/eventpoll.c b/fs/eventpoll.c</span>
<span class="p_header">index 451b9b839c74..7903ddb45bf9 100644</span>
<span class="p_header">--- a/fs/eventpoll.c</span>
<span class="p_header">+++ b/fs/eventpoll.c</span>
<span class="p_chunk">@@ -477,8 +477,14 @@</span> <span class="p_context"> static void ep_remove_wait_queue(struct eppoll_entry *pwq)</span>
 	wait_queue_head_t *whead;
 
 	rcu_read_lock();
<span class="p_del">-	/* If it is cleared by POLLFREE, it should be rcu-safe */</span>
<span class="p_del">-	whead = rcu_dereference(pwq-&gt;whead);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If it is cleared by POLLFREE, it should be rcu-safe.</span>
<span class="p_add">+	 * If we read NULL we need a barrier paired with</span>
<span class="p_add">+	 * smp_store_release() in ep_poll_callback(), otherwise</span>
<span class="p_add">+	 * we rely on whead-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	whead = ACCESS_ONCE(pwq-&gt;whead);</span>
<span class="p_add">+	smp_mb();</span>
 	if (whead)
 		remove_wait_queue(whead, &amp;pwq-&gt;wait);
 	rcu_read_unlock();
<span class="p_chunk">@@ -859,17 +865,6 @@</span> <span class="p_context"> static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k</span>
 	struct epitem *epi = ep_item_from_wait(wait);
 	struct eventpoll *ep = epi-&gt;ep;
 
<span class="p_del">-	if ((unsigned long)key &amp; POLLFREE) {</span>
<span class="p_del">-		ep_pwq_from_wait(wait)-&gt;whead = NULL;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * whead = NULL above can race with ep_remove_wait_queue()</span>
<span class="p_del">-		 * which can do another remove_wait_queue() after us, so we</span>
<span class="p_del">-		 * can&#39;t use __remove_wait_queue(). whead-&gt;lock is held by</span>
<span class="p_del">-		 * the caller.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		list_del_init(&amp;wait-&gt;task_list);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;ep-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -924,6 +919,23 @@</span> <span class="p_context"> static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k</span>
 	if (pwake)
 		ep_poll_safewake(&amp;ep-&gt;poll_wait);
 
<span class="p_add">+	if ((unsigned long)key &amp; POLLFREE) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we race with ep_remove_wait_queue() it can miss</span>
<span class="p_add">+		 * -&gt;whead = NULL and do another remove_wait_queue() after</span>
<span class="p_add">+		 * us, so we can&#39;t use __remove_wait_queue().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_del_init(&amp;wait-&gt;task_list);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * -&gt;whead != NULL protects us from the race with ep_free()</span>
<span class="p_add">+		 * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span>
<span class="p_add">+		 * held by the caller. Once we nullify it, nothing protects</span>
<span class="p_add">+		 * ep/epi or even wait.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+		ACCESS_ONCE(ep_pwq_from_wait(wait)-&gt;whead) = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/fuse/cuse.c b/fs/fuse/cuse.c</span>
<span class="p_header">index 3426521f3205..406352c563e1 100644</span>
<span class="p_header">--- a/fs/fuse/cuse.c</span>
<span class="p_header">+++ b/fs/fuse/cuse.c</span>
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> static int cuse_parse_one(char **pp, char *end, char **keyp, char **valp)</span>
 static int cuse_parse_devinfo(char *p, size_t len, struct cuse_devinfo *devinfo)
 {
 	char *end = p + len;
<span class="p_del">-	char *key, *val;</span>
<span class="p_add">+	char *uninitialized_var(key), *uninitialized_var(val);</span>
 	int rc;
 
 	while (true) {
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 1f78f91dedc4..7be47190c3fd 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)</span>
 {
 	struct fuse_file *ff;
 
<span class="p_del">-	ff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);</span>
<span class="p_add">+	ff = kzalloc(sizeof(struct fuse_file), GFP_KERNEL);</span>
 	if (unlikely(!ff))
 		return NULL;
 
<span class="p_header">diff --git a/fs/nfs/client.c b/fs/nfs/client.c</span>
<span class="p_header">index d03a40019f9f..4ba011d7da35 100644</span>
<span class="p_header">--- a/fs/nfs/client.c</span>
<span class="p_header">+++ b/fs/nfs/client.c</span>
<span class="p_chunk">@@ -1018,6 +1018,7 @@</span> <span class="p_context"> static void nfs_server_copy_userdata(struct nfs_server *target, struct nfs_serve</span>
 	target-&gt;acdirmax = source-&gt;acdirmax;
 	target-&gt;caps = source-&gt;caps;
 	target-&gt;options = source-&gt;options;
<span class="p_add">+	target-&gt;port = source-&gt;port;</span>
 }
 
 static void nfs_server_insert_lists(struct nfs_server *server)
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index 090d8ce25bd1..250db0862ca6 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -1797,7 +1797,7 @@</span> <span class="p_context"> int nilfs_btree_convert_and_insert(struct nilfs_bmap *btree,</span>
 				   __u64 key, __u64 ptr,
 				   const __u64 *keys, const __u64 *ptrs, int n)
 {
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	union nilfs_bmap_ptr_req dreq, nreq, *di, *ni;
 	struct nilfs_bmap_stats stats;
 	int ret;
<span class="p_header">diff --git a/fs/nilfs2/recovery.c b/fs/nilfs2/recovery.c</span>
<span class="p_header">index a604ac0331b2..7fe6773320d0 100644</span>
<span class="p_header">--- a/fs/nilfs2/recovery.c</span>
<span class="p_header">+++ b/fs/nilfs2/recovery.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> static int nilfs_do_roll_forward(struct the_nilfs *nilfs,</span>
 				 struct nilfs_recovery_info *ri)
 {
 	struct buffer_head *bh_sum = NULL;
<span class="p_del">-	struct nilfs_segment_summary *sum;</span>
<span class="p_add">+	struct nilfs_segment_summary *sum = NULL;</span>
 	sector_t pseg_start;
 	sector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */
 	unsigned long nsalvaged_blocks = 0;
<span class="p_chunk">@@ -813,7 +813,7 @@</span> <span class="p_context"> int nilfs_search_super_root(struct the_nilfs *nilfs,</span>
 			    struct nilfs_recovery_info *ri)
 {
 	struct buffer_head *bh_sum = NULL;
<span class="p_del">-	struct nilfs_segment_summary *sum;</span>
<span class="p_add">+	struct nilfs_segment_summary *sum = NULL;</span>
 	sector_t pseg_start, pseg_end, sr_pseg_start = 0;
 	sector_t seg_start, seg_end; /* range of full segment (block number) */
 	sector_t b, end;
<span class="p_header">diff --git a/fs/nilfs2/super.c b/fs/nilfs2/super.c</span>
<span class="p_header">index 97bfbddd9fc8..8715fbc5ff8c 100644</span>
<span class="p_header">--- a/fs/nilfs2/super.c</span>
<span class="p_header">+++ b/fs/nilfs2/super.c</span>
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)</span>
 	struct nilfs_super_block *nsbp;
 	sector_t blocknr, newblocknr;
 	unsigned long offset;
<span class="p_del">-	int sb2i = -1;  /* array index of the secondary superblock */</span>
<span class="p_add">+	int sb2i;  /* array index of the secondary superblock */</span>
 	int ret = 0;
 
 	/* nilfs-&gt;ns_sem must be locked by the caller. */
<span class="p_chunk">@@ -371,6 +371,9 @@</span> <span class="p_context"> static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)</span>
 	} else if (nilfs-&gt;ns_sbh[0]-&gt;b_blocknr &gt; nilfs-&gt;ns_first_data_block) {
 		sb2i = 0;
 		blocknr = nilfs-&gt;ns_sbh[0]-&gt;b_blocknr;
<span class="p_add">+	} else {</span>
<span class="p_add">+		sb2i = -1;</span>
<span class="p_add">+		blocknr = 0;</span>
 	}
 	if (sb2i &gt;= 0 &amp;&amp; (u64)blocknr &lt;&lt; nilfs-&gt;ns_blocksize_bits == sb2off)
 		goto out;  /* super block location is unchanged */
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 7e6e1f826358..06a5027fb2ad 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -246,19 +246,6 @@</span> <span class="p_context"> static int ocfs2_set_acl(handle_t *handle,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			umode_t mode;</span>
<span class="p_del">-			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				return ret;</span>
<span class="p_del">-			else {</span>
<span class="p_del">-				ret = ocfs2_acl_set_mode(inode, di_bh,</span>
<span class="p_del">-							 handle, mode);</span>
<span class="p_del">-				if (ret)</span>
<span class="p_del">-					return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;
<span class="p_chunk">@@ -483,6 +470,17 @@</span> <span class="p_context"> static int ocfs2_xattr_set_acl(struct dentry *dentry, const char *name,</span>
 	} else
 		acl = NULL;
 
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto cleanup;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = ocfs2_acl_set_mode(inode, NULL, NULL, mode);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto cleanup;</span>
<span class="p_add">+	}</span>
 	ret = ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);
 
 cleanup:
<span class="p_header">diff --git a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c</span>
<span class="p_header">index 169380e66057..24675e3e562b 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ialloc.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ialloc.c</span>
<span class="p_chunk">@@ -894,13 +894,13 @@</span> <span class="p_context"> xfs_dialloc(</span>
 
 			/* free inodes to the left? */
 			if (useleft &amp;&amp; trec.ir_freecount) {
<span class="p_del">-				rec = trec;</span>
 				xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
 				cur = tcur;
 
 				pag-&gt;pagl_leftrec = trec.ir_startino;
 				pag-&gt;pagl_rightrec = rec.ir_startino;
 				pag-&gt;pagl_pagino = pagino;
<span class="p_add">+				rec = trec;</span>
 				goto alloc_inode;
 			}
 
<span class="p_header">diff --git a/include/asm-generic/topology.h b/include/asm-generic/topology.h</span>
<span class="p_header">index fc824e2828f3..5d2add1a6c96 100644</span>
<span class="p_header">--- a/include/asm-generic/topology.h</span>
<span class="p_header">+++ b/include/asm-generic/topology.h</span>
<span class="p_chunk">@@ -48,7 +48,11 @@</span> <span class="p_context"></span>
 #define parent_node(node)	((void)(node),0)
 #endif
 #ifndef cpumask_of_node
<span class="p_del">-#define cpumask_of_node(node)	((void)node, cpu_online_mask)</span>
<span class="p_add">+  #ifdef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="p_add">+    #define cpumask_of_node(node)	((node) == 0 ? cpu_online_mask : cpu_none_mask)</span>
<span class="p_add">+  #else</span>
<span class="p_add">+    #define cpumask_of_node(node)	((void)node, cpu_online_mask)</span>
<span class="p_add">+  #endif</span>
 #endif
 #ifndef pcibus_to_node
 #define pcibus_to_node(bus)	((void)(bus), -1)
<span class="p_header">diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h</span>
<span class="p_header">index 213a8700144b..45bf2ddf43e8 100644</span>
<span class="p_header">--- a/include/linux/device-mapper.h</span>
<span class="p_header">+++ b/include/linux/device-mapper.h</span>
<span class="p_chunk">@@ -398,56 +398,32 @@</span> <span class="p_context"> void *dm_vcalloc(unsigned long nmemb, unsigned long elem_size);</span>
  *---------------------------------------------------------------*/
 #define DM_NAME &quot;device-mapper&quot;
 
<span class="p_del">-#ifdef CONFIG_PRINTK</span>
<span class="p_del">-extern struct ratelimit_state dm_ratelimit_state;</span>
<span class="p_del">-</span>
<span class="p_del">-#define dm_ratelimit()	__ratelimit(&amp;dm_ratelimit_state)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define dm_ratelimit()	0</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMCRIT(f, arg...) \</span>
<span class="p_del">-	printk(KERN_CRIT DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMERR(f, arg...) \</span>
<span class="p_del">-	printk(KERN_ERR DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMERR_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_ERR DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; \</span>
<span class="p_del">-			       f &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMWARN(f, arg...) \</span>
<span class="p_del">-	printk(KERN_WARNING DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMWARN_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_WARNING DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; \</span>
<span class="p_del">-			       f &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMINFO(f, arg...) \</span>
<span class="p_del">-	printk(KERN_INFO DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMINFO_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_INFO DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f \</span>
<span class="p_del">-			       &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_add">+#define DM_RATELIMIT(pr_func, fmt, ...)					\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,	\</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_BURST);		\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	if (__ratelimit(&amp;rs))						\</span>
<span class="p_add">+		pr_func(DM_FMT(fmt), ##__VA_ARGS__);			\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DM_FMT(fmt) DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; fmt &quot;\n&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DMCRIT(fmt, ...) pr_crit(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DMERR(fmt, ...) pr_err(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMERR_LIMIT(fmt, ...) DM_RATELIMIT(pr_err, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMWARN(fmt, ...) pr_warn(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMWARN_LIMIT(fmt, ...) DM_RATELIMIT(pr_warn, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMINFO(fmt, ...) pr_info(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMINFO_LIMIT(fmt, ...) DM_RATELIMIT(pr_info, fmt, ##__VA_ARGS__)</span>
 
 #ifdef CONFIG_DM_DEBUG
<span class="p_del">-#  define DMDEBUG(f, arg...) \</span>
<span class="p_del">-	printk(KERN_DEBUG DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot; DEBUG: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#  define DMDEBUG_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_DEBUG DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f \</span>
<span class="p_del">-			       &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_add">+#define DMDEBUG(fmt, ...) printk(KERN_DEBUG DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMDEBUG_LIMIT(fmt, ...) DM_RATELIMIT(pr_debug, fmt, ##__VA_ARGS__)</span>
 #else
<span class="p_del">-#  define DMDEBUG(f, arg...) do {} while (0)</span>
<span class="p_del">-#  define DMDEBUG_LIMIT(f, arg...) do {} while (0)</span>
<span class="p_add">+#define DMDEBUG(fmt, ...) no_printk(fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMDEBUG_LIMIT(fmt, ...) no_printk(fmt, ##__VA_ARGS__)</span>
 #endif
 
 #define DMEMIT(x...) sz += ((sz &gt;= maxlen) ? \
<span class="p_header">diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h</span>
<span class="p_header">index 84b0b1848f17..081f038d0f9c 100644</span>
<span class="p_header">--- a/include/linux/mlx4/device.h</span>
<span class="p_header">+++ b/include/linux/mlx4/device.h</span>
<span class="p_chunk">@@ -287,6 +287,7 @@</span> <span class="p_context"> struct mlx4_caps {</span>
 	enum mlx4_port_type	possible_type[MLX4_MAX_PORTS + 1];
 	u32			max_counters;
 	u8			ext_port_cap[MLX4_MAX_PORTS + 1];
<span class="p_add">+	bool			wol_port[MLX4_MAX_PORTS + 1];</span>
 };
 
 struct mlx4_buf_list {
<span class="p_header">diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h</span>
<span class="p_header">index 3887901bf48c..ec69d760c49d 100644</span>
<span class="p_header">--- a/include/linux/mtd/map.h</span>
<span class="p_header">+++ b/include/linux/mtd/map.h</span>
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word</span>
 
 static inline map_word map_word_load(struct map_info *map, const void *ptr)
 {
<span class="p_del">-	map_word r;</span>
<span class="p_add">+	map_word r = {{0} };</span>
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = *(unsigned char *)ptr;
<span class="p_header">diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h</span>
<span class="p_header">index 8d5b91ec2b19..0aa2c4f528af 100644</span>
<span class="p_header">--- a/include/linux/perf_event.h</span>
<span class="p_header">+++ b/include/linux/perf_event.h</span>
<span class="p_chunk">@@ -859,11 +859,6 @@</span> <span class="p_context"> struct perf_event {</span>
 #endif /* CONFIG_PERF_EVENTS */
 };
 
<span class="p_del">-enum perf_event_context_type {</span>
<span class="p_del">-	task_context,</span>
<span class="p_del">-	cpu_context,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /**
  * struct perf_event_context - event context structure
  *
<span class="p_chunk">@@ -871,7 +866,6 @@</span> <span class="p_context"> enum perf_event_context_type {</span>
  */
 struct perf_event_context {
 	struct pmu			*pmu;
<span class="p_del">-	enum perf_event_context_type	type;</span>
 	/*
 	 * Protect the states of the events in the list,
 	 * nr_active, and the list:
<span class="p_header">diff --git a/include/linux/usb/ch9.h b/include/linux/usb/ch9.h</span>
<span class="p_header">index 3b6f628880f8..046b1f4382df 100644</span>
<span class="p_header">--- a/include/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -686,6 +686,7 @@</span> <span class="p_context"> struct usb_interface_assoc_descriptor {</span>
 	__u8  iFunction;
 } __attribute__ ((packed));
 
<span class="p_add">+#define USB_DT_INTERFACE_ASSOCIATION_SIZE	8</span>
 
 /*-------------------------------------------------------------------------*/
 
<span class="p_header">diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h</span>
<span class="p_header">index 390735885629..852f2ce99456 100644</span>
<span class="p_header">--- a/include/net/ip6_fib.h</span>
<span class="p_header">+++ b/include/net/ip6_fib.h</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> struct fib6_node {</span>
 	__u16			fn_flags;
 	__u32			fn_sernum;
 	struct rt6_info		*rr_ptr;
<span class="p_add">+	struct rcu_head		rcu;</span>
 };
 
 #ifndef CONFIG_IPV6_SUBTREES
<span class="p_chunk">@@ -95,7 +96,7 @@</span> <span class="p_context"> struct rt6_info {</span>
 	 * the same cache line.
 	 */
 	struct fib6_table		*rt6i_table;
<span class="p_del">-	struct fib6_node		*rt6i_node;</span>
<span class="p_add">+	struct fib6_node __rcu		*rt6i_node;</span>
 
 	struct in6_addr			rt6i_gateway;
 
<span class="p_chunk">@@ -126,6 +127,38 @@</span> <span class="p_context"> static inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)</span>
 	return ((struct rt6_info *)dst)-&gt;rt6i_idev;
 }
 
<span class="p_add">+/* Function to safely get fn-&gt;sernum for passed in rt</span>
<span class="p_add">+ * and store result in passed in cookie.</span>
<span class="p_add">+ * Return true if we can get cookie safely</span>
<span class="p_add">+ * Return false if not</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool rt6_get_cookie_safe(const struct rt6_info *rt,</span>
<span class="p_add">+				       u32 *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fib6_node *fn;</span>
<span class="p_add">+	bool status = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fn) {</span>
<span class="p_add">+		*cookie = fn-&gt;fn_sernum;</span>
<span class="p_add">+		status = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u32 rt6_get_cookie(const struct rt6_info *rt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 cookie = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	rt6_get_cookie_safe(rt, &amp;cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+	return cookie;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct fib6_walker_t {
 	struct list_head lh;
 	struct fib6_node *root, *node;
<span class="p_header">diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h</span>
<span class="p_header">index 4913dacd1333..67bfec19b99a 100644</span>
<span class="p_header">--- a/include/net/ip6_route.h</span>
<span class="p_header">+++ b/include/net/ip6_route.h</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static inline void __ip6_dst_store(struct sock *sk, struct dst_entry *dst,</span>
 #ifdef CONFIG_IPV6_SUBTREES
 	np-&gt;saddr_cache = saddr;
 #endif
<span class="p_del">-	np-&gt;dst_cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+	np-&gt;dst_cookie = rt6_get_cookie(rt);</span>
 }
 
 static inline void ip6_dst_store(struct sock *sk, struct dst_entry *dst,
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index e0f1c916b9ed..505eca3ce49a 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -538,6 +538,8 @@</span> <span class="p_context"> _sctp_walk_params((pos), (chunk), ntohs((chunk)-&gt;chunk_hdr.length), member)</span>
 
 #define _sctp_walk_params(pos, chunk, end, member)\
 for (pos.v = chunk-&gt;member;\
<span class="p_add">+     (pos.v + offsetof(struct sctp_paramhdr, length) + sizeof(pos.p-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk + end) &amp;&amp;\</span>
      pos.v &lt;= (void *)chunk + end - ntohs(pos.p-&gt;length) &amp;&amp;\
      ntohs(pos.p-&gt;length) &gt;= sizeof(sctp_paramhdr_t);\
      pos.v += WORD_ROUND(ntohs(pos.p-&gt;length)))
<span class="p_chunk">@@ -548,6 +550,8 @@</span> <span class="p_context"> _sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)-&gt;length))</span>
 #define _sctp_walk_errors(err, chunk_hdr, end)\
 for (err = (sctp_errhdr_t *)((void *)chunk_hdr + \
 	    sizeof(sctp_chunkhdr_t));\
<span class="p_add">+     ((void *)err + offsetof(sctp_errhdr_t, length) + sizeof(err-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk_hdr + end) &amp;&amp;\</span>
      (void *)err &lt;= (void *)chunk_hdr + end - ntohs(err-&gt;length) &amp;&amp;\
      ntohs(err-&gt;length) &gt;= sizeof(sctp_errhdr_t); \
      err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err-&gt;length))))
<span class="p_header">diff --git a/include/scsi/libsas.h b/include/scsi/libsas.h</span>
<span class="p_header">index 1e100c63d542..9cc517ad4159 100644</span>
<span class="p_header">--- a/include/scsi/libsas.h</span>
<span class="p_header">+++ b/include/scsi/libsas.h</span>
<span class="p_chunk">@@ -449,7 +449,10 @@</span> <span class="p_context"> enum service_response {</span>
 };
 
 enum exec_status {
<span class="p_del">-	/* The SAM_STAT_.. codes fit in the lower 6 bits */</span>
<span class="p_add">+	/* The SAM_STAT_.. codes fit in the lower 6 bits, alias some of</span>
<span class="p_add">+	 * them here to silence &#39;case value not in enumerated type&#39; warnings</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__SAM_STAT_CHECK_CONDITION = SAM_STAT_CHECK_CONDITION,</span>
 
 	SAS_DEV_NO_RESPONSE = 0x80,
 	SAS_DATA_UNDERRUN,
<span class="p_header">diff --git a/kernel/audit_watch.c b/kernel/audit_watch.c</span>
<span class="p_header">index e683869365d9..4b4b9d5506f5 100644</span>
<span class="p_header">--- a/kernel/audit_watch.c</span>
<span class="p_header">+++ b/kernel/audit_watch.c</span>
<span class="p_chunk">@@ -471,13 +471,15 @@</span> <span class="p_context"> void audit_remove_watch_rule(struct audit_krule *krule)</span>
 	list_del(&amp;krule-&gt;rlist);
 
 	if (list_empty(&amp;watch-&gt;rules)) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * audit_remove_watch() drops our reference to &#39;parent&#39; which</span>
<span class="p_add">+		 * can get freed. Grab our own reference to be safe.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		audit_get_parent(parent);</span>
 		audit_remove_watch(watch);
<span class="p_del">-</span>
<span class="p_del">-		if (list_empty(&amp;parent-&gt;watches)) {</span>
<span class="p_del">-			audit_get_parent(parent);</span>
<span class="p_add">+		if (list_empty(&amp;parent-&gt;watches))</span>
 			fsnotify_destroy_mark(&amp;parent-&gt;mark);
<span class="p_del">-			audit_put_parent(parent);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		audit_put_parent(parent);</span>
 	}
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 8b37d9553146..103b563f6540 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3277,50 +3277,77 @@</span> <span class="p_context"> u64 perf_event_read_value(struct perf_event *event, u64 *enabled, u64 *running)</span>
 }
 EXPORT_SYMBOL_GPL(perf_event_read_value);
 
<span class="p_del">-static int perf_event_read_group(struct perf_event *event,</span>
<span class="p_del">-				   u64 read_format, char __user *buf)</span>
<span class="p_add">+static void __perf_read_group_add(struct perf_event *leader,</span>
<span class="p_add">+					u64 read_format, u64 *values)</span>
 {
<span class="p_del">-	struct perf_event *leader = event-&gt;group_leader, *sub;</span>
 	struct perf_event_context *ctx = leader-&gt;ctx;
<span class="p_del">-	int n = 0, size = 0, ret;</span>
<span class="p_add">+	struct perf_event *sub;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int n = 1; /* skip @nr */</span>
 	u64 count, enabled, running;
<span class="p_del">-	u64 values[5];</span>
<span class="p_del">-</span>
<span class="p_del">-	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
 
 	count = perf_event_read_value(leader, &amp;enabled, &amp;running);
 
<span class="p_del">-	values[n++] = 1 + leader-&gt;nr_siblings;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Since we co-schedule groups, {enabled,running} times of siblings</span>
<span class="p_add">+	 * will be identical to those of the leader, so we only publish one</span>
<span class="p_add">+	 * set.</span>
<span class="p_add">+	 */</span>
 	if (read_format &amp; PERF_FORMAT_TOTAL_TIME_ENABLED)
 		values[n++] = enabled;
 	if (read_format &amp; PERF_FORMAT_TOTAL_TIME_RUNNING)
 		values[n++] = running;
<span class="p_del">-	values[n++] = count;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write {count,id} tuples for every sibling.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	values[n++] += count;</span>
 	if (read_format &amp; PERF_FORMAT_ID)
 		values[n++] = primary_event_id(leader);
 
<span class="p_del">-	size = n * sizeof(u64);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_to_user(buf, values, size))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = size;</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;ctx-&gt;lock, flags);</span>
 
 	list_for_each_entry(sub, &amp;leader-&gt;sibling_list, group_entry) {
<span class="p_del">-		n = 0;</span>
<span class="p_del">-</span>
 		values[n++] = perf_event_read_value(sub, &amp;enabled, &amp;running);
 		if (read_format &amp; PERF_FORMAT_ID)
 			values[n++] = primary_event_id(sub);
<span class="p_add">+	}</span>
 
<span class="p_del">-		size = n * sizeof(u64);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;ctx-&gt;lock, flags);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-		if (copy_to_user(buf + ret, values, size)) {</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		}</span>
<span class="p_add">+static int perf_event_read_group(struct perf_event *event,</span>
<span class="p_add">+				   u64 read_format, char __user *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event *leader = event-&gt;group_leader, *child;</span>
<span class="p_add">+	struct perf_event_context *ctx = leader-&gt;ctx;</span>
<span class="p_add">+	int ret = event-&gt;read_size;</span>
<span class="p_add">+	u64 *values;</span>
 
<span class="p_del">-		ret += size;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	values = kzalloc(event-&gt;read_size, GFP_KERNEL);</span>
<span class="p_add">+	if (!values)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	values[0] = 1 + leader-&gt;nr_siblings;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * By locking the child_mutex of the leader we effectively</span>
<span class="p_add">+	 * lock the child list of all siblings.. XXX explain how.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;leader-&gt;child_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	__perf_read_group_add(leader, read_format, values);</span>
<span class="p_add">+	list_for_each_entry(child, &amp;leader-&gt;child_list, child_list)</span>
<span class="p_add">+		__perf_read_group_add(child, read_format, values);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;leader-&gt;child_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_to_user(buf, values, event-&gt;read_size))</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(values);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -6089,7 +6116,6 @@</span> <span class="p_context"> int perf_pmu_register(struct pmu *pmu, char *name, int type)</span>
 		__perf_event_init_context(&amp;cpuctx-&gt;ctx);
 		lockdep_set_class(&amp;cpuctx-&gt;ctx.mutex, &amp;cpuctx_mutex);
 		lockdep_set_class(&amp;cpuctx-&gt;ctx.lock, &amp;cpuctx_lock);
<span class="p_del">-		cpuctx-&gt;ctx.type = cpu_context;</span>
 		cpuctx-&gt;ctx.pmu = pmu;
 		cpuctx-&gt;jiffies_interval = 1;
 		INIT_LIST_HEAD(&amp;cpuctx-&gt;rotation_list);
<span class="p_chunk">@@ -6666,16 +6692,27 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 		if (group_leader-&gt;group_leader != group_leader)
 			goto err_context;
 		/*
<span class="p_del">-		 * Do not allow to attach to a group in a different</span>
<span class="p_del">-		 * task or CPU context:</span>
<span class="p_add">+		 * Make sure we&#39;re both events for the same CPU;</span>
<span class="p_add">+		 * grouping events for different CPUs is broken; since</span>
<span class="p_add">+		 * you can never concurrently schedule them anyhow.</span>
 		 */
<span class="p_del">-		if (move_group) {</span>
<span class="p_del">-			if (group_leader-&gt;ctx-&gt;type != ctx-&gt;type)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			if (group_leader-&gt;ctx != ctx)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (group_leader-&gt;cpu != event-&gt;cpu)</span>
<span class="p_add">+			goto err_context;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure we&#39;re both on the same task, or both</span>
<span class="p_add">+		 * per-CPU events.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (group_leader-&gt;ctx-&gt;task != ctx-&gt;task)</span>
<span class="p_add">+			goto err_context;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not allow to attach to a group in a different task</span>
<span class="p_add">+		 * or CPU context. If we&#39;re moving SW events, we&#39;ll fix</span>
<span class="p_add">+		 * this up later, so allow that.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!move_group &amp;&amp; group_leader-&gt;ctx != ctx)</span>
<span class="p_add">+			goto err_context;</span>
 
 		/*
 		 * Only a group leader can be exclusive or pinned
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index d6e6cafdb2c9..94ef2af4a76b 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1009,7 +1009,6 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct mm_struct *mm,</span>
 	if (flags &amp; FOLL_GET)
 		get_page_foll(page);
 
<span class="p_del">-out:</span>
 	return page;
 }
 
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index c8e4ebe5f78d..1ea67ad062db 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -885,11 +885,6 @@</span> <span class="p_context"> static long do_get_mempolicy(int *policy, nodemask_t *nmask,</span>
 		*policy |= (pol-&gt;flags &amp; MPOL_MODE_FLAGS);
 	}
 
<span class="p_del">-	if (vma) {</span>
<span class="p_del">-		up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="p_del">-		vma = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 62a7fa23d328..ba0fa4bc16f3 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -57,6 +57,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/ftrace_event.h&gt;
 #include &lt;linux/memcontrol.h&gt;
 #include &lt;linux/prefetch.h&gt;
<span class="p_add">+#include &lt;linux/nmi.h&gt;</span>
 
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/div64.h&gt;
<span class="p_chunk">@@ -1124,9 +1125,14 @@</span> <span class="p_context"> void drain_all_pages(void)</span>
 
 #ifdef CONFIG_HIBERNATION
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Touch the watchdog for every WD_PAGE_COUNT pages.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WD_PAGE_COUNT	(128*1024)</span>
<span class="p_add">+</span>
 void mark_free_pages(struct zone *zone)
 {
<span class="p_del">-	unsigned long pfn, max_zone_pfn;</span>
<span class="p_add">+	unsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;</span>
 	unsigned long flags;
 	int order, t;
 	struct list_head *curr;
<span class="p_chunk">@@ -1141,6 +1147,11 @@</span> <span class="p_context"> void mark_free_pages(struct zone *zone)</span>
 		if (pfn_valid(pfn)) {
 			struct page *page = pfn_to_page(pfn);
 
<span class="p_add">+			if (!--page_count) {</span>
<span class="p_add">+				touch_nmi_watchdog();</span>
<span class="p_add">+				page_count = WD_PAGE_COUNT;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!swsusp_page_is_forbidden(page))
 				swsusp_unset_page_free(page);
 		}
<span class="p_chunk">@@ -1150,8 +1161,13 @@</span> <span class="p_context"> void mark_free_pages(struct zone *zone)</span>
 			unsigned long i;
 
 			pfn = page_to_pfn(list_entry(curr, struct page, lru));
<span class="p_del">-			for (i = 0; i &lt; (1UL &lt;&lt; order); i++)</span>
<span class="p_add">+			for (i = 0; i &lt; (1UL &lt;&lt; order); i++) {</span>
<span class="p_add">+				if (!--page_count) {</span>
<span class="p_add">+					touch_nmi_watchdog();</span>
<span class="p_add">+					page_count = WD_PAGE_COUNT;</span>
<span class="p_add">+				}</span>
 				swsusp_set_page_free(pfn_to_page(pfn + i));
<span class="p_add">+			}</span>
 		}
 	}
 	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);
<span class="p_header">diff --git a/net/dccp/probe.c b/net/dccp/probe.c</span>
<span class="p_header">index 33d0e6297c21..0a8d6ebd9b45 100644</span>
<span class="p_header">--- a/net/dccp/probe.c</span>
<span class="p_header">+++ b/net/dccp/probe.c</span>
<span class="p_chunk">@@ -152,6 +152,17 @@</span> <span class="p_context"> static const struct file_operations dccpprobe_fops = {</span>
 	.llseek  = noop_llseek,
 };
 
<span class="p_add">+static __init int setup_jprobe(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = register_jprobe(&amp;dccp_send_probe);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		request_module(&quot;dccp&quot;);</span>
<span class="p_add">+		ret = register_jprobe(&amp;dccp_send_probe);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __init int dccpprobe_init(void)
 {
 	int ret = -ENOMEM;
<span class="p_chunk">@@ -163,8 +174,7 @@</span> <span class="p_context"> static __init int dccpprobe_init(void)</span>
 	if (!proc_net_fops_create(&amp;init_net, procname, S_IRUSR, &amp;dccpprobe_fops))
 		goto err0;
 
<span class="p_del">-	try_then_request_module((ret = register_jprobe(&amp;dccp_send_probe)) == 0,</span>
<span class="p_del">-				&quot;dccp&quot;);</span>
<span class="p_add">+	ret = setup_jprobe();</span>
 	if (ret)
 		goto err1;
 
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 76784c7d54da..003a814aec89 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1128,13 +1128,14 @@</span> <span class="p_context"> static struct pernet_operations fib_net_ops = {</span>
 
 void __init ip_fib_init(void)
 {
<span class="p_del">-	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
<span class="p_add">+	fib_trie_init();</span>
 
 	register_pernet_subsys(&amp;fib_net_ops);
<span class="p_add">+</span>
 	register_netdevice_notifier(&amp;fib_netdev_notifier);
 	register_inetaddr_notifier(&amp;fib_inetaddr_notifier);
 
<span class="p_del">-	fib_trie_init();</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
 }
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index cd4f45bce336..9d74f445a176 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4284,7 +4284,7 @@</span> <span class="p_context"> static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)</span>
 		 * our DAD process, so we don&#39;t need
 		 * to do it again
 		 */
<span class="p_del">-		if (!(ifp-&gt;rt-&gt;rt6i_node))</span>
<span class="p_add">+		if (!rcu_access_pointer(ifp-&gt;rt-&gt;rt6i_node))</span>
 			ip6_ins_rt(ifp-&gt;rt);
 		if (ifp-&gt;idev-&gt;cnf.forwarding)
 			addrconf_join_anycast(ifp);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 785e62d90b39..8b1f0f9c1252 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -153,11 +153,23 @@</span> <span class="p_context"> static __inline__ struct fib6_node * node_alloc(void)</span>
 	return fn;
 }
 
<span class="p_del">-static __inline__ void node_free(struct fib6_node * fn)</span>
<span class="p_add">+static void node_free_immediate(struct fib6_node *fn)</span>
 {
 	kmem_cache_free(fib6_node_kmem, fn);
 }
 
<span class="p_add">+static void node_free_rcu(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fib6_node *fn = container_of(head, struct fib6_node, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kmem_cache_free(fib6_node_kmem, fn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void node_free(struct fib6_node *fn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	call_rcu(&amp;fn-&gt;rcu, node_free_rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __inline__ void rt6_release(struct rt6_info *rt)
 {
 	if (atomic_dec_and_test(&amp;rt-&gt;rt6i_ref))
<span class="p_chunk">@@ -529,9 +541,9 @@</span> <span class="p_context"> static struct fib6_node * fib6_add_1(struct fib6_node *root, void *addr,</span>
 
 		if (in == NULL || ln == NULL) {
 			if (in)
<span class="p_del">-				node_free(in);</span>
<span class="p_add">+				node_free_immediate(in);</span>
 			if (ln)
<span class="p_del">-				node_free(ln);</span>
<span class="p_add">+				node_free_immediate(ln);</span>
 			return NULL;
 		}
 
<span class="p_chunk">@@ -658,7 +670,7 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 
 	rt-&gt;dst.rt6_next = iter;
 	*ins = rt;
<span class="p_del">-	rt-&gt;rt6i_node = fn;</span>
<span class="p_add">+	rcu_assign_pointer(rt-&gt;rt6i_node, fn);</span>
 	atomic_inc(&amp;rt-&gt;rt6i_ref);
 	inet6_rt_notify(RTM_NEWROUTE, rt, info);
 	info-&gt;nl_net-&gt;ipv6.rt6_stats-&gt;fib_rt_entries++;
<span class="p_chunk">@@ -743,7 +755,7 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info)</span>
 				   root, and then (in st_failure) stale node
 				   in main tree.
 				 */
<span class="p_del">-				node_free(sfn);</span>
<span class="p_add">+				node_free_immediate(sfn);</span>
 				goto st_failure;
 			}
 
<span class="p_chunk">@@ -1169,8 +1181,9 @@</span> <span class="p_context"> static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,</span>
 
 int fib6_del(struct rt6_info *rt, struct nl_info *info)
 {
<span class="p_add">+	struct fib6_node *fn = rcu_dereference_protected(rt-&gt;rt6i_node,</span>
<span class="p_add">+				    lockdep_is_held(&amp;rt-&gt;rt6i_table-&gt;tb6_lock));</span>
 	struct net *net = info-&gt;nl_net;
<span class="p_del">-	struct fib6_node *fn = rt-&gt;rt6i_node;</span>
 	struct rt6_info **rtp;
 
 #if RT6_DEBUG &gt;= 2
<span class="p_chunk">@@ -1348,7 +1361,10 @@</span> <span class="p_context"> static int fib6_clean_node(struct fib6_walker_t *w)</span>
 			res = fib6_del(rt, &amp;info);
 			if (res) {
 #if RT6_DEBUG &gt;= 2
<span class="p_del">-				printk(KERN_DEBUG &quot;fib6_clean_node: del failed: rt=%p@%p err=%d\n&quot;, rt, rt-&gt;rt6i_node, res);</span>
<span class="p_add">+				pr_debug(&quot;%s: del failed: rt=%p@%p err=%d\n&quot;,</span>
<span class="p_add">+					 __func__, rt,</span>
<span class="p_add">+					 rcu_access_pointer(rt-&gt;rt6i_node),</span>
<span class="p_add">+					 res);</span>
 #endif
 				continue;
 			}
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index a2a085299f68..c7568ce7c212 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -568,7 +568,6 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 	while (offset &lt;= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
<span class="p_del">-		unsigned int len;</span>
 
 		switch (**nexthdr) {
 
<span class="p_chunk">@@ -594,10 +593,9 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
<span class="p_del">-		len = ipv6_optlen(exthdr);</span>
<span class="p_del">-		if (len + offset &gt;= IPV6_MAXPLEN)</span>
<span class="p_add">+		offset += ipv6_optlen(exthdr);</span>
<span class="p_add">+		if (offset &gt; IPV6_MAXPLEN)</span>
 			return -EINVAL;
<span class="p_del">-		offset += len;</span>
 		*nexthdr = &amp;exthdr-&gt;nexthdr;
 	}
 
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 2b4b4e379ac8..55f5a1a5112d 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static inline void ip6_tnl_dst_reset(struct ip6_tnl *t)</span>
 static inline void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
<span class="p_del">-	t-&gt;dst_cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+	t-&gt;dst_cookie = rt6_get_cookie(rt);</span>
 	dst_release(t-&gt;dst_cache);
 	t-&gt;dst_cache = dst;
 }
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index cda5cfe92f6b..6fc91f9e8e1b 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -964,10 +964,11 @@</span> <span class="p_context"> struct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_ori</span>
 static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
 {
 	struct rt6_info *rt;
<span class="p_add">+	u32 rt_cookie = 0;</span>
 
 	rt = (struct rt6_info *) dst;
 
<span class="p_del">-	if (rt-&gt;rt6i_node &amp;&amp; (rt-&gt;rt6i_node-&gt;fn_sernum == cookie)) {</span>
<span class="p_add">+	if (rt6_get_cookie_safe(rt, &amp;rt_cookie) &amp;&amp; rt_cookie == cookie) {</span>
 		if (rt-&gt;rt6i_peer_genid != rt6_peer_genid()) {
 			if (!rt-&gt;rt6i_peer)
 				rt6_bind_peer(rt, 0);
<span class="p_chunk">@@ -1007,8 +1008,15 @@</span> <span class="p_context"> static void ip6_link_failure(struct sk_buff *skb)</span>
 		if (rt-&gt;rt6i_flags&amp;RTF_CACHE) {
 			dst_set_expires(&amp;rt-&gt;dst, 0);
 			rt-&gt;rt6i_flags |= RTF_EXPIRES;
<span class="p_del">-		} else if (rt-&gt;rt6i_node &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT))</span>
<span class="p_del">-			rt-&gt;rt6i_node-&gt;fn_sernum = -1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			struct fib6_node *fn;</span>
<span class="p_add">+</span>
<span class="p_add">+			rcu_read_lock();</span>
<span class="p_add">+			fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+			if (fn &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT))</span>
<span class="p_add">+				fn-&gt;fn_sernum = -1;</span>
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">index db78e7d874d7..353ce0071d25 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_policy.c</span>
<span class="p_chunk">@@ -78,8 +78,7 @@</span> <span class="p_context"> static int xfrm6_init_path(struct xfrm_dst *path, struct dst_entry *dst,</span>
 {
 	if (dst-&gt;ops-&gt;family == AF_INET6) {
 		struct rt6_info *rt = (struct rt6_info*)dst;
<span class="p_del">-		if (rt-&gt;rt6i_node)</span>
<span class="p_del">-			path-&gt;path_cookie = rt-&gt;rt6i_node-&gt;fn_sernum;</span>
<span class="p_add">+		path-&gt;path_cookie = rt6_get_cookie(rt);</span>
 	}
 
 	path-&gt;u.rt6.rt6i_nfheader_len = nfheader_len;
<span class="p_chunk">@@ -111,8 +110,7 @@</span> <span class="p_context"> static int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,</span>
 						   RTF_LOCAL);
 	xdst-&gt;u.rt6.rt6i_metric = rt-&gt;rt6i_metric;
 	xdst-&gt;u.rt6.rt6i_node = rt-&gt;rt6i_node;
<span class="p_del">-	if (rt-&gt;rt6i_node)</span>
<span class="p_del">-		xdst-&gt;route_cookie = rt-&gt;rt6i_node-&gt;fn_sernum;</span>
<span class="p_add">+	xdst-&gt;route_cookie = rt6_get_cookie(rt);</span>
 	xdst-&gt;u.rt6.rt6i_gateway = rt-&gt;rt6i_gateway;
 	xdst-&gt;u.rt6.rt6i_dst = rt-&gt;rt6i_dst;
 	xdst-&gt;u.rt6.rt6i_src = rt-&gt;rt6i_src;
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index 35fc5ba2826b..c839f2d99efd 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,</span>
 #define BROADCAST_ONE		1
 #define BROADCAST_REGISTERED	2
 #define BROADCAST_PROMISC_ONLY	4
<span class="p_del">-static int pfkey_broadcast(struct sk_buff *skb,</span>
<span class="p_add">+static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 			   int broadcast_flags, struct sock *one_sk,
 			   struct net *net)
 {
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb,</span>
 	rcu_read_unlock();
 
 	if (one_sk != NULL)
<span class="p_del">-		err = pfkey_broadcast_one(skb, &amp;skb2, GFP_KERNEL, one_sk);</span>
<span class="p_add">+		err = pfkey_broadcast_one(skb, &amp;skb2, allocation, one_sk);</span>
 
 	kfree_skb(skb2);
 	kfree_skb(skb);
<span class="p_chunk">@@ -309,7 +309,7 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
 		hdr-&gt;sadb_msg_errno = rc;
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 		pfk-&gt;dump.skb = NULL;
 	}
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) /
 			     sizeof(uint64_t));
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1388,7 +1388,7 @@</span> <span class="p_context"> static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_</span>
 
 	xfrm_state_put(x);
 
<span class="p_del">-	pfkey_broadcast(resp_skb, BROADCAST_ONE, sk, net);</span>
<span class="p_add">+	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1476,7 +1476,7 @@</span> <span class="p_context"> static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	hdr-&gt;sadb_msg_pid = c-&gt;pid;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1593,7 +1593,7 @@</span> <span class="p_context"> static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg</span>
 	out_hdr-&gt;sadb_msg_reserved = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1694,8 +1694,8 @@</span> <span class="p_context"> static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 		return -ENOBUFS;
 	}
 
<span class="p_del">-	pfkey_broadcast(supp_skb, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
<span class="p_del">-</span>
<span class="p_add">+	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,</span>
<span class="p_add">+			sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1713,7 +1713,8 @@</span> <span class="p_context"> static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)</span>
 	hdr-&gt;sadb_msg_errno = (uint8_t) 0;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk,</span>
<span class="p_add">+			       sock_net(sk));</span>
 }
 
 static int key_notify_sa_flush(const struct km_event *c)
<span class="p_chunk">@@ -1734,7 +1735,7 @@</span> <span class="p_context"> static int key_notify_sa_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1795,7 +1796,7 @@</span> <span class="p_context"> static int dump_sa(struct xfrm_state *x, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_pid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -1862,7 +1863,7 @@</span> <span class="p_context"> static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 		new_hdr-&gt;sadb_msg_errno = 0;
 	}
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2193,7 +2194,7 @@</span> <span class="p_context"> static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_ev</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	out_hdr-&gt;sadb_msg_pid = c-&gt;pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ALL, NULL, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2419,7 +2420,7 @@</span> <span class="p_context"> static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struc</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));</span>
 	err = 0;
 
 out:
<span class="p_chunk">@@ -2672,7 +2673,7 @@</span> <span class="p_context"> static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_pid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -2727,7 +2728,7 @@</span> <span class="p_context"> static int key_notify_policy_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
<span class="p_del">-	pfkey_broadcast(skb_out, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2793,7 +2794,7 @@</span> <span class="p_context"> static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 	void *ext_hdrs[SADB_EXT_MAX];
 	int err;
 
<span class="p_del">-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL),</span>
<span class="p_add">+	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,</span>
 			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
 
 	memset(ext_hdrs, 0, sizeof(ext_hdrs));
<span class="p_chunk">@@ -2999,7 +3000,8 @@</span> <span class="p_context"> static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)</span>
 	out_hdr-&gt;sadb_msg_seq = 0;
 	out_hdr-&gt;sadb_msg_pid = 0;
 
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			xs_net(x));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3171,7 +3173,8 @@</span> <span class="p_context"> static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct</span>
 		       xfrm_ctx-&gt;ctx_len);
 	}
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
<span class="p_chunk">@@ -3369,7 +3372,8 @@</span> <span class="p_context"> static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,</span>
 	n_port-&gt;sadb_x_nat_t_port_port = sport;
 	n_port-&gt;sadb_x_nat_t_port_reserved = 0;
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 #ifdef CONFIG_NET_KEY_MIGRATE
<span class="p_chunk">@@ -3561,7 +3565,7 @@</span> <span class="p_context"> static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,</span>
 	}
 
 	/* broadcast migrate message to sockets */
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, &amp;init_net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &amp;init_net);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 3954b18f42ee..b539c784c6d1 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -112,10 +112,9 @@</span> <span class="p_context"> struct l2tp_net {</span>
 };
 
 static void l2tp_session_set_header_len(struct l2tp_session *session, int version);
<span class="p_del">-static void l2tp_tunnel_free(struct l2tp_tunnel *tunnel);</span>
 static void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel);
 
<span class="p_del">-static inline struct l2tp_net *l2tp_pernet(struct net *net)</span>
<span class="p_add">+static inline struct l2tp_net *l2tp_pernet(const struct net *net)</span>
 {
 	BUG_ON(!net);
 
<span class="p_chunk">@@ -123,33 +122,6 @@</span> <span class="p_context"> static inline struct l2tp_net *l2tp_pernet(struct net *net)</span>
 }
 
 
<span class="p_del">-/* Tunnel reference counts. Incremented per session that is added to</span>
<span class="p_del">- * the tunnel.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void l2tp_tunnel_inc_refcount_1(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	atomic_inc(&amp;tunnel-&gt;ref_count);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void l2tp_tunnel_dec_refcount_1(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;tunnel-&gt;ref_count))</span>
<span class="p_del">-		l2tp_tunnel_free(tunnel);</span>
<span class="p_del">-}</span>
<span class="p_del">-#ifdef L2TP_REFCNT_DEBUG</span>
<span class="p_del">-#define l2tp_tunnel_inc_refcount(_t) do { \</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;l2tp_tunnel_inc_refcount: %s:%d %s: cnt=%d\n&quot;, __func__, __LINE__, (_t)-&gt;name, atomic_read(&amp;_t-&gt;ref_count)); \</span>
<span class="p_del">-		l2tp_tunnel_inc_refcount_1(_t);				\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-#define l2tp_tunnel_dec_refcount(_t) do { \</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;l2tp_tunnel_dec_refcount: %s:%d %s: cnt=%d\n&quot;, __func__, __LINE__, (_t)-&gt;name, atomic_read(&amp;_t-&gt;ref_count)); \</span>
<span class="p_del">-		l2tp_tunnel_dec_refcount_1(_t);				\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define l2tp_tunnel_inc_refcount(t) l2tp_tunnel_inc_refcount_1(t)</span>
<span class="p_del">-#define l2tp_tunnel_dec_refcount(t) l2tp_tunnel_dec_refcount_1(t)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /* Session hash global list for L2TPv3.
  * The session_id SHOULD be random according to RFC3931, but several
  * L2TP implementations use incrementing session_ids.  So we do a real
<span class="p_chunk">@@ -225,10 +197,31 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunn</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_session_find);
 
<span class="p_add">+/* Lookup a tunnel. A new reference is held on the returned tunnel. */</span>
<span class="p_add">+struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct l2tp_net *pn = l2tp_pernet(net);</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock_bh();</span>
<span class="p_add">+	list_for_each_entry_rcu(tunnel, &amp;pn-&gt;l2tp_tunnel_list, list) {</span>
<span class="p_add">+		if (tunnel-&gt;tunnel_id == tunnel_id) {</span>
<span class="p_add">+			l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+			rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+			return tunnel;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_tunnel_get);</span>
<span class="p_add">+</span>
 /* Like l2tp_session_find() but takes a reference on the returned session.
  * Optionally calls session-&gt;ref() too if do_ref is true.
  */
<span class="p_del">-struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get(const struct net *net,</span>
 				      struct l2tp_tunnel *tunnel,
 				      u32 session_id, bool do_ref)
 {
<span class="p_chunk">@@ -305,7 +298,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_session_get_nth);</span>
 /* Lookup a session by interface name.
  * This is very inefficient but is only used by management interfaces.
  */
<span class="p_del">-struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,</span>
<span class="p_add">+						const char *ifname,</span>
 						bool do_ref)
 {
 	struct l2tp_net *pn = l2tp_pernet(net);
<span class="p_chunk">@@ -1340,7 +1334,7 @@</span> <span class="p_context"> static void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)</span>
 /* Really kill the tunnel.
  * Come here only when all sessions have been cleared from the tunnel.
  */
<span class="p_del">-static void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)</span>
 {
 	struct l2tp_net *pn = l2tp_pernet(tunnel-&gt;l2tp_net);
 
<span class="p_chunk">@@ -1358,6 +1352,7 @@</span> <span class="p_context"> static void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)</span>
 
 	atomic_dec(&amp;l2tp_tunnel_count);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_tunnel_free);</span>
 
 /* Create a socket for the tunnel, if one isn&#39;t set up by
  * userspace. This is used for static tunnels where there is no
<span class="p_chunk">@@ -1715,6 +1710,8 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 
 		l2tp_session_set_header_len(session, tunnel-&gt;version);
 
<span class="p_add">+		l2tp_session_inc_refcount(session);</span>
<span class="p_add">+</span>
 		err = l2tp_session_add_to_tunnel(tunnel, session);
 		if (err) {
 			kfree(session);
<span class="p_chunk">@@ -1722,10 +1719,6 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 			return ERR_PTR(err);
 		}
 
<span class="p_del">-		/* Bump the reference count. The session context is deleted</span>
<span class="p_del">-		 * only when this drops to zero.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		l2tp_session_inc_refcount(session);</span>
 		l2tp_tunnel_inc_refcount(tunnel);
 
 		/* Ensure tunnel socket isn&#39;t deleted */
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 1caf21e11822..2066d2396fbd 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -222,13 +222,17 @@</span> <span class="p_context"> static inline struct l2tp_tunnel *l2tp_sock_to_tunnel(struct sock *sk)</span>
 	return tunnel;
 }
 
<span class="p_del">-struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id);</span>
<span class="p_add">+void l2tp_tunnel_free(struct l2tp_tunnel *tunnel);</span>
<span class="p_add">+</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get(const struct net *net,</span>
 				      struct l2tp_tunnel *tunnel,
 				      u32 session_id, bool do_ref);
 extern struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunnel, u32 session_id);
 struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth,
 					  bool do_ref);
<span class="p_del">-struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,</span>
<span class="p_add">+						const char *ifname,</span>
 						bool do_ref);
 extern struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 extern struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
<span class="p_chunk">@@ -247,6 +251,17 @@</span> <span class="p_context"> extern int l2tp_nl_register_ops(enum l2tp_pwtype pw_type, const struct l2tp_nl_c</span>
 extern void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
 int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 
<span class="p_add">+static inline void l2tp_tunnel_inc_refcount(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_inc(&amp;tunnel-&gt;ref_count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void l2tp_tunnel_dec_refcount(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;tunnel-&gt;ref_count))</span>
<span class="p_add">+		l2tp_tunnel_free(tunnel);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Session reference counts. Incremented when code obtains a reference
  * to a session.
  */
<span class="p_header">diff --git a/net/l2tp/l2tp_netlink.c b/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">index 6fd632285106..aefb6a2313ea 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_netlink.c</span>
<span class="p_chunk">@@ -57,10 +57,12 @@</span> <span class="p_context"> static struct l2tp_session *l2tp_nl_session_get(struct genl_info *info,</span>
 		   (info-&gt;attrs[L2TP_ATTR_CONN_ID])) {
 		tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 		session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_SESSION_ID]);
<span class="p_del">-		tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-		if (tunnel)</span>
<span class="p_add">+		tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+		if (tunnel) {</span>
 			session = l2tp_session_get(net, tunnel, session_id,
 						   do_ref);
<span class="p_add">+			l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+		}</span>
 	}
 
 	return session;
<span class="p_chunk">@@ -182,14 +184,16 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_delete(struct sk_buff *skb, struct genl_info *info</span>
 	}
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
 
 	(void) l2tp_tunnel_delete(tunnel);
 
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -207,8 +211,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info</span>
 	}
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_chunk">@@ -216,6 +220,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info</span>
 	if (info-&gt;attrs[L2TP_ATTR_DEBUG])
 		tunnel-&gt;debug = nla_get_u32(info-&gt;attrs[L2TP_ATTR_DEBUG]);
 
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -289,34 +295,37 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_get(struct sk_buff *skb, struct genl_info *info)</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_CONN_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
 	if (!msg) {
 		ret = -ENOMEM;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_nlmsg;</span>
 	}
 
 	ret = l2tp_nl_tunnel_send(msg, info-&gt;snd_pid, info-&gt;snd_seq,
 				  NLM_F_ACK, tunnel);
 	if (ret &lt; 0)
<span class="p_del">-		goto err_out;</span>
<span class="p_add">+		goto err_nlmsg_tunnel;</span>
<span class="p_add">+</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
 
 	return genlmsg_unicast(net, msg, info-&gt;snd_pid);
 
<span class="p_del">-err_out:</span>
<span class="p_add">+err_nlmsg_tunnel:</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+err_nlmsg:</span>
 	nlmsg_free(msg);
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_add">+err:</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -352,7 +361,6 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	u32 peer_session_id;
 	int ret = 0;
 	struct l2tp_tunnel *tunnel;
<span class="p_del">-	struct l2tp_session *session;</span>
 	struct l2tp_session_cfg cfg = { 0, };
 	struct net *net = genl_info_net(info);
 
<span class="p_chunk">@@ -360,8 +368,9 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_add">+</span>
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
 	if (!tunnel) {
 		ret = -ENODEV;
 		goto out;
<span class="p_chunk">@@ -369,29 +378,24 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_SESSION_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_SESSION_ID]);
<span class="p_del">-	session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_del">-	if (session) {</span>
<span class="p_del">-		ret = -EEXIST;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_PEER_SESSION_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	peer_session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_PEER_SESSION_ID]);
 
 	if (!info-&gt;attrs[L2TP_ATTR_PW_TYPE]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	cfg.pw_type = nla_get_u16(info-&gt;attrs[L2TP_ATTR_PW_TYPE]);
 	if (cfg.pw_type &gt;= __L2TP_PWTYPE_MAX) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 
 	if (tunnel-&gt;version &gt; 2) {
<span class="p_chunk">@@ -413,7 +417,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 			u16 len = nla_len(info-&gt;attrs[L2TP_ATTR_COOKIE]);
 			if (len &gt; 8) {
 				ret = -EINVAL;
<span class="p_del">-				goto out;</span>
<span class="p_add">+				goto out_tunnel;</span>
 			}
 			cfg.cookie_len = len;
 			memcpy(&amp;cfg.cookie[0], nla_data(info-&gt;attrs[L2TP_ATTR_COOKIE]), len);
<span class="p_chunk">@@ -422,7 +426,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 			u16 len = nla_len(info-&gt;attrs[L2TP_ATTR_PEER_COOKIE]);
 			if (len &gt; 8) {
 				ret = -EINVAL;
<span class="p_del">-				goto out;</span>
<span class="p_add">+				goto out_tunnel;</span>
 			}
 			cfg.peer_cookie_len = len;
 			memcpy(&amp;cfg.peer_cookie[0], nla_data(info-&gt;attrs[L2TP_ATTR_PEER_COOKIE]), len);
<span class="p_chunk">@@ -458,7 +462,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	if ((l2tp_nl_cmd_ops[cfg.pw_type] == NULL) ||
 	    (l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create == NULL)) {
 		ret = -EPROTONOSUPPORT;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 
 	/* Check that pseudowire-specific params are present */
<span class="p_chunk">@@ -468,7 +472,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	case L2TP_PWTYPE_ETH_VLAN:
 		if (!info-&gt;attrs[L2TP_ATTR_VLAN_ID]) {
 			ret = -EINVAL;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_tunnel;</span>
 		}
 		break;
 	case L2TP_PWTYPE_ETH:
<span class="p_chunk">@@ -487,6 +491,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 		ret = (*l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create)(net, tunnel_id,
 			session_id, peer_session_id, &amp;cfg);
 
<span class="p_add">+out_tunnel:</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/net/mac80211/key.c b/net/mac80211/key.c</span>
<span class="p_header">index fb02ea52d2c2..f2bdd6fc3e76 100644</span>
<span class="p_header">--- a/net/mac80211/key.c</span>
<span class="p_header">+++ b/net/mac80211/key.c</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
  * Copyright 2005-2006, Devicescape Software, Inc.
  * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;
  * Copyright 2007-2008	Johannes Berg &lt;johannes@sipsolutions.net&gt;
<span class="p_add">+ * Copyright 2017	Intel Deutschland GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -456,9 +457,6 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 
 	pairwise = key-&gt;conf.flags &amp; IEEE80211_KEY_FLAG_PAIRWISE;
 	idx = key-&gt;conf.keyidx;
<span class="p_del">-	key-&gt;local = sdata-&gt;local;</span>
<span class="p_del">-	key-&gt;sdata = sdata;</span>
<span class="p_del">-	key-&gt;sta = sta;</span>
 
 	if (sta) {
 		/*
<span class="p_chunk">@@ -495,6 +493,21 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 	else
 		old_key = key_mtx_dereference(sdata-&gt;local, sdata-&gt;keys[idx]);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Silently accept key re-installation without really installing the</span>
<span class="p_add">+	 * new version of the key to avoid nonce reuse or replay issues.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (old_key &amp;&amp; key-&gt;conf.keylen == old_key-&gt;conf.keylen &amp;&amp;</span>
<span class="p_add">+	    !memcmp(key-&gt;conf.key, old_key-&gt;conf.key, key-&gt;conf.keylen)) {</span>
<span class="p_add">+		__ieee80211_key_free(key);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	key-&gt;local = sdata-&gt;local;</span>
<span class="p_add">+	key-&gt;sdata = sdata;</span>
<span class="p_add">+	key-&gt;sta = sta;</span>
<span class="p_add">+</span>
 	increment_tailroom_need_count(sdata);
 
 	__ieee80211_key_replace(sdata, sta, pairwise, old_key, key);
<span class="p_chunk">@@ -504,6 +517,7 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 
 	ret = ieee80211_key_enable_hw_accel(key);
 
<span class="p_add">+ out:</span>
 	mutex_unlock(&amp;sdata-&gt;local-&gt;key_mtx);
 
 	return ret;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">index cc8f8b43ba0e..a6cbb7aacb25 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> __ip_vs_get_out_rt_v6(struct sk_buff *skb, struct ip_vs_dest *dest,</span>
 				return NULL;
 			}
 			rt = (struct rt6_info *) dst;
<span class="p_del">-			cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+			cookie = rt6_get_cookie(rt);</span>
 			__ip_vs_dst_set(dest, 0, dst_clone(&amp;rt-&gt;dst), cookie);
 			IP_VS_DBG(10, &quot;new dst %pI6, src %pI6, refcnt=%d\n&quot;,
 				  &amp;dest-&gt;addr.in6, &amp;dest-&gt;dst_saddr.in6,
<span class="p_header">diff --git a/net/netfilter/xt_socket.c b/net/netfilter/xt_socket.c</span>
<span class="p_header">index c4706be65add..1baf17370f41 100644</span>
<span class="p_header">--- a/net/netfilter/xt_socket.c</span>
<span class="p_header">+++ b/net/netfilter/xt_socket.c</span>
<span class="p_chunk">@@ -108,9 +108,9 @@</span> <span class="p_context"> socket_match(const struct sk_buff *skb, struct xt_action_param *par,</span>
 	const struct iphdr *iph = ip_hdr(skb);
 	struct udphdr _hdr, *hp = NULL;
 	struct sock *sk;
<span class="p_del">-	__be32 daddr, saddr;</span>
<span class="p_del">-	__be16 dport, sport;</span>
<span class="p_del">-	u8 protocol;</span>
<span class="p_add">+	__be32 uninitialized_var(daddr), uninitialized_var(saddr);</span>
<span class="p_add">+	__be16 uninitialized_var(dport), uninitialized_var(sport);</span>
<span class="p_add">+	u8 uninitialized_var(protocol);</span>
 #ifdef XT_SOCKET_HAVE_CONNTRACK
 	struct nf_conn const *ct;
 	enum ip_conntrack_info ctinfo;
<span class="p_chunk">@@ -263,9 +263,9 @@</span> <span class="p_context"> socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)</span>
 	struct ipv6hdr ipv6_var, *iph = ipv6_hdr(skb);
 	struct udphdr _hdr, *hp = NULL;
 	struct sock *sk;
<span class="p_del">-	const struct in6_addr *daddr, *saddr;</span>
<span class="p_del">-	__be16 dport, sport;</span>
<span class="p_del">-	int thoff, tproto;</span>
<span class="p_add">+	const struct in6_addr *daddr = NULL, *saddr = NULL;</span>
<span class="p_add">+	__be16 uninitialized_var(dport), uninitialized_var(sport);</span>
<span class="p_add">+	int thoff, uninitialized_var(tproto);</span>
 	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par-&gt;matchinfo;
 
 	tproto = ipv6_find_hdr(skb, &amp;thoff, -1, NULL);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 57b5add0c978..2d44726d8a00 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1294,10 +1294,6 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 
 	mutex_lock(&amp;fanout_mutex);
 
<span class="p_del">-	err = -EINVAL;</span>
<span class="p_del">-	if (!po-&gt;running)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	err = -EALREADY;
 	if (po-&gt;fanout)
 		goto out;
<span class="p_chunk">@@ -1334,7 +1330,10 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		list_add(&amp;match-&gt;list, &amp;fanout_list);
 	}
 	err = -EINVAL;
<span class="p_del">-	if (match-&gt;type == type &amp;&amp;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+	if (po-&gt;running &amp;&amp;</span>
<span class="p_add">+	    match-&gt;type == type &amp;&amp;</span>
 	    match-&gt;prot_hook.type == po-&gt;prot_hook.type &amp;&amp;
 	    match-&gt;prot_hook.dev == po-&gt;prot_hook.dev) {
 		err = -ENOSPC;
<span class="p_chunk">@@ -1346,6 +1345,13 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 			err = 0;
 		}
 	}
<span class="p_add">+	spin_unlock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err &amp;&amp; !atomic_read(&amp;match-&gt;sk_ref)) {</span>
<span class="p_add">+		list_del(&amp;match-&gt;list);</span>
<span class="p_add">+		kfree(match);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 out:
 	mutex_unlock(&amp;fanout_mutex);
 	return err;
<span class="p_chunk">@@ -2468,33 +2474,72 @@</span> <span class="p_context"> static int packet_release(struct socket *sock)</span>
  *	Attach a packet hook.
  */
 
<span class="p_del">-static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 protocol)</span>
<span class="p_add">+static int packet_do_bind(struct sock *sk, const char *name, int ifindex,</span>
<span class="p_add">+			  __be16 protocol)</span>
 {
 	struct packet_sock *po = pkt_sk(sk);
<span class="p_add">+	struct net_device *dev_curr;</span>
<span class="p_add">+	struct net_device *dev = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	bool unlisted = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+	rcu_read_lock();</span>
 
 	if (po-&gt;fanout) {
<span class="p_del">-		if (dev)</span>
<span class="p_del">-			dev_put(dev);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (name) {</span>
<span class="p_add">+		dev = dev_get_by_name_rcu(sock_net(sk), name);</span>
<span class="p_add">+		if (!dev) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (ifindex) {</span>
<span class="p_add">+		dev = dev_get_by_index_rcu(sock_net(sk), ifindex);</span>
<span class="p_add">+		if (!dev) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_add">+	if (dev)</span>
<span class="p_add">+		dev_hold(dev);</span>
 
<span class="p_del">-	spin_lock(&amp;po-&gt;bind_lock);</span>
<span class="p_del">-	unregister_prot_hook(sk, true);</span>
<span class="p_add">+	dev_curr = po-&gt;prot_hook.dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (po-&gt;running) {</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		__unregister_prot_hook(sk, true);</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		dev_curr = po-&gt;prot_hook.dev;</span>
<span class="p_add">+		if (dev)</span>
<span class="p_add">+			unlisted = !dev_get_by_index_rcu(sock_net(sk),</span>
<span class="p_add">+							 dev-&gt;ifindex);</span>
<span class="p_add">+	}</span>
 	po-&gt;num = protocol;
 	po-&gt;prot_hook.type = protocol;
<span class="p_del">-	if (po-&gt;prot_hook.dev)</span>
<span class="p_del">-		dev_put(po-&gt;prot_hook.dev);</span>
<span class="p_del">-	po-&gt;prot_hook.dev = dev;</span>
 
<span class="p_del">-	po-&gt;ifindex = dev ? dev-&gt;ifindex : 0;</span>
<span class="p_add">+	if (unlikely(unlisted)) {</span>
<span class="p_add">+		dev_put(dev);</span>
<span class="p_add">+		po-&gt;prot_hook.dev = NULL;</span>
<span class="p_add">+		po-&gt;ifindex = -1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		po-&gt;prot_hook.dev = dev;</span>
<span class="p_add">+		po-&gt;ifindex = dev ? dev-&gt;ifindex : 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev_curr)</span>
<span class="p_add">+		dev_put(dev_curr);</span>
 
 	if (protocol == 0)
 		goto out_unlock;
 
<span class="p_del">-	if (!dev || (dev-&gt;flags &amp; IFF_UP)) {</span>
<span class="p_add">+	if (!unlisted &amp;&amp; (!dev || (dev-&gt;flags &amp; IFF_UP))) {</span>
 		register_prot_hook(sk);
 	} else {
 		sk-&gt;sk_err = ENETDOWN;
<span class="p_chunk">@@ -2503,9 +2548,10 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, struct net_device *dev, __be16 protoc</span>
 	}
 
 out_unlock:
<span class="p_add">+	rcu_read_unlock();</span>
 	spin_unlock(&amp;po-&gt;bind_lock);
 	release_sock(sk);
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -2517,8 +2563,6 @@</span> <span class="p_context"> static int packet_bind_spkt(struct socket *sock, struct sockaddr *uaddr,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	char name[15];
<span class="p_del">-	struct net_device *dev;</span>
<span class="p_del">-	int err = -ENODEV;</span>
 
 	/*
 	 *	Check legality
<span class="p_chunk">@@ -2528,19 +2572,13 @@</span> <span class="p_context"> static int packet_bind_spkt(struct socket *sock, struct sockaddr *uaddr,</span>
 		return -EINVAL;
 	strlcpy(name, uaddr-&gt;sa_data, sizeof(name));
 
<span class="p_del">-	dev = dev_get_by_name(sock_net(sk), name);</span>
<span class="p_del">-	if (dev)</span>
<span class="p_del">-		err = packet_do_bind(sk, dev, pkt_sk(sk)-&gt;num);</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return packet_do_bind(sk, name, 0, pkt_sk(sk)-&gt;num);</span>
 }
 
 static int packet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	struct sockaddr_ll *sll = (struct sockaddr_ll *)uaddr;
 	struct sock *sk = sock-&gt;sk;
<span class="p_del">-	struct net_device *dev = NULL;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
 
 	/*
 	 *	Check legality
<span class="p_chunk">@@ -2551,16 +2589,8 @@</span> <span class="p_context"> static int packet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len</span>
 	if (sll-&gt;sll_family != AF_PACKET)
 		return -EINVAL;
 
<span class="p_del">-	if (sll-&gt;sll_ifindex) {</span>
<span class="p_del">-		err = -ENODEV;</span>
<span class="p_del">-		dev = dev_get_by_index(sock_net(sk), sll-&gt;sll_ifindex);</span>
<span class="p_del">-		if (dev == NULL)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	err = packet_do_bind(sk, dev, sll-&gt;sll_protocol ? : pkt_sk(sk)-&gt;num);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return packet_do_bind(sk, NULL, sll-&gt;sll_ifindex,</span>
<span class="p_add">+			      sll-&gt;sll_protocol ? : pkt_sk(sk)-&gt;num);</span>
 }
 
 static struct proto packet_proto = {
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index dca6c1a576f7..2751bd8b6cf2 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -866,6 +866,8 @@</span> <span class="p_context"> qdisc_create(struct net_device *dev, struct netdev_queue *dev_queue,</span>
 
 		return sch;
 	}
<span class="p_add">+	/* ops-&gt;init() failed, we call -&gt;destroy() like qdisc_create_dflt() */</span>
<span class="p_add">+	ops-&gt;destroy(sch);</span>
 err_out3:
 	dev_put(dev);
 	kfree((char *) sch - sch-&gt;padded);
<span class="p_header">diff --git a/net/sched/sch_cbq.c b/net/sched/sch_cbq.c</span>
<span class="p_header">index 7f599447b3ca..407ffa744946 100644</span>
<span class="p_header">--- a/net/sched/sch_cbq.c</span>
<span class="p_header">+++ b/net/sched/sch_cbq.c</span>
<span class="p_chunk">@@ -1367,6 +1367,13 @@</span> <span class="p_context"> static int cbq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct tc_ratespec *r;
 	int err;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	hrtimer_init(&amp;q-&gt;delay_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);</span>
<span class="p_add">+	q-&gt;delay_timer.function = cbq_undelay;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!opt)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	err = nla_parse_nested(tb, TCA_CBQ_MAX, opt, cbq_policy);
 	if (err &lt; 0)
 		return err;
<span class="p_chunk">@@ -1405,9 +1412,6 @@</span> <span class="p_context"> static int cbq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	q-&gt;link.avpkt = q-&gt;link.allot/2;
 	q-&gt;link.minidle = -0x7FFFFFFF;
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	hrtimer_init(&amp;q-&gt;delay_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);</span>
<span class="p_del">-	q-&gt;delay_timer.function = cbq_undelay;</span>
 	q-&gt;toplevel = TC_CBQ_MAXLEVEL;
 	q-&gt;now = psched_get_time();
 	q-&gt;now_rt = q-&gt;now;
<span class="p_header">diff --git a/net/sched/sch_drr.c b/net/sched/sch_drr.c</span>
<span class="p_header">index 6b7fe4a84f13..7ce8acc5594b 100644</span>
<span class="p_header">--- a/net/sched/sch_drr.c</span>
<span class="p_header">+++ b/net/sched/sch_drr.c</span>
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static int drr_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 {
 	struct drr_sched *q = qdisc_priv(sch);
 	struct drr_class *cl;
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 
 	cl = drr_classify(skb, sch, &amp;err);
 	if (cl == NULL) {
<span class="p_header">diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c</span>
<span class="p_header">index 6488e6425652..a239d0aac5ae 100644</span>
<span class="p_header">--- a/net/sched/sch_hfsc.c</span>
<span class="p_header">+++ b/net/sched/sch_hfsc.c</span>
<span class="p_chunk">@@ -1435,6 +1435,8 @@</span> <span class="p_context"> hfsc_init_qdisc(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct tc_hfsc_qopt *qopt;
 	int err;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+</span>
 	if (opt == NULL || nla_len(opt) &lt; sizeof(*qopt))
 		return -EINVAL;
 	qopt = nla_data(opt);
<span class="p_chunk">@@ -1460,8 +1462,6 @@</span> <span class="p_context"> hfsc_init_qdisc(struct Qdisc *sch, struct nlattr *opt)</span>
 	qdisc_class_hash_insert(&amp;q-&gt;clhash, &amp;q-&gt;root.cl_common);
 	qdisc_class_hash_grow(sch, &amp;q-&gt;clhash);
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c</span>
<span class="p_header">index 92f0c1f36c1b..3f93a5cb34ac 100644</span>
<span class="p_header">--- a/net/sched/sch_htb.c</span>
<span class="p_header">+++ b/net/sched/sch_htb.c</span>
<span class="p_chunk">@@ -997,6 +997,9 @@</span> <span class="p_context"> static int htb_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	int err;
 	int i;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	INIT_WORK(&amp;q-&gt;work, htb_work_func);</span>
<span class="p_add">+</span>
 	if (!opt)
 		return -EINVAL;
 
<span class="p_chunk">@@ -1021,8 +1024,6 @@</span> <span class="p_context"> static int htb_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	for (i = 0; i &lt; TC_HTB_NUMPRIO; i++)
 		INIT_LIST_HEAD(q-&gt;drops + i);
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	INIT_WORK(&amp;q-&gt;work, htb_work_func);</span>
 	skb_queue_head_init(&amp;q-&gt;direct_queue);
 
 	q-&gt;direct_qlen = qdisc_dev(sch)-&gt;tx_queue_len;
<span class="p_header">diff --git a/net/sched/sch_mq.c b/net/sched/sch_mq.c</span>
<span class="p_header">index 0a4b2f9a0094..7cf451fb4599 100644</span>
<span class="p_header">--- a/net/sched/sch_mq.c</span>
<span class="p_header">+++ b/net/sched/sch_mq.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> static int mq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	/* pre-allocate qdiscs, attachment can&#39;t fail */
 	priv-&gt;qdiscs = kcalloc(dev-&gt;num_tx_queues, sizeof(priv-&gt;qdiscs[0]),
 			       GFP_KERNEL);
<span class="p_del">-	if (priv-&gt;qdiscs == NULL)</span>
<span class="p_add">+	if (!priv-&gt;qdiscs)</span>
 		return -ENOMEM;
 
 	for (ntx = 0; ntx &lt; dev-&gt;num_tx_queues; ntx++) {
<span class="p_chunk">@@ -60,17 +60,13 @@</span> <span class="p_context"> static int mq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 		qdisc = qdisc_create_dflt(dev_queue, &amp;pfifo_fast_ops,
 					  TC_H_MAKE(TC_H_MAJ(sch-&gt;handle),
 						    TC_H_MIN(ntx + 1)));
<span class="p_del">-		if (qdisc == NULL)</span>
<span class="p_del">-			goto err;</span>
<span class="p_add">+		if (!qdisc)</span>
<span class="p_add">+			return -ENOMEM;</span>
 		priv-&gt;qdiscs[ntx] = qdisc;
 	}
 
 	sch-&gt;flags |= TCQ_F_MQROOT;
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	mq_destroy(sch);</span>
<span class="p_del">-	return -ENOMEM;</span>
 }
 
 static void mq_attach(struct Qdisc *sch)
<span class="p_header">diff --git a/net/sched/sch_mqprio.c b/net/sched/sch_mqprio.c</span>
<span class="p_header">index 28de43092330..b4a388beb47e 100644</span>
<span class="p_header">--- a/net/sched/sch_mqprio.c</span>
<span class="p_header">+++ b/net/sched/sch_mqprio.c</span>
<span class="p_chunk">@@ -117,20 +117,17 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	/* pre-allocate qdisc, attachment can&#39;t fail */
 	priv-&gt;qdiscs = kcalloc(dev-&gt;num_tx_queues, sizeof(priv-&gt;qdiscs[0]),
 			       GFP_KERNEL);
<span class="p_del">-	if (priv-&gt;qdiscs == NULL) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!priv-&gt;qdiscs)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	for (i = 0; i &lt; dev-&gt;num_tx_queues; i++) {
 		dev_queue = netdev_get_tx_queue(dev, i);
 		qdisc = qdisc_create_dflt(dev_queue, &amp;pfifo_fast_ops,
 					  TC_H_MAKE(TC_H_MAJ(sch-&gt;handle),
 						    TC_H_MIN(i + 1)));
<span class="p_del">-		if (qdisc == NULL) {</span>
<span class="p_del">-			err = -ENOMEM;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!qdisc)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
 		priv-&gt;qdiscs[i] = qdisc;
 	}
 
<span class="p_chunk">@@ -142,7 +139,7 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 		priv-&gt;hw_owned = 1;
 		err = dev-&gt;netdev_ops-&gt;ndo_setup_tc(dev, qopt-&gt;num_tc);
 		if (err)
<span class="p_del">-			goto err;</span>
<span class="p_add">+			return err;</span>
 	} else {
 		netdev_set_num_tc(dev, qopt-&gt;num_tc);
 		for (i = 0; i &lt; qopt-&gt;num_tc; i++)
<span class="p_chunk">@@ -156,10 +153,6 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch-&gt;flags |= TCQ_F_MQROOT;
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	mqprio_destroy(sch);</span>
<span class="p_del">-	return err;</span>
 }
 
 static void mqprio_attach(struct Qdisc *sch)
<span class="p_header">diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c</span>
<span class="p_header">index edc1950e0e77..a8f8dc1e0e41 100644</span>
<span class="p_header">--- a/net/sched/sch_multiq.c</span>
<span class="p_header">+++ b/net/sched/sch_multiq.c</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 static int multiq_init(struct Qdisc *sch, struct nlattr *opt)
 {
 	struct multiq_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	int i, err;</span>
<span class="p_add">+	int i;</span>
 
 	q-&gt;queues = NULL;
 
<span class="p_chunk">@@ -265,12 +265,7 @@</span> <span class="p_context"> static int multiq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	for (i = 0; i &lt; q-&gt;max_bands; i++)
 		q-&gt;queues[i] = &amp;noop_qdisc;
 
<span class="p_del">-	err = multiq_tune(sch, opt);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		kfree(q-&gt;queues);</span>
<span class="p_del">-</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return multiq_tune(sch, opt);</span>
 }
 
 static int multiq_dump(struct Qdisc *sch, struct sk_buff *skb)
<span class="p_header">diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c</span>
<span class="p_header">index a489d8bcfd41..5856ce55a02a 100644</span>
<span class="p_header">--- a/net/sched/sch_netem.c</span>
<span class="p_header">+++ b/net/sched/sch_netem.c</span>
<span class="p_chunk">@@ -758,11 +758,11 @@</span> <span class="p_context"> static int netem_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct netem_sched_data *q = qdisc_priv(sch);
 	int ret;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+</span>
 	if (!opt)
 		return -EINVAL;
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-</span>
 	q-&gt;loss_model = CLG_RANDOM;
 	q-&gt;qdisc = qdisc_create_dflt(sch-&gt;dev_queue, &amp;tfifo_qdisc_ops,
 				     TC_H_MAKE(sch-&gt;handle, 1));
<span class="p_header">diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c</span>
<span class="p_header">index ca0fb48d3e55..4ade9189b13b 100644</span>
<span class="p_header">--- a/net/sched/sch_qfq.c</span>
<span class="p_header">+++ b/net/sched/sch_qfq.c</span>
<span class="p_chunk">@@ -846,7 +846,7 @@</span> <span class="p_context"> static int qfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	struct qfq_sched *q = qdisc_priv(sch);
 	struct qfq_group *grp;
 	struct qfq_class *cl;
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 	u64 roundedS;
 	int s;
 
<span class="p_header">diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c</span>
<span class="p_header">index 1dcfb5223a86..e24dfbe7a387 100644</span>
<span class="p_header">--- a/net/sched/sch_tbf.c</span>
<span class="p_header">+++ b/net/sched/sch_tbf.c</span>
<span class="p_chunk">@@ -316,12 +316,13 @@</span> <span class="p_context"> static int tbf_init(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct tbf_sched_data *q = qdisc_priv(sch);
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	q-&gt;qdisc = &amp;noop_qdisc;</span>
<span class="p_add">+</span>
 	if (opt == NULL)
 		return -EINVAL;
 
 	q-&gt;t_c = psched_get_time();
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	q-&gt;qdisc = &amp;noop_qdisc;</span>
 
 	return tbf_change(sch, opt);
 }
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index bd26a97bcc03..963222e89dbe 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1719,6 +1719,7 @@</span> <span class="p_context"> static int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct</span>
 		return -EMSGSIZE;
 
 	id = nlmsg_data(nlh);
<span class="p_add">+	memset(&amp;id-&gt;sa_id, 0, sizeof(id-&gt;sa_id));</span>
 	memcpy(&amp;id-&gt;sa_id.daddr, &amp;x-&gt;id.daddr,sizeof(x-&gt;id.daddr));
 	id-&gt;sa_id.spi = x-&gt;id.spi;
 	id-&gt;sa_id.family = x-&gt;props.family;
<span class="p_chunk">@@ -2507,6 +2508,7 @@</span> <span class="p_context"> static int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 		struct nlattr *attr;
 
 		id = nlmsg_data(nlh);
<span class="p_add">+		memset(id, 0, sizeof(*id));</span>
 		memcpy(&amp;id-&gt;daddr, &amp;x-&gt;id.daddr, sizeof(id-&gt;daddr));
 		id-&gt;spi = x-&gt;id.spi;
 		id-&gt;family = x-&gt;props.family;
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index d3b2f6ec137a..04c809fb0add 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -847,6 +847,16 @@</span> <span class="p_context"> key_ref_t key_create_or_update(key_ref_t keyring_ref,</span>
 	__key_link_end(keyring, ktype, prealloc);
 	key_type_put(ktype);
 
<span class="p_add">+	key = key_ref_to_ptr(key_ref);</span>
<span class="p_add">+	if (test_bit(KEY_FLAG_USER_CONSTRUCT, &amp;key-&gt;flags)) {</span>
<span class="p_add">+		ret = wait_for_key_construction(key, true);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			key_ref_put(key_ref);</span>
<span class="p_add">+			key_ref = ERR_PTR(ret);</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	key_ref = __key_update(key_ref, payload, plen);
 	goto error;
 }
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 132856b16b8d..fd2de9392252 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1084,7 +1084,7 @@</span> <span class="p_context"> static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,</span>
 		mutex_lock(&amp;ue-&gt;card-&gt;user_ctl_lock);
 		change = ue-&gt;tlv_data_size != size;
 		if (!change)
<span class="p_del">-			change = memcmp(ue-&gt;tlv_data, new_data, size);</span>
<span class="p_add">+			change = memcmp(ue-&gt;tlv_data, new_data, size) != 0;</span>
 		kfree(ue-&gt;tlv_data);
 		ue-&gt;tlv_data = new_data;
 		ue-&gt;tlv_data_size = size;
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index d449dde1bf50..7b5a7902b7a2 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1248,6 +1248,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_info info;
 	struct snd_seq_port_callback *callback;
<span class="p_add">+	int port_idx;</span>
 
 	if (copy_from_user(&amp;info, arg, sizeof(info)))
 		return -EFAULT;
<span class="p_chunk">@@ -1261,7 +1262,9 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 		return -ENOMEM;
 
 	if (client-&gt;type == USER_CLIENT &amp;&amp; info.kernel) {
<span class="p_del">-		snd_seq_delete_port(client, port-&gt;addr.port);</span>
<span class="p_add">+		port_idx = port-&gt;addr.port;</span>
<span class="p_add">+		snd_seq_port_unlock(port);</span>
<span class="p_add">+		snd_seq_delete_port(client, port_idx);</span>
 		return -EINVAL;
 	}
 	if (client-&gt;type == KERNEL_CLIENT) {
<span class="p_chunk">@@ -1283,6 +1286,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 
 	snd_seq_set_port_info(port, &amp;info);
 	snd_seq_system_client_ev_port_start(port-&gt;addr.client, port-&gt;addr.port);
<span class="p_add">+	snd_seq_port_unlock(port);</span>
 
 	if (copy_to_user(arg, &amp;info, sizeof(info)))
 		return -EFAULT;
<span class="p_header">diff --git a/sound/core/seq/seq_lock.c b/sound/core/seq/seq_lock.c</span>
<span class="p_header">index 8a6b7baafa35..d8405d343987 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_lock.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_lock.c</span>
<span class="p_chunk">@@ -23,8 +23,6 @@</span> <span class="p_context"></span>
 #include &lt;sound/core.h&gt;
 #include &quot;seq_lock.h&quot;
 
<span class="p_del">-#if defined(CONFIG_SMP) || defined(CONFIG_SND_DEBUG)</span>
<span class="p_del">-</span>
 /* wait until all locks are released */
 void snd_use_lock_sync_helper(snd_use_lock_t *lockp, const char *file, int line)
 {
<span class="p_chunk">@@ -42,5 +40,3 @@</span> <span class="p_context"> void snd_use_lock_sync_helper(snd_use_lock_t *lockp, const char *file, int line)</span>
 }
 
 EXPORT_SYMBOL(snd_use_lock_sync_helper);
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/sound/core/seq/seq_lock.h b/sound/core/seq/seq_lock.h</span>
<span class="p_header">index 54044bc2c9ef..ac38031c370e 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_lock.h</span>
<span class="p_header">+++ b/sound/core/seq/seq_lock.h</span>
<span class="p_chunk">@@ -3,8 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/sched.h&gt;
 
<span class="p_del">-#if defined(CONFIG_SMP) || defined(CONFIG_SND_DEBUG)</span>
<span class="p_del">-</span>
 typedef atomic_t snd_use_lock_t;
 
 /* initialize lock */
<span class="p_chunk">@@ -20,14 +18,4 @@</span> <span class="p_context"> typedef atomic_t snd_use_lock_t;</span>
 void snd_use_lock_sync_helper(snd_use_lock_t *lock, const char *file, int line);
 #define snd_use_lock_sync(lockp) snd_use_lock_sync_helper(lockp, __BASE_FILE__, __LINE__)
 
<span class="p_del">-#else /* SMP || CONFIG_SND_DEBUG */</span>
<span class="p_del">-</span>
<span class="p_del">-typedef spinlock_t snd_use_lock_t;	/* dummy */</span>
<span class="p_del">-#define snd_use_lock_init(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_use(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_free(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_sync(lockp) /**/</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* SMP || CONFIG_SND_DEBUG */</span>
<span class="p_del">-</span>
 #endif /* __SND_SEQ_LOCK_H */
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index ee0522a8f730..a28d1acad574 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -122,7 +122,9 @@</span> <span class="p_context"> static void port_subs_info_init(struct snd_seq_port_subs_info *grp)</span>
 }
 
 
<span class="p_del">-/* create a port, port number is returned (-1 on failure) */</span>
<span class="p_add">+/* create a port, port number is returned (-1 on failure);</span>
<span class="p_add">+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately</span>
<span class="p_add">+ */</span>
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
<span class="p_chunk">@@ -153,6 +155,7 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	snd_use_lock_init(&amp;new_port-&gt;use_lock);
 	port_subs_info_init(&amp;new_port-&gt;c_src);
 	port_subs_info_init(&amp;new_port-&gt;c_dest);
<span class="p_add">+	snd_use_lock_use(&amp;new_port-&gt;use_lock);</span>
 
 	num = port &gt;= 0 ? port : 0;
 	mutex_lock(&amp;client-&gt;ports_mutex);
<span class="p_chunk">@@ -167,9 +170,9 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	list_add_tail(&amp;new_port-&gt;list, &amp;p-&gt;list);
 	client-&gt;num_ports++;
 	new_port-&gt;addr.port = num;	/* store the port number in the port */
<span class="p_add">+	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 	write_unlock_irqrestore(&amp;client-&gt;ports_lock, flags);
 	mutex_unlock(&amp;client-&gt;ports_mutex);
<span class="p_del">-	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 
 	return new_port;
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index de51abcbb80e..81ac4c154088 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -4498,6 +4498,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x390b, &quot;Lenovo G50-80&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3975, &quot;Lenovo U300s&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;Lenovo IdeaPad U310&quot;, CXT_FIXUP_STEREO_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;Lenovo G50-70&quot;, CXT_FIXUP_STEREO_DMIC),</span>
 	SND_PCI_QUIRK(0x17aa, 0x397b, &quot;Lenovo S205&quot;, CXT_FIXUP_STEREO_DMIC),
 	{}
 };
<span class="p_header">diff --git a/sound/soc/codecs/adau1373.c b/sound/soc/codecs/adau1373.c</span>
<span class="p_header">index 45c63028b40d..396f356221b5 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adau1373.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adau1373.c</span>
<span class="p_chunk">@@ -133,6 +133,8 @@</span> <span class="p_context"> struct adau1373 {</span>
 #define ADAU1373_DAI_FORMAT_DSP		0x3
 
 #define ADAU1373_BCLKDIV_SOURCE		BIT(5)
<span class="p_add">+#define ADAU1373_BCLKDIV_SR_MASK	(0x07 &lt;&lt; 2)</span>
<span class="p_add">+#define ADAU1373_BCLKDIV_BCLK_MASK	0x03</span>
 #define ADAU1373_BCLKDIV_32		0x03
 #define ADAU1373_BCLKDIV_64		0x02
 #define ADAU1373_BCLKDIV_128		0x01
<span class="p_chunk">@@ -937,7 +939,8 @@</span> <span class="p_context"> static int adau1373_hw_params(struct snd_pcm_substream *substream,</span>
 	adau1373_dai-&gt;enable_src = (div != 0);
 
 	snd_soc_update_bits(codec, ADAU1373_BCLKDIV(dai-&gt;id),
<span class="p_del">-		~ADAU1373_BCLKDIV_SOURCE, (div &lt;&lt; 2) | ADAU1373_BCLKDIV_64);</span>
<span class="p_add">+		ADAU1373_BCLKDIV_SR_MASK | ADAU1373_BCLKDIV_BCLK_MASK,</span>
<span class="p_add">+		(div &lt;&lt; 2) | ADAU1373_BCLKDIV_64);</span>
 
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
<span class="p_header">diff --git a/sound/soc/codecs/wm8983.c b/sound/soc/codecs/wm8983.c</span>
<span class="p_header">index 93ee28439be5..f23944d05c63 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8983.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8983.c</span>
<span class="p_chunk">@@ -855,30 +855,33 @@</span> <span class="p_context"> static int wm8983_set_pll(struct snd_soc_dai *dai, int pll_id,</span>
 	struct pll_div pll_div;
 
 	codec = dai-&gt;codec;
<span class="p_del">-	if (freq_in &amp;&amp; freq_out) {</span>
<span class="p_add">+	if (!freq_in || !freq_out) {</span>
<span class="p_add">+		/* disable the PLL */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,</span>
<span class="p_add">+				    WM8983_PLLEN_MASK, 0);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	} else {</span>
 		ret = pll_factors(&amp;pll_div, freq_out * 4 * 2, freq_in);
 		if (ret)
 			return ret;
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* disable the PLL before re-programming it */</span>
<span class="p_del">-	snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,</span>
<span class="p_del">-			    WM8983_PLLEN_MASK, 0);</span>
 
<span class="p_del">-	if (!freq_in || !freq_out)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		/* disable the PLL before re-programming it */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,</span>
<span class="p_add">+				    WM8983_PLLEN_MASK, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* set PLLN and PRESCALE */</span>
<span class="p_add">+		snd_soc_write(codec, WM8983_PLL_N,</span>
<span class="p_add">+			(pll_div.div2 &lt;&lt; WM8983_PLL_PRESCALE_SHIFT)</span>
<span class="p_add">+			| pll_div.n);</span>
<span class="p_add">+		/* set PLLK */</span>
<span class="p_add">+		snd_soc_write(codec, WM8983_PLL_K_3, pll_div.k &amp; 0x1ff);</span>
<span class="p_add">+		snd_soc_write(codec, WM8983_PLL_K_2, (pll_div.k &gt;&gt; 9) &amp; 0x1ff);</span>
<span class="p_add">+		snd_soc_write(codec, WM8983_PLL_K_1, (pll_div.k &gt;&gt; 18));</span>
<span class="p_add">+		/* enable the PLL */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,</span>
<span class="p_add">+					WM8983_PLLEN_MASK, WM8983_PLLEN);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* set PLLN and PRESCALE */</span>
<span class="p_del">-	snd_soc_write(codec, WM8983_PLL_N,</span>
<span class="p_del">-		      (pll_div.div2 &lt;&lt; WM8983_PLL_PRESCALE_SHIFT)</span>
<span class="p_del">-		      | pll_div.n);</span>
<span class="p_del">-	/* set PLLK */</span>
<span class="p_del">-	snd_soc_write(codec, WM8983_PLL_K_3, pll_div.k &amp; 0x1ff);</span>
<span class="p_del">-	snd_soc_write(codec, WM8983_PLL_K_2, (pll_div.k &gt;&gt; 9) &amp; 0x1ff);</span>
<span class="p_del">-	snd_soc_write(codec, WM8983_PLL_K_1, (pll_div.k &gt;&gt; 18));</span>
<span class="p_del">-	/* enable the PLL */</span>
<span class="p_del">-	snd_soc_update_bits(codec, WM8983_POWER_MANAGEMENT_1,</span>
<span class="p_del">-			    WM8983_PLLEN_MASK, WM8983_PLLEN);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8985.c b/sound/soc/codecs/wm8985.c</span>
<span class="p_header">index bae510acdec8..9d79cc7c5ccc 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8985.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8985.c</span>
<span class="p_chunk">@@ -785,33 +785,30 @@</span> <span class="p_context"> static int wm8985_set_pll(struct snd_soc_dai *dai, int pll_id,</span>
 	struct pll_div pll_div;
 
 	codec = dai-&gt;codec;
<span class="p_del">-	if (freq_in &amp;&amp; freq_out) {</span>
<span class="p_add">+	if (!freq_in || !freq_out) {</span>
<span class="p_add">+		/* disable the PLL */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,</span>
<span class="p_add">+				    WM8985_PLLEN_MASK, 0);</span>
<span class="p_add">+	} else {</span>
 		ret = pll_factors(&amp;pll_div, freq_out * 4 * 2, freq_in);
 		if (ret)
 			return ret;
<span class="p_del">-	}</span>
 
<span class="p_del">-	/* disable the PLL before reprogramming it */</span>
<span class="p_del">-	snd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,</span>
<span class="p_del">-			    WM8985_PLLEN_MASK, 0);</span>
<span class="p_del">-	</span>
<span class="p_del">-	if (!freq_in || !freq_out)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* set PLLN and PRESCALE */</span>
<span class="p_del">-	snd_soc_write(codec, WM8985_PLL_N,</span>
<span class="p_del">-		      (pll_div.div2 &lt;&lt; WM8985_PLL_PRESCALE_SHIFT)</span>
<span class="p_del">-		      | pll_div.n);</span>
<span class="p_del">-	/* set PLLK */</span>
<span class="p_del">-	snd_soc_write(codec, WM8985_PLL_K_3, pll_div.k &amp; 0x1ff);</span>
<span class="p_del">-	snd_soc_write(codec, WM8985_PLL_K_2, (pll_div.k &gt;&gt; 9) &amp; 0x1ff);</span>
<span class="p_del">-	snd_soc_write(codec, WM8985_PLL_K_1, (pll_div.k &gt;&gt; 18));</span>
<span class="p_del">-	/* set the source of the clock to be the PLL */</span>
<span class="p_del">-	snd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,</span>
<span class="p_del">-			    WM8985_CLKSEL_MASK, WM8985_CLKSEL);</span>
<span class="p_del">-	/* enable the PLL */</span>
<span class="p_del">-	snd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,</span>
<span class="p_del">-			    WM8985_PLLEN_MASK, WM8985_PLLEN);</span>
<span class="p_add">+		/* set PLLN and PRESCALE */</span>
<span class="p_add">+		snd_soc_write(codec, WM8985_PLL_N,</span>
<span class="p_add">+			      (pll_div.div2 &lt;&lt; WM8985_PLL_PRESCALE_SHIFT)</span>
<span class="p_add">+			      | pll_div.n);</span>
<span class="p_add">+		/* set PLLK */</span>
<span class="p_add">+		snd_soc_write(codec, WM8985_PLL_K_3, pll_div.k &amp; 0x1ff);</span>
<span class="p_add">+		snd_soc_write(codec, WM8985_PLL_K_2, (pll_div.k &gt;&gt; 9) &amp; 0x1ff);</span>
<span class="p_add">+		snd_soc_write(codec, WM8985_PLL_K_1, (pll_div.k &gt;&gt; 18));</span>
<span class="p_add">+		/* set the source of the clock to be the PLL */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8985_CLOCK_GEN_CONTROL,</span>
<span class="p_add">+				    WM8985_CLKSEL_MASK, WM8985_CLKSEL);</span>
<span class="p_add">+		/* enable the PLL */</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8985_POWER_MANAGEMENT_1,</span>
<span class="p_add">+				    WM8985_PLLEN_MASK, WM8985_PLLEN);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c</span>
<span class="p_header">index e44c0e3a89b6..3b26d443507d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm_hubs.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm_hubs.c</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> static void calibrate_dc_servo(struct snd_soc_codec *codec)</span>
 		break;
 	default:
 		WARN(1, &quot;Unknown DCS readback method\n&quot;);
<span class="p_del">-		break;</span>
<span class="p_add">+		return;</span>
 	}
 
 	dev_dbg(codec-&gt;dev, &quot;DCS input: %x %x\n&quot;, reg_l, reg_r);
<span class="p_header">diff --git a/sound/usb/caiaq/device.c b/sound/usb/caiaq/device.c</span>
<span class="p_header">index 3eb605bd9503..88e3f8149e23 100644</span>
<span class="p_header">--- a/sound/usb/caiaq/device.c</span>
<span class="p_header">+++ b/sound/usb/caiaq/device.c</span>
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> static int __devinit snd_probe(struct usb_interface *intf,</span>
 		     const struct usb_device_id *id)
 {
 	int ret;
<span class="p_del">-	struct snd_card *card;</span>
<span class="p_add">+	struct snd_card *card = NULL;</span>
 	struct usb_device *device = interface_to_usbdev(intf);
 
 	ret = create_card(device, intf, &amp;card);
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 413b32d6ef35..aefb62ef814d 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -222,6 +222,7 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	struct usb_interface_descriptor *altsd;
 	void *control_header;
 	int i, protocol;
<span class="p_add">+	int rest_bytes;</span>
 
 	/* find audiocontrol interface */
 	host_iface = &amp;usb_ifnum_to_if(dev, ctrlif)-&gt;altsetting[0];
<span class="p_chunk">@@ -236,6 +237,15 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	rest_bytes = (void *)(host_iface-&gt;extra + host_iface-&gt;extralen) -</span>
<span class="p_add">+		control_header;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* just to be sure -- this shouldn&#39;t hit at all */</span>
<span class="p_add">+	if (rest_bytes &lt;= 0) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;invalid control header\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (protocol) {
 	default:
 		snd_printdd(KERN_WARNING &quot;unknown interface protocol %#02x, assuming v1\n&quot;,
<span class="p_chunk">@@ -245,11 +255,21 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
<span class="p_add">+		if (rest_bytes &lt; sizeof(*h1)) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;too short v1 buffer descriptor\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (!h1-&gt;bInCollection) {
 			snd_printk(KERN_INFO &quot;skipping empty audio interface (v1)\n&quot;);
 			return -EINVAL;
 		}
 
<span class="p_add">+		if (rest_bytes &lt; h1-&gt;bLength) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;invalid buffer length (v1)\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (h1-&gt;bLength &lt; sizeof(*h1) + h1-&gt;bInCollection) {
 			snd_printk(KERN_ERR &quot;invalid UAC_HEADER (v1)\n&quot;);
 			return -EINVAL;
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 9c36a1ff3172..a489f2fbe4d8 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -515,6 +515,8 @@</span> <span class="p_context"> static int mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,</span>
 
 	if (size &lt; sizeof(scale))
 		return -ENOMEM;
<span class="p_add">+	if (cval-&gt;min_mute)</span>
<span class="p_add">+		scale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;</span>
 	scale[2] = cval-&gt;dBmin;
 	scale[3] = cval-&gt;dBmax;
 	if (copy_to_user(_tlv, scale, sizeof(scale)))
<span class="p_chunk">@@ -1983,6 +1985,9 @@</span> <span class="p_context"> static int parse_audio_unit(struct mixer_build *state, int unitid)</span>
 
 static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)
 {
<span class="p_add">+	/* kill pending URBs */</span>
<span class="p_add">+	snd_usb_mixer_disconnect(&amp;mixer-&gt;list);</span>
<span class="p_add">+</span>
 	kfree(mixer-&gt;id_elems);
 	if (mixer-&gt;urb) {
 		kfree(mixer-&gt;urb-&gt;transfer_buffer);
<span class="p_chunk">@@ -2329,6 +2334,11 @@</span> <span class="p_context"> void snd_usb_mixer_disconnect(struct list_head *p)</span>
 	struct usb_mixer_interface *mixer;
 
 	mixer = list_entry(p, struct usb_mixer_interface, list);
<span class="p_del">-	usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_del">-	usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	if (mixer-&gt;disconnected)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (mixer-&gt;urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_add">+	if (mixer-&gt;rc_urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	mixer-&gt;disconnected = true;</span>
 }
<span class="p_header">diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h</span>
<span class="p_header">index 81b2d8a32fb0..7b6b6832ec21 100644</span>
<span class="p_header">--- a/sound/usb/mixer.h</span>
<span class="p_header">+++ b/sound/usb/mixer.h</span>
<span class="p_chunk">@@ -23,6 +23,8 @@</span> <span class="p_context"> struct usb_mixer_interface {</span>
 
 	u8 audigy2nx_leds[3];
 	u8 xonar_u1_status;
<span class="p_add">+</span>
<span class="p_add">+	bool disconnected;</span>
 };
 
 #define MAX_CHANNELS	16	/* max logical channels */
<span class="p_chunk">@@ -52,6 +54,7 @@</span> <span class="p_context"> struct usb_mixer_elem_info {</span>
 	int cached;
 	int cache_val[MAX_CHANNELS];
 	u8 initialized;
<span class="p_add">+	u8 min_mute;</span>
 };
 
 int snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index d422d162724a..ee1a148b22a1 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -726,6 +726,12 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)
 			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);
 		break;
<span class="p_add">+	/* lowest playback value is muted on C-Media devices */</span>
<span class="p_add">+	case USB_ID(0x0d8c, 0x000c):</span>
<span class="p_add">+	case USB_ID(0x0d8c, 0x0014):</span>
<span class="p_add">+		if (strstr(kctl-&gt;id.name, &quot;Playback&quot;))</span>
<span class="p_add">+			cval-&gt;min_mute = 1;</span>
<span class="p_add">+		break;</span>
 	}
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



