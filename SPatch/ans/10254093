
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v8,3/5] iommu/arm-smmu: Invoke pm_runtime during probe, add/remove device - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v8,3/5] iommu/arm-smmu: Invoke pm_runtime during probe, add/remove device</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=170013">Vivek Gautam</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 2, 2018, 10:10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180302101050.6191-4-vivek.gautam@codeaurora.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10254093/mbox/"
   >mbox</a>
|
   <a href="/patch/10254093/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10254093/">/patch/10254093/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	0AEAD6037F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Mar 2018 10:11:33 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E3EB328931
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Mar 2018 10:11:32 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D831C2893C; Fri,  2 Mar 2018 10:11:32 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.8 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 36B4D28931
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  2 Mar 2018 10:11:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1426240AbeCBKL1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 2 Mar 2018 05:11:27 -0500
Received: from smtp.codeaurora.org ([198.145.29.96]:46928 &quot;EHLO
	smtp.codeaurora.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1426224AbeCBKLU (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 2 Mar 2018 05:11:20 -0500
Received: by smtp.codeaurora.org (Postfix, from userid 1000)
	id B48AC6074C; Fri,  2 Mar 2018 10:11:19 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=codeaurora.org;
	s=default; t=1519985479;
	bh=Tm1vg9amY0vXe3hsi35XDevCO3/k2lFKTL34QHn9cNY=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=cEKdqL3AHuMEa13H/rv77PahiM/8UE44Zij0YJbozIkYM4szcxLz+8p5fZl90DtSc
	gn0yHqX4ww6XEwltExiP8NIdrAONBEWXJWa/0NYNqEnOoNBkTBoc5Q/N8+DLea6ofJ
	H061X87/1i6OwU72I+u+PQv4DxiJg4hijEy1N9GI=
Received: from blr-ubuntu-41.ap.qualcomm.com
	(blr-bdr-fw-01_globalnat_allzones-outside.qualcomm.com
	[103.229.18.19])
	(using TLSv1.1 with cipher ECDHE-RSA-AES128-SHA (128/128 bits))
	(No client certificate requested)
	(Authenticated sender: vivek.gautam@smtp.codeaurora.org)
	by smtp.codeaurora.org (Postfix) with ESMTPSA id 3D46260316;
	Fri,  2 Mar 2018 10:11:13 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=codeaurora.org;
	s=default; t=1519985477;
	bh=Tm1vg9amY0vXe3hsi35XDevCO3/k2lFKTL34QHn9cNY=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=N4tn94jxvi044NLscub/e6AskSj55ce2kIlEZXQQixgygXnAHNguVsEsq8WaaVale
	+z8yMQW/vvLdRwDItM3YUjY/hjGddL9H+bKt/71mbAxliv45rTrhKMd0ApuvlLRMo7
	EfBPc0tpT8DyqzR3Dr1eC0zWzuIJ+AKKPwCsMy4c=
DMARC-Filter: OpenDMARC Filter v1.3.2 smtp.codeaurora.org 3D46260316
Authentication-Results: pdx-caf-mail.web.codeaurora.org;
	dmarc=none (p=none dis=none)
	header.from=codeaurora.org
Authentication-Results: pdx-caf-mail.web.codeaurora.org;
	spf=none smtp.mailfrom=vivek.gautam@codeaurora.org
From: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;
To: joro@8bytes.org, robh+dt@kernel.org, mark.rutland@arm.com,
	rjw@rjwysocki.net, robin.murphy@arm.com, will.deacon@arm.com,
	robdclark@gmail.com, iommu@lists.linux-foundation.org,
	devicetree@vger.kernel.org, linux-kernel@vger.kernel.org
Cc: tfiga@chromium.org, jcrouse@codeaurora.org, sboyd@codeaurora.org,
	sricharan@codeaurora.org, m.szyprowski@samsung.com,
	architt@codeaurora.org, linux-arm-msm@vger.kernel.org,
	vivek.gautam@codeaurora.org
Subject: [PATCH v8 3/5] iommu/arm-smmu: Invoke pm_runtime during probe,
	add/remove device
Date: Fri,  2 Mar 2018 15:40:48 +0530
Message-Id: &lt;20180302101050.6191-4-vivek.gautam@codeaurora.org&gt;
X-Mailer: git-send-email 2.16.1.72.g5be1f00a9a70
In-Reply-To: &lt;20180302101050.6191-1-vivek.gautam@codeaurora.org&gt;
References: &lt;20180302101050.6191-1-vivek.gautam@codeaurora.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170013">Vivek Gautam</a> - March 2, 2018, 10:10 a.m.</div>
<pre class="content">
<span class="from">From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>

The smmu device probe/remove and add/remove master device callbacks
gets called when the smmu is not linked to its master, that is without
the context of the master device. So calling runtime apis in those places
separately.
<span class="signed-off-by">
Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
[vivek: Cleanup pm runtime calls]
<span class="signed-off-by">Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
---
 drivers/iommu/arm-smmu.c | 96 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 88 insertions(+), 8 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - March 7, 2018, 12:38 p.m.</div>
<pre class="content">
On 02/03/18 10:10, Vivek Gautam wrote:
<span class="quote">&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt; the context of the master device. So calling runtime apis in those places</span>
<span class="quote">&gt; separately.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;   drivers/iommu/arm-smmu.c | 96 ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;   1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;   	struct clk_bulk_data		*clks;</span>
<span class="quote">&gt;   	int				num_clks;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	bool				rpm_supported;</span>
<span class="quote">&gt; +</span>

Can we not automatically infer this from whether clocks and/or power 
domains are specified or not, then just use pm_runtime_enabled() as the 
fast-path check as Tomasz originally proposed?

I worry that relying on statically-defined matchdata is just going to 
blow up the driver and DT binding into a maintenance nightmare; I really 
don&#39;t want to start needing separate definitions for e.g. 
&quot;arm,juno-etr-mmu-401&quot; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one 
otherwise-identical instance within the SoC is in a separate 
controllable power domain while the others aren&#39;t.

Robin.
<span class="quote">
&gt;   	u32				cavium_id_base; /* Specific to Cavium */</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	spinlock_t			global_sync_lock;</span>
<span class="quote">&gt; @@ -268,6 +270,20 @@ static struct arm_smmu_option_prop arm_smmu_options[] = {</span>
<span class="quote">&gt;   	{ 0, NULL},</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +static inline int arm_smmu_rpm_get(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (smmu-&gt;rpm_supported)</span>
<span class="quote">&gt; +		return pm_runtime_get_sync(smmu-&gt;dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline void arm_smmu_rpm_put(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (smmu-&gt;rpm_supported)</span>
<span class="quote">&gt; +		pm_runtime_put(smmu-&gt;dev);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   static struct arm_smmu_domain *to_smmu_domain(struct iommu_domain *dom)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	return container_of(dom, struct arm_smmu_domain, domain);</span>
<span class="quote">&gt; @@ -913,11 +929,15 @@ static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
<span class="quote">&gt;   	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt;   	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt;   	struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;</span>
<span class="quote">&gt; -	int irq;</span>
<span class="quote">&gt; +	int ret, irq;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!smmu || domain-&gt;type == IOMMU_DOMAIN_IDENTITY)</span>
<span class="quote">&gt;   		return;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * Disable the context bank and free the page tables before freeing</span>
<span class="quote">&gt;   	 * it.</span>
<span class="quote">&gt; @@ -932,6 +952,8 @@ static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	free_io_pgtable_ops(smmu_domain-&gt;pgtbl_ops);</span>
<span class="quote">&gt;   	__arm_smmu_free_bitmap(smmu-&gt;context_map, cfg-&gt;cbndx);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static struct iommu_domain *arm_smmu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; @@ -1213,10 +1235,15 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
<span class="quote">&gt;   		return -ENODEV;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	smmu = fwspec_smmu(fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/* Ensure that the domain is finalised */</span>
<span class="quote">&gt;   	ret = arm_smmu_init_domain_context(domain, smmu);</span>
<span class="quote">&gt;   	if (ret &lt; 0)</span>
<span class="quote">&gt; -		return ret;</span>
<span class="quote">&gt; +		goto rpm_put;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * Sanity check the domain. We don&#39;t support domains across</span>
<span class="quote">&gt; @@ -1231,10 +1258,17 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	/* Looks ok, so add the device to the domain */</span>
<span class="quote">&gt; -	return arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt; +	ret = arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   destroy_domain:</span>
<span class="quote">&gt;   	arm_smmu_destroy_domain_context(domain);</span>
<span class="quote">&gt; +rpm_put:</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; @@ -1242,22 +1276,36 @@ static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt;   			phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt; +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt; +	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!ops)</span>
<span class="quote">&gt;   		return -ENODEV;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	return ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	ret = ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static size_t arm_smmu_unmap(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt;   			     size_t size)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt; +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt; +	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt; +	size_t ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!ops)</span>
<span class="quote">&gt;   		return 0;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	return ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	ret = ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static void arm_smmu_iotlb_sync(struct iommu_domain *domain)</span>
<span class="quote">&gt; @@ -1412,14 +1460,22 @@ static int arm_smmu_add_device(struct device *dev)</span>
<span class="quote">&gt;   	while (i--)</span>
<span class="quote">&gt;   		cfg-&gt;smendx[i] = INVALID_SMENDX;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		goto out_cfg_free;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	ret = arm_smmu_master_alloc_smes(dev);</span>
<span class="quote">&gt;   	if (ret)</span>
<span class="quote">&gt; -		goto out_cfg_free;</span>
<span class="quote">&gt; +		goto out_rpm_put;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	iommu_device_link(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	return 0;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +out_rpm_put:</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;   out_cfg_free:</span>
<span class="quote">&gt;   	kfree(cfg);</span>
<span class="quote">&gt;   out_free:</span>
<span class="quote">&gt; @@ -1432,7 +1488,7 @@ static void arm_smmu_remove_device(struct device *dev)</span>
<span class="quote">&gt;   	struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;</span>
<span class="quote">&gt;   	struct arm_smmu_master_cfg *cfg;</span>
<span class="quote">&gt;   	struct arm_smmu_device *smmu;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!fwspec || fwspec-&gt;ops != &amp;arm_smmu_ops)</span>
<span class="quote">&gt;   		return;</span>
<span class="quote">&gt; @@ -1440,8 +1496,15 @@ static void arm_smmu_remove_device(struct device *dev)</span>
<span class="quote">&gt;   	cfg  = fwspec-&gt;iommu_priv;</span>
<span class="quote">&gt;   	smmu = cfg-&gt;smmu;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	iommu_device_unlink(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;   	arm_smmu_master_free_smes(fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	iommu_group_remove_device(dev);</span>
<span class="quote">&gt;   	kfree(fwspec-&gt;iommu_priv);</span>
<span class="quote">&gt;   	iommu_fwspec_free(dev);</span>
<span class="quote">&gt; @@ -1907,6 +1970,7 @@ struct arm_smmu_match_data {</span>
<span class="quote">&gt;   	enum arm_smmu_implementation model;</span>
<span class="quote">&gt;   	const char * const *clks;</span>
<span class="quote">&gt;   	int num_clks;</span>
<span class="quote">&gt; +	bool rpm_supported;</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   #define ARM_SMMU_MATCH_DATA(name, ver, imp)	\</span>
<span class="quote">&gt; @@ -2029,6 +2093,7 @@ static int arm_smmu_device_dt_probe(struct platform_device *pdev,</span>
<span class="quote">&gt;   	smmu-&gt;version = data-&gt;version;</span>
<span class="quote">&gt;   	smmu-&gt;model = data-&gt;model;</span>
<span class="quote">&gt;   	smmu-&gt;num_clks = data-&gt;num_clks;</span>
<span class="quote">&gt; +	smmu-&gt;rpm_supported = data-&gt;rpm_supported;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	arm_smmu_fill_clk_data(smmu, data-&gt;clks);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; @@ -2129,6 +2194,8 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   		smmu-&gt;irqs[i] = irq;</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	err = devm_clk_bulk_get(smmu-&gt;dev, smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt; @@ -2137,6 +2204,13 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	if (smmu-&gt;rpm_supported)</span>
<span class="quote">&gt; +		pm_runtime_enable(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (err &lt; 0)</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	err = arm_smmu_device_cfg_probe(smmu);</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt; @@ -2178,10 +2252,11 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt;   	arm_smmu_device_reset(smmu);</span>
<span class="quote">&gt;   	arm_smmu_test_smr_masks(smmu);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * For ACPI and generic DT bindings, an SMMU will be probed before</span>
<span class="quote">&gt;   	 * any device which might need it, so we want the bus ops in place</span>
<span class="quote">&gt; @@ -2217,9 +2292,14 @@ static int arm_smmu_device_remove(struct platform_device *pdev)</span>
<span class="quote">&gt;   	if (!bitmap_empty(smmu-&gt;context_map, ARM_SMMU_MAX_CBS))</span>
<span class="quote">&gt;   		dev_err(&amp;pdev-&gt;dev, &quot;removing device with active domains!\n&quot;);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;   	/* Turn the thing off */</span>
<span class="quote">&gt;   	writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +	if (smmu-&gt;rpm_supported)</span>
<span class="quote">&gt; +		pm_runtime_disable(smmu-&gt;dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	clk_bulk_unprepare(smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	return 0;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=117291">Tomasz Figa</a> - March 7, 2018, 1:52 p.m.</div>
<pre class="content">
On Wed, Mar 7, 2018 at 9:38 PM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:
<span class="quote">&gt; On 02/03/18 10:10, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt; the context of the master device. So calling runtime apis in those places</span>
<span class="quote">&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;   drivers/iommu/arm-smmu.c | 96</span>
<span class="quote">&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;   1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;&gt;         struct clk_bulk_data            *clks;</span>
<span class="quote">&gt;&gt;         int                             num_clks;</span>
<span class="quote">&gt;&gt;   +     bool                            rpm_supported;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can we not automatically infer this from whether clocks and/or power domains</span>
<span class="quote">&gt; are specified or not, then just use pm_runtime_enabled() as the fast-path</span>
<span class="quote">&gt; check as Tomasz originally proposed?</span>

I wouldn&#39;t tie this to presence of clocks, since as a next step we
would want to actually control the clocks separately. (As far as I
understand, on QCom SoCs we might want to have runtime PM active for
the translation to work, but clocks gated whenever access to SMMU
registers is not needed.) Moreover, you might still have some super
high scale thousand-core systems that require clocks to be
prepare-enabled, but runtime PM would be undesirable for the reasons
we discussed before.
<span class="quote">
&gt;</span>
<span class="quote">&gt; I worry that relying on statically-defined matchdata is just going to blow</span>
<span class="quote">&gt; up the driver and DT binding into a maintenance nightmare; I really don&#39;t</span>
<span class="quote">&gt; want to start needing separate definitions for e.g. &quot;arm,juno-etr-mmu-401&quot;</span>
<span class="quote">&gt; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one otherwise-identical instance</span>
<span class="quote">&gt; within the SoC is in a separate controllable power domain while the others</span>
<span class="quote">&gt; aren&#39;t.</span>

I don&#39;t see a reason why both couldn&#39;t just have RPM supported
regardless of whether there is a real power domain. It would
effectively be just a no-op for those that don&#39;t have one. IMHO the
only reason to avoid having the RPM enabled is the scalability issue
we discussed before.

Best regards,
Tomasz
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - March 7, 2018, 4:58 p.m.</div>
<pre class="content">
On 07/03/18 13:52, Tomasz Figa wrote:
<span class="quote">&gt; On Wed, Mar 7, 2018 at 9:38 PM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On 02/03/18 10:10, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt;&gt; the context of the master device. So calling runtime apis in those places</span>
<span class="quote">&gt;&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;    drivers/iommu/arm-smmu.c | 96</span>
<span class="quote">&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;&gt;    1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;&gt;&gt;          struct clk_bulk_data            *clks;</span>
<span class="quote">&gt;&gt;&gt;          int                             num_clks;</span>
<span class="quote">&gt;&gt;&gt;    +     bool                            rpm_supported;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Can we not automatically infer this from whether clocks and/or power domains</span>
<span class="quote">&gt;&gt; are specified or not, then just use pm_runtime_enabled() as the fast-path</span>
<span class="quote">&gt;&gt; check as Tomasz originally proposed?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I wouldn&#39;t tie this to presence of clocks, since as a next step we</span>
<span class="quote">&gt; would want to actually control the clocks separately. (As far as I</span>
<span class="quote">&gt; understand, on QCom SoCs we might want to have runtime PM active for</span>
<span class="quote">&gt; the translation to work, but clocks gated whenever access to SMMU</span>
<span class="quote">&gt; registers is not needed.) Moreover, you might still have some super</span>
<span class="quote">&gt; high scale thousand-core systems that require clocks to be</span>
<span class="quote">&gt; prepare-enabled, but runtime PM would be undesirable for the reasons</span>
<span class="quote">&gt; we discussed before.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I worry that relying on statically-defined matchdata is just going to blow</span>
<span class="quote">&gt;&gt; up the driver and DT binding into a maintenance nightmare; I really don&#39;t</span>
<span class="quote">&gt;&gt; want to start needing separate definitions for e.g. &quot;arm,juno-etr-mmu-401&quot;</span>
<span class="quote">&gt;&gt; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one otherwise-identical instance</span>
<span class="quote">&gt;&gt; within the SoC is in a separate controllable power domain while the others</span>
<span class="quote">&gt;&gt; aren&#39;t.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t see a reason why both couldn&#39;t just have RPM supported</span>
<span class="quote">&gt; regardless of whether there is a real power domain. It would</span>
<span class="quote">&gt; effectively be just a no-op for those that don&#39;t have one.</span>

Because you&#39;re then effectively defining &quot;compatible&quot; values for the 
sake of attaching software policy to them, rather than actually 
describing different hardware implementations.

The fact that RPM can&#39;t do anything meaningful unless relevant 
clock/power aspects *are* described, however, means that we shouldn&#39;t 
need additional information redundant with that. Much like the fact that 
we don&#39;t *already* have an &quot;arm,juno-hdlcd-mmu-401&quot; compatible to 
account for those being integrated such that IDR0.CTTW has the wrong 
value, since the presence or not of the &quot;dma-coherent&quot; property already 
describes the truth in that regard.
<span class="quote">
&gt; IMHO the</span>
<span class="quote">&gt; only reason to avoid having the RPM enabled is the scalability issue</span>
<span class="quote">&gt; we discussed before.</span>

Yes, but that&#39;s kind of my point; in reality high throughput/minimal 
latency and aggressive power management are more or less mutually 
exclusive. Mobile SoCs with fine-grained clock trees and power domains 
won&#39;t have multiple 40GBe/NVMf/whatever links running flat out in 
parallel; conversely networking/infrastructure/server SoCs aren&#39;t 
designed around saving every last microamp of leakage current - even in 
the (fairly unlikely) case of the interconnect clocks being 
software-gateable at all I would be very surprised if that were ever 
exposed directly to Linux (FWIW I believe ACPI essentially *requires* 
clocks to be abstracted behind firmware).

Realistically then, explicit clocks are only expected on systems which 
care about power management. We can always revisit that assumption if 
anything crazy where it isn&#39;t the case ever becomes non-theoretical, but 
for now it&#39;s one I&#39;m entirely comfortable with. If on the other hand it 
turns out that we can rely on just a power domain being present wherever 
we want RPM, making clocks moot, then all the better.

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=117291">Tomasz Figa</a> - March 8, 2018, 4:33 a.m.</div>
<pre class="content">
On Thu, Mar 8, 2018 at 1:58 AM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:
<span class="quote">&gt; On 07/03/18 13:52, Tomasz Figa wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Wed, Mar 7, 2018 at 9:38 PM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 02/03/18 10:10, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt;&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt;&gt;&gt; the context of the master device. So calling runtime apis in those</span>
<span class="quote">&gt;&gt;&gt;&gt; places</span>
<span class="quote">&gt;&gt;&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt;    drivers/iommu/arm-smmu.c | 96</span>
<span class="quote">&gt;&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;&gt;&gt;    1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;&gt;&gt;&gt;          struct clk_bulk_data            *clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;          int                             num_clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;    +     bool                            rpm_supported;</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Can we not automatically infer this from whether clocks and/or power</span>
<span class="quote">&gt;&gt;&gt; domains</span>
<span class="quote">&gt;&gt;&gt; are specified or not, then just use pm_runtime_enabled() as the fast-path</span>
<span class="quote">&gt;&gt;&gt; check as Tomasz originally proposed?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I wouldn&#39;t tie this to presence of clocks, since as a next step we</span>
<span class="quote">&gt;&gt; would want to actually control the clocks separately. (As far as I</span>
<span class="quote">&gt;&gt; understand, on QCom SoCs we might want to have runtime PM active for</span>
<span class="quote">&gt;&gt; the translation to work, but clocks gated whenever access to SMMU</span>
<span class="quote">&gt;&gt; registers is not needed.) Moreover, you might still have some super</span>
<span class="quote">&gt;&gt; high scale thousand-core systems that require clocks to be</span>
<span class="quote">&gt;&gt; prepare-enabled, but runtime PM would be undesirable for the reasons</span>
<span class="quote">&gt;&gt; we discussed before.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I worry that relying on statically-defined matchdata is just going to</span>
<span class="quote">&gt;&gt;&gt; blow</span>
<span class="quote">&gt;&gt;&gt; up the driver and DT binding into a maintenance nightmare; I really don&#39;t</span>
<span class="quote">&gt;&gt;&gt; want to start needing separate definitions for e.g.</span>
<span class="quote">&gt;&gt;&gt; &quot;arm,juno-etr-mmu-401&quot;</span>
<span class="quote">&gt;&gt;&gt; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one otherwise-identical</span>
<span class="quote">&gt;&gt;&gt; instance</span>
<span class="quote">&gt;&gt;&gt; within the SoC is in a separate controllable power domain while the</span>
<span class="quote">&gt;&gt;&gt; others</span>
<span class="quote">&gt;&gt;&gt; aren&#39;t.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I don&#39;t see a reason why both couldn&#39;t just have RPM supported</span>
<span class="quote">&gt;&gt; regardless of whether there is a real power domain. It would</span>
<span class="quote">&gt;&gt; effectively be just a no-op for those that don&#39;t have one.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Because you&#39;re then effectively defining &quot;compatible&quot; values for the sake of</span>
<span class="quote">&gt; attaching software policy to them, rather than actually describing different</span>
<span class="quote">&gt; hardware implementations.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The fact that RPM can&#39;t do anything meaningful unless relevant clock/power</span>
<span class="quote">&gt; aspects *are* described, however, means that we shouldn&#39;t need additional</span>
<span class="quote">&gt; information redundant with that. Much like the fact that we don&#39;t *already*</span>
<span class="quote">&gt; have an &quot;arm,juno-hdlcd-mmu-401&quot; compatible to account for those being</span>
<span class="quote">&gt; integrated such that IDR0.CTTW has the wrong value, since the presence or</span>
<span class="quote">&gt; not of the &quot;dma-coherent&quot; property already describes the truth in that</span>
<span class="quote">&gt; regard.</span>

Fair enough.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; IMHO the</span>
<span class="quote">&gt;&gt; only reason to avoid having the RPM enabled is the scalability issue</span>
<span class="quote">&gt;&gt; we discussed before.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, but that&#39;s kind of my point; in reality high throughput/minimal latency</span>
<span class="quote">&gt; and aggressive power management are more or less mutually exclusive. Mobile</span>
<span class="quote">&gt; SoCs with fine-grained clock trees and power domains won&#39;t have multiple</span>
<span class="quote">&gt; 40GBe/NVMf/whatever links running flat out in parallel; conversely</span>
<span class="quote">&gt; networking/infrastructure/server SoCs aren&#39;t designed around saving every</span>
<span class="quote">&gt; last microamp of leakage current - even in the (fairly unlikely) case of the</span>
<span class="quote">&gt; interconnect clocks being software-gateable at all I would be very surprised</span>
<span class="quote">&gt; if that were ever exposed directly to Linux (FWIW I believe ACPI essentially</span>
<span class="quote">&gt; *requires* clocks to be abstracted behind firmware).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Realistically then, explicit clocks are only expected on systems which care</span>
<span class="quote">&gt; about power management. We can always revisit that assumption if anything</span>
<span class="quote">&gt; crazy where it isn&#39;t the case ever becomes non-theoretical, but for now it&#39;s</span>
<span class="quote">&gt; one I&#39;m entirely comfortable with. If on the other hand it turns out that we</span>
<span class="quote">&gt; can rely on just a power domain being present wherever we want RPM, making</span>
<span class="quote">&gt; clocks moot, then all the better.</span>

Alright. Since Qcom would be the only user of clock and power handling
for the time being, I think checking power domain presence could work
for us. +/- the fact that clocks need to be handled even if power
domain is not present, but we should normally always have both.

Now we need a way to do the check. Perhaps for the time being it would
be enough to just check for the power-domains property in DT?

Best regards,
Tomasz
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - March 8, 2018, 12:12 p.m.</div>
<pre class="content">
On 08/03/18 04:33, Tomasz Figa wrote:
<span class="quote">&gt; On Thu, Mar 8, 2018 at 1:58 AM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On 07/03/18 13:52, Tomasz Figa wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On Wed, Mar 7, 2018 at 9:38 PM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; On 02/03/18 10:10, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; the context of the master device. So calling runtime apis in those</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; places</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;     drivers/iommu/arm-smmu.c | 96</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;     1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;           struct clk_bulk_data            *clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;           int                             num_clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;     +     bool                            rpm_supported;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Can we not automatically infer this from whether clocks and/or power</span>
<span class="quote">&gt;&gt;&gt;&gt; domains</span>
<span class="quote">&gt;&gt;&gt;&gt; are specified or not, then just use pm_runtime_enabled() as the fast-path</span>
<span class="quote">&gt;&gt;&gt;&gt; check as Tomasz originally proposed?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I wouldn&#39;t tie this to presence of clocks, since as a next step we</span>
<span class="quote">&gt;&gt;&gt; would want to actually control the clocks separately. (As far as I</span>
<span class="quote">&gt;&gt;&gt; understand, on QCom SoCs we might want to have runtime PM active for</span>
<span class="quote">&gt;&gt;&gt; the translation to work, but clocks gated whenever access to SMMU</span>
<span class="quote">&gt;&gt;&gt; registers is not needed.) Moreover, you might still have some super</span>
<span class="quote">&gt;&gt;&gt; high scale thousand-core systems that require clocks to be</span>
<span class="quote">&gt;&gt;&gt; prepare-enabled, but runtime PM would be undesirable for the reasons</span>
<span class="quote">&gt;&gt;&gt; we discussed before.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I worry that relying on statically-defined matchdata is just going to</span>
<span class="quote">&gt;&gt;&gt;&gt; blow</span>
<span class="quote">&gt;&gt;&gt;&gt; up the driver and DT binding into a maintenance nightmare; I really don&#39;t</span>
<span class="quote">&gt;&gt;&gt;&gt; want to start needing separate definitions for e.g.</span>
<span class="quote">&gt;&gt;&gt;&gt; &quot;arm,juno-etr-mmu-401&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one otherwise-identical</span>
<span class="quote">&gt;&gt;&gt;&gt; instance</span>
<span class="quote">&gt;&gt;&gt;&gt; within the SoC is in a separate controllable power domain while the</span>
<span class="quote">&gt;&gt;&gt;&gt; others</span>
<span class="quote">&gt;&gt;&gt;&gt; aren&#39;t.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I don&#39;t see a reason why both couldn&#39;t just have RPM supported</span>
<span class="quote">&gt;&gt;&gt; regardless of whether there is a real power domain. It would</span>
<span class="quote">&gt;&gt;&gt; effectively be just a no-op for those that don&#39;t have one.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Because you&#39;re then effectively defining &quot;compatible&quot; values for the sake of</span>
<span class="quote">&gt;&gt; attaching software policy to them, rather than actually describing different</span>
<span class="quote">&gt;&gt; hardware implementations.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The fact that RPM can&#39;t do anything meaningful unless relevant clock/power</span>
<span class="quote">&gt;&gt; aspects *are* described, however, means that we shouldn&#39;t need additional</span>
<span class="quote">&gt;&gt; information redundant with that. Much like the fact that we don&#39;t *already*</span>
<span class="quote">&gt;&gt; have an &quot;arm,juno-hdlcd-mmu-401&quot; compatible to account for those being</span>
<span class="quote">&gt;&gt; integrated such that IDR0.CTTW has the wrong value, since the presence or</span>
<span class="quote">&gt;&gt; not of the &quot;dma-coherent&quot; property already describes the truth in that</span>
<span class="quote">&gt;&gt; regard.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fair enough.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; IMHO the</span>
<span class="quote">&gt;&gt;&gt; only reason to avoid having the RPM enabled is the scalability issue</span>
<span class="quote">&gt;&gt;&gt; we discussed before.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Yes, but that&#39;s kind of my point; in reality high throughput/minimal latency</span>
<span class="quote">&gt;&gt; and aggressive power management are more or less mutually exclusive. Mobile</span>
<span class="quote">&gt;&gt; SoCs with fine-grained clock trees and power domains won&#39;t have multiple</span>
<span class="quote">&gt;&gt; 40GBe/NVMf/whatever links running flat out in parallel; conversely</span>
<span class="quote">&gt;&gt; networking/infrastructure/server SoCs aren&#39;t designed around saving every</span>
<span class="quote">&gt;&gt; last microamp of leakage current - even in the (fairly unlikely) case of the</span>
<span class="quote">&gt;&gt; interconnect clocks being software-gateable at all I would be very surprised</span>
<span class="quote">&gt;&gt; if that were ever exposed directly to Linux (FWIW I believe ACPI essentially</span>
<span class="quote">&gt;&gt; *requires* clocks to be abstracted behind firmware).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Realistically then, explicit clocks are only expected on systems which care</span>
<span class="quote">&gt;&gt; about power management. We can always revisit that assumption if anything</span>
<span class="quote">&gt;&gt; crazy where it isn&#39;t the case ever becomes non-theoretical, but for now it&#39;s</span>
<span class="quote">&gt;&gt; one I&#39;m entirely comfortable with. If on the other hand it turns out that we</span>
<span class="quote">&gt;&gt; can rely on just a power domain being present wherever we want RPM, making</span>
<span class="quote">&gt;&gt; clocks moot, then all the better.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Alright. Since Qcom would be the only user of clock and power handling</span>
<span class="quote">&gt; for the time being, I think checking power domain presence could work</span>
<span class="quote">&gt; for us. +/- the fact that clocks need to be handled even if power</span>
<span class="quote">&gt; domain is not present, but we should normally always have both.</span>

Great! (the issue of Qcom-specific clock handling is a separate argument 
which I don&#39;t feel like reigniting just now...)
<span class="quote">
&gt; Now we need a way to do the check. Perhaps for the time being it would</span>
<span class="quote">&gt; be enough to just check for the power-domains property in DT?</span>

AFAICS, it might be as simple as arm_smmu_probe() doing this:

	/*
	 * We want to avoid touching dev-&gt;power.lock in fastpaths unless
	 * it&#39;s really going to do something useful - pm_runtime_enabled()
	 * can serve as an ideal proxy for that decision.
	 */
	if (dev-&gt;pm_domain)
		pm_runtime_enable(dev);

or maybe even just gate all the calls with &quot;if (smmu-&gt;dev.pm_domain)&quot; 
directly (like pcie-mediatek does), but I&#39;m not sure which would be 
conceptually cleaner.

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=117291">Tomasz Figa</a> - March 9, 2018, 4:50 a.m.</div>
<pre class="content">
On Thu, Mar 8, 2018 at 9:12 PM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:
<span class="quote">&gt; On 08/03/18 04:33, Tomasz Figa wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Thu, Mar 8, 2018 at 1:58 AM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 07/03/18 13:52, Tomasz Figa wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; On Wed, Mar 7, 2018 at 9:38 PM, Robin Murphy &lt;robin.murphy@arm.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On 02/03/18 10:10, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; the context of the master device. So calling runtime apis in those</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; places</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;     drivers/iommu/arm-smmu.c | 96</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;     1 file changed, 88 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; index c8b16f53f597..3d6a1875431f 100644</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; @@ -209,6 +209,8 @@ struct arm_smmu_device {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;           struct clk_bulk_data            *clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;           int                             num_clks;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;     +     bool                            rpm_supported;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Can we not automatically infer this from whether clocks and/or power</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; domains</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; are specified or not, then just use pm_runtime_enabled() as the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; fast-path</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; check as Tomasz originally proposed?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I wouldn&#39;t tie this to presence of clocks, since as a next step we</span>
<span class="quote">&gt;&gt;&gt;&gt; would want to actually control the clocks separately. (As far as I</span>
<span class="quote">&gt;&gt;&gt;&gt; understand, on QCom SoCs we might want to have runtime PM active for</span>
<span class="quote">&gt;&gt;&gt;&gt; the translation to work, but clocks gated whenever access to SMMU</span>
<span class="quote">&gt;&gt;&gt;&gt; registers is not needed.) Moreover, you might still have some super</span>
<span class="quote">&gt;&gt;&gt;&gt; high scale thousand-core systems that require clocks to be</span>
<span class="quote">&gt;&gt;&gt;&gt; prepare-enabled, but runtime PM would be undesirable for the reasons</span>
<span class="quote">&gt;&gt;&gt;&gt; we discussed before.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I worry that relying on statically-defined matchdata is just going to</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; blow</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; up the driver and DT binding into a maintenance nightmare; I really</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; don&#39;t</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; want to start needing separate definitions for e.g.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; &quot;arm,juno-etr-mmu-401&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; and &quot;arm,juno-hdlcd-mmu-401&quot; just because one otherwise-identical</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; instance</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; within the SoC is in a separate controllable power domain while the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; others</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; aren&#39;t.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I don&#39;t see a reason why both couldn&#39;t just have RPM supported</span>
<span class="quote">&gt;&gt;&gt;&gt; regardless of whether there is a real power domain. It would</span>
<span class="quote">&gt;&gt;&gt;&gt; effectively be just a no-op for those that don&#39;t have one.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Because you&#39;re then effectively defining &quot;compatible&quot; values for the sake</span>
<span class="quote">&gt;&gt;&gt; of</span>
<span class="quote">&gt;&gt;&gt; attaching software policy to them, rather than actually describing</span>
<span class="quote">&gt;&gt;&gt; different</span>
<span class="quote">&gt;&gt;&gt; hardware implementations.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The fact that RPM can&#39;t do anything meaningful unless relevant</span>
<span class="quote">&gt;&gt;&gt; clock/power</span>
<span class="quote">&gt;&gt;&gt; aspects *are* described, however, means that we shouldn&#39;t need additional</span>
<span class="quote">&gt;&gt;&gt; information redundant with that. Much like the fact that we don&#39;t</span>
<span class="quote">&gt;&gt;&gt; *already*</span>
<span class="quote">&gt;&gt;&gt; have an &quot;arm,juno-hdlcd-mmu-401&quot; compatible to account for those being</span>
<span class="quote">&gt;&gt;&gt; integrated such that IDR0.CTTW has the wrong value, since the presence or</span>
<span class="quote">&gt;&gt;&gt; not of the &quot;dma-coherent&quot; property already describes the truth in that</span>
<span class="quote">&gt;&gt;&gt; regard.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Fair enough.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; IMHO the</span>
<span class="quote">&gt;&gt;&gt;&gt; only reason to avoid having the RPM enabled is the scalability issue</span>
<span class="quote">&gt;&gt;&gt;&gt; we discussed before.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Yes, but that&#39;s kind of my point; in reality high throughput/minimal</span>
<span class="quote">&gt;&gt;&gt; latency</span>
<span class="quote">&gt;&gt;&gt; and aggressive power management are more or less mutually exclusive.</span>
<span class="quote">&gt;&gt;&gt; Mobile</span>
<span class="quote">&gt;&gt;&gt; SoCs with fine-grained clock trees and power domains won&#39;t have multiple</span>
<span class="quote">&gt;&gt;&gt; 40GBe/NVMf/whatever links running flat out in parallel; conversely</span>
<span class="quote">&gt;&gt;&gt; networking/infrastructure/server SoCs aren&#39;t designed around saving every</span>
<span class="quote">&gt;&gt;&gt; last microamp of leakage current - even in the (fairly unlikely) case of</span>
<span class="quote">&gt;&gt;&gt; the</span>
<span class="quote">&gt;&gt;&gt; interconnect clocks being software-gateable at all I would be very</span>
<span class="quote">&gt;&gt;&gt; surprised</span>
<span class="quote">&gt;&gt;&gt; if that were ever exposed directly to Linux (FWIW I believe ACPI</span>
<span class="quote">&gt;&gt;&gt; essentially</span>
<span class="quote">&gt;&gt;&gt; *requires* clocks to be abstracted behind firmware).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Realistically then, explicit clocks are only expected on systems which</span>
<span class="quote">&gt;&gt;&gt; care</span>
<span class="quote">&gt;&gt;&gt; about power management. We can always revisit that assumption if anything</span>
<span class="quote">&gt;&gt;&gt; crazy where it isn&#39;t the case ever becomes non-theoretical, but for now</span>
<span class="quote">&gt;&gt;&gt; it&#39;s</span>
<span class="quote">&gt;&gt;&gt; one I&#39;m entirely comfortable with. If on the other hand it turns out that</span>
<span class="quote">&gt;&gt;&gt; we</span>
<span class="quote">&gt;&gt;&gt; can rely on just a power domain being present wherever we want RPM,</span>
<span class="quote">&gt;&gt;&gt; making</span>
<span class="quote">&gt;&gt;&gt; clocks moot, then all the better.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Alright. Since Qcom would be the only user of clock and power handling</span>
<span class="quote">&gt;&gt; for the time being, I think checking power domain presence could work</span>
<span class="quote">&gt;&gt; for us. +/- the fact that clocks need to be handled even if power</span>
<span class="quote">&gt;&gt; domain is not present, but we should normally always have both.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Great! (the issue of Qcom-specific clock handling is a separate argument</span>
<span class="quote">&gt; which I don&#39;t feel like reigniting just now...)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Now we need a way to do the check. Perhaps for the time being it would</span>
<span class="quote">&gt;&gt; be enough to just check for the power-domains property in DT?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; AFAICS, it might be as simple as arm_smmu_probe() doing this:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         /*</span>
<span class="quote">&gt;          * We want to avoid touching dev-&gt;power.lock in fastpaths unless</span>
<span class="quote">&gt;          * it&#39;s really going to do something useful - pm_runtime_enabled()</span>
<span class="quote">&gt;          * can serve as an ideal proxy for that decision.</span>
<span class="quote">&gt;          */</span>
<span class="quote">&gt;         if (dev-&gt;pm_domain)</span>
<span class="quote">&gt;                 pm_runtime_enable(dev);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; or maybe even just gate all the calls with &quot;if (smmu-&gt;dev.pm_domain)&quot;</span>
<span class="quote">&gt; directly (like pcie-mediatek does), but I&#39;m not sure which would be</span>
<span class="quote">&gt; conceptually cleaner.</span>

Okay, that was easier than I expected. Thanks. :)

Actually, there is one more thing that might need rechecking. Are you
sure that dev-&gt;pm_domain is NULL for the devices, for which we don&#39;t
want runtime PM to be enabled? I think ACPI was mentioned and ACPI
includes the concept of PM domains.

Best regards,
Tomasz
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - March 9, 2018, 5:36 p.m.</div>
<pre class="content">
[ +Lorenzo ]

On 09/03/18 04:50, Tomasz Figa wrote:
[...]
<span class="quote">&gt;&gt;&gt; Now we need a way to do the check. Perhaps for the time being it would</span>
<span class="quote">&gt;&gt;&gt; be enough to just check for the power-domains property in DT?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; AFAICS, it might be as simple as arm_smmu_probe() doing this:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;          /*</span>
<span class="quote">&gt;&gt;           * We want to avoid touching dev-&gt;power.lock in fastpaths unless</span>
<span class="quote">&gt;&gt;           * it&#39;s really going to do something useful - pm_runtime_enabled()</span>
<span class="quote">&gt;&gt;           * can serve as an ideal proxy for that decision.</span>
<span class="quote">&gt;&gt;           */</span>
<span class="quote">&gt;&gt;          if (dev-&gt;pm_domain)</span>
<span class="quote">&gt;&gt;                  pm_runtime_enable(dev);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; or maybe even just gate all the calls with &quot;if (smmu-&gt;dev.pm_domain)&quot;</span>
<span class="quote">&gt;&gt; directly (like pcie-mediatek does), but I&#39;m not sure which would be</span>
<span class="quote">&gt;&gt; conceptually cleaner.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Okay, that was easier than I expected. Thanks. :)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Actually, there is one more thing that might need rechecking. Are you</span>
<span class="quote">&gt; sure that dev-&gt;pm_domain is NULL for the devices, for which we don&#39;t</span>
<span class="quote">&gt; want runtime PM to be enabled? I think ACPI was mentioned and ACPI</span>
<span class="quote">&gt; includes the concept of PM domains.</span>

Thanks for pointing that out - thankfully, I&#39;ve confirmed that the SMMUs 
on my Juno don&#39;t have dev-&gt;pm_domain set when booting with ACPI, and 
double-checking the ACPI code I think we&#39;re OK here. Since the SMMUs are 
only described in the static IORT table and not in the ACPI namespace, 
they won&#39;t have the ACPI companion device that acpi_dev_pm_attach() 
looks for, and thus should always be ignored. Lorenzo, do I have that right?

Robin.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="p_header">index c8b16f53f597..3d6a1875431f 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu.c</span>
<span class="p_chunk">@@ -209,6 +209,8 @@</span> <span class="p_context"> struct arm_smmu_device {</span>
 	struct clk_bulk_data		*clks;
 	int				num_clks;
 
<span class="p_add">+	bool				rpm_supported;</span>
<span class="p_add">+</span>
 	u32				cavium_id_base; /* Specific to Cavium */
 
 	spinlock_t			global_sync_lock;
<span class="p_chunk">@@ -268,6 +270,20 @@</span> <span class="p_context"> static struct arm_smmu_option_prop arm_smmu_options[] = {</span>
 	{ 0, NULL},
 };
 
<span class="p_add">+static inline int arm_smmu_rpm_get(struct arm_smmu_device *smmu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (smmu-&gt;rpm_supported)</span>
<span class="p_add">+		return pm_runtime_get_sync(smmu-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arm_smmu_rpm_put(struct arm_smmu_device *smmu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (smmu-&gt;rpm_supported)</span>
<span class="p_add">+		pm_runtime_put(smmu-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct arm_smmu_domain *to_smmu_domain(struct iommu_domain *dom)
 {
 	return container_of(dom, struct arm_smmu_domain, domain);
<span class="p_chunk">@@ -913,11 +929,15 @@</span> <span class="p_context"> static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
 	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
 	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;
 	struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;
<span class="p_del">-	int irq;</span>
<span class="p_add">+	int ret, irq;</span>
 
 	if (!smmu || domain-&gt;type == IOMMU_DOMAIN_IDENTITY)
 		return;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * Disable the context bank and free the page tables before freeing
 	 * it.
<span class="p_chunk">@@ -932,6 +952,8 @@</span> <span class="p_context"> static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
 
 	free_io_pgtable_ops(smmu_domain-&gt;pgtbl_ops);
 	__arm_smmu_free_bitmap(smmu-&gt;context_map, cfg-&gt;cbndx);
<span class="p_add">+</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
 }
 
 static struct iommu_domain *arm_smmu_domain_alloc(unsigned type)
<span class="p_chunk">@@ -1213,10 +1235,15 @@</span> <span class="p_context"> static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 		return -ENODEV;
 
 	smmu = fwspec_smmu(fwspec);
<span class="p_add">+</span>
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	/* Ensure that the domain is finalised */
 	ret = arm_smmu_init_domain_context(domain, smmu);
 	if (ret &lt; 0)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto rpm_put;</span>
 
 	/*
 	 * Sanity check the domain. We don&#39;t support domains across
<span class="p_chunk">@@ -1231,10 +1258,17 @@</span> <span class="p_context"> static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 	}
 
 	/* Looks ok, so add the device to the domain */
<span class="p_del">-	return arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="p_add">+	ret = arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="p_add">+</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 
 destroy_domain:
 	arm_smmu_destroy_domain_context(domain);
<span class="p_add">+rpm_put:</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1242,22 +1276,36 @@</span> <span class="p_context"> static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,</span>
 			phys_addr_t paddr, size_t size, int prot)
 {
 	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;
<span class="p_add">+	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="p_add">+	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!ops)
 		return -ENODEV;
 
<span class="p_del">-	return ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	ret = ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static size_t arm_smmu_unmap(struct iommu_domain *domain, unsigned long iova,
 			     size_t size)
 {
 	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;
<span class="p_add">+	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="p_add">+	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="p_add">+	size_t ret;</span>
 
 	if (!ops)
 		return 0;
 
<span class="p_del">-	return ops-&gt;unmap(ops, iova, size);</span>
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	ret = ops-&gt;unmap(ops, iova, size);</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void arm_smmu_iotlb_sync(struct iommu_domain *domain)
<span class="p_chunk">@@ -1412,14 +1460,22 @@</span> <span class="p_context"> static int arm_smmu_add_device(struct device *dev)</span>
 	while (i--)
 		cfg-&gt;smendx[i] = INVALID_SMENDX;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto out_cfg_free;</span>
<span class="p_add">+</span>
 	ret = arm_smmu_master_alloc_smes(dev);
 	if (ret)
<span class="p_del">-		goto out_cfg_free;</span>
<span class="p_add">+		goto out_rpm_put;</span>
 
 	iommu_device_link(&amp;smmu-&gt;iommu, dev);
 
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	return 0;
 
<span class="p_add">+out_rpm_put:</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
 out_cfg_free:
 	kfree(cfg);
 out_free:
<span class="p_chunk">@@ -1432,7 +1488,7 @@</span> <span class="p_context"> static void arm_smmu_remove_device(struct device *dev)</span>
 	struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
 	struct arm_smmu_master_cfg *cfg;
 	struct arm_smmu_device *smmu;
<span class="p_del">-</span>
<span class="p_add">+	int ret;</span>
 
 	if (!fwspec || fwspec-&gt;ops != &amp;arm_smmu_ops)
 		return;
<span class="p_chunk">@@ -1440,8 +1496,15 @@</span> <span class="p_context"> static void arm_smmu_remove_device(struct device *dev)</span>
 	cfg  = fwspec-&gt;iommu_priv;
 	smmu = cfg-&gt;smmu;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	iommu_device_unlink(&amp;smmu-&gt;iommu, dev);
 	arm_smmu_master_free_smes(fwspec);
<span class="p_add">+</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	iommu_group_remove_device(dev);
 	kfree(fwspec-&gt;iommu_priv);
 	iommu_fwspec_free(dev);
<span class="p_chunk">@@ -1907,6 +1970,7 @@</span> <span class="p_context"> struct arm_smmu_match_data {</span>
 	enum arm_smmu_implementation model;
 	const char * const *clks;
 	int num_clks;
<span class="p_add">+	bool rpm_supported;</span>
 };
 
 #define ARM_SMMU_MATCH_DATA(name, ver, imp)	\
<span class="p_chunk">@@ -2029,6 +2093,7 @@</span> <span class="p_context"> static int arm_smmu_device_dt_probe(struct platform_device *pdev,</span>
 	smmu-&gt;version = data-&gt;version;
 	smmu-&gt;model = data-&gt;model;
 	smmu-&gt;num_clks = data-&gt;num_clks;
<span class="p_add">+	smmu-&gt;rpm_supported = data-&gt;rpm_supported;</span>
 
 	arm_smmu_fill_clk_data(smmu, data-&gt;clks);
 
<span class="p_chunk">@@ -2129,6 +2194,8 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 		smmu-&gt;irqs[i] = irq;
 	}
 
<span class="p_add">+	platform_set_drvdata(pdev, smmu);</span>
<span class="p_add">+</span>
 	err = devm_clk_bulk_get(smmu-&gt;dev, smmu-&gt;num_clks, smmu-&gt;clks);
 	if (err)
 		return err;
<span class="p_chunk">@@ -2137,6 +2204,13 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	if (smmu-&gt;rpm_supported)</span>
<span class="p_add">+		pm_runtime_enable(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	err = arm_smmu_device_cfg_probe(smmu);
 	if (err)
 		return err;
<span class="p_chunk">@@ -2178,10 +2252,11 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 		return err;
 	}
 
<span class="p_del">-	platform_set_drvdata(pdev, smmu);</span>
 	arm_smmu_device_reset(smmu);
 	arm_smmu_test_smr_masks(smmu);
 
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	/*
 	 * For ACPI and generic DT bindings, an SMMU will be probed before
 	 * any device which might need it, so we want the bus ops in place
<span class="p_chunk">@@ -2217,9 +2292,14 @@</span> <span class="p_context"> static int arm_smmu_device_remove(struct platform_device *pdev)</span>
 	if (!bitmap_empty(smmu-&gt;context_map, ARM_SMMU_MAX_CBS))
 		dev_err(&amp;pdev-&gt;dev, &quot;removing device with active domains!\n&quot;);
 
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
 	/* Turn the thing off */
 	writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);
 
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+	if (smmu-&gt;rpm_supported)</span>
<span class="p_add">+		pm_runtime_disable(smmu-&gt;dev);</span>
<span class="p_add">+</span>
 	clk_bulk_unprepare(smmu-&gt;num_clks, smmu-&gt;clks);
 
 	return 0;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



