
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.13.2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.13.2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 14, 2017, 4:05 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170914160517.GB3649@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9953499/mbox/"
   >mbox</a>
|
   <a href="/patch/9953499/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9953499/">/patch/9953499/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	09F1E602C9 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:05:27 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 072811FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:05:27 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id F00D3281B7; Thu, 14 Sep 2017 16:05:26 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 871F01FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:05:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752129AbdINQFW (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Sep 2017 12:05:22 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:44896 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751545AbdINQFS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Sep 2017 12:05:18 -0400
Received: from localhost (unknown [12.145.98.253])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 300719FA;
	Thu, 14 Sep 2017 16:05:18 +0000 (UTC)
Date: Thu, 14 Sep 2017 09:05:17 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.13.2
Message-ID: &lt;20170914160517.GB3649@kroah.com&gt;
References: &lt;20170914160510.GA3649@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170914160510.GA3649@kroah.com&gt;
User-Agent: Mutt/1.9.0 (2017-09-02)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 14, 2017, 4:05 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/driver-api/firmware/request_firmware.rst b/Documentation/driver-api/firmware/request_firmware.rst</span>
<span class="p_header">index 1c2c4967cd43..cc0aea880824 100644</span>
<span class="p_header">--- a/Documentation/driver-api/firmware/request_firmware.rst</span>
<span class="p_header">+++ b/Documentation/driver-api/firmware/request_firmware.rst</span>
<span class="p_chunk">@@ -44,17 +44,6 @@</span> <span class="p_context"> request_firmware_nowait</span>
 .. kernel-doc:: drivers/base/firmware_class.c
    :functions: request_firmware_nowait
 
<span class="p_del">-Considerations for suspend and resume</span>
<span class="p_del">-=====================================</span>
<span class="p_del">-</span>
<span class="p_del">-During suspend and resume only the built-in firmware and the firmware cache</span>
<span class="p_del">-elements of the firmware API can be used. This is managed by fw_pm_notify().</span>
<span class="p_del">-</span>
<span class="p_del">-fw_pm_notify</span>
<span class="p_del">-------------</span>
<span class="p_del">-.. kernel-doc:: drivers/base/firmware_class.c</span>
<span class="p_del">-   :functions: fw_pm_notify</span>
<span class="p_del">-</span>
 request firmware API expected driver use
 ========================================
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 41a976854cad..8aad6bc50d52 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 13
<span class="p_del">-SUBLEVEL = 1</span>
<span class="p_add">+SUBLEVEL = 2</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c</span>
<span class="p_header">index ff8b0aa2dfde..42f585379e19 100644</span>
<span class="p_header">--- a/arch/arm/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm/mm/fault.c</span>
<span class="p_chunk">@@ -315,8 +315,11 @@</span> <span class="p_context"> do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * signal first. We do not need to release the mmap_sem because
 	 * it would already be released in __lock_page_or_retry in
 	 * mm/filemap.c. */
<span class="p_del">-	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))</span>
<span class="p_add">+	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)) {</span>
<span class="p_add">+		if (!user_mode(regs))</span>
<span class="p_add">+			goto no_context;</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/*
 	 * Major/minor page fault accounting is only done on the
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">index 51763d674050..a92ac63addf0 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_chunk">@@ -323,6 +323,7 @@</span> <span class="p_context"></span>
 				interrupt-controller;
 				reg = &lt;0x1d00000 0x10000&gt;, /* GICD */
 				      &lt;0x1d40000 0x40000&gt;; /* GICR */
<span class="p_add">+				interrupts = &lt;GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
 			};
 		};
 
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 9b1dd114956a..56e68dfac974 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -4839,7 +4839,8 @@</span> <span class="p_context"> int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u64 error_code,</span>
 	 * Note: AMD only (since it supports the PFERR_GUEST_PAGE_MASK used
 	 *       in PFERR_NEXT_GUEST_PAGE)
 	 */
<span class="p_del">-	if (error_code == PFERR_NESTED_GUEST_PAGE) {</span>
<span class="p_add">+	if (vcpu-&gt;arch.mmu.direct_map &amp;&amp;</span>
<span class="p_add">+		error_code == PFERR_NESTED_GUEST_PAGE) {</span>
 		kvm_mmu_unprotect_page(vcpu-&gt;kvm, gpa_to_gfn(cr2));
 		return 1;
 	}
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index bfbe1e154128..19b63d20f5d3 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -256,38 +256,6 @@</span> <span class="p_context"> static int fw_cache_piggyback_on_request(const char *name);</span>
  * guarding for corner cases a global lock should be OK */
 static DEFINE_MUTEX(fw_lock);
 
<span class="p_del">-static bool __enable_firmware = false;</span>
<span class="p_del">-</span>
<span class="p_del">-static void enable_firmware(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	mutex_lock(&amp;fw_lock);</span>
<span class="p_del">-	__enable_firmware = true;</span>
<span class="p_del">-	mutex_unlock(&amp;fw_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void disable_firmware(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	mutex_lock(&amp;fw_lock);</span>
<span class="p_del">-	__enable_firmware = false;</span>
<span class="p_del">-	mutex_unlock(&amp;fw_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * When disabled only the built-in firmware and the firmware cache will be</span>
<span class="p_del">- * used to look for firmware.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool firmware_enabled(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool enabled = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;fw_lock);</span>
<span class="p_del">-	if (__enable_firmware)</span>
<span class="p_del">-		enabled = true;</span>
<span class="p_del">-	mutex_unlock(&amp;fw_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return enabled;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct firmware_cache fw_cache;
 
 static struct firmware_buf *__allocate_fw_buf(const char *fw_name,
<span class="p_chunk">@@ -1239,12 +1207,6 @@</span> <span class="p_context"> _request_firmware(const struct firmware **firmware_p, const char *name,</span>
 	if (ret &lt;= 0) /* error or already assigned */
 		goto out;
 
<span class="p_del">-	if (!firmware_enabled()) {</span>
<span class="p_del">-		WARN(1, &quot;firmware request while host is not available\n&quot;);</span>
<span class="p_del">-		ret = -EHOSTDOWN;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = fw_get_filesystem_firmware(device, fw-&gt;priv);
 	if (ret) {
 		if (!(opt_flags &amp; FW_OPT_NO_WARN))
<span class="p_chunk">@@ -1755,62 +1717,6 @@</span> <span class="p_context"> static void device_uncache_fw_images_delay(unsigned long delay)</span>
 			   msecs_to_jiffies(delay));
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * fw_pm_notify - notifier for suspend/resume</span>
<span class="p_del">- * @notify_block: unused</span>
<span class="p_del">- * @mode: mode we are switching to</span>
<span class="p_del">- * @unused: unused</span>
<span class="p_del">- *</span>
<span class="p_del">- * Used to modify the firmware_class state as we move in between states.</span>
<span class="p_del">- * The firmware_class implements a firmware cache to enable device driver</span>
<span class="p_del">- * to fetch firmware upon resume before the root filesystem is ready. We</span>
<span class="p_del">- * disable API calls which do not use the built-in firmware or the firmware</span>
<span class="p_del">- * cache when we know these calls will not work.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The inner logic behind all this is a bit complex so it is worth summarizing</span>
<span class="p_del">- * the kernel&#39;s own suspend/resume process with context and focus on how this</span>
<span class="p_del">- * can impact the firmware API.</span>
<span class="p_del">- *</span>
<span class="p_del">- * First a review on how we go to suspend::</span>
<span class="p_del">- *</span>
<span class="p_del">- *	pm_suspend() --&gt; enter_state() --&gt;</span>
<span class="p_del">- *	sys_sync()</span>
<span class="p_del">- *	suspend_prepare() --&gt;</span>
<span class="p_del">- *		__pm_notifier_call_chain(PM_SUSPEND_PREPARE, ...);</span>
<span class="p_del">- *		suspend_freeze_processes() --&gt;</span>
<span class="p_del">- *			freeze_processes() --&gt;</span>
<span class="p_del">- *				__usermodehelper_set_disable_depth(UMH_DISABLED);</span>
<span class="p_del">- *				freeze all tasks ...</span>
<span class="p_del">- *			freeze_kernel_threads()</span>
<span class="p_del">- *	suspend_devices_and_enter() --&gt;</span>
<span class="p_del">- *		dpm_suspend_start() --&gt;</span>
<span class="p_del">- *				dpm_prepare()</span>
<span class="p_del">- *				dpm_suspend()</span>
<span class="p_del">- *		suspend_enter()  --&gt;</span>
<span class="p_del">- *			platform_suspend_prepare()</span>
<span class="p_del">- *			dpm_suspend_late()</span>
<span class="p_del">- *			freeze_enter()</span>
<span class="p_del">- *			syscore_suspend()</span>
<span class="p_del">- *</span>
<span class="p_del">- * When we resume we bail out of a loop from suspend_devices_and_enter() and</span>
<span class="p_del">- * unwind back out to the caller enter_state() where we were before as follows::</span>
<span class="p_del">- *</span>
<span class="p_del">- * 	enter_state() --&gt;</span>
<span class="p_del">- *	suspend_devices_and_enter() --&gt; (bail from loop)</span>
<span class="p_del">- *		dpm_resume_end() --&gt;</span>
<span class="p_del">- *			dpm_resume()</span>
<span class="p_del">- *			dpm_complete()</span>
<span class="p_del">- *	suspend_finish() --&gt;</span>
<span class="p_del">- *		suspend_thaw_processes() --&gt;</span>
<span class="p_del">- *			thaw_processes() --&gt;</span>
<span class="p_del">- *				__usermodehelper_set_disable_depth(UMH_FREEZING);</span>
<span class="p_del">- *				thaw_workqueues();</span>
<span class="p_del">- *				thaw all processes ...</span>
<span class="p_del">- *				usermodehelper_enable();</span>
<span class="p_del">- *		pm_notifier_call_chain(PM_POST_SUSPEND);</span>
<span class="p_del">- *</span>
<span class="p_del">- * fw_pm_notify() works through pm_notifier_call_chain().</span>
<span class="p_del">- */</span>
 static int fw_pm_notify(struct notifier_block *notify_block,
 			unsigned long mode, void *unused)
 {
<span class="p_chunk">@@ -1824,7 +1730,6 @@</span> <span class="p_context"> static int fw_pm_notify(struct notifier_block *notify_block,</span>
 		 */
 		kill_pending_fw_fallback_reqs(true);
 		device_cache_fw_images();
<span class="p_del">-		disable_firmware();</span>
 		break;
 
 	case PM_POST_SUSPEND:
<span class="p_chunk">@@ -1837,7 +1742,6 @@</span> <span class="p_context"> static int fw_pm_notify(struct notifier_block *notify_block,</span>
 		mutex_lock(&amp;fw_lock);
 		fw_cache.state = FW_LOADER_NO_CACHE;
 		mutex_unlock(&amp;fw_lock);
<span class="p_del">-		enable_firmware();</span>
 
 		device_uncache_fw_images_delay(10 * MSEC_PER_SEC);
 		break;
<span class="p_chunk">@@ -1886,7 +1790,6 @@</span> <span class="p_context"> static void __init fw_cache_init(void)</span>
 static int fw_shutdown_notify(struct notifier_block *unused1,
 			      unsigned long unused2, void *unused3)
 {
<span class="p_del">-	disable_firmware();</span>
 	/*
 	 * Kill all pending fallback requests to avoid both stalling shutdown,
 	 * and avoid a deadlock with the usermode_lock.
<span class="p_chunk">@@ -1902,7 +1805,6 @@</span> <span class="p_context"> static struct notifier_block fw_shutdown_nb = {</span>
 
 static int __init firmware_class_init(void)
 {
<span class="p_del">-	enable_firmware();</span>
 	fw_cache_init();
 	register_reboot_notifier(&amp;fw_shutdown_nb);
 #ifdef CONFIG_FW_LOADER_USER_HELPER
<span class="p_chunk">@@ -1914,7 +1816,6 @@</span> <span class="p_context"> static int __init firmware_class_init(void)</span>
 
 static void __exit firmware_class_exit(void)
 {
<span class="p_del">-	disable_firmware();</span>
 #ifdef CONFIG_PM_SLEEP
 	unregister_syscore_ops(&amp;fw_syscore_ops);
 	unregister_pm_notifier(&amp;fw_cache.pm_notify);
<span class="p_header">diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">index a764d5ca7536..5bedf7bc3d88 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_chunk">@@ -876,6 +876,8 @@</span> <span class="p_context"> static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)</span>
 	}
 }
 
<span class="p_add">+#define MXC_V1_ECCBYTES		5</span>
<span class="p_add">+</span>
 static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,
 				struct mtd_oob_region *oobregion)
 {
<span class="p_chunk">@@ -885,7 +887,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,</span>
 		return -ERANGE;
 
 	oobregion-&gt;offset = (section * 16) + 6;
<span class="p_del">-	oobregion-&gt;length = nand_chip-&gt;ecc.bytes;</span>
<span class="p_add">+	oobregion-&gt;length = MXC_V1_ECCBYTES;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -907,8 +909,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_free(struct mtd_info *mtd, int section,</span>
 			oobregion-&gt;length = 4;
 		}
 	} else {
<span class="p_del">-		oobregion-&gt;offset = ((section - 1) * 16) +</span>
<span class="p_del">-				    nand_chip-&gt;ecc.bytes + 6;</span>
<span class="p_add">+		oobregion-&gt;offset = ((section - 1) * 16) + MXC_V1_ECCBYTES + 6;</span>
 		if (section &lt; nand_chip-&gt;ecc.steps)
 			oobregion-&gt;length = (section * 16) + 6 -
 					    oobregion-&gt;offset;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index c6c18b82f8f4..c05cf874cbb8 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -3993,10 +3993,13 @@</span> <span class="p_context"> static void nand_manufacturer_detect(struct nand_chip *chip)</span>
 	 * nand_decode_ext_id() otherwise.
 	 */
 	if (chip-&gt;manufacturer.desc &amp;&amp; chip-&gt;manufacturer.desc-&gt;ops &amp;&amp;
<span class="p_del">-	    chip-&gt;manufacturer.desc-&gt;ops-&gt;detect)</span>
<span class="p_add">+	    chip-&gt;manufacturer.desc-&gt;ops-&gt;detect) {</span>
<span class="p_add">+		/* The 3rd id byte holds MLC / multichip data */</span>
<span class="p_add">+		chip-&gt;bits_per_cell = nand_get_bits_per_cell(chip-&gt;id.data[2]);</span>
 		chip-&gt;manufacturer.desc-&gt;ops-&gt;detect(chip);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		nand_decode_ext_id(chip);
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/mtd/nand/nand_hynix.c b/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_header">index b12dc7325378..bd9a6e343848 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_hynix.c</span>
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> static void hynix_nand_extract_ecc_requirements(struct nand_chip *chip,</span>
 		 * The ECC requirements field meaning depends on the
 		 * NAND technology.
 		 */
<span class="p_del">-		u8 nand_tech = chip-&gt;id.data[5] &amp; 0x3;</span>
<span class="p_add">+		u8 nand_tech = chip-&gt;id.data[5] &amp; 0x7;</span>
 
 		if (nand_tech &lt; 3) {
 			/* &gt; 26nm, reference: H27UBG8T2A datasheet */
<span class="p_chunk">@@ -533,7 +533,7 @@</span> <span class="p_context"> static void hynix_nand_extract_scrambling_requirements(struct nand_chip *chip,</span>
 		if (nand_tech &gt; 0)
 			chip-&gt;options |= NAND_NEED_SCRAMBLING;
 	} else {
<span class="p_del">-		nand_tech = chip-&gt;id.data[5] &amp; 0x3;</span>
<span class="p_add">+		nand_tech = chip-&gt;id.data[5] &amp; 0x7;</span>
 
 		/* &lt; 32nm */
 		if (nand_tech &gt; 2)
<span class="p_header">diff --git a/drivers/mtd/nand/qcom_nandc.c b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">index 88af7145a51a..8928500b5bde 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_chunk">@@ -109,7 +109,11 @@</span> <span class="p_context"></span>
 #define	READ_ADDR			0
 
 /* NAND_DEV_CMD_VLD bits */
<span class="p_del">-#define	READ_START_VLD			0</span>
<span class="p_add">+#define	READ_START_VLD			BIT(0)</span>
<span class="p_add">+#define	READ_STOP_VLD			BIT(1)</span>
<span class="p_add">+#define	WRITE_START_VLD			BIT(2)</span>
<span class="p_add">+#define	ERASE_START_VLD			BIT(3)</span>
<span class="p_add">+#define	SEQ_READ_START_VLD		BIT(4)</span>
 
 /* NAND_EBI2_ECC_BUF_CFG bits */
 #define	NUM_STEPS			0
<span class="p_chunk">@@ -148,6 +152,10 @@</span> <span class="p_context"></span>
 #define	FETCH_ID			0xb
 #define	RESET_DEVICE			0xd
 
<span class="p_add">+/* Default Value for NAND_DEV_CMD_VLD */</span>
<span class="p_add">+#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \</span>
<span class="p_add">+					 ERASE_START_VLD | SEQ_READ_START_VLD)</span>
<span class="p_add">+</span>
 /*
  * the NAND controller performs reads/writes with ECC in 516 byte chunks.
  * the driver calls the chunks &#39;step&#39; or &#39;codeword&#39; interchangeably
<span class="p_chunk">@@ -672,8 +680,7 @@</span> <span class="p_context"> static int nandc_param(struct qcom_nand_host *host)</span>
 
 	/* configure CMD1 and VLD for ONFI param probing */
 	nandc_set_reg(nandc, NAND_DEV_CMD_VLD,
<span class="p_del">-		      (nandc-&gt;vld &amp; ~(1 &lt;&lt; READ_START_VLD))</span>
<span class="p_del">-		      | 0 &lt;&lt; READ_START_VLD);</span>
<span class="p_add">+		      (nandc-&gt;vld &amp; ~READ_START_VLD));</span>
 	nandc_set_reg(nandc, NAND_DEV_CMD1,
 		      (nandc-&gt;cmd1 &amp; ~(0xFF &lt;&lt; READ_ADDR))
 		      | NAND_CMD_PARAM &lt;&lt; READ_ADDR);
<span class="p_chunk">@@ -1893,7 +1900,7 @@</span> <span class="p_context"> static int qcom_nand_host_setup(struct qcom_nand_host *host)</span>
 				| wide_bus &lt;&lt; WIDE_FLASH
 				| 1 &lt;&lt; DEV0_CFG1_ECC_DISABLE;
 
<span class="p_del">-	host-&gt;ecc_bch_cfg = host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
<span class="p_add">+	host-&gt;ecc_bch_cfg = !host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
 				| 0 &lt;&lt; ECC_SW_RESET
 				| host-&gt;cw_data &lt;&lt; ECC_NUM_DATA_BYTES
 				| 1 &lt;&lt; ECC_FORCE_CLK_OPEN
<span class="p_chunk">@@ -1972,13 +1979,14 @@</span> <span class="p_context"> static int qcom_nandc_setup(struct qcom_nand_controller *nandc)</span>
 {
 	/* kill onenand */
 	nandc_write(nandc, SFLASHC_BURST_CFG, 0);
<span class="p_add">+	nandc_write(nandc, NAND_DEV_CMD_VLD, NAND_DEV_CMD_VLD_VAL);</span>
 
 	/* enable ADM DMA */
 	nandc_write(nandc, NAND_FLASH_CHIP_SELECT, DM_EN);
 
 	/* save the original values of these registers */
 	nandc-&gt;cmd1 = nandc_read(nandc, NAND_DEV_CMD1);
<span class="p_del">-	nandc-&gt;vld = nandc_read(nandc, NAND_DEV_CMD_VLD);</span>
<span class="p_add">+	nandc-&gt;vld = NAND_DEV_CMD_VLD_VAL;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c</span>
<span class="p_header">index f1b60740e020..53ae30259989 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c</span>
<span class="p_chunk">@@ -159,7 +159,8 @@</span> <span class="p_context"> void brcmf_feat_attach(struct brcmf_pub *drvr)</span>
 
 	brcmf_feat_firmware_capabilities(ifp);
 	memset(&amp;gscan_cfg, 0, sizeof(gscan_cfg));
<span class="p_del">-	if (drvr-&gt;bus_if-&gt;chip != BRCM_CC_43430_CHIP_ID)</span>
<span class="p_add">+	if (drvr-&gt;bus_if-&gt;chip != BRCM_CC_43430_CHIP_ID &amp;&amp;</span>
<span class="p_add">+	    drvr-&gt;bus_if-&gt;chip != BRCM_CC_4345_CHIP_ID)</span>
 		brcmf_feat_iovar_data_set(ifp, BRCMF_FEAT_GSCAN,
 					  &quot;pfn_gscan_cfg&quot;,
 					  &amp;gscan_cfg, sizeof(gscan_cfg));
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">index 0b75def39c6c..d2c289446c00 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_chunk">@@ -3702,7 +3702,10 @@</span> <span class="p_context"> static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,</span>
 	if (rt2x00_rt(rt2x00dev, RT3572))
 		rt2800_rfcsr_write(rt2x00dev, 8, 0);
 
<span class="p_del">-	tx_pin = rt2800_register_read(rt2x00dev, TX_PIN_CFG);</span>
<span class="p_add">+	if (rt2x00_rt(rt2x00dev, RT6352))</span>
<span class="p_add">+		tx_pin = rt2800_register_read(rt2x00dev, TX_PIN_CFG);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tx_pin = 0;</span>
 
 	switch (rt2x00dev-&gt;default_ant.tx_chain_num) {
 	case 3:
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">index 31965f0ef69d..e8f07573aed9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtc8723b2ant.c</span>
<span class="p_chunk">@@ -1183,7 +1183,10 @@</span> <span class="p_context"> static void btc8723b2ant_set_ant_path(struct btc_coexist *btcoexist,</span>
 		}
 
 		/* fixed internal switch S1-&gt;WiFi, S0-&gt;BT */
<span class="p_del">-		btcoexist-&gt;btc_write_4byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		if (board_info-&gt;btdm_ant_pos == BTC_ANTENNA_AT_MAIN_PORT)</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			btcoexist-&gt;btc_write_2byte(btcoexist, 0x948, 0x280);</span>
 
 		switch (antpos_type) {
 		case BTC_ANT_WIFI_AT_MAIN:
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtcoutsrc.c b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_header">index e6024b013ca5..00eea3440290 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtcoutsrc.c</span>
<span class="p_chunk">@@ -173,6 +173,16 @@</span> <span class="p_context"> static u8 halbtc_get_wifi_central_chnl(struct btc_coexist *btcoexist)</span>
 
 u8 rtl_get_hwpg_single_ant_path(struct rtl_priv *rtlpriv)
 {
<span class="p_add">+	struct rtl_mod_params *mod_params = rtlpriv-&gt;cfg-&gt;mod_params;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* override ant_num / ant_path */</span>
<span class="p_add">+	if (mod_params-&gt;ant_sel) {</span>
<span class="p_add">+		rtlpriv-&gt;btcoexist.btc_info.ant_num =</span>
<span class="p_add">+			(mod_params-&gt;ant_sel == 1 ? ANT_X2 : ANT_X1);</span>
<span class="p_add">+</span>
<span class="p_add">+		rtlpriv-&gt;btcoexist.btc_info.single_ant_path =</span>
<span class="p_add">+			(mod_params-&gt;ant_sel == 1 ? 0 : 1);</span>
<span class="p_add">+	}</span>
 	return rtlpriv-&gt;btcoexist.btc_info.single_ant_path;
 }
 
<span class="p_chunk">@@ -183,6 +193,7 @@</span> <span class="p_context"> u8 rtl_get_hwpg_bt_type(struct rtl_priv *rtlpriv)</span>
 
 u8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv)
 {
<span class="p_add">+	struct rtl_mod_params *mod_params = rtlpriv-&gt;cfg-&gt;mod_params;</span>
 	u8 num;
 
 	if (rtlpriv-&gt;btcoexist.btc_info.ant_num == ANT_X2)
<span class="p_chunk">@@ -190,6 +201,10 @@</span> <span class="p_context"> u8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv)</span>
 	else
 		num = 1;
 
<span class="p_add">+	/* override ant_num / ant_path */</span>
<span class="p_add">+	if (mod_params-&gt;ant_sel)</span>
<span class="p_add">+		num = (mod_params-&gt;ant_sel == 1 ? ANT_X2 : ANT_X1) + 1;</span>
<span class="p_add">+</span>
 	return num;
 }
 
<span class="p_chunk">@@ -861,7 +876,7 @@</span> <span class="p_context"> bool exhalbtc_bind_bt_coex_withadapter(void *adapter)</span>
 {
 	struct btc_coexist *btcoexist = &amp;gl_bt_coexist;
 	struct rtl_priv *rtlpriv = adapter;
<span class="p_del">-	u8 ant_num = 2, chip_type, single_ant_path = 0;</span>
<span class="p_add">+	u8 ant_num = 2, chip_type;</span>
 
 	if (btcoexist-&gt;binded)
 		return false;
<span class="p_chunk">@@ -896,12 +911,6 @@</span> <span class="p_context"> bool exhalbtc_bind_bt_coex_withadapter(void *adapter)</span>
 	ant_num = rtl_get_hwpg_ant_num(rtlpriv);
 	exhalbtc_set_ant_num(rtlpriv, BT_COEX_ANT_TYPE_PG, ant_num);
 
<span class="p_del">-	/* set default antenna position to main  port */</span>
<span class="p_del">-	btcoexist-&gt;board_info.btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;</span>
<span class="p_del">-</span>
<span class="p_del">-	single_ant_path = rtl_get_hwpg_single_ant_path(rtlpriv);</span>
<span class="p_del">-	exhalbtc_set_single_ant_path(single_ant_path);</span>
<span class="p_del">-</span>
 	if (rtl_get_hwpg_package_type(rtlpriv) == 0)
 		btcoexist-&gt;board_info.tfbga_package = false;
 	else if (rtl_get_hwpg_package_type(rtlpriv) == 1)
<span class="p_header">diff --git a/drivers/nvme/host/fabrics.c b/drivers/nvme/host/fabrics.c</span>
<span class="p_header">index 5f5cd306f76d..ffa7191ddfa5 100644</span>
<span class="p_header">--- a/drivers/nvme/host/fabrics.c</span>
<span class="p_header">+++ b/drivers/nvme/host/fabrics.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static struct nvmf_host *nvmf_host_default(void)</span>
 
 	kref_init(&amp;host-&gt;ref);
 	snprintf(host-&gt;nqn, NVMF_NQN_SIZE,
<span class="p_del">-		&quot;nqn.2014-08.org.nvmexpress:NVMf:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
<span class="p_add">+		&quot;nqn.2014-08.org.nvmexpress:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
 
 	mutex_lock(&amp;nvmf_hosts_mutex);
 	list_add_tail(&amp;host-&gt;list, &amp;nvmf_hosts);
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 12540b6104b5..1618dac7bf74 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -1814,6 +1814,8 @@</span> <span class="p_context"> static int btrfs_remount(struct super_block *sb, int *flags, char *data)</span>
 			goto restore;
 		}
 
<span class="p_add">+		btrfs_qgroup_rescan_resume(fs_info);</span>
<span class="p_add">+</span>
 		if (!fs_info-&gt;uuid_root) {
 			btrfs_info(fs_info, &quot;creating UUID tree&quot;);
 			ret = btrfs_create_uuid_tree(fs_info);
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index af330c31f627..a85d1cf9b4a8 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -631,11 +631,11 @@</span> <span class="p_context"> ssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)</span>
 	if (result &lt;= 0)
 		goto out;
 
<span class="p_del">-	result = generic_write_sync(iocb, result);</span>
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		goto out;</span>
 	written = result;
 	iocb-&gt;ki_pos += written;
<span class="p_add">+	result = generic_write_sync(iocb, written);</span>
<span class="p_add">+	if (result &lt; 0)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Return error values */
 	if (nfs_need_check_write(file, inode)) {
<span class="p_header">diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h</span>
<span class="p_header">index dc456416d2be..68cc22083639 100644</span>
<span class="p_header">--- a/fs/nfs/internal.h</span>
<span class="p_header">+++ b/fs/nfs/internal.h</span>
<span class="p_chunk">@@ -251,7 +251,6 @@</span> <span class="p_context"> int nfs_iocounter_wait(struct nfs_lock_context *l_ctx);</span>
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *);</span>
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
 		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index de9066a92c0d..d291e6e72573 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -530,16 +530,6 @@</span> <span class="p_context"> struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)</span>
 }
 EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
 
<span class="p_del">-/*</span>
<span class="p_del">- * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_del">- * @hdr: The header to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
<span class="p_del">-</span>
 /**
  * nfs_pgio_data_destroy - make @hdr suitable for reuse
  *
<span class="p_chunk">@@ -548,14 +538,24 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
  *
  * @hdr: A header that has had nfs_generic_pgio called
  */
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+static void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
 {
 	if (hdr-&gt;args.context)
 		put_nfs_open_context(hdr-&gt;args.context);
 	if (hdr-&gt;page_array.pagevec != hdr-&gt;page_array.page_array)
 		kfree(hdr-&gt;page_array.pagevec);
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_add">+ * @hdr: The header to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	nfs_pgio_data_destroy(hdr);</span>
<span class="p_add">+	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
 
 /**
  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
<span class="p_chunk">@@ -669,7 +669,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_initiate_pgio);</span>
 static void nfs_pgio_error(struct nfs_pgio_header *hdr)
 {
 	set_bit(NFS_IOHDR_REDO, &amp;hdr-&gt;flags);
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_chunk">@@ -680,7 +679,6 @@</span> <span class="p_context"> static void nfs_pgio_error(struct nfs_pgio_header *hdr)</span>
 static void nfs_pgio_release(void *calldata)
 {
 	struct nfs_pgio_header *hdr = calldata;
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_chunk">@@ -714,9 +712,6 @@</span> <span class="p_context"> void nfs_pageio_init(struct nfs_pageio_descriptor *desc,</span>
 		     int io_flags,
 		     gfp_t gfp_flags)
 {
<span class="p_del">-	struct nfs_pgio_mirror *new;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
 	desc-&gt;pg_moreio = 0;
 	desc-&gt;pg_inode = inode;
 	desc-&gt;pg_ops = pg_ops;
<span class="p_chunk">@@ -732,21 +727,9 @@</span> <span class="p_context"> void nfs_pageio_init(struct nfs_pageio_descriptor *desc,</span>
 	desc-&gt;pg_mirror_count = 1;
 	desc-&gt;pg_mirror_idx = 0;
 
<span class="p_del">-	if (pg_ops-&gt;pg_get_mirror_count) {</span>
<span class="p_del">-		/* until we have a request, we don&#39;t have an lseg and no</span>
<span class="p_del">-		 * idea how many mirrors there will be */</span>
<span class="p_del">-		new = kcalloc(NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX,</span>
<span class="p_del">-			      sizeof(struct nfs_pgio_mirror), gfp_flags);</span>
<span class="p_del">-		desc-&gt;pg_mirrors_dynamic = new;</span>
<span class="p_del">-		desc-&gt;pg_mirrors = new;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 0; i &lt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX; i++)</span>
<span class="p_del">-			nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[i], bsize);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_del">-		desc-&gt;pg_mirrors = desc-&gt;pg_mirrors_static;</span>
<span class="p_del">-		nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[0], bsize);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_add">+	desc-&gt;pg_mirrors = desc-&gt;pg_mirrors_static;</span>
<span class="p_add">+	nfs_pageio_mirror_init(&amp;desc-&gt;pg_mirrors[0], bsize);</span>
 }
 EXPORT_SYMBOL_GPL(nfs_pageio_init);
 
<span class="p_chunk">@@ -865,32 +848,52 @@</span> <span class="p_context"> static int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *desc)</span>
 	return ret;
 }
 
<span class="p_add">+static struct nfs_pgio_mirror *</span>
<span class="p_add">+nfs_pageio_alloc_mirrors(struct nfs_pageio_descriptor *desc,</span>
<span class="p_add">+		unsigned int mirror_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs_pgio_mirror *ret;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(desc-&gt;pg_mirrors_dynamic);</span>
<span class="p_add">+	desc-&gt;pg_mirrors_dynamic = NULL;</span>
<span class="p_add">+	if (mirror_count == 1)</span>
<span class="p_add">+		return desc-&gt;pg_mirrors_static;</span>
<span class="p_add">+	ret = kmalloc_array(mirror_count, sizeof(*ret), GFP_NOFS);</span>
<span class="p_add">+	if (ret != NULL) {</span>
<span class="p_add">+		for (i = 0; i &lt; mirror_count; i++)</span>
<span class="p_add">+			nfs_pageio_mirror_init(&amp;ret[i], desc-&gt;pg_bsize);</span>
<span class="p_add">+		desc-&gt;pg_mirrors_dynamic = ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * nfs_pageio_setup_mirroring - determine if mirroring is to be used
  *				by calling the pg_get_mirror_count op
  */
<span class="p_del">-static int nfs_pageio_setup_mirroring(struct nfs_pageio_descriptor *pgio,</span>
<span class="p_add">+static void nfs_pageio_setup_mirroring(struct nfs_pageio_descriptor *pgio,</span>
 				       struct nfs_page *req)
 {
<span class="p_del">-	int mirror_count = 1;</span>
<span class="p_add">+	unsigned int mirror_count = 1;</span>
 
<span class="p_del">-	if (!pgio-&gt;pg_ops-&gt;pg_get_mirror_count)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	mirror_count = pgio-&gt;pg_ops-&gt;pg_get_mirror_count(pgio, req);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pgio-&gt;pg_error &lt; 0)</span>
<span class="p_del">-		return pgio-&gt;pg_error;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mirror_count || mirror_count &gt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (pgio-&gt;pg_ops-&gt;pg_get_mirror_count)</span>
<span class="p_add">+		mirror_count = pgio-&gt;pg_ops-&gt;pg_get_mirror_count(pgio, req);</span>
<span class="p_add">+	if (mirror_count == pgio-&gt;pg_mirror_count || pgio-&gt;pg_error &lt; 0)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	if (WARN_ON_ONCE(!pgio-&gt;pg_mirrors_dynamic))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!mirror_count || mirror_count &gt; NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX) {</span>
<span class="p_add">+		pgio-&gt;pg_error = -EINVAL;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	pgio-&gt;pg_mirrors = nfs_pageio_alloc_mirrors(pgio, mirror_count);</span>
<span class="p_add">+	if (pgio-&gt;pg_mirrors == NULL) {</span>
<span class="p_add">+		pgio-&gt;pg_error = -ENOMEM;</span>
<span class="p_add">+		pgio-&gt;pg_mirrors = pgio-&gt;pg_mirrors_static;</span>
<span class="p_add">+		mirror_count = 1;</span>
<span class="p_add">+	}</span>
 	pgio-&gt;pg_mirror_count = mirror_count;
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index c383d0913b54..64bb20130edf 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -2274,7 +2274,6 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_write_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_chunk">@@ -2398,7 +2397,6 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_read_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_header">diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h</span>
<span class="p_header">index 9301c5a6060b..dcd1292664b3 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_linux.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_linux.h</span>
<span class="p_chunk">@@ -270,7 +270,14 @@</span> <span class="p_context"> static inline uint64_t howmany_64(uint64_t x, uint32_t y)</span>
 #endif /* DEBUG */
 
 #ifdef CONFIG_XFS_RT
<span class="p_del">-#define XFS_IS_REALTIME_INODE(ip) ((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * make sure we ignore the inode flag if the filesystem doesn&#39;t have a</span>
<span class="p_add">+ * configured realtime device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define XFS_IS_REALTIME_INODE(ip)			\</span>
<span class="p_add">+	(((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME) &amp;&amp;	\</span>
<span class="p_add">+	 (ip)-&gt;i_mount-&gt;m_rtdev_targp)</span>
 #else
 #define XFS_IS_REALTIME_INODE(ip) (0)
 #endif
<span class="p_header">diff --git a/lib/radix-tree.c b/lib/radix-tree.c</span>
<span class="p_header">index 898e87998417..79a804f1aab9 100644</span>
<span class="p_header">--- a/lib/radix-tree.c</span>
<span class="p_header">+++ b/lib/radix-tree.c</span>
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> radix_tree_node_free(struct radix_tree_node *node)</span>
  * To make use of this facility, the radix tree must be initialised without
  * __GFP_DIRECT_RECLAIM being passed to INIT_RADIX_TREE().
  */
<span class="p_del">-static int __radix_tree_preload(gfp_t gfp_mask, unsigned nr)</span>
<span class="p_add">+static __must_check int __radix_tree_preload(gfp_t gfp_mask, unsigned nr)</span>
 {
 	struct radix_tree_preload *rtp;
 	struct radix_tree_node *node;
<span class="p_chunk">@@ -2103,7 +2103,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(radix_tree_tagged);</span>
  */
 void idr_preload(gfp_t gfp_mask)
 {
<span class="p_del">-	__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE);</span>
<span class="p_add">+	if (__radix_tree_preload(gfp_mask, IDR_PRELOAD_SIZE))</span>
<span class="p_add">+		preempt_disable();</span>
 }
 EXPORT_SYMBOL(idr_preload);
 
<span class="p_chunk">@@ -2117,13 +2118,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(idr_preload);</span>
  */
 int ida_pre_get(struct ida *ida, gfp_t gfp)
 {
<span class="p_del">-	__radix_tree_preload(gfp, IDA_PRELOAD_SIZE);</span>
 	/*
 	 * The IDA API has no preload_end() equivalent.  Instead,
 	 * ida_get_new() can return -EAGAIN, prompting the caller
 	 * to return to the ida_pre_get() step.
 	 */
<span class="p_del">-	preempt_enable();</span>
<span class="p_add">+	if (!__radix_tree_preload(gfp, IDA_PRELOAD_SIZE))</span>
<span class="p_add">+		preempt_enable();</span>
 
 	if (!this_cpu_read(ida_bitmap)) {
 		struct ida_bitmap *bitmap = kmalloc(sizeof(*bitmap), gfp);
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 56e48e4593cb..274547075486 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3888,6 +3888,11 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	/* do counter updates before entering really critical section. */
 	check_sync_rss_stat(current);
 
<span class="p_add">+	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_add">+		return VM_FAULT_SIGSEGV;</span>
<span class="p_add">+</span>
 	/*
 	 * Enable the memcg OOM handling for faults triggered in user
 	 * space.  Kernel faults are handled more gracefully.
<span class="p_chunk">@@ -3895,11 +3900,6 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	if (flags &amp; FAULT_FLAG_USER)
 		mem_cgroup_oom_enable();
 
<span class="p_del">-	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);
 	else
<span class="p_header">diff --git a/mm/sparse.c b/mm/sparse.c</span>
<span class="p_header">index 7b4be3fd5cac..cdce7a7bb3f3 100644</span>
<span class="p_header">--- a/mm/sparse.c</span>
<span class="p_header">+++ b/mm/sparse.c</span>
<span class="p_chunk">@@ -630,7 +630,7 @@</span> <span class="p_context"> void online_mem_sections(unsigned long start_pfn, unsigned long end_pfn)</span>
 	unsigned long pfn;
 
 	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += PAGES_PER_SECTION) {
<span class="p_del">-		unsigned long section_nr = pfn_to_section_nr(start_pfn);</span>
<span class="p_add">+		unsigned long section_nr = pfn_to_section_nr(pfn);</span>
 		struct mem_section *ms;
 
 		/* onlining code should never touch invalid ranges */
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index 6ba4aab2db0b..a8952b6563c6 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -3052,7 +3052,8 @@</span> <span class="p_context"> SYSCALL_DEFINE2(swapon, const char __user *, specialfile, int, swap_flags)</span>
 	p-&gt;flags = 0;
 	spin_unlock(&amp;swap_lock);
 	vfree(swap_map);
<span class="p_del">-	vfree(cluster_info);</span>
<span class="p_add">+	kvfree(cluster_info);</span>
<span class="p_add">+	kvfree(frontswap_map);</span>
 	if (swap_file) {
 		if (inode &amp;&amp; S_ISREG(inode-&gt;i_mode)) {
 			inode_unlock(inode);
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index 303c779bfe38..43ba91c440bc 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,</span>
 				       u8 code, u8 ident, u16 dlen, void *data);
 static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
 			   void *data);
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);</span>
 static void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);
 
 static void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,
<span class="p_chunk">@@ -1473,7 +1473,7 @@</span> <span class="p_context"> static void l2cap_conn_start(struct l2cap_conn *conn)</span>
 
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 
<span class="p_chunk">@@ -2987,12 +2987,15 @@</span> <span class="p_context"> static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,</span>
 	return len;
 }
 
<span class="p_del">-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
<span class="p_add">+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)</span>
 {
 	struct l2cap_conf_opt *opt = *ptr;
 
 	BT_DBG(&quot;type 0x%2.2x len %u val 0x%lx&quot;, type, len, val);
 
<span class="p_add">+	if (size &lt; L2CAP_CONF_OPT_SIZE + len)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	opt-&gt;type = type;
 	opt-&gt;len  = len;
 
<span class="p_chunk">@@ -3017,7 +3020,7 @@</span> <span class="p_context"> static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
 	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
<span class="p_del">-static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
<span class="p_add">+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)</span>
 {
 	struct l2cap_conf_efs efs;
 
<span class="p_chunk">@@ -3045,7 +3048,7 @@</span> <span class="p_context"> static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
 	}
 
 	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-			   (unsigned long) &amp;efs);</span>
<span class="p_add">+			   (unsigned long) &amp;efs, size);</span>
 }
 
 static void l2cap_ack_timeout(struct work_struct *work)
<span class="p_chunk">@@ -3191,11 +3194,12 @@</span> <span class="p_context"> static inline void l2cap_txwin_setup(struct l2cap_chan *chan)</span>
 	chan-&gt;ack_win = chan-&gt;tx_win;
 }
 
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_req *req = data;
 	struct l2cap_conf_rfc rfc = { .mode = chan-&gt;mode };
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	u16 size;
 
 	BT_DBG(&quot;chan %p&quot;, chan);
<span class="p_chunk">@@ -3220,7 +3224,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 done:
 	if (chan-&gt;imtu != L2CAP_DEFAULT_MTU)
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 
 	switch (chan-&gt;mode) {
 	case L2CAP_MODE_BASIC:
<span class="p_chunk">@@ -3239,7 +3243,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size    = 0;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 		break;
 
 	case L2CAP_MODE_ERTM:
<span class="p_chunk">@@ -3259,21 +3263,21 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 				       L2CAP_DEFAULT_TX_WINDOW);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EXT_CTRL, &amp;chan-&gt;flags))
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 
<span class="p_chunk">@@ -3291,17 +3295,17 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size = cpu_to_le16(size);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 	}
<span class="p_chunk">@@ -3312,10 +3316,11 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 	return ptr - data;
 }
 
<span class="p_del">-static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	void *req = chan-&gt;conf_req;
 	int len = chan-&gt;conf_len;
 	int type, hint, olen;
<span class="p_chunk">@@ -3417,7 +3422,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			return -ECONNREFUSED;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 	}
 
 	if (result == L2CAP_CONF_SUCCESS) {
<span class="p_chunk">@@ -3430,7 +3435,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			chan-&gt;omtu = mtu;
 			set_bit(CONF_MTU_DONE, &amp;chan-&gt;conf_state);
 		}
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu, endptr - ptr);</span>
 
 		if (remote_efs) {
 			if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;
<span class="p_chunk">@@ -3444,7 +3449,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			} else {
 				/* Send PENDING Conf Rsp */
 				result = L2CAP_CONF_PENDING;
<span class="p_chunk">@@ -3477,7 +3482,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags)) {
 				chan-&gt;remote_id = efs.id;
<span class="p_chunk">@@ -3491,7 +3496,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 					le32_to_cpu(efs.sdu_itime);
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			}
 			break;
 
<span class="p_chunk">@@ -3505,7 +3510,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-					   (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			break;
 
<span class="p_chunk">@@ -3527,10 +3532,11 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 }
 
 static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
<span class="p_del">-				void *data, u16 *result)</span>
<span class="p_add">+				void *data, size_t size, u16 *result)</span>
 {
 	struct l2cap_conf_req *req = data;
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + size;</span>
 	int type, olen;
 	unsigned long val;
 	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
<span class="p_chunk">@@ -3548,13 +3554,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				chan-&gt;imtu = L2CAP_DEFAULT_MIN_MTU;
 			} else
 				chan-&gt;imtu = val;
<span class="p_del">-			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FLUSH_TO:
 			chan-&gt;flush_to = val;
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FLUSH_TO,
<span class="p_del">-					   2, chan-&gt;flush_to);</span>
<span class="p_add">+					   2, chan-&gt;flush_to, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_RFC:
<span class="p_chunk">@@ -3568,13 +3574,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 			chan-&gt;fcs = 0;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EWS:
 			chan-&gt;ack_win = min_t(u16, val, chan-&gt;ack_win);
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_chunk">@@ -3587,7 +3593,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				return -ECONNREFUSED;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-					   (unsigned long) &amp;efs);</span>
<span class="p_add">+					   (unsigned long) &amp;efs, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FCS:
<span class="p_chunk">@@ -3692,7 +3698,7 @@</span> <span class="p_context"> void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)</span>
 		return;
 
 	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-		       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+		       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 	chan-&gt;num_conf_req++;
 }
 
<span class="p_chunk">@@ -3900,7 +3906,7 @@</span> <span class="p_context"> static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,</span>
 		u8 buf[128];
 		set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -3978,7 +3984,7 @@</span> <span class="p_context"> static int l2cap_connect_create_rsp(struct l2cap_conn *conn,</span>
 			break;
 
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, req), req);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, req, sizeof(req)), req);</span>
 		chan-&gt;num_conf_req++;
 		break;
 
<span class="p_chunk">@@ -4090,7 +4096,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	}
 
 	/* Complete config. */
<span class="p_del">-	len = l2cap_parse_conf_req(chan, rsp);</span>
<span class="p_add">+	len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));</span>
 	if (len &lt; 0) {
 		l2cap_send_disconn_req(chan, ECONNRESET);
 		goto unlock;
<span class="p_chunk">@@ -4124,7 +4130,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	if (!test_and_set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state)) {
 		u8 buf[64];
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -4184,7 +4190,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			char buf[64];
 
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   buf, &amp;result);</span>
<span class="p_add">+						   buf, sizeof(buf), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4214,7 +4220,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			/* throw out any old stored conf requests */
 			result = L2CAP_CONF_SUCCESS;
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   req, &amp;result);</span>
<span class="p_add">+						   req, sizeof(req), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4791,7 +4797,7 @@</span> <span class="p_context"> static void l2cap_do_create(struct l2cap_chan *chan, int result,</span>
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(chan-&gt;conn, l2cap_get_ident(chan-&gt;conn),
 				       L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 	}
<span class="p_chunk">@@ -7465,7 +7471,7 @@</span> <span class="p_context"> static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)</span>
 				set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 				l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					       L2CAP_CONF_REQ,
<span class="p_del">-					       l2cap_build_conf_req(chan, buf),</span>
<span class="p_add">+					       l2cap_build_conf_req(chan, buf, sizeof(buf)),</span>
 					       buf);
 				chan-&gt;num_conf_req++;
 			}
<span class="p_header">diff --git a/tools/testing/selftests/timers/Makefile b/tools/testing/selftests/timers/Makefile</span>
<span class="p_header">index a9b86133b9b3..dfa916e651fb 100644</span>
<span class="p_header">--- a/tools/testing/selftests/timers/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/timers/Makefile</span>
<span class="p_chunk">@@ -14,20 +14,20 @@</span> <span class="p_context"> TEST_GEN_PROGS_EXTENDED = alarmtimer-suspend valid-adjtimex adjtick change_skew</span>
 
 include ../lib.mk
 
<span class="p_add">+define RUN_DESTRUCTIVE_TESTS</span>
<span class="p_add">+	@for TEST in $(TEST_GEN_PROGS_EXTENDED); do \</span>
<span class="p_add">+		BASENAME_TEST=`basename $$TEST`;	\</span>
<span class="p_add">+		if [ ! -x $$BASENAME_TEST ]; then	\</span>
<span class="p_add">+			echo &quot;selftests: Warning: file $$BASENAME_TEST is not executable, correct this.&quot;;\</span>
<span class="p_add">+			echo &quot;selftests: $$BASENAME_TEST [FAIL]&quot;; \</span>
<span class="p_add">+		else					\</span>
<span class="p_add">+			cd `dirname $$TEST`; (./$$BASENAME_TEST &amp;&amp; echo &quot;selftests: $$BASENAME_TEST [PASS]&quot;) || echo &quot;selftests:  $$BASENAME_TEST [FAIL]&quot;; cd -;\</span>
<span class="p_add">+		fi;					\</span>
<span class="p_add">+	done;</span>
<span class="p_add">+endef</span>
<span class="p_add">+</span>
 # these tests require escalated privileges
 # and may modify the system time or trigger
 # other behavior like suspend
 run_destructive_tests: run_tests
<span class="p_del">-	./alarmtimer-suspend</span>
<span class="p_del">-	./valid-adjtimex</span>
<span class="p_del">-	./adjtick</span>
<span class="p_del">-	./change_skew</span>
<span class="p_del">-	./skew_consistency</span>
<span class="p_del">-	./clocksource-switch</span>
<span class="p_del">-	./freq-step</span>
<span class="p_del">-	./leap-a-day -s -i 10</span>
<span class="p_del">-	./leapcrash</span>
<span class="p_del">-	./set-tz</span>
<span class="p_del">-	./set-tai</span>
<span class="p_del">-	./set-2038</span>
<span class="p_del">-</span>
<span class="p_add">+	$(RUN_DESTRUCTIVE_TESTS)</span>
<span class="p_header">diff --git a/tools/testing/selftests/timers/leap-a-day.c b/tools/testing/selftests/timers/leap-a-day.c</span>
<span class="p_header">index fb46ad6ac92c..067017634057 100644</span>
<span class="p_header">--- a/tools/testing/selftests/timers/leap-a-day.c</span>
<span class="p_header">+++ b/tools/testing/selftests/timers/leap-a-day.c</span>
<span class="p_chunk">@@ -190,18 +190,18 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 	struct sigevent se;
 	struct sigaction act;
 	int signum = SIGRTMAX;
<span class="p_del">-	int settime = 0;</span>
<span class="p_add">+	int settime = 1;</span>
 	int tai_time = 0;
 	int insert = 1;
<span class="p_del">-	int iterations = -1;</span>
<span class="p_add">+	int iterations = 10;</span>
 	int opt;
 
 	/* Process arguments */
 	while ((opt = getopt(argc, argv, &quot;sti:&quot;)) != -1) {
 		switch (opt) {
<span class="p_del">-		case &#39;s&#39;:</span>
<span class="p_del">-			printf(&quot;Setting time to speed up testing\n&quot;);</span>
<span class="p_del">-			settime = 1;</span>
<span class="p_add">+		case &#39;w&#39;:</span>
<span class="p_add">+			printf(&quot;Only setting leap-flag, not changing time. It could take up to a day for leap to trigger.\n&quot;);</span>
<span class="p_add">+			settime = 0;</span>
 			break;
 		case &#39;i&#39;:
 			iterations = atoi(optarg);
<span class="p_chunk">@@ -210,9 +210,10 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 			tai_time = 1;
 			break;
 		default:
<span class="p_del">-			printf(&quot;Usage: %s [-s] [-i &lt;iterations&gt;]\n&quot;, argv[0]);</span>
<span class="p_del">-			printf(&quot;	-s: Set time to right before leap second each iteration\n&quot;);</span>
<span class="p_del">-			printf(&quot;	-i: Number of iterations\n&quot;);</span>
<span class="p_add">+			printf(&quot;Usage: %s [-w] [-i &lt;iterations&gt;]\n&quot;, argv[0]);</span>
<span class="p_add">+			printf(&quot;	-w: Set flag and wait for leap second each iteration&quot;);</span>
<span class="p_add">+			printf(&quot;	    (default sets time to right before leapsecond)\n&quot;);</span>
<span class="p_add">+			printf(&quot;	-i: Number of iterations (-1 = infinite, default is 10)\n&quot;);</span>
 			printf(&quot;	-t: Print TAI time\n&quot;);
 			exit(-1);
 		}
<span class="p_header">diff --git a/tools/testing/selftests/x86/fsgsbase.c b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">index b4967d875236..f249e042b3b5 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_chunk">@@ -285,9 +285,12 @@</span> <span class="p_context"> static void *threadproc(void *ctx)</span>
 	}
 }
 
<span class="p_del">-static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
<span class="p_add">+static void set_gs_and_switch_to(unsigned long local,</span>
<span class="p_add">+				 unsigned short force_sel,</span>
<span class="p_add">+				 unsigned long remote)</span>
 {
 	unsigned long base;
<span class="p_add">+	unsigned short sel_pre_sched, sel_post_sched;</span>
 
 	bool hard_zero = false;
 	if (local == HARD_ZERO) {
<span class="p_chunk">@@ -297,6 +300,8 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 
 	printf(&quot;[RUN]\tARCH_SET_GS(0x%lx)%s, then schedule to 0x%lx\n&quot;,
 	       local, hard_zero ? &quot; and clear gs&quot; : &quot;&quot;, remote);
<span class="p_add">+	if (force_sel)</span>
<span class="p_add">+		printf(&quot;\tBefore schedule, set selector to 0x%hx\n&quot;, force_sel);</span>
 	if (syscall(SYS_arch_prctl, ARCH_SET_GS, local) != 0)
 		err(1, &quot;ARCH_SET_GS&quot;);
 	if (hard_zero)
<span class="p_chunk">@@ -307,18 +312,35 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 		printf(&quot;[FAIL]\tGSBASE wasn&#39;t set as expected\n&quot;);
 	}
 
<span class="p_add">+	if (force_sel) {</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+		sel_pre_sched = force_sel;</span>
<span class="p_add">+		local = read_base(GS);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Signal delivery seems to mess up weird selectors.  Put it</span>
<span class="p_add">+		 * back.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_pre_sched));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	remote_base = remote;
 	ftx = 1;
 	syscall(SYS_futex, &amp;ftx, FUTEX_WAKE, 0, NULL, NULL, 0);
 	while (ftx != 0)
 		syscall(SYS_futex, &amp;ftx, FUTEX_WAIT, 1, NULL, NULL, 0);
 
<span class="p_add">+	asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_post_sched));</span>
 	base = read_base(GS);
<span class="p_del">-	if (base == local) {</span>
<span class="p_del">-		printf(&quot;[OK]\tGSBASE remained 0x%lx\n&quot;, local);</span>
<span class="p_add">+	if (base == local &amp;&amp; sel_pre_sched == sel_post_sched) {</span>
<span class="p_add">+		printf(&quot;[OK]\tGS/BASE remained 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local);</span>
 	} else {
 		nerrs++;
<span class="p_del">-		printf(&quot;[FAIL]\tGSBASE changed to 0x%lx\n&quot;, base);</span>
<span class="p_add">+		printf(&quot;[FAIL]\tGS/BASE changed from 0x%hx/0x%lx to 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local, sel_post_sched, base);</span>
 	}
 }
 
<span class="p_chunk">@@ -381,8 +403,15 @@</span> <span class="p_context"> int main()</span>
 
 	for (int local = 0; local &lt; 4; local++) {
 		for (int remote = 0; remote &lt; 4; remote++) {
<span class="p_del">-			set_gs_and_switch_to(bases_with_hard_zero[local],</span>
<span class="p_del">-					     bases_with_hard_zero[remote]);</span>
<span class="p_add">+			for (unsigned short s = 0; s &lt; 5; s++) {</span>
<span class="p_add">+				unsigned short sel = s;</span>
<span class="p_add">+				if (s == 4)</span>
<span class="p_add">+					asm (&quot;mov %%ss, %0&quot; : &quot;=rm&quot; (sel));</span>
<span class="p_add">+				set_gs_and_switch_to(</span>
<span class="p_add">+					bases_with_hard_zero[local],</span>
<span class="p_add">+					sel,</span>
<span class="p_add">+					bases_with_hard_zero[remote]);</span>
<span class="p_add">+			}</span>
 		}
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



