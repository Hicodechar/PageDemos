
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.8 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.8</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 21, 2015, 10:35 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150921223559.GB31668@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7234511/mbox/"
   >mbox</a>
|
   <a href="/patch/7234511/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7234511/">/patch/7234511/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 38A459F30C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Sep 2015 22:36:38 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 7FEB720822
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Sep 2015 22:36:30 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 6143B20749
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Sep 2015 22:36:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933127AbbIUWgP (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 21 Sep 2015 18:36:15 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:33390 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933047AbbIUWgA (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 21 Sep 2015 18:36:00 -0400
Received: from localhost (unknown [70.35.39.2])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D569E1B4F;
	Mon, 21 Sep 2015 22:35:59 +0000 (UTC)
Date: Mon, 21 Sep 2015 15:35:59 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.8
Message-ID: &lt;20150921223559.GB31668@kroah.com&gt;
References: &lt;20150921223551.GA31668@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150921223551.GA31668@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 21, 2015, 10:35 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/configfs-usb-gadget-loopback b/Documentation/ABI/testing/configfs-usb-gadget-loopback</span>
<span class="p_header">index 9aae5bfb9908..06beefbcf061 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/configfs-usb-gadget-loopback</span>
<span class="p_header">+++ b/Documentation/ABI/testing/configfs-usb-gadget-loopback</span>
<span class="p_chunk">@@ -5,4 +5,4 @@</span> <span class="p_context"> Description:</span>
 		The attributes:
 
 		qlen		- depth of loopback queue
<span class="p_del">-		bulk_buflen	- buffer length</span>
<span class="p_add">+		buflen		- buffer length</span>
<span class="p_header">diff --git a/Documentation/ABI/testing/configfs-usb-gadget-sourcesink b/Documentation/ABI/testing/configfs-usb-gadget-sourcesink</span>
<span class="p_header">index 29477c319f61..bc7ff731aa0c 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/configfs-usb-gadget-sourcesink</span>
<span class="p_header">+++ b/Documentation/ABI/testing/configfs-usb-gadget-sourcesink</span>
<span class="p_chunk">@@ -9,4 +9,4 @@</span> <span class="p_context"> Description:</span>
 		isoc_maxpacket	- 0 - 1023 (fs), 0 - 1024 (hs/ss)
 		isoc_mult	- 0..2 (hs/ss only)
 		isoc_maxburst	- 0..15 (ss only)
<span class="p_del">-		qlen		- buffer length</span>
<span class="p_add">+		buflen		- buffer length</span>
<span class="p_header">diff --git a/Documentation/usb/gadget-testing.txt b/Documentation/usb/gadget-testing.txt</span>
<span class="p_header">index f45b2bf4b41d..820664af8f6a 100644</span>
<span class="p_header">--- a/Documentation/usb/gadget-testing.txt</span>
<span class="p_header">+++ b/Documentation/usb/gadget-testing.txt</span>
<span class="p_chunk">@@ -237,9 +237,7 @@</span> <span class="p_context"> Testing the LOOPBACK function</span>
 -----------------------------
 
 device: run the gadget
<span class="p_del">-host: test-usb</span>
<span class="p_del">-</span>
<span class="p_del">-http://www.linux-usb.org/usbtest/testusb.c</span>
<span class="p_add">+host: test-usb (tools/usb/testusb.c)</span>
 
 8. MASS STORAGE function
 ========================
<span class="p_chunk">@@ -588,9 +586,8 @@</span> <span class="p_context"> Testing the SOURCESINK function</span>
 -------------------------------
 
 device: run the gadget
<span class="p_del">-host: test-usb</span>
<span class="p_add">+host: test-usb (tools/usb/testusb.c)</span>
 
<span class="p_del">-http://www.linux-usb.org/usbtest/testusb.c</span>
 
 16. UAC1 function
 =================
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b8591e5f79b8..dbf3baa5fabb 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 7</span>
<span class="p_add">+SUBLEVEL = 8</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig</span>
<span class="p_header">index 45df48ba0b12..19f4cc634b0e 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/Kconfig</span>
<span class="p_chunk">@@ -538,6 +538,7 @@</span> <span class="p_context"> config ARCH_ORION5X</span>
 	select MVEBU_MBUS
 	select PCI
 	select PLAT_ORION_LEGACY
<span class="p_add">+	select MULTI_IRQ_HANDLER</span>
 	help
 	  Support for the following Marvell Orion 5x series SoCs:
 	  Orion-1 (5181), Orion-VoIP (5181L), Orion-NAS (5182),
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos3250-rinato.dts b/arch/arm/boot/dts/exynos3250-rinato.dts</span>
<span class="p_header">index 0b9906880c0c..75aba40c69e1 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos3250-rinato.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos3250-rinato.dts</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"></span>
 
 		display-timings {
 			timing-0 {
<span class="p_del">-				clock-frequency = &lt;0&gt;;</span>
<span class="p_add">+				clock-frequency = &lt;4600000&gt;;</span>
 				hactive = &lt;320&gt;;
 				vactive = &lt;320&gt;;
 				hfront-porch = &lt;1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi</span>
<span class="p_header">index 165968d51d8f..8eca5878a877 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/rk3288.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/rk3288.dtsi</span>
<span class="p_chunk">@@ -584,7 +584,7 @@</span> <span class="p_context"></span>
 		compatible = &quot;rockchip,rk3288-wdt&quot;, &quot;snps,dw-wdt&quot;;
 		reg = &lt;0xff800000 0x100&gt;;
 		clocks = &lt;&amp;cru PCLK_WDT&gt;;
<span class="p_del">-		interrupts = &lt;GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
<span class="p_add">+		interrupts = &lt;GIC_SPI 79 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
 		status = &quot;disabled&quot;;
 	};
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/clockdomains7xx_data.c b/arch/arm/mach-omap2/clockdomains7xx_data.c</span>
<span class="p_header">index 57d5df0c1fbd..7581e036bda6 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/clockdomains7xx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/clockdomains7xx_data.c</span>
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> static struct clockdomain l4per2_7xx_clkdm = {</span>
 	.dep_bit	  = DRA7XX_L4PER2_STATDEP_SHIFT,
 	.wkdep_srcs	  = l4per2_wkup_sleep_deps,
 	.sleepdep_srcs	  = l4per2_wkup_sleep_deps,
<span class="p_del">-	.flags		  = CLKDM_CAN_HWSUP_SWSUP,</span>
<span class="p_add">+	.flags		  = CLKDM_CAN_SWSUP,</span>
 };
 
 static struct clockdomain mpu0_7xx_clkdm = {
<span class="p_header">diff --git a/arch/arm/mach-orion5x/include/mach/irqs.h b/arch/arm/mach-orion5x/include/mach/irqs.h</span>
<span class="p_header">index a6fa9d8f12d8..2431d9923427 100644</span>
<span class="p_header">--- a/arch/arm/mach-orion5x/include/mach/irqs.h</span>
<span class="p_header">+++ b/arch/arm/mach-orion5x/include/mach/irqs.h</span>
<span class="p_chunk">@@ -16,42 +16,42 @@</span> <span class="p_context"></span>
 /*
  * Orion Main Interrupt Controller
  */
<span class="p_del">-#define IRQ_ORION5X_BRIDGE		0</span>
<span class="p_del">-#define IRQ_ORION5X_DOORBELL_H2C	1</span>
<span class="p_del">-#define IRQ_ORION5X_DOORBELL_C2H	2</span>
<span class="p_del">-#define IRQ_ORION5X_UART0		3</span>
<span class="p_del">-#define IRQ_ORION5X_UART1		4</span>
<span class="p_del">-#define IRQ_ORION5X_I2C			5</span>
<span class="p_del">-#define IRQ_ORION5X_GPIO_0_7		6</span>
<span class="p_del">-#define IRQ_ORION5X_GPIO_8_15		7</span>
<span class="p_del">-#define IRQ_ORION5X_GPIO_16_23		8</span>
<span class="p_del">-#define IRQ_ORION5X_GPIO_24_31		9</span>
<span class="p_del">-#define IRQ_ORION5X_PCIE0_ERR		10</span>
<span class="p_del">-#define IRQ_ORION5X_PCIE0_INT		11</span>
<span class="p_del">-#define IRQ_ORION5X_USB1_CTRL		12</span>
<span class="p_del">-#define IRQ_ORION5X_DEV_BUS_ERR		14</span>
<span class="p_del">-#define IRQ_ORION5X_PCI_ERR		15</span>
<span class="p_del">-#define IRQ_ORION5X_USB_BR_ERR		16</span>
<span class="p_del">-#define IRQ_ORION5X_USB0_CTRL		17</span>
<span class="p_del">-#define IRQ_ORION5X_ETH_RX		18</span>
<span class="p_del">-#define IRQ_ORION5X_ETH_TX		19</span>
<span class="p_del">-#define IRQ_ORION5X_ETH_MISC		20</span>
<span class="p_del">-#define IRQ_ORION5X_ETH_SUM		21</span>
<span class="p_del">-#define IRQ_ORION5X_ETH_ERR		22</span>
<span class="p_del">-#define IRQ_ORION5X_IDMA_ERR		23</span>
<span class="p_del">-#define IRQ_ORION5X_IDMA_0		24</span>
<span class="p_del">-#define IRQ_ORION5X_IDMA_1		25</span>
<span class="p_del">-#define IRQ_ORION5X_IDMA_2		26</span>
<span class="p_del">-#define IRQ_ORION5X_IDMA_3		27</span>
<span class="p_del">-#define IRQ_ORION5X_CESA		28</span>
<span class="p_del">-#define IRQ_ORION5X_SATA		29</span>
<span class="p_del">-#define IRQ_ORION5X_XOR0		30</span>
<span class="p_del">-#define IRQ_ORION5X_XOR1		31</span>
<span class="p_add">+#define IRQ_ORION5X_BRIDGE		(1 + 0)</span>
<span class="p_add">+#define IRQ_ORION5X_DOORBELL_H2C	(1 + 1)</span>
<span class="p_add">+#define IRQ_ORION5X_DOORBELL_C2H	(1 + 2)</span>
<span class="p_add">+#define IRQ_ORION5X_UART0		(1 + 3)</span>
<span class="p_add">+#define IRQ_ORION5X_UART1		(1 + 4)</span>
<span class="p_add">+#define IRQ_ORION5X_I2C			(1 + 5)</span>
<span class="p_add">+#define IRQ_ORION5X_GPIO_0_7		(1 + 6)</span>
<span class="p_add">+#define IRQ_ORION5X_GPIO_8_15		(1 + 7)</span>
<span class="p_add">+#define IRQ_ORION5X_GPIO_16_23		(1 + 8)</span>
<span class="p_add">+#define IRQ_ORION5X_GPIO_24_31		(1 + 9)</span>
<span class="p_add">+#define IRQ_ORION5X_PCIE0_ERR		(1 + 10)</span>
<span class="p_add">+#define IRQ_ORION5X_PCIE0_INT		(1 + 11)</span>
<span class="p_add">+#define IRQ_ORION5X_USB1_CTRL		(1 + 12)</span>
<span class="p_add">+#define IRQ_ORION5X_DEV_BUS_ERR		(1 + 14)</span>
<span class="p_add">+#define IRQ_ORION5X_PCI_ERR		(1 + 15)</span>
<span class="p_add">+#define IRQ_ORION5X_USB_BR_ERR		(1 + 16)</span>
<span class="p_add">+#define IRQ_ORION5X_USB0_CTRL		(1 + 17)</span>
<span class="p_add">+#define IRQ_ORION5X_ETH_RX		(1 + 18)</span>
<span class="p_add">+#define IRQ_ORION5X_ETH_TX		(1 + 19)</span>
<span class="p_add">+#define IRQ_ORION5X_ETH_MISC		(1 + 20)</span>
<span class="p_add">+#define IRQ_ORION5X_ETH_SUM		(1 + 21)</span>
<span class="p_add">+#define IRQ_ORION5X_ETH_ERR		(1 + 22)</span>
<span class="p_add">+#define IRQ_ORION5X_IDMA_ERR		(1 + 23)</span>
<span class="p_add">+#define IRQ_ORION5X_IDMA_0		(1 + 24)</span>
<span class="p_add">+#define IRQ_ORION5X_IDMA_1		(1 + 25)</span>
<span class="p_add">+#define IRQ_ORION5X_IDMA_2		(1 + 26)</span>
<span class="p_add">+#define IRQ_ORION5X_IDMA_3		(1 + 27)</span>
<span class="p_add">+#define IRQ_ORION5X_CESA		(1 + 28)</span>
<span class="p_add">+#define IRQ_ORION5X_SATA		(1 + 29)</span>
<span class="p_add">+#define IRQ_ORION5X_XOR0		(1 + 30)</span>
<span class="p_add">+#define IRQ_ORION5X_XOR1		(1 + 31)</span>
 
 /*
  * Orion General Purpose Pins
  */
<span class="p_del">-#define IRQ_ORION5X_GPIO_START	32</span>
<span class="p_add">+#define IRQ_ORION5X_GPIO_START	33</span>
 #define NR_GPIO_IRQS		32
 
 #define NR_IRQS			(IRQ_ORION5X_GPIO_START + NR_GPIO_IRQS)
<span class="p_header">diff --git a/arch/arm/mach-orion5x/irq.c b/arch/arm/mach-orion5x/irq.c</span>
<span class="p_header">index cd4bac4d7e43..086ecb87d885 100644</span>
<span class="p_header">--- a/arch/arm/mach-orion5x/irq.c</span>
<span class="p_header">+++ b/arch/arm/mach-orion5x/irq.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)</span>
 	stat = readl_relaxed(MAIN_IRQ_CAUSE);
 	stat &amp;= readl_relaxed(MAIN_IRQ_MASK);
 	if (stat) {
<span class="p_del">-		unsigned int hwirq = __fls(stat);</span>
<span class="p_add">+		unsigned int hwirq = 1 + __fls(stat);</span>
 		handle_IRQ(hwirq, regs);
 		return;
 	}
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> __exception_irq_entry orion5x_legacy_handle_irq(struct pt_regs *regs)</span>
 
 void __init orion5x_init_irq(void)
 {
<span class="p_del">-	orion_irq_init(0, MAIN_IRQ_MASK);</span>
<span class="p_add">+	orion_irq_init(1, MAIN_IRQ_MASK);</span>
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(orion5x_legacy_handle_irq);
<span class="p_header">diff --git a/arch/arm/mach-rockchip/platsmp.c b/arch/arm/mach-rockchip/platsmp.c</span>
<span class="p_header">index 2e6ab67e2284..611a5f96d3ca 100644</span>
<span class="p_header">--- a/arch/arm/mach-rockchip/platsmp.c</span>
<span class="p_header">+++ b/arch/arm/mach-rockchip/platsmp.c</span>
<span class="p_chunk">@@ -72,29 +72,22 @@</span> <span class="p_context"> static struct reset_control *rockchip_get_core_reset(int cpu)</span>
 static int pmu_set_power_domain(int pd, bool on)
 {
 	u32 val = (on) ? 0 : BIT(pd);
<span class="p_add">+	struct reset_control *rstc = rockchip_get_core_reset(pd);</span>
 	int ret;
 
<span class="p_add">+	if (IS_ERR(rstc) &amp;&amp; read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {</span>
<span class="p_add">+		pr_err(&quot;%s: could not get reset control for core %d\n&quot;,</span>
<span class="p_add">+		       __func__, pd);</span>
<span class="p_add">+		return PTR_ERR(rstc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * We need to soft reset the cpu when we turn off the cpu power domain,
 	 * or else the active processors might be stalled when the individual
 	 * processor is powered down.
 	 */
<span class="p_del">-	if (read_cpuid_part() != ARM_CPU_PART_CORTEX_A9) {</span>
<span class="p_del">-		struct reset_control *rstc = rockchip_get_core_reset(pd);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (IS_ERR(rstc)) {</span>
<span class="p_del">-			pr_err(&quot;%s: could not get reset control for core %d\n&quot;,</span>
<span class="p_del">-			       __func__, pd);</span>
<span class="p_del">-			return PTR_ERR(rstc);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		if (on)</span>
<span class="p_del">-			reset_control_deassert(rstc);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			reset_control_assert(rstc);</span>
<span class="p_del">-</span>
<span class="p_del">-		reset_control_put(rstc);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!IS_ERR(rstc) &amp;&amp; !on)</span>
<span class="p_add">+		reset_control_assert(rstc);</span>
 
 	ret = regmap_update_bits(pmu, PMU_PWRDN_CON, BIT(pd), val);
 	if (ret &lt; 0) {
<span class="p_chunk">@@ -112,6 +105,12 @@</span> <span class="p_context"> static int pmu_set_power_domain(int pd, bool on)</span>
 		}
 	}
 
<span class="p_add">+	if (!IS_ERR(rstc)) {</span>
<span class="p_add">+		if (on)</span>
<span class="p_add">+			reset_control_deassert(rstc);</span>
<span class="p_add">+		reset_control_put(rstc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -147,8 +146,12 @@</span> <span class="p_context"> static int __cpuinit rockchip_boot_secondary(unsigned int cpu,</span>
 		 * the mailbox:
 		 * sram_base_addr + 4: 0xdeadbeaf
 		 * sram_base_addr + 8: start address for pc
<span class="p_add">+		 * The cpu0 need to wait the other cpus other than cpu0 entering</span>
<span class="p_add">+		 * the wfe state.The wait time is affected by many aspects.</span>
<span class="p_add">+		 * (e.g: cpu frequency, bootrom frequency, sram frequency, ...)</span>
 		 * */
<span class="p_del">-		udelay(10);</span>
<span class="p_add">+		mdelay(1); /* ensure the cpus other than cpu0 to startup */</span>
<span class="p_add">+</span>
 		writel(virt_to_phys(secondary_startup), sram_base_addr + 8);
 		writel(0xDEADBEAF, sram_base_addr + 4);
 		dsb_sev();
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rm_mmu.c b/arch/powerpc/kvm/book3s_hv_rm_mmu.c</span>
<span class="p_header">index b027a89737b6..c6d601cc9764 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rm_mmu.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rm_mmu.c</span>
<span class="p_chunk">@@ -421,14 +421,20 @@</span> <span class="p_context"> long kvmppc_do_h_remove(struct kvm *kvm, unsigned long flags,</span>
 	rev = real_vmalloc_addr(&amp;kvm-&gt;arch.revmap[pte_index]);
 	v = pte &amp; ~HPTE_V_HVLOCK;
 	if (v &amp; HPTE_V_VALID) {
<span class="p_del">-		u64 pte1;</span>
<span class="p_del">-</span>
<span class="p_del">-		pte1 = be64_to_cpu(hpte[1]);</span>
 		hpte[0] &amp;= ~cpu_to_be64(HPTE_V_VALID);
<span class="p_del">-		rb = compute_tlbie_rb(v, pte1, pte_index);</span>
<span class="p_add">+		rb = compute_tlbie_rb(v, be64_to_cpu(hpte[1]), pte_index);</span>
 		do_tlbies(kvm, &amp;rb, 1, global_invalidates(kvm, flags), true);
<span class="p_del">-		/* Read PTE low word after tlbie to get final R/C values */</span>
<span class="p_del">-		remove_revmap_chain(kvm, pte_index, rev, v, pte1);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The reference (R) and change (C) bits in a HPT</span>
<span class="p_add">+		 * entry can be set by hardware at any time up until</span>
<span class="p_add">+		 * the HPTE is invalidated and the TLB invalidation</span>
<span class="p_add">+		 * sequence has completed.  This means that when</span>
<span class="p_add">+		 * removing a HPTE, we need to re-read the HPTE after</span>
<span class="p_add">+		 * the invalidation sequence has completed in order to</span>
<span class="p_add">+		 * obtain reliable values of R and C.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		remove_revmap_chain(kvm, pte_index, rev, v,</span>
<span class="p_add">+				    be64_to_cpu(hpte[1]));</span>
 	}
 	r = rev-&gt;guest_rpte &amp; ~HPTE_GR_RESERVED;
 	note_hpte_modification(kvm, rev);
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 4d70df26c402..3b2d2c5b6376 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -1127,6 +1127,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_HAS_PPR)</span>
 	cmpwi	r12, BOOK3S_INTERRUPT_H_DOORBELL
 	bne	3f
 	lbz	r0, HSTATE_HOST_IPI(r13)
<span class="p_add">+	cmpwi	r0, 0</span>
 	beq	4f
 	b	guest_exit_cont
 3:
<span class="p_header">diff --git a/arch/s390/kernel/setup.c b/arch/s390/kernel/setup.c</span>
<span class="p_header">index 7262fe438c99..1942f22e6694 100644</span>
<span class="p_header">--- a/arch/s390/kernel/setup.c</span>
<span class="p_header">+++ b/arch/s390/kernel/setup.c</span>
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> static void __init setup_memory(void)</span>
 /*
  * Setup hardware capabilities.
  */
<span class="p_del">-static void __init setup_hwcaps(void)</span>
<span class="p_add">+static int __init setup_hwcaps(void)</span>
 {
 	static const int stfl_bits[6] = { 0, 2, 7, 17, 19, 21 };
 	struct cpuid cpu_id;
<span class="p_chunk">@@ -749,9 +749,11 @@</span> <span class="p_context"> static void __init setup_hwcaps(void)</span>
 		elf_hwcap |= HWCAP_S390_TE;
 
 	/*
<span class="p_del">-	 * Vector extension HWCAP_S390_VXRS is bit 11.</span>
<span class="p_add">+	 * Vector extension HWCAP_S390_VXRS is bit 11. The Vector extension</span>
<span class="p_add">+	 * can be disabled with the &quot;novx&quot; parameter. Use MACHINE_HAS_VX</span>
<span class="p_add">+	 * instead of facility bit 129.</span>
 	 */
<span class="p_del">-	if (test_facility(129))</span>
<span class="p_add">+	if (MACHINE_HAS_VX)</span>
 		elf_hwcap |= HWCAP_S390_VXRS;
 	get_cpu_id(&amp;cpu_id);
 	add_device_randomness(&amp;cpu_id, sizeof(cpu_id));
<span class="p_chunk">@@ -788,7 +790,9 @@</span> <span class="p_context"> static void __init setup_hwcaps(void)</span>
 		strcpy(elf_platform, &quot;z13&quot;);
 		break;
 	}
<span class="p_add">+	return 0;</span>
 }
<span class="p_add">+arch_initcall(setup_hwcaps);</span>
 
 /*
  * Add system information as device randomness
<span class="p_chunk">@@ -871,11 +875,6 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
         cpu_init();
 
 	/*
<span class="p_del">-	 * Setup capabilities (ELF_HWCAP &amp; ELF_PLATFORM).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	setup_hwcaps();</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * Create kernel page tables and switch to virtual addressing.
 	 */
         paging_init();
<span class="p_header">diff --git a/arch/x86/crypto/ghash-clmulni-intel_glue.c b/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_header">index 2079baf06bdd..daf8d2b9a217 100644</span>
<span class="p_header">--- a/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_chunk">@@ -294,6 +294,7 @@</span> <span class="p_context"> static struct ahash_alg ghash_async_alg = {</span>
 			.cra_name		= &quot;ghash&quot;,
 			.cra_driver_name	= &quot;ghash-clmulni&quot;,
 			.cra_priority		= 400,
<span class="p_add">+			.cra_ctxsize		= sizeof(struct ghash_async_ctx),</span>
 			.cra_flags		= CRYPTO_ALG_TYPE_AHASH | CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= GHASH_BLOCK_SIZE,
 			.cra_type		= &amp;crypto_ahash_type,
<span class="p_header">diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h</span>
<span class="p_header">index a0bf89fd2647..4e10d73cf018 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/desc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/desc.h</span>
<span class="p_chunk">@@ -280,21 +280,6 @@</span> <span class="p_context"> static inline void clear_LDT(void)</span>
 	set_ldt(NULL, 0);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * load one particular LDT into the current CPU</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void load_LDT_nolock(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_ldt(pc-&gt;ldt, pc-&gt;size);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void load_LDT(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	load_LDT_nolock(pc);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long get_desc_base(const struct desc_struct *desc)
 {
 	return (unsigned)(desc-&gt;base0 | ((desc-&gt;base1) &lt;&lt; 16) | ((desc-&gt;base2) &lt;&lt; 24));
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 09b9620a73b4..364d27481a52 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -9,8 +9,7 @@</span> <span class="p_context"></span>
  * we put the segment information here.
  */
 typedef struct {
<span class="p_del">-	void *ldt;</span>
<span class="p_del">-	int size;</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
 
 #ifdef CONFIG_X86_64
 	/* True if mm supports a task running in 32 bit compatibility mode. */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index e997f70f80c4..80d67dd80351 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -34,6 +34,50 @@</span> <span class="p_context"> static inline void load_mm_cr4(struct mm_struct *mm) {}</span>
 #endif
 
 /*
<span class="p_add">+ * ldt_structs can be allocated, used, and freed, but they are never</span>
<span class="p_add">+ * modified while live.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct ldt_struct {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen requires page-aligned LDTs with special permissions.  This is</span>
<span class="p_add">+	 * needed to prevent us from installing evil descriptors such as</span>
<span class="p_add">+	 * call gates.  On native, we could merge the ldt_struct and LDT</span>
<span class="p_add">+	 * allocations, but it&#39;s not worth trying to optimize.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct desc_struct *entries;</span>
<span class="p_add">+	int size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_mm_ldt(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* lockless_dereference synchronizes with smp_store_release */</span>
<span class="p_add">+	ldt = lockless_dereference(mm-&gt;context.ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Any change to mm-&gt;context.ldt is followed by an IPI to all</span>
<span class="p_add">+	 * CPUs with the mm active.  The LDT will not be freed until</span>
<span class="p_add">+	 * after the IPI is handled by all such CPUs.  This means that,</span>
<span class="p_add">+	 * if the ldt_struct changes before we return, the values we see</span>
<span class="p_add">+	 * will be safe, and the new values will be loaded before we run</span>
<span class="p_add">+	 * any user code.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * NB: don&#39;t try to convert this to use RCU without extreme care.</span>
<span class="p_add">+	 * We would still need IRQs off, because we don&#39;t want to change</span>
<span class="p_add">+	 * the local LDT after an IPI loaded a newer value than the one</span>
<span class="p_add">+	 * that we can see.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ldt))</span>
<span class="p_add">+		set_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clear_LDT();</span>
<span class="p_add">+</span>
<span class="p_add">+	DEBUG_LOCKS_WARN_ON(preemptible());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Used for LDT copy/destruction.
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm);
<span class="p_chunk">@@ -78,12 +122,12 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 		 * was called and then modify_ldt changed
 		 * prev-&gt;context.ldt but suppressed an IPI to this CPU.
 		 * In this case, prev-&gt;context.ldt != NULL, because we
<span class="p_del">-		 * never free an LDT while the mm still exists.  That</span>
<span class="p_del">-		 * means that next-&gt;context.ldt != prev-&gt;context.ldt,</span>
<span class="p_del">-		 * because mms never share an LDT.</span>
<span class="p_add">+		 * never set context.ldt to NULL while the mm still</span>
<span class="p_add">+		 * exists.  That means that next-&gt;context.ldt !=</span>
<span class="p_add">+		 * prev-&gt;context.ldt, because mms never share an LDT.</span>
 		 */
 		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 	}
 #ifdef CONFIG_SMP
 	  else {
<span class="p_chunk">@@ -106,7 +150,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			load_cr3(next-&gt;pgd);
 			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 			load_mm_cr4(next);
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 		}
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index dbe76a14c3c9..07bea80223f6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -489,6 +489,7 @@</span> <span class="p_context"> static void __init acpi_sci_ioapic_setup(u8 bus_irq, u16 polarity, u16 trigger,</span>
 		polarity = acpi_sci_flags &amp; ACPI_MADT_POLARITY_MASK;
 
 	mp_override_legacy_irq(bus_irq, polarity, trigger, gsi);
<span class="p_add">+	acpi_penalize_sci_irq(bus_irq, trigger, polarity);</span>
 
 	/*
 	 * stash over-ride to indicate we&#39;ve been here
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index a62cf04dac8a..205e0f3df501 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1434,7 +1434,7 @@</span> <span class="p_context"> void cpu_init(void)</span>
 	load_sp0(t, &amp;current-&gt;thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	clear_all_debug_regs();
 	dbg_restore_debug_regs();
<span class="p_chunk">@@ -1483,7 +1483,7 @@</span> <span class="p_context"> void cpu_init(void)</span>
 	load_sp0(t, thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	t-&gt;x86_tss.io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce_intel.c b/arch/x86/kernel/cpu/mcheck/mce_intel.c</span>
<span class="p_header">index b4a41cf030ed..e166d833cf63 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce_intel.c</span>
<span class="p_chunk">@@ -116,6 +116,27 @@</span> <span class="p_context"> void mce_intel_hcpu_update(unsigned long cpu)</span>
 	per_cpu(cmci_storm_state, cpu) = CMCI_STORM_NONE;
 }
 
<span class="p_add">+static void cmci_toggle_interrupt_mode(bool on)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags, *owned;</span>
<span class="p_add">+	int bank;</span>
<span class="p_add">+	u64 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;cmci_discover_lock, flags);</span>
<span class="p_add">+	owned = this_cpu_ptr(mce_banks_owned);</span>
<span class="p_add">+	for_each_set_bit(bank, owned, MAX_NR_BANKS) {</span>
<span class="p_add">+		rdmsrl(MSR_IA32_MCx_CTL2(bank), val);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (on)</span>
<span class="p_add">+			val |= MCI_CTL2_CMCI_EN;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			val &amp;= ~MCI_CTL2_CMCI_EN;</span>
<span class="p_add">+</span>
<span class="p_add">+		wrmsrl(MSR_IA32_MCx_CTL2(bank), val);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;cmci_discover_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 unsigned long cmci_intel_adjust_timer(unsigned long interval)
 {
 	if ((this_cpu_read(cmci_backoff_cnt) &gt; 0) &amp;&amp;
<span class="p_chunk">@@ -145,7 +166,7 @@</span> <span class="p_context"> unsigned long cmci_intel_adjust_timer(unsigned long interval)</span>
 		 */
 		if (!atomic_read(&amp;cmci_storm_on_cpus)) {
 			__this_cpu_write(cmci_storm_state, CMCI_STORM_NONE);
<span class="p_del">-			cmci_reenable();</span>
<span class="p_add">+			cmci_toggle_interrupt_mode(true);</span>
 			cmci_recheck();
 		}
 		return CMCI_POLL_INTERVAL;
<span class="p_chunk">@@ -156,22 +177,6 @@</span> <span class="p_context"> unsigned long cmci_intel_adjust_timer(unsigned long interval)</span>
 	}
 }
 
<span class="p_del">-static void cmci_storm_disable_banks(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags, *owned;</span>
<span class="p_del">-	int bank;</span>
<span class="p_del">-	u64 val;</span>
<span class="p_del">-</span>
<span class="p_del">-	raw_spin_lock_irqsave(&amp;cmci_discover_lock, flags);</span>
<span class="p_del">-	owned = this_cpu_ptr(mce_banks_owned);</span>
<span class="p_del">-	for_each_set_bit(bank, owned, MAX_NR_BANKS) {</span>
<span class="p_del">-		rdmsrl(MSR_IA32_MCx_CTL2(bank), val);</span>
<span class="p_del">-		val &amp;= ~MCI_CTL2_CMCI_EN;</span>
<span class="p_del">-		wrmsrl(MSR_IA32_MCx_CTL2(bank), val);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;cmci_discover_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static bool cmci_storm_detect(void)
 {
 	unsigned int cnt = __this_cpu_read(cmci_storm_cnt);
<span class="p_chunk">@@ -193,7 +198,7 @@</span> <span class="p_context"> static bool cmci_storm_detect(void)</span>
 	if (cnt &lt;= CMCI_STORM_THRESHOLD)
 		return false;
 
<span class="p_del">-	cmci_storm_disable_banks();</span>
<span class="p_add">+	cmci_toggle_interrupt_mode(false);</span>
 	__this_cpu_write(cmci_storm_state, CMCI_STORM_ACTIVE);
 	r = atomic_add_return(1, &amp;cmci_storm_on_cpus);
 	mce_timer_kick(CMCI_STORM_INTERVAL);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index aa4e3a74e541..4cc98a4e8ea9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -2170,21 +2170,25 @@</span> <span class="p_context"> static unsigned long get_segment_base(unsigned int segment)</span>
 	int idx = segment &gt;&gt; 3;
 
 	if ((segment &amp; SEGMENT_TI_MASK) == SEGMENT_LDT) {
<span class="p_add">+		struct ldt_struct *ldt;</span>
<span class="p_add">+</span>
 		if (idx &gt; LDT_ENTRIES)
 			return 0;
 
<span class="p_del">-		if (idx &gt; current-&gt;active_mm-&gt;context.size)</span>
<span class="p_add">+		/* IRQs are off, so this synchronizes with smp_store_release */</span>
<span class="p_add">+		ldt = lockless_dereference(current-&gt;active_mm-&gt;context.ldt);</span>
<span class="p_add">+		if (!ldt || idx &gt; ldt-&gt;size)</span>
 			return 0;
 
<span class="p_del">-		desc = current-&gt;active_mm-&gt;context.ldt;</span>
<span class="p_add">+		desc = &amp;ldt-&gt;entries[idx];</span>
 	} else {
 		if (idx &gt; GDT_ENTRIES)
 			return 0;
 
<span class="p_del">-		desc = raw_cpu_ptr(gdt_page.gdt);</span>
<span class="p_add">+		desc = raw_cpu_ptr(gdt_page.gdt) + idx;</span>
 	}
 
<span class="p_del">-	return get_desc_base(desc + idx);</span>
<span class="p_add">+	return get_desc_base(desc);</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_header">diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c</span>
<span class="p_header">index c37886d759cc..2bcc0525f1c1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ldt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ldt.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
 
<span class="p_chunk">@@ -20,82 +21,82 @@</span> <span class="p_context"></span>
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/syscalls.h&gt;
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+/* context.lock is held for us, so we don&#39;t need any locking. */</span>
 static void flush_ldt(void *current_mm)
 {
<span class="p_del">-	if (current-&gt;active_mm == current_mm)</span>
<span class="p_del">-		load_LDT(&amp;current-&gt;active_mm-&gt;context);</span>
<span class="p_add">+	mm_context_t *pc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;active_mm != current_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pc = &amp;current-&gt;active_mm-&gt;context;</span>
<span class="p_add">+	set_ldt(pc-&gt;ldt-&gt;entries, pc-&gt;ldt-&gt;size);</span>
 }
<span class="p_del">-#endif</span>
 
<span class="p_del">-static int alloc_ldt(mm_context_t *pc, int mincount, int reload)</span>
<span class="p_add">+/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span>
<span class="p_add">+static struct ldt_struct *alloc_ldt_struct(int size)</span>
 {
<span class="p_del">-	void *oldldt, *newldt;</span>
<span class="p_del">-	int oldsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mincount &lt;= pc-&gt;size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	oldsize = pc-&gt;size;</span>
<span class="p_del">-	mincount = (mincount + (PAGE_SIZE / LDT_ENTRY_SIZE - 1)) &amp;</span>
<span class="p_del">-			(~(PAGE_SIZE / LDT_ENTRY_SIZE - 1));</span>
<span class="p_del">-	if (mincount * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-		newldt = vmalloc(mincount * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
<span class="p_add">+	int alloc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &gt; LDT_ENTRIES)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL);</span>
<span class="p_add">+	if (!new_ldt)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));</span>
<span class="p_add">+	alloc_size = size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen is very picky: it requires a page-aligned LDT that has no</span>
<span class="p_add">+	 * trailing nonzero bytes in any page that contains LDT descriptors.</span>
<span class="p_add">+	 * Keep it simple: zero the whole allocation and never allocate less</span>
<span class="p_add">+	 * than PAGE_SIZE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (alloc_size &gt; PAGE_SIZE)</span>
<span class="p_add">+		new_ldt-&gt;entries = vzalloc(alloc_size);</span>
 	else
<span class="p_del">-		newldt = (void *)__get_free_page(GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!newldt)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		new_ldt-&gt;entries = kzalloc(PAGE_SIZE, GFP_KERNEL);</span>
 
<span class="p_del">-	if (oldsize)</span>
<span class="p_del">-		memcpy(newldt, pc-&gt;ldt, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	oldldt = pc-&gt;ldt;</span>
<span class="p_del">-	memset(newldt + oldsize * LDT_ENTRY_SIZE, 0,</span>
<span class="p_del">-	       (mincount - oldsize) * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	if (!new_ldt-&gt;entries) {</span>
<span class="p_add">+		kfree(new_ldt);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	paravirt_alloc_ldt(newldt, mincount);</span>
<span class="p_add">+	new_ldt-&gt;size = size;</span>
<span class="p_add">+	return new_ldt;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* CHECKME: Do we really need this ? */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pc-&gt;ldt = newldt;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	pc-&gt;size = mincount;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (reload) {</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-		preempt_disable();</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-		if (!cpumask_equal(mm_cpumask(current-&gt;mm),</span>
<span class="p_del">-				   cpumask_of(smp_processor_id())))</span>
<span class="p_del">-			smp_call_function(flush_ldt, current-&gt;mm, 1);</span>
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-#else</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (oldsize) {</span>
<span class="p_del">-		paravirt_free_ldt(oldldt, oldsize);</span>
<span class="p_del">-		if (oldsize * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(oldldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(oldldt));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+/* After calling this, the LDT is immutable. */</span>
<span class="p_add">+static void finalize_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	paravirt_alloc_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
 }
 
<span class="p_del">-static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
<span class="p_add">+/* context.lock is held */</span>
<span class="p_add">+static void install_ldt(struct mm_struct *current_mm,</span>
<span class="p_add">+			struct ldt_struct *ldt)</span>
 {
<span class="p_del">-	int err = alloc_ldt(new, old-&gt;size, 0);</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	/* Synchronizes with lockless_dereference in load_mm_ldt. */</span>
<span class="p_add">+	smp_store_release(&amp;current_mm-&gt;context.ldt, ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Activate the LDT for all CPUs using current_mm. */</span>
<span class="p_add">+	on_each_cpu_mask(mm_cpumask(current_mm), flush_ldt, current_mm, true);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+static void free_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(!ldt))</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	for (i = 0; i &lt; old-&gt;size; i++)</span>
<span class="p_del">-		write_ldt_entry(new-&gt;ldt, i, old-&gt;ldt + i * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	paravirt_free_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	if (ldt-&gt;size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_add">+		vfree(ldt-&gt;entries);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kfree(ldt-&gt;entries);</span>
<span class="p_add">+	kfree(ldt);</span>
 }
 
 /*
<span class="p_chunk">@@ -104,17 +105,37 @@</span> <span class="p_context"> static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
 	struct mm_struct *old_mm;
 	int retval = 0;
 
 	mutex_init(&amp;mm-&gt;context.lock);
<span class="p_del">-	mm-&gt;context.size = 0;</span>
 	old_mm = current-&gt;mm;
<span class="p_del">-	if (old_mm &amp;&amp; old_mm-&gt;context.size &gt; 0) {</span>
<span class="p_del">-		mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_del">-		retval = copy_ldt(&amp;mm-&gt;context, &amp;old_mm-&gt;context);</span>
<span class="p_del">-		mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		return 0;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm-&gt;context.ldt) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;size);</span>
<span class="p_add">+	if (!new_ldt) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span>
<span class="p_add">+	       new_ldt-&gt;size * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	mm-&gt;context.ldt = new_ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -125,53 +146,47 @@</span> <span class="p_context"> int init_new_context(struct task_struct *tsk, struct mm_struct *mm)</span>
  */
 void destroy_context(struct mm_struct *mm)
 {
<span class="p_del">-	if (mm-&gt;context.size) {</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-		/* CHECKME: Can this ever happen ? */</span>
<span class="p_del">-		if (mm == current-&gt;active_mm)</span>
<span class="p_del">-			clear_LDT();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		paravirt_free_ldt(mm-&gt;context.ldt, mm-&gt;context.size);</span>
<span class="p_del">-		if (mm-&gt;context.size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(mm-&gt;context.ldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(mm-&gt;context.ldt));</span>
<span class="p_del">-		mm-&gt;context.size = 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	free_ldt_struct(mm-&gt;context.ldt);</span>
<span class="p_add">+	mm-&gt;context.ldt = NULL;</span>
 }
 
 static int read_ldt(void __user *ptr, unsigned long bytecount)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int retval;</span>
 	unsigned long size;
 	struct mm_struct *mm = current-&gt;mm;
 
<span class="p_del">-	if (!mm-&gt;context.size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mm-&gt;context.ldt) {</span>
<span class="p_add">+		retval = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)
 		bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	size = mm-&gt;context.size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+	size = mm-&gt;context.ldt-&gt;size * LDT_ENTRY_SIZE;</span>
 	if (size &gt; bytecount)
 		size = bytecount;
 
<span class="p_del">-	err = 0;</span>
<span class="p_del">-	if (copy_to_user(ptr, mm-&gt;context.ldt, size))</span>
<span class="p_del">-		err = -EFAULT;</span>
<span class="p_del">-	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto error_return;</span>
<span class="p_add">+	if (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, size)) {</span>
<span class="p_add">+		retval = -EFAULT;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (size != bytecount) {
<span class="p_del">-		/* zero-fill the rest */</span>
<span class="p_del">-		if (clear_user(ptr + size, bytecount - size) != 0) {</span>
<span class="p_del">-			err = -EFAULT;</span>
<span class="p_del">-			goto error_return;</span>
<span class="p_add">+		/* Zero-fill the rest and pretend we read bytecount bytes. */</span>
<span class="p_add">+		if (clear_user(ptr + size, bytecount - size)) {</span>
<span class="p_add">+			retval = -EFAULT;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
 	}
<span class="p_del">-	return bytecount;</span>
<span class="p_del">-error_return:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	retval = bytecount;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	return retval;</span>
 }
 
 static int read_default_ldt(void __user *ptr, unsigned long bytecount)
<span class="p_chunk">@@ -195,6 +210,8 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 	struct desc_struct ldt;
 	int error;
 	struct user_desc ldt_info;
<span class="p_add">+	int oldsize, newsize;</span>
<span class="p_add">+	struct ldt_struct *new_ldt, *old_ldt;</span>
 
 	error = -EINVAL;
 	if (bytecount != sizeof(ldt_info))
<span class="p_chunk">@@ -213,34 +230,39 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 			goto out;
 	}
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (ldt_info.entry_number &gt;= mm-&gt;context.size) {</span>
<span class="p_del">-		error = alloc_ldt(&amp;current-&gt;mm-&gt;context,</span>
<span class="p_del">-				  ldt_info.entry_number + 1, 1);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allow LDTs to be cleared by the user. */</span>
<span class="p_del">-	if (ldt_info.base_addr == 0 &amp;&amp; ldt_info.limit == 0) {</span>
<span class="p_del">-		if (oldmode || LDT_empty(&amp;ldt_info)) {</span>
<span class="p_del">-			memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_del">-			goto install;</span>
<span class="p_add">+	if ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span>
<span class="p_add">+	    LDT_empty(&amp;ldt_info)) {</span>
<span class="p_add">+		/* The user wants to clear the entry. */</span>
<span class="p_add">+		memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_add">+			error = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_add">+		if (oldmode)</span>
<span class="p_add">+			ldt.avl = 0;</span>
 	}
 
<span class="p_del">-	if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_del">-		error = -EINVAL;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	old_ldt = mm-&gt;context.ldt;</span>
<span class="p_add">+	oldsize = old_ldt ? old_ldt-&gt;size : 0;</span>
<span class="p_add">+	newsize = max((int)(ldt_info.entry_number + 1), oldsize);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = -ENOMEM;</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(newsize);</span>
<span class="p_add">+	if (!new_ldt)</span>
 		goto out_unlock;
<span class="p_del">-	}</span>
 
<span class="p_del">-	fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_del">-	if (oldmode)</span>
<span class="p_del">-		ldt.avl = 0;</span>
<span class="p_add">+	if (old_ldt)</span>
<span class="p_add">+		memcpy(new_ldt-&gt;entries, old_ldt-&gt;entries, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
 
<span class="p_del">-	/* Install the new entry ...  */</span>
<span class="p_del">-install:</span>
<span class="p_del">-	write_ldt_entry(mm-&gt;context.ldt, ldt_info.entry_number, &amp;ldt);</span>
<span class="p_add">+	install_ldt(mm, new_ldt);</span>
<span class="p_add">+	free_ldt_struct(old_ldt);</span>
 	error = 0;
 
 out_unlock:
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index ddfdbf74f174..5e0bf57d9944 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -122,11 +122,11 @@</span> <span class="p_context"> void __show_regs(struct pt_regs *regs, int all)</span>
 void release_thread(struct task_struct *dead_task)
 {
 	if (dead_task-&gt;mm) {
<span class="p_del">-		if (dead_task-&gt;mm-&gt;context.size) {</span>
<span class="p_add">+		if (dead_task-&gt;mm-&gt;context.ldt) {</span>
 			pr_warn(&quot;WARNING: dead process %s still has LDT? &lt;%p/%d&gt;\n&quot;,
 				dead_task-&gt;comm,
 				dead_task-&gt;mm-&gt;context.ldt,
<span class="p_del">-				dead_task-&gt;mm-&gt;context.size);</span>
<span class="p_add">+				dead_task-&gt;mm-&gt;context.ldt-&gt;size);</span>
 			BUG();
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kernel/step.c b/arch/x86/kernel/step.c</span>
<span class="p_header">index 9b4d51d0c0d0..0ccb53a9fcd9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/step.c</span>
<span class="p_header">+++ b/arch/x86/kernel/step.c</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/ptrace.h&gt;
 #include &lt;asm/desc.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)
 {
<span class="p_chunk">@@ -27,13 +28,14 @@</span> <span class="p_context"> unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *re</span>
 		struct desc_struct *desc;
 		unsigned long base;
 
<span class="p_del">-		seg &amp;= ~7UL;</span>
<span class="p_add">+		seg &gt;&gt;= 3;</span>
 
 		mutex_lock(&amp;child-&gt;mm-&gt;context.lock);
<span class="p_del">-		if (unlikely((seg &gt;&gt; 3) &gt;= child-&gt;mm-&gt;context.size))</span>
<span class="p_add">+		if (unlikely(!child-&gt;mm-&gt;context.ldt ||</span>
<span class="p_add">+			     seg &gt;= child-&gt;mm-&gt;context.ldt-&gt;size))</span>
 			addr = -1L; /* bogus selector, access would fault */
 		else {
<span class="p_del">-			desc = child-&gt;mm-&gt;context.ldt + seg;</span>
<span class="p_add">+			desc = &amp;child-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
 			base = get_desc_base(desc);
 
 			/* 16-bit code segment? */
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index b73337634214..554e877e0bc4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -357,12 +357,6 @@</span> <span class="p_context"> static u64 __get_spte_lockless(u64 *sptep)</span>
 {
 	return ACCESS_ONCE(*sptep);
 }
<span class="p_del">-</span>
<span class="p_del">-static bool __check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* It is valid if the spte is zapped. */</span>
<span class="p_del">-	return spte == 0ull;</span>
<span class="p_del">-}</span>
 #else
 union split_spte {
 	struct {
<span class="p_chunk">@@ -478,23 +472,6 @@</span> <span class="p_context"> retry:</span>
 
 	return spte.spte;
 }
<span class="p_del">-</span>
<span class="p_del">-static bool __check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	union split_spte sspte = (union split_spte)spte;</span>
<span class="p_del">-	u32 high_mmio_mask = shadow_mmio_mask &gt;&gt; 32;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It is valid if the spte is zapped. */</span>
<span class="p_del">-	if (spte == 0ull)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It is valid if the spte is being zapped. */</span>
<span class="p_del">-	if (sspte.spte_low == 0ull &amp;&amp;</span>
<span class="p_del">-	    (sspte.spte_high &amp; high_mmio_mask) == high_mmio_mask)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
 #endif
 
 static bool spte_is_locklessly_modifiable(u64 spte)
<span class="p_chunk">@@ -3343,21 +3320,6 @@</span> <span class="p_context"> static bool quickly_check_mmio_pf(struct kvm_vcpu *vcpu, u64 addr, bool direct)</span>
 	return vcpu_match_mmio_gva(vcpu, addr);
 }
 
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On direct hosts, the last spte is only allows two states</span>
<span class="p_del">- * for mmio page fault:</span>
<span class="p_del">- *   - It is the mmio spte</span>
<span class="p_del">- *   - It is zapped or it is being zapped.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function completely checks the spte when the last spte</span>
<span class="p_del">- * is not the mmio spte.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __check_direct_spte_mmio_pf(spte);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static u64 walk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr)
 {
 	struct kvm_shadow_walk_iterator iterator;
<span class="p_chunk">@@ -3400,13 +3362,6 @@</span> <span class="p_context"> int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct)</span>
 	}
 
 	/*
<span class="p_del">-	 * It&#39;s ok if the gva is remapped by other cpus on shadow guest,</span>
<span class="p_del">-	 * it&#39;s a BUG if the gfn is not a mmio page.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (direct &amp;&amp; !check_direct_spte_mmio_pf(spte))</span>
<span class="p_del">-		return RET_MMIO_PF_BUG;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * If the page table is zapped by other cpus, let CPU fault again on
 	 * the address.
 	 */
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index ea306adbbc13..47a32f743a91 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -2192,7 +2192,7 @@</span> <span class="p_context"> int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)</span>
 		if (guest_cpuid_has_tsc_adjust(vcpu)) {
 			if (!msr_info-&gt;host_initiated) {
 				s64 adj = data - vcpu-&gt;arch.ia32_tsc_adjust_msr;
<span class="p_del">-				kvm_x86_ops-&gt;adjust_tsc_offset(vcpu, adj, true);</span>
<span class="p_add">+				adjust_tsc_offset_guest(vcpu, adj);</span>
 			}
 			vcpu-&gt;arch.ia32_tsc_adjust_msr = data;
 		}
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">index 9b868124128d..274a52b1183e 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/traps.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 #include &lt;asm/user.h&gt;
 #include &lt;asm/i387.h&gt;
 
<span class="p_chunk">@@ -185,7 +184,7 @@</span> <span class="p_context"> void math_emulate(struct math_emu_info *info)</span>
 			math_abort(FPU_info, SIGILL);
 		}
 
<span class="p_del">-		code_descriptor = LDT_DESCRIPTOR(FPU_CS);</span>
<span class="p_add">+		code_descriptor = FPU_get_ldt_descriptor(FPU_CS);</span>
 		if (SEG_D_SIZE(code_descriptor)) {
 			/* The above test may be wrong, the book is not clear */
 			/* Segmented 32 bit protected mode */
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_system.h b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">index 2c614410a5f3..d342fce49447 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_chunk">@@ -16,9 +16,24 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
 
<span class="p_del">-/* s is always from a cpu register, and the cpu does bounds checking</span>
<span class="p_del">- * during register load --&gt; no further bounds checks needed */</span>
<span class="p_del">-#define LDT_DESCRIPTOR(s)	(((struct desc_struct *)current-&gt;mm-&gt;context.ldt)[(s) &gt;&gt; 3])</span>
<span class="p_add">+#include &lt;asm/desc.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct desc_struct FPU_get_ldt_descriptor(unsigned seg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static struct desc_struct zero_desc;</span>
<span class="p_add">+	struct desc_struct ret = zero_desc;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MODIFY_LDT_SYSCALL</span>
<span class="p_add">+	seg &gt;&gt;= 3;</span>
<span class="p_add">+	mutex_lock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+	if (current-&gt;mm-&gt;context.ldt &amp;&amp; seg &lt; current-&gt;mm-&gt;context.ldt-&gt;size)</span>
<span class="p_add">+		ret = current-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
<span class="p_add">+	mutex_unlock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define SEG_D_SIZE(x)		((x).b &amp; (3 &lt;&lt; 21))
 #define SEG_G_BIT(x)		((x).b &amp; (1 &lt;&lt; 23))
 #define SEG_GRANULARITY(x)	(((x).b &amp; (1 &lt;&lt; 23)) ? 4096 : 1)
<span class="p_header">diff --git a/arch/x86/math-emu/get_address.c b/arch/x86/math-emu/get_address.c</span>
<span class="p_header">index 6ef5e99380f9..8300db71c2a6 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/get_address.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/get_address.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/stddef.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 
 #include &quot;fpu_system.h&quot;
 #include &quot;exception.h&quot;
<span class="p_chunk">@@ -158,7 +157,7 @@</span> <span class="p_context"> static long pm_address(u_char FPU_modrm, u_char segment,</span>
 		addr-&gt;selector = PM_REG_(segment);
 	}
 
<span class="p_del">-	descriptor = LDT_DESCRIPTOR(PM_REG_(segment));</span>
<span class="p_add">+	descriptor = FPU_get_ldt_descriptor(addr-&gt;selector);</span>
 	base_address = SEG_BASE_ADDR(descriptor);
 	address = base_address + offset;
 	limit = base_address
<span class="p_header">diff --git a/arch/x86/power/cpu.c b/arch/x86/power/cpu.c</span>
<span class="p_header">index 757678fb26e1..bf9384488399 100644</span>
<span class="p_header">--- a/arch/x86/power/cpu.c</span>
<span class="p_header">+++ b/arch/x86/power/cpu.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/fpu-internal.h&gt; /* pcntxt_mask */
 #include &lt;asm/cpu.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 #ifdef CONFIG_X86_32
 __visible unsigned long saved_context_ebx;
<span class="p_chunk">@@ -154,7 +155,7 @@</span> <span class="p_context"> static void fix_processor_context(void)</span>
 	syscall_init();				/* This sets MSR_*STAR and related */
 #endif
 	load_TR_desc();				/* This does ltr */
<span class="p_del">-	load_LDT(&amp;current-&gt;active_mm-&gt;context);	/* This does lldt */</span>
<span class="p_add">+	load_mm_ldt(current-&gt;active_mm);	/* This does lldt */</span>
 }
 
 /**
<span class="p_header">diff --git a/arch/xtensa/include/asm/traps.h b/arch/xtensa/include/asm/traps.h</span>
<span class="p_header">index 677bfcf4ee5d..28f33a8b7f5f 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/traps.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/traps.h</span>
<span class="p_chunk">@@ -25,30 +25,39 @@</span> <span class="p_context"> static inline void spill_registers(void)</span>
 {
 #if XCHAL_NUM_AREGS &gt; 16
 	__asm__ __volatile__ (
<span class="p_del">-		&quot;	call12	1f\n&quot;</span>
<span class="p_add">+		&quot;	call8	1f\n&quot;</span>
 		&quot;	_j	2f\n&quot;
 		&quot;	retw\n&quot;
 		&quot;	.align	4\n&quot;
 		&quot;1:\n&quot;
<span class="p_add">+#if XCHAL_NUM_AREGS == 32</span>
<span class="p_add">+		&quot;	_entry	a1, 32\n&quot;</span>
<span class="p_add">+		&quot;	addi	a8, a0, 3\n&quot;</span>
<span class="p_add">+		&quot;	_entry	a1, 16\n&quot;</span>
<span class="p_add">+		&quot;	mov	a12, a12\n&quot;</span>
<span class="p_add">+		&quot;	retw\n&quot;</span>
<span class="p_add">+#else</span>
 		&quot;	_entry	a1, 48\n&quot;
<span class="p_del">-		&quot;	addi	a12, a0, 3\n&quot;</span>
<span class="p_del">-#if XCHAL_NUM_AREGS &gt; 32</span>
<span class="p_del">-		&quot;	.rept	(&quot; __stringify(XCHAL_NUM_AREGS) &quot; - 32) / 12\n&quot;</span>
<span class="p_add">+		&quot;	call12	1f\n&quot;</span>
<span class="p_add">+		&quot;	retw\n&quot;</span>
<span class="p_add">+		&quot;	.align	4\n&quot;</span>
<span class="p_add">+		&quot;1:\n&quot;</span>
<span class="p_add">+		&quot;	.rept	(&quot; __stringify(XCHAL_NUM_AREGS) &quot; - 16) / 12\n&quot;</span>
 		&quot;	_entry	a1, 48\n&quot;
 		&quot;	mov	a12, a0\n&quot;
 		&quot;	.endr\n&quot;
<span class="p_del">-#endif</span>
<span class="p_del">-		&quot;	_entry	a1, 48\n&quot;</span>
<span class="p_add">+		&quot;	_entry	a1, 16\n&quot;</span>
 #if XCHAL_NUM_AREGS % 12 == 0
<span class="p_del">-		&quot;	mov	a8, a8\n&quot;</span>
<span class="p_del">-#elif XCHAL_NUM_AREGS % 12 == 4</span>
 		&quot;	mov	a12, a12\n&quot;
<span class="p_del">-#elif XCHAL_NUM_AREGS % 12 == 8</span>
<span class="p_add">+#elif XCHAL_NUM_AREGS % 12 == 4</span>
 		&quot;	mov	a4, a4\n&quot;
<span class="p_add">+#elif XCHAL_NUM_AREGS % 12 == 8</span>
<span class="p_add">+		&quot;	mov	a8, a8\n&quot;</span>
 #endif
 		&quot;	retw\n&quot;
<span class="p_add">+#endif</span>
 		&quot;2:\n&quot;
<span class="p_del">-		: : : &quot;a12&quot;, &quot;a13&quot;, &quot;memory&quot;);</span>
<span class="p_add">+		: : : &quot;a8&quot;, &quot;a9&quot;, &quot;memory&quot;);</span>
 #else
 	__asm__ __volatile__ (
 		&quot;	mov	a12, a12\n&quot;
<span class="p_header">diff --git a/arch/xtensa/kernel/entry.S b/arch/xtensa/kernel/entry.S</span>
<span class="p_header">index 82bbfa5a05b3..a2a902140c4e 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/entry.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/entry.S</span>
<span class="p_chunk">@@ -568,12 +568,13 @@</span> <span class="p_context"> user_exception_exit:</span>
 	 *	 (if we have restored WSBITS-1 frames).
 	 */
 
<span class="p_add">+2:</span>
 #if XCHAL_HAVE_THREADPTR
 	l32i	a3, a1, PT_THREADPTR
 	wur	a3, threadptr
 #endif
 
<span class="p_del">-2:	j	common_exception_exit</span>
<span class="p_add">+	j	common_exception_exit</span>
 
 	/* This is the kernel exception exit.
 	 * We avoided to do a MOVSP when we entered the exception, but we
<span class="p_chunk">@@ -1820,7 +1821,7 @@</span> <span class="p_context"> ENDPROC(system_call)</span>
 	mov	a12, a0
 	.endr
 #endif
<span class="p_del">-	_entry	a1, 48</span>
<span class="p_add">+	_entry	a1, 16</span>
 #if XCHAL_NUM_AREGS % 12 == 0
 	mov	a8, a8
 #elif XCHAL_NUM_AREGS % 12 == 4
<span class="p_chunk">@@ -1844,7 +1845,7 @@</span> <span class="p_context"> ENDPROC(system_call)</span>
 
 ENTRY(_switch_to)
 
<span class="p_del">-	entry	a1, 16</span>
<span class="p_add">+	entry	a1, 48</span>
 
 	mov	a11, a3			# and &#39;next&#39; (a3)
 
<span class="p_header">diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">index ff6d8adc9cda..fb765524cc3d 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_pnp.c</span>
<span class="p_chunk">@@ -153,6 +153,7 @@</span> <span class="p_context"> static const struct acpi_device_id acpi_pnp_device_ids[] = {</span>
 	{&quot;AEI0250&quot;},		/* PROLiNK 1456VH ISA PnP K56flex Fax Modem */
 	{&quot;AEI1240&quot;},		/* Actiontec ISA PNP 56K X2 Fax Modem */
 	{&quot;AKY1021&quot;},		/* Rockwell 56K ACF II Fax+Data+Voice Modem */
<span class="p_add">+	{&quot;ALI5123&quot;},		/* ALi Fast Infrared Controller */</span>
 	{&quot;AZT4001&quot;},		/* AZT3005 PnP SOUND DEVICE */
 	{&quot;BDP3336&quot;},		/* Best Data Products Inc. Smart One 336F PnP Modem */
 	{&quot;BRI0A49&quot;},		/* Boca Complete Ofc Communicator 14.4 Data-FAX */
<span class="p_header">diff --git a/drivers/acpi/pci_link.c b/drivers/acpi/pci_link.c</span>
<span class="p_header">index cfd7581cc19f..b09ad554430a 100644</span>
<span class="p_header">--- a/drivers/acpi/pci_link.c</span>
<span class="p_header">+++ b/drivers/acpi/pci_link.c</span>
<span class="p_chunk">@@ -826,6 +826,22 @@</span> <span class="p_context"> void acpi_penalize_isa_irq(int irq, int active)</span>
 }
 
 /*
<span class="p_add">+ * Penalize IRQ used by ACPI SCI. If ACPI SCI pin attributes conflict with</span>
<span class="p_add">+ * PCI IRQ attributes, mark ACPI SCI as ISA_ALWAYS so it won&#39;t be use for</span>
<span class="p_add">+ * PCI IRQs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void acpi_penalize_sci_irq(int irq, int trigger, int polarity)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (irq &gt;= 0 &amp;&amp; irq &lt; ARRAY_SIZE(acpi_irq_penalty)) {</span>
<span class="p_add">+		if (trigger != ACPI_MADT_TRIGGER_LEVEL ||</span>
<span class="p_add">+		    polarity != ACPI_MADT_POLARITY_ACTIVE_LOW)</span>
<span class="p_add">+			acpi_irq_penalty[irq] += PIRQ_PENALTY_ISA_ALWAYS;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			acpi_irq_penalty[irq] += PIRQ_PENALTY_PCI_USING;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Over-ride default table to reserve additional IRQs for use by ISA
  * e.g. acpi_irq_isa=5
  * Useful for telling ACPI how not to interfere with your ISA sound card.
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 65ee94454bbd..e6ea912aee31 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -349,6 +349,7 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	/* JMicron 362B and 362C have an AHCI function with IDE class code */
 	{ PCI_VDEVICE(JMICRON, 0x2362), board_ahci_ign_iferr },
 	{ PCI_VDEVICE(JMICRON, 0x236f), board_ahci_ign_iferr },
<span class="p_add">+	/* May need to update quirk_jmicron_async_suspend() for additions */</span>
 
 	/* ATI */
 	{ PCI_VDEVICE(ATI, 0x4380), board_ahci_sb600 }, /* ATI SB600 */
<span class="p_chunk">@@ -1377,18 +1378,6 @@</span> <span class="p_context"> static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	else if (pdev-&gt;vendor == 0x1c44 &amp;&amp; pdev-&gt;device == 0x8000)
 		ahci_pci_bar = AHCI_PCI_BAR_ENMOTUS;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The JMicron chip 361/363 contains one SATA controller and one</span>
<span class="p_del">-	 * PATA controller,for powering on these both controllers, we must</span>
<span class="p_del">-	 * follow the sequence one by one, otherwise one of them can not be</span>
<span class="p_del">-	 * powered on successfully, so here we disable the async suspend</span>
<span class="p_del">-	 * method for these chips.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (pdev-&gt;vendor == PCI_VENDOR_ID_JMICRON &amp;&amp;</span>
<span class="p_del">-		(pdev-&gt;device == PCI_DEVICE_ID_JMICRON_JMB363 ||</span>
<span class="p_del">-		pdev-&gt;device == PCI_DEVICE_ID_JMICRON_JMB361))</span>
<span class="p_del">-		device_disable_async_suspend(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
 	if (rc)
<span class="p_header">diff --git a/drivers/ata/pata_jmicron.c b/drivers/ata/pata_jmicron.c</span>
<span class="p_header">index 47e418b8c8ba..4d1a5d2c4287 100644</span>
<span class="p_header">--- a/drivers/ata/pata_jmicron.c</span>
<span class="p_header">+++ b/drivers/ata/pata_jmicron.c</span>
<span class="p_chunk">@@ -143,18 +143,6 @@</span> <span class="p_context"> static int jmicron_init_one (struct pci_dev *pdev, const struct pci_device_id *i</span>
 	};
 	const struct ata_port_info *ppi[] = { &amp;info, NULL };
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The JMicron chip 361/363 contains one SATA controller and one</span>
<span class="p_del">-	 * PATA controller,for powering on these both controllers, we must</span>
<span class="p_del">-	 * follow the sequence one by one, otherwise one of them can not be</span>
<span class="p_del">-	 * powered on successfully, so here we disable the async suspend</span>
<span class="p_del">-	 * method for these chips.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (pdev-&gt;vendor == PCI_VENDOR_ID_JMICRON &amp;&amp;</span>
<span class="p_del">-		(pdev-&gt;device == PCI_DEVICE_ID_JMICRON_JMB363 ||</span>
<span class="p_del">-		pdev-&gt;device == PCI_DEVICE_ID_JMICRON_JMB361))</span>
<span class="p_del">-		device_disable_async_suspend(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	return ata_pci_bmdma_init_one(pdev, ppi, &amp;jmicron_sht, NULL, 0);
 }
 
<span class="p_header">diff --git a/drivers/auxdisplay/ks0108.c b/drivers/auxdisplay/ks0108.c</span>
<span class="p_header">index 5b93852392b8..0d752851a1ee 100644</span>
<span class="p_header">--- a/drivers/auxdisplay/ks0108.c</span>
<span class="p_header">+++ b/drivers/auxdisplay/ks0108.c</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> static int __init ks0108_init(void)</span>
 
 	ks0108_pardevice = parport_register_device(ks0108_parport, KS0108_NAME,
 		NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
<span class="p_add">+	parport_put_port(ks0108_parport);</span>
 	if (ks0108_pardevice == NULL) {
 		printk(KERN_ERR KS0108_NAME &quot;: ERROR: &quot;
 			&quot;parport didn&#39;t register new device\n&quot;);
<span class="p_header">diff --git a/drivers/base/devres.c b/drivers/base/devres.c</span>
<span class="p_header">index c8a53d1e019f..875464690117 100644</span>
<span class="p_header">--- a/drivers/base/devres.c</span>
<span class="p_header">+++ b/drivers/base/devres.c</span>
<span class="p_chunk">@@ -297,10 +297,10 @@</span> <span class="p_context"> void * devres_get(struct device *dev, void *new_res,</span>
 	if (!dr) {
 		add_dr(dev, &amp;new_dr-&gt;node);
 		dr = new_dr;
<span class="p_del">-		new_dr = NULL;</span>
<span class="p_add">+		new_res = NULL;</span>
 	}
 	spin_unlock_irqrestore(&amp;dev-&gt;devres_lock, flags);
<span class="p_del">-	devres_free(new_dr);</span>
<span class="p_add">+	devres_free(new_res);</span>
 
 	return dr-&gt;data;
 }
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index ebf034b97278..7403de94832c 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -375,9 +375,7 @@</span> <span class="p_context"> int platform_device_add(struct platform_device *pdev)</span>
 
 	while (--i &gt;= 0) {
 		struct resource *r = &amp;pdev-&gt;resource[i];
<span class="p_del">-		unsigned long type = resource_type(r);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)</span>
<span class="p_add">+		if (r-&gt;parent)</span>
 			release_resource(r);
 	}
 
<span class="p_chunk">@@ -408,9 +406,7 @@</span> <span class="p_context"> void platform_device_del(struct platform_device *pdev)</span>
 
 		for (i = 0; i &lt; pdev-&gt;num_resources; i++) {
 			struct resource *r = &amp;pdev-&gt;resource[i];
<span class="p_del">-			unsigned long type = resource_type(r);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)</span>
<span class="p_add">+			if (r-&gt;parent)</span>
 				release_resource(r);
 		}
 	}
<span class="p_header">diff --git a/drivers/base/power/clock_ops.c b/drivers/base/power/clock_ops.c</span>
<span class="p_header">index c7b0fcebf168..ac3c07db92f1 100644</span>
<span class="p_header">--- a/drivers/base/power/clock_ops.c</span>
<span class="p_header">+++ b/drivers/base/power/clock_ops.c</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> struct pm_clock_entry {</span>
  * @dev: The device for the given clock
  * @ce: PM clock entry corresponding to the clock.
  */
<span class="p_del">-static inline int __pm_clk_enable(struct device *dev, struct pm_clock_entry *ce)</span>
<span class="p_add">+static inline void __pm_clk_enable(struct device *dev, struct pm_clock_entry *ce)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -49,8 +49,6 @@</span> <span class="p_context"> static inline int __pm_clk_enable(struct device *dev, struct pm_clock_entry *ce)</span>
 			dev_err(dev, &quot;%s: failed to enable clk %p, error %d\n&quot;,
 				__func__, ce-&gt;clk, ret);
 	}
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/clk/pistachio/clk-pistachio.c b/drivers/clk/pistachio/clk-pistachio.c</span>
<span class="p_header">index 8c0fe8828f99..c4ceb5eaf46c 100644</span>
<span class="p_header">--- a/drivers/clk/pistachio/clk-pistachio.c</span>
<span class="p_header">+++ b/drivers/clk/pistachio/clk-pistachio.c</span>
<span class="p_chunk">@@ -159,9 +159,15 @@</span> <span class="p_context"> PNAME(mux_debug) = { &quot;mips_pll_mux&quot;, &quot;rpu_v_pll_mux&quot;,</span>
 		     &quot;wifi_pll_mux&quot;, &quot;bt_pll_mux&quot; };
 static u32 mux_debug_idx[] = { 0x0, 0x1, 0x2, 0x4, 0x8, 0x10 };
 
<span class="p_del">-static unsigned int pistachio_critical_clks[] __initdata = {</span>
<span class="p_del">-	CLK_MIPS,</span>
<span class="p_del">-	CLK_PERIPH_SYS,</span>
<span class="p_add">+static unsigned int pistachio_critical_clks_core[] __initdata = {</span>
<span class="p_add">+	CLK_MIPS</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int pistachio_critical_clks_sys[] __initdata = {</span>
<span class="p_add">+	PERIPH_CLK_SYS,</span>
<span class="p_add">+	PERIPH_CLK_SYS_BUS,</span>
<span class="p_add">+	PERIPH_CLK_DDR,</span>
<span class="p_add">+	PERIPH_CLK_ROM,</span>
 };
 
 static void __init pistachio_clk_init(struct device_node *np)
<span class="p_chunk">@@ -193,8 +199,8 @@</span> <span class="p_context"> static void __init pistachio_clk_init(struct device_node *np)</span>
 
 	pistachio_clk_register_provider(p);
 
<span class="p_del">-	pistachio_clk_force_enable(p, pistachio_critical_clks,</span>
<span class="p_del">-				   ARRAY_SIZE(pistachio_critical_clks));</span>
<span class="p_add">+	pistachio_clk_force_enable(p, pistachio_critical_clks_core,</span>
<span class="p_add">+				   ARRAY_SIZE(pistachio_critical_clks_core));</span>
 }
 CLK_OF_DECLARE(pistachio_clk, &quot;img,pistachio-clk&quot;, pistachio_clk_init);
 
<span class="p_chunk">@@ -261,6 +267,9 @@</span> <span class="p_context"> static void __init pistachio_clk_periph_init(struct device_node *np)</span>
 				    ARRAY_SIZE(pistachio_periph_gates));
 
 	pistachio_clk_register_provider(p);
<span class="p_add">+</span>
<span class="p_add">+	pistachio_clk_force_enable(p, pistachio_critical_clks_sys,</span>
<span class="p_add">+				   ARRAY_SIZE(pistachio_critical_clks_sys));</span>
 }
 CLK_OF_DECLARE(pistachio_clk_periph, &quot;img,pistachio-clk-periph&quot;,
 	       pistachio_clk_periph_init);
<span class="p_header">diff --git a/drivers/clk/pistachio/clk-pll.c b/drivers/clk/pistachio/clk-pll.c</span>
<span class="p_header">index de537560bf70..ebd0d2a3b5da 100644</span>
<span class="p_header">--- a/drivers/clk/pistachio/clk-pll.c</span>
<span class="p_header">+++ b/drivers/clk/pistachio/clk-pll.c</span>
<span class="p_chunk">@@ -115,8 +115,7 @@</span> <span class="p_context"> static int pll_gf40lp_frac_enable(struct clk_hw *hw)</span>
 	u32 val;
 
 	val = pll_readl(pll, PLL_CTRL3);
<span class="p_del">-	val &amp;= ~(PLL_FRAC_CTRL3_PD | PLL_FRAC_CTRL3_DACPD |</span>
<span class="p_del">-		 PLL_FRAC_CTRL3_DSMPD | PLL_FRAC_CTRL3_FOUTPOSTDIVPD |</span>
<span class="p_add">+	val &amp;= ~(PLL_FRAC_CTRL3_PD | PLL_FRAC_CTRL3_FOUTPOSTDIVPD |</span>
 		 PLL_FRAC_CTRL3_FOUT4PHASEPD | PLL_FRAC_CTRL3_FOUTVCOPD);
 	pll_writel(pll, val, PLL_CTRL3);
 
<span class="p_chunk">@@ -233,7 +232,7 @@</span> <span class="p_context"> static int pll_gf40lp_laint_enable(struct clk_hw *hw)</span>
 	u32 val;
 
 	val = pll_readl(pll, PLL_CTRL1);
<span class="p_del">-	val &amp;= ~(PLL_INT_CTRL1_PD | PLL_INT_CTRL1_DSMPD |</span>
<span class="p_add">+	val &amp;= ~(PLL_INT_CTRL1_PD |</span>
 		 PLL_INT_CTRL1_FOUTPOSTDIVPD | PLL_INT_CTRL1_FOUTVCOPD);
 	pll_writel(pll, val, PLL_CTRL1);
 
<span class="p_header">diff --git a/drivers/clk/pxa/clk-pxa25x.c b/drivers/clk/pxa/clk-pxa25x.c</span>
<span class="p_header">index 6cd88d963a7f..542e45ef5087 100644</span>
<span class="p_header">--- a/drivers/clk/pxa/clk-pxa25x.c</span>
<span class="p_header">+++ b/drivers/clk/pxa/clk-pxa25x.c</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> unsigned int pxa25x_get_clk_frequency_khz(int info)</span>
 			clks[3] / 1000000, (clks[3] % 1000000) / 10000);
 	}
 
<span class="p_del">-	return (unsigned int)clks[0];</span>
<span class="p_add">+	return (unsigned int)clks[0] / KHz;</span>
 }
 
 static unsigned long clk_pxa25x_memory_get_rate(struct clk_hw *hw,
<span class="p_header">diff --git a/drivers/clk/pxa/clk-pxa27x.c b/drivers/clk/pxa/clk-pxa27x.c</span>
<span class="p_header">index 5f9b54b024b9..267511df1e59 100644</span>
<span class="p_header">--- a/drivers/clk/pxa/clk-pxa27x.c</span>
<span class="p_header">+++ b/drivers/clk/pxa/clk-pxa27x.c</span>
<span class="p_chunk">@@ -80,7 +80,7 @@</span> <span class="p_context"> unsigned int pxa27x_get_clk_frequency_khz(int info)</span>
 		pr_info(&quot;System bus clock: %ld.%02ldMHz\n&quot;,
 			clks[4] / 1000000, (clks[4] % 1000000) / 10000);
 	}
<span class="p_del">-	return (unsigned int)clks[0];</span>
<span class="p_add">+	return (unsigned int)clks[0] / KHz;</span>
 }
 
 bool pxa27x_is_ppll_disabled(void)
<span class="p_header">diff --git a/drivers/clk/pxa/clk-pxa3xx.c b/drivers/clk/pxa/clk-pxa3xx.c</span>
<span class="p_header">index ac03ba49e9d1..4af4eed5f89f 100644</span>
<span class="p_header">--- a/drivers/clk/pxa/clk-pxa3xx.c</span>
<span class="p_header">+++ b/drivers/clk/pxa/clk-pxa3xx.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> unsigned int pxa3xx_get_clk_frequency_khz(int info)</span>
 		pr_info(&quot;System bus clock: %ld.%02ldMHz\n&quot;,
 			clks[4] / 1000000, (clks[4] % 1000000) / 10000);
 	}
<span class="p_del">-	return (unsigned int)clks[0];</span>
<span class="p_add">+	return (unsigned int)clks[0] / KHz;</span>
 }
 
 static unsigned long clk_pxa3xx_ac97_get_rate(struct clk_hw *hw,
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-apq8084.c b/drivers/clk/qcom/gcc-apq8084.c</span>
<span class="p_header">index 54a756b90a37..457c540585f9 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-apq8084.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-apq8084.c</span>
<span class="p_chunk">@@ -2105,6 +2105,7 @@</span> <span class="p_context"> static struct clk_branch gcc_ce1_clk = {</span>
 				&quot;ce1_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-msm8916.c b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">index c66f7bc2ae87..5d75bffab141 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_chunk">@@ -2278,7 +2278,7 @@</span> <span class="p_context"> static struct clk_branch gcc_prng_ahb_clk = {</span>
 	.halt_check = BRANCH_HALT_VOTED,
 	.clkr = {
 		.enable_reg = 0x45004,
<span class="p_del">-		.enable_mask = BIT(0),</span>
<span class="p_add">+		.enable_mask = BIT(8),</span>
 		.hw.init = &amp;(struct clk_init_data){
 			.name = &quot;gcc_prng_ahb_clk&quot;,
 			.parent_names = (const char *[]){
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-msm8974.c b/drivers/clk/qcom/gcc-msm8974.c</span>
<span class="p_header">index c39d09874e74..f06a082e3e87 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-msm8974.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-msm8974.c</span>
<span class="p_chunk">@@ -1783,6 +1783,7 @@</span> <span class="p_context"> static struct clk_branch gcc_ce1_clk = {</span>
 				&quot;ce1_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_header">diff --git a/drivers/clk/rockchip/clk-rk3288.c b/drivers/clk/rockchip/clk-rk3288.c</span>
<span class="p_header">index d17eb4528a28..37f96117fd3d 100644</span>
<span class="p_header">--- a/drivers/clk/rockchip/clk-rk3288.c</span>
<span class="p_header">+++ b/drivers/clk/rockchip/clk-rk3288.c</span>
<span class="p_chunk">@@ -578,7 +578,7 @@</span> <span class="p_context"> static struct rockchip_clk_branch rk3288_clk_branches[] __initdata = {</span>
 	COMPOSITE(0, &quot;mac_pll_src&quot;, mux_pll_src_npll_cpll_gpll_p, 0,
 			RK3288_CLKSEL_CON(21), 0, 2, MFLAGS, 8, 5, DFLAGS,
 			RK3288_CLKGATE_CON(2), 5, GFLAGS),
<span class="p_del">-	MUX(SCLK_MAC, &quot;mac_clk&quot;, mux_mac_p, 0,</span>
<span class="p_add">+	MUX(SCLK_MAC, &quot;mac_clk&quot;, mux_mac_p, CLK_SET_RATE_PARENT,</span>
 			RK3288_CLKSEL_CON(21), 4, 1, MFLAGS),
 	GATE(SCLK_MACREF_OUT, &quot;sclk_macref_out&quot;, &quot;mac_clk&quot;, 0,
 			RK3288_CLKGATE_CON(5), 3, GFLAGS),
<span class="p_header">diff --git a/drivers/clk/samsung/clk-exynos4.c b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">index 714d6ba782c8..f7890bf652e6 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-exynos4.c</span>
<span class="p_chunk">@@ -85,6 +85,7 @@</span> <span class="p_context"></span>
 #define DIV_PERIL4		0xc560
 #define DIV_PERIL5		0xc564
 #define E4X12_DIV_CAM1		0xc568
<span class="p_add">+#define E4X12_GATE_BUS_FSYS1	0xc744</span>
 #define GATE_SCLK_CAM		0xc820
 #define GATE_IP_CAM		0xc920
 #define GATE_IP_TV		0xc924
<span class="p_chunk">@@ -1095,6 +1096,7 @@</span> <span class="p_context"> static struct samsung_gate_clock exynos4x12_gate_clks[] __initdata = {</span>
 		0),
 	GATE(CLK_PPMUIMAGE, &quot;ppmuimage&quot;, &quot;aclk200&quot;, E4X12_GATE_IP_IMAGE, 9, 0,
 		0),
<span class="p_add">+	GATE(CLK_TSADC, &quot;tsadc&quot;, &quot;aclk133&quot;, E4X12_GATE_BUS_FSYS1, 16, 0, 0),</span>
 	GATE(CLK_MIPI_HSI, &quot;mipi_hsi&quot;, &quot;aclk133&quot;, GATE_IP_FSYS, 10, 0, 0),
 	GATE(CLK_CHIPID, &quot;chipid&quot;, &quot;aclk100&quot;, E4X12_GATE_IP_PERIR, 0, 0, 0),
 	GATE(CLK_SYSREG, &quot;sysreg&quot;, &quot;aclk100&quot;, E4X12_GATE_IP_PERIR, 1,
<span class="p_header">diff --git a/drivers/clk/samsung/clk-s5pv210.c b/drivers/clk/samsung/clk-s5pv210.c</span>
<span class="p_header">index e668e479a697..bdd284249cc3 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-s5pv210.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-s5pv210.c</span>
<span class="p_chunk">@@ -828,6 +828,8 @@</span> <span class="p_context"> static void __init __s5pv210_clk_init(struct device_node *np,</span>
 
 	s5pv210_clk_sleep_init();
 
<span class="p_add">+	samsung_clk_of_add_provider(np, ctx);</span>
<span class="p_add">+</span>
 	pr_info(&quot;%s clocks: mout_apll = %ld, mout_mpll = %ld\n&quot;
 		&quot;\tmout_epll = %ld, mout_vpll = %ld\n&quot;,
 		is_s5p6442 ? &quot;S5P6442&quot; : &quot;S5PV210&quot;,
<span class="p_header">diff --git a/drivers/clk/versatile/clk-sp810.c b/drivers/clk/versatile/clk-sp810.c</span>
<span class="p_header">index c6e86a9a2aa3..5122ef25f595 100644</span>
<span class="p_header">--- a/drivers/clk/versatile/clk-sp810.c</span>
<span class="p_header">+++ b/drivers/clk/versatile/clk-sp810.c</span>
<span class="p_chunk">@@ -128,8 +128,8 @@</span> <span class="p_context"> static struct clk *clk_sp810_timerclken_of_get(struct of_phandle_args *clkspec,</span>
 {
 	struct clk_sp810 *sp810 = data;
 
<span class="p_del">-	if (WARN_ON(clkspec-&gt;args_count != 1 || clkspec-&gt;args[0] &gt;</span>
<span class="p_del">-			ARRAY_SIZE(sp810-&gt;timerclken)))</span>
<span class="p_add">+	if (WARN_ON(clkspec-&gt;args_count != 1 ||</span>
<span class="p_add">+		    clkspec-&gt;args[0] &gt;=	ARRAY_SIZE(sp810-&gt;timerclken)))</span>
 		return NULL;
 
 	return sp810-&gt;timerclken[clkspec-&gt;args[0]].clk;
<span class="p_header">diff --git a/drivers/crypto/vmx/ghashp8-ppc.pl b/drivers/crypto/vmx/ghashp8-ppc.pl</span>
<span class="p_header">index 0a6f899839dd..d8429cb71f02 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/ghashp8-ppc.pl</span>
<span class="p_header">+++ b/drivers/crypto/vmx/ghashp8-ppc.pl</span>
<span class="p_chunk">@@ -61,6 +61,12 @@</span> <span class="p_context"> $code=&lt;&lt;___;</span>
 	mtspr		256,r0
 	li		r10,0x30
 	lvx_u		$H,0,r4			# load H
<span class="p_add">+	le?xor		r7,r7,r7</span>
<span class="p_add">+	le?addi		r7,r7,0x8		# need a vperm start with 08</span>
<span class="p_add">+	le?lvsr		5,0,r7</span>
<span class="p_add">+	le?vspltisb	6,0x0f</span>
<span class="p_add">+	le?vxor		5,5,6			# set a b-endian mask</span>
<span class="p_add">+	le?vperm	$H,$H,$H,5</span>
 
 	vspltisb	$xC2,-16		# 0xf0
 	vspltisb	$t0,1			# one
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index a19d2c71e205..fb91df1631d9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -647,15 +647,18 @@</span> <span class="p_context"> static int i915_drm_suspend_late(struct drm_device *drm_dev, bool hibernation)</span>
 
 	pci_disable_device(drm_dev-&gt;pdev);
 	/*
<span class="p_del">-	 * During hibernation on some GEN4 platforms the BIOS may try to access</span>
<span class="p_add">+	 * During hibernation on some platforms the BIOS may try to access</span>
 	 * the device even though it&#39;s already in D3 and hang the machine. So
 	 * leave the device in D0 on those platforms and hope the BIOS will
<span class="p_del">-	 * power down the device properly. Platforms where this was seen:</span>
<span class="p_del">-	 * Lenovo Thinkpad X301, X61s</span>
<span class="p_add">+	 * power down the device properly. The issue was seen on multiple old</span>
<span class="p_add">+	 * GENs with different BIOS vendors, so having an explicit blacklist</span>
<span class="p_add">+	 * is inpractical; apply the workaround on everything pre GEN6. The</span>
<span class="p_add">+	 * platforms where the issue was seen:</span>
<span class="p_add">+	 * Lenovo Thinkpad X301, X61s, X60, T60, X41</span>
<span class="p_add">+	 * Fujitsu FSC S7110</span>
<span class="p_add">+	 * Acer Aspire 1830T</span>
 	 */
<span class="p_del">-	if (!(hibernation &amp;&amp;</span>
<span class="p_del">-	      drm_dev-&gt;pdev-&gt;subsystem_vendor == PCI_VENDOR_ID_LENOVO &amp;&amp;</span>
<span class="p_del">-	      INTEL_INFO(dev_priv)-&gt;gen == 4))</span>
<span class="p_add">+	if (!(hibernation &amp;&amp; INTEL_INFO(dev_priv)-&gt;gen &lt; 6))</span>
 		pci_set_power_state(drm_dev-&gt;pdev, PCI_D3hot);
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 683a9b004c11..7d53d7e15455 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -3190,13 +3190,13 @@</span> <span class="p_context"> int intel_freq_opcode(struct drm_i915_private *dev_priv, int val);</span>
 #define I915_READ64(reg)	dev_priv-&gt;uncore.funcs.mmio_readq(dev_priv, (reg), true)
 
 #define I915_READ64_2x32(lower_reg, upper_reg) ({			\
<span class="p_del">-	u32 upper, lower, tmp;						\</span>
<span class="p_del">-	tmp = I915_READ(upper_reg);					\</span>
<span class="p_add">+	u32 upper, lower, old_upper, loop = 0;				\</span>
<span class="p_add">+	upper = I915_READ(upper_reg);					\</span>
 	do {								\
<span class="p_del">-		upper = tmp;						\</span>
<span class="p_add">+		old_upper = upper;					\</span>
 		lower = I915_READ(lower_reg);				\
<span class="p_del">-		tmp = I915_READ(upper_reg);				\</span>
<span class="p_del">-	} while (upper != tmp);						\</span>
<span class="p_add">+		upper = I915_READ(upper_reg);				\</span>
<span class="p_add">+	} while (upper != old_upper &amp;&amp; loop++ &lt; 2);			\</span>
 	(u64)upper &lt;&lt; 32 | lower; })
 
 #define POSTING_READ(reg)	(void)I915_READ_NOTRACE(reg)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_header">index a3190e793ed4..479024a4caad 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_chunk">@@ -1025,6 +1025,7 @@</span> <span class="p_context"> i915_gem_execbuffer_move_to_active(struct list_head *vmas,</span>
 		u32 old_read = obj-&gt;base.read_domains;
 		u32 old_write = obj-&gt;base.write_domain;
 
<span class="p_add">+		obj-&gt;dirty = 1; /* be paranoid  */</span>
 		obj-&gt;base.write_domain = obj-&gt;base.pending_write_domain;
 		if (obj-&gt;base.write_domain == 0)
 			obj-&gt;base.pending_read_domains |= obj-&gt;base.read_domains;
<span class="p_chunk">@@ -1032,7 +1033,6 @@</span> <span class="p_context"> i915_gem_execbuffer_move_to_active(struct list_head *vmas,</span>
 
 		i915_vma_move_to_active(vma, ring);
 		if (obj-&gt;base.write_domain) {
<span class="p_del">-			obj-&gt;dirty = 1;</span>
 			i915_gem_request_assign(&amp;obj-&gt;last_write_req, req);
 
 			intel_fb_obj_invalidate(obj, ring, ORIGIN_CS);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 57c887843dc3..f208bbc6d58e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -13781,6 +13781,24 @@</span> <span class="p_context"> void intel_modeset_init(struct drm_device *dev)</span>
 	if (INTEL_INFO(dev)-&gt;num_pipes == 0)
 		return;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There may be no VBT; and if the BIOS enabled SSC we can</span>
<span class="p_add">+	 * just keep using it to avoid unnecessary flicker.  Whereas if the</span>
<span class="p_add">+	 * BIOS isn&#39;t using it, don&#39;t assume it will work even if the VBT</span>
<span class="p_add">+	 * indicates as much.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {</span>
<span class="p_add">+		bool bios_lvds_use_ssc = !!(I915_READ(PCH_DREF_CONTROL) &amp;</span>
<span class="p_add">+					    DREF_SSC1_ENABLE);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dev_priv-&gt;vbt.lvds_use_ssc != bios_lvds_use_ssc) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;SSC %sabled by BIOS, overriding VBT which says %sabled\n&quot;,</span>
<span class="p_add">+				     bios_lvds_use_ssc ? &quot;en&quot; : &quot;dis&quot;,</span>
<span class="p_add">+				     dev_priv-&gt;vbt.lvds_use_ssc ? &quot;en&quot; : &quot;dis&quot;);</span>
<span class="p_add">+			dev_priv-&gt;vbt.lvds_use_ssc = bios_lvds_use_ssc;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	intel_init_display(dev);
 	intel_init_audio(dev);
 
<span class="p_chunk">@@ -14266,7 +14284,6 @@</span> <span class="p_context"> void intel_modeset_setup_hw_state(struct drm_device *dev,</span>
 
 void intel_modeset_gem_init(struct drm_device *dev)
 {
<span class="p_del">-	struct drm_i915_private *dev_priv = dev-&gt;dev_private;</span>
 	struct drm_crtc *c;
 	struct drm_i915_gem_object *obj;
 	int ret;
<span class="p_chunk">@@ -14275,16 +14292,6 @@</span> <span class="p_context"> void intel_modeset_gem_init(struct drm_device *dev)</span>
 	intel_init_gt_powersave(dev);
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There may be no VBT; and if the BIOS enabled SSC we can</span>
<span class="p_del">-	 * just keep using it to avoid unnecessary flicker.  Whereas if the</span>
<span class="p_del">-	 * BIOS isn&#39;t using it, don&#39;t assume it will work even if the VBT</span>
<span class="p_del">-	 * indicates as much.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))</span>
<span class="p_del">-		dev_priv-&gt;vbt.lvds_use_ssc = !!(I915_READ(PCH_DREF_CONTROL) &amp;</span>
<span class="p_del">-						DREF_SSC1_ENABLE);</span>
<span class="p_del">-</span>
 	intel_modeset_init_hw(dev);
 
 	intel_setup_overlay(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index b1fe32b119ef..fb2983f77141 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -4691,9 +4691,12 @@</span> <span class="p_context"> intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)</span>
 
 		intel_dp_probe_oui(intel_dp);
 
<span class="p_del">-		if (!intel_dp_probe_mst(intel_dp))</span>
<span class="p_add">+		if (!intel_dp_probe_mst(intel_dp)) {</span>
<span class="p_add">+			drm_modeset_lock(&amp;dev-&gt;mode_config.connection_mutex, NULL);</span>
<span class="p_add">+			intel_dp_check_link_status(intel_dp);</span>
<span class="p_add">+			drm_modeset_unlock(&amp;dev-&gt;mode_config.connection_mutex);</span>
 			goto mst_fail;
<span class="p_del">-</span>
<span class="p_add">+		}</span>
 	} else {
 		if (intel_dp-&gt;is_mst) {
 			if (intel_dp_check_mst_status(intel_dp) == -EINVAL)
<span class="p_chunk">@@ -4701,10 +4704,6 @@</span> <span class="p_context"> intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)</span>
 		}
 
 		if (!intel_dp-&gt;is_mst) {
<span class="p_del">-			/*</span>
<span class="p_del">-			 * we&#39;ll check the link status via the normal hot plug path later -</span>
<span class="p_del">-			 * but for short hpds we should check it now</span>
<span class="p_del">-			 */</span>
 			drm_modeset_lock(&amp;dev-&gt;mode_config.connection_mutex, NULL);
 			intel_dp_check_link_status(intel_dp);
 			drm_modeset_unlock(&amp;dev-&gt;mode_config.connection_mutex);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dsi.c b/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_header">index 51966426addf..c7a0b8d8fac9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dsi.c</span>
<span class="p_chunk">@@ -1036,11 +1036,7 @@</span> <span class="p_context"> void intel_dsi_init(struct drm_device *dev)</span>
 	intel_connector-&gt;unregister = intel_connector_unregister;
 
 	/* Pipe A maps to MIPI DSI port A, pipe B maps to MIPI DSI port C */
<span class="p_del">-	if (dev_priv-&gt;vbt.dsi.config-&gt;dual_link) {</span>
<span class="p_del">-		/* XXX: does dual link work on either pipe? */</span>
<span class="p_del">-		intel_encoder-&gt;crtc_mask = (1 &lt;&lt; PIPE_A);</span>
<span class="p_del">-		intel_dsi-&gt;ports = ((1 &lt;&lt; PORT_A) | (1 &lt;&lt; PORT_C));</span>
<span class="p_del">-	} else if (dev_priv-&gt;vbt.dsi.port == DVO_PORT_MIPIA) {</span>
<span class="p_add">+	if (dev_priv-&gt;vbt.dsi.port == DVO_PORT_MIPIA) {</span>
 		intel_encoder-&gt;crtc_mask = (1 &lt;&lt; PIPE_A);
 		intel_dsi-&gt;ports = (1 &lt;&lt; PORT_A);
 	} else if (dev_priv-&gt;vbt.dsi.port == DVO_PORT_MIPIC) {
<span class="p_chunk">@@ -1048,6 +1044,9 @@</span> <span class="p_context"> void intel_dsi_init(struct drm_device *dev)</span>
 		intel_dsi-&gt;ports = (1 &lt;&lt; PORT_C);
 	}
 
<span class="p_add">+	if (dev_priv-&gt;vbt.dsi.config-&gt;dual_link)</span>
<span class="p_add">+		intel_dsi-&gt;ports = ((1 &lt;&lt; PORT_A) | (1 &lt;&lt; PORT_C));</span>
<span class="p_add">+</span>
 	/* Create a DSI host (and a device) for each port. */
 	for_each_dsi_port(port, intel_dsi-&gt;ports) {
 		struct intel_dsi_host *host;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_display.c b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">index 4a0a8b29b0a1..32248791bc4b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_display.c</span>
<span class="p_chunk">@@ -160,9 +160,35 @@</span> <span class="p_context"> static int qxl_add_monitors_config_modes(struct drm_connector *connector,</span>
 	*pwidth = head-&gt;width;
 	*pheight = head-&gt;height;
 	drm_mode_probed_add(connector, mode);
<span class="p_add">+	/* remember the last custom size for mode validation */</span>
<span class="p_add">+	qdev-&gt;monitors_config_width = mode-&gt;hdisplay;</span>
<span class="p_add">+	qdev-&gt;monitors_config_height = mode-&gt;vdisplay;</span>
 	return 1;
 }
 
<span class="p_add">+static struct mode_size {</span>
<span class="p_add">+	int w;</span>
<span class="p_add">+	int h;</span>
<span class="p_add">+} common_modes[] = {</span>
<span class="p_add">+	{ 640,  480},</span>
<span class="p_add">+	{ 720,  480},</span>
<span class="p_add">+	{ 800,  600},</span>
<span class="p_add">+	{ 848,  480},</span>
<span class="p_add">+	{1024,  768},</span>
<span class="p_add">+	{1152,  768},</span>
<span class="p_add">+	{1280,  720},</span>
<span class="p_add">+	{1280,  800},</span>
<span class="p_add">+	{1280,  854},</span>
<span class="p_add">+	{1280,  960},</span>
<span class="p_add">+	{1280, 1024},</span>
<span class="p_add">+	{1440,  900},</span>
<span class="p_add">+	{1400, 1050},</span>
<span class="p_add">+	{1680, 1050},</span>
<span class="p_add">+	{1600, 1200},</span>
<span class="p_add">+	{1920, 1080},</span>
<span class="p_add">+	{1920, 1200}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int qxl_add_common_modes(struct drm_connector *connector,
                                 unsigned pwidth,
                                 unsigned pheight)
<span class="p_chunk">@@ -170,29 +196,6 @@</span> <span class="p_context"> static int qxl_add_common_modes(struct drm_connector *connector,</span>
 	struct drm_device *dev = connector-&gt;dev;
 	struct drm_display_mode *mode = NULL;
 	int i;
<span class="p_del">-	struct mode_size {</span>
<span class="p_del">-		int w;</span>
<span class="p_del">-		int h;</span>
<span class="p_del">-	} common_modes[] = {</span>
<span class="p_del">-		{ 640,  480},</span>
<span class="p_del">-		{ 720,  480},</span>
<span class="p_del">-		{ 800,  600},</span>
<span class="p_del">-		{ 848,  480},</span>
<span class="p_del">-		{1024,  768},</span>
<span class="p_del">-		{1152,  768},</span>
<span class="p_del">-		{1280,  720},</span>
<span class="p_del">-		{1280,  800},</span>
<span class="p_del">-		{1280,  854},</span>
<span class="p_del">-		{1280,  960},</span>
<span class="p_del">-		{1280, 1024},</span>
<span class="p_del">-		{1440,  900},</span>
<span class="p_del">-		{1400, 1050},</span>
<span class="p_del">-		{1680, 1050},</span>
<span class="p_del">-		{1600, 1200},</span>
<span class="p_del">-		{1920, 1080},</span>
<span class="p_del">-		{1920, 1200}</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; ARRAY_SIZE(common_modes); i++) {
 		mode = drm_cvt_mode(dev, common_modes[i].w, common_modes[i].h,
 				    60, false, false, false);
<span class="p_chunk">@@ -823,11 +826,22 @@</span> <span class="p_context"> static int qxl_conn_get_modes(struct drm_connector *connector)</span>
 static int qxl_conn_mode_valid(struct drm_connector *connector,
 			       struct drm_display_mode *mode)
 {
<span class="p_add">+	struct drm_device *ddev = connector-&gt;dev;</span>
<span class="p_add">+	struct qxl_device *qdev = ddev-&gt;dev_private;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
 	/* TODO: is this called for user defined modes? (xrandr --add-mode)
 	 * TODO: check that the mode fits in the framebuffer */
<span class="p_del">-	DRM_DEBUG(&quot;%s: %dx%d status=%d\n&quot;, mode-&gt;name, mode-&gt;hdisplay,</span>
<span class="p_del">-		  mode-&gt;vdisplay, mode-&gt;status);</span>
<span class="p_del">-	return MODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+	if(qdev-&gt;monitors_config_width == mode-&gt;hdisplay &amp;&amp;</span>
<span class="p_add">+	   qdev-&gt;monitors_config_height == mode-&gt;vdisplay)</span>
<span class="p_add">+		return MODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(common_modes); i++) {</span>
<span class="p_add">+		if (common_modes[i].w == mode-&gt;hdisplay &amp;&amp; common_modes[i].h == mode-&gt;vdisplay)</span>
<span class="p_add">+			return MODE_OK;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return MODE_BAD;</span>
 }
 
 static struct drm_encoder *qxl_best_encoder(struct drm_connector *connector)
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_drv.h b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">index 7c6cafe21f5f..e66143cc1a7a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_drv.h</span>
<span class="p_chunk">@@ -325,6 +325,8 @@</span> <span class="p_context"> struct qxl_device {</span>
 	struct work_struct fb_work;
 
 	struct drm_property *hotplug_mode_update_property;
<span class="p_add">+	int monitors_config_width;</span>
<span class="p_add">+	int monitors_config_height;</span>
 };
 
 /* forward declaration for QXL_INFO_IO */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index b435c859dcbc..447dbfa6c793 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -171,8 +171,9 @@</span> <span class="p_context"> radeon_dp_aux_transfer_atom(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)</span>
 		return -E2BIG;
 
 	tx_buf[0] = msg-&gt;address &amp; 0xff;
<span class="p_del">-	tx_buf[1] = msg-&gt;address &gt;&gt; 8;</span>
<span class="p_del">-	tx_buf[2] = msg-&gt;request &lt;&lt; 4;</span>
<span class="p_add">+	tx_buf[1] = (msg-&gt;address &gt;&gt; 8) &amp; 0xff;</span>
<span class="p_add">+	tx_buf[2] = (msg-&gt;request &lt;&lt; 4) |</span>
<span class="p_add">+		((msg-&gt;address &gt;&gt; 16) &amp; 0xf);</span>
 	tx_buf[3] = msg-&gt;size ? (msg-&gt;size - 1) : 0;
 
 	switch (msg-&gt;request &amp; ~DP_AUX_I2C_MOT) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">index 59b3d3221294..d77dd1430d58 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_chunk">@@ -522,13 +522,15 @@</span> <span class="p_context"> static int radeon_audio_set_avi_packet(struct drm_encoder *encoder,</span>
 		return err;
 	}
 
<span class="p_del">-	if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {</span>
<span class="p_del">-		if (radeon_encoder-&gt;output_csc == RADEON_OUTPUT_CSC_TVRGB)</span>
<span class="p_del">-			frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;</span>
<span class="p_add">+	if (radeon_encoder-&gt;output_csc != RADEON_OUTPUT_CSC_BYPASS) {</span>
<span class="p_add">+		if (drm_rgb_quant_range_selectable(radeon_connector_edid(connector))) {</span>
<span class="p_add">+			if (radeon_encoder-&gt;output_csc == RADEON_OUTPUT_CSC_TVRGB)</span>
<span class="p_add">+				frame.quantization_range = HDMI_QUANTIZATION_RANGE_LIMITED;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				frame.quantization_range = HDMI_QUANTIZATION_RANGE_FULL;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			frame.quantization_range = HDMI_QUANTIZATION_RANGE_DEFAULT;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = hdmi_avi_infoframe_pack(&amp;frame, buffer, sizeof(buffer));
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 94b21ae70ef7..5a2cafb4f1bc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -95,6 +95,11 @@</span> <span class="p_context"> void radeon_connector_hotplug(struct drm_connector *connector)</span>
 			if (!radeon_hpd_sense(rdev, radeon_connector-&gt;hpd.hpd)) {
 				drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 			} else if (radeon_dp_needs_link_train(radeon_connector)) {
<span class="p_add">+				/* Don&#39;t try to start link training before we</span>
<span class="p_add">+				 * have the dpcd */</span>
<span class="p_add">+				if (!radeon_dp_getdpcd(radeon_connector))</span>
<span class="p_add">+					return;</span>
<span class="p_add">+</span>
 				/* set it to OFF so that drm_helper_connector_dpms()
 				 * won&#39;t return immediately since the current state
 				 * is ON at this point.
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_dp_auxch.c b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">index fcbd60bb0349..3b0c229d7dcd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_chunk">@@ -116,8 +116,8 @@</span> <span class="p_context"> radeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg</span>
 	       AUX_SW_WR_BYTES(bytes));
 
 	/* write the data header into the registers */
<span class="p_del">-	/* request, addres, msg size */</span>
<span class="p_del">-	byte = (msg-&gt;request &lt;&lt; 4);</span>
<span class="p_add">+	/* request, address, msg size */</span>
<span class="p_add">+	byte = (msg-&gt;request &lt;&lt; 4) | ((msg-&gt;address &gt;&gt; 16) &amp; 0xf);</span>
 	WREG32(AUX_SW_DATA + aux_offset[instance],
 	       AUX_SW_DATA_MASK(byte) | AUX_SW_AUTOINCREMENT_DISABLE);
 
<span class="p_header">diff --git a/drivers/hid/hid-cp2112.c b/drivers/hid/hid-cp2112.c</span>
<span class="p_header">index a2dbbbe0d8d7..39bf74793b8b 100644</span>
<span class="p_header">--- a/drivers/hid/hid-cp2112.c</span>
<span class="p_header">+++ b/drivers/hid/hid-cp2112.c</span>
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> static int cp2112_xfer(struct i2c_adapter *adap, u16 addr,</span>
 	struct cp2112_device *dev = (struct cp2112_device *)adap-&gt;algo_data;
 	struct hid_device *hdev = dev-&gt;hdev;
 	u8 buf[64];
<span class="p_del">-	__be16 word;</span>
<span class="p_add">+	__le16 word;</span>
 	ssize_t count;
 	size_t read_length = 0;
 	unsigned int retries;
<span class="p_chunk">@@ -554,7 +554,7 @@</span> <span class="p_context"> static int cp2112_xfer(struct i2c_adapter *adap, u16 addr,</span>
 		if (I2C_SMBUS_READ == read_write)
 			count = cp2112_read_req(buf, addr, read_length);
 		else
<span class="p_del">-			count = cp2112_write_req(buf, addr, data-&gt;byte, NULL,</span>
<span class="p_add">+			count = cp2112_write_req(buf, addr, command, NULL,</span>
 						 0);
 		break;
 	case I2C_SMBUS_BYTE_DATA:
<span class="p_chunk">@@ -569,7 +569,7 @@</span> <span class="p_context"> static int cp2112_xfer(struct i2c_adapter *adap, u16 addr,</span>
 		break;
 	case I2C_SMBUS_WORD_DATA:
 		read_length = 2;
<span class="p_del">-		word = cpu_to_be16(data-&gt;word);</span>
<span class="p_add">+		word = cpu_to_le16(data-&gt;word);</span>
 
 		if (I2C_SMBUS_READ == read_write)
 			count = cp2112_write_read_req(buf, addr, read_length,
<span class="p_chunk">@@ -582,7 +582,7 @@</span> <span class="p_context"> static int cp2112_xfer(struct i2c_adapter *adap, u16 addr,</span>
 		size = I2C_SMBUS_WORD_DATA;
 		read_write = I2C_SMBUS_READ;
 		read_length = 2;
<span class="p_del">-		word = cpu_to_be16(data-&gt;word);</span>
<span class="p_add">+		word = cpu_to_le16(data-&gt;word);</span>
 
 		count = cp2112_write_read_req(buf, addr, read_length, command,
 					      (u8 *)&amp;word, 2);
<span class="p_chunk">@@ -675,7 +675,7 @@</span> <span class="p_context"> static int cp2112_xfer(struct i2c_adapter *adap, u16 addr,</span>
 		data-&gt;byte = buf[0];
 		break;
 	case I2C_SMBUS_WORD_DATA:
<span class="p_del">-		data-&gt;word = be16_to_cpup((__be16 *)buf);</span>
<span class="p_add">+		data-&gt;word = le16_to_cpup((__le16 *)buf);</span>
 		break;
 	case I2C_SMBUS_BLOCK_DATA:
 		if (read_length &gt; I2C_SMBUS_BLOCK_MAX) {
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index bfbe1bedda7f..eab5bd6a2442 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static void hid_io_error(struct hid_device *hid)</span>
 	if (time_after(jiffies, usbhid-&gt;stop_retry)) {
 
 		/* Retries failed, so do a port reset unless we lack bandwidth*/
<span class="p_del">-		if (test_bit(HID_NO_BANDWIDTH, &amp;usbhid-&gt;iofl)</span>
<span class="p_add">+		if (!test_bit(HID_NO_BANDWIDTH, &amp;usbhid-&gt;iofl)</span>
 		     &amp;&amp; !test_and_set_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)) {
 
 			schedule_work(&amp;usbhid-&gt;reset_work);
<span class="p_header">diff --git a/drivers/iio/gyro/Kconfig b/drivers/iio/gyro/Kconfig</span>
<span class="p_header">index b3d0e94f72eb..8d2439345673 100644</span>
<span class="p_header">--- a/drivers/iio/gyro/Kconfig</span>
<span class="p_header">+++ b/drivers/iio/gyro/Kconfig</span>
<span class="p_chunk">@@ -53,7 +53,8 @@</span> <span class="p_context"> config ADXRS450</span>
 config BMG160
 	tristate &quot;BOSCH BMG160 Gyro Sensor&quot;
 	depends on I2C
<span class="p_del">-	select IIO_TRIGGERED_BUFFER if IIO_BUFFER</span>
<span class="p_add">+	select IIO_BUFFER</span>
<span class="p_add">+	select IIO_TRIGGERED_BUFFER</span>
 	help
 	  Say yes here to build support for Bosch BMG160 Tri-axis Gyro Sensor
 	  driver. This driver also supports BMI055 gyroscope.
<span class="p_header">diff --git a/drivers/iio/imu/adis16400_core.c b/drivers/iio/imu/adis16400_core.c</span>
<span class="p_header">index 2fd68f2219a7..d42e4fe2c7ed 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16400_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16400_core.c</span>
<span class="p_chunk">@@ -780,7 +780,7 @@</span> <span class="p_context"> static struct adis16400_chip_info adis16400_chips[] = {</span>
 		.flags = ADIS16400_HAS_PROD_ID |
 				ADIS16400_HAS_SERIAL_NUMBER |
 				ADIS16400_BURST_DIAG_STAT,
<span class="p_del">-		.gyro_scale_micro = IIO_DEGREE_TO_RAD(10000), /* 0.01 deg/s */</span>
<span class="p_add">+		.gyro_scale_micro = IIO_DEGREE_TO_RAD(40000), /* 0.04 deg/s */</span>
 		.accel_scale_micro = IIO_G_TO_M_S_2(833), /* 1/1200 g */
 		.temp_scale_nano = 73860000, /* 0.07386 C */
 		.temp_offset = 31000000 / 73860, /* 31 C = 0x00 */
<span class="p_header">diff --git a/drivers/iio/imu/adis16480.c b/drivers/iio/imu/adis16480.c</span>
<span class="p_header">index 989605dd6f78..b94bfd3f595b 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16480.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16480.c</span>
<span class="p_chunk">@@ -110,6 +110,10 @@</span> <span class="p_context"></span>
 struct adis16480_chip_info {
 	unsigned int num_channels;
 	const struct iio_chan_spec *channels;
<span class="p_add">+	unsigned int gyro_max_val;</span>
<span class="p_add">+	unsigned int gyro_max_scale;</span>
<span class="p_add">+	unsigned int accel_max_val;</span>
<span class="p_add">+	unsigned int accel_max_scale;</span>
 };
 
 struct adis16480 {
<span class="p_chunk">@@ -497,19 +501,21 @@</span> <span class="p_context"> static int adis16480_set_filter_freq(struct iio_dev *indio_dev,</span>
 static int adis16480_read_raw(struct iio_dev *indio_dev,
 	const struct iio_chan_spec *chan, int *val, int *val2, long info)
 {
<span class="p_add">+	struct adis16480 *st = iio_priv(indio_dev);</span>
<span class="p_add">+</span>
 	switch (info) {
 	case IIO_CHAN_INFO_RAW:
 		return adis_single_conversion(indio_dev, chan, 0, val);
 	case IIO_CHAN_INFO_SCALE:
 		switch (chan-&gt;type) {
 		case IIO_ANGL_VEL:
<span class="p_del">-			*val = 0;</span>
<span class="p_del">-			*val2 = IIO_DEGREE_TO_RAD(20000); /* 0.02 degree/sec */</span>
<span class="p_del">-			return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+			*val = st-&gt;chip_info-&gt;gyro_max_scale;</span>
<span class="p_add">+			*val2 = st-&gt;chip_info-&gt;gyro_max_val;</span>
<span class="p_add">+			return IIO_VAL_FRACTIONAL;</span>
 		case IIO_ACCEL:
<span class="p_del">-			*val = 0;</span>
<span class="p_del">-			*val2 = IIO_G_TO_M_S_2(800); /* 0.8 mg */</span>
<span class="p_del">-			return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+			*val = st-&gt;chip_info-&gt;accel_max_scale;</span>
<span class="p_add">+			*val2 = st-&gt;chip_info-&gt;accel_max_val;</span>
<span class="p_add">+			return IIO_VAL_FRACTIONAL;</span>
 		case IIO_MAGN:
 			*val = 0;
 			*val2 = 100; /* 0.0001 gauss */
<span class="p_chunk">@@ -674,18 +680,39 @@</span> <span class="p_context"> static const struct adis16480_chip_info adis16480_chip_info[] = {</span>
 	[ADIS16375] = {
 		.channels = adis16485_channels,
 		.num_channels = ARRAY_SIZE(adis16485_channels),
<span class="p_add">+		/*</span>
<span class="p_add">+		 * storing the value in rad/degree and the scale in degree</span>
<span class="p_add">+		 * gives us the result in rad and better precession than</span>
<span class="p_add">+		 * storing the scale directly in rad.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		.gyro_max_val = IIO_RAD_TO_DEGREE(22887),</span>
<span class="p_add">+		.gyro_max_scale = 300,</span>
<span class="p_add">+		.accel_max_val = IIO_M_S_2_TO_G(21973),</span>
<span class="p_add">+		.accel_max_scale = 18,</span>
 	},
 	[ADIS16480] = {
 		.channels = adis16480_channels,
 		.num_channels = ARRAY_SIZE(adis16480_channels),
<span class="p_add">+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),</span>
<span class="p_add">+		.gyro_max_scale = 450,</span>
<span class="p_add">+		.accel_max_val = IIO_M_S_2_TO_G(12500),</span>
<span class="p_add">+		.accel_max_scale = 5,</span>
 	},
 	[ADIS16485] = {
 		.channels = adis16485_channels,
 		.num_channels = ARRAY_SIZE(adis16485_channels),
<span class="p_add">+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),</span>
<span class="p_add">+		.gyro_max_scale = 450,</span>
<span class="p_add">+		.accel_max_val = IIO_M_S_2_TO_G(20000),</span>
<span class="p_add">+		.accel_max_scale = 5,</span>
 	},
 	[ADIS16488] = {
 		.channels = adis16480_channels,
 		.num_channels = ARRAY_SIZE(adis16480_channels),
<span class="p_add">+		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),</span>
<span class="p_add">+		.gyro_max_scale = 450,</span>
<span class="p_add">+		.accel_max_val = IIO_M_S_2_TO_G(22500),</span>
<span class="p_add">+		.accel_max_scale = 18,</span>
 	},
 };
 
<span class="p_header">diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">index df919f44d513..7fa280b28ecb 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-buffer.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> unsigned int iio_buffer_poll(struct file *filp,</span>
 	struct iio_buffer *rb = indio_dev-&gt;buffer;
 
 	if (!indio_dev-&gt;info)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return 0;</span>
 
 	poll_wait(filp, &amp;rb-&gt;pollq, wait);
 	if (iio_buffer_ready(indio_dev, rb, rb-&gt;watermark, 0))
<span class="p_header">diff --git a/drivers/iio/industrialio-event.c b/drivers/iio/industrialio-event.c</span>
<span class="p_header">index a99692ba91bc..69b8c338fa89 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-event.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-event.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static unsigned int iio_event_poll(struct file *filep,</span>
 	unsigned int events = 0;
 
 	if (!indio_dev-&gt;info)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return events;</span>
 
 	poll_wait(filep, &amp;ev_int-&gt;wait, wait);
 
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 8bfda6ade2c0..384574c3987c 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -845,10 +845,10 @@</span> <span class="p_context"> struct device_node *of_find_matching_node_by_address(struct device_node *from,</span>
 	struct resource res;
 
 	while (dn) {
<span class="p_del">-		if (of_address_to_resource(dn, 0, &amp;res))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (res.start == base_address)</span>
<span class="p_add">+		if (!of_address_to_resource(dn, 0, &amp;res) &amp;&amp;</span>
<span class="p_add">+		    res.start == base_address)</span>
 			return dn;
<span class="p_add">+</span>
 		dn = of_find_matching_node(dn, matches);
 	}
 
<span class="p_header">diff --git a/drivers/pci/access.c b/drivers/pci/access.c</span>
<span class="p_header">index d9b64a175990..b965c12168b7 100644</span>
<span class="p_header">--- a/drivers/pci/access.c</span>
<span class="p_header">+++ b/drivers/pci/access.c</span>
<span class="p_chunk">@@ -439,6 +439,56 @@</span> <span class="p_context"> static const struct pci_vpd_ops pci_vpd_pci22_ops = {</span>
 	.release = pci_vpd_pci22_release,
 };
 
<span class="p_add">+static ssize_t pci_vpd_f0_read(struct pci_dev *dev, loff_t pos, size_t count,</span>
<span class="p_add">+			       void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	ssize_t ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pci_read_vpd(tdev, pos, count, arg);</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t pci_vpd_f0_write(struct pci_dev *dev, loff_t pos, size_t count,</span>
<span class="p_add">+				const void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	ssize_t ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pci_write_vpd(tdev, pos, count, arg);</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct pci_vpd_ops pci_vpd_f0_ops = {</span>
<span class="p_add">+	.read = pci_vpd_f0_read,</span>
<span class="p_add">+	.write = pci_vpd_f0_write,</span>
<span class="p_add">+	.release = pci_vpd_pci22_release,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int pci_vpd_f0_dev_check(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	if (!tdev-&gt;vpd || !tdev-&gt;multifunction ||</span>
<span class="p_add">+	    dev-&gt;class != tdev-&gt;class || dev-&gt;vendor != tdev-&gt;vendor ||</span>
<span class="p_add">+	    dev-&gt;device != tdev-&gt;device)</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int pci_vpd_pci22_init(struct pci_dev *dev)
 {
 	struct pci_vpd_pci22 *vpd;
<span class="p_chunk">@@ -447,12 +497,21 @@</span> <span class="p_context"> int pci_vpd_pci22_init(struct pci_dev *dev)</span>
 	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 	if (!cap)
 		return -ENODEV;
<span class="p_add">+	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_VPD_REF_F0) {</span>
<span class="p_add">+		int ret = pci_vpd_f0_dev_check(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
 	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
 	if (!vpd)
 		return -ENOMEM;
 
 	vpd-&gt;base.len = PCI_VPD_PCI22_SIZE;
<span class="p_del">-	vpd-&gt;base.ops = &amp;pci_vpd_pci22_ops;</span>
<span class="p_add">+	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_VPD_REF_F0)</span>
<span class="p_add">+		vpd-&gt;base.ops = &amp;pci_vpd_f0_ops;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		vpd-&gt;base.ops = &amp;pci_vpd_pci22_ops;</span>
 	mutex_init(&amp;vpd-&gt;lock);
 	vpd-&gt;cap = cap;
 	vpd-&gt;busy = false;
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index c6dc1dfd25d5..804cd3b02c66 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -1576,6 +1576,18 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_JMICRON, PCI_DEVICE_ID_JMICRON_JMB3</span>
 
 #endif
 
<span class="p_add">+static void quirk_jmicron_async_suspend(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;multifunction) {</span>
<span class="p_add">+		device_disable_async_suspend(&amp;dev-&gt;dev);</span>
<span class="p_add">+		dev_info(&amp;dev-&gt;dev, &quot;async suspend disabled to avoid multi-function power-on ordering issue\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_CLASS_STORAGE_IDE, 8, quirk_jmicron_async_suspend);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_CLASS_FINAL(PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_CLASS_STORAGE_SATA_AHCI, 0, quirk_jmicron_async_suspend);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_JMICRON, 0x2362, quirk_jmicron_async_suspend);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_JMICRON, 0x236f, quirk_jmicron_async_suspend);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_IO_APIC
 static void quirk_alder_ioapic(struct pci_dev *pdev)
 {
<span class="p_chunk">@@ -1903,6 +1915,15 @@</span> <span class="p_context"> static void quirk_netmos(struct pci_dev *dev)</span>
 DECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_NETMOS, PCI_ANY_ID,
 			 PCI_CLASS_COMMUNICATION_SERIAL, 8, quirk_netmos);
 
<span class="p_add">+static void quirk_f0_vpd_link(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!dev-&gt;multifunction || !PCI_FUNC(dev-&gt;devfn))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	dev-&gt;dev_flags |= PCI_DEV_FLAGS_VPD_REF_F0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_INTEL, PCI_ANY_ID,</span>
<span class="p_add">+			      PCI_CLASS_NETWORK_ETHERNET, 8, quirk_f0_vpd_link);</span>
<span class="p_add">+</span>
 static void quirk_e100_interrupt(struct pci_dev *dev)
 {
 	u16 command, pmcsr;
<span class="p_chunk">@@ -2838,12 +2859,15 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, 0x3c28, vtd_mask_spec_errors);</span>
 
 static void fixup_ti816x_class(struct pci_dev *dev)
 {
<span class="p_add">+	u32 class = dev-&gt;class;</span>
<span class="p_add">+</span>
 	/* TI 816x devices do not have class code set when in PCIe boot mode */
<span class="p_del">-	dev_info(&amp;dev-&gt;dev, &quot;Setting PCI class for 816x PCIe device\n&quot;);</span>
<span class="p_del">-	dev-&gt;class = PCI_CLASS_MULTIMEDIA_VIDEO;</span>
<span class="p_add">+	dev-&gt;class = PCI_CLASS_MULTIMEDIA_VIDEO &lt;&lt; 8;</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;PCI class overridden (%#08x -&gt; %#08x)\n&quot;,</span>
<span class="p_add">+		 class, dev-&gt;class);</span>
 }
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_TI, 0xb800,
<span class="p_del">-				 PCI_CLASS_NOT_DEFINED, 0, fixup_ti816x_class);</span>
<span class="p_add">+			      PCI_CLASS_NOT_DEFINED, 0, fixup_ti816x_class);</span>
 
 /* Some PCIe devices do not work reliably with the claimed maximum
  * payload size supported.
<span class="p_header">diff --git a/drivers/regulator/pbias-regulator.c b/drivers/regulator/pbias-regulator.c</span>
<span class="p_header">index bd2b75c0d1d1..4fa7bcaf454e 100644</span>
<span class="p_header">--- a/drivers/regulator/pbias-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/pbias-regulator.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 struct pbias_reg_info {
 	u32 enable;
 	u32 enable_mask;
<span class="p_add">+	u32 disable_val;</span>
 	u32 vmode;
 	unsigned int enable_time;
 	char *name;
<span class="p_chunk">@@ -62,6 +63,7 @@</span> <span class="p_context"> static const struct pbias_reg_info pbias_mmc_omap2430 = {</span>
 	.enable = BIT(1),
 	.enable_mask = BIT(1),
 	.vmode = BIT(0),
<span class="p_add">+	.disable_val = 0,</span>
 	.enable_time = 100,
 	.name = &quot;pbias_mmc_omap2430&quot;
 };
<span class="p_chunk">@@ -77,6 +79,7 @@</span> <span class="p_context"> static const struct pbias_reg_info pbias_sim_omap3 = {</span>
 static const struct pbias_reg_info pbias_mmc_omap4 = {
 	.enable = BIT(26) | BIT(22),
 	.enable_mask = BIT(26) | BIT(25) | BIT(22),
<span class="p_add">+	.disable_val = BIT(25),</span>
 	.vmode = BIT(21),
 	.enable_time = 100,
 	.name = &quot;pbias_mmc_omap4&quot;
<span class="p_chunk">@@ -85,6 +88,7 @@</span> <span class="p_context"> static const struct pbias_reg_info pbias_mmc_omap4 = {</span>
 static const struct pbias_reg_info pbias_mmc_omap5 = {
 	.enable = BIT(27) | BIT(26),
 	.enable_mask = BIT(27) | BIT(25) | BIT(26),
<span class="p_add">+	.disable_val = BIT(25),</span>
 	.vmode = BIT(21),
 	.enable_time = 100,
 	.name = &quot;pbias_mmc_omap5&quot;
<span class="p_chunk">@@ -159,6 +163,7 @@</span> <span class="p_context"> static int pbias_regulator_probe(struct platform_device *pdev)</span>
 		drvdata[data_idx].desc.enable_reg = res-&gt;start;
 		drvdata[data_idx].desc.enable_mask = info-&gt;enable_mask;
 		drvdata[data_idx].desc.enable_val = info-&gt;enable;
<span class="p_add">+		drvdata[data_idx].desc.disable_val = info-&gt;disable_val;</span>
 
 		cfg.init_data = pbias_matches[idx].init_data;
 		cfg.driver_data = &amp;drvdata[data_idx];
<span class="p_header">diff --git a/drivers/s390/char/sclp_early.c b/drivers/s390/char/sclp_early.c</span>
<span class="p_header">index 1efa4fdb7fe2..f45cd0cb1b32 100644</span>
<span class="p_header">--- a/drivers/s390/char/sclp_early.c</span>
<span class="p_header">+++ b/drivers/s390/char/sclp_early.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #define KMSG_COMPONENT &quot;sclp_early&quot;
 #define pr_fmt(fmt) KMSG_COMPONENT &quot;: &quot; fmt
 
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
 #include &lt;asm/ctl_reg.h&gt;
 #include &lt;asm/sclp.h&gt;
 #include &lt;asm/ipl.h&gt;
<span class="p_header">diff --git a/drivers/soc/tegra/pmc.c b/drivers/soc/tegra/pmc.c</span>
<span class="p_header">index c956395cf46f..c89bada875f8 100644</span>
<span class="p_header">--- a/drivers/soc/tegra/pmc.c</span>
<span class="p_header">+++ b/drivers/soc/tegra/pmc.c</span>
<span class="p_chunk">@@ -732,12 +732,12 @@</span> <span class="p_context"> void tegra_pmc_init_tsense_reset(struct tegra_pmc *pmc)</span>
 	u32 value, checksum;
 
 	if (!pmc-&gt;soc-&gt;has_tsense_reset)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return;</span>
 
 	np = of_find_node_by_name(pmc-&gt;dev-&gt;of_node, &quot;i2c-thermtrip&quot;);
 	if (!np) {
 		dev_warn(dev, &quot;i2c-thermtrip node not found, %s.\n&quot;, disabled);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return;</span>
 	}
 
 	if (of_property_read_u32(np, &quot;nvidia,i2c-controller-id&quot;, &amp;ctrl_id)) {
<span class="p_header">diff --git a/drivers/spi/spi-bcm2835.c b/drivers/spi/spi-bcm2835.c</span>
<span class="p_header">index 37875cf942f7..a5067739ee93 100644</span>
<span class="p_header">--- a/drivers/spi/spi-bcm2835.c</span>
<span class="p_header">+++ b/drivers/spi/spi-bcm2835.c</span>
<span class="p_chunk">@@ -257,13 +257,11 @@</span> <span class="p_context"> static int bcm2835_spi_transfer_one(struct spi_master *master,</span>
 	spi_used_hz = cdiv ? (clk_hz / cdiv) : (clk_hz / 65536);
 	bcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);
 
<span class="p_del">-	/* handle all the modes */</span>
<span class="p_add">+	/* handle all the 3-wire mode */</span>
 	if ((spi-&gt;mode &amp; SPI_3WIRE) &amp;&amp; (tfr-&gt;rx_buf))
 		cs |= BCM2835_SPI_CS_REN;
<span class="p_del">-	if (spi-&gt;mode &amp; SPI_CPOL)</span>
<span class="p_del">-		cs |= BCM2835_SPI_CS_CPOL;</span>
<span class="p_del">-	if (spi-&gt;mode &amp; SPI_CPHA)</span>
<span class="p_del">-		cs |= BCM2835_SPI_CS_CPHA;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		cs &amp;= ~BCM2835_SPI_CS_REN;</span>
 
 	/* for gpio_cs set dummy CS so that no HW-CS get changed
 	 * we can not run this in bcm2835_spi_set_cs, as it does
<span class="p_chunk">@@ -291,6 +289,25 @@</span> <span class="p_context"> static int bcm2835_spi_transfer_one(struct spi_master *master,</span>
 	return bcm2835_spi_transfer_one_irq(master, spi, tfr, cs);
 }
 
<span class="p_add">+static int bcm2835_spi_prepare_message(struct spi_master *master,</span>
<span class="p_add">+				       struct spi_message *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct spi_device *spi = msg-&gt;spi;</span>
<span class="p_add">+	struct bcm2835_spi *bs = spi_master_get_devdata(master);</span>
<span class="p_add">+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);</span>
<span class="p_add">+</span>
<span class="p_add">+	cs &amp;= ~(BCM2835_SPI_CS_CPOL | BCM2835_SPI_CS_CPHA);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (spi-&gt;mode &amp; SPI_CPOL)</span>
<span class="p_add">+		cs |= BCM2835_SPI_CS_CPOL;</span>
<span class="p_add">+	if (spi-&gt;mode &amp; SPI_CPHA)</span>
<span class="p_add">+		cs |= BCM2835_SPI_CS_CPHA;</span>
<span class="p_add">+</span>
<span class="p_add">+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void bcm2835_spi_handle_err(struct spi_master *master,
 				   struct spi_message *msg)
 {
<span class="p_chunk">@@ -429,6 +446,7 @@</span> <span class="p_context"> static int bcm2835_spi_probe(struct platform_device *pdev)</span>
 	master-&gt;set_cs = bcm2835_spi_set_cs;
 	master-&gt;transfer_one = bcm2835_spi_transfer_one;
 	master-&gt;handle_err = bcm2835_spi_handle_err;
<span class="p_add">+	master-&gt;prepare_message = bcm2835_spi_prepare_message;</span>
 	master-&gt;dev.of_node = pdev-&gt;dev.of_node;
 
 	bs = spi_master_get_devdata(master);
<span class="p_header">diff --git a/drivers/spi/spi-bitbang-txrx.h b/drivers/spi/spi-bitbang-txrx.h</span>
<span class="p_header">index 06b34e5bcfa3..47bb9b898dfd 100644</span>
<span class="p_header">--- a/drivers/spi/spi-bitbang-txrx.h</span>
<span class="p_header">+++ b/drivers/spi/spi-bitbang-txrx.h</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> bitbang_txrx_be_cpha0(struct spi_device *spi,</span>
 {
 	/* if (cpol == 0) this is SPI_MODE_0; else this is SPI_MODE_2 */
 
<span class="p_del">-	bool oldbit = !(word &amp; 1);</span>
<span class="p_add">+	u32 oldbit = (!(word &amp; (1&lt;&lt;(bits-1)))) &lt;&lt; 31;</span>
 	/* clock starts at inactive polarity */
 	for (word &lt;&lt;= (32 - bits); likely(bits); bits--) {
 
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> bitbang_txrx_be_cpha1(struct spi_device *spi,</span>
 {
 	/* if (cpol == 0) this is SPI_MODE_1; else this is SPI_MODE_3 */
 
<span class="p_del">-	bool oldbit = !(word &amp; (1 &lt;&lt; 31));</span>
<span class="p_add">+	u32 oldbit = (!(word &amp; (1&lt;&lt;(bits-1)))) &lt;&lt; 31;</span>
 	/* clock starts at inactive polarity */
 	for (word &lt;&lt;= (32 - bits); likely(bits); bits--) {
 
<span class="p_header">diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c</span>
<span class="p_header">index eb03e1215195..7edede6e024b 100644</span>
<span class="p_header">--- a/drivers/spi/spi-dw-mmio.c</span>
<span class="p_header">+++ b/drivers/spi/spi-dw-mmio.c</span>
<span class="p_chunk">@@ -74,6 +74,9 @@</span> <span class="p_context"> static int dw_spi_mmio_probe(struct platform_device *pdev)</span>
 
 	dws-&gt;max_freq = clk_get_rate(dwsmmio-&gt;clk);
 
<span class="p_add">+	of_property_read_u32(pdev-&gt;dev.of_node, &quot;reg-io-width&quot;,</span>
<span class="p_add">+			     &amp;dws-&gt;reg_io_width);</span>
<span class="p_add">+</span>
 	num_cs = 4;
 
 	if (pdev-&gt;dev.of_node)
<span class="p_header">diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c</span>
<span class="p_header">index 8d67d03c71eb..4fbfcdc5cb24 100644</span>
<span class="p_header">--- a/drivers/spi/spi-dw.c</span>
<span class="p_header">+++ b/drivers/spi/spi-dw.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static void dw_writer(struct dw_spi *dws)</span>
 			else
 				txw = *(u16 *)(dws-&gt;tx);
 		}
<span class="p_del">-		dw_writel(dws, DW_SPI_DR, txw);</span>
<span class="p_add">+		dw_write_io_reg(dws, DW_SPI_DR, txw);</span>
 		dws-&gt;tx += dws-&gt;n_bytes;
 	}
 }
<span class="p_chunk">@@ -205,7 +205,7 @@</span> <span class="p_context"> static void dw_reader(struct dw_spi *dws)</span>
 	u16 rxw;
 
 	while (max--) {
<span class="p_del">-		rxw = dw_readl(dws, DW_SPI_DR);</span>
<span class="p_add">+		rxw = dw_read_io_reg(dws, DW_SPI_DR);</span>
 		/* Care rx only if the transfer&#39;s original &quot;rx&quot; is not null */
 		if (dws-&gt;rx_end - dws-&gt;len) {
 			if (dws-&gt;n_bytes == 1)
<span class="p_header">diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h</span>
<span class="p_header">index 6c91391c1a4f..b75ed327d5a2 100644</span>
<span class="p_header">--- a/drivers/spi/spi-dw.h</span>
<span class="p_header">+++ b/drivers/spi/spi-dw.h</span>
<span class="p_chunk">@@ -109,6 +109,7 @@</span> <span class="p_context"> struct dw_spi {</span>
 	u32			fifo_len;	/* depth of the FIFO buffer */
 	u32			max_freq;	/* max bus freq supported */
 
<span class="p_add">+	u32			reg_io_width;	/* DR I/O width in bytes */</span>
 	u16			bus_num;
 	u16			num_cs;		/* supported slave numbers */
 
<span class="p_chunk">@@ -145,11 +146,45 @@</span> <span class="p_context"> static inline u32 dw_readl(struct dw_spi *dws, u32 offset)</span>
 	return __raw_readl(dws-&gt;regs + offset);
 }
 
<span class="p_add">+static inline u16 dw_readw(struct dw_spi *dws, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __raw_readw(dws-&gt;regs + offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void dw_writel(struct dw_spi *dws, u32 offset, u32 val)
 {
 	__raw_writel(val, dws-&gt;regs + offset);
 }
 
<span class="p_add">+static inline void dw_writew(struct dw_spi *dws, u32 offset, u16 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__raw_writew(val, dws-&gt;regs + offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u32 dw_read_io_reg(struct dw_spi *dws, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (dws-&gt;reg_io_width) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		return dw_readw(dws, offset);</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return dw_readl(dws, offset);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void dw_write_io_reg(struct dw_spi *dws, u32 offset, u32 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (dws-&gt;reg_io_width) {</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		dw_writew(dws, offset, val);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		dw_writel(dws, offset, val);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void spi_enable_chip(struct dw_spi *dws, int enable)
 {
 	dw_writel(dws, DW_SPI_SSIENR, (enable ? 1 : 0));
<span class="p_header">diff --git a/drivers/spi/spi-img-spfi.c b/drivers/spi/spi-img-spfi.c</span>
<span class="p_header">index acce90ac7371..bb916c8d40db 100644</span>
<span class="p_header">--- a/drivers/spi/spi-img-spfi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-img-spfi.c</span>
<span class="p_chunk">@@ -105,6 +105,10 @@</span> <span class="p_context"> struct img_spfi {</span>
 	bool rx_dma_busy;
 };
 
<span class="p_add">+struct img_spfi_device_data {</span>
<span class="p_add">+	bool gpio_requested;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static inline u32 spfi_readl(struct img_spfi *spfi, u32 reg)
 {
 	return readl(spfi-&gt;regs + reg);
<span class="p_chunk">@@ -267,15 +271,15 @@</span> <span class="p_context"> static int img_spfi_start_pio(struct spi_master *master,</span>
 		cpu_relax();
 	}
 
<span class="p_del">-	ret = spfi_wait_all_done(spfi);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
 	if (rx_bytes &gt; 0 || tx_bytes &gt; 0) {
 		dev_err(spfi-&gt;dev, &quot;PIO transfer timed out\n&quot;);
 		return -ETIMEDOUT;
 	}
 
<span class="p_add">+	ret = spfi_wait_all_done(spfi);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -440,21 +444,50 @@</span> <span class="p_context"> static int img_spfi_unprepare(struct spi_master *master,</span>
 
 static int img_spfi_setup(struct spi_device *spi)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = gpio_request_one(spi-&gt;cs_gpio, (spi-&gt;mode &amp; SPI_CS_HIGH) ?</span>
<span class="p_del">-			       GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,</span>
<span class="p_del">-			       dev_name(&amp;spi-&gt;dev));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		dev_err(&amp;spi-&gt;dev, &quot;can&#39;t request chipselect gpio %d\n&quot;,</span>
<span class="p_add">+	int ret = -EINVAL;</span>
<span class="p_add">+	struct img_spfi_device_data *spfi_data = spi_get_ctldata(spi);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!spfi_data) {</span>
<span class="p_add">+		spfi_data = kzalloc(sizeof(*spfi_data), GFP_KERNEL);</span>
<span class="p_add">+		if (!spfi_data)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		spfi_data-&gt;gpio_requested = false;</span>
<span class="p_add">+		spi_set_ctldata(spi, spfi_data);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!spfi_data-&gt;gpio_requested) {</span>
<span class="p_add">+		ret = gpio_request_one(spi-&gt;cs_gpio,</span>
<span class="p_add">+				       (spi-&gt;mode &amp; SPI_CS_HIGH) ?</span>
<span class="p_add">+				       GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,</span>
<span class="p_add">+				       dev_name(&amp;spi-&gt;dev));</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_err(&amp;spi-&gt;dev, &quot;can&#39;t request chipselect gpio %d\n&quot;,</span>
 				spi-&gt;cs_gpio);
<span class="p_del">-</span>
<span class="p_add">+		else</span>
<span class="p_add">+			spfi_data-&gt;gpio_requested = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (gpio_is_valid(spi-&gt;cs_gpio)) {</span>
<span class="p_add">+			int mode = ((spi-&gt;mode &amp; SPI_CS_HIGH) ?</span>
<span class="p_add">+				    GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH);</span>
<span class="p_add">+</span>
<span class="p_add">+			ret = gpio_direction_output(spi-&gt;cs_gpio, mode);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				dev_err(&amp;spi-&gt;dev, &quot;chipselect gpio %d setup failed (%d)\n&quot;,</span>
<span class="p_add">+					spi-&gt;cs_gpio, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return ret;
 }
 
 static void img_spfi_cleanup(struct spi_device *spi)
 {
<span class="p_del">-	gpio_free(spi-&gt;cs_gpio);</span>
<span class="p_add">+	struct img_spfi_device_data *spfi_data = spi_get_ctldata(spi);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (spfi_data) {</span>
<span class="p_add">+		if (spfi_data-&gt;gpio_requested)</span>
<span class="p_add">+			gpio_free(spi-&gt;cs_gpio);</span>
<span class="p_add">+		kfree(spfi_data);</span>
<span class="p_add">+		spi_set_ctldata(spi, NULL);</span>
<span class="p_add">+	}</span>
 }
 
 static void img_spfi_config(struct spi_master *master, struct spi_device *spi,
<span class="p_header">diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">index bcc7c635d8e7..7872f3c78b51 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_chunk">@@ -48,8 +48,8 @@</span> <span class="p_context"> struct sh_msiof_spi_priv {</span>
 	const struct sh_msiof_chipdata *chipdata;
 	struct sh_msiof_spi_info *info;
 	struct completion done;
<span class="p_del">-	int tx_fifo_size;</span>
<span class="p_del">-	int rx_fifo_size;</span>
<span class="p_add">+	unsigned int tx_fifo_size;</span>
<span class="p_add">+	unsigned int rx_fifo_size;</span>
 	void *tx_dma_page;
 	void *rx_dma_page;
 	dma_addr_t tx_dma_addr;
<span class="p_chunk">@@ -95,8 +95,6 @@</span> <span class="p_context"> struct sh_msiof_spi_priv {</span>
 #define MDR2_WDLEN1(i)	(((i) - 1) &lt;&lt; 16) /* Word Count (1-64/256 (SH, A1))) */
 #define MDR2_GRPMASK1	0x00000001 /* Group Output Mask 1 (SH, A1) */
 
<span class="p_del">-#define MAX_WDLEN	256U</span>
<span class="p_del">-</span>
 /* TSCR and RSCR */
 #define SCR_BRPS_MASK	    0x1f00 /* Prescaler Setting (1-32) */
 #define SCR_BRPS(i)	(((i) - 1) &lt;&lt; 8)
<span class="p_chunk">@@ -850,7 +848,12 @@</span> <span class="p_context"> static int sh_msiof_transfer_one(struct spi_master *master,</span>
 		 *  DMA supports 32-bit words only, hence pack 8-bit and 16-bit
 		 *  words, with byte resp. word swapping.
 		 */
<span class="p_del">-		unsigned int l = min(len, MAX_WDLEN * 4);</span>
<span class="p_add">+		unsigned int l = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (tx_buf)</span>
<span class="p_add">+			l = min(len, p-&gt;tx_fifo_size * 4);</span>
<span class="p_add">+		if (rx_buf)</span>
<span class="p_add">+			l = min(len, p-&gt;rx_fifo_size * 4);</span>
 
 		if (bits &lt;= 8) {
 			if (l &amp; 3)
<span class="p_chunk">@@ -963,7 +966,7 @@</span> <span class="p_context"> static const struct sh_msiof_chipdata sh_data = {</span>
 
 static const struct sh_msiof_chipdata r8a779x_data = {
 	.tx_fifo_size = 64,
<span class="p_del">-	.rx_fifo_size = 256,</span>
<span class="p_add">+	.rx_fifo_size = 64,</span>
 	.master_flags = SPI_MASTER_MUST_TX,
 };
 
<span class="p_header">diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c</span>
<span class="p_header">index 133f53a9c1d4..a339c1e9997a 100644</span>
<span class="p_header">--- a/drivers/spi/spi-xilinx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-xilinx.c</span>
<span class="p_chunk">@@ -249,19 +249,23 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 	xspi-&gt;tx_ptr = t-&gt;tx_buf;
 	xspi-&gt;rx_ptr = t-&gt;rx_buf;
 	remaining_words = t-&gt;len / xspi-&gt;bytes_per_word;
<span class="p_del">-	reinit_completion(&amp;xspi-&gt;done);</span>
 
 	if (xspi-&gt;irq &gt;= 0 &amp;&amp;  remaining_words &gt; xspi-&gt;buffer_size) {
<span class="p_add">+		u32 isr;</span>
 		use_irq = true;
<span class="p_del">-		xspi-&gt;write_fn(XSPI_INTR_TX_EMPTY,</span>
<span class="p_del">-				xspi-&gt;regs + XIPIF_V123B_IISR_OFFSET);</span>
<span class="p_del">-		/* Enable the global IPIF interrupt */</span>
<span class="p_del">-		xspi-&gt;write_fn(XIPIF_V123B_GINTR_ENABLE,</span>
<span class="p_del">-				xspi-&gt;regs + XIPIF_V123B_DGIER_OFFSET);</span>
 		/* Inhibit irq to avoid spurious irqs on tx_empty*/
 		cr = xspi-&gt;read_fn(xspi-&gt;regs + XSPI_CR_OFFSET);
 		xspi-&gt;write_fn(cr | XSPI_CR_TRANS_INHIBIT,
 			       xspi-&gt;regs + XSPI_CR_OFFSET);
<span class="p_add">+		/* ACK old irqs (if any) */</span>
<span class="p_add">+		isr = xspi-&gt;read_fn(xspi-&gt;regs + XIPIF_V123B_IISR_OFFSET);</span>
<span class="p_add">+		if (isr)</span>
<span class="p_add">+			xspi-&gt;write_fn(isr,</span>
<span class="p_add">+				       xspi-&gt;regs + XIPIF_V123B_IISR_OFFSET);</span>
<span class="p_add">+		/* Enable the global IPIF interrupt */</span>
<span class="p_add">+		xspi-&gt;write_fn(XIPIF_V123B_GINTR_ENABLE,</span>
<span class="p_add">+				xspi-&gt;regs + XIPIF_V123B_DGIER_OFFSET);</span>
<span class="p_add">+		reinit_completion(&amp;xspi-&gt;done);</span>
 	}
 
 	while (remaining_words) {
<span class="p_chunk">@@ -302,8 +306,10 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 		remaining_words -= n_words;
 	}
 
<span class="p_del">-	if (use_irq)</span>
<span class="p_add">+	if (use_irq) {</span>
 		xspi-&gt;write_fn(0, xspi-&gt;regs + XIPIF_V123B_DGIER_OFFSET);
<span class="p_add">+		xspi-&gt;write_fn(cr, xspi-&gt;regs + XSPI_CR_OFFSET);</span>
<span class="p_add">+	}</span>
 
 	return t-&gt;len;
 }
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/adl_pci7x3x.c b/drivers/staging/comedi/drivers/adl_pci7x3x.c</span>
<span class="p_header">index 934af3ff7897..b0fc027cf485 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/adl_pci7x3x.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/adl_pci7x3x.c</span>
<span class="p_chunk">@@ -120,8 +120,20 @@</span> <span class="p_context"> static int adl_pci7x3x_do_insn_bits(struct comedi_device *dev,</span>
 {
 	unsigned long reg = (unsigned long)s-&gt;private;
 
<span class="p_del">-	if (comedi_dio_update_state(s, data))</span>
<span class="p_del">-		outl(s-&gt;state, dev-&gt;iobase + reg);</span>
<span class="p_add">+	if (comedi_dio_update_state(s, data)) {</span>
<span class="p_add">+		unsigned int val = s-&gt;state;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (s-&gt;n_chan == 16) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * It seems the PCI-7230 needs the 16-bit DO state</span>
<span class="p_add">+			 * to be shifted left by 16 bits before being written</span>
<span class="p_add">+			 * to the 32-bit register.  Set the value in both</span>
<span class="p_add">+			 * halves of the register to be sure.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			val |= val &lt;&lt; 16;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		outl(val, dev-&gt;iobase + reg);</span>
<span class="p_add">+	}</span>
 
 	data[1] = s-&gt;state;
 
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/usbduxsigma.c b/drivers/staging/comedi/drivers/usbduxsigma.c</span>
<span class="p_header">index eaa9add491df..dc0b25a54088 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/usbduxsigma.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/usbduxsigma.c</span>
<span class="p_chunk">@@ -550,27 +550,6 @@</span> <span class="p_context"> static int usbduxsigma_ai_cmdtest(struct comedi_device *dev,</span>
 	if (err)
 		return 3;
 
<span class="p_del">-	/* Step 4: fix up any arguments */</span>
<span class="p_del">-</span>
<span class="p_del">-	if (high_speed) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * every 2 channels get a time window of 125us. Thus, if we</span>
<span class="p_del">-		 * sample all 16 channels we need 1ms. If we sample only one</span>
<span class="p_del">-		 * channel we need only 125us</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		devpriv-&gt;ai_interval = interval;</span>
<span class="p_del">-		devpriv-&gt;ai_timer = cmd-&gt;scan_begin_arg / (125000 * interval);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* interval always 1ms */</span>
<span class="p_del">-		devpriv-&gt;ai_interval = 1;</span>
<span class="p_del">-		devpriv-&gt;ai_timer = cmd-&gt;scan_begin_arg / 1000000;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (devpriv-&gt;ai_timer &lt; 1)</span>
<span class="p_del">-		err |= -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return 4;</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -668,6 +647,22 @@</span> <span class="p_context"> static int usbduxsigma_ai_cmd(struct comedi_device *dev,</span>
 
 	down(&amp;devpriv-&gt;sem);
 
<span class="p_add">+	if (devpriv-&gt;high_speed) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * every 2 channels get a time window of 125us. Thus, if we</span>
<span class="p_add">+		 * sample all 16 channels we need 1ms. If we sample only one</span>
<span class="p_add">+		 * channel we need only 125us</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		unsigned int interval = usbduxsigma_chans_to_interval(len);</span>
<span class="p_add">+</span>
<span class="p_add">+		devpriv-&gt;ai_interval = interval;</span>
<span class="p_add">+		devpriv-&gt;ai_timer = cmd-&gt;scan_begin_arg / (125000 * interval);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* interval always 1ms */</span>
<span class="p_add">+		devpriv-&gt;ai_interval = 1;</span>
<span class="p_add">+		devpriv-&gt;ai_timer = cmd-&gt;scan_begin_arg / 1000000;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; len; i++) {
 		unsigned int chan  = CR_CHAN(cmd-&gt;chanlist[i]);
 
<span class="p_chunk">@@ -917,25 +912,6 @@</span> <span class="p_context"> static int usbduxsigma_ao_cmdtest(struct comedi_device *dev,</span>
 	if (err)
 		return 3;
 
<span class="p_del">-	/* Step 4: fix up any arguments */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* we count in timer steps */</span>
<span class="p_del">-	if (high_speed) {</span>
<span class="p_del">-		/* timing of the conversion itself: every 125 us */</span>
<span class="p_del">-		devpriv-&gt;ao_timer = cmd-&gt;convert_arg / 125000;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * timing of the scan: every 1ms</span>
<span class="p_del">-		 * we get all channels at once</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		devpriv-&gt;ao_timer = cmd-&gt;scan_begin_arg / 1000000;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (devpriv-&gt;ao_timer &lt; 1)</span>
<span class="p_del">-		err |= -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return 4;</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -948,6 +924,20 @@</span> <span class="p_context"> static int usbduxsigma_ao_cmd(struct comedi_device *dev,</span>
 
 	down(&amp;devpriv-&gt;sem);
 
<span class="p_add">+	if (cmd-&gt;convert_src == TRIG_TIMER) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * timing of the conversion itself: every 125 us</span>
<span class="p_add">+		 * at high speed (not used yet)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		devpriv-&gt;ao_timer = cmd-&gt;convert_arg / 125000;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * timing of the scan: every 1ms</span>
<span class="p_add">+		 * we get all channels at once</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		devpriv-&gt;ao_timer = cmd-&gt;scan_begin_arg / 1000000;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	devpriv-&gt;ao_counter = devpriv-&gt;ao_timer;
 
 	if (cmd-&gt;start_src == TRIG_NOW) {
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 46bcebba54b2..9373cca121d3 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -2000,6 +2000,12 @@</span> <span class="p_context"> pci_wch_ch38x_setup(struct serial_private *priv,</span>
 
 #define PCI_DEVICE_ID_EXAR_XR17V8358	0x8358
 
<span class="p_add">+#define PCI_VENDOR_ID_PERICOM			0x12D8</span>
<span class="p_add">+#define PCI_DEVICE_ID_PERICOM_PI7C9X7951	0x7951</span>
<span class="p_add">+#define PCI_DEVICE_ID_PERICOM_PI7C9X7952	0x7952</span>
<span class="p_add">+#define PCI_DEVICE_ID_PERICOM_PI7C9X7954	0x7954</span>
<span class="p_add">+#define PCI_DEVICE_ID_PERICOM_PI7C9X7958	0x7958</span>
<span class="p_add">+</span>
 /* Unknown vendors/cards - this should not be in linux/pci_ids.h */
 #define PCI_SUBDEVICE_ID_UNKNOWN_0x1584	0x1584
 #define PCI_SUBDEVICE_ID_UNKNOWN_0x1588	0x1588
<span class="p_chunk">@@ -2314,27 +2320,12 @@</span> <span class="p_context"> static struct pci_serial_quirk pci_serial_quirks[] __refdata = {</span>
 	 * Pericom
 	 */
 	{
<span class="p_del">-		.vendor		= 0x12d8,</span>
<span class="p_del">-		.device		= 0x7952,</span>
<span class="p_del">-		.subvendor	= PCI_ANY_ID,</span>
<span class="p_del">-		.subdevice	= PCI_ANY_ID,</span>
<span class="p_del">-		.setup		= pci_pericom_setup,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.vendor		= 0x12d8,</span>
<span class="p_del">-		.device		= 0x7954,</span>
<span class="p_del">-		.subvendor	= PCI_ANY_ID,</span>
<span class="p_del">-		.subdevice	= PCI_ANY_ID,</span>
<span class="p_del">-		.setup		= pci_pericom_setup,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.vendor		= 0x12d8,</span>
<span class="p_del">-		.device		= 0x7958,</span>
<span class="p_del">-		.subvendor	= PCI_ANY_ID,</span>
<span class="p_del">-		.subdevice	= PCI_ANY_ID,</span>
<span class="p_del">-		.setup		= pci_pericom_setup,</span>
<span class="p_add">+		.vendor         = PCI_VENDOR_ID_PERICOM,</span>
<span class="p_add">+		.device         = PCI_ANY_ID,</span>
<span class="p_add">+		.subvendor      = PCI_ANY_ID,</span>
<span class="p_add">+		.subdevice      = PCI_ANY_ID,</span>
<span class="p_add">+		.setup          = pci_pericom_setup,</span>
 	},
<span class="p_del">-</span>
 	/*
 	 * PLX
 	 */
<span class="p_chunk">@@ -3031,6 +3022,10 @@</span> <span class="p_context"> enum pci_board_num_t {</span>
 	pbn_fintek_8,
 	pbn_fintek_12,
 	pbn_wch384_4,
<span class="p_add">+	pbn_pericom_PI7C9X7951,</span>
<span class="p_add">+	pbn_pericom_PI7C9X7952,</span>
<span class="p_add">+	pbn_pericom_PI7C9X7954,</span>
<span class="p_add">+	pbn_pericom_PI7C9X7958,</span>
 };
 
 /*
<span class="p_chunk">@@ -3848,7 +3843,6 @@</span> <span class="p_context"> static struct pciserial_board pci_boards[] = {</span>
 		.base_baud	= 115200,
 		.first_offset	= 0x40,
 	},
<span class="p_del">-</span>
 	[pbn_wch384_4] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 4,
<span class="p_chunk">@@ -3856,6 +3850,33 @@</span> <span class="p_context"> static struct pciserial_board pci_boards[] = {</span>
 		.uart_offset    = 8,
 		.first_offset   = 0xC0,
 	},
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pericom PI7C9X795[1248] Uno/Dual/Quad/Octal UART</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	[pbn_pericom_PI7C9X7951] = {</span>
<span class="p_add">+		.flags          = FL_BASE0,</span>
<span class="p_add">+		.num_ports      = 1,</span>
<span class="p_add">+		.base_baud      = 921600,</span>
<span class="p_add">+		.uart_offset	= 0x8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[pbn_pericom_PI7C9X7952] = {</span>
<span class="p_add">+		.flags          = FL_BASE0,</span>
<span class="p_add">+		.num_ports      = 2,</span>
<span class="p_add">+		.base_baud      = 921600,</span>
<span class="p_add">+		.uart_offset	= 0x8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[pbn_pericom_PI7C9X7954] = {</span>
<span class="p_add">+		.flags          = FL_BASE0,</span>
<span class="p_add">+		.num_ports      = 4,</span>
<span class="p_add">+		.base_baud      = 921600,</span>
<span class="p_add">+		.uart_offset	= 0x8,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[pbn_pericom_PI7C9X7958] = {</span>
<span class="p_add">+		.flags          = FL_BASE0,</span>
<span class="p_add">+		.num_ports      = 8,</span>
<span class="p_add">+		.base_baud      = 921600,</span>
<span class="p_add">+		.uart_offset	= 0x8,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct pci_device_id blacklist[] = {
<span class="p_chunk">@@ -5117,6 +5138,25 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 		0,
 		0, pbn_exar_XR17V8358 },
 	/*
<span class="p_add">+	 * Pericom PI7C9X795[1248] Uno/Dual/Quad/Octal UART</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{   PCI_VENDOR_ID_PERICOM, PCI_DEVICE_ID_PERICOM_PI7C9X7951,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0,</span>
<span class="p_add">+		0, pbn_pericom_PI7C9X7951 },</span>
<span class="p_add">+	{   PCI_VENDOR_ID_PERICOM, PCI_DEVICE_ID_PERICOM_PI7C9X7952,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0,</span>
<span class="p_add">+		0, pbn_pericom_PI7C9X7952 },</span>
<span class="p_add">+	{   PCI_VENDOR_ID_PERICOM, PCI_DEVICE_ID_PERICOM_PI7C9X7954,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0,</span>
<span class="p_add">+		0, pbn_pericom_PI7C9X7954 },</span>
<span class="p_add">+	{   PCI_VENDOR_ID_PERICOM, PCI_DEVICE_ID_PERICOM_PI7C9X7958,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0,</span>
<span class="p_add">+		0, pbn_pericom_PI7C9X7958 },</span>
<span class="p_add">+	/*</span>
 	 * Topic TP560 Data/Fax/Voice 56k modem (reported by Evan Clarke)
 	 */
 	{	PCI_VENDOR_ID_TOPIC, PCI_DEVICE_ID_TOPIC_TP560,
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pnp.c b/drivers/tty/serial/8250/8250_pnp.c</span>
<span class="p_header">index 50a09cd76d50..658b392d1170 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pnp.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pnp.c</span>
<span class="p_chunk">@@ -41,6 +41,12 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	{	&quot;AEI1240&quot;,		0	},
 	/* Rockwell 56K ACF II Fax+Data+Voice Modem */
 	{	&quot;AKY1021&quot;,		0 /*SPCI_FL_NO_SHIRQ*/	},
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ALi Fast Infrared Controller</span>
<span class="p_add">+	 * Native driver (ali-ircc) is broken so at least</span>
<span class="p_add">+	 * it can be used with irtty-sir.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{	&quot;ALI5123&quot;,		0	},</span>
 	/* AZT3005 PnP SOUND DEVICE */
 	{	&quot;AZT4001&quot;,		0	},
 	/* Best Data Products Inc. Smart One 336F PnP Modem */
<span class="p_chunk">@@ -364,6 +370,11 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	/* Winbond CIR port, should not be probed. We should keep track
 	   of it to prevent the legacy serial driver from probing it */
 	{	&quot;WEC1022&quot;,		CIR_PORT	},
<span class="p_add">+	/*</span>
<span class="p_add">+	 * SMSC IrCC SIR/FIR port, should not be probed by serial driver</span>
<span class="p_add">+	 * as well so its own driver can bind to it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{	&quot;SMCF010&quot;,		CIR_PORT	},</span>
 	{	&quot;&quot;,			0	}
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/men_z135_uart.c b/drivers/tty/serial/men_z135_uart.c</span>
<span class="p_header">index 35c55505b3eb..5a41b8fbb10a 100644</span>
<span class="p_header">--- a/drivers/tty/serial/men_z135_uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/men_z135_uart.c</span>
<span class="p_chunk">@@ -392,7 +392,6 @@</span> <span class="p_context"> static irqreturn_t men_z135_intr(int irq, void *data)</span>
 	struct men_z135_port *uart = (struct men_z135_port *)data;
 	struct uart_port *port = &amp;uart-&gt;port;
 	bool handled = false;
<span class="p_del">-	unsigned long flags;</span>
 	int irq_id;
 
 	uart-&gt;stat_reg = ioread32(port-&gt;membase + MEN_Z135_STAT_REG);
<span class="p_chunk">@@ -401,7 +400,7 @@</span> <span class="p_context"> static irqreturn_t men_z135_intr(int irq, void *data)</span>
 	if (!irq_id)
 		goto out;
 
<span class="p_del">-	spin_lock_irqsave(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;port-&gt;lock);</span>
 	/* It&#39;s save to write to IIR[7:6] RXC[9:8] */
 	iowrite8(irq_id, port-&gt;membase + MEN_Z135_STAT_REG);
 
<span class="p_chunk">@@ -427,7 +426,7 @@</span> <span class="p_context"> static irqreturn_t men_z135_intr(int irq, void *data)</span>
 		handled = true;
 	}
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;port-&gt;lock);</span>
 out:
 	return IRQ_RETVAL(handled);
 }
<span class="p_chunk">@@ -717,7 +716,7 @@</span> <span class="p_context"> static void men_z135_set_termios(struct uart_port *port,</span>
 
 	baud = uart_get_baud_rate(port, termios, old, 0, uart_freq / 16);
 
<span class="p_del">-	spin_lock(&amp;port-&gt;lock);</span>
<span class="p_add">+	spin_lock_irq(&amp;port-&gt;lock);</span>
 	if (tty_termios_baud_rate(termios))
 		tty_termios_encode_baud_rate(termios, baud, baud);
 
<span class="p_chunk">@@ -725,7 +724,7 @@</span> <span class="p_context"> static void men_z135_set_termios(struct uart_port *port,</span>
 	iowrite32(bd_reg, port-&gt;membase + MEN_Z135_BAUD_REG);
 
 	uart_update_timeout(port, termios-&gt;c_cflag, baud);
<span class="p_del">-	spin_unlock(&amp;port-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irq(&amp;port-&gt;lock);</span>
 }
 
 static const char *men_z135_type(struct uart_port *port)
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index a0ae942d9562..1e0d9b8c48c9 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -295,15 +295,6 @@</span> <span class="p_context"> static int s3c24xx_serial_start_tx_dma(struct s3c24xx_uart_port *ourport,</span>
 	if (ourport-&gt;tx_mode != S3C24XX_TX_DMA)
 		enable_tx_dma(ourport);
 
<span class="p_del">-	while (xmit-&gt;tail &amp; (dma_get_cache_alignment() - 1)) {</span>
<span class="p_del">-		if (rd_regl(port, S3C2410_UFSTAT) &amp; ourport-&gt;info-&gt;tx_fifofull)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		wr_regb(port, S3C2410_UTXH, xmit-&gt;buf[xmit-&gt;tail]);</span>
<span class="p_del">-		xmit-&gt;tail = (xmit-&gt;tail + 1) &amp; (UART_XMIT_SIZE - 1);</span>
<span class="p_del">-		port-&gt;icount.tx++;</span>
<span class="p_del">-		count--;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dma-&gt;tx_size = count &amp; ~(dma_get_cache_alignment() - 1);
 	dma-&gt;tx_transfer_addr = dma-&gt;tx_addr + xmit-&gt;tail;
 
<span class="p_chunk">@@ -342,7 +333,9 @@</span> <span class="p_context"> static void s3c24xx_serial_start_next_tx(struct s3c24xx_uart_port *ourport)</span>
 		return;
 	}
 
<span class="p_del">-	if (!ourport-&gt;dma || !ourport-&gt;dma-&gt;tx_chan || count &lt; port-&gt;fifosize)</span>
<span class="p_add">+	if (!ourport-&gt;dma || !ourport-&gt;dma-&gt;tx_chan ||</span>
<span class="p_add">+	    count &lt; ourport-&gt;min_dma_size ||</span>
<span class="p_add">+	    xmit-&gt;tail &amp; (dma_get_cache_alignment() - 1))</span>
 		s3c24xx_serial_start_tx_pio(ourport);
 	else
 		s3c24xx_serial_start_tx_dma(ourport, count);
<span class="p_chunk">@@ -736,15 +729,20 @@</span> <span class="p_context"> static irqreturn_t s3c24xx_serial_tx_chars(int irq, void *id)</span>
 	struct uart_port *port = &amp;ourport-&gt;port;
 	struct circ_buf *xmit = &amp;port-&gt;state-&gt;xmit;
 	unsigned long flags;
<span class="p_del">-	int count;</span>
<span class="p_add">+	int count, dma_count = 0;</span>
 
 	spin_lock_irqsave(&amp;port-&gt;lock, flags);
 
 	count = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);
 
<span class="p_del">-	if (ourport-&gt;dma &amp;&amp; ourport-&gt;dma-&gt;tx_chan &amp;&amp; count &gt;= port-&gt;fifosize) {</span>
<span class="p_del">-		s3c24xx_serial_start_tx_dma(ourport, count);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (ourport-&gt;dma &amp;&amp; ourport-&gt;dma-&gt;tx_chan &amp;&amp;</span>
<span class="p_add">+	    count &gt;= ourport-&gt;min_dma_size) {</span>
<span class="p_add">+		int align = dma_get_cache_alignment() -</span>
<span class="p_add">+			(xmit-&gt;tail &amp; (dma_get_cache_alignment() - 1));</span>
<span class="p_add">+		if (count-align &gt;= ourport-&gt;min_dma_size) {</span>
<span class="p_add">+			dma_count = count-align;</span>
<span class="p_add">+			count = align;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (port-&gt;x_char) {
<span class="p_chunk">@@ -765,14 +763,24 @@</span> <span class="p_context"> static irqreturn_t s3c24xx_serial_tx_chars(int irq, void *id)</span>
 
 	/* try and drain the buffer... */
 
<span class="p_del">-	count = port-&gt;fifosize;</span>
<span class="p_del">-	while (!uart_circ_empty(xmit) &amp;&amp; count-- &gt; 0) {</span>
<span class="p_add">+	if (count &gt; port-&gt;fifosize) {</span>
<span class="p_add">+		count = port-&gt;fifosize;</span>
<span class="p_add">+		dma_count = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!uart_circ_empty(xmit) &amp;&amp; count &gt; 0) {</span>
 		if (rd_regl(port, S3C2410_UFSTAT) &amp; ourport-&gt;info-&gt;tx_fifofull)
 			break;
 
 		wr_regb(port, S3C2410_UTXH, xmit-&gt;buf[xmit-&gt;tail]);
 		xmit-&gt;tail = (xmit-&gt;tail + 1) &amp; (UART_XMIT_SIZE - 1);
 		port-&gt;icount.tx++;
<span class="p_add">+		count--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!count &amp;&amp; dma_count) {</span>
<span class="p_add">+		s3c24xx_serial_start_tx_dma(ourport, dma_count);</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (uart_circ_chars_pending(xmit) &lt; WAKEUP_CHARS) {
<span class="p_chunk">@@ -1838,6 +1846,13 @@</span> <span class="p_context"> static int s3c24xx_serial_probe(struct platform_device *pdev)</span>
 	else if (ourport-&gt;info-&gt;fifosize)
 		ourport-&gt;port.fifosize = ourport-&gt;info-&gt;fifosize;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * DMA transfers must be aligned at least to cache line size,</span>
<span class="p_add">+	 * so find minimal transfer size suitable for DMA mode</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ourport-&gt;min_dma_size = max_t(int, ourport-&gt;port.fifosize,</span>
<span class="p_add">+				    dma_get_cache_alignment());</span>
<span class="p_add">+</span>
 	probe_index++;
 
 	dbg(&quot;%s: initialising port %p...\n&quot;, __func__, ourport);
<span class="p_header">diff --git a/drivers/tty/serial/samsung.h b/drivers/tty/serial/samsung.h</span>
<span class="p_header">index d275032aa68d..fc5deaa4f382 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.h</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.h</span>
<span class="p_chunk">@@ -82,6 +82,7 @@</span> <span class="p_context"> struct s3c24xx_uart_port {</span>
 	unsigned char			tx_claimed;
 	unsigned int			pm_level;
 	unsigned long			baudclk_rate;
<span class="p_add">+	unsigned int			min_dma_size;</span>
 
 	unsigned int			rx_irq;
 	unsigned int			tx_irq;
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 69e769c35cf5..06ecd1e6871c 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -820,6 +820,11 @@</span> <span class="p_context"> static void dwc3_ep0_complete_data(struct dwc3 *dwc,</span>
 		unsigned maxp = ep0-&gt;endpoint.maxpacket;
 
 		transfer_size += (maxp - (transfer_size % maxp));
<span class="p_add">+</span>
<span class="p_add">+		/* Maximum of DWC3_EP0_BOUNCE_SIZE can only be received */</span>
<span class="p_add">+		if (transfer_size &gt; DWC3_EP0_BOUNCE_SIZE)</span>
<span class="p_add">+			transfer_size = DWC3_EP0_BOUNCE_SIZE;</span>
<span class="p_add">+</span>
 		transferred = min_t(u32, ur-&gt;length,
 				transfer_size - length);
 		memcpy(ur-&gt;buf, dwc-&gt;ep0_bounce, transferred);
<span class="p_chunk">@@ -941,11 +946,14 @@</span> <span class="p_context"> static void __dwc3_ep0_do_control_data(struct dwc3 *dwc,</span>
 			return;
 		}
 
<span class="p_del">-		WARN_ON(req-&gt;request.length &gt; DWC3_EP0_BOUNCE_SIZE);</span>
<span class="p_del">-</span>
 		maxpacket = dep-&gt;endpoint.maxpacket;
 		transfer_size = roundup(req-&gt;request.length, maxpacket);
 
<span class="p_add">+		if (transfer_size &gt; DWC3_EP0_BOUNCE_SIZE) {</span>
<span class="p_add">+			dev_WARN(dwc-&gt;dev, &quot;bounce buf can&#39;t handle req len\n&quot;);</span>
<span class="p_add">+			transfer_size = DWC3_EP0_BOUNCE_SIZE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		dwc-&gt;ep0_bounced = true;
 
 		/*
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uac2.c b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">index 531861547253..96d935b00504 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_chunk">@@ -975,6 +975,29 @@</span> <span class="p_context"> free_ep(struct uac2_rtd_params *prm, struct usb_ep *ep)</span>
 			&quot;%s:%d Error!\n&quot;, __func__, __LINE__);
 }
 
<span class="p_add">+static void set_ep_max_packet_size(const struct f_uac2_opts *uac2_opts,</span>
<span class="p_add">+	struct usb_endpoint_descriptor *ep_desc,</span>
<span class="p_add">+	unsigned int factor, bool is_playback)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int chmask, srate, ssize;</span>
<span class="p_add">+	u16 max_packet_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_playback) {</span>
<span class="p_add">+		chmask = uac2_opts-&gt;p_chmask;</span>
<span class="p_add">+		srate = uac2_opts-&gt;p_srate;</span>
<span class="p_add">+		ssize = uac2_opts-&gt;p_ssize;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chmask = uac2_opts-&gt;c_chmask;</span>
<span class="p_add">+		srate = uac2_opts-&gt;c_srate;</span>
<span class="p_add">+		ssize = uac2_opts-&gt;c_ssize;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	max_packet_size = num_channels(chmask) * ssize *</span>
<span class="p_add">+		DIV_ROUND_UP(srate, factor / (1 &lt;&lt; (ep_desc-&gt;bInterval - 1)));</span>
<span class="p_add">+	ep_desc-&gt;wMaxPacketSize = cpu_to_le16(min(max_packet_size,</span>
<span class="p_add">+				le16_to_cpu(ep_desc-&gt;wMaxPacketSize)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 afunc_bind(struct usb_configuration *cfg, struct usb_function *fn)
 {
<span class="p_chunk">@@ -1070,10 +1093,14 @@</span> <span class="p_context"> afunc_bind(struct usb_configuration *cfg, struct usb_function *fn)</span>
 	uac2-&gt;p_prm.uac2 = uac2;
 	uac2-&gt;c_prm.uac2 = uac2;
 
<span class="p_add">+	/* Calculate wMaxPacketSize according to audio bandwidth */</span>
<span class="p_add">+	set_ep_max_packet_size(uac2_opts, &amp;fs_epin_desc, 1000, true);</span>
<span class="p_add">+	set_ep_max_packet_size(uac2_opts, &amp;fs_epout_desc, 1000, false);</span>
<span class="p_add">+	set_ep_max_packet_size(uac2_opts, &amp;hs_epin_desc, 8000, true);</span>
<span class="p_add">+	set_ep_max_packet_size(uac2_opts, &amp;hs_epout_desc, 8000, false);</span>
<span class="p_add">+</span>
 	hs_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;
<span class="p_del">-	hs_epout_desc.wMaxPacketSize = fs_epout_desc.wMaxPacketSize;</span>
 	hs_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;
<span class="p_del">-	hs_epin_desc.wMaxPacketSize = fs_epin_desc.wMaxPacketSize;</span>
 
 	ret = usb_assign_descriptors(fn, fs_audio_desc, hs_audio_desc, NULL);
 	if (ret)
<span class="p_header">diff --git a/drivers/usb/gadget/udc/m66592-udc.c b/drivers/usb/gadget/udc/m66592-udc.c</span>
<span class="p_header">index 309706fe4bf0..9704053dfe05 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/m66592-udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/m66592-udc.c</span>
<span class="p_chunk">@@ -1052,7 +1052,7 @@</span> <span class="p_context"> static void set_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)</span>
 				tmp = m66592_read(m66592, M66592_INTSTS0) &amp;
 								M66592_CTSQ;
 				udelay(1);
<span class="p_del">-			} while (tmp != M66592_CS_IDST || timeout-- &gt; 0);</span>
<span class="p_add">+			} while (tmp != M66592_CS_IDST &amp;&amp; timeout-- &gt; 0);</span>
 
 			if (tmp == M66592_CS_IDST)
 				m66592_bset(m66592,
<span class="p_header">diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_header">index 5e44407aa099..5216f2b09d63 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> static ssize_t show_companion(struct device *dev,</span>
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	nports = HCS_N_PORTS(ehci-&gt;hcs_params);
 
 	for (index = 0; index &lt; nports; ++index) {
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static ssize_t store_companion(struct device *dev,</span>
 	struct ehci_hcd		*ehci;
 	int			portnum, new_owner;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	new_owner = PORT_OWNER;		/* Owned by companion */
 	if (sscanf(buf, &quot;%d&quot;, &amp;portnum) != 1)
 		return -EINVAL;
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static ssize_t show_uframe_periodic_max(struct device *dev,</span>
 	struct ehci_hcd		*ehci;
 	int			n;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	n = scnprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, ehci-&gt;uframe_periodic_max);
 	return n;
 }
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> static ssize_t store_uframe_periodic_max(struct device *dev,</span>
 	unsigned long		flags;
 	ssize_t			ret;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	if (kstrtouint(buf, 0, &amp;uframe_periodic_max) &lt; 0)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 4c8b3b82103d..a5a0376bbd48 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -605,6 +605,10 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2WI_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX3_PID) },</span>
 	/*
 	 * ELV devices:
 	 */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 792e054126de..2943b97b2a83 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -568,6 +568,14 @@</span> <span class="p_context"></span>
  */
 #define FTDI_SYNAPSE_SS200_PID 0x9090 /* SS200 - SNAP Stick 200 */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * CustomWare / ShipModul NMEA multiplexers product ids (FTDI_VID)</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX_PID	0xfd48	/* MiniPlex first generation NMEA Multiplexer */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX2_PID	0xfd49	/* MiniPlex-USB and MiniPlex-2 series */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX2WI_PID	0xfd4a	/* MiniPlex-2Wi */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX3_PID	0xfd4b	/* MiniPlex-3 series */</span>
<span class="p_add">+</span>
 
 /********************************/
 /** third-party VID/PID combos **/
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index f5257af33ecf..ae682e4eeaef 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -362,21 +362,38 @@</span> <span class="p_context"> static speed_t pl2303_encode_baud_rate_direct(unsigned char buf[4],</span>
 static speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],
 								speed_t baud)
 {
<span class="p_del">-	unsigned int tmp;</span>
<span class="p_add">+	unsigned int baseline, mantissa, exponent;</span>
 
 	/*
 	 * Apparently the formula is:
<span class="p_del">-	 * baudrate = 12M * 32 / (2^buf[1]) / buf[0]</span>
<span class="p_add">+	 *   baudrate = 12M * 32 / (mantissa * 4^exponent)</span>
<span class="p_add">+	 * where</span>
<span class="p_add">+	 *   mantissa = buf[8:0]</span>
<span class="p_add">+	 *   exponent = buf[11:9]</span>
 	 */
<span class="p_del">-	tmp = 12000000 * 32 / baud;</span>
<span class="p_add">+	baseline = 12000000 * 32;</span>
<span class="p_add">+	mantissa = baseline / baud;</span>
<span class="p_add">+	if (mantissa == 0)</span>
<span class="p_add">+		mantissa = 1;	/* Avoid dividing by zero if baud &gt; 32*12M. */</span>
<span class="p_add">+	exponent = 0;</span>
<span class="p_add">+	while (mantissa &gt;= 512) {</span>
<span class="p_add">+		if (exponent &lt; 7) {</span>
<span class="p_add">+			mantissa &gt;&gt;= 2;	/* divide by 4 */</span>
<span class="p_add">+			exponent++;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* Exponent is maxed. Trim mantissa and leave. */</span>
<span class="p_add">+			mantissa = 511;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	buf[3] = 0x80;
 	buf[2] = 0;
<span class="p_del">-	buf[1] = (tmp &gt;= 256);</span>
<span class="p_del">-	while (tmp &gt;= 256) {</span>
<span class="p_del">-		tmp &gt;&gt;= 2;</span>
<span class="p_del">-		buf[1] &lt;&lt;= 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	buf[0] = tmp;</span>
<span class="p_add">+	buf[1] = exponent &lt;&lt; 1 | mantissa &gt;&gt; 8;</span>
<span class="p_add">+	buf[0] = mantissa &amp; 0xff;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Calculate and return the exact baud rate. */</span>
<span class="p_add">+	baud = (baseline / mantissa) &gt;&gt; (exponent &lt;&lt; 1);</span>
 
 	return baud;
 }
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index d156545728c2..ebcec8cda858 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{USB_DEVICE(0x0AF0, 0x8120)},	/* Option GTM681W */
 
 	/* non-Gobi Sierra Wireless devices */
<span class="p_add">+	{DEVICE_SWI(0x03f0, 0x4e1d)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */</span>
 	{DEVICE_SWI(0x0f3d, 0x68a2)},	/* Sierra Wireless MC7700 */
 	{DEVICE_SWI(0x114f, 0x68a2)},	/* Sierra Wireless MC7750 */
 	{DEVICE_SWI(0x1199, 0x68a2)},	/* Sierra Wireless MC7710 */
<span class="p_header">diff --git a/drivers/usb/serial/symbolserial.c b/drivers/usb/serial/symbolserial.c</span>
<span class="p_header">index 8fceec7298e0..6ed804450a5a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/symbolserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/symbolserial.c</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> exit:</span>
 
 static int symbol_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
<span class="p_del">-	struct symbol_private *priv = usb_get_serial_data(port-&gt;serial);</span>
<span class="p_add">+	struct symbol_private *priv = usb_get_serial_port_data(port);</span>
 	unsigned long flags;
 	int result = 0;
 
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static void symbol_close(struct usb_serial_port *port)</span>
 static void symbol_throttle(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
<span class="p_del">-	struct symbol_private *priv = usb_get_serial_data(port-&gt;serial);</span>
<span class="p_add">+	struct symbol_private *priv = usb_get_serial_port_data(port);</span>
 
 	spin_lock_irq(&amp;priv-&gt;lock);
 	priv-&gt;throttled = true;
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static void symbol_throttle(struct tty_struct *tty)</span>
 static void symbol_unthrottle(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
<span class="p_del">-	struct symbol_private *priv = usb_get_serial_data(port-&gt;serial);</span>
<span class="p_add">+	struct symbol_private *priv = usb_get_serial_port_data(port);</span>
 	int result;
 	bool was_throttled;
 
<span class="p_header">diff --git a/fs/ceph/super.c b/fs/ceph/super.c</span>
<span class="p_header">index 4e9905374078..0d47422e3548 100644</span>
<span class="p_header">--- a/fs/ceph/super.c</span>
<span class="p_header">+++ b/fs/ceph/super.c</span>
<span class="p_chunk">@@ -466,7 +466,7 @@</span> <span class="p_context"> static int ceph_show_options(struct seq_file *m, struct dentry *root)</span>
 	if (fsopt-&gt;max_readdir_bytes != CEPH_MAX_READDIR_BYTES_DEFAULT)
 		seq_printf(m, &quot;,readdir_max_bytes=%d&quot;, fsopt-&gt;max_readdir_bytes);
 	if (strcmp(fsopt-&gt;snapdir_name, CEPH_SNAPDIRNAME_DEFAULT))
<span class="p_del">-		seq_printf(m, &quot;,snapdirname=%s&quot;, fsopt-&gt;snapdir_name);</span>
<span class="p_add">+		seq_show_option(m, &quot;snapdirname&quot;, fsopt-&gt;snapdir_name);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 0a9fb6b53126..6a1119e87fbb 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -394,17 +394,17 @@</span> <span class="p_context"> cifs_show_options(struct seq_file *s, struct dentry *root)</span>
 	struct sockaddr *srcaddr;
 	srcaddr = (struct sockaddr *)&amp;tcon-&gt;ses-&gt;server-&gt;srcaddr;
 
<span class="p_del">-	seq_printf(s, &quot;,vers=%s&quot;, tcon-&gt;ses-&gt;server-&gt;vals-&gt;version_string);</span>
<span class="p_add">+	seq_show_option(s, &quot;vers&quot;, tcon-&gt;ses-&gt;server-&gt;vals-&gt;version_string);</span>
 	cifs_show_security(s, tcon-&gt;ses);
 	cifs_show_cache_flavor(s, cifs_sb);
 
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER)
 		seq_puts(s, &quot;,multiuser&quot;);
 	else if (tcon-&gt;ses-&gt;user_name)
<span class="p_del">-		seq_printf(s, &quot;,username=%s&quot;, tcon-&gt;ses-&gt;user_name);</span>
<span class="p_add">+		seq_show_option(s, &quot;username&quot;, tcon-&gt;ses-&gt;user_name);</span>
 
 	if (tcon-&gt;ses-&gt;domainName)
<span class="p_del">-		seq_printf(s, &quot;,domain=%s&quot;, tcon-&gt;ses-&gt;domainName);</span>
<span class="p_add">+		seq_show_option(s, &quot;domain&quot;, tcon-&gt;ses-&gt;domainName);</span>
 
 	if (srcaddr-&gt;sa_family != AF_UNSPEC) {
 		struct sockaddr_in *saddr4;
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index ca12affdba96..6b4eb94b04a5 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -1738,10 +1738,10 @@</span> <span class="p_context"> static inline void ext4_show_quota_options(struct seq_file *seq,</span>
 	}
 
 	if (sbi-&gt;s_qf_names[USRQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,usrjquota=%s&quot;, sbi-&gt;s_qf_names[USRQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;usrjquota&quot;, sbi-&gt;s_qf_names[USRQUOTA]);</span>
 
 	if (sbi-&gt;s_qf_names[GRPQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,grpjquota=%s&quot;, sbi-&gt;s_qf_names[GRPQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;grpjquota&quot;, sbi-&gt;s_qf_names[GRPQUOTA]);</span>
 #endif
 }
 
<span class="p_header">diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c</span>
<span class="p_header">index 859c6edbf81a..c18b49dc5d4f 100644</span>
<span class="p_header">--- a/fs/gfs2/super.c</span>
<span class="p_header">+++ b/fs/gfs2/super.c</span>
<span class="p_chunk">@@ -1334,11 +1334,11 @@</span> <span class="p_context"> static int gfs2_show_options(struct seq_file *s, struct dentry *root)</span>
 	if (is_ancestor(root, sdp-&gt;sd_master_dir))
 		seq_puts(s, &quot;,meta&quot;);
 	if (args-&gt;ar_lockproto[0])
<span class="p_del">-		seq_printf(s, &quot;,lockproto=%s&quot;, args-&gt;ar_lockproto);</span>
<span class="p_add">+		seq_show_option(s, &quot;lockproto&quot;, args-&gt;ar_lockproto);</span>
 	if (args-&gt;ar_locktable[0])
<span class="p_del">-		seq_printf(s, &quot;,locktable=%s&quot;, args-&gt;ar_locktable);</span>
<span class="p_add">+		seq_show_option(s, &quot;locktable&quot;, args-&gt;ar_locktable);</span>
 	if (args-&gt;ar_hostdata[0])
<span class="p_del">-		seq_printf(s, &quot;,hostdata=%s&quot;, args-&gt;ar_hostdata);</span>
<span class="p_add">+		seq_show_option(s, &quot;hostdata&quot;, args-&gt;ar_hostdata);</span>
 	if (args-&gt;ar_spectator)
 		seq_puts(s, &quot;,spectator&quot;);
 	if (args-&gt;ar_localflocks)
<span class="p_header">diff --git a/fs/hfs/super.c b/fs/hfs/super.c</span>
<span class="p_header">index eee7206c38d1..410b65eea683 100644</span>
<span class="p_header">--- a/fs/hfs/super.c</span>
<span class="p_header">+++ b/fs/hfs/super.c</span>
<span class="p_chunk">@@ -135,9 +135,9 @@</span> <span class="p_context"> static int hfs_show_options(struct seq_file *seq, struct dentry *root)</span>
 	struct hfs_sb_info *sbi = HFS_SB(root-&gt;d_sb);
 
 	if (sbi-&gt;s_creator != cpu_to_be32(0x3f3f3f3f))
<span class="p_del">-		seq_printf(seq, &quot;,creator=%.4s&quot;, (char *)&amp;sbi-&gt;s_creator);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;creator&quot;, (char *)&amp;sbi-&gt;s_creator, 4);</span>
 	if (sbi-&gt;s_type != cpu_to_be32(0x3f3f3f3f))
<span class="p_del">-		seq_printf(seq, &quot;,type=%.4s&quot;, (char *)&amp;sbi-&gt;s_type);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;type&quot;, (char *)&amp;sbi-&gt;s_type, 4);</span>
 	seq_printf(seq, &quot;,uid=%u,gid=%u&quot;,
 			from_kuid_munged(&amp;init_user_ns, sbi-&gt;s_uid),
 			from_kgid_munged(&amp;init_user_ns, sbi-&gt;s_gid));
<span class="p_header">diff --git a/fs/hfsplus/options.c b/fs/hfsplus/options.c</span>
<span class="p_header">index c90b72ee676d..bb806e58c977 100644</span>
<span class="p_header">--- a/fs/hfsplus/options.c</span>
<span class="p_header">+++ b/fs/hfsplus/options.c</span>
<span class="p_chunk">@@ -218,9 +218,9 @@</span> <span class="p_context"> int hfsplus_show_options(struct seq_file *seq, struct dentry *root)</span>
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(root-&gt;d_sb);
 
 	if (sbi-&gt;creator != HFSPLUS_DEF_CR_TYPE)
<span class="p_del">-		seq_printf(seq, &quot;,creator=%.4s&quot;, (char *)&amp;sbi-&gt;creator);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;creator&quot;, (char *)&amp;sbi-&gt;creator, 4);</span>
 	if (sbi-&gt;type != HFSPLUS_DEF_CR_TYPE)
<span class="p_del">-		seq_printf(seq, &quot;,type=%.4s&quot;, (char *)&amp;sbi-&gt;type);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;type&quot;, (char *)&amp;sbi-&gt;type, 4);</span>
 	seq_printf(seq, &quot;,umask=%o,uid=%u,gid=%u&quot;, sbi-&gt;umask,
 			from_kuid_munged(&amp;init_user_ns, sbi-&gt;uid),
 			from_kgid_munged(&amp;init_user_ns, sbi-&gt;gid));
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 07d8d8f52faf..de2d6245e9fa 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static int hostfs_show_options(struct seq_file *seq, struct dentry *root)</span>
 	size_t offset = strlen(root_ino) + 1;
 
 	if (strlen(root_path) &gt; offset)
<span class="p_del">-		seq_printf(seq, &quot;,%s&quot;, root_path + offset);</span>
<span class="p_add">+		seq_show_option(seq, root_path + offset, NULL);</span>
 
 	if (append)
 		seq_puts(seq, &quot;,append&quot;);
<span class="p_header">diff --git a/fs/hpfs/namei.c b/fs/hpfs/namei.c</span>
<span class="p_header">index a0872f239f04..9e92c9c2d319 100644</span>
<span class="p_header">--- a/fs/hpfs/namei.c</span>
<span class="p_header">+++ b/fs/hpfs/namei.c</span>
<span class="p_chunk">@@ -8,6 +8,17 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &quot;hpfs_fn.h&quot;
 
<span class="p_add">+static void hpfs_update_directory_times(struct inode *dir)</span>
<span class="p_add">+{</span>
<span class="p_add">+	time_t t = get_seconds();</span>
<span class="p_add">+	if (t == dir-&gt;i_mtime.tv_sec &amp;&amp;</span>
<span class="p_add">+	    t == dir-&gt;i_ctime.tv_sec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	dir-&gt;i_mtime.tv_sec = dir-&gt;i_ctime.tv_sec = t;</span>
<span class="p_add">+	dir-&gt;i_mtime.tv_nsec = dir-&gt;i_ctime.tv_nsec = 0;</span>
<span class="p_add">+	hpfs_write_inode_nolock(dir);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
 	const unsigned char *name = dentry-&gt;d_name.name;
<span class="p_chunk">@@ -99,6 +110,7 @@</span> <span class="p_context"> static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)</span>
 		result-&gt;i_mode = mode | S_IFDIR;
 		hpfs_write_inode_nolock(result);
 	}
<span class="p_add">+	hpfs_update_directory_times(dir);</span>
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir-&gt;i_sb);
 	return 0;
<span class="p_chunk">@@ -187,6 +199,7 @@</span> <span class="p_context"> static int hpfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, b</span>
 		result-&gt;i_mode = mode | S_IFREG;
 		hpfs_write_inode_nolock(result);
 	}
<span class="p_add">+	hpfs_update_directory_times(dir);</span>
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir-&gt;i_sb);
 	return 0;
<span class="p_chunk">@@ -262,6 +275,7 @@</span> <span class="p_context"> static int hpfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, de</span>
 	insert_inode_hash(result);
 
 	hpfs_write_inode_nolock(result);
<span class="p_add">+	hpfs_update_directory_times(dir);</span>
 	d_instantiate(dentry, result);
 	brelse(bh);
 	hpfs_unlock(dir-&gt;i_sb);
<span class="p_chunk">@@ -340,6 +354,7 @@</span> <span class="p_context"> static int hpfs_symlink(struct inode *dir, struct dentry *dentry, const char *sy</span>
 	insert_inode_hash(result);
 
 	hpfs_write_inode_nolock(result);
<span class="p_add">+	hpfs_update_directory_times(dir);</span>
 	d_instantiate(dentry, result);
 	hpfs_unlock(dir-&gt;i_sb);
 	return 0;
<span class="p_chunk">@@ -423,6 +438,8 @@</span> <span class="p_context"> again:</span>
 out1:
 	hpfs_brelse4(&amp;qbh);
 out:
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		hpfs_update_directory_times(dir);</span>
 	hpfs_unlock(dir-&gt;i_sb);
 	return err;
 }
<span class="p_chunk">@@ -477,6 +494,8 @@</span> <span class="p_context"> static int hpfs_rmdir(struct inode *dir, struct dentry *dentry)</span>
 out1:
 	hpfs_brelse4(&amp;qbh);
 out:
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		hpfs_update_directory_times(dir);</span>
 	hpfs_unlock(dir-&gt;i_sb);
 	return err;
 }
<span class="p_chunk">@@ -595,7 +614,7 @@</span> <span class="p_context"> static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		goto end1;
 	}
 
<span class="p_del">-	end:</span>
<span class="p_add">+end:</span>
 	hpfs_i(i)-&gt;i_parent_dir = new_dir-&gt;i_ino;
 	if (S_ISDIR(i-&gt;i_mode)) {
 		inc_nlink(new_dir);
<span class="p_chunk">@@ -610,6 +629,10 @@</span> <span class="p_context"> static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		brelse(bh);
 	}
 end1:
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		hpfs_update_directory_times(old_dir);</span>
<span class="p_add">+		hpfs_update_directory_times(new_dir);</span>
<span class="p_add">+	}</span>
 	hpfs_unlock(i-&gt;i_sb);
 	return err;
 }
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index 02813592e121..f4641fd27bda 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -1176,7 +1176,7 @@</span> <span class="p_context"> void make_empty_dir_inode(struct inode *inode)</span>
 	inode-&gt;i_uid = GLOBAL_ROOT_UID;
 	inode-&gt;i_gid = GLOBAL_ROOT_GID;
 	inode-&gt;i_rdev = 0;
<span class="p_del">-	inode-&gt;i_size = 2;</span>
<span class="p_add">+	inode-&gt;i_size = 0;</span>
 	inode-&gt;i_blkbits = PAGE_SHIFT;
 	inode-&gt;i_blocks = 0;
 
<span class="p_header">diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c</span>
<span class="p_header">index 403c5660b306..a482e312c7b2 100644</span>
<span class="p_header">--- a/fs/ocfs2/super.c</span>
<span class="p_header">+++ b/fs/ocfs2/super.c</span>
<span class="p_chunk">@@ -1550,8 +1550,8 @@</span> <span class="p_context"> static int ocfs2_show_options(struct seq_file *s, struct dentry *root)</span>
 		seq_printf(s, &quot;,localflocks,&quot;);
 
 	if (osb-&gt;osb_cluster_stack[0])
<span class="p_del">-		seq_printf(s, &quot;,cluster_stack=%.*s&quot;, OCFS2_STACK_LABEL_LEN,</span>
<span class="p_del">-			   osb-&gt;osb_cluster_stack);</span>
<span class="p_add">+		seq_show_option_n(s, &quot;cluster_stack&quot;, osb-&gt;osb_cluster_stack,</span>
<span class="p_add">+				  OCFS2_STACK_LABEL_LEN);</span>
 	if (opts &amp; OCFS2_MOUNT_USRQUOTA)
 		seq_printf(s, &quot;,usrquota&quot;);
 	if (opts &amp; OCFS2_MOUNT_GRPQUOTA)
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index bf8537c7f455..155989455a72 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -517,10 +517,10 @@</span> <span class="p_context"> static int ovl_show_options(struct seq_file *m, struct dentry *dentry)</span>
 	struct super_block *sb = dentry-&gt;d_sb;
 	struct ovl_fs *ufs = sb-&gt;s_fs_info;
 
<span class="p_del">-	seq_printf(m, &quot;,lowerdir=%s&quot;, ufs-&gt;config.lowerdir);</span>
<span class="p_add">+	seq_show_option(m, &quot;lowerdir&quot;, ufs-&gt;config.lowerdir);</span>
 	if (ufs-&gt;config.upperdir) {
<span class="p_del">-		seq_printf(m, &quot;,upperdir=%s&quot;, ufs-&gt;config.upperdir);</span>
<span class="p_del">-		seq_printf(m, &quot;,workdir=%s&quot;, ufs-&gt;config.workdir);</span>
<span class="p_add">+		seq_show_option(m, &quot;upperdir&quot;, ufs-&gt;config.upperdir);</span>
<span class="p_add">+		seq_show_option(m, &quot;workdir&quot;, ufs-&gt;config.workdir);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c</span>
<span class="p_header">index 0111ad0466ed..cf6fa25f884b 100644</span>
<span class="p_header">--- a/fs/reiserfs/super.c</span>
<span class="p_header">+++ b/fs/reiserfs/super.c</span>
<span class="p_chunk">@@ -714,18 +714,20 @@</span> <span class="p_context"> static int reiserfs_show_options(struct seq_file *seq, struct dentry *root)</span>
 		seq_puts(seq, &quot;,acl&quot;);
 
 	if (REISERFS_SB(s)-&gt;s_jdev)
<span class="p_del">-		seq_printf(seq, &quot;,jdev=%s&quot;, REISERFS_SB(s)-&gt;s_jdev);</span>
<span class="p_add">+		seq_show_option(seq, &quot;jdev&quot;, REISERFS_SB(s)-&gt;s_jdev);</span>
 
 	if (journal-&gt;j_max_commit_age != journal-&gt;j_default_max_commit_age)
 		seq_printf(seq, &quot;,commit=%d&quot;, journal-&gt;j_max_commit_age);
 
 #ifdef CONFIG_QUOTA
 	if (REISERFS_SB(s)-&gt;s_qf_names[USRQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,usrjquota=%s&quot;, REISERFS_SB(s)-&gt;s_qf_names[USRQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;usrjquota&quot;,</span>
<span class="p_add">+				REISERFS_SB(s)-&gt;s_qf_names[USRQUOTA]);</span>
 	else if (opts &amp; (1 &lt;&lt; REISERFS_USRQUOTA))
 		seq_puts(seq, &quot;,usrquota&quot;);
 	if (REISERFS_SB(s)-&gt;s_qf_names[GRPQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,grpjquota=%s&quot;, REISERFS_SB(s)-&gt;s_qf_names[GRPQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;grpjquota&quot;,</span>
<span class="p_add">+				REISERFS_SB(s)-&gt;s_qf_names[GRPQUOTA]);</span>
 	else if (opts &amp; (1 &lt;&lt; REISERFS_GRPQUOTA))
 		seq_puts(seq, &quot;,grpquota&quot;);
 	if (REISERFS_SB(s)-&gt;s_jquota_fmt) {
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_da_format.h b/fs/xfs/libxfs/xfs_da_format.h</span>
<span class="p_header">index 74bcbabfa523..b14bbd6bb05f 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_da_format.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_da_format.h</span>
<span class="p_chunk">@@ -680,8 +680,15 @@</span> <span class="p_context"> typedef struct xfs_attr_leaf_name_remote {</span>
 typedef struct xfs_attr_leafblock {
 	xfs_attr_leaf_hdr_t	hdr;	/* constant-structure header block */
 	xfs_attr_leaf_entry_t	entries[1];	/* sorted on key, not name */
<span class="p_del">-	xfs_attr_leaf_name_local_t namelist;	/* grows from bottom of buf */</span>
<span class="p_del">-	xfs_attr_leaf_name_remote_t valuelist;	/* grows from bottom of buf */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rest of the block contains the following structures after the</span>
<span class="p_add">+	 * leaf entries, growing from the bottom up. The variables are never</span>
<span class="p_add">+	 * referenced and definining them can actually make gcc optimize away</span>
<span class="p_add">+	 * accesses to the &#39;entries&#39; array above index 0 so don&#39;t do that.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * xfs_attr_leaf_name_local_t namelist;</span>
<span class="p_add">+	 * xfs_attr_leaf_name_remote_t valuelist;</span>
<span class="p_add">+	 */</span>
 } xfs_attr_leafblock_t;
 
 /*
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_dir2_data.c b/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_header">index de1ea16f5748..534bbf283d6b 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_dir2_data.c</span>
<span class="p_chunk">@@ -252,7 +252,8 @@</span> <span class="p_context"> xfs_dir3_data_reada_verify(</span>
 		return;
 	case cpu_to_be32(XFS_DIR2_DATA_MAGIC):
 	case cpu_to_be32(XFS_DIR3_DATA_MAGIC):
<span class="p_del">-		xfs_dir3_data_verify(bp);</span>
<span class="p_add">+		bp-&gt;b_ops = &amp;xfs_dir3_data_buf_ops;</span>
<span class="p_add">+		bp-&gt;b_ops-&gt;verify_read(bp);</span>
 		return;
 	default:
 		xfs_buf_ioerror(bp, -EFSCORRUPTED);
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_dir2_node.c b/fs/xfs/libxfs/xfs_dir2_node.c</span>
<span class="p_header">index 41b80d3d3877..06bb4218b362 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_dir2_node.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_dir2_node.c</span>
<span class="p_chunk">@@ -2132,6 +2132,7 @@</span> <span class="p_context"> xfs_dir2_node_replace(</span>
 	int			error;		/* error return value */
 	int			i;		/* btree level */
 	xfs_ino_t		inum;		/* new inode number */
<span class="p_add">+	int			ftype;		/* new file type */</span>
 	xfs_dir2_leaf_t		*leaf;		/* leaf structure */
 	xfs_dir2_leaf_entry_t	*lep;		/* leaf entry being changed */
 	int			rval;		/* internal return value */
<span class="p_chunk">@@ -2145,7 +2146,14 @@</span> <span class="p_context"> xfs_dir2_node_replace(</span>
 	state = xfs_da_state_alloc();
 	state-&gt;args = args;
 	state-&gt;mp = args-&gt;dp-&gt;i_mount;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We have to save new inode number and ftype since</span>
<span class="p_add">+	 * xfs_da3_node_lookup_int() is going to overwrite them</span>
<span class="p_add">+	 */</span>
 	inum = args-&gt;inumber;
<span class="p_add">+	ftype = args-&gt;filetype;</span>
<span class="p_add">+</span>
 	/*
 	 * Lookup the entry to change in the btree.
 	 */
<span class="p_chunk">@@ -2183,7 +2191,7 @@</span> <span class="p_context"> xfs_dir2_node_replace(</span>
 		 * Fill in the new inode number and log the entry.
 		 */
 		dep-&gt;inumber = cpu_to_be64(inum);
<span class="p_del">-		args-&gt;dp-&gt;d_ops-&gt;data_put_ftype(dep, args-&gt;filetype);</span>
<span class="p_add">+		args-&gt;dp-&gt;d_ops-&gt;data_put_ftype(dep, ftype);</span>
 		xfs_dir2_data_log_entry(args, state-&gt;extrablk.bp, dep);
 		rval = 0;
 	}
<span class="p_header">diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c</span>
<span class="p_header">index 858e1e62bbaa..65a45372fb1f 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_super.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_super.c</span>
<span class="p_chunk">@@ -504,9 +504,9 @@</span> <span class="p_context"> xfs_showargs(</span>
 		seq_printf(m, &quot;,&quot; MNTOPT_LOGBSIZE &quot;=%dk&quot;, mp-&gt;m_logbsize &gt;&gt; 10);
 
 	if (mp-&gt;m_logname)
<span class="p_del">-		seq_printf(m, &quot;,&quot; MNTOPT_LOGDEV &quot;=%s&quot;, mp-&gt;m_logname);</span>
<span class="p_add">+		seq_show_option(m, MNTOPT_LOGDEV, mp-&gt;m_logname);</span>
 	if (mp-&gt;m_rtname)
<span class="p_del">-		seq_printf(m, &quot;,&quot; MNTOPT_RTDEV &quot;=%s&quot;, mp-&gt;m_rtname);</span>
<span class="p_add">+		seq_show_option(m, MNTOPT_RTDEV, mp-&gt;m_rtname);</span>
 
 	if (mp-&gt;m_dalign &gt; 0)
 		seq_printf(m, &quot;,&quot; MNTOPT_SUNIT &quot;=%d&quot;,
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 4550be3bb63b..808c43afa8ac 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> struct pci_dev;</span>
 
 int acpi_pci_irq_enable (struct pci_dev *dev);
 void acpi_penalize_isa_irq(int irq, int active);
<span class="p_del">-</span>
<span class="p_add">+void acpi_penalize_sci_irq(int irq, int trigger, int polarity);</span>
 void acpi_pci_irq_disable (struct pci_dev *dev);
 
 extern int ec_read(u8 addr, u8 *val);
<span class="p_header">diff --git a/include/linux/iio/iio.h b/include/linux/iio/iio.h</span>
<span class="p_header">index d86b753e9b30..5ed7771ad386 100644</span>
<span class="p_header">--- a/include/linux/iio/iio.h</span>
<span class="p_header">+++ b/include/linux/iio/iio.h</span>
<span class="p_chunk">@@ -642,6 +642,15 @@</span> <span class="p_context"> int iio_str_to_fixpoint(const char *str, int fract_mult, int *integer,</span>
 #define IIO_DEGREE_TO_RAD(deg) (((deg) * 314159ULL + 9000000ULL) / 18000000ULL)
 
 /**
<span class="p_add">+ * IIO_RAD_TO_DEGREE() - Convert rad to degree</span>
<span class="p_add">+ * @rad: A value in rad</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the given value converted from rad to degree</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IIO_RAD_TO_DEGREE(rad) \</span>
<span class="p_add">+	(((rad) * 18000000ULL + 314159ULL / 2) / 314159ULL)</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * IIO_G_TO_M_S_2() - Convert g to meter / second**2
  * @g: A value in g
  *
<span class="p_chunk">@@ -649,4 +658,12 @@</span> <span class="p_context"> int iio_str_to_fixpoint(const char *str, int fract_mult, int *integer,</span>
  */
 #define IIO_G_TO_M_S_2(g) ((g) * 980665ULL / 100000ULL)
 
<span class="p_add">+/**</span>
<span class="p_add">+ * IIO_M_S_2_TO_G() - Convert meter / second**2 to g</span>
<span class="p_add">+ * @ms2: A value in meter / second**2</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the given value converted from meter / second**2 to g</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IIO_M_S_2_TO_G(ms2) (((ms2) * 100000ULL + 980665ULL / 2) / 980665ULL)</span>
<span class="p_add">+</span>
 #endif /* _INDUSTRIAL_IO_H_ */
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index 3ef3a52068df..6e935e5eab56 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -180,6 +180,8 @@</span> <span class="p_context"> enum pci_dev_flags {</span>
 	PCI_DEV_FLAGS_NO_BUS_RESET = (__force pci_dev_flags_t) (1 &lt;&lt; 6),
 	/* Do not use PM reset even if device advertises NoSoftRst- */
 	PCI_DEV_FLAGS_NO_PM_RESET = (__force pci_dev_flags_t) (1 &lt;&lt; 7),
<span class="p_add">+	/* Get VPD from function 0 VPD */</span>
<span class="p_add">+	PCI_DEV_FLAGS_VPD_REF_F0 = (__force pci_dev_flags_t) (1 &lt;&lt; 8),</span>
 };
 
 enum pci_irq_reroute_variant {
<span class="p_header">diff --git a/include/linux/seq_file.h b/include/linux/seq_file.h</span>
<span class="p_header">index afbb1fd77c77..7848473a5bc8 100644</span>
<span class="p_header">--- a/include/linux/seq_file.h</span>
<span class="p_header">+++ b/include/linux/seq_file.h</span>
<span class="p_chunk">@@ -148,6 +148,41 @@</span> <span class="p_context"> static inline struct user_namespace *seq_user_ns(struct seq_file *seq)</span>
 #endif
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * seq_show_options - display mount options with appropriate escapes.</span>
<span class="p_add">+ * @m: the seq_file handle</span>
<span class="p_add">+ * @name: the mount option name</span>
<span class="p_add">+ * @value: the mount option name&#39;s value, can be NULL</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void seq_show_option(struct seq_file *m, const char *name,</span>
<span class="p_add">+				   const char *value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	seq_putc(m, &#39;,&#39;);</span>
<span class="p_add">+	seq_escape(m, name, &quot;,= \t\n\\&quot;);</span>
<span class="p_add">+	if (value) {</span>
<span class="p_add">+		seq_putc(m, &#39;=&#39;);</span>
<span class="p_add">+		seq_escape(m, value, &quot;, \t\n\\&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * seq_show_option_n - display mount options with appropriate escapes</span>
<span class="p_add">+ *		       where @value must be a specific length.</span>
<span class="p_add">+ * @m: the seq_file handle</span>
<span class="p_add">+ * @name: the mount option name</span>
<span class="p_add">+ * @value: the mount option name&#39;s value, cannot be NULL</span>
<span class="p_add">+ * @length: the length of @value to display</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is a macro since this uses &quot;length&quot; to define the size of the</span>
<span class="p_add">+ * stack buffer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define seq_show_option_n(m, name, value, length) {	\</span>
<span class="p_add">+	char val_buf[length + 1];			\</span>
<span class="p_add">+	strncpy(val_buf, value, length);		\</span>
<span class="p_add">+	val_buf[length] = &#39;\0&#39;;				\</span>
<span class="p_add">+	seq_show_option(m, name, val_buf);		\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define SEQ_START_TOKEN ((void *)1)
 /*
  * Helpers for iteration over list_head-s in seq_files
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index e8a5491be756..4d65b66ae60d 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -1319,7 +1319,7 @@</span> <span class="p_context"> static int cgroup_show_options(struct seq_file *seq,</span>
 
 	for_each_subsys(ss, ssid)
 		if (root-&gt;subsys_mask &amp; (1 &lt;&lt; ssid))
<span class="p_del">-			seq_printf(seq, &quot;,%s&quot;, ss-&gt;name);</span>
<span class="p_add">+			seq_show_option(seq, ss-&gt;name, NULL);</span>
 	if (root-&gt;flags &amp; CGRP_ROOT_NOPREFIX)
 		seq_puts(seq, &quot;,noprefix&quot;);
 	if (root-&gt;flags &amp; CGRP_ROOT_XATTR)
<span class="p_chunk">@@ -1327,13 +1327,14 @@</span> <span class="p_context"> static int cgroup_show_options(struct seq_file *seq,</span>
 
 	spin_lock(&amp;release_agent_path_lock);
 	if (strlen(root-&gt;release_agent_path))
<span class="p_del">-		seq_printf(seq, &quot;,release_agent=%s&quot;, root-&gt;release_agent_path);</span>
<span class="p_add">+		seq_show_option(seq, &quot;release_agent&quot;,</span>
<span class="p_add">+				root-&gt;release_agent_path);</span>
 	spin_unlock(&amp;release_agent_path_lock);
 
 	if (test_bit(CGRP_CPUSET_CLONE_CHILDREN, &amp;root-&gt;cgrp.flags))
 		seq_puts(seq, &quot;,clone_children&quot;);
 	if (strlen(root-&gt;name))
<span class="p_del">-		seq_printf(seq, &quot;,name=%s&quot;, root-&gt;name);</span>
<span class="p_add">+		seq_show_option(seq, &quot;name&quot;, root-&gt;name);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 123673291ffb..e6910526c84b 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5328,6 +5328,14 @@</span> <span class="p_context"> static int sched_cpu_active(struct notifier_block *nfb,</span>
 	case CPU_STARTING:
 		set_cpu_rq_start_time();
 		return NOTIFY_OK;
<span class="p_add">+	case CPU_ONLINE:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * At this point a starting CPU has marked itself as online via</span>
<span class="p_add">+		 * set_cpu_online(). But it might not yet have marked itself</span>
<span class="p_add">+		 * as active, which is essential from here on.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, fall-through and help the starting CPU along.</span>
<span class="p_add">+		 */</span>
 	case CPU_DOWN_FAILED:
 		set_cpu_active((long)hcpu, true);
 		return NOTIFY_OK;
<span class="p_header">diff --git a/net/ceph/ceph_common.c b/net/ceph/ceph_common.c</span>
<span class="p_header">index 79e8f71aef5b..3f76eb84b395 100644</span>
<span class="p_header">--- a/net/ceph/ceph_common.c</span>
<span class="p_header">+++ b/net/ceph/ceph_common.c</span>
<span class="p_chunk">@@ -495,8 +495,11 @@</span> <span class="p_context"> int ceph_print_client_options(struct seq_file *m, struct ceph_client *client)</span>
 	struct ceph_options *opt = client-&gt;options;
 	size_t pos = m-&gt;count;
 
<span class="p_del">-	if (opt-&gt;name)</span>
<span class="p_del">-		seq_printf(m, &quot;name=%s,&quot;, opt-&gt;name);</span>
<span class="p_add">+	if (opt-&gt;name) {</span>
<span class="p_add">+		seq_puts(m, &quot;name=&quot;);</span>
<span class="p_add">+		seq_escape(m, opt-&gt;name, &quot;, \t\n\\&quot;);</span>
<span class="p_add">+		seq_putc(m, &#39;,&#39;);</span>
<span class="p_add">+	}</span>
 	if (opt-&gt;key)
 		seq_puts(m, &quot;secret=&lt;hidden&gt;,&quot;);
 
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 7f8d7f19e044..280235cc3a98 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -1095,7 +1095,7 @@</span> <span class="p_context"> static void selinux_write_opts(struct seq_file *m,</span>
 		seq_puts(m, prefix);
 		if (has_comma)
 			seq_putc(m, &#39;\&quot;&#39;);
<span class="p_del">-		seq_puts(m, opts-&gt;mnt_opts[i]);</span>
<span class="p_add">+		seq_escape(m, opts-&gt;mnt_opts[i], &quot;\&quot;\n\\&quot;);</span>
 		if (has_comma)
 			seq_putc(m, &#39;\&quot;&#39;);
 	}
<span class="p_header">diff --git a/sound/soc/codecs/adav80x.c b/sound/soc/codecs/adav80x.c</span>
<span class="p_header">index 4373ada95648..3a91a00fb973 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adav80x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adav80x.c</span>
<span class="p_chunk">@@ -864,7 +864,6 @@</span> <span class="p_context"> const struct regmap_config adav80x_regmap_config = {</span>
 	.val_bits = 8,
 	.pad_bits = 1,
 	.reg_bits = 7,
<span class="p_del">-	.read_flag_mask = 0x01,</span>
 
 	.max_register = ADAV80X_PLL_OUTE,
 
<span class="p_header">diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c</span>
<span class="p_header">index eff4b4d512b7..ee91edcf3cb0 100644</span>
<span class="p_header">--- a/sound/soc/codecs/arizona.c</span>
<span class="p_header">+++ b/sound/soc/codecs/arizona.c</span>
<span class="p_chunk">@@ -1610,17 +1610,6 @@</span> <span class="p_context"> int arizona_init_dai(struct arizona_priv *priv, int id)</span>
 }
 EXPORT_SYMBOL_GPL(arizona_init_dai);
 
<span class="p_del">-static irqreturn_t arizona_fll_clock_ok(int irq, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct arizona_fll *fll = data;</span>
<span class="p_del">-</span>
<span class="p_del">-	arizona_fll_dbg(fll, &quot;clock OK\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	complete(&amp;fll-&gt;ok);</span>
<span class="p_del">-</span>
<span class="p_del">-	return IRQ_HANDLED;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct {
 	unsigned int min;
 	unsigned int max;
<span class="p_chunk">@@ -1902,17 +1891,18 @@</span> <span class="p_context"> static int arizona_is_enabled_fll(struct arizona_fll *fll)</span>
 static int arizona_enable_fll(struct arizona_fll *fll)
 {
 	struct arizona *arizona = fll-&gt;arizona;
<span class="p_del">-	unsigned long time_left;</span>
 	bool use_sync = false;
 	int already_enabled = arizona_is_enabled_fll(fll);
 	struct arizona_fll_cfg cfg;
<span class="p_add">+	int i;</span>
<span class="p_add">+	unsigned int val;</span>
 
 	if (already_enabled &lt; 0)
 		return already_enabled;
 
 	if (already_enabled) {
 		/* Facilitate smooth refclk across the transition */
<span class="p_del">-		regmap_update_bits_async(fll-&gt;arizona-&gt;regmap, fll-&gt;base + 0x7,</span>
<span class="p_add">+		regmap_update_bits_async(fll-&gt;arizona-&gt;regmap, fll-&gt;base + 0x9,</span>
 					 ARIZONA_FLL1_GAIN_MASK, 0);
 		regmap_update_bits_async(fll-&gt;arizona-&gt;regmap, fll-&gt;base + 1,
 					 ARIZONA_FLL1_FREERUN,
<span class="p_chunk">@@ -1964,9 +1954,6 @@</span> <span class="p_context"> static int arizona_enable_fll(struct arizona_fll *fll)</span>
 	if (!already_enabled)
 		pm_runtime_get(arizona-&gt;dev);
 
<span class="p_del">-	/* Clear any pending completions */</span>
<span class="p_del">-	try_wait_for_completion(&amp;fll-&gt;ok);</span>
<span class="p_del">-</span>
 	regmap_update_bits_async(arizona-&gt;regmap, fll-&gt;base + 1,
 				 ARIZONA_FLL1_ENA, ARIZONA_FLL1_ENA);
 	if (use_sync)
<span class="p_chunk">@@ -1978,10 +1965,24 @@</span> <span class="p_context"> static int arizona_enable_fll(struct arizona_fll *fll)</span>
 		regmap_update_bits_async(arizona-&gt;regmap, fll-&gt;base + 1,
 					 ARIZONA_FLL1_FREERUN, 0);
 
<span class="p_del">-	time_left = wait_for_completion_timeout(&amp;fll-&gt;ok,</span>
<span class="p_del">-					  msecs_to_jiffies(250));</span>
<span class="p_del">-	if (time_left == 0)</span>
<span class="p_add">+	arizona_fll_dbg(fll, &quot;Waiting for FLL lock...\n&quot;);</span>
<span class="p_add">+	val = 0;</span>
<span class="p_add">+	for (i = 0; i &lt; 15; i++) {</span>
<span class="p_add">+		if (i &lt; 5)</span>
<span class="p_add">+			usleep_range(200, 400);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			msleep(20);</span>
<span class="p_add">+</span>
<span class="p_add">+		regmap_read(arizona-&gt;regmap,</span>
<span class="p_add">+			    ARIZONA_INTERRUPT_RAW_STATUS_5,</span>
<span class="p_add">+			    &amp;val);</span>
<span class="p_add">+		if (val &amp; (ARIZONA_FLL1_CLOCK_OK_STS &lt;&lt; (fll-&gt;id - 1)))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (i == 15)</span>
 		arizona_fll_warn(fll, &quot;Timed out waiting for lock\n&quot;);
<span class="p_add">+	else</span>
<span class="p_add">+		arizona_fll_dbg(fll, &quot;FLL locked (%d polls)\n&quot;, i);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2066,11 +2067,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(arizona_set_fll);</span>
 int arizona_init_fll(struct arizona *arizona, int id, int base, int lock_irq,
 		     int ok_irq, struct arizona_fll *fll)
 {
<span class="p_del">-	int ret;</span>
 	unsigned int val;
 
<span class="p_del">-	init_completion(&amp;fll-&gt;ok);</span>
<span class="p_del">-</span>
 	fll-&gt;id = id;
 	fll-&gt;base = base;
 	fll-&gt;arizona = arizona;
<span class="p_chunk">@@ -2092,13 +2090,6 @@</span> <span class="p_context"> int arizona_init_fll(struct arizona *arizona, int id, int base, int lock_irq,</span>
 	snprintf(fll-&gt;clock_ok_name, sizeof(fll-&gt;clock_ok_name),
 		 &quot;FLL%d clock OK&quot;, id);
 
<span class="p_del">-	ret = arizona_request_irq(arizona, ok_irq, fll-&gt;clock_ok_name,</span>
<span class="p_del">-				  arizona_fll_clock_ok, fll);</span>
<span class="p_del">-	if (ret != 0) {</span>
<span class="p_del">-		dev_err(arizona-&gt;dev, &quot;Failed to get FLL%d clock OK IRQ: %d\n&quot;,</span>
<span class="p_del">-			id, ret);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	regmap_update_bits(arizona-&gt;regmap, fll-&gt;base + 1,
 			   ARIZONA_FLL1_FREERUN, 0);
 
<span class="p_header">diff --git a/sound/soc/codecs/arizona.h b/sound/soc/codecs/arizona.h</span>
<span class="p_header">index 11ff899b0272..14e8485b5585 100644</span>
<span class="p_header">--- a/sound/soc/codecs/arizona.h</span>
<span class="p_header">+++ b/sound/soc/codecs/arizona.h</span>
<span class="p_chunk">@@ -233,7 +233,6 @@</span> <span class="p_context"> struct arizona_fll {</span>
 	int id;
 	unsigned int base;
 	unsigned int vco_mult;
<span class="p_del">-	struct completion ok;</span>
 
 	unsigned int fout;
 	int sync_src;
<span class="p_header">diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c</span>
<span class="p_header">index 178e55d4d481..06317f7d945f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5640.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5640.c</span>
<span class="p_chunk">@@ -985,6 +985,35 @@</span> <span class="p_context"> static int rt5640_hp_event(struct snd_soc_dapm_widget *w,</span>
 	return 0;
 }
 
<span class="p_add">+static int rt5640_lout_event(struct snd_soc_dapm_widget *w,</span>
<span class="p_add">+	struct snd_kcontrol *kcontrol, int event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w-&gt;dapm);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (event) {</span>
<span class="p_add">+	case SND_SOC_DAPM_POST_PMU:</span>
<span class="p_add">+		hp_amp_power_on(codec);</span>
<span class="p_add">+		snd_soc_update_bits(codec, RT5640_PWR_ANLG1,</span>
<span class="p_add">+			RT5640_PWR_LM, RT5640_PWR_LM);</span>
<span class="p_add">+		snd_soc_update_bits(codec, RT5640_OUTPUT,</span>
<span class="p_add">+			RT5640_L_MUTE | RT5640_R_MUTE, 0);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case SND_SOC_DAPM_PRE_PMD:</span>
<span class="p_add">+		snd_soc_update_bits(codec, RT5640_OUTPUT,</span>
<span class="p_add">+			RT5640_L_MUTE | RT5640_R_MUTE,</span>
<span class="p_add">+			RT5640_L_MUTE | RT5640_R_MUTE);</span>
<span class="p_add">+		snd_soc_update_bits(codec, RT5640_PWR_ANLG1,</span>
<span class="p_add">+			RT5640_PWR_LM, 0);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int rt5640_hp_power_event(struct snd_soc_dapm_widget *w,
 			   struct snd_kcontrol *kcontrol, int event)
 {
<span class="p_chunk">@@ -1180,13 +1209,16 @@</span> <span class="p_context"> static const struct snd_soc_dapm_widget rt5640_dapm_widgets[] = {</span>
 		0, rt5640_spo_l_mix, ARRAY_SIZE(rt5640_spo_l_mix)),
 	SND_SOC_DAPM_MIXER(&quot;SPOR MIX&quot;, SND_SOC_NOPM, 0,
 		0, rt5640_spo_r_mix, ARRAY_SIZE(rt5640_spo_r_mix)),
<span class="p_del">-	SND_SOC_DAPM_MIXER(&quot;LOUT MIX&quot;, RT5640_PWR_ANLG1, RT5640_PWR_LM_BIT, 0,</span>
<span class="p_add">+	SND_SOC_DAPM_MIXER(&quot;LOUT MIX&quot;, SND_SOC_NOPM, 0, 0,</span>
 		rt5640_lout_mix, ARRAY_SIZE(rt5640_lout_mix)),
 	SND_SOC_DAPM_SUPPLY_S(&quot;Improve HP Amp Drv&quot;, 1, SND_SOC_NOPM,
 		0, 0, rt5640_hp_power_event, SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_PGA_S(&quot;HP Amp&quot;, 1, SND_SOC_NOPM, 0, 0,
 		rt5640_hp_event,
 		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
<span class="p_add">+	SND_SOC_DAPM_PGA_S(&quot;LOUT amp&quot;, 1, SND_SOC_NOPM, 0, 0,</span>
<span class="p_add">+		rt5640_lout_event,</span>
<span class="p_add">+		SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),</span>
 	SND_SOC_DAPM_SUPPLY(&quot;HP L Amp&quot;, RT5640_PWR_ANLG1,
 		RT5640_PWR_HP_L_BIT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY(&quot;HP R Amp&quot;, RT5640_PWR_ANLG1,
<span class="p_chunk">@@ -1501,8 +1533,10 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route rt5640_dapm_routes[] = {</span>
 	{&quot;HP R Playback&quot;, &quot;Switch&quot;, &quot;HP Amp&quot;},
 	{&quot;HPOL&quot;, NULL, &quot;HP L Playback&quot;},
 	{&quot;HPOR&quot;, NULL, &quot;HP R Playback&quot;},
<span class="p_del">-	{&quot;LOUTL&quot;, NULL, &quot;LOUT MIX&quot;},</span>
<span class="p_del">-	{&quot;LOUTR&quot;, NULL, &quot;LOUT MIX&quot;},</span>
<span class="p_add">+</span>
<span class="p_add">+	{&quot;LOUT amp&quot;, NULL, &quot;LOUT MIX&quot;},</span>
<span class="p_add">+	{&quot;LOUTL&quot;, NULL, &quot;LOUT amp&quot;},</span>
<span class="p_add">+	{&quot;LOUTR&quot;, NULL, &quot;LOUT amp&quot;},</span>
 };
 
 static const struct snd_soc_dapm_route rt5640_specific_dapm_routes[] = {
<span class="p_header">diff --git a/sound/soc/samsung/arndale_rt5631.c b/sound/soc/samsung/arndale_rt5631.c</span>
<span class="p_header">index 8bf2e2c4bafb..9e371eb3e4fa 100644</span>
<span class="p_header">--- a/sound/soc/samsung/arndale_rt5631.c</span>
<span class="p_header">+++ b/sound/soc/samsung/arndale_rt5631.c</span>
<span class="p_chunk">@@ -116,15 +116,6 @@</span> <span class="p_context"> static int arndale_audio_probe(struct platform_device *pdev)</span>
 	return ret;
 }
 
<span class="p_del">-static int arndale_audio_remove(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct snd_soc_card *card = platform_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	snd_soc_unregister_card(card);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const struct of_device_id samsung_arndale_rt5631_of_match[] __maybe_unused = {
 	{ .compatible = &quot;samsung,arndale-rt5631&quot;, },
 	{ .compatible = &quot;samsung,arndale-alc5631&quot;, },
<span class="p_chunk">@@ -139,7 +130,6 @@</span> <span class="p_context"> static struct platform_driver arndale_audio_driver = {</span>
 		.of_match_table = of_match_ptr(samsung_arndale_rt5631_of_match),
 	},
 	.probe = arndale_audio_probe,
<span class="p_del">-	.remove = arndale_audio_remove,</span>
 };
 
 module_platform_driver(arndale_audio_driver);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



