
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,2/7] x86, mm: introduce struct vmem_altmap - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,2/7] x86, mm: introduce struct vmem_altmap</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=320">Dan Williams</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 13, 2015, 3:50 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150813035011.36913.42952.stgit@otcpl-skl-sds-2.jf.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7005781/mbox/"
   >mbox</a>
|
   <a href="/patch/7005781/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7005781/">/patch/7005781/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id ADFFCC05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 13 Aug 2015 03:57:42 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C130D2073D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 13 Aug 2015 03:57:40 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 7D70E20742
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 13 Aug 2015 03:57:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752561AbbHMD5d (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 12 Aug 2015 23:57:33 -0400
Received: from mga11.intel.com ([192.55.52.93]:47355 &quot;EHLO mga11.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752107AbbHMDzy (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 12 Aug 2015 23:55:54 -0400
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
	by fmsmga102.fm.intel.com with ESMTP; 12 Aug 2015 20:55:54 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.15,667,1432623600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;540910304&quot;
Received: from dwillia2-desk3.jf.intel.com (HELO
	otcpl-skl-sds-2.jf.intel.com) ([10.54.39.137])
	by FMSMGA003.fm.intel.com with ESMTP; 12 Aug 2015 20:55:53 -0700
Subject: [RFC PATCH 2/7] x86, mm: introduce struct vmem_altmap
From: Dan Williams &lt;dan.j.williams@intel.com&gt;
To: linux-kernel@vger.kernel.org
Cc: boaz@plexistor.com, riel@redhat.com, linux-nvdimm@lists.01.org,
	Dave Hansen &lt;dave.hansen@linux.intel.com&gt;, david@fromorbit.com,
	mingo@kernel.org, linux-mm@kvack.org,
	Ingo Molnar &lt;mingo@redhat.com&gt;, mgorman@suse.de,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, ross.zwisler@linux.intel.com,
	torvalds@linux-foundation.org, hch@lst.de
Date: Wed, 12 Aug 2015 23:50:11 -0400
Message-ID: &lt;20150813035011.36913.42952.stgit@otcpl-skl-sds-2.jf.intel.com&gt;
In-Reply-To: &lt;20150813031253.36913.29580.stgit@otcpl-skl-sds-2.jf.intel.com&gt;
References: &lt;20150813031253.36913.29580.stgit@otcpl-skl-sds-2.jf.intel.com&gt;
User-Agent: StGit/0.17.1-8-g92dd
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Aug. 13, 2015, 3:50 a.m.</div>
<pre class="content">
This is a preparation patch only, no functional changes.  It simply
makes the following patch easier to read.  struct vmem_altmap modifies
the memory hotplug code to enable it to map &quot;device memory&quot; while
allocating the storage for struct page from that same capacity. The
first user of this capability will be the pmem driver for persistent
memory.

Cc: H. Peter Anvin &lt;hpa@zytor.com&gt;
Cc: Ingo Molnar &lt;mingo@redhat.com&gt;
Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;
Cc: Rik van Riel &lt;riel@redhat.com&gt;
Cc: Mel Gorman &lt;mgorman@suse.de&gt;
Cc: linux-mm@kvack.org
<span class="signed-off-by">Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;</span>
---
 arch/powerpc/mm/init_64.c      |    7 ++++
 arch/x86/mm/init_64.c          |   79 ++++++++++++++++++++++++++--------------
 include/linux/memory_hotplug.h |   17 ++++++++-
 include/linux/mm.h             |   13 ++++++-
 mm/memory_hotplug.c            |   67 +++++++++++++++++++++-------------
 mm/page_alloc.c                |   11 +++++-
 mm/sparse-vmemmap.c            |   29 ++++++++++++---
 mm/sparse.c                    |   29 +++++++++------
 8 files changed, 177 insertions(+), 75 deletions(-)


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="p_header">index d747dd7bc90b..e3e367399935 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_64.c</span>
<span class="p_chunk">@@ -404,6 +404,13 @@</span> <span class="p_context"> void __ref vmemmap_free(unsigned long start, unsigned long end)</span>
 		}
 	}
 }
<span class="p_add">+</span>
<span class="p_add">+void __ref __vmemmap_free(unsigned long start, unsigned long end,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN_ONCE(altmap, &quot;vmem_altmap support not implemented.\n&quot;);</span>
<span class="p_add">+	return vmemmap_free(start, end);</span>
<span class="p_add">+}</span>
 #endif
 void register_page_bootmem_memmap(unsigned long section_nr,
 				  struct page *start_page, unsigned long size)
<span class="p_header">diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c</span>
<span class="p_header">index 94f0fa56f0ed..c2f872a379d2 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_64.c</span>
<span class="p_chunk">@@ -683,7 +683,8 @@</span> <span class="p_context"> static void  update_end_of_memory_vars(u64 start, u64 size)</span>
 	}
 }
 
<span class="p_del">-static int __arch_add_memory(int nid, u64 start, u64 size, struct zone *zone)</span>
<span class="p_add">+static int __arch_add_memory(int nid, u64 start, u64 size, struct zone *zone,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long start_pfn = start &gt;&gt; PAGE_SHIFT;
 	unsigned long nr_pages = size &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -691,7 +692,7 @@</span> <span class="p_context"> static int __arch_add_memory(int nid, u64 start, u64 size, struct zone *zone)</span>
 
 	init_memory_mapping(start, start + size);
 
<span class="p_del">-	ret = __add_pages(nid, zone, start_pfn, nr_pages);</span>
<span class="p_add">+	ret = __add_pages_altmap(nid, zone, start_pfn, nr_pages, altmap);</span>
 	WARN_ON_ONCE(ret);
 
 	/*
<span class="p_chunk">@@ -714,7 +715,7 @@</span> <span class="p_context"> int arch_add_memory(int nid, u64 start, u64 size)</span>
 	struct zone *zone = pgdat-&gt;node_zones +
 		zone_for_memory(nid, start, size, ZONE_NORMAL);
 
<span class="p_del">-	return __arch_add_memory(nid, start, size, zone);</span>
<span class="p_add">+	return __arch_add_memory(nid, start, size, zone, NULL);</span>
 }
 EXPORT_SYMBOL_GPL(arch_add_memory);
 
<span class="p_chunk">@@ -758,7 +759,8 @@</span> <span class="p_context"> static void __meminit free_pte_table(pte_t *pte_start, pmd_t *pmd)</span>
 	spin_unlock(&amp;init_mm.page_table_lock);
 }
 
<span class="p_del">-static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud)</span>
<span class="p_add">+static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	pmd_t *pmd;
 	int i;
<span class="p_chunk">@@ -869,9 +871,9 @@</span> <span class="p_context"> remove_pte_table(pte_t *pte_start, unsigned long addr, unsigned long end,</span>
 		update_page_count(PG_LEVEL_4K, -pages);
 }
 
<span class="p_del">-static void __meminit</span>
<span class="p_add">+static void noinline __meminit</span>
 remove_pmd_table(pmd_t *pmd_start, unsigned long addr, unsigned long end,
<span class="p_del">-		 bool direct)</span>
<span class="p_add">+		 bool direct, struct vmem_altmap *altmap)</span>
 {
 	unsigned long next, pages = 0;
 	pte_t *pte_base;
<span class="p_chunk">@@ -925,9 +927,9 @@</span> <span class="p_context"> remove_pmd_table(pmd_t *pmd_start, unsigned long addr, unsigned long end,</span>
 		update_page_count(PG_LEVEL_2M, -pages);
 }
 
<span class="p_del">-static void __meminit</span>
<span class="p_add">+static void noinline __meminit</span>
 remove_pud_table(pud_t *pud_start, unsigned long addr, unsigned long end,
<span class="p_del">-		 bool direct)</span>
<span class="p_add">+		 bool direct, struct vmem_altmap *altmap)</span>
 {
 	unsigned long next, pages = 0;
 	pmd_t *pmd_base;
<span class="p_chunk">@@ -972,8 +974,8 @@</span> <span class="p_context"> remove_pud_table(pud_t *pud_start, unsigned long addr, unsigned long end,</span>
 		}
 
 		pmd_base = (pmd_t *)pud_page_vaddr(*pud);
<span class="p_del">-		remove_pmd_table(pmd_base, addr, next, direct);</span>
<span class="p_del">-		free_pmd_table(pmd_base, pud);</span>
<span class="p_add">+		remove_pmd_table(pmd_base, addr, next, direct, altmap);</span>
<span class="p_add">+		free_pmd_table(pmd_base, pud, altmap);</span>
 	}
 
 	if (direct)
<span class="p_chunk">@@ -982,7 +984,8 @@</span> <span class="p_context"> remove_pud_table(pud_t *pud_start, unsigned long addr, unsigned long end,</span>
 
 /* start and end are both virtual address. */
 static void __meminit
<span class="p_del">-remove_pagetable(unsigned long start, unsigned long end, bool direct)</span>
<span class="p_add">+remove_pagetable(unsigned long start, unsigned long end, bool direct,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long next;
 	unsigned long addr;
<span class="p_chunk">@@ -998,7 +1001,7 @@</span> <span class="p_context"> remove_pagetable(unsigned long start, unsigned long end, bool direct)</span>
 			continue;
 
 		pud = (pud_t *)pgd_page_vaddr(*pgd);
<span class="p_del">-		remove_pud_table(pud, addr, next, direct);</span>
<span class="p_add">+		remove_pud_table(pud, addr, next, direct, altmap);</span>
 		if (free_pud_table(pud, pgd))
 			pgd_changed = true;
 	}
<span class="p_chunk">@@ -1009,9 +1012,15 @@</span> <span class="p_context"> remove_pagetable(unsigned long start, unsigned long end, bool direct)</span>
 	flush_tlb_all();
 }
 
<span class="p_add">+void __ref __vmemmap_free(unsigned long start, unsigned long end,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	remove_pagetable(start, end, false, altmap);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __ref vmemmap_free(unsigned long start, unsigned long end)
 {
<span class="p_del">-	remove_pagetable(start, end, false);</span>
<span class="p_add">+	return __vmemmap_free(start, end, NULL);</span>
 }
 
 #ifdef CONFIG_MEMORY_HOTREMOVE
<span class="p_chunk">@@ -1021,22 +1030,25 @@</span> <span class="p_context"> kernel_physical_mapping_remove(unsigned long start, unsigned long end)</span>
 	start = (unsigned long)__va(start);
 	end = (unsigned long)__va(end);
 
<span class="p_del">-	remove_pagetable(start, end, true);</span>
<span class="p_add">+	remove_pagetable(start, end, true, NULL);</span>
 }
 
<span class="p_del">-int __ref arch_remove_memory(u64 start, u64 size)</span>
<span class="p_add">+static int __ref __arch_remove_memory(u64 start, u64 size, struct zone *zone,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
<span class="p_del">-	unsigned long start_pfn = start &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	unsigned long nr_pages = size &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	struct zone *zone;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	zone = page_zone(pfn_to_page(start_pfn));</span>
 	kernel_physical_mapping_remove(start, start + size);
<span class="p_del">-	ret = __remove_pages(zone, start_pfn, nr_pages);</span>
<span class="p_del">-	WARN_ON_ONCE(ret);</span>
<span class="p_add">+	return __remove_pages_altmap(zone, __phys_to_pfn(start),</span>
<span class="p_add">+			__phys_to_pfn(size), altmap);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+int __ref arch_remove_memory(u64 start, u64 size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zone *zone = page_zone(pfn_to_page(__phys_to_pfn(start)));</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = __arch_remove_memory(start, size, zone, NULL);</span>
<span class="p_add">+	WARN_ON_ONCE(rc);</span>
<span class="p_add">+	return rc;</span>
 }
 #endif /* CONFIG_MEMORY_HOTREMOVE */
 #endif /* CONFIG_MEMORY_HOTPLUG */
<span class="p_chunk">@@ -1244,7 +1256,7 @@</span> <span class="p_context"> static void __meminitdata *p_start, *p_end;</span>
 static int __meminitdata node_start;
 
 static int __meminit vmemmap_populate_hugepages(unsigned long start,
<span class="p_del">-						unsigned long end, int node)</span>
<span class="p_add">+		unsigned long end, int node, struct vmem_altmap *altmap)</span>
 {
 	unsigned long addr;
 	unsigned long next;
<span class="p_chunk">@@ -1267,7 +1279,7 @@</span> <span class="p_context"> static int __meminit vmemmap_populate_hugepages(unsigned long start,</span>
 		if (pmd_none(*pmd)) {
 			void *p;
 
<span class="p_del">-			p = vmemmap_alloc_block_buf(PMD_SIZE, node);</span>
<span class="p_add">+			p = vmemmap_alloc_block_buf(PMD_SIZE, node, altmap);</span>
 			if (p) {
 				pte_t entry;
 
<span class="p_chunk">@@ -1300,12 +1312,18 @@</span> <span class="p_context"> static int __meminit vmemmap_populate_hugepages(unsigned long start,</span>
 	return 0;
 }
 
<span class="p_del">-int __meminit vmemmap_populate(unsigned long start, unsigned long end, int node)</span>
<span class="p_add">+int __meminit __vmemmap_populate(unsigned long start, unsigned long end,</span>
<span class="p_add">+		int node, struct vmem_altmap *altmap)</span>
 {
 	int err;
 
<span class="p_add">+	if (!cpu_has_pse &amp;&amp; altmap) {</span>
<span class="p_add">+		pr_warn_once(&quot;vmemmap: alternate mapping not supported\n&quot;);</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (cpu_has_pse)
<span class="p_del">-		err = vmemmap_populate_hugepages(start, end, node);</span>
<span class="p_add">+		err = vmemmap_populate_hugepages(start, end, node, altmap);</span>
 	else
 		err = vmemmap_populate_basepages(start, end, node);
 	if (!err)
<span class="p_chunk">@@ -1313,6 +1331,11 @@</span> <span class="p_context"> int __meminit vmemmap_populate(unsigned long start, unsigned long end, int node)</span>
 	return err;
 }
 
<span class="p_add">+int __meminit vmemmap_populate(unsigned long start, unsigned long end, int node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __vmemmap_populate(start, end, node, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) &amp;&amp; defined(CONFIG_HAVE_BOOTMEM_INFO_NODE)
 void register_page_bootmem_memmap(unsigned long section_nr,
 				  struct page *start_page, unsigned long size)
<span class="p_header">diff --git a/include/linux/memory_hotplug.h b/include/linux/memory_hotplug.h</span>
<span class="p_header">index 6ffa0ac7f7d6..48a4e0a5e13d 100644</span>
<span class="p_header">--- a/include/linux/memory_hotplug.h</span>
<span class="p_header">+++ b/include/linux/memory_hotplug.h</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"> struct zone;</span>
 struct pglist_data;
 struct mem_section;
 struct memory_block;
<span class="p_add">+struct vmem_altmap;</span>
 
 #ifdef CONFIG_MEMORY_HOTPLUG
 
<span class="p_chunk">@@ -101,6 +102,8 @@</span> <span class="p_context"> extern int try_online_node(int nid);</span>
 #ifdef CONFIG_MEMORY_HOTREMOVE
 extern bool is_pageblock_removable_nolock(struct page *page);
 extern int arch_remove_memory(u64 start, u64 size);
<span class="p_add">+extern int __remove_pages_altmap(struct zone *zone, unsigned long start_pfn,</span>
<span class="p_add">+	unsigned long nr_pages, struct vmem_altmap *altmap);</span>
 extern int __remove_pages(struct zone *zone, unsigned long start_pfn,
 	unsigned long nr_pages);
 #endif /* CONFIG_MEMORY_HOTREMOVE */
<span class="p_chunk">@@ -109,6 +112,14 @@</span> <span class="p_context"> extern int __remove_pages(struct zone *zone, unsigned long start_pfn,</span>
 extern int __add_pages(int nid, struct zone *zone, unsigned long start_pfn,
 	unsigned long nr_pages);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Specialized interface for callers that want to control the allocation</span>
<span class="p_add">+ * of the memmap</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern int __add_pages_altmap(int nid, struct zone *zone,</span>
<span class="p_add">+		unsigned long start_pfn, unsigned long nr_pages,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_NUMA
 extern int memory_add_physaddr_to_nid(u64 start);
 #else
<span class="p_chunk">@@ -271,8 +282,10 @@</span> <span class="p_context"> extern int arch_add_memory(int nid, u64 start, u64 size);</span>
 extern int offline_pages(unsigned long start_pfn, unsigned long nr_pages);
 extern bool is_memblock_offlined(struct memory_block *mem);
 extern void remove_memory(int nid, u64 start, u64 size);
<span class="p_del">-extern int sparse_add_one_section(struct zone *zone, unsigned long start_pfn);</span>
<span class="p_del">-extern void sparse_remove_one_section(struct zone *zone, struct mem_section *ms);</span>
<span class="p_add">+extern int sparse_add_one_section(struct zone *zone, unsigned long start_pfn,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
<span class="p_add">+extern void sparse_remove_one_section(struct zone *zone, struct mem_section *ms,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
 extern struct page *sparse_decode_mem_map(unsigned long coded_mem_map,
 					  unsigned long pnum);
 
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 348f69467f54..de44de70e63a 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1827,6 +1827,9 @@</span> <span class="p_context"> extern int __meminit __early_pfn_to_nid(unsigned long pfn,</span>
 extern void set_dma_reserve(unsigned long new_dma_reserve);
 extern void memmap_init_zone(unsigned long, int, unsigned long,
 				unsigned long, enum memmap_context);
<span class="p_add">+extern void __memmap_init_zone(unsigned long, int, unsigned long, unsigned long,</span>
<span class="p_add">+		enum memmap_context context, struct vmem_altmap *);</span>
<span class="p_add">+</span>
 extern void setup_per_zone_wmarks(void);
 extern int __meminit init_per_zone_wmark_min(void);
 extern void mem_init(void);
<span class="p_chunk">@@ -2212,20 +2215,28 @@</span> <span class="p_context"> void sparse_mem_maps_populate_node(struct page **map_map,</span>
 				   unsigned long map_count,
 				   int nodeid);
 
<span class="p_add">+struct vmem_altmap;</span>
 struct page *sparse_mem_map_populate(unsigned long pnum, int nid);
<span class="p_add">+struct page *sparse_alt_map_populate(unsigned long pnum, int nid,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
 pgd_t *vmemmap_pgd_populate(unsigned long addr, int node);
 pud_t *vmemmap_pud_populate(pgd_t *pgd, unsigned long addr, int node);
 pmd_t *vmemmap_pmd_populate(pud_t *pud, unsigned long addr, int node);
 pte_t *vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node);
 void *vmemmap_alloc_block(unsigned long size, int node);
<span class="p_del">-void *vmemmap_alloc_block_buf(unsigned long size, int node);</span>
<span class="p_add">+void *vmemmap_alloc_block_buf(unsigned long size, int node,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
 void vmemmap_verify(pte_t *, int, unsigned long, unsigned long);
 int vmemmap_populate_basepages(unsigned long start, unsigned long end,
 			       int node);
<span class="p_add">+int __vmemmap_populate(unsigned long start, unsigned long end, int node,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
 int vmemmap_populate(unsigned long start, unsigned long end, int node);
 void vmemmap_populate_print_last(void);
 #ifdef CONFIG_MEMORY_HOTPLUG
 void vmemmap_free(unsigned long start, unsigned long end);
<span class="p_add">+void __vmemmap_free(unsigned long start, unsigned long end,</span>
<span class="p_add">+		struct vmem_altmap *altmap);</span>
 #endif
 void register_page_bootmem_memmap(unsigned long section_nr, struct page *map,
 				  unsigned long size);
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 6bc5b755ce98..d4bcfeaaec37 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -440,7 +440,8 @@</span> <span class="p_context"> static void __meminit grow_pgdat_span(struct pglist_data *pgdat, unsigned long s</span>
 					pgdat-&gt;node_start_pfn;
 }
 
<span class="p_del">-static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)</span>
<span class="p_add">+static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	struct pglist_data *pgdat = zone-&gt;zone_pgdat;
 	int nr_pages = PAGES_PER_SECTION;
<span class="p_chunk">@@ -459,25 +460,26 @@</span> <span class="p_context"> static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)</span>
 	grow_pgdat_span(zone-&gt;zone_pgdat, phys_start_pfn,
 			phys_start_pfn + nr_pages);
 	pgdat_resize_unlock(zone-&gt;zone_pgdat, &amp;flags);
<span class="p_del">-	memmap_init_zone(nr_pages, nid, zone_type,</span>
<span class="p_del">-			 phys_start_pfn, MEMMAP_HOTPLUG);</span>
<span class="p_add">+	__memmap_init_zone(nr_pages, nid, zone_type,</span>
<span class="p_add">+			 phys_start_pfn, MEMMAP_HOTPLUG, altmap);</span>
 	return 0;
 }
 
 static int __meminit __add_section(int nid, struct zone *zone,
<span class="p_del">-					unsigned long phys_start_pfn)</span>
<span class="p_add">+		unsigned long phys_start_pfn,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	int ret;
 
 	if (pfn_valid(phys_start_pfn))
 		return -EEXIST;
 
<span class="p_del">-	ret = sparse_add_one_section(zone, phys_start_pfn);</span>
<span class="p_add">+	ret = sparse_add_one_section(zone, phys_start_pfn, altmap);</span>
 
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	ret = __add_zone(zone, phys_start_pfn);</span>
<span class="p_add">+	ret = __add_zone(zone, phys_start_pfn, altmap);</span>
 
 	if (ret &lt; 0)
 		return ret;
<span class="p_chunk">@@ -491,18 +493,20 @@</span> <span class="p_context"> static int __meminit __add_section(int nid, struct zone *zone,</span>
  * call this function after deciding the zone to which to
  * add the new pages.
  */
<span class="p_del">-int __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_del">-			unsigned long nr_pages)</span>
<span class="p_add">+int __ref __add_pages_altmap(int nid, struct zone *zone,</span>
<span class="p_add">+		unsigned long phys_start_pfn, unsigned long nr_pages,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long i;
 	int err = 0;
 	int start_sec, end_sec;
<span class="p_add">+</span>
 	/* during initialize mem_map, align hot-added range to section */
 	start_sec = pfn_to_section_nr(phys_start_pfn);
 	end_sec = pfn_to_section_nr(phys_start_pfn + nr_pages - 1);
 
 	for (i = start_sec; i &lt;= end_sec; i++) {
<span class="p_del">-		err = __add_section(nid, zone, section_nr_to_pfn(i));</span>
<span class="p_add">+		err = __add_section(nid, zone, section_nr_to_pfn(i), altmap);</span>
 
 		/*
 		 * EEXIST is finally dealt with by ioresource collision
<span class="p_chunk">@@ -517,6 +521,12 @@</span> <span class="p_context"> int __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,</span>
 
 	return err;
 }
<span class="p_add">+</span>
<span class="p_add">+int __ref __add_pages(int nid, struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_add">+			unsigned long nr_pages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __add_pages_altmap(nid, zone, phys_start_pfn, nr_pages, NULL);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(__add_pages);
 
 #ifdef CONFIG_MEMORY_HOTREMOVE
<span class="p_chunk">@@ -722,7 +732,8 @@</span> <span class="p_context"> static void __remove_zone(struct zone *zone, unsigned long start_pfn)</span>
 	pgdat_resize_unlock(zone-&gt;zone_pgdat, &amp;flags);
 }
 
<span class="p_del">-static int __remove_section(struct zone *zone, struct mem_section *ms)</span>
<span class="p_add">+static int __remove_section(struct zone *zone, struct mem_section *ms,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long start_pfn;
 	int scn_nr;
<span class="p_chunk">@@ -739,23 +750,12 @@</span> <span class="p_context"> static int __remove_section(struct zone *zone, struct mem_section *ms)</span>
 	start_pfn = section_nr_to_pfn(scn_nr);
 	__remove_zone(zone, start_pfn);
 
<span class="p_del">-	sparse_remove_one_section(zone, ms);</span>
<span class="p_add">+	sparse_remove_one_section(zone, ms, altmap);</span>
 	return 0;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * __remove_pages() - remove sections of pages from a zone</span>
<span class="p_del">- * @zone: zone from which pages need to be removed</span>
<span class="p_del">- * @phys_start_pfn: starting pageframe (must be aligned to start of a section)</span>
<span class="p_del">- * @nr_pages: number of pages to remove (must be multiple of section size)</span>
<span class="p_del">- *</span>
<span class="p_del">- * Generic helper function to remove section mappings and sysfs entries</span>
<span class="p_del">- * for the section of the memory we are removing. Caller needs to make</span>
<span class="p_del">- * sure that pages are marked reserved and zones are adjust properly by</span>
<span class="p_del">- * calling offline_pages().</span>
<span class="p_del">- */</span>
<span class="p_del">-int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_del">-		 unsigned long nr_pages)</span>
<span class="p_add">+int __remove_pages_altmap(struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_add">+		 unsigned long nr_pages, struct vmem_altmap *altmap)</span>
 {
 	unsigned long i;
 	int sections_to_remove;
<span class="p_chunk">@@ -784,12 +784,29 @@</span> <span class="p_context"> int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,</span>
 	sections_to_remove = nr_pages / PAGES_PER_SECTION;
 	for (i = 0; i &lt; sections_to_remove; i++) {
 		unsigned long pfn = phys_start_pfn + i*PAGES_PER_SECTION;
<span class="p_del">-		ret = __remove_section(zone, __pfn_to_section(pfn));</span>
<span class="p_add">+		ret = __remove_section(zone, __pfn_to_section(pfn), altmap);</span>
 		if (ret)
 			break;
 	}
 	return ret;
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * __remove_pages() - remove sections of pages from a zone</span>
<span class="p_add">+ * @zone: zone from which pages need to be removed</span>
<span class="p_add">+ * @phys_start_pfn: starting pageframe (must be aligned to start of a section)</span>
<span class="p_add">+ * @nr_pages: number of pages to remove (must be multiple of section size)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Generic helper function to remove section mappings and sysfs entries</span>
<span class="p_add">+ * for the section of the memory we are removing. Caller needs to make</span>
<span class="p_add">+ * sure that pages are marked reserved and zones are adjust properly by</span>
<span class="p_add">+ * calling offline_pages().</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __remove_pages(struct zone *zone, unsigned long phys_start_pfn,</span>
<span class="p_add">+		 unsigned long nr_pages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __remove_pages_altmap(zone, phys_start_pfn, nr_pages, NULL);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(__remove_pages);
 #endif /* CONFIG_MEMORY_HOTREMOVE */
 
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 0f19b4e18233..c18520831dbc 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -4577,8 +4577,9 @@</span> <span class="p_context"> static void setup_zone_migrate_reserve(struct zone *zone)</span>
  * up by free_all_bootmem() once the early boot process is
  * done. Non-atomic initialization, single-pass.
  */
<span class="p_del">-void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,</span>
<span class="p_del">-		unsigned long start_pfn, enum memmap_context context)</span>
<span class="p_add">+void __meminit __memmap_init_zone(unsigned long size, int nid,</span>
<span class="p_add">+		unsigned long zone, unsigned long start_pfn,</span>
<span class="p_add">+		enum memmap_context context, struct vmem_altmap *altmap)</span>
 {
 	pg_data_t *pgdat = NODE_DATA(nid);
 	unsigned long end_pfn = start_pfn + size;
<span class="p_chunk">@@ -4631,6 +4632,12 @@</span> <span class="p_context"> void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,</span>
 	}
 }
 
<span class="p_add">+void __meminit memmap_init_zone(unsigned long size, int nid, unsigned long zone,</span>
<span class="p_add">+		unsigned long start_pfn, enum memmap_context context)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __memmap_init_zone(size, nid, zone, start_pfn, context, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __meminit zone_init_free_lists(struct zone *zone)
 {
 	unsigned int order, t;
<span class="p_header">diff --git a/mm/sparse-vmemmap.c b/mm/sparse-vmemmap.c</span>
<span class="p_header">index 4cba9c2783a1..16ec1675b793 100644</span>
<span class="p_header">--- a/mm/sparse-vmemmap.c</span>
<span class="p_header">+++ b/mm/sparse-vmemmap.c</span>
<span class="p_chunk">@@ -69,8 +69,7 @@</span> <span class="p_context"> void * __meminit vmemmap_alloc_block(unsigned long size, int node)</span>
 				__pa(MAX_DMA_ADDRESS));
 }
 
<span class="p_del">-/* need to make sure size is all the same during early stage */</span>
<span class="p_del">-void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node)</span>
<span class="p_add">+static void * __meminit __vmemmap_alloc_block_buf(unsigned long size, int node)</span>
 {
 	void *ptr;
 
<span class="p_chunk">@@ -87,6 +86,13 @@</span> <span class="p_context"> void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node)</span>
 	return ptr;
 }
 
<span class="p_add">+/* need to make sure size is all the same during early stage */</span>
<span class="p_add">+void * __meminit vmemmap_alloc_block_buf(unsigned long size, int node,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __vmemmap_alloc_block_buf(size, node);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __meminit vmemmap_verify(pte_t *pte, int node,
 				unsigned long start, unsigned long end)
 {
<span class="p_chunk">@@ -103,7 +109,7 @@</span> <span class="p_context"> pte_t * __meminit vmemmap_pte_populate(pmd_t *pmd, unsigned long addr, int node)</span>
 	pte_t *pte = pte_offset_kernel(pmd, addr);
 	if (pte_none(*pte)) {
 		pte_t entry;
<span class="p_del">-		void *p = vmemmap_alloc_block_buf(PAGE_SIZE, node);</span>
<span class="p_add">+		void *p = __vmemmap_alloc_block_buf(PAGE_SIZE, node);</span>
 		if (!p)
 			return NULL;
 		entry = pfn_pte(__pa(p) &gt;&gt; PAGE_SHIFT, PAGE_KERNEL);
<span class="p_chunk">@@ -176,7 +182,15 @@</span> <span class="p_context"> int __meminit vmemmap_populate_basepages(unsigned long start,</span>
 	return 0;
 }
 
<span class="p_del">-struct page * __meminit sparse_mem_map_populate(unsigned long pnum, int nid)</span>
<span class="p_add">+__weak int __vmemmap_populate(unsigned long start, unsigned long end, int node,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_warn_once(&quot;%s: arch does not support vmem_altmap\n&quot;, __func__);</span>
<span class="p_add">+	return -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct page * __meminit sparse_alt_map_populate(unsigned long pnum, int nid,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long start;
 	unsigned long end;
<span class="p_chunk">@@ -186,12 +200,17 @@</span> <span class="p_context"> struct page * __meminit sparse_mem_map_populate(unsigned long pnum, int nid)</span>
 	start = (unsigned long)map;
 	end = (unsigned long)(map + PAGES_PER_SECTION);
 
<span class="p_del">-	if (vmemmap_populate(start, end, nid))</span>
<span class="p_add">+	if (__vmemmap_populate(start, end, nid, altmap))</span>
 		return NULL;
 
 	return map;
 }
 
<span class="p_add">+struct page * __meminit sparse_mem_map_populate(unsigned long pnum, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sparse_alt_map_populate(pnum, nid, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init sparse_mem_maps_populate_node(struct page **map_map,
 					  unsigned long pnum_begin,
 					  unsigned long pnum_end,
<span class="p_header">diff --git a/mm/sparse.c b/mm/sparse.c</span>
<span class="p_header">index d1b48b691ac8..eda783903b1d 100644</span>
<span class="p_header">--- a/mm/sparse.c</span>
<span class="p_header">+++ b/mm/sparse.c</span>
<span class="p_chunk">@@ -595,17 +595,19 @@</span> <span class="p_context"> void __init sparse_init(void)</span>
 
 #ifdef CONFIG_MEMORY_HOTPLUG
 #ifdef CONFIG_SPARSEMEM_VMEMMAP
<span class="p_del">-static inline struct page *kmalloc_section_memmap(unsigned long pnum, int nid)</span>
<span class="p_add">+static struct page *alloc_section_memmap(unsigned long pnum, int nid,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
<span class="p_del">-	/* This will make the necessary allocations eventually. */</span>
 	return sparse_mem_map_populate(pnum, nid);
 }
<span class="p_del">-static void __kfree_section_memmap(struct page *memmap)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void free_section_memmap(struct page *memmap,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long start = (unsigned long)memmap;
 	unsigned long end = (unsigned long)(memmap + PAGES_PER_SECTION);
 
<span class="p_del">-	vmemmap_free(start, end);</span>
<span class="p_add">+	__vmemmap_free(start, end, NULL);</span>
 }
 #ifdef CONFIG_MEMORY_HOTREMOVE
 static void free_map_bootmem(struct page *memmap)
<span class="p_chunk">@@ -690,7 +692,8 @@</span> <span class="p_context"> static void free_map_bootmem(struct page *memmap)</span>
  * set.  If this is &lt;=0, then that means that the passed-in
  * map was not consumed and must be freed.
  */
<span class="p_del">-int __meminit sparse_add_one_section(struct zone *zone, unsigned long start_pfn)</span>
<span class="p_add">+int __meminit sparse_add_one_section(struct zone *zone, unsigned long start_pfn,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	unsigned long section_nr = pfn_to_section_nr(start_pfn);
 	struct pglist_data *pgdat = zone-&gt;zone_pgdat;
<span class="p_chunk">@@ -707,12 +710,12 @@</span> <span class="p_context"> int __meminit sparse_add_one_section(struct zone *zone, unsigned long start_pfn)</span>
 	ret = sparse_index_init(section_nr, pgdat-&gt;node_id);
 	if (ret &lt; 0 &amp;&amp; ret != -EEXIST)
 		return ret;
<span class="p_del">-	memmap = kmalloc_section_memmap(section_nr, pgdat-&gt;node_id);</span>
<span class="p_add">+	memmap = alloc_section_memmap(section_nr, pgdat-&gt;node_id, altmap);</span>
 	if (!memmap)
 		return -ENOMEM;
 	usemap = __kmalloc_section_usemap();
 	if (!usemap) {
<span class="p_del">-		__kfree_section_memmap(memmap);</span>
<span class="p_add">+		free_section_memmap(memmap, altmap);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -734,7 +737,7 @@</span> <span class="p_context"> out:</span>
 	pgdat_resize_unlock(pgdat, &amp;flags);
 	if (ret &lt;= 0) {
 		kfree(usemap);
<span class="p_del">-		__kfree_section_memmap(memmap);</span>
<span class="p_add">+		free_section_memmap(memmap, altmap);</span>
 	}
 	return ret;
 }
<span class="p_chunk">@@ -761,7 +764,8 @@</span> <span class="p_context"> static inline void clear_hwpoisoned_pages(struct page *memmap, int nr_pages)</span>
 }
 #endif
 
<span class="p_del">-static void free_section_usemap(struct page *memmap, unsigned long *usemap)</span>
<span class="p_add">+static void free_section_usemap(struct page *memmap, unsigned long *usemap,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	struct page *usemap_page;
 
<span class="p_chunk">@@ -775,7 +779,7 @@</span> <span class="p_context"> static void free_section_usemap(struct page *memmap, unsigned long *usemap)</span>
 	if (PageSlab(usemap_page) || PageCompound(usemap_page)) {
 		kfree(usemap);
 		if (memmap)
<span class="p_del">-			__kfree_section_memmap(memmap);</span>
<span class="p_add">+			free_section_memmap(memmap, altmap);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -788,7 +792,8 @@</span> <span class="p_context"> static void free_section_usemap(struct page *memmap, unsigned long *usemap)</span>
 		free_map_bootmem(memmap);
 }
 
<span class="p_del">-void sparse_remove_one_section(struct zone *zone, struct mem_section *ms)</span>
<span class="p_add">+void sparse_remove_one_section(struct zone *zone, struct mem_section *ms,</span>
<span class="p_add">+		struct vmem_altmap *altmap)</span>
 {
 	struct page *memmap = NULL;
 	unsigned long *usemap = NULL, flags;
<span class="p_chunk">@@ -805,7 +810,7 @@</span> <span class="p_context"> void sparse_remove_one_section(struct zone *zone, struct mem_section *ms)</span>
 	pgdat_resize_unlock(pgdat, &amp;flags);
 
 	clear_hwpoisoned_pages(memmap, PAGES_PER_SECTION);
<span class="p_del">-	free_section_usemap(memmap, usemap);</span>
<span class="p_add">+	free_section_usemap(memmap, usemap, altmap);</span>
 }
 #endif /* CONFIG_MEMORY_HOTREMOVE */
 #endif /* CONFIG_MEMORY_HOTPLUG */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



