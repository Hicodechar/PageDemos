
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[-v2] x86/hweight: Get rid of the special calling convention - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [-v2] x86/hweight: Get rid of the special calling convention</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 12, 2016, 11:57 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160512115738.GB10056@pd.tnic&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9079691/mbox/"
   >mbox</a>
|
   <a href="/patch/9079691/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9079691/">/patch/9079691/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 93C5CBF29F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 May 2016 11:57:53 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id E47902021A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 May 2016 11:57:51 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id DD91F2021B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 12 May 2016 11:57:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752972AbcELL5q (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 12 May 2016 07:57:46 -0400
Received: from mx2.suse.de ([195.135.220.15]:54983 &quot;EHLO mx2.suse.de&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752456AbcELL5o (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 12 May 2016 07:57:44 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay1.suse.de (charybdis-ext.suse.de [195.135.220.254])
	by mx2.suse.de (Postfix) with ESMTP id D0F23AD8C;
	Thu, 12 May 2016 11:57:42 +0000 (UTC)
Received: by pd.tnic (Postfix, from userid 1000)
	id 6EBC51605B2; Thu, 12 May 2016 13:57:38 +0200 (CEST)
Date: Thu, 12 May 2016 13:57:38 +0200
From: Borislav Petkov &lt;bp@suse.de&gt;
To: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;,
	Brian Gerst &lt;brgerst@gmail.com&gt;, x86-ml &lt;x86@kernel.org&gt;,
	Denys Vlasenko &lt;dvlasenk@redhat.com&gt;,
	LKML &lt;linux-kernel@vger.kernel.org&gt;, Dmitry Vyukov &lt;dvyukov@google.com&gt;,
	Andi Kleen &lt;andi@firstfloor.org&gt;, zengzhaoxiu@163.com,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, Zhaoxiu Zeng &lt;zhaoxiu.zeng@gmail.com&gt;,
	Andy Lutomirski &lt;luto@amacapital.net&gt;
Subject: Re: [PATCH -v2] x86/hweight: Get rid of the special calling
	convention
Message-ID: &lt;20160512115738.GB10056@pd.tnic&gt;
References: &lt;20160505140446.GE534@pd.tnic&gt; &lt;20160510165318.GD28520@pd.tnic&gt;
	&lt;20160510172313.GA3192@twins.programming.kicks-ass.net&gt;
	&lt;8FE6169B-4F2E-4B7D-A271-14FEC245F663@zytor.com&gt;
	&lt;20160510191041.GI28520@pd.tnic&gt;
	&lt;ca79a89a-7240-8572-1688-ec5506c12665@zytor.com&gt;
	&lt;20160511041128.GA2180@pd.tnic&gt;
	&lt;CAMzpN2hm3WO5-jO44Wp4u+jyeVeke_MRgdoQZOFUv0qAEu6OSg@mail.gmail.com&gt;
	&lt;20160511112409.GE3190@twins.programming.kicks-ass.net&gt;
	&lt;B403FEFA-78F7-4D8F-A46C-E5174527D79E@zytor.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;B403FEFA-78F7-4D8F-A46C-E5174527D79E@zytor.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - May 12, 2016, 11:57 a.m.</div>
<pre class="content">
On Wed, May 11, 2016 at 09:54:50PM -0700, H. Peter Anvin wrote:
<span class="quote">&gt; I was thinking it isn&#39;t really very complex code even in assembly as</span>
<span class="quote">&gt; it is super-regular; you can even crib the gcc-generated code if you</span>
<span class="quote">&gt; wish.</span>

Do I wanna do experiments in asm? Always! :-)

Ok, so I did steal gcc -m32 -O3 output because there it uses only one
additional register. So how about this (only __sw_hweight32 today):

#ifdef CONFIG_X86_32
# define PUSH_DX        &quot;pushl %%edx\n\t&quot;
# define POP_DX         &quot;popl %%edx\n\t&quot;
#else
# define PUSH_DX        &quot;pushq %%rdx\n\t&quot;
# define POP_DX         &quot;popq %%rdx\n\t&quot;
#endif

unsigned int __sw_hweight32(unsigned int w)
{
        asm volatile(PUSH_DX
                     &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */
                     &quot;shrl %%edx\n\t&quot;                           /* t &gt;&gt; 1 */
                     &quot;andl $0x55555555, %%edx\n\t&quot;              /* t &amp; 0x55555555 */
                     &quot;subl %%edx, %[w]\n&quot;                       /* w -= t */
                     &quot;\n\t&quot;
                     &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */
                     &quot;shrl $2, %[w]\n\t&quot;                        /* w_tmp &gt;&gt; 2 */
                     &quot;andl $0x33333333, %%edx\n\t&quot;              /* t &amp; 0x33333333 */
                     &quot;andl $0x33333333, %[w]\n\t&quot;               /* w_tmp &amp; 0x33333333 */
                     &quot;addl %%edx, %[w]\n&quot;                       /* w = w_tmp + t */
                     &quot;\n\t&quot;
                     &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */
                     &quot;shrl $4, %%edx\n\t&quot;                       /* t &gt;&gt; 4 */
                     &quot;addl %%edx, %[w]\n\t&quot;                     /* w_tmp += t */
                     &quot;andl  $0x0f0f0f0f, %[w]\n\t&quot;              /* w_tmp &amp;= 0x0f0f0f0f */
                     &quot;imull $0x01010101, %[w], %[w]\n\t&quot;        /* w_tmp *= 0x01010101 */
                     &quot;shrl $24, %[w]\n\t&quot;                       /* w = w_tmp &gt;&gt; 24 */
                     POP_DX
                     : [w] &quot;+r&quot; (w));

        return w;
}

I&#39;ve chosen rDX as a temp because gcc takes that one but it doesn&#39;t
matter which - we&#39;re stashing it.

And then we rely on gcc to figure out which reg to use for w. It ends up
using rAX as that is the return reg which fits nicely with our intention
of returning POPCNT values in rAX.

I&#39;m guessing we can just as well write %%rax in the asm because we&#39;re
returning that value and that&#39;s ABI.

Generated asm looks ok, only on 64-bit it does one

	movl    %edi, %eax      # w, w

before the inline asm in order to stick w in rAX.

Complaints?

Full diff:

---
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - May 12, 2016, 12:14 p.m.</div>
<pre class="content">
On Thu, May 12, 2016 at 01:57:38PM +0200, Borislav Petkov wrote:
<span class="quote">&gt; #ifdef CONFIG_X86_32</span>
<span class="quote">&gt; # define PUSH_DX        &quot;pushl %%edx\n\t&quot;</span>
<span class="quote">&gt; # define POP_DX         &quot;popl %%edx\n\t&quot;</span>
<span class="quote">&gt; #else</span>
<span class="quote">&gt; # define PUSH_DX        &quot;pushq %%rdx\n\t&quot;</span>
<span class="quote">&gt; # define POP_DX         &quot;popq %%rdx\n\t&quot;</span>
<span class="quote">&gt; #endif</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; unsigned int __sw_hweight32(unsigned int w)</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt;         asm volatile(PUSH_DX</span>
<span class="quote">&gt;                      &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */</span>
<span class="quote">&gt;                      &quot;shrl %%edx\n\t&quot;                           /* t &gt;&gt; 1 */</span>
<span class="quote">&gt;                      &quot;andl $0x55555555, %%edx\n\t&quot;              /* t &amp; 0x55555555 */</span>
<span class="quote">&gt;                      &quot;subl %%edx, %[w]\n&quot;                       /* w -= t */</span>
<span class="quote">&gt;                      &quot;\n\t&quot;</span>
<span class="quote">&gt;                      &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */</span>
<span class="quote">&gt;                      &quot;shrl $2, %[w]\n\t&quot;                        /* w_tmp &gt;&gt; 2 */</span>
<span class="quote">&gt;                      &quot;andl $0x33333333, %%edx\n\t&quot;              /* t &amp; 0x33333333 */</span>
<span class="quote">&gt;                      &quot;andl $0x33333333, %[w]\n\t&quot;               /* w_tmp &amp; 0x33333333 */</span>
<span class="quote">&gt;                      &quot;addl %%edx, %[w]\n&quot;                       /* w = w_tmp + t */</span>
<span class="quote">&gt;                      &quot;\n\t&quot;</span>
<span class="quote">&gt;                      &quot;movl %[w], %%edx\n\t&quot;                     /* w -&gt; t */</span>
<span class="quote">&gt;                      &quot;shrl $4, %%edx\n\t&quot;                       /* t &gt;&gt; 4 */</span>
<span class="quote">&gt;                      &quot;addl %%edx, %[w]\n\t&quot;                     /* w_tmp += t */</span>
<span class="quote">&gt;                      &quot;andl  $0x0f0f0f0f, %[w]\n\t&quot;              /* w_tmp &amp;= 0x0f0f0f0f */</span>
<span class="quote">&gt;                      &quot;imull $0x01010101, %[w], %[w]\n\t&quot;        /* w_tmp *= 0x01010101 */</span>
<span class="quote">&gt;                      &quot;shrl $24, %[w]\n\t&quot;                       /* w = w_tmp &gt;&gt; 24 */</span>
<span class="quote">&gt;                      POP_DX</span>
<span class="quote">&gt;                      : [w] &quot;+r&quot; (w));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;         return w;</span>
<span class="quote">&gt; }</span>

But this is a C function, with C calling convention. You&#39;re now assuming
GCC doesn&#39;t clobber anything with its prologue/epilogue.

I think hpa meant to put it in an .S file and avoid all that.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - May 12, 2016, 1:09 p.m.</div>
<pre class="content">
On Thu, May 12, 2016 at 02:14:52PM +0200, Peter Zijlstra wrote:
<span class="quote">&gt; But this is a C function, with C calling convention. You&#39;re now assuming</span>
<span class="quote">&gt; GCC doesn&#39;t clobber anything with its prologue/epilogue.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think hpa meant to put it in an .S file and avoid all that.</span>

I wanted to have gcc use %[w] and this way not hardcode the reg but the
ABI kinda hardcodes it to rAX. And you&#39;re right about tracing funkyness
adding glue so we&#39;re probably better off doing the .S thing directly and
making it more robust this way.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 7bb15747fea2..79e0bcd61cb1 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -292,11 +292,6 @@</span> <span class="p_context"> config X86_32_LAZY_GS</span>
 	def_bool y
 	depends on X86_32 &amp;&amp; !CC_STACKPROTECTOR
 
<span class="p_del">-config ARCH_HWEIGHT_CFLAGS</span>
<span class="p_del">-	string</span>
<span class="p_del">-	default &quot;-fcall-saved-ecx -fcall-saved-edx&quot; if X86_32</span>
<span class="p_del">-	default &quot;-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11&quot; if X86_64</span>
<span class="p_del">-</span>
 config ARCH_SUPPORTS_UPROBES
 	def_bool y
 
<span class="p_header">diff --git a/arch/x86/include/asm/arch_hweight.h b/arch/x86/include/asm/arch_hweight.h</span>
<span class="p_header">index 02e799fa43d1..7dd97eaba67d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/arch_hweight.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/arch_hweight.h</span>
<span class="p_chunk">@@ -2,10 +2,11 @@</span> <span class="p_context"></span>
 #define _ASM_X86_HWEIGHT_H
 
 #include &lt;asm/cpufeatures.h&gt;
<span class="p_add">+#include &lt;asm/static_cpu_has.h&gt;</span>
 
 #ifdef CONFIG_64BIT
<span class="p_del">-/* popcnt %edi, %eax -- redundant REX prefix for alignment */</span>
<span class="p_del">-#define POPCNT32 &quot;.byte 0xf3,0x40,0x0f,0xb8,0xc7&quot;</span>
<span class="p_add">+/* popcnt %edi, %eax */</span>
<span class="p_add">+#define POPCNT32 &quot;.byte 0xf3,0x0f,0xb8,0xc7&quot;</span>
 /* popcnt %rdi, %rax */
 #define POPCNT64 &quot;.byte 0xf3,0x48,0x0f,0xb8,0xc7&quot;
 #define REG_IN &quot;D&quot;
<span class="p_chunk">@@ -17,19 +18,15 @@</span> <span class="p_context"></span>
 #define REG_OUT &quot;a&quot;
 #endif
 
<span class="p_del">-/*</span>
<span class="p_del">- * __sw_hweightXX are called from within the alternatives below</span>
<span class="p_del">- * and callee-clobbered registers need to be taken care of. See</span>
<span class="p_del">- * ARCH_HWEIGHT_CFLAGS in &lt;arch/x86/Kconfig&gt; for the respective</span>
<span class="p_del">- * compiler switches.</span>
<span class="p_del">- */</span>
<span class="p_add">+#define __HAVE_ARCH_SW_HWEIGHT</span>
<span class="p_add">+</span>
 static __always_inline unsigned int __arch_hweight32(unsigned int w)
 {
<span class="p_del">-	unsigned int res = 0;</span>
<span class="p_add">+	unsigned int res;</span>
 
 	asm (ALTERNATIVE(&quot;call __sw_hweight32&quot;, POPCNT32, X86_FEATURE_POPCNT)
<span class="p_del">-		     : &quot;=&quot;REG_OUT (res)</span>
<span class="p_del">-		     : REG_IN (w));</span>
<span class="p_add">+			: &quot;=&quot;REG_OUT (res)</span>
<span class="p_add">+			: REG_IN (w));</span>
 
 	return res;
 }
<span class="p_chunk">@@ -53,13 +50,16 @@</span> <span class="p_context"> static inline unsigned long __arch_hweight64(__u64 w)</span>
 #else
 static __always_inline unsigned long __arch_hweight64(__u64 w)
 {
<span class="p_del">-	unsigned long res = 0;</span>
<span class="p_add">+	unsigned long res;</span>
 
<span class="p_del">-	asm (ALTERNATIVE(&quot;call __sw_hweight64&quot;, POPCNT64, X86_FEATURE_POPCNT)</span>
<span class="p_del">-		     : &quot;=&quot;REG_OUT (res)</span>
<span class="p_del">-		     : REG_IN (w));</span>
<span class="p_add">+	if (likely(static_cpu_has(X86_FEATURE_POPCNT))) {</span>
<span class="p_add">+		asm volatile(POPCNT64</span>
<span class="p_add">+				: &quot;=&quot;REG_OUT (res)</span>
<span class="p_add">+				: REG_IN (w));</span>
 
<span class="p_del">-	return res;</span>
<span class="p_add">+		return res;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return __sw_hweight64(w);</span>
 }
 #endif /* CONFIG_X86_32 */
 
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeature.h b/arch/x86/include/asm/cpufeature.h</span>
<span class="p_header">index 07c942d84662..9a70b12ae8df 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeature.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeature.h</span>
<span class="p_chunk">@@ -6,6 +6,8 @@</span> <span class="p_context"></span>
 #if defined(__KERNEL__) &amp;&amp; !defined(__ASSEMBLY__)
 
 #include &lt;asm/asm.h&gt;
<span class="p_add">+#include &lt;asm/static_cpu_has.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;linux/bitops.h&gt;
 
 enum cpuid_leafs
<span class="p_chunk">@@ -45,51 +47,6 @@</span> <span class="p_context"> extern const char * const x86_power_flags[32];</span>
  */
 extern const char * const x86_bug_flags[NBUGINTS*32];
 
<span class="p_del">-#define test_cpu_cap(c, bit)						\</span>
<span class="p_del">-	 test_bit(bit, (unsigned long *)((c)-&gt;x86_capability))</span>
<span class="p_del">-</span>
<span class="p_del">-#define REQUIRED_MASK_BIT_SET(bit)					\</span>
<span class="p_del">-	 ( (((bit)&gt;&gt;5)==0  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK0 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==1  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK1 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==2  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK2 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==3  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK3 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==4  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK4 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==5  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK5 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==6  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK6 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==7  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK7 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==8  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK8 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==9  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK9 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==10 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK10)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==11 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK11)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==12 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK12)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK13)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK14)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK15)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==14 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK16)) )</span>
<span class="p_del">-</span>
<span class="p_del">-#define DISABLED_MASK_BIT_SET(bit)					\</span>
<span class="p_del">-	 ( (((bit)&gt;&gt;5)==0  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK0 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==1  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK1 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==2  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK2 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==3  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK3 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==4  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK4 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==5  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK5 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==6  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK6 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==7  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK7 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==8  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK8 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==9  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK9 )) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==10 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK10)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==11 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK11)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==12 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK12)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK13)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK14)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK15)) ||	\</span>
<span class="p_del">-	   (((bit)&gt;&gt;5)==14 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK16)) )</span>
<span class="p_del">-</span>
<span class="p_del">-#define cpu_has(c, bit)							\</span>
<span class="p_del">-	(__builtin_constant_p(bit) &amp;&amp; REQUIRED_MASK_BIT_SET(bit) ? 1 :	\</span>
<span class="p_del">-	 test_cpu_cap(c, bit))</span>
<span class="p_del">-</span>
 #define this_cpu_has(bit)						\
 	(__builtin_constant_p(bit) &amp;&amp; REQUIRED_MASK_BIT_SET(bit) ? 1 : 	\
 	 x86_this_cpu_test_bit(bit, (unsigned long *)&amp;cpu_info.x86_capability))
<span class="p_chunk">@@ -105,8 +62,6 @@</span> <span class="p_context"> extern const char * const x86_bug_flags[NBUGINTS*32];</span>
 #define cpu_feature_enabled(bit)	\
 	(__builtin_constant_p(bit) &amp;&amp; DISABLED_MASK_BIT_SET(bit) ? 0 : static_cpu_has(bit))
 
<span class="p_del">-#define boot_cpu_has(bit)	cpu_has(&amp;boot_cpu_data, bit)</span>
<span class="p_del">-</span>
 #define set_cpu_cap(c, bit)	set_bit(bit, (unsigned long *)((c)-&gt;x86_capability))
 #define clear_cpu_cap(c, bit)	clear_bit(bit, (unsigned long *)((c)-&gt;x86_capability))
 #define setup_clear_cpu_cap(bit) do { \
<span class="p_chunk">@@ -118,69 +73,6 @@</span> <span class="p_context"> extern const char * const x86_bug_flags[NBUGINTS*32];</span>
 	set_bit(bit, (unsigned long *)cpu_caps_set);	\
 } while (0)
 
<span class="p_del">-#if defined(CC_HAVE_ASM_GOTO) &amp;&amp; defined(CONFIG_X86_FAST_FEATURE_TESTS)</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Static testing of CPU features.  Used the same as boot_cpu_has().</span>
<span class="p_del">- * These will statically patch the target code for additional</span>
<span class="p_del">- * performance.</span>
<span class="p_del">- */</span>
<span class="p_del">-static __always_inline __pure bool _static_cpu_has(u16 bit)</span>
<span class="p_del">-{</span>
<span class="p_del">-		asm_volatile_goto(&quot;1: jmp 6f\n&quot;</span>
<span class="p_del">-			 &quot;2:\n&quot;</span>
<span class="p_del">-			 &quot;.skip -(((5f-4f) - (2b-1b)) &gt; 0) * &quot;</span>
<span class="p_del">-			         &quot;((5f-4f) - (2b-1b)),0x90\n&quot;</span>
<span class="p_del">-			 &quot;3:\n&quot;</span>
<span class="p_del">-			 &quot;.section .altinstructions,\&quot;a\&quot;\n&quot;</span>
<span class="p_del">-			 &quot; .long 1b - .\n&quot;		/* src offset */</span>
<span class="p_del">-			 &quot; .long 4f - .\n&quot;		/* repl offset */</span>
<span class="p_del">-			 &quot; .word %P1\n&quot;			/* always replace */</span>
<span class="p_del">-			 &quot; .byte 3b - 1b\n&quot;		/* src len */</span>
<span class="p_del">-			 &quot; .byte 5f - 4f\n&quot;		/* repl len */</span>
<span class="p_del">-			 &quot; .byte 3b - 2b\n&quot;		/* pad len */</span>
<span class="p_del">-			 &quot;.previous\n&quot;</span>
<span class="p_del">-			 &quot;.section .altinstr_replacement,\&quot;ax\&quot;\n&quot;</span>
<span class="p_del">-			 &quot;4: jmp %l[t_no]\n&quot;</span>
<span class="p_del">-			 &quot;5:\n&quot;</span>
<span class="p_del">-			 &quot;.previous\n&quot;</span>
<span class="p_del">-			 &quot;.section .altinstructions,\&quot;a\&quot;\n&quot;</span>
<span class="p_del">-			 &quot; .long 1b - .\n&quot;		/* src offset */</span>
<span class="p_del">-			 &quot; .long 0\n&quot;			/* no replacement */</span>
<span class="p_del">-			 &quot; .word %P0\n&quot;			/* feature bit */</span>
<span class="p_del">-			 &quot; .byte 3b - 1b\n&quot;		/* src len */</span>
<span class="p_del">-			 &quot; .byte 0\n&quot;			/* repl len */</span>
<span class="p_del">-			 &quot; .byte 0\n&quot;			/* pad len */</span>
<span class="p_del">-			 &quot;.previous\n&quot;</span>
<span class="p_del">-			 &quot;.section .altinstr_aux,\&quot;ax\&quot;\n&quot;</span>
<span class="p_del">-			 &quot;6:\n&quot;</span>
<span class="p_del">-			 &quot; testb %[bitnum],%[cap_byte]\n&quot;</span>
<span class="p_del">-			 &quot; jnz %l[t_yes]\n&quot;</span>
<span class="p_del">-			 &quot; jmp %l[t_no]\n&quot;</span>
<span class="p_del">-			 &quot;.previous\n&quot;</span>
<span class="p_del">-			 : : &quot;i&quot; (bit), &quot;i&quot; (X86_FEATURE_ALWAYS),</span>
<span class="p_del">-			     [bitnum] &quot;i&quot; (1 &lt;&lt; (bit &amp; 7)),</span>
<span class="p_del">-			     [cap_byte] &quot;m&quot; (((const char *)boot_cpu_data.x86_capability)[bit &gt;&gt; 3])</span>
<span class="p_del">-			 : : t_yes, t_no);</span>
<span class="p_del">-	t_yes:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	t_no:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define static_cpu_has(bit)					\</span>
<span class="p_del">-(								\</span>
<span class="p_del">-	__builtin_constant_p(boot_cpu_has(bit)) ?		\</span>
<span class="p_del">-		boot_cpu_has(bit) :				\</span>
<span class="p_del">-		_static_cpu_has(bit)				\</span>
<span class="p_del">-)</span>
<span class="p_del">-#else</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Fall back to dynamic for gcc versions which don&#39;t support asm goto. Should be</span>
<span class="p_del">- * a minority now anyway.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define static_cpu_has(bit)		boot_cpu_has(bit)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #define cpu_has_bug(c, bit)		cpu_has(c, (bit))
 #define set_cpu_bug(c, bit)		set_cpu_cap(c, (bit))
 #define clear_cpu_bug(c, bit)		clear_cpu_cap(c, (bit))
<span class="p_header">diff --git a/arch/x86/include/asm/cpuinfo.h b/arch/x86/include/asm/cpuinfo.h</span>
new file mode 100644
<span class="p_header">index 000000000000..a6632044f199</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpuinfo.h</span>
<span class="p_chunk">@@ -0,0 +1,65 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_CPUINFO_H_</span>
<span class="p_add">+#define _ASM_X86_CPUINFO_H_</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  CPU type and hardware bug flags. Kept separately for each CPU.</span>
<span class="p_add">+ *  Members of this structure are referenced in head.S, so think twice</span>
<span class="p_add">+ *  before touching them. [mj]</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct cpuinfo_x86 {</span>
<span class="p_add">+	__u8			x86;		/* CPU family */</span>
<span class="p_add">+	__u8			x86_vendor;	/* CPU vendor */</span>
<span class="p_add">+	__u8			x86_model;</span>
<span class="p_add">+	__u8			x86_mask;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	char			wp_works_ok;	/* It doesn&#39;t on 386&#39;s */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Problems on some 486Dx4&#39;s and old 386&#39;s: */</span>
<span class="p_add">+	char			rfu;</span>
<span class="p_add">+	char			pad0;</span>
<span class="p_add">+	char			pad1;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	/* Number of 4K pages in DTLB/ITLB combined(in pages): */</span>
<span class="p_add">+	int			x86_tlbsize;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	__u8			x86_virt_bits;</span>
<span class="p_add">+	__u8			x86_phys_bits;</span>
<span class="p_add">+	/* CPUID returned core id bits: */</span>
<span class="p_add">+	__u8			x86_coreid_bits;</span>
<span class="p_add">+	/* Max extended CPUID function supported: */</span>
<span class="p_add">+	__u32			extended_cpuid_level;</span>
<span class="p_add">+	/* Maximum supported CPUID level, -1=no CPUID: */</span>
<span class="p_add">+	int			cpuid_level;</span>
<span class="p_add">+	__u32			x86_capability[NCAPINTS + NBUGINTS];</span>
<span class="p_add">+	char			x86_vendor_id[16];</span>
<span class="p_add">+	char			x86_model_id[64];</span>
<span class="p_add">+	/* in KB - valid for CPUS which support this call: */</span>
<span class="p_add">+	int			x86_cache_size;</span>
<span class="p_add">+	int			x86_cache_alignment;	/* In bytes */</span>
<span class="p_add">+	/* Cache QoS architectural values: */</span>
<span class="p_add">+	int			x86_cache_max_rmid;	/* max index */</span>
<span class="p_add">+	int			x86_cache_occ_scale;	/* scale to bytes */</span>
<span class="p_add">+	int			x86_power;</span>
<span class="p_add">+	unsigned long		loops_per_jiffy;</span>
<span class="p_add">+	/* cpuid returned max cores value: */</span>
<span class="p_add">+	u16			 x86_max_cores;</span>
<span class="p_add">+	u16			apicid;</span>
<span class="p_add">+	u16			initial_apicid;</span>
<span class="p_add">+	u16			x86_clflush_size;</span>
<span class="p_add">+	/* number of cores as seen by the OS: */</span>
<span class="p_add">+	u16			booted_cores;</span>
<span class="p_add">+	/* Physical processor id: */</span>
<span class="p_add">+	u16			phys_proc_id;</span>
<span class="p_add">+	/* Logical processor id: */</span>
<span class="p_add">+	u16			logical_proc_id;</span>
<span class="p_add">+	/* Core id: */</span>
<span class="p_add">+	u16			cpu_core_id;</span>
<span class="p_add">+	/* Index into per_cpu list: */</span>
<span class="p_add">+	u16			cpu_index;</span>
<span class="p_add">+	u32			microcode;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct cpuinfo_x86	boot_cpu_data;</span>
<span class="p_add">+extern struct cpuinfo_x86	new_cpu_data;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_CPUINFO_H_ */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 62c6cc3cc5d3..6f6555b20e3d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"> struct vm86;</span>
 #include &lt;asm/nops.h&gt;
 #include &lt;asm/special_insns.h&gt;
 #include &lt;asm/fpu/types.h&gt;
<span class="p_add">+#include &lt;asm/cpuinfo.h&gt;</span>
 
 #include &lt;linux/personality.h&gt;
 #include &lt;linux/cache.h&gt;
<span class="p_chunk">@@ -78,65 +79,6 @@</span> <span class="p_context"> extern u16 __read_mostly tlb_lld_2m[NR_INFO];</span>
 extern u16 __read_mostly tlb_lld_4m[NR_INFO];
 extern u16 __read_mostly tlb_lld_1g[NR_INFO];
 
<span class="p_del">-/*</span>
<span class="p_del">- *  CPU type and hardware bug flags. Kept separately for each CPU.</span>
<span class="p_del">- *  Members of this structure are referenced in head.S, so think twice</span>
<span class="p_del">- *  before touching them. [mj]</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-struct cpuinfo_x86 {</span>
<span class="p_del">-	__u8			x86;		/* CPU family */</span>
<span class="p_del">-	__u8			x86_vendor;	/* CPU vendor */</span>
<span class="p_del">-	__u8			x86_model;</span>
<span class="p_del">-	__u8			x86_mask;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	char			wp_works_ok;	/* It doesn&#39;t on 386&#39;s */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Problems on some 486Dx4&#39;s and old 386&#39;s: */</span>
<span class="p_del">-	char			rfu;</span>
<span class="p_del">-	char			pad0;</span>
<span class="p_del">-	char			pad1;</span>
<span class="p_del">-#else</span>
<span class="p_del">-	/* Number of 4K pages in DTLB/ITLB combined(in pages): */</span>
<span class="p_del">-	int			x86_tlbsize;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	__u8			x86_virt_bits;</span>
<span class="p_del">-	__u8			x86_phys_bits;</span>
<span class="p_del">-	/* CPUID returned core id bits: */</span>
<span class="p_del">-	__u8			x86_coreid_bits;</span>
<span class="p_del">-	/* Max extended CPUID function supported: */</span>
<span class="p_del">-	__u32			extended_cpuid_level;</span>
<span class="p_del">-	/* Maximum supported CPUID level, -1=no CPUID: */</span>
<span class="p_del">-	int			cpuid_level;</span>
<span class="p_del">-	__u32			x86_capability[NCAPINTS + NBUGINTS];</span>
<span class="p_del">-	char			x86_vendor_id[16];</span>
<span class="p_del">-	char			x86_model_id[64];</span>
<span class="p_del">-	/* in KB - valid for CPUS which support this call: */</span>
<span class="p_del">-	int			x86_cache_size;</span>
<span class="p_del">-	int			x86_cache_alignment;	/* In bytes */</span>
<span class="p_del">-	/* Cache QoS architectural values: */</span>
<span class="p_del">-	int			x86_cache_max_rmid;	/* max index */</span>
<span class="p_del">-	int			x86_cache_occ_scale;	/* scale to bytes */</span>
<span class="p_del">-	int			x86_power;</span>
<span class="p_del">-	unsigned long		loops_per_jiffy;</span>
<span class="p_del">-	/* cpuid returned max cores value: */</span>
<span class="p_del">-	u16			 x86_max_cores;</span>
<span class="p_del">-	u16			apicid;</span>
<span class="p_del">-	u16			initial_apicid;</span>
<span class="p_del">-	u16			x86_clflush_size;</span>
<span class="p_del">-	/* number of cores as seen by the OS: */</span>
<span class="p_del">-	u16			booted_cores;</span>
<span class="p_del">-	/* Physical processor id: */</span>
<span class="p_del">-	u16			phys_proc_id;</span>
<span class="p_del">-	/* Logical processor id: */</span>
<span class="p_del">-	u16			logical_proc_id;</span>
<span class="p_del">-	/* Core id: */</span>
<span class="p_del">-	u16			cpu_core_id;</span>
<span class="p_del">-	/* Index into per_cpu list: */</span>
<span class="p_del">-	u16			cpu_index;</span>
<span class="p_del">-	u32			microcode;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 #define X86_VENDOR_INTEL	0
 #define X86_VENDOR_CYRIX	1
 #define X86_VENDOR_AMD		2
<span class="p_chunk">@@ -151,9 +93,6 @@</span> <span class="p_context"> struct cpuinfo_x86 {</span>
 /*
  * capabilities of CPUs
  */
<span class="p_del">-extern struct cpuinfo_x86	boot_cpu_data;</span>
<span class="p_del">-extern struct cpuinfo_x86	new_cpu_data;</span>
<span class="p_del">-</span>
 extern struct tss_struct	doublefault_tss;
 extern __u32			cpu_caps_cleared[NCAPINTS];
 extern __u32			cpu_caps_set[NCAPINTS];
<span class="p_header">diff --git a/arch/x86/include/asm/static_cpu_has.h b/arch/x86/include/asm/static_cpu_has.h</span>
new file mode 100644
<span class="p_header">index 000000000000..648ada0c7ffe</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/static_cpu_has.h</span>
<span class="p_chunk">@@ -0,0 +1,116 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_STATIC_CPU_HAS_H</span>
<span class="p_add">+#define _ASM_X86_STATIC_CPU_HAS_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/cpuinfo.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define test_cpu_cap(c, bit)						\</span>
<span class="p_add">+	 test_bit(bit, (unsigned long *)((c)-&gt;x86_capability))</span>
<span class="p_add">+</span>
<span class="p_add">+#define REQUIRED_MASK_BIT_SET(bit)					\</span>
<span class="p_add">+	 ( (((bit)&gt;&gt;5)==0  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK0 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==1  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK1 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==2  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK2 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==3  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK3 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==4  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK4 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==5  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK5 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==6  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK6 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==7  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK7 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==8  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK8 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==9  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK9 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==10 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK10)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==11 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK11)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==12 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK12)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK13)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK14)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK15)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==14 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; REQUIRED_MASK16)) )</span>
<span class="p_add">+</span>
<span class="p_add">+#define DISABLED_MASK_BIT_SET(bit)					\</span>
<span class="p_add">+	 ( (((bit)&gt;&gt;5)==0  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK0 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==1  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK1 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==2  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK2 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==3  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK3 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==4  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK4 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==5  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK5 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==6  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK6 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==7  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK7 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==8  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK8 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==9  &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK9 )) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==10 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK10)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==11 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK11)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==12 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK12)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK13)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK14)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==13 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK15)) ||	\</span>
<span class="p_add">+	   (((bit)&gt;&gt;5)==14 &amp;&amp; (1UL&lt;&lt;((bit)&amp;31) &amp; DISABLED_MASK16)) )</span>
<span class="p_add">+</span>
<span class="p_add">+#define cpu_has(c, bit)							\</span>
<span class="p_add">+	(__builtin_constant_p(bit) &amp;&amp; REQUIRED_MASK_BIT_SET(bit) ? 1 :	\</span>
<span class="p_add">+	 test_cpu_cap(c, bit))</span>
<span class="p_add">+</span>
<span class="p_add">+#define boot_cpu_has(bit)	cpu_has(&amp;boot_cpu_data, bit)</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CC_HAVE_ASM_GOTO) &amp;&amp; defined(CONFIG_X86_FAST_FEATURE_TESTS)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Static testing of CPU features.  Used the same as boot_cpu_has().</span>
<span class="p_add">+ * These will statically patch the target code for additional</span>
<span class="p_add">+ * performance.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __always_inline __pure bool _static_cpu_has(u16 bit)</span>
<span class="p_add">+{</span>
<span class="p_add">+		asm_volatile_goto(&quot;1: jmp 6f\n&quot;</span>
<span class="p_add">+			 &quot;2:\n&quot;</span>
<span class="p_add">+			 &quot;.skip -(((5f-4f) - (2b-1b)) &gt; 0) * &quot;</span>
<span class="p_add">+			         &quot;((5f-4f) - (2b-1b)),0x90\n&quot;</span>
<span class="p_add">+			 &quot;3:\n&quot;</span>
<span class="p_add">+			 &quot;.section .altinstructions,\&quot;a\&quot;\n&quot;</span>
<span class="p_add">+			 &quot; .long 1b - .\n&quot;		/* src offset */</span>
<span class="p_add">+			 &quot; .long 4f - .\n&quot;		/* repl offset */</span>
<span class="p_add">+			 &quot; .word %P1\n&quot;			/* always replace */</span>
<span class="p_add">+			 &quot; .byte 3b - 1b\n&quot;		/* src len */</span>
<span class="p_add">+			 &quot; .byte 5f - 4f\n&quot;		/* repl len */</span>
<span class="p_add">+			 &quot; .byte 3b - 2b\n&quot;		/* pad len */</span>
<span class="p_add">+			 &quot;.previous\n&quot;</span>
<span class="p_add">+			 &quot;.section .altinstr_replacement,\&quot;ax\&quot;\n&quot;</span>
<span class="p_add">+			 &quot;4: jmp %l[t_no]\n&quot;</span>
<span class="p_add">+			 &quot;5:\n&quot;</span>
<span class="p_add">+			 &quot;.previous\n&quot;</span>
<span class="p_add">+			 &quot;.section .altinstructions,\&quot;a\&quot;\n&quot;</span>
<span class="p_add">+			 &quot; .long 1b - .\n&quot;		/* src offset */</span>
<span class="p_add">+			 &quot; .long 0\n&quot;			/* no replacement */</span>
<span class="p_add">+			 &quot; .word %P0\n&quot;			/* feature bit */</span>
<span class="p_add">+			 &quot; .byte 3b - 1b\n&quot;		/* src len */</span>
<span class="p_add">+			 &quot; .byte 0\n&quot;			/* repl len */</span>
<span class="p_add">+			 &quot; .byte 0\n&quot;			/* pad len */</span>
<span class="p_add">+			 &quot;.previous\n&quot;</span>
<span class="p_add">+			 &quot;.section .altinstr_aux,\&quot;ax\&quot;\n&quot;</span>
<span class="p_add">+			 &quot;6:\n&quot;</span>
<span class="p_add">+			 &quot; testb %[bitnum],%[cap_byte]\n&quot;</span>
<span class="p_add">+			 &quot; jnz %l[t_yes]\n&quot;</span>
<span class="p_add">+			 &quot; jmp %l[t_no]\n&quot;</span>
<span class="p_add">+			 &quot;.previous\n&quot;</span>
<span class="p_add">+			 : : &quot;i&quot; (bit), &quot;i&quot; (X86_FEATURE_ALWAYS),</span>
<span class="p_add">+			     [bitnum] &quot;i&quot; (1 &lt;&lt; (bit &amp; 7)),</span>
<span class="p_add">+			     [cap_byte] &quot;m&quot; (((const char *)boot_cpu_data.x86_capability)[bit &gt;&gt; 3])</span>
<span class="p_add">+			 : : t_yes, t_no);</span>
<span class="p_add">+	t_yes:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	t_no:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define static_cpu_has(bit)					\</span>
<span class="p_add">+(								\</span>
<span class="p_add">+	__builtin_constant_p(boot_cpu_has(bit)) ?		\</span>
<span class="p_add">+		boot_cpu_has(bit) :				\</span>
<span class="p_add">+		_static_cpu_has(bit)				\</span>
<span class="p_add">+)</span>
<span class="p_add">+#else</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Fall back to dynamic for gcc versions which don&#39;t support asm goto. Should be</span>
<span class="p_add">+ * a minority now anyway.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define static_cpu_has(bit)		boot_cpu_has(bit)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_STATIC_CPU_HAS_H */</span>
<span class="p_header">diff --git a/arch/x86/lib/Makefile b/arch/x86/lib/Makefile</span>
<span class="p_header">index 72a576752a7e..ec969cc3eb20 100644</span>
<span class="p_header">--- a/arch/x86/lib/Makefile</span>
<span class="p_header">+++ b/arch/x86/lib/Makefile</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"> lib-y += memcpy_$(BITS).o</span>
 lib-$(CONFIG_RWSEM_XCHGADD_ALGORITHM) += rwsem.o
 lib-$(CONFIG_INSTRUCTION_DECODER) += insn.o inat.o
 
<span class="p_del">-obj-y += msr.o msr-reg.o msr-reg-export.o</span>
<span class="p_add">+obj-y += msr.o msr-reg.o msr-reg-export.o hweight.o</span>
 
 ifeq ($(CONFIG_X86_32),y)
         obj-y += atomic64_32.o
<span class="p_header">diff --git a/arch/x86/lib/hweight.c b/arch/x86/lib/hweight.c</span>
new file mode 100644
<span class="p_header">index 000000000000..5834fb9af6ff</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/lib/hweight.c</span>
<span class="p_chunk">@@ -0,0 +1,37 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+# define PUSH_DX	&quot;pushl %%edx\n\t&quot;</span>
<span class="p_add">+# define POP_DX		&quot;popl %%edx\n\t&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define PUSH_DX	&quot;pushq %%rdx\n\t&quot;</span>
<span class="p_add">+# define POP_DX		&quot;popq %%rdx\n\t&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned int __sw_hweight32(unsigned int w)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(PUSH_DX</span>
<span class="p_add">+		     &quot;movl %[w], %%edx\n\t&quot;			/* w -&gt; t */</span>
<span class="p_add">+		     &quot;shrl %%edx\n\t&quot;				/* t &gt;&gt; 1 */</span>
<span class="p_add">+		     &quot;andl $0x55555555, %%edx\n\t&quot;		/* t &amp; 0x55555555 */</span>
<span class="p_add">+		     &quot;subl %%edx, %[w]\n&quot;			/* w -= t */</span>
<span class="p_add">+		     &quot;\n\t&quot;</span>
<span class="p_add">+		     &quot;movl %[w], %%edx\n\t&quot;			/* w -&gt; t */</span>
<span class="p_add">+		     &quot;shrl $2, %[w]\n\t&quot;			/* w_tmp &gt;&gt; 2 */</span>
<span class="p_add">+		     &quot;andl $0x33333333, %%edx\n\t&quot;		/* t &amp; 0x33333333 */</span>
<span class="p_add">+		     &quot;andl $0x33333333, %[w]\n\t&quot;		/* w_tmp &amp; 0x33333333 */</span>
<span class="p_add">+		     &quot;addl %%edx, %[w]\n&quot;			/* w = w_tmp + t */</span>
<span class="p_add">+		     &quot;\n\t&quot;</span>
<span class="p_add">+		     &quot;movl %[w], %%edx\n\t&quot;			/* w -&gt; t */</span>
<span class="p_add">+		     &quot;shrl $4, %%edx\n\t&quot;			/* t &gt;&gt; 4 */</span>
<span class="p_add">+		     &quot;addl %%edx, %[w]\n\t&quot;			/* w_tmp += t */</span>
<span class="p_add">+		     &quot;andl  $0x0f0f0f0f, %[w]\n\t&quot;		/* w_tmp &amp;= 0x0f0f0f0f */</span>
<span class="p_add">+		     &quot;imull $0x01010101, %[w], %[w]\n\t&quot;	/* w_tmp *= 0x01010101 */</span>
<span class="p_add">+		     &quot;shrl $24, %[w]\n\t&quot;			/* w = w_tmp &gt;&gt; 24 */</span>
<span class="p_add">+		     POP_DX</span>
<span class="p_add">+		     : [w] &quot;+r&quot; (w));</span>
<span class="p_add">+</span>
<span class="p_add">+	return w;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__sw_hweight32);</span>
<span class="p_header">diff --git a/lib/Makefile b/lib/Makefile</span>
<span class="p_header">index a65e9a861535..55ad20701dc0 100644</span>
<span class="p_header">--- a/lib/Makefile</span>
<span class="p_header">+++ b/lib/Makefile</span>
<span class="p_chunk">@@ -15,9 +15,6 @@</span> <span class="p_context"> KCOV_INSTRUMENT_rbtree.o := n</span>
 KCOV_INSTRUMENT_list_debug.o := n
 KCOV_INSTRUMENT_debugobjects.o := n
 KCOV_INSTRUMENT_dynamic_debug.o := n
<span class="p_del">-# Kernel does not boot if we instrument this file as it uses custom calling</span>
<span class="p_del">-# convention (see CONFIG_ARCH_HWEIGHT_CFLAGS).</span>
<span class="p_del">-KCOV_INSTRUMENT_hweight.o := n</span>
 
 lib-y := ctype.o string.o vsprintf.o cmdline.o \
 	 rbtree.o radix-tree.o dump_stack.o timerqueue.o\
<span class="p_chunk">@@ -72,8 +69,6 @@</span> <span class="p_context"> obj-$(CONFIG_HAS_IOMEM) += iomap_copy.o devres.o</span>
 obj-$(CONFIG_CHECK_SIGNATURE) += check_signature.o
 obj-$(CONFIG_DEBUG_LOCKING_API_SELFTESTS) += locking-selftest.o
 
<span class="p_del">-GCOV_PROFILE_hweight.o := n</span>
<span class="p_del">-CFLAGS_hweight.o = $(subst $(quote),,$(CONFIG_ARCH_HWEIGHT_CFLAGS))</span>
 obj-$(CONFIG_GENERIC_HWEIGHT) += hweight.o
 
 obj-$(CONFIG_BTREE) += btree.o
<span class="p_header">diff --git a/lib/hweight.c b/lib/hweight.c</span>
<span class="p_header">index 9a5c1f221558..d53137a8def4 100644</span>
<span class="p_header">--- a/lib/hweight.c</span>
<span class="p_header">+++ b/lib/hweight.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  * The Hamming Weight of a number is the total number of bits set in it.
  */
 
<span class="p_add">+#ifndef __HAVE_ARCH_SW_HWEIGHT</span>
 unsigned int __sw_hweight32(unsigned int w)
 {
 #ifdef CONFIG_ARCH_HAS_FAST_MULTIPLIER
<span class="p_chunk">@@ -25,6 +26,7 @@</span> <span class="p_context"> unsigned int __sw_hweight32(unsigned int w)</span>
 #endif
 }
 EXPORT_SYMBOL(__sw_hweight32);
<span class="p_add">+#endif</span>
 
 unsigned int __sw_hweight16(unsigned int w)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



