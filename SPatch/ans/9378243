
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.25 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.25</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 16, 2016, 4:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161016161053.GB19626@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9378243/mbox/"
   >mbox</a>
|
   <a href="/patch/9378243/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9378243/">/patch/9378243/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DD729600CA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:10:58 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D064628A5C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:10:58 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C460F28BB8; Sun, 16 Oct 2016 16:10:58 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7374228BD7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:10:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932575AbcJPQKw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 16 Oct 2016 12:10:52 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:47538 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932506AbcJPQKs (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 16 Oct 2016 12:10:48 -0400
Received: from localhost (unknown [37.162.138.181])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 7ED4DA48;
	Sun, 16 Oct 2016 16:10:46 +0000 (UTC)
Date: Sun, 16 Oct 2016 18:10:53 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.25
Message-ID: &lt;20161016161053.GB19626@kroah.com&gt;
References: &lt;20161016161047.GA19626@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161016161047.GA19626@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 16, 2016, 4:10 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index cdbc185c3539..578a82554923 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 24</span>
<span class="p_add">+SUBLEVEL = 25</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-390.dtsi b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">index 094e39c66039..6cd18d8aaac7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_chunk">@@ -47,6 +47,8 @@</span> <span class="p_context"></span>
 #include &quot;armada-39x.dtsi&quot;
 
 / {
<span class="p_add">+	compatible = &quot;marvell,armada390&quot;;</span>
<span class="p_add">+</span>
 	soc {
 		internal-regs {
 			pinctrl@18000 {
<span class="p_chunk">@@ -54,4 +56,5 @@</span> <span class="p_context"></span>
 				reg = &lt;0x18000 0x20&gt;;
 			};
 		};
<span class="p_add">+	};</span>
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/qcom-apq8064.dtsi b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">index a4c1762b53ea..e00d50ef678f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;dt-bindings/reset/qcom,gcc-msm8960.h&gt;
 #include &lt;dt-bindings/clock/qcom,mmcc-msm8960.h&gt;
 #include &lt;dt-bindings/soc/qcom,gsbi.h&gt;
<span class="p_add">+#include &lt;dt-bindings/interrupt-controller/irq.h&gt;</span>
 #include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;
 / {
 	model = &quot;Qualcomm APQ8064&quot;;
<span class="p_chunk">@@ -354,22 +355,50 @@</span> <span class="p_context"></span>
 
 					compatible = &quot;qcom,pm8921-gpio&quot;;
 					reg = &lt;0x150&gt;;
<span class="p_del">-					interrupts = &lt;192 1&gt;, &lt;193 1&gt;, &lt;194 1&gt;,</span>
<span class="p_del">-						     &lt;195 1&gt;, &lt;196 1&gt;, &lt;197 1&gt;,</span>
<span class="p_del">-						     &lt;198 1&gt;, &lt;199 1&gt;, &lt;200 1&gt;,</span>
<span class="p_del">-						     &lt;201 1&gt;, &lt;202 1&gt;, &lt;203 1&gt;,</span>
<span class="p_del">-						     &lt;204 1&gt;, &lt;205 1&gt;, &lt;206 1&gt;,</span>
<span class="p_del">-						     &lt;207 1&gt;, &lt;208 1&gt;, &lt;209 1&gt;,</span>
<span class="p_del">-						     &lt;210 1&gt;, &lt;211 1&gt;, &lt;212 1&gt;,</span>
<span class="p_del">-						     &lt;213 1&gt;, &lt;214 1&gt;, &lt;215 1&gt;,</span>
<span class="p_del">-						     &lt;216 1&gt;, &lt;217 1&gt;, &lt;218 1&gt;,</span>
<span class="p_del">-						     &lt;219 1&gt;, &lt;220 1&gt;, &lt;221 1&gt;,</span>
<span class="p_del">-						     &lt;222 1&gt;, &lt;223 1&gt;, &lt;224 1&gt;,</span>
<span class="p_del">-						     &lt;225 1&gt;, &lt;226 1&gt;, &lt;227 1&gt;,</span>
<span class="p_del">-						     &lt;228 1&gt;, &lt;229 1&gt;, &lt;230 1&gt;,</span>
<span class="p_del">-						     &lt;231 1&gt;, &lt;232 1&gt;, &lt;233 1&gt;,</span>
<span class="p_del">-						     &lt;234 1&gt;, &lt;235 1&gt;;</span>
<span class="p_del">-</span>
<span class="p_add">+					interrupts = &lt;192 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;193 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;194 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;195 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;196 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;197 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;198 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;199 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;200 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;201 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;202 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;203 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;204 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;205 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;206 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;207 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;208 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;209 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;210 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;211 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;212 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;213 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;214 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;215 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;216 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;217 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;218 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;219 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;220 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;221 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;222 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;223 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;224 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;225 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;226 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;227 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;228 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;229 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;230 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;231 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;232 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;233 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;234 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;235 IRQ_TYPE_NONE&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 
<span class="p_chunk">@@ -381,9 +410,18 @@</span> <span class="p_context"></span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 					interrupts =
<span class="p_del">-					&lt;128 1&gt;, &lt;129 1&gt;, &lt;130 1&gt;, &lt;131 1&gt;,</span>
<span class="p_del">-					&lt;132 1&gt;, &lt;133 1&gt;, &lt;134 1&gt;, &lt;135 1&gt;,</span>
<span class="p_del">-					&lt;136 1&gt;, &lt;137 1&gt;, &lt;138 1&gt;, &lt;139 1&gt;;</span>
<span class="p_add">+					&lt;128 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;129 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;130 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;131 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;132 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;133 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;134 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;135 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;136 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;137 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;138 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;139 IRQ_TYPE_NONE&gt;;</span>
 				};
 
 				rtc@11d {
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index d6476d11212e..3251b206e55a 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -807,6 +807,47 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbr(struct kvm_vcpu *vcpu)</span>
 	return EMULATE_FAIL;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kvm_mips_invalidate_guest_tlb() - Indicates a change in guest MMU map.</span>
<span class="p_add">+ * @vcpu:	VCPU with changed mappings.</span>
<span class="p_add">+ * @tlb:	TLB entry being removed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is called to indicate a single change in guest MMU mappings, so that we</span>
<span class="p_add">+ * can arrange TLB flushes on this and other CPUs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void kvm_mips_invalidate_guest_tlb(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					  struct kvm_mips_tlb *tlb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, i;</span>
<span class="p_add">+	bool user;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No need to flush for entries which are already invalid */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_lo[0] | tlb-&gt;tlb_lo[1]) &amp; ENTRYLO_V))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	/* User address space doesn&#39;t need flushing for KSeg2/3 changes */</span>
<span class="p_add">+	user = tlb-&gt;tlb_hi &lt; KVM_GUEST_KSEG0;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_add">+	 * matches, invalidate it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Invalidate the whole ASID on other CPUs */</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	for_each_possible_cpu(i) {</span>
<span class="p_add">+		if (i == cpu)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (user)</span>
<span class="p_add">+			vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+		vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Write Guest TLB Entry @ Index */
 enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -826,11 +867,8 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)</span>
 	}
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -859,11 +897,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwr(struct kvm_vcpu *vcpu)</span>
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -982,6 +1016,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 	int32_t rt, rd, copz, sel, co_bit, op;
 	uint32_t pc = vcpu-&gt;arch.pc;
 	unsigned long curr_pc;
<span class="p_add">+	int cpu, i;</span>
 
 	/*
 	 * Update PC and hold onto current PC in case there is
<span class="p_chunk">@@ -1089,8 +1124,16 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 						vcpu-&gt;arch.gprs[rt]
 						&amp; ASID_MASK);
 
<span class="p_add">+					preempt_disable();</span>
 					/* Blow away the shadow host TLBs */
 					kvm_mips_flush_host_tlb(1);
<span class="p_add">+					cpu = smp_processor_id();</span>
<span class="p_add">+					for_each_possible_cpu(i)</span>
<span class="p_add">+						if (i != cpu) {</span>
<span class="p_add">+							vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+							vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+						}</span>
<span class="p_add">+					preempt_enable();</span>
 				}
 				kvm_write_c0_guest_entryhi(cop0,
 							   vcpu-&gt;arch.gprs[rt]);
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index 070fa8552051..627d129d7fcb 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -708,6 +708,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
 #define SPRN_MMCR2	785
<span class="p_add">+#define SPRN_UMMCR2	769</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">index 2afdb9c0937d..729f8faa95c5 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_chunk">@@ -498,6 +498,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mtspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong spr_val)</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 #endif
 		break;
 unprivileged:
<span class="p_chunk">@@ -640,6 +641,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mfspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong *spr_val</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 	case SPRN_TIR:
 #endif
 		*spr_val = 0;
<span class="p_header">diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c</span>
<span class="p_header">index fd5875179e5c..6d63cd67b09b 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/booke.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/booke.c</span>
<span class="p_chunk">@@ -2033,7 +2033,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,</span>
 		if (type == KVMPPC_DEBUG_NONE)
 			continue;
 
<span class="p_del">-		if (type &amp; !(KVMPPC_DEBUG_WATCH_READ |</span>
<span class="p_add">+		if (type &amp; ~(KVMPPC_DEBUG_WATCH_READ |</span>
 			     KVMPPC_DEBUG_WATCH_WRITE |
 			     KVMPPC_DEBUG_BREAKPOINT))
 			return -EINVAL;
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index df6b4eeac0bd..0988e204f1e3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -659,11 +659,28 @@</span> <span class="p_context"> void irq_complete_move(struct irq_cfg *cfg)</span>
  */
 void irq_force_complete_move(struct irq_desc *desc)
 {
<span class="p_del">-	struct irq_data *irqdata = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct apic_chip_data *data = apic_chip_data(irqdata);</span>
<span class="p_del">-	struct irq_cfg *cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+	struct irq_data *irqdata;</span>
<span class="p_add">+	struct apic_chip_data *data;</span>
<span class="p_add">+	struct irq_cfg *cfg;</span>
 	unsigned int cpu;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The function is called for all descriptors regardless of which</span>
<span class="p_add">+	 * irqdomain they belong to. For example if an IRQ is provided by</span>
<span class="p_add">+	 * an irq_chip as part of a GPIO driver, the chip data for that</span>
<span class="p_add">+	 * descriptor is specific to the irq_chip in question.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Check first that the chip_data is what we expect</span>
<span class="p_add">+	 * (apic_chip_data) before touching it any further.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	irqdata = irq_domain_get_irq_data(x86_vector_domain,</span>
<span class="p_add">+					  irq_desc_get_irq(desc));</span>
<span class="p_add">+	if (!irqdata)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = apic_chip_data(irqdata);</span>
<span class="p_add">+	cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+</span>
 	if (!cfg)
 		return;
 
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 569c1e4f96fe..38b3ead7222d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,</span>
 		 * continue building up new bios map based on this
 		 * information
 		 */
<span class="p_del">-		if (current_type != last_type || current_type == E820_PRAM) {</span>
<span class="p_add">+		if (current_type != last_type) {</span>
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]-&gt;addr - last_addr;
<span class="p_chunk">@@ -753,7 +753,7 @@</span> <span class="p_context"> u64 __init early_reserve_e820(u64 size, u64 align)</span>
 /*
  * Find the highest page frame number we have available
  */
<span class="p_del">-static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
<span class="p_add">+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)</span>
 {
 	int i;
 	unsigned long last_pfn = 0;
<span class="p_chunk">@@ -764,11 +764,7 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Persistent memory is accounted as ram for purposes of</span>
<span class="p_del">-		 * establishing max_pfn and mem_map.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)</span>
<span class="p_add">+		if (ei-&gt;type != type)</span>
 			continue;
 
 		start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -793,12 +789,12 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(MAX_ARCH_PFN);</span>
<span class="p_add">+	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);</span>
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(1UL &lt;&lt; (32-PAGE_SHIFT));</span>
<span class="p_add">+	return e820_end_pfn(1UL &lt;&lt; (32 - PAGE_SHIFT), E820_RAM);</span>
 }
 
 static void early_panic(char *msg)
<span class="p_header">diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c</span>
<span class="p_header">index 558f50edebca..479a409ddac8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ptrace.c</span>
<span class="p_chunk">@@ -188,8 +188,8 @@</span> <span class="p_context"> unsigned long kernel_stack_pointer(struct pt_regs *regs)</span>
 		return sp;
 
 	prev_esp = (u32 *)(context);
<span class="p_del">-	if (prev_esp)</span>
<span class="p_del">-		return (unsigned long)prev_esp;</span>
<span class="p_add">+	if (*prev_esp)</span>
<span class="p_add">+		return (unsigned long)*prev_esp;</span>
 
 	return (unsigned long)regs;
 }
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">index de0337ebd658..4f3137d9a35e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> static ssize_t tpm_write(struct file *file, const char __user *buf,</span>
 
 	/* atomic tpm command send and result receive */
 	out_size = tpm_transmit(priv-&gt;chip, priv-&gt;data_buffer,
<span class="p_del">-				sizeof(priv-&gt;data_buffer));</span>
<span class="p_add">+				sizeof(priv-&gt;data_buffer), 0);</span>
 	if (out_size &lt; 0) {
 		mutex_unlock(&amp;priv-&gt;buffer_mutex);
 		return out_size;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">index c50637db3a8a..17abe52e6365 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_chunk">@@ -328,8 +328,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);</span>
 /*
  * Internal kernel interface to transmit TPM commands
  */
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz)</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags)</span>
 {
 	ssize_t rc;
 	u32 count, ordinal;
<span class="p_chunk">@@ -348,7 +348,8 @@</span> <span class="p_context"> ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
 		return -E2BIG;
 	}
 
<span class="p_del">-	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
 
 	rc = chip-&gt;ops-&gt;send(chip, (u8 *) buf, count);
 	if (rc &lt; 0) {
<span class="p_chunk">@@ -391,20 +392,21 @@</span> <span class="p_context"> out_recv:</span>
 		dev_err(chip-&gt;pdev,
 			&quot;tpm_transmit: tpm_recv: error %zd\n&quot;, rc);
 out:
<span class="p_del">-	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
 #define TPM_DIGEST_SIZE 20
 #define TPM_RET_CODE_IDX 6
 
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd,</span>
<span class="p_del">-			 int len, const char *desc)</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd,</span>
<span class="p_add">+			 int len, unsigned int flags, const char *desc)</span>
 {
<span class="p_del">-	struct tpm_output_header *header;</span>
<span class="p_add">+	const struct tpm_output_header *header;</span>
 	int err;
 
<span class="p_del">-	len = tpm_transmit(chip, (u8 *) cmd, len);</span>
<span class="p_add">+	len = tpm_transmit(chip, (const u8 *)cmd, len, flags);</span>
 	if (len &lt;  0)
 		return len;
 	else if (len &lt; TPM_HEADER_SIZE)
<span class="p_chunk">@@ -452,7 +454,8 @@</span> <span class="p_context"> ssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = subcap_id;
 	}
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      desc);</span>
 	if (!rc)
 		*cap = tpm_cmd.params.getcap_out.cap;
 	return rc;
<span class="p_chunk">@@ -468,7 +471,7 @@</span> <span class="p_context"> void tpm_gen_interrupt(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the timeouts&quot;);
 }
 EXPORT_SYMBOL_GPL(tpm_gen_interrupt);
<span class="p_chunk">@@ -489,7 +492,7 @@</span> <span class="p_context"> static int tpm_startup(struct tpm_chip *chip, __be16 startup_type)</span>
 	start_cmd.header.in = tpm_startup_header;
 
 	start_cmd.params.startup_in.startup_type = startup_type;
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 
<span class="p_chunk">@@ -505,7 +508,8 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, NULL);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      NULL);</span>
 
 	if (rc == TPM_ERR_INVALID_POSTINIT) {
 		/* The TPM is not started, we are the first to talk to it.
<span class="p_chunk">@@ -519,7 +523,7 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 		rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,
<span class="p_del">-				  NULL);</span>
<span class="p_add">+				      0, NULL);</span>
 	}
 	if (rc) {
 		dev_err(chip-&gt;pdev,
<span class="p_chunk">@@ -580,7 +584,7 @@</span> <span class="p_context"> duration:</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the durations&quot;);
 	if (rc)
 		return rc;
<span class="p_chunk">@@ -636,7 +640,7 @@</span> <span class="p_context"> static int tpm_continue_selftest(struct tpm_chip *chip)</span>
 	struct tpm_cmd_t cmd;
 
 	cmd.header.in = continue_selftest_header;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 	return rc;
 }
<span class="p_chunk">@@ -656,7 +660,7 @@</span> <span class="p_context"> int tpm_pcr_read_dev(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 
 	cmd.header.in = pcrread_header;
 	cmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 
 	if (rc == 0)
<span class="p_chunk">@@ -754,7 +758,7 @@</span> <span class="p_context"> int tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)</span>
 	cmd.header.in = pcrextend_header;
 	cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);
 	memcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	tpm_chip_put(chip);
<span class="p_chunk">@@ -793,7 +797,7 @@</span> <span class="p_context"> int tpm_do_selftest(struct tpm_chip *chip)</span>
 		/* Attempt to read a PCR value */
 		cmd.header.in = pcrread_header;
 		cmd.params.pcrread_in.pcr_idx = cpu_to_be32(0);
<span class="p_del">-		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE);</span>
<span class="p_add">+		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE, 0);</span>
 		/* Some buggy TPMs will not respond to tpm_tis_ready() for
 		 * around 300ms while the self test is ongoing, keep trying
 		 * until the self test duration expires. */
<span class="p_chunk">@@ -834,7 +838,7 @@</span> <span class="p_context"> int tpm_send(u32 chip_num, void *cmd, size_t buflen)</span>
 	if (chip == NULL)
 		return -ENODEV;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, cmd, buflen, &quot;attempting tpm_cmd&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, cmd, buflen, 0, &quot;attempting tpm_cmd&quot;);</span>
 
 	tpm_chip_put(chip);
 	return rc;
<span class="p_chunk">@@ -936,14 +940,15 @@</span> <span class="p_context"> int tpm_pm_suspend(struct device *dev)</span>
 		cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);
 		memcpy(cmd.params.pcrextend_in.hash, dummy_hash,
 		       TPM_DIGEST_SIZE);
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 				      &quot;extending dummy pcr before suspend&quot;);
 	}
 
 	/* now do the actual savestate */
 	for (try = 0; try &lt; TPM_RETRY; try++) {
 		cmd.header.in = savestate_header;
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, 0,</span>
<span class="p_add">+				      NULL);</span>
 
 		/*
 		 * If the TPM indicates that it is too busy to respond to
<span class="p_chunk">@@ -1027,8 +1032,8 @@</span> <span class="p_context"> int tpm_get_random(u32 chip_num, u8 *out, size_t max)</span>
 		tpm_cmd.params.getrandom_in.num_bytes = cpu_to_be32(num_bytes);
 
 		err = tpm_transmit_cmd(chip, &amp;tpm_cmd,
<span class="p_del">-				   TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_del">-				   &quot;attempting get random&quot;);</span>
<span class="p_add">+				       TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_add">+				       0, &quot;attempting get random&quot;);</span>
 		if (err)
 			break;
 
<span class="p_header">diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">index ee66fd4673f3..f880856aa75e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,</span>
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 
 	tpm_cmd.header.in = tpm_readpubek_header;
<span class="p_del">-	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE,</span>
<span class="p_add">+	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE, 0,</span>
 			       &quot;attempting to read the PUBEK&quot;);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h</span>
<span class="p_header">index a4257a32964f..2216861f89f1 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm.h</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm.h</span>
<span class="p_chunk">@@ -498,11 +498,15 @@</span> <span class="p_context"> extern struct class *tpm_class;</span>
 extern dev_t tpm_devt;
 extern const struct file_operations tpm_fops;
 
<span class="p_add">+enum tpm_transmit_flags {</span>
<span class="p_add">+	TPM_TRANSMIT_UNLOCKED	= BIT(0),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags);</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd, int len,</span>
<span class="p_add">+			 unsigned int flags, const char *desc);</span>
 ssize_t	tpm_getcap(struct device *, __be32, cap_t *, const char *);
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz);</span>
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd, int len,</span>
<span class="p_del">-			 const char *desc);</span>
 extern int tpm_get_timeouts(struct tpm_chip *);
 extern void tpm_gen_interrupt(struct tpm_chip *);
 extern int tpm_do_selftest(struct tpm_chip *);
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index 678af51fb29e..cb7e4f6b70ba 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -264,7 +264,7 @@</span> <span class="p_context"> int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 	       sizeof(cmd.params.pcrread_in.pcr_select));
 	cmd.params.pcrread_in.pcr_select[pcr_idx &gt;&gt; 3] = 1 &lt;&lt; (pcr_idx &amp; 0x7);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 	if (rc == 0) {
 		buf = cmd.params.pcrread_out.digest;
<span class="p_chunk">@@ -312,7 +312,7 @@</span> <span class="p_context"> int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)</span>
 	cmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);
 	memcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	return rc;
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> int tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max)</span>
 		cmd.header.in = tpm2_getrandom_header;
 		cmd.params.getrandom_in.size = cpu_to_be16(num_bytes);
 
<span class="p_del">-		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				       &quot;attempting get random&quot;);
 		if (err)
 			break;
<span class="p_chunk">@@ -416,12 +416,12 @@</span> <span class="p_context"> static void tpm2_buf_append_auth(struct tpm_buf *buf, u32 session_handle,</span>
 }
 
 /**
<span class="p_del">- * tpm2_seal_trusted() - seal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm2_seal_trusted() - seal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_seal_trusted(struct tpm_chip *chip,
 		      struct trusted_key_payload *payload,
<span class="p_chunk">@@ -472,7 +472,7 @@</span> <span class="p_context"> int tpm2_seal_trusted(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;sealing data&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, 0, &quot;sealing data&quot;);</span>
 	if (rc)
 		goto out;
 
<span class="p_chunk">@@ -494,10 +494,18 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static int tpm2_load(struct tpm_chip *chip,</span>
<span class="p_del">-		     struct trusted_key_payload *payload,</span>
<span class="p_del">-		     struct trusted_key_options *options,</span>
<span class="p_del">-		     u32 *blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_load_cmd() - execute a TPM2_Load command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_load_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			 struct trusted_key_payload *payload,</span>
<span class="p_add">+			 struct trusted_key_options *options,</span>
<span class="p_add">+			 u32 *blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	unsigned int private_len;
<span class="p_chunk">@@ -532,7 +540,7 @@</span> <span class="p_context"> static int tpm2_load(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;loading blob&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;loading blob&quot;);</span>
 	if (!rc)
 		*blob_handle = be32_to_cpup(
 			(__be32 *) &amp;buf.data[TPM_HEADER_SIZE]);
<span class="p_chunk">@@ -546,7 +554,16 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_flush_context_cmd() - execute a TPM2_FlushContext command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void tpm2_flush_context_cmd(struct tpm_chip *chip, u32 handle,</span>
<span class="p_add">+				   unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	int rc;
<span class="p_chunk">@@ -560,7 +577,8 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 
 	tpm_buf_append_u32(&amp;buf, handle);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;flushing context&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags,</span>
<span class="p_add">+			      &quot;flushing context&quot;);</span>
 	if (rc)
 		dev_warn(chip-&gt;pdev, &quot;0x%08x was not flushed, rc=%d\n&quot;, handle,
 			 rc);
<span class="p_chunk">@@ -568,10 +586,18 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 	tpm_buf_destroy(&amp;buf);
 }
 
<span class="p_del">-static int tpm2_unseal(struct tpm_chip *chip,</span>
<span class="p_del">-		       struct trusted_key_payload *payload,</span>
<span class="p_del">-		       struct trusted_key_options *options,</span>
<span class="p_del">-		       u32 blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_unseal_cmd() - execute a TPM2_Unload command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_unseal_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			   struct trusted_key_payload *payload,</span>
<span class="p_add">+			   struct trusted_key_options *options,</span>
<span class="p_add">+			   u32 blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	u16 data_len;
<span class="p_chunk">@@ -589,7 +615,7 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 			     options-&gt;blobauth /* hmac */,
 			     TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;unsealing&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;unsealing&quot;);</span>
 	if (rc &gt; 0)
 		rc = -EPERM;
 
<span class="p_chunk">@@ -608,12 +634,12 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 }
 
 /**
<span class="p_del">- * tpm_unseal_trusted() - unseal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm_unseal_trusted() - unseal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_unseal_trusted(struct tpm_chip *chip,
 			struct trusted_key_payload *payload,
<span class="p_chunk">@@ -622,14 +648,17 @@</span> <span class="p_context"> int tpm2_unseal_trusted(struct tpm_chip *chip,</span>
 	u32 blob_handle;
 	int rc;
 
<span class="p_del">-	rc = tpm2_load(chip, payload, options, &amp;blob_handle);</span>
<span class="p_add">+	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	rc = tpm2_load_cmd(chip, payload, options, &amp;blob_handle,</span>
<span class="p_add">+			   TPM_TRANSMIT_UNLOCKED);</span>
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = tpm2_unseal(chip, payload, options, blob_handle);</span>
<span class="p_del">-</span>
<span class="p_del">-	tpm2_flush_context(chip, blob_handle);</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	rc = tpm2_unseal_cmd(chip, payload, options, blob_handle,</span>
<span class="p_add">+			     TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+	tpm2_flush_context_cmd(chip, blob_handle, TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -655,7 +684,7 @@</span> <span class="p_context"> ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(property_id);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, desc);</span>
 	if (!rc)
 		*value = be32_to_cpu(cmd.params.get_tpm_pt_out.value);
 
<span class="p_chunk">@@ -689,7 +718,7 @@</span> <span class="p_context"> int tpm2_startup(struct tpm_chip *chip, u16 startup_type)</span>
 	cmd.header.in = tpm2_startup_header;
 
 	cmd.params.startup_in.startup_type = cpu_to_be16(startup_type);
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 EXPORT_SYMBOL_GPL(tpm2_startup);
<span class="p_chunk">@@ -718,7 +747,7 @@</span> <span class="p_context"> void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)</span>
 	cmd.header.in = tpm2_shutdown_header;
 	cmd.params.startup_in.startup_type = cpu_to_be16(shutdown_type);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), &quot;stopping the TPM&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, &quot;stopping the TPM&quot;);</span>
 
 	/* In places where shutdown command is sent there&#39;s no much we can do
 	 * except print the error code on a system failure.
<span class="p_chunk">@@ -784,7 +813,7 @@</span> <span class="p_context"> static int tpm2_start_selftest(struct tpm_chip *chip, bool full)</span>
 	cmd.header.in = tpm2_selftest_header;
 	cmd.params.selftest_in.full_test = full;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 
 	/* At least some prototype chips seem to give RC_TESTING error
<span class="p_chunk">@@ -836,7 +865,7 @@</span> <span class="p_context"> int tpm2_do_selftest(struct tpm_chip *chip)</span>
 		cmd.params.pcrread_in.pcr_select[1] = 0x00;
 		cmd.params.pcrread_in.pcr_select[2] = 0x00;
 
<span class="p_del">-		rc = tpm_transmit_cmd(chip, (u8 *) &amp;cmd, sizeof(cmd), NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, NULL);</span>
 		if (rc &lt; 0)
 			break;
 
<span class="p_chunk">@@ -885,7 +914,7 @@</span> <span class="p_context"> int tpm2_probe(struct tpm_chip *chip)</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(0x100);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit(chip, (const char *) &amp;cmd, sizeof(cmd));</span>
<span class="p_add">+	rc = tpm_transmit(chip, (const u8 *)&amp;cmd, sizeof(cmd), 0);</span>
 	if (rc &lt;  0)
 		return rc;
 	else if (rc &lt; TPM_HEADER_SIZE)
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index 61e64293b765..2b21398c3adc 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -149,6 +149,11 @@</span> <span class="p_context"> static int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)</span>
 	struct crb_priv *priv = chip-&gt;vendor.priv;
 	int rc = 0;
 
<span class="p_add">+	/* Zero the cancel register so that the next command will not get</span>
<span class="p_add">+	 * canceled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
<span class="p_add">+</span>
 	if (len &gt; le32_to_cpu(ioread32(&amp;priv-&gt;cca-&gt;cmd_size))) {
 		dev_err(&amp;chip-&gt;dev,
 			&quot;invalid command count value %x %zx\n&quot;,
<span class="p_chunk">@@ -182,8 +187,6 @@</span> <span class="p_context"> static void crb_cancel(struct tpm_chip *chip)</span>
 
 	if ((priv-&gt;flags &amp; CRB_FL_ACPI_START) &amp;&amp; crb_do_acpi_start(chip))
 		dev_err(&amp;chip-&gt;dev, &quot;ACPI Start failed\n&quot;);
<span class="p_del">-</span>
<span class="p_del">-	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
 }
 
 static bool crb_req_canceled(struct tpm_chip *chip, u8 status)
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle-arm.c b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">index e342565e8715..1855b9ee807f 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static int __init arm_idle_init(void)</span>
 		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 		if (!dev) {
 			pr_err(&quot;Failed to allocate cpuidle device\n&quot;);
<span class="p_add">+			ret = -ENOMEM;</span>
 			goto out_fail;
 		}
 		dev-&gt;cpu = cpu;
<span class="p_header">diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig</span>
<span class="p_header">index 4d92df6ef9fe..7398262a2fab 100644</span>
<span class="p_header">--- a/drivers/mfd/Kconfig</span>
<span class="p_header">+++ b/drivers/mfd/Kconfig</span>
<span class="p_chunk">@@ -1460,6 +1460,7 @@</span> <span class="p_context"> config MFD_WM8350</span>
 config MFD_WM8350_I2C
 	bool &quot;Wolfson Microelectronics WM8350 with I2C&quot;
 	select MFD_WM8350
<span class="p_add">+	select REGMAP_I2C</span>
 	depends on I2C=y
 	help
 	  The WM8350 is an integrated audio and power management
<span class="p_header">diff --git a/drivers/mfd/atmel-hlcdc.c b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">index 06c205868573..c216c3a55793 100644</span>
<span class="p_header">--- a/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">+++ b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_chunk">@@ -50,8 +50,9 @@</span> <span class="p_context"> static int regmap_atmel_hlcdc_reg_write(void *context, unsigned int reg,</span>
 	if (reg &lt;= ATMEL_HLCDC_DIS) {
 		u32 status;
 
<span class="p_del">-		readl_poll_timeout(hregmap-&gt;regs + ATMEL_HLCDC_SR, status,</span>
<span class="p_del">-				   !(status &amp; ATMEL_HLCDC_SIP), 1, 100);</span>
<span class="p_add">+		readl_poll_timeout_atomic(hregmap-&gt;regs + ATMEL_HLCDC_SR,</span>
<span class="p_add">+					  status, !(status &amp; ATMEL_HLCDC_SIP),</span>
<span class="p_add">+					  1, 100);</span>
 	}
 
 	writel(val, hregmap-&gt;regs + reg);
<span class="p_header">diff --git a/drivers/mfd/rtsx_usb.c b/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">index dbd907d7170e..691dab791f7a 100644</span>
<span class="p_header">--- a/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">+++ b/drivers/mfd/rtsx_usb.c</span>
<span class="p_chunk">@@ -46,9 +46,6 @@</span> <span class="p_context"> static void rtsx_usb_sg_timed_out(unsigned long data)</span>
 
 	dev_dbg(&amp;ucr-&gt;pusb_intf-&gt;dev, &quot;%s: sg transfer timed out&quot;, __func__);
 	usb_sg_cancel(&amp;ucr-&gt;current_sg);
<span class="p_del">-</span>
<span class="p_del">-	/* we know the cancellation is caused by time-out */</span>
<span class="p_del">-	ucr-&gt;current_sg.status = -ETIMEDOUT;</span>
 }
 
 static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,
<span class="p_chunk">@@ -67,12 +64,15 @@</span> <span class="p_context"> static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,</span>
 	ucr-&gt;sg_timer.expires = jiffies + msecs_to_jiffies(timeout);
 	add_timer(&amp;ucr-&gt;sg_timer);
 	usb_sg_wait(&amp;ucr-&gt;current_sg);
<span class="p_del">-	del_timer_sync(&amp;ucr-&gt;sg_timer);</span>
<span class="p_add">+	if (!del_timer_sync(&amp;ucr-&gt;sg_timer))</span>
<span class="p_add">+		ret = -ETIMEDOUT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = ucr-&gt;current_sg.status;</span>
 
 	if (act_len)
 		*act_len = ucr-&gt;current_sg.bytes;
 
<span class="p_del">-	return ucr-&gt;current_sg.status;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,
<span class="p_header">diff --git a/include/linux/mfd/88pm80x.h b/include/linux/mfd/88pm80x.h</span>
<span class="p_header">index d409ceb2231e..c118a7ec94d6 100644</span>
<span class="p_header">--- a/include/linux/mfd/88pm80x.h</span>
<span class="p_header">+++ b/include/linux/mfd/88pm80x.h</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static inline int pm80x_dev_suspend(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		set_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		set_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> static inline int pm80x_dev_resume(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		clear_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		clear_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c</span>
<span class="p_header">index 4ff237dbc006..445601c580d6 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping.c</span>
<span class="p_chunk">@@ -298,17 +298,34 @@</span> <span class="p_context"> u32 (*arch_gettimeoffset)(void) = default_arch_gettimeoffset;</span>
 static inline u32 arch_gettimeoffset(void) { return 0; }
 #endif
 
<span class="p_add">+static inline s64 timekeeping_delta_to_ns(struct tk_read_base *tkr,</span>
<span class="p_add">+					  cycle_t delta)</span>
<span class="p_add">+{</span>
<span class="p_add">+	s64 nsec;</span>
<span class="p_add">+</span>
<span class="p_add">+	nsec = delta * tkr-&gt;mult + tkr-&gt;xtime_nsec;</span>
<span class="p_add">+	nsec &gt;&gt;= tkr-&gt;shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If arch requires, add in get_arch_timeoffset() */</span>
<span class="p_add">+	return nsec + arch_gettimeoffset();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline s64 timekeeping_get_ns(struct tk_read_base *tkr)
 {
 	cycle_t delta;
<span class="p_del">-	s64 nsec;</span>
 
 	delta = timekeeping_get_delta(tkr);
<span class="p_add">+	return timekeeping_delta_to_ns(tkr, delta);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	nsec = (delta * tkr-&gt;mult + tkr-&gt;xtime_nsec) &gt;&gt; tkr-&gt;shift;</span>
<span class="p_add">+static inline s64 timekeeping_cycles_to_ns(struct tk_read_base *tkr,</span>
<span class="p_add">+					    cycle_t cycles)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cycle_t delta;</span>
 
<span class="p_del">-	/* If arch requires, add in get_arch_timeoffset() */</span>
<span class="p_del">-	return nsec + arch_gettimeoffset();</span>
<span class="p_add">+	/* calculate the delta since the last update_wall_time */</span>
<span class="p_add">+	delta = clocksource_delta(cycles, tkr-&gt;cycle_last, tkr-&gt;mask);</span>
<span class="p_add">+	return timekeeping_delta_to_ns(tkr, delta);</span>
 }
 
 /**
<span class="p_chunk">@@ -385,8 +402,11 @@</span> <span class="p_context"> static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)</span>
 		tkr = tkf-&gt;base + (seq &amp; 0x01);
 		now = ktime_to_ns(tkr-&gt;base);
 
<span class="p_del">-		now += clocksource_delta(tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_del">-					 tkr-&gt;cycle_last, tkr-&gt;mask);</span>
<span class="p_add">+		now += timekeeping_delta_to_ns(tkr,</span>
<span class="p_add">+				clocksource_delta(</span>
<span class="p_add">+					tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_add">+					tkr-&gt;cycle_last,</span>
<span class="p_add">+					tkr-&gt;mask));</span>
 	} while (read_seqcount_retry(&amp;tkf-&gt;seq, seq));
 
 	return now;
<span class="p_header">diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c</span>
<span class="p_header">index 1d950fbb2aec..2d1fe34781fa 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_api.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_api.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> int ima_collect_measurement(struct integrity_iint_cache *iint,</span>
 	} hash;
 
 	if (xattr_value)
<span class="p_del">-		*xattr_len = ima_read_xattr(file-&gt;f_path.dentry, xattr_value);</span>
<span class="p_add">+		*xattr_len = ima_read_xattr(file_dentry(file), xattr_value);</span>
 
 	if (!(iint-&gt;flags &amp; IMA_COLLECTED)) {
 		u64 i_version = file_inode(file)-&gt;i_version;
<span class="p_header">diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">index 1873b5536f80..ed5a9c110b3a 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_appraise.c</span>
<span class="p_chunk">@@ -189,7 +189,7 @@</span> <span class="p_context"> int ima_appraise_measurement(int func, struct integrity_iint_cache *iint,</span>
 {
 	static const char op[] = &quot;appraise_data&quot;;
 	char *cause = &quot;unknown&quot;;
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	struct inode *inode = d_backing_inode(dentry);
 	enum integrity_status status = INTEGRITY_UNKNOWN;
 	int rc = xattr_len, hash_start = 0;
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> out:</span>
  */
 void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)
 {
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	int rc = 0;
 
 	/* do not collect and update hash for digital signatures */
<span class="p_header">diff --git a/sound/pci/ali5451/ali5451.c b/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">index 36470af7eda7..92b819e4f729 100644</span>
<span class="p_header">--- a/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">+++ b/sound/pci/ali5451/ali5451.c</span>
<span class="p_chunk">@@ -1408,6 +1408,7 @@</span> <span class="p_context"> snd_ali_playback_pointer(struct snd_pcm_substream *substream)</span>
 	spin_unlock(&amp;codec-&gt;reg_lock);
 	dev_dbg(codec-&gt;card-&gt;dev, &quot;playback pointer returned cso=%xh.\n&quot;, cso);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_chunk">@@ -1428,6 +1429,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t snd_ali_pointer(struct snd_pcm_substream *substream)</span>
 	cso = inw(ALI_REG(codec, ALI_CSO_ALPHA_FMS + 2));
 	spin_unlock(&amp;codec-&gt;reg_lock);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_header">diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c</span>
<span class="p_header">index 81b7da8e56d3..183311cb849e 100644</span>
<span class="p_header">--- a/sound/usb/line6/driver.c</span>
<span class="p_header">+++ b/sound/usb/line6/driver.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 /*
 	This is Line 6&#39;s MIDI manufacturer ID.
 */
<span class="p_del">-const unsigned char line6_midi_id[] = {</span>
<span class="p_add">+const unsigned char line6_midi_id[3] = {</span>
 	0x00, 0x01, 0x0c
 };
 EXPORT_SYMBOL_GPL(line6_midi_id);
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index f6c3bf79af9a..04991b009132 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1831,6 +1831,7 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 }
 
 static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,
<span class="p_add">+					 struct usb_mixer_elem_info *cval,</span>
 					 struct snd_kcontrol *kctl)
 {
 	/* Approximation using 10 ranges based on output measurement on hw v1.2.
<span class="p_chunk">@@ -1848,10 +1849,19 @@</span> <span class="p_context"> static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
 		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),
 	);
 
<span class="p_del">-	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_del">-	kctl-&gt;tlv.p = scale;</span>
<span class="p_del">-	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_del">-	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50) {</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk (0-50 variant)\n&quot;);</span>
<span class="p_add">+		kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+		kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max &lt;= 1000) {</span>
<span class="p_add">+		/* Some other clearly broken DragonFly variant.</span>
<span class="p_add">+		 * At least a 0..53 variant (hw v1.0) exists.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;ignoring too narrow dB range on a DragonFly device&quot;);</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,
<span class="p_chunk">@@ -1860,8 +1870,8 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 {
 	switch (mixer-&gt;chip-&gt;usb_id) {
 	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
<span class="p_del">-		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_del">-			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);</span>
 		break;
 	}
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



