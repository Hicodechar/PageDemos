
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.11 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.11</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 19, 2016, 2:15 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160519021534.GB11924@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9123521/mbox/"
   >mbox</a>
|
   <a href="/patch/9123521/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9123521/">/patch/9123521/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id A43ED9F1C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 02:15:58 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 346E62022A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 02:15:52 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 13DB02022D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 19 May 2016 02:15:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753902AbcESCPk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 18 May 2016 22:15:40 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:47156 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753864AbcESCPg (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 18 May 2016 22:15:36 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 41428256;
	Thu, 19 May 2016 02:15:35 +0000 (UTC)
Date: Wed, 18 May 2016 19:15:34 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.11
Message-ID: &lt;20160519021534.GB11924@kroah.com&gt;
References: &lt;20160519021529.GA11924@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160519021529.GA11924@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 19, 2016, 2:15 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 5b5f462f834c..aad86274b61b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 10</span>
<span class="p_add">+SUBLEVEL = 11</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91sam9x5.dtsi b/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_header">index 0827d594b1f0..cd0cd5fd09a3 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"></span>
 
 			pmc: pmc@fffffc00 {
 				compatible = &quot;atmel,at91sam9x5-pmc&quot;, &quot;syscon&quot;;
<span class="p_del">-				reg = &lt;0xfffffc00 0x100&gt;;</span>
<span class="p_add">+				reg = &lt;0xfffffc00 0x200&gt;;</span>
 				interrupts = &lt;1 IRQ_TYPE_LEVEL_HIGH 7&gt;;
 				interrupt-controller;
 				#address-cells = &lt;1&gt;;
<span class="p_header">diff --git a/arch/s390/include/asm/mmu.h b/arch/s390/include/asm/mmu.h</span>
<span class="p_header">index d29ad9545b41..081b2ad99d73 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu.h</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> typedef struct {</span>
 	spinlock_t list_lock;
 	struct list_head pgtable_list;
 	struct list_head gmap_list;
<span class="p_del">-	unsigned long asce_bits;</span>
<span class="p_add">+	unsigned long asce;</span>
 	unsigned long asce_limit;
 	unsigned long vdso_base;
 	/* The mmu context allocates 4K page tables. */
<span class="p_header">diff --git a/arch/s390/include/asm/mmu_context.h b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">index e485817f7b1a..22877c9440ea 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -26,12 +26,28 @@</span> <span class="p_context"> static inline int init_new_context(struct task_struct *tsk,</span>
 	mm-&gt;context.has_pgste = 0;
 	mm-&gt;context.use_skey = 0;
 #endif
<span class="p_del">-	if (mm-&gt;context.asce_limit == 0) {</span>
<span class="p_add">+	switch (mm-&gt;context.asce_limit) {</span>
<span class="p_add">+	case 1UL &lt;&lt; 42:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * forked 3-level task, fall through to set new asce with new</span>
<span class="p_add">+		 * mm-&gt;pgd</span>
<span class="p_add">+		 */</span>
<span class="p_add">+	case 0:</span>
 		/* context created by exec, set asce limit to 4TB */
<span class="p_del">-		mm-&gt;context.asce_bits = _ASCE_TABLE_LENGTH |</span>
<span class="p_del">-			_ASCE_USER_BITS | _ASCE_TYPE_REGION3;</span>
 		mm-&gt;context.asce_limit = STACK_TOP_MAX;
<span class="p_del">-	} else if (mm-&gt;context.asce_limit == (1UL &lt;&lt; 31)) {</span>
<span class="p_add">+		mm-&gt;context.asce = __pa(mm-&gt;pgd) | _ASCE_TABLE_LENGTH |</span>
<span class="p_add">+				   _ASCE_USER_BITS | _ASCE_TYPE_REGION3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 1UL &lt;&lt; 53:</span>
<span class="p_add">+		/* forked 4-level task, set new asce with new mm-&gt;pgd */</span>
<span class="p_add">+		mm-&gt;context.asce = __pa(mm-&gt;pgd) | _ASCE_TABLE_LENGTH |</span>
<span class="p_add">+				   _ASCE_USER_BITS | _ASCE_TYPE_REGION2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 1UL &lt;&lt; 31:</span>
<span class="p_add">+		/* forked 2-level compat task, set new asce with new mm-&gt;pgd */</span>
<span class="p_add">+		mm-&gt;context.asce = __pa(mm-&gt;pgd) | _ASCE_TABLE_LENGTH |</span>
<span class="p_add">+				   _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;</span>
<span class="p_add">+		/* pgd_alloc() did not increase mm-&gt;nr_pmds */</span>
 		mm_inc_nr_pmds(mm);
 	}
 	crst_table_init((unsigned long *) mm-&gt;pgd, pgd_entry_type(mm));
<span class="p_chunk">@@ -42,7 +58,7 @@</span> <span class="p_context"> static inline int init_new_context(struct task_struct *tsk,</span>
 
 static inline void set_user_asce(struct mm_struct *mm)
 {
<span class="p_del">-	S390_lowcore.user_asce = mm-&gt;context.asce_bits | __pa(mm-&gt;pgd);</span>
<span class="p_add">+	S390_lowcore.user_asce = mm-&gt;context.asce;</span>
 	if (current-&gt;thread.mm_segment.ar4)
 		__ctl_load(S390_lowcore.user_asce, 7, 7);
 	set_cpu_flag(CIF_ASCE);
<span class="p_chunk">@@ -71,7 +87,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 {
 	int cpu = smp_processor_id();
 
<span class="p_del">-	S390_lowcore.user_asce = next-&gt;context.asce_bits | __pa(next-&gt;pgd);</span>
<span class="p_add">+	S390_lowcore.user_asce = next-&gt;context.asce;</span>
 	if (prev == next)
 		return;
 	if (MACHINE_HAS_TLB_LC)
<span class="p_header">diff --git a/arch/s390/include/asm/pgalloc.h b/arch/s390/include/asm/pgalloc.h</span>
<span class="p_header">index d7cc79fb6191..5991cdcb5b40 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -56,8 +56,8 @@</span> <span class="p_context"> static inline unsigned long pgd_entry_type(struct mm_struct *mm)</span>
 	return _REGION2_ENTRY_EMPTY;
 }
 
<span class="p_del">-int crst_table_upgrade(struct mm_struct *, unsigned long limit);</span>
<span class="p_del">-void crst_table_downgrade(struct mm_struct *, unsigned long limit);</span>
<span class="p_add">+int crst_table_upgrade(struct mm_struct *);</span>
<span class="p_add">+void crst_table_downgrade(struct mm_struct *);</span>
 
 static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long address)
 {
<span class="p_header">diff --git a/arch/s390/include/asm/processor.h b/arch/s390/include/asm/processor.h</span>
<span class="p_header">index b16c3d0a1b9f..c1ea67db8404 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/processor.h</span>
<span class="p_chunk">@@ -163,7 +163,7 @@</span> <span class="p_context"> extern __vector128 init_task_fpu_regs[__NUM_VXRS];</span>
 	regs-&gt;psw.mask	= PSW_USER_BITS | PSW_MASK_BA;			\
 	regs-&gt;psw.addr	= new_psw | PSW_ADDR_AMODE;			\
 	regs-&gt;gprs[15]	= new_stackp;					\
<span class="p_del">-	crst_table_downgrade(current-&gt;mm, 1UL &lt;&lt; 31);			\</span>
<span class="p_add">+	crst_table_downgrade(current-&gt;mm);				\</span>
 	execve_tail();							\
 } while (0)
 
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index ca148f7c3eaa..a2e6ef32e054 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -110,8 +110,7 @@</span> <span class="p_context"> static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)</span>
 static inline void __tlb_flush_kernel(void)
 {
 	if (MACHINE_HAS_IDTE)
<span class="p_del">-		__tlb_flush_idte((unsigned long) init_mm.pgd |</span>
<span class="p_del">-				 init_mm.context.asce_bits);</span>
<span class="p_add">+		__tlb_flush_idte(init_mm.context.asce);</span>
 	else
 		__tlb_flush_global();
 }
<span class="p_chunk">@@ -133,8 +132,7 @@</span> <span class="p_context"> static inline void __tlb_flush_asce(struct mm_struct *mm, unsigned long asce)</span>
 static inline void __tlb_flush_kernel(void)
 {
 	if (MACHINE_HAS_TLB_LC)
<span class="p_del">-		__tlb_flush_idte_local((unsigned long) init_mm.pgd |</span>
<span class="p_del">-				       init_mm.context.asce_bits);</span>
<span class="p_add">+		__tlb_flush_idte_local(init_mm.context.asce);</span>
 	else
 		__tlb_flush_local();
 }
<span class="p_chunk">@@ -148,8 +146,7 @@</span> <span class="p_context"> static inline void __tlb_flush_mm(struct mm_struct * mm)</span>
 	 * only ran on the local cpu.
 	 */
 	if (MACHINE_HAS_IDTE &amp;&amp; list_empty(&amp;mm-&gt;context.gmap_list))
<span class="p_del">-		__tlb_flush_asce(mm, (unsigned long) mm-&gt;pgd |</span>
<span class="p_del">-				 mm-&gt;context.asce_bits);</span>
<span class="p_add">+		__tlb_flush_asce(mm, mm-&gt;context.asce);</span>
 	else
 		__tlb_flush_full(mm);
 }
<span class="p_header">diff --git a/arch/s390/mm/init.c b/arch/s390/mm/init.c</span>
<span class="p_header">index c722400c7697..feff9caf89b5 100644</span>
<span class="p_header">--- a/arch/s390/mm/init.c</span>
<span class="p_header">+++ b/arch/s390/mm/init.c</span>
<span class="p_chunk">@@ -89,7 +89,8 @@</span> <span class="p_context"> void __init paging_init(void)</span>
 		asce_bits = _ASCE_TYPE_REGION3 | _ASCE_TABLE_LENGTH;
 		pgd_type = _REGION3_ENTRY_EMPTY;
 	}
<span class="p_del">-	S390_lowcore.kernel_asce = (__pa(init_mm.pgd) &amp; PAGE_MASK) | asce_bits;</span>
<span class="p_add">+	init_mm.context.asce = (__pa(init_mm.pgd) &amp; PAGE_MASK) | asce_bits;</span>
<span class="p_add">+	S390_lowcore.kernel_asce = init_mm.context.asce;</span>
 	clear_table((unsigned long *) init_mm.pgd, pgd_type,
 		    sizeof(unsigned long)*2048);
 	vmem_map_init();
<span class="p_header">diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c</span>
<span class="p_header">index ea01477b4aa6..f2b6b1d9c804 100644</span>
<span class="p_header">--- a/arch/s390/mm/mmap.c</span>
<span class="p_header">+++ b/arch/s390/mm/mmap.c</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> int s390_mmap_check(unsigned long addr, unsigned long len, unsigned long flags)</span>
 	if (!(flags &amp; MAP_FIXED))
 		addr = 0;
 	if ((addr + len) &gt;= TASK_SIZE)
<span class="p_del">-		return crst_table_upgrade(current-&gt;mm, 1UL &lt;&lt; 53);</span>
<span class="p_add">+		return crst_table_upgrade(current-&gt;mm);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> s390_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		return area;
 	if (area == -ENOMEM &amp;&amp; !is_compat_task() &amp;&amp; TASK_SIZE &lt; (1UL &lt;&lt; 53)) {
 		/* Upgrade the page table to 4 levels and retry. */
<span class="p_del">-		rc = crst_table_upgrade(mm, 1UL &lt;&lt; 53);</span>
<span class="p_add">+		rc = crst_table_upgrade(mm);</span>
 		if (rc)
 			return (unsigned long) rc;
 		area = arch_get_unmapped_area(filp, addr, len, pgoff, flags);
<span class="p_chunk">@@ -213,7 +213,7 @@</span> <span class="p_context"> s390_get_unmapped_area_topdown(struct file *filp, const unsigned long addr,</span>
 		return area;
 	if (area == -ENOMEM &amp;&amp; !is_compat_task() &amp;&amp; TASK_SIZE &lt; (1UL &lt;&lt; 53)) {
 		/* Upgrade the page table to 4 levels and retry. */
<span class="p_del">-		rc = crst_table_upgrade(mm, 1UL &lt;&lt; 53);</span>
<span class="p_add">+		rc = crst_table_upgrade(mm);</span>
 		if (rc)
 			return (unsigned long) rc;
 		area = arch_get_unmapped_area_topdown(filp, addr, len,
<span class="p_header">diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c</span>
<span class="p_header">index 54ef3bc01b43..471a370a527b 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgtable.c</span>
<span class="p_chunk">@@ -49,81 +49,52 @@</span> <span class="p_context"> static void __crst_table_upgrade(void *arg)</span>
 	__tlb_flush_local();
 }
 
<span class="p_del">-int crst_table_upgrade(struct mm_struct *mm, unsigned long limit)</span>
<span class="p_add">+int crst_table_upgrade(struct mm_struct *mm)</span>
 {
 	unsigned long *table, *pgd;
<span class="p_del">-	unsigned long entry;</span>
<span class="p_del">-	int flush;</span>
 
<span class="p_del">-	BUG_ON(limit &gt; (1UL &lt;&lt; 53));</span>
<span class="p_del">-	flush = 0;</span>
<span class="p_del">-repeat:</span>
<span class="p_add">+	/* upgrade should only happen from 3 to 4 levels */</span>
<span class="p_add">+	BUG_ON(mm-&gt;context.asce_limit != (1UL &lt;&lt; 42));</span>
<span class="p_add">+</span>
 	table = crst_table_alloc(mm);
 	if (!table)
 		return -ENOMEM;
<span class="p_add">+</span>
 	spin_lock_bh(&amp;mm-&gt;page_table_lock);
<span class="p_del">-	if (mm-&gt;context.asce_limit &lt; limit) {</span>
<span class="p_del">-		pgd = (unsigned long *) mm-&gt;pgd;</span>
<span class="p_del">-		if (mm-&gt;context.asce_limit &lt;= (1UL &lt;&lt; 31)) {</span>
<span class="p_del">-			entry = _REGION3_ENTRY_EMPTY;</span>
<span class="p_del">-			mm-&gt;context.asce_limit = 1UL &lt;&lt; 42;</span>
<span class="p_del">-			mm-&gt;context.asce_bits = _ASCE_TABLE_LENGTH |</span>
<span class="p_del">-						_ASCE_USER_BITS |</span>
<span class="p_del">-						_ASCE_TYPE_REGION3;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			entry = _REGION2_ENTRY_EMPTY;</span>
<span class="p_del">-			mm-&gt;context.asce_limit = 1UL &lt;&lt; 53;</span>
<span class="p_del">-			mm-&gt;context.asce_bits = _ASCE_TABLE_LENGTH |</span>
<span class="p_del">-						_ASCE_USER_BITS |</span>
<span class="p_del">-						_ASCE_TYPE_REGION2;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		crst_table_init(table, entry);</span>
<span class="p_del">-		pgd_populate(mm, (pgd_t *) table, (pud_t *) pgd);</span>
<span class="p_del">-		mm-&gt;pgd = (pgd_t *) table;</span>
<span class="p_del">-		mm-&gt;task_size = mm-&gt;context.asce_limit;</span>
<span class="p_del">-		table = NULL;</span>
<span class="p_del">-		flush = 1;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	pgd = (unsigned long *) mm-&gt;pgd;</span>
<span class="p_add">+	crst_table_init(table, _REGION2_ENTRY_EMPTY);</span>
<span class="p_add">+	pgd_populate(mm, (pgd_t *) table, (pud_t *) pgd);</span>
<span class="p_add">+	mm-&gt;pgd = (pgd_t *) table;</span>
<span class="p_add">+	mm-&gt;context.asce_limit = 1UL &lt;&lt; 53;</span>
<span class="p_add">+	mm-&gt;context.asce = __pa(mm-&gt;pgd) | _ASCE_TABLE_LENGTH |</span>
<span class="p_add">+			   _ASCE_USER_BITS | _ASCE_TYPE_REGION2;</span>
<span class="p_add">+	mm-&gt;task_size = mm-&gt;context.asce_limit;</span>
 	spin_unlock_bh(&amp;mm-&gt;page_table_lock);
<span class="p_del">-	if (table)</span>
<span class="p_del">-		crst_table_free(mm, table);</span>
<span class="p_del">-	if (mm-&gt;context.asce_limit &lt; limit)</span>
<span class="p_del">-		goto repeat;</span>
<span class="p_del">-	if (flush)</span>
<span class="p_del">-		on_each_cpu(__crst_table_upgrade, mm, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	on_each_cpu(__crst_table_upgrade, mm, 0);</span>
 	return 0;
 }
 
<span class="p_del">-void crst_table_downgrade(struct mm_struct *mm, unsigned long limit)</span>
<span class="p_add">+void crst_table_downgrade(struct mm_struct *mm)</span>
 {
 	pgd_t *pgd;
 
<span class="p_add">+	/* downgrade should only happen from 3 to 2 levels (compat only) */</span>
<span class="p_add">+	BUG_ON(mm-&gt;context.asce_limit != (1UL &lt;&lt; 42));</span>
<span class="p_add">+</span>
 	if (current-&gt;active_mm == mm) {
 		clear_user_asce();
 		__tlb_flush_mm(mm);
 	}
<span class="p_del">-	while (mm-&gt;context.asce_limit &gt; limit) {</span>
<span class="p_del">-		pgd = mm-&gt;pgd;</span>
<span class="p_del">-		switch (pgd_val(*pgd) &amp; _REGION_ENTRY_TYPE_MASK) {</span>
<span class="p_del">-		case _REGION_ENTRY_TYPE_R2:</span>
<span class="p_del">-			mm-&gt;context.asce_limit = 1UL &lt;&lt; 42;</span>
<span class="p_del">-			mm-&gt;context.asce_bits = _ASCE_TABLE_LENGTH |</span>
<span class="p_del">-						_ASCE_USER_BITS |</span>
<span class="p_del">-						_ASCE_TYPE_REGION3;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case _REGION_ENTRY_TYPE_R3:</span>
<span class="p_del">-			mm-&gt;context.asce_limit = 1UL &lt;&lt; 31;</span>
<span class="p_del">-			mm-&gt;context.asce_bits = _ASCE_TABLE_LENGTH |</span>
<span class="p_del">-						_ASCE_USER_BITS |</span>
<span class="p_del">-						_ASCE_TYPE_SEGMENT;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			BUG();</span>
<span class="p_del">-		}</span>
<span class="p_del">-		mm-&gt;pgd = (pgd_t *) (pgd_val(*pgd) &amp; _REGION_ENTRY_ORIGIN);</span>
<span class="p_del">-		mm-&gt;task_size = mm-&gt;context.asce_limit;</span>
<span class="p_del">-		crst_table_free(mm, (unsigned long *) pgd);</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = mm-&gt;pgd;</span>
<span class="p_add">+	mm-&gt;pgd = (pgd_t *) (pgd_val(*pgd) &amp; _REGION_ENTRY_ORIGIN);</span>
<span class="p_add">+	mm-&gt;context.asce_limit = 1UL &lt;&lt; 31;</span>
<span class="p_add">+	mm-&gt;context.asce = __pa(mm-&gt;pgd) | _ASCE_TABLE_LENGTH |</span>
<span class="p_add">+			   _ASCE_USER_BITS | _ASCE_TYPE_SEGMENT;</span>
<span class="p_add">+	mm-&gt;task_size = mm-&gt;context.asce_limit;</span>
<span class="p_add">+	crst_table_free(mm, (unsigned long *) pgd);</span>
<span class="p_add">+</span>
 	if (current-&gt;active_mm == mm)
 		set_user_asce(mm);
 }
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index d19b52324cf5..dac1c24e9c3e 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -69,8 +69,9 @@</span> <span class="p_context"> static int hash_walk_new_entry(struct crypto_hash_walk *walk)</span>
 	struct scatterlist *sg;
 
 	sg = walk-&gt;sg;
<span class="p_del">-	walk-&gt;pg = sg_page(sg);</span>
 	walk-&gt;offset = sg-&gt;offset;
<span class="p_add">+	walk-&gt;pg = sg_page(walk-&gt;sg) + (walk-&gt;offset &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	walk-&gt;offset = offset_in_page(walk-&gt;offset);</span>
 	walk-&gt;entrylen = sg-&gt;length;
 
 	if (walk-&gt;entrylen &gt; walk-&gt;total)
<span class="p_header">diff --git a/crypto/testmgr.c b/crypto/testmgr.c</span>
<span class="p_header">index ae8c57fd8bc7..d4944318ca1f 100644</span>
<span class="p_header">--- a/crypto/testmgr.c</span>
<span class="p_header">+++ b/crypto/testmgr.c</span>
<span class="p_chunk">@@ -1849,6 +1849,7 @@</span> <span class="p_context"> static int alg_test_drbg(const struct alg_test_desc *desc, const char *driver,</span>
 static int do_test_rsa(struct crypto_akcipher *tfm,
 		       struct akcipher_testvec *vecs)
 {
<span class="p_add">+	char *xbuf[XBUFSIZE];</span>
 	struct akcipher_request *req;
 	void *outbuf_enc = NULL;
 	void *outbuf_dec = NULL;
<span class="p_chunk">@@ -1857,9 +1858,12 @@</span> <span class="p_context"> static int do_test_rsa(struct crypto_akcipher *tfm,</span>
 	int err = -ENOMEM;
 	struct scatterlist src, dst, src_tab[2];
 
<span class="p_add">+	if (testmgr_alloc_buf(xbuf))</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	req = akcipher_request_alloc(tfm, GFP_KERNEL);
 	if (!req)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto free_xbuf;</span>
 
 	init_completion(&amp;result.completion);
 
<span class="p_chunk">@@ -1877,9 +1881,14 @@</span> <span class="p_context"> static int do_test_rsa(struct crypto_akcipher *tfm,</span>
 	if (!outbuf_enc)
 		goto free_req;
 
<span class="p_add">+	if (WARN_ON(vecs-&gt;m_size &gt; PAGE_SIZE))</span>
<span class="p_add">+		goto free_all;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(xbuf[0], vecs-&gt;m, vecs-&gt;m_size);</span>
<span class="p_add">+</span>
 	sg_init_table(src_tab, 2);
<span class="p_del">-	sg_set_buf(&amp;src_tab[0], vecs-&gt;m, 8);</span>
<span class="p_del">-	sg_set_buf(&amp;src_tab[1], vecs-&gt;m + 8, vecs-&gt;m_size - 8);</span>
<span class="p_add">+	sg_set_buf(&amp;src_tab[0], xbuf[0], 8);</span>
<span class="p_add">+	sg_set_buf(&amp;src_tab[1], xbuf[0] + 8, vecs-&gt;m_size - 8);</span>
 	sg_init_one(&amp;dst, outbuf_enc, out_len_max);
 	akcipher_request_set_crypt(req, src_tab, &amp;dst, vecs-&gt;m_size,
 				   out_len_max);
<span class="p_chunk">@@ -1898,7 +1907,7 @@</span> <span class="p_context"> static int do_test_rsa(struct crypto_akcipher *tfm,</span>
 		goto free_all;
 	}
 	/* verify that encrypted message is equal to expected */
<span class="p_del">-	if (memcmp(vecs-&gt;c, sg_virt(req-&gt;dst), vecs-&gt;c_size)) {</span>
<span class="p_add">+	if (memcmp(vecs-&gt;c, outbuf_enc, vecs-&gt;c_size)) {</span>
 		pr_err(&quot;alg: rsa: encrypt test failed. Invalid output\n&quot;);
 		err = -EINVAL;
 		goto free_all;
<span class="p_chunk">@@ -1913,7 +1922,13 @@</span> <span class="p_context"> static int do_test_rsa(struct crypto_akcipher *tfm,</span>
 		err = -ENOMEM;
 		goto free_all;
 	}
<span class="p_del">-	sg_init_one(&amp;src, vecs-&gt;c, vecs-&gt;c_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(vecs-&gt;c_size &gt; PAGE_SIZE))</span>
<span class="p_add">+		goto free_all;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(xbuf[0], vecs-&gt;c, vecs-&gt;c_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	sg_init_one(&amp;src, xbuf[0], vecs-&gt;c_size);</span>
 	sg_init_one(&amp;dst, outbuf_dec, out_len_max);
 	init_completion(&amp;result.completion);
 	akcipher_request_set_crypt(req, &amp;src, &amp;dst, vecs-&gt;c_size, out_len_max);
<span class="p_chunk">@@ -1940,6 +1955,8 @@</span> <span class="p_context"> free_all:</span>
 	kfree(outbuf_enc);
 free_req:
 	akcipher_request_free(req);
<span class="p_add">+free_xbuf:</span>
<span class="p_add">+	testmgr_free_buf(xbuf);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/base/regmap/regmap-spmi.c b/drivers/base/regmap/regmap-spmi.c</span>
<span class="p_header">index 7e58f6560399..4a36e415e938 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap-spmi.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap-spmi.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> static int regmap_spmi_ext_read(void *context,</span>
 	while (val_size) {
 		len = min_t(size_t, val_size, 8);
 
<span class="p_del">-		err = spmi_ext_register_readl(context, addr, val, val_size);</span>
<span class="p_add">+		err = spmi_ext_register_readl(context, addr, val, len);</span>
 		if (err)
 			goto err_out;
 
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_common_drv.h b/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_header">index 3f76bd495bcb..b9178d0a3093 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_chunk">@@ -145,6 +145,8 @@</span> <span class="p_context"> int adf_enable_aer(struct adf_accel_dev *accel_dev, struct pci_driver *adf);</span>
 void adf_disable_aer(struct adf_accel_dev *accel_dev);
 int adf_init_aer(void);
 void adf_exit_aer(void);
<span class="p_add">+int adf_init_pf_wq(void);</span>
<span class="p_add">+void adf_exit_pf_wq(void);</span>
 int adf_init_admin_comms(struct adf_accel_dev *accel_dev);
 void adf_exit_admin_comms(struct adf_accel_dev *accel_dev);
 int adf_send_admin_init(struct adf_accel_dev *accel_dev);
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">index 473d36d91644..e7480f373532 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_chunk">@@ -469,12 +469,17 @@</span> <span class="p_context"> static int __init adf_register_ctl_device_driver(void)</span>
 	if (adf_init_aer())
 		goto err_aer;
 
<span class="p_add">+	if (adf_init_pf_wq())</span>
<span class="p_add">+		goto err_pf_wq;</span>
<span class="p_add">+</span>
 	if (qat_crypto_register())
 		goto err_crypto_register;
 
 	return 0;
 
 err_crypto_register:
<span class="p_add">+	adf_exit_pf_wq();</span>
<span class="p_add">+err_pf_wq:</span>
 	adf_exit_aer();
 err_aer:
 	adf_chr_drv_destroy();
<span class="p_chunk">@@ -487,6 +492,7 @@</span> <span class="p_context"> static void __exit adf_unregister_ctl_device_driver(void)</span>
 {
 	adf_chr_drv_destroy();
 	adf_exit_aer();
<span class="p_add">+	adf_exit_pf_wq();</span>
 	qat_crypto_unregister();
 	adf_clean_vf_map(false);
 	mutex_destroy(&amp;adf_ctl_lock);
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_sriov.c b/drivers/crypto/qat/qat_common/adf_sriov.c</span>
<span class="p_header">index 1117a8b58280..38a0415e767d 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_sriov.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_sriov.c</span>
<span class="p_chunk">@@ -119,11 +119,6 @@</span> <span class="p_context"> static int adf_enable_sriov(struct adf_accel_dev *accel_dev)</span>
 	int i;
 	u32 reg;
 
<span class="p_del">-	/* Workqueue for PF2VF responses */</span>
<span class="p_del">-	pf2vf_resp_wq = create_workqueue(&quot;qat_pf2vf_resp_wq&quot;);</span>
<span class="p_del">-	if (!pf2vf_resp_wq)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	for (i = 0, vf_info = accel_dev-&gt;pf.vf_info; i &lt; totalvfs;
 	     i++, vf_info++) {
 		/* This ptr will be populated when VFs will be created */
<span class="p_chunk">@@ -216,11 +211,6 @@</span> <span class="p_context"> void adf_disable_sriov(struct adf_accel_dev *accel_dev)</span>
 
 	kfree(accel_dev-&gt;pf.vf_info);
 	accel_dev-&gt;pf.vf_info = NULL;
<span class="p_del">-</span>
<span class="p_del">-	if (pf2vf_resp_wq) {</span>
<span class="p_del">-		destroy_workqueue(pf2vf_resp_wq);</span>
<span class="p_del">-		pf2vf_resp_wq = NULL;</span>
<span class="p_del">-	}</span>
 }
 EXPORT_SYMBOL_GPL(adf_disable_sriov);
 
<span class="p_chunk">@@ -304,3 +294,19 @@</span> <span class="p_context"> int adf_sriov_configure(struct pci_dev *pdev, int numvfs)</span>
 	return numvfs;
 }
 EXPORT_SYMBOL_GPL(adf_sriov_configure);
<span class="p_add">+</span>
<span class="p_add">+int __init adf_init_pf_wq(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Workqueue for PF2VF responses */</span>
<span class="p_add">+	pf2vf_resp_wq = create_workqueue(&quot;qat_pf2vf_resp_wq&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return !pf2vf_resp_wq ? -ENOMEM : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void adf_exit_pf_wq(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pf2vf_resp_wq) {</span>
<span class="p_add">+		destroy_workqueue(pf2vf_resp_wq);</span>
<span class="p_add">+		pf2vf_resp_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">index 6a2c76e367a5..97d1ed20418b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_chunk">@@ -248,8 +248,14 @@</span> <span class="p_context"> static bool intel_crt_compute_config(struct intel_encoder *encoder,</span>
 		pipe_config-&gt;has_pch_encoder = true;
 
 	/* LPT FDI RX only supports 8bpc. */
<span class="p_del">-	if (HAS_PCH_LPT(dev))</span>
<span class="p_add">+	if (HAS_PCH_LPT(dev)) {</span>
<span class="p_add">+		if (pipe_config-&gt;bw_constrained &amp;&amp; pipe_config-&gt;pipe_bpp &lt; 24) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;LPT only supports 24bpp\n&quot;);</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		pipe_config-&gt;pipe_bpp = 24;
<span class="p_add">+	}</span>
 
 	/* FDI must always be 2.7 GHz */
 	if (HAS_DDI(dev)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index f091ad12d694..0a68d2ec89dc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -6620,6 +6620,12 @@</span> <span class="p_context"> static void broadwell_init_clock_gating(struct drm_device *dev)</span>
 	misccpctl = I915_READ(GEN7_MISCCPCTL);
 	I915_WRITE(GEN7_MISCCPCTL, misccpctl &amp; ~GEN7_DOP_CLOCK_GATE_ENABLE);
 	I915_WRITE(GEN8_L3SQCREG1, BDW_WA_L3SQCREG1_DEFAULT);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait at least 100 clocks before re-enabling clock gating. See</span>
<span class="p_add">+	 * the definition of L3SQCREG1 in BSpec.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	POSTING_READ(GEN8_L3SQCREG1);</span>
<span class="p_add">+	udelay(1);</span>
 	I915_WRITE(GEN7_MISCCPCTL, misccpctl);
 
 	/*
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index dac78ad24b31..79bab6fd76bb 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -1739,6 +1739,7 @@</span> <span class="p_context"> static u32 radeon_get_pll_use_mask(struct drm_crtc *crtc)</span>
 static int radeon_get_shared_dp_ppll(struct drm_crtc *crtc)
 {
 	struct drm_device *dev = crtc-&gt;dev;
<span class="p_add">+	struct radeon_device *rdev = dev-&gt;dev_private;</span>
 	struct drm_crtc *test_crtc;
 	struct radeon_crtc *test_radeon_crtc;
 
<span class="p_chunk">@@ -1748,6 +1749,10 @@</span> <span class="p_context"> static int radeon_get_shared_dp_ppll(struct drm_crtc *crtc)</span>
 		test_radeon_crtc = to_radeon_crtc(test_crtc);
 		if (test_radeon_crtc-&gt;encoder &amp;&amp;
 		    ENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc-&gt;encoder))) {
<span class="p_add">+			/* PPLL2 is exclusive to UNIPHYA on DCE61 */</span>
<span class="p_add">+			if (ASIC_IS_DCE61(rdev) &amp;&amp; !ASIC_IS_DCE8(rdev) &amp;&amp;</span>
<span class="p_add">+			    test_radeon_crtc-&gt;pll_id == ATOM_PPLL2)</span>
<span class="p_add">+				continue;</span>
 			/* for DP use the same PLL for all */
 			if (test_radeon_crtc-&gt;pll_id != ATOM_PPLL_INVALID)
 				return test_radeon_crtc-&gt;pll_id;
<span class="p_chunk">@@ -1769,6 +1774,7 @@</span> <span class="p_context"> static int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)</span>
 {
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
 	struct drm_device *dev = crtc-&gt;dev;
<span class="p_add">+	struct radeon_device *rdev = dev-&gt;dev_private;</span>
 	struct drm_crtc *test_crtc;
 	struct radeon_crtc *test_radeon_crtc;
 	u32 adjusted_clock, test_adjusted_clock;
<span class="p_chunk">@@ -1784,6 +1790,10 @@</span> <span class="p_context"> static int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)</span>
 		test_radeon_crtc = to_radeon_crtc(test_crtc);
 		if (test_radeon_crtc-&gt;encoder &amp;&amp;
 		    !ENCODER_MODE_IS_DP(atombios_get_encoder_mode(test_radeon_crtc-&gt;encoder))) {
<span class="p_add">+			/* PPLL2 is exclusive to UNIPHYA on DCE61 */</span>
<span class="p_add">+			if (ASIC_IS_DCE61(rdev) &amp;&amp; !ASIC_IS_DCE8(rdev) &amp;&amp;</span>
<span class="p_add">+			    test_radeon_crtc-&gt;pll_id == ATOM_PPLL2)</span>
<span class="p_add">+				continue;</span>
 			/* check if we are already driving this connector with another crtc */
 			if (test_radeon_crtc-&gt;connector == radeon_crtc-&gt;connector) {
 				/* if we are, return that pll */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_dp_auxch.c b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">index 3b0c229d7dcd..db64e0062689 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> radeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg</span>
 
 	tmp &amp;= AUX_HPD_SEL(0x7);
 	tmp |= AUX_HPD_SEL(chan-&gt;rec.hpd);
<span class="p_del">-	tmp |= AUX_EN | AUX_LS_READ_EN;</span>
<span class="p_add">+	tmp |= AUX_EN | AUX_LS_READ_EN | AUX_HPD_DISCON(0x1);</span>
 
 	WREG32(AUX_CONTROL + aux_offset[instance], tmp);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 721d63f5b461..fd17443aeacd 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -405,8 +405,8 @@</span> <span class="p_context"> static int mlx5_query_hca_port(struct ib_device *ibdev, u8 port,</span>
 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
 	struct mlx5_core_dev *mdev = dev-&gt;mdev;
 	struct mlx5_hca_vport_context *rep;
<span class="p_del">-	int max_mtu;</span>
<span class="p_del">-	int oper_mtu;</span>
<span class="p_add">+	u16 max_mtu;</span>
<span class="p_add">+	u16 oper_mtu;</span>
 	int err;
 	u8 ib_link_width_oper;
 	u8 vl_hw_cap;
<span class="p_header">diff --git a/drivers/input/misc/max8997_haptic.c b/drivers/input/misc/max8997_haptic.c</span>
<span class="p_header">index a806ba3818f7..8d6326d7e7be 100644</span>
<span class="p_header">--- a/drivers/input/misc/max8997_haptic.c</span>
<span class="p_header">+++ b/drivers/input/misc/max8997_haptic.c</span>
<span class="p_chunk">@@ -255,12 +255,14 @@</span> <span class="p_context"> static int max8997_haptic_probe(struct platform_device *pdev)</span>
 	struct max8997_dev *iodev = dev_get_drvdata(pdev-&gt;dev.parent);
 	const struct max8997_platform_data *pdata =
 					dev_get_platdata(iodev-&gt;dev);
<span class="p_del">-	const struct max8997_haptic_platform_data *haptic_pdata =</span>
<span class="p_del">-					pdata-&gt;haptic_pdata;</span>
<span class="p_add">+	const struct max8997_haptic_platform_data *haptic_pdata = NULL;</span>
 	struct max8997_haptic *chip;
 	struct input_dev *input_dev;
 	int error;
 
<span class="p_add">+	if (pdata)</span>
<span class="p_add">+		haptic_pdata = pdata-&gt;haptic_pdata;</span>
<span class="p_add">+</span>
 	if (!haptic_pdata) {
 		dev_err(&amp;pdev-&gt;dev, &quot;no haptic platform data\n&quot;);
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-v4l2.c b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">index 6c441be8f893..502984c724ff 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_chunk">@@ -67,11 +67,6 @@</span> <span class="p_context"> static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer</span>
 	return 0;
 }
 
<span class="p_del">-static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __verify_planes_array(vb, pb);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn&#39;t exceed the bytesused value.
<span class="p_chunk">@@ -437,7 +432,6 @@</span> <span class="p_context"> static int __fill_vb2_buffer(struct vb2_buffer *vb,</span>
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
<span class="p_del">-	.verify_planes_array	= __verify_planes_array_core,</span>
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.set_timestamp		= __set_timestamp,
<span class="p_header">diff --git a/drivers/net/ethernet/atheros/atlx/atl2.c b/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_header">index 8f76f4558a88..2ff465848b65 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_chunk">@@ -1412,7 +1412,7 @@</span> <span class="p_context"> static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 
 	err = -EIO;
 
<span class="p_del">-	netdev-&gt;hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX;</span>
<span class="p_add">+	netdev-&gt;hw_features = NETIF_F_HW_VLAN_CTAG_RX;</span>
 	netdev-&gt;features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
<span class="p_header">diff --git a/drivers/net/ethernet/cavium/thunder/nicvf_queues.c b/drivers/net/ethernet/cavium/thunder/nicvf_queues.c</span>
<span class="p_header">index 206b6a71a545..d1c217eaf417 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cavium/thunder/nicvf_queues.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cavium/thunder/nicvf_queues.c</span>
<span class="p_chunk">@@ -550,6 +550,7 @@</span> <span class="p_context"> static void nicvf_rcv_queue_config(struct nicvf *nic, struct queue_set *qs,</span>
 		nicvf_config_vlan_stripping(nic, nic-&gt;netdev-&gt;features);
 
 	/* Enable Receive queue */
<span class="p_add">+	memset(&amp;rq_cfg, 0, sizeof(struct rq_cfg));</span>
 	rq_cfg.ena = 1;
 	rq_cfg.tcp_ena = 0;
 	nicvf_queue_reg_write(nic, NIC_QSET_RQ_0_7_CFG, qidx, *(u64 *)&amp;rq_cfg);
<span class="p_chunk">@@ -582,6 +583,7 @@</span> <span class="p_context"> void nicvf_cmp_queue_config(struct nicvf *nic, struct queue_set *qs,</span>
 			      qidx, (u64)(cq-&gt;dmem.phys_base));
 
 	/* Enable Completion queue */
<span class="p_add">+	memset(&amp;cq_cfg, 0, sizeof(struct cq_cfg));</span>
 	cq_cfg.ena = 1;
 	cq_cfg.reset = 0;
 	cq_cfg.caching = 0;
<span class="p_chunk">@@ -630,6 +632,7 @@</span> <span class="p_context"> static void nicvf_snd_queue_config(struct nicvf *nic, struct queue_set *qs,</span>
 			      qidx, (u64)(sq-&gt;dmem.phys_base));
 
 	/* Enable send queue  &amp; set queue size */
<span class="p_add">+	memset(&amp;sq_cfg, 0, sizeof(struct sq_cfg));</span>
 	sq_cfg.ena = 1;
 	sq_cfg.reset = 0;
 	sq_cfg.ldwb = 0;
<span class="p_chunk">@@ -666,6 +669,7 @@</span> <span class="p_context"> static void nicvf_rbdr_config(struct nicvf *nic, struct queue_set *qs,</span>
 
 	/* Enable RBDR  &amp; set queue size */
 	/* Buffer size should be in multiples of 128 bytes */
<span class="p_add">+	memset(&amp;rbdr_cfg, 0, sizeof(struct rbdr_cfg));</span>
 	rbdr_cfg.ena = 1;
 	rbdr_cfg.reset = 0;
 	rbdr_cfg.ldwb = 0;
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">index b2a32209ffbf..f6147ffc7fbc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/fec_main.c</span>
<span class="p_chunk">@@ -1557,9 +1557,15 @@</span> <span class="p_context"> fec_enet_rx(struct net_device *ndev, int budget)</span>
 	struct fec_enet_private *fep = netdev_priv(ndev);
 
 	for_each_set_bit(queue_id, &amp;fep-&gt;work_rx, FEC_ENET_MAX_RX_QS) {
<span class="p_del">-		clear_bit(queue_id, &amp;fep-&gt;work_rx);</span>
<span class="p_del">-		pkt_received += fec_enet_rx_queue(ndev,</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = fec_enet_rx_queue(ndev,</span>
 					budget - pkt_received, queue_id);
<span class="p_add">+</span>
<span class="p_add">+		if (ret &lt; budget - pkt_received)</span>
<span class="p_add">+			clear_bit(queue_id, &amp;fep-&gt;work_rx);</span>
<span class="p_add">+</span>
<span class="p_add">+		pkt_received += ret;</span>
 	}
 	return pkt_received;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index e7a5000aa12c..bbff8ec6713e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -704,7 +704,7 @@</span> <span class="p_context"> static int get_fixed_ipv6_csum(__wsum hw_checksum, struct sk_buff *skb,</span>
 
 	if (ipv6h-&gt;nexthdr == IPPROTO_FRAGMENT || ipv6h-&gt;nexthdr == IPPROTO_HOPOPTS)
 		return -1;
<span class="p_del">-	hw_checksum = csum_add(hw_checksum, (__force __wsum)(ipv6h-&gt;nexthdr &lt;&lt; 8));</span>
<span class="p_add">+	hw_checksum = csum_add(hw_checksum, (__force __wsum)htons(ipv6h-&gt;nexthdr));</span>
 
 	csum_pseudo_hdr = csum_partial(&amp;ipv6h-&gt;saddr,
 				       sizeof(ipv6h-&gt;saddr) + sizeof(ipv6h-&gt;daddr), 0);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index 4421bf5463f6..e4019a803a9c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -400,7 +400,6 @@</span> <span class="p_context"> static bool mlx4_en_process_tx_cq(struct net_device *dev,</span>
 	u32 packets = 0;
 	u32 bytes = 0;
 	int factor = priv-&gt;cqe_factor;
<span class="p_del">-	u64 timestamp = 0;</span>
 	int done = 0;
 	int budget = priv-&gt;tx_work_limit;
 	u32 last_nr_txbb;
<span class="p_chunk">@@ -440,9 +439,12 @@</span> <span class="p_context"> static bool mlx4_en_process_tx_cq(struct net_device *dev,</span>
 		new_index = be16_to_cpu(cqe-&gt;wqe_index) &amp; size_mask;
 
 		do {
<span class="p_add">+			u64 timestamp = 0;</span>
<span class="p_add">+</span>
 			txbbs_skipped += last_nr_txbb;
 			ring_index = (ring_index + last_nr_txbb) &amp; size_mask;
<span class="p_del">-			if (ring-&gt;tx_info[ring_index].ts_requested)</span>
<span class="p_add">+</span>
<span class="p_add">+			if (unlikely(ring-&gt;tx_info[ring_index].ts_requested))</span>
 				timestamp = mlx4_en_get_cqe_ts(cqe);
 
 			/* free next descriptor */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index 1203d892e842..cbd17e25beeb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -1372,7 +1372,7 @@</span> <span class="p_context"> static int mlx5e_set_dev_port_mtu(struct net_device *netdev)</span>
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 	struct mlx5_core_dev *mdev = priv-&gt;mdev;
<span class="p_del">-	int hw_mtu;</span>
<span class="p_add">+	u16 hw_mtu;</span>
 	int err;
 
 	err = mlx5_set_port_mtu(mdev, MLX5E_SW2HW_MTU(netdev-&gt;mtu), 1);
<span class="p_chunk">@@ -1891,22 +1891,27 @@</span> <span class="p_context"> static int mlx5e_set_features(struct net_device *netdev,</span>
 	return err;
 }
 
<span class="p_add">+#define MXL5_HW_MIN_MTU 64</span>
<span class="p_add">+#define MXL5E_MIN_MTU (MXL5_HW_MIN_MTU + ETH_FCS_LEN)</span>
<span class="p_add">+</span>
 static int mlx5e_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 	struct mlx5_core_dev *mdev = priv-&gt;mdev;
 	bool was_opened;
<span class="p_del">-	int max_mtu;</span>
<span class="p_add">+	u16 max_mtu;</span>
<span class="p_add">+	u16 min_mtu;</span>
 	int err = 0;
 
 	mlx5_query_port_max_mtu(mdev, &amp;max_mtu, 1);
 
 	max_mtu = MLX5E_HW2SW_MTU(max_mtu);
<span class="p_add">+	min_mtu = MLX5E_HW2SW_MTU(MXL5E_MIN_MTU);</span>
 
<span class="p_del">-	if (new_mtu &gt; max_mtu) {</span>
<span class="p_add">+	if (new_mtu &gt; max_mtu || new_mtu &lt; min_mtu) {</span>
 		netdev_err(netdev,
<span class="p_del">-			   &quot;%s: Bad MTU (%d) &gt; (%d) Max\n&quot;,</span>
<span class="p_del">-			   __func__, new_mtu, max_mtu);</span>
<span class="p_add">+			   &quot;%s: Bad MTU (%d), valid range is: [%d..%d]\n&quot;,</span>
<span class="p_add">+			   __func__, new_mtu, min_mtu, max_mtu);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/port.c b/drivers/net/ethernet/mellanox/mlx5/core/port.c</span>
<span class="p_header">index a87e773e93f3..53a793bc2e3d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c</span>
<span class="p_chunk">@@ -246,8 +246,8 @@</span> <span class="p_context"> int mlx5_query_port_admin_status(struct mlx5_core_dev *dev,</span>
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_admin_status);
 
<span class="p_del">-static void mlx5_query_port_mtu(struct mlx5_core_dev *dev, int *admin_mtu,</span>
<span class="p_del">-				int *max_mtu, int *oper_mtu, u8 port)</span>
<span class="p_add">+static void mlx5_query_port_mtu(struct mlx5_core_dev *dev, u16 *admin_mtu,</span>
<span class="p_add">+				u16 *max_mtu, u16 *oper_mtu, u8 port)</span>
 {
 	u32 in[MLX5_ST_SZ_DW(pmtu_reg)];
 	u32 out[MLX5_ST_SZ_DW(pmtu_reg)];
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> static void mlx5_query_port_mtu(struct mlx5_core_dev *dev, int *admin_mtu,</span>
 		*admin_mtu = MLX5_GET(pmtu_reg, out, admin_mtu);
 }
 
<span class="p_del">-int mlx5_set_port_mtu(struct mlx5_core_dev *dev, int mtu, u8 port)</span>
<span class="p_add">+int mlx5_set_port_mtu(struct mlx5_core_dev *dev, u16 mtu, u8 port)</span>
 {
 	u32 in[MLX5_ST_SZ_DW(pmtu_reg)];
 	u32 out[MLX5_ST_SZ_DW(pmtu_reg)];
<span class="p_chunk">@@ -282,14 +282,14 @@</span> <span class="p_context"> int mlx5_set_port_mtu(struct mlx5_core_dev *dev, int mtu, u8 port)</span>
 }
 EXPORT_SYMBOL_GPL(mlx5_set_port_mtu);
 
<span class="p_del">-void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu,</span>
<span class="p_add">+void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, u16 *max_mtu,</span>
 			     u8 port)
 {
 	mlx5_query_port_mtu(dev, NULL, max_mtu, NULL, port);
 }
 EXPORT_SYMBOL_GPL(mlx5_query_port_max_mtu);
 
<span class="p_del">-void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu,</span>
<span class="p_add">+void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, u16 *oper_mtu,</span>
 			      u8 port)
 {
 	mlx5_query_port_mtu(dev, NULL, NULL, oper_mtu, port);
<span class="p_header">diff --git a/drivers/net/usb/cdc_mbim.c b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">index bdd83d95ec0a..96a5028621c8 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_chunk">@@ -617,8 +617,13 @@</span> <span class="p_context"> static const struct usb_device_id mbim_devs[] = {</span>
 	{ USB_VENDOR_AND_INTERFACE_INFO(0x0bdb, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),
 	  .driver_info = (unsigned long)&amp;cdc_mbim_info,
 	},
<span class="p_del">-	/* Huawei E3372 fails unless NDP comes after the IP packets */</span>
<span class="p_del">-	{ USB_DEVICE_AND_INTERFACE_INFO(0x12d1, 0x157d, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Some Huawei devices, ME906s-158 (12d1:15c1) and E3372</span>
<span class="p_add">+	 * (12d1:157d), are known to fail unless the NDP is placed</span>
<span class="p_add">+	 * after the IP packets.  Applying the quirk to all Huawei</span>
<span class="p_add">+	 * devices is broader than necessary, but harmless.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{ USB_VENDOR_AND_INTERFACE_INFO(0x12d1, USB_CLASS_COMM, USB_CDC_SUBCLASS_MBIM, USB_CDC_PROTO_NONE),</span>
 	  .driver_info = (unsigned long)&amp;cdc_mbim_info_ndp_to_end,
 	},
 	/* default entry */
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-at91-pio4.c b/drivers/pinctrl/pinctrl-at91-pio4.c</span>
<span class="p_header">index 33edd07d9149..b3235fd2950c 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-at91-pio4.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-at91-pio4.c</span>
<span class="p_chunk">@@ -717,9 +717,11 @@</span> <span class="p_context"> static int atmel_conf_pin_config_group_set(struct pinctrl_dev *pctldev,</span>
 			break;
 		case PIN_CONFIG_BIAS_PULL_UP:
 			conf |= ATMEL_PIO_PUEN_MASK;
<span class="p_add">+			conf &amp;= (~ATMEL_PIO_PDEN_MASK);</span>
 			break;
 		case PIN_CONFIG_BIAS_PULL_DOWN:
 			conf |= ATMEL_PIO_PDEN_MASK;
<span class="p_add">+			conf &amp;= (~ATMEL_PIO_PUEN_MASK);</span>
 			break;
 		case PIN_CONFIG_DRIVE_OPEN_DRAIN:
 			if (arg == 0)
<span class="p_header">diff --git a/drivers/regulator/axp20x-regulator.c b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">index f2e1a39ce0f3..5cf4a97e0304 100644</span>
<span class="p_header">--- a/drivers/regulator/axp20x-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/axp20x-regulator.c</span>
<span class="p_chunk">@@ -221,10 +221,10 @@</span> <span class="p_context"> static const struct regulator_desc axp22x_regulators[] = {</span>
 		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
 	AXP_DESC(AXP22X, ELDO3, &quot;eldo3&quot;, &quot;eldoin&quot;, 700, 3300, 100,
 		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
<span class="p_del">-	AXP_DESC_IO(AXP22X, LDO_IO0, &quot;ldo_io0&quot;, &quot;ips&quot;, 1800, 3300, 100,</span>
<span class="p_add">+	AXP_DESC_IO(AXP22X, LDO_IO0, &quot;ldo_io0&quot;, &quot;ips&quot;, 700, 3300, 100,</span>
 		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
 		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
<span class="p_del">-	AXP_DESC_IO(AXP22X, LDO_IO1, &quot;ldo_io1&quot;, &quot;ips&quot;, 1800, 3300, 100,</span>
<span class="p_add">+	AXP_DESC_IO(AXP22X, LDO_IO1, &quot;ldo_io1&quot;, &quot;ips&quot;, 700, 3300, 100,</span>
 		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
 		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
 	AXP_DESC_FIXED(AXP22X, RTC_LDO, &quot;rtc_ldo&quot;, &quot;ips&quot;, 3000),
<span class="p_header">diff --git a/drivers/regulator/s2mps11.c b/drivers/regulator/s2mps11.c</span>
<span class="p_header">index 72fc3c32db49..b6d831b84e1d 100644</span>
<span class="p_header">--- a/drivers/regulator/s2mps11.c</span>
<span class="p_header">+++ b/drivers/regulator/s2mps11.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static struct regulator_ops s2mps11_buck_ops = {</span>
 	.enable_mask	= S2MPS11_ENABLE_MASK			\
 }
 
<span class="p_del">-#define regulator_desc_s2mps11_buck6_10(num, min, step) {	\</span>
<span class="p_add">+#define regulator_desc_s2mps11_buck67810(num, min, step) {	\</span>
 	.name		= &quot;BUCK&quot;#num,				\
 	.id		= S2MPS11_BUCK##num,			\
 	.ops		= &amp;s2mps11_buck_ops,			\
<span class="p_chunk">@@ -321,6 +321,22 @@</span> <span class="p_context"> static struct regulator_ops s2mps11_buck_ops = {</span>
 	.enable_mask	= S2MPS11_ENABLE_MASK			\
 }
 
<span class="p_add">+#define regulator_desc_s2mps11_buck9 {				\</span>
<span class="p_add">+	.name		= &quot;BUCK9&quot;,				\</span>
<span class="p_add">+	.id		= S2MPS11_BUCK9,			\</span>
<span class="p_add">+	.ops		= &amp;s2mps11_buck_ops,			\</span>
<span class="p_add">+	.type		= REGULATOR_VOLTAGE,			\</span>
<span class="p_add">+	.owner		= THIS_MODULE,				\</span>
<span class="p_add">+	.min_uV		= MIN_3000_MV,				\</span>
<span class="p_add">+	.uV_step	= STEP_25_MV,				\</span>
<span class="p_add">+	.n_voltages	= S2MPS11_BUCK9_N_VOLTAGES,		\</span>
<span class="p_add">+	.ramp_delay	= S2MPS11_RAMP_DELAY,			\</span>
<span class="p_add">+	.vsel_reg	= S2MPS11_REG_B9CTRL2,			\</span>
<span class="p_add">+	.vsel_mask	= S2MPS11_BUCK9_VSEL_MASK,		\</span>
<span class="p_add">+	.enable_reg	= S2MPS11_REG_B9CTRL1,			\</span>
<span class="p_add">+	.enable_mask	= S2MPS11_ENABLE_MASK			\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct regulator_desc s2mps11_regulators[] = {
 	regulator_desc_s2mps11_ldo(1, STEP_25_MV),
 	regulator_desc_s2mps11_ldo(2, STEP_50_MV),
<span class="p_chunk">@@ -365,11 +381,11 @@</span> <span class="p_context"> static const struct regulator_desc s2mps11_regulators[] = {</span>
 	regulator_desc_s2mps11_buck1_4(3),
 	regulator_desc_s2mps11_buck1_4(4),
 	regulator_desc_s2mps11_buck5,
<span class="p_del">-	regulator_desc_s2mps11_buck6_10(6, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_del">-	regulator_desc_s2mps11_buck6_10(7, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_del">-	regulator_desc_s2mps11_buck6_10(8, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_del">-	regulator_desc_s2mps11_buck6_10(9, MIN_3000_MV, STEP_25_MV),</span>
<span class="p_del">-	regulator_desc_s2mps11_buck6_10(10, MIN_750_MV, STEP_12_5_MV),</span>
<span class="p_add">+	regulator_desc_s2mps11_buck67810(6, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_add">+	regulator_desc_s2mps11_buck67810(7, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_add">+	regulator_desc_s2mps11_buck67810(8, MIN_600_MV, STEP_6_25_MV),</span>
<span class="p_add">+	regulator_desc_s2mps11_buck9,</span>
<span class="p_add">+	regulator_desc_s2mps11_buck67810(10, MIN_750_MV, STEP_12_5_MV),</span>
 };
 
 static struct regulator_ops s2mps14_reg_ops;
<span class="p_header">diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c</span>
<span class="p_header">index 5d0ec42a9317..634254a52301 100644</span>
<span class="p_header">--- a/drivers/scsi/qla1280.c</span>
<span class="p_header">+++ b/drivers/scsi/qla1280.c</span>
<span class="p_chunk">@@ -4214,7 +4214,7 @@</span> <span class="p_context"> static struct scsi_host_template qla1280_driver_template = {</span>
 	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
 	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
 	.bios_param		= qla1280_biosparam,
<span class="p_del">-	.can_queue		= 0xfffff,</span>
<span class="p_add">+	.can_queue		= MAX_OUTSTANDING_COMMANDS,</span>
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
 	.use_clustering		= ENABLE_CLUSTERING,
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index b25dc71b0ea9..73c8ea0b1360 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static const struct lpss_config lpss_platforms[] = {</span>
 		.reg_general = -1,
 		.reg_ssp = 0x20,
 		.reg_cs_ctrl = 0x24,
<span class="p_del">-		.reg_capabilities = 0xfc,</span>
<span class="p_add">+		.reg_capabilities = -1,</span>
 		.rx_threshold = 1,
 		.tx_threshold_lo = 32,
 		.tx_threshold_hi = 56,
<span class="p_header">diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c</span>
<span class="p_header">index 64318fcfacf2..5044c6198332 100644</span>
<span class="p_header">--- a/drivers/spi/spi-ti-qspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-ti-qspi.c</span>
<span class="p_chunk">@@ -94,6 +94,7 @@</span> <span class="p_context"> struct ti_qspi {</span>
 #define QSPI_FLEN(n)			((n - 1) &lt;&lt; 0)
 #define QSPI_WLEN_MAX_BITS		128
 #define QSPI_WLEN_MAX_BYTES		16
<span class="p_add">+#define QSPI_WLEN_MASK			QSPI_WLEN(QSPI_WLEN_MAX_BITS)</span>
 
 /* STATUS REGISTER */
 #define BUSY				0x01
<span class="p_chunk">@@ -224,16 +225,16 @@</span> <span class="p_context"> static inline int ti_qspi_poll_wc(struct ti_qspi *qspi)</span>
 	return  -ETIMEDOUT;
 }
 
<span class="p_del">-static int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
<span class="p_add">+static int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t,</span>
<span class="p_add">+			  int count)</span>
 {
<span class="p_del">-	int wlen, count, xfer_len;</span>
<span class="p_add">+	int wlen, xfer_len;</span>
 	unsigned int cmd;
 	const u8 *txbuf;
 	u32 data;
 
 	txbuf = t-&gt;tx_buf;
 	cmd = qspi-&gt;cmd | QSPI_WR_SNGL;
<span class="p_del">-	count = t-&gt;len;</span>
 	wlen = t-&gt;bits_per_word &gt;&gt; 3;	/* in bytes */
 	xfer_len = wlen;
 
<span class="p_chunk">@@ -293,9 +294,10 @@</span> <span class="p_context"> static int qspi_write_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
 	return 0;
 }
 
<span class="p_del">-static int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
<span class="p_add">+static int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t,</span>
<span class="p_add">+			 int count)</span>
 {
<span class="p_del">-	int wlen, count;</span>
<span class="p_add">+	int wlen;</span>
 	unsigned int cmd;
 	u8 *rxbuf;
 
<span class="p_chunk">@@ -312,7 +314,6 @@</span> <span class="p_context"> static int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
 		cmd |= QSPI_RD_SNGL;
 		break;
 	}
<span class="p_del">-	count = t-&gt;len;</span>
 	wlen = t-&gt;bits_per_word &gt;&gt; 3;	/* in bytes */
 
 	while (count) {
<span class="p_chunk">@@ -343,12 +344,13 @@</span> <span class="p_context"> static int qspi_read_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
 	return 0;
 }
 
<span class="p_del">-static int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
<span class="p_add">+static int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t,</span>
<span class="p_add">+			     int count)</span>
 {
 	int ret;
 
 	if (t-&gt;tx_buf) {
<span class="p_del">-		ret = qspi_write_msg(qspi, t);</span>
<span class="p_add">+		ret = qspi_write_msg(qspi, t, count);</span>
 		if (ret) {
 			dev_dbg(qspi-&gt;dev, &quot;Error while writing\n&quot;);
 			return ret;
<span class="p_chunk">@@ -356,7 +358,7 @@</span> <span class="p_context"> static int qspi_transfer_msg(struct ti_qspi *qspi, struct spi_transfer *t)</span>
 	}
 
 	if (t-&gt;rx_buf) {
<span class="p_del">-		ret = qspi_read_msg(qspi, t);</span>
<span class="p_add">+		ret = qspi_read_msg(qspi, t, count);</span>
 		if (ret) {
 			dev_dbg(qspi-&gt;dev, &quot;Error while reading\n&quot;);
 			return ret;
<span class="p_chunk">@@ -373,7 +375,8 @@</span> <span class="p_context"> static int ti_qspi_start_transfer_one(struct spi_master *master,</span>
 	struct spi_device *spi = m-&gt;spi;
 	struct spi_transfer *t;
 	int status = 0, ret;
<span class="p_del">-	int frame_length;</span>
<span class="p_add">+	unsigned int frame_len_words, transfer_len_words;</span>
<span class="p_add">+	int wlen;</span>
 
 	/* setup device control reg */
 	qspi-&gt;dc = 0;
<span class="p_chunk">@@ -385,30 +388,38 @@</span> <span class="p_context"> static int ti_qspi_start_transfer_one(struct spi_master *master,</span>
 	if (spi-&gt;mode &amp; SPI_CS_HIGH)
 		qspi-&gt;dc |= QSPI_CSPOL(spi-&gt;chip_select);
 
<span class="p_del">-	frame_length = (m-&gt;frame_length &lt;&lt; 3) / spi-&gt;bits_per_word;</span>
<span class="p_del">-</span>
<span class="p_del">-	frame_length = clamp(frame_length, 0, QSPI_FRAME);</span>
<span class="p_add">+	frame_len_words = 0;</span>
<span class="p_add">+	list_for_each_entry(t, &amp;m-&gt;transfers, transfer_list)</span>
<span class="p_add">+		frame_len_words += t-&gt;len / (t-&gt;bits_per_word &gt;&gt; 3);</span>
<span class="p_add">+	frame_len_words = min_t(unsigned int, frame_len_words, QSPI_FRAME);</span>
 
 	/* setup command reg */
 	qspi-&gt;cmd = 0;
 	qspi-&gt;cmd |= QSPI_EN_CS(spi-&gt;chip_select);
<span class="p_del">-	qspi-&gt;cmd |= QSPI_FLEN(frame_length);</span>
<span class="p_add">+	qspi-&gt;cmd |= QSPI_FLEN(frame_len_words);</span>
 
 	ti_qspi_write(qspi, qspi-&gt;dc, QSPI_SPI_DC_REG);
 
 	mutex_lock(&amp;qspi-&gt;list_lock);
 
 	list_for_each_entry(t, &amp;m-&gt;transfers, transfer_list) {
<span class="p_del">-		qspi-&gt;cmd |= QSPI_WLEN(t-&gt;bits_per_word);</span>
<span class="p_add">+		qspi-&gt;cmd = ((qspi-&gt;cmd &amp; ~QSPI_WLEN_MASK) |</span>
<span class="p_add">+			     QSPI_WLEN(t-&gt;bits_per_word));</span>
<span class="p_add">+</span>
<span class="p_add">+		wlen = t-&gt;bits_per_word &gt;&gt; 3;</span>
<span class="p_add">+		transfer_len_words = min(t-&gt;len / wlen, frame_len_words);</span>
 
<span class="p_del">-		ret = qspi_transfer_msg(qspi, t);</span>
<span class="p_add">+		ret = qspi_transfer_msg(qspi, t, transfer_len_words * wlen);</span>
 		if (ret) {
 			dev_dbg(qspi-&gt;dev, &quot;transfer message failed\n&quot;);
 			mutex_unlock(&amp;qspi-&gt;list_lock);
 			return -EINVAL;
 		}
 
<span class="p_del">-		m-&gt;actual_length += t-&gt;len;</span>
<span class="p_add">+		m-&gt;actual_length += transfer_len_words * wlen;</span>
<span class="p_add">+		frame_len_words -= transfer_len_words;</span>
<span class="p_add">+		if (frame_len_words == 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	mutex_unlock(&amp;qspi-&gt;list_lock);
<span class="p_header">diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c</span>
<span class="p_header">index 735d7522a3a9..204659a5f6db 100644</span>
<span class="p_header">--- a/fs/isofs/rock.c</span>
<span class="p_header">+++ b/fs/isofs/rock.c</span>
<span class="p_chunk">@@ -203,6 +203,8 @@</span> <span class="p_context"> int get_rock_ridge_filename(struct iso_directory_record *de,</span>
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
<span class="p_add">+	char *p;</span>
<span class="p_add">+	int len;</span>
 
 	if (!ISOFS_SB(inode-&gt;i_sb)-&gt;s_rock)
 		return 0;
<span class="p_chunk">@@ -267,12 +269,17 @@</span> <span class="p_context"> repeat:</span>
 					rr-&gt;u.NM.flags);
 				break;
 			}
<span class="p_del">-			if ((strlen(retname) + rr-&gt;len - 5) &gt;= 254) {</span>
<span class="p_add">+			len = rr-&gt;len - 5;</span>
<span class="p_add">+			if (retnamlen + len &gt;= 254) {</span>
 				truncate = 1;
 				break;
 			}
<span class="p_del">-			strncat(retname, rr-&gt;u.NM.name, rr-&gt;len - 5);</span>
<span class="p_del">-			retnamlen += rr-&gt;len - 5;</span>
<span class="p_add">+			p = memchr(rr-&gt;u.NM.name, &#39;\0&#39;, len);</span>
<span class="p_add">+			if (unlikely(p))</span>
<span class="p_add">+				len = p - rr-&gt;u.NM.name;</span>
<span class="p_add">+			memcpy(retname + retnamlen, rr-&gt;u.NM.name, len);</span>
<span class="p_add">+			retnamlen += len;</span>
<span class="p_add">+			retname[retnamlen] = &#39;\0&#39;;</span>
 			break;
 		case SIG(&#39;R&#39;, &#39;E&#39;):
 			kfree(rs.buffer);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index d8ee4da93650..209ca7737cb2 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -2906,22 +2906,10 @@</span> <span class="p_context"> no_open:</span>
 		dentry = lookup_real(dir, dentry, nd-&gt;flags);
 		if (IS_ERR(dentry))
 			return PTR_ERR(dentry);
<span class="p_del">-</span>
<span class="p_del">-		if (create_error) {</span>
<span class="p_del">-			int open_flag = op-&gt;open_flag;</span>
<span class="p_del">-</span>
<span class="p_del">-			error = create_error;</span>
<span class="p_del">-			if ((open_flag &amp; O_EXCL)) {</span>
<span class="p_del">-				if (!dentry-&gt;d_inode)</span>
<span class="p_del">-					goto out;</span>
<span class="p_del">-			} else if (!dentry-&gt;d_inode) {</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			} else if ((open_flag &amp; O_TRUNC) &amp;&amp;</span>
<span class="p_del">-				   d_is_reg(dentry)) {</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			/* will fail later, go on to get the right error */</span>
<span class="p_del">-		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (create_error &amp;&amp; !dentry-&gt;d_inode) {</span>
<span class="p_add">+		error = create_error;</span>
<span class="p_add">+		goto out;</span>
 	}
 looked_up:
 	path-&gt;dentry = dentry;
<span class="p_chunk">@@ -4195,7 +4183,11 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	bool new_is_dir = false;
 	unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links;
 
<span class="p_del">-	if (source == target)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check source == target.</span>
<span class="p_add">+	 * On overlayfs need to look at underlying inodes.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))</span>
 		return 0;
 
 	error = may_delete(old_dir, old_dentry, is_dir);
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 0cdf497c91ef..2162434728c0 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -322,3 +322,90 @@</span> <span class="p_context"> struct posix_acl *ocfs2_iop_get_acl(struct inode *inode, int type)</span>
 	brelse(di_bh);
 	return acl;
 }
<span class="p_add">+</span>
<span class="p_add">+int ocfs2_acl_chmod(struct inode *inode, struct buffer_head *bh)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);</span>
<span class="p_add">+	struct posix_acl *acl;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (S_ISLNK(inode-&gt;i_mode))</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(osb-&gt;s_mount_opt &amp; OCFS2_MOUNT_POSIX_ACL))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	acl = ocfs2_get_acl_nolock(inode, ACL_TYPE_ACCESS, bh);</span>
<span class="p_add">+	if (IS_ERR(acl) || !acl)</span>
<span class="p_add">+		return PTR_ERR(acl);</span>
<span class="p_add">+	ret = __posix_acl_chmod(&amp;acl, GFP_KERNEL, inode-&gt;i_mode);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	ret = ocfs2_set_acl(NULL, inode, NULL, ACL_TYPE_ACCESS,</span>
<span class="p_add">+			    acl, NULL, NULL);</span>
<span class="p_add">+	posix_acl_release(acl);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Initialize the ACLs of a new inode. If parent directory has default ACL,</span>
<span class="p_add">+ * then clone to new inode. Called from ocfs2_mknod.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int ocfs2_init_acl(handle_t *handle,</span>
<span class="p_add">+		   struct inode *inode,</span>
<span class="p_add">+		   struct inode *dir,</span>
<span class="p_add">+		   struct buffer_head *di_bh,</span>
<span class="p_add">+		   struct buffer_head *dir_bh,</span>
<span class="p_add">+		   struct ocfs2_alloc_context *meta_ac,</span>
<span class="p_add">+		   struct ocfs2_alloc_context *data_ac)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);</span>
<span class="p_add">+	struct posix_acl *acl = NULL;</span>
<span class="p_add">+	int ret = 0, ret2;</span>
<span class="p_add">+	umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!S_ISLNK(inode-&gt;i_mode)) {</span>
<span class="p_add">+		if (osb-&gt;s_mount_opt &amp; OCFS2_MOUNT_POSIX_ACL) {</span>
<span class="p_add">+			acl = ocfs2_get_acl_nolock(dir, ACL_TYPE_DEFAULT,</span>
<span class="p_add">+						   dir_bh);</span>
<span class="p_add">+			if (IS_ERR(acl))</span>
<span class="p_add">+				return PTR_ERR(acl);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!acl) {</span>
<span class="p_add">+			mode = inode-&gt;i_mode &amp; ~current_umask();</span>
<span class="p_add">+			ret = ocfs2_acl_set_mode(inode, di_bh, handle, mode);</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				mlog_errno(ret);</span>
<span class="p_add">+				goto cleanup;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if ((osb-&gt;s_mount_opt &amp; OCFS2_MOUNT_POSIX_ACL) &amp;&amp; acl) {</span>
<span class="p_add">+		if (S_ISDIR(inode-&gt;i_mode)) {</span>
<span class="p_add">+			ret = ocfs2_set_acl(handle, inode, di_bh,</span>
<span class="p_add">+					    ACL_TYPE_DEFAULT, acl,</span>
<span class="p_add">+					    meta_ac, data_ac);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				goto cleanup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mode = inode-&gt;i_mode;</span>
<span class="p_add">+		ret = __posix_acl_create(&amp;acl, GFP_NOFS, &amp;mode);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret2 = ocfs2_acl_set_mode(inode, di_bh, handle, mode);</span>
<span class="p_add">+		if (ret2) {</span>
<span class="p_add">+			mlog_errno(ret2);</span>
<span class="p_add">+			ret = ret2;</span>
<span class="p_add">+			goto cleanup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (ret &gt; 0) {</span>
<span class="p_add">+			ret = ocfs2_set_acl(handle, inode,</span>
<span class="p_add">+					    di_bh, ACL_TYPE_ACCESS,</span>
<span class="p_add">+					    acl, meta_ac, data_ac);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+cleanup:</span>
<span class="p_add">+	posix_acl_release(acl);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/ocfs2/acl.h b/fs/ocfs2/acl.h</span>
<span class="p_header">index 3fce68d08625..2783a75b3999 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.h</span>
<span class="p_header">+++ b/fs/ocfs2/acl.h</span>
<span class="p_chunk">@@ -35,5 +35,10 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 			 struct posix_acl *acl,
 			 struct ocfs2_alloc_context *meta_ac,
 			 struct ocfs2_alloc_context *data_ac);
<span class="p_add">+extern int ocfs2_acl_chmod(struct inode *, struct buffer_head *);</span>
<span class="p_add">+extern int ocfs2_init_acl(handle_t *, struct inode *, struct inode *,</span>
<span class="p_add">+			  struct buffer_head *, struct buffer_head *,</span>
<span class="p_add">+			  struct ocfs2_alloc_context *,</span>
<span class="p_add">+			  struct ocfs2_alloc_context *);</span>
 
 #endif /* OCFS2_ACL_H */
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 0e5b4515f92e..77d30cbd944d 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1268,20 +1268,20 @@</span> <span class="p_context"> bail_unlock_rw:</span>
 	if (size_change)
 		ocfs2_rw_unlock(inode, 1);
 bail:
<span class="p_del">-	brelse(bh);</span>
 
 	/* Release quota pointers in case we acquired them */
 	for (qtype = 0; qtype &lt; OCFS2_MAXQUOTAS; qtype++)
 		dqput(transfer_to[qtype]);
 
 	if (!status &amp;&amp; attr-&gt;ia_valid &amp; ATTR_MODE) {
<span class="p_del">-		status = posix_acl_chmod(inode, inode-&gt;i_mode);</span>
<span class="p_add">+		status = ocfs2_acl_chmod(inode, bh);</span>
 		if (status &lt; 0)
 			mlog_errno(status);
 	}
 	if (inode_locked)
 		ocfs2_inode_unlock(inode, 1);
 
<span class="p_add">+	brelse(bh);</span>
 	return status;
 }
 
<span class="p_header">diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c</span>
<span class="p_header">index 3123408da935..62af9554541d 100644</span>
<span class="p_header">--- a/fs/ocfs2/namei.c</span>
<span class="p_header">+++ b/fs/ocfs2/namei.c</span>
<span class="p_chunk">@@ -259,7 +259,6 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 	struct ocfs2_dir_lookup_result lookup = { NULL, };
 	sigset_t oldset;
 	int did_block_signals = 0;
<span class="p_del">-	struct posix_acl *default_acl = NULL, *acl = NULL;</span>
 	struct ocfs2_dentry_lock *dl = NULL;
 
 	trace_ocfs2_mknod(dir, dentry, dentry-&gt;d_name.len, dentry-&gt;d_name.name,
<span class="p_chunk">@@ -367,12 +366,6 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		goto leave;
 	}
 
<span class="p_del">-	status = posix_acl_create(dir, &amp;inode-&gt;i_mode, &amp;default_acl, &amp;acl);</span>
<span class="p_del">-	if (status) {</span>
<span class="p_del">-		mlog_errno(status);</span>
<span class="p_del">-		goto leave;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	handle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb-&gt;sb,
 							    S_ISDIR(mode),
 							    xattr_credits));
<span class="p_chunk">@@ -421,16 +414,8 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		inc_nlink(dir);
 	}
 
<span class="p_del">-	if (default_acl) {</span>
<span class="p_del">-		status = ocfs2_set_acl(handle, inode, new_fe_bh,</span>
<span class="p_del">-				       ACL_TYPE_DEFAULT, default_acl,</span>
<span class="p_del">-				       meta_ac, data_ac);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!status &amp;&amp; acl) {</span>
<span class="p_del">-		status = ocfs2_set_acl(handle, inode, new_fe_bh,</span>
<span class="p_del">-				       ACL_TYPE_ACCESS, acl,</span>
<span class="p_del">-				       meta_ac, data_ac);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	status = ocfs2_init_acl(handle, inode, dir, new_fe_bh, parent_fe_bh,</span>
<span class="p_add">+			 meta_ac, data_ac);</span>
 
 	if (status &lt; 0) {
 		mlog_errno(status);
<span class="p_chunk">@@ -472,10 +457,6 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 	d_instantiate(dentry, inode);
 	status = 0;
 leave:
<span class="p_del">-	if (default_acl)</span>
<span class="p_del">-		posix_acl_release(default_acl);</span>
<span class="p_del">-	if (acl)</span>
<span class="p_del">-		posix_acl_release(acl);</span>
 	if (status &lt; 0 &amp;&amp; did_quota_inode)
 		dquot_free_inode(inode);
 	if (handle)
<span class="p_header">diff --git a/fs/ocfs2/refcounttree.c b/fs/ocfs2/refcounttree.c</span>
<span class="p_header">index 252119860e6c..6a0c55d7dff0 100644</span>
<span class="p_header">--- a/fs/ocfs2/refcounttree.c</span>
<span class="p_header">+++ b/fs/ocfs2/refcounttree.c</span>
<span class="p_chunk">@@ -4248,20 +4248,12 @@</span> <span class="p_context"> static int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,</span>
 	struct inode *inode = d_inode(old_dentry);
 	struct buffer_head *old_bh = NULL;
 	struct inode *new_orphan_inode = NULL;
<span class="p_del">-	struct posix_acl *default_acl, *acl;</span>
<span class="p_del">-	umode_t mode;</span>
 
 	if (!ocfs2_refcount_tree(OCFS2_SB(inode-&gt;i_sb)))
 		return -EOPNOTSUPP;
 
<span class="p_del">-	mode = inode-&gt;i_mode;</span>
<span class="p_del">-	error = posix_acl_create(dir, &amp;mode, &amp;default_acl, &amp;acl);</span>
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		mlog_errno(error);</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	error = ocfs2_create_inode_in_orphan(dir, mode,</span>
<span class="p_add">+	error = ocfs2_create_inode_in_orphan(dir, inode-&gt;i_mode,</span>
 					     &amp;new_orphan_inode);
 	if (error) {
 		mlog_errno(error);
<span class="p_chunk">@@ -4300,16 +4292,11 @@</span> <span class="p_context"> static int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,</span>
 	/* If the security isn&#39;t preserved, we need to re-initialize them. */
 	if (!preserve) {
 		error = ocfs2_init_security_and_acl(dir, new_orphan_inode,
<span class="p_del">-						    &amp;new_dentry-&gt;d_name,</span>
<span class="p_del">-						    default_acl, acl);</span>
<span class="p_add">+						    &amp;new_dentry-&gt;d_name);</span>
 		if (error)
 			mlog_errno(error);
 	}
 out:
<span class="p_del">-	if (default_acl)</span>
<span class="p_del">-		posix_acl_release(default_acl);</span>
<span class="p_del">-	if (acl)</span>
<span class="p_del">-		posix_acl_release(acl);</span>
 	if (!error) {
 		error = ocfs2_mv_orphaned_inode_to_new(dir, new_orphan_inode,
 						       new_dentry);
<span class="p_header">diff --git a/fs/ocfs2/xattr.c b/fs/ocfs2/xattr.c</span>
<span class="p_header">index e9164f09841b..877830b05e12 100644</span>
<span class="p_header">--- a/fs/ocfs2/xattr.c</span>
<span class="p_header">+++ b/fs/ocfs2/xattr.c</span>
<span class="p_chunk">@@ -7197,12 +7197,10 @@</span> <span class="p_context"> out:</span>
  */
 int ocfs2_init_security_and_acl(struct inode *dir,
 				struct inode *inode,
<span class="p_del">-				const struct qstr *qstr,</span>
<span class="p_del">-				struct posix_acl *default_acl,</span>
<span class="p_del">-				struct posix_acl *acl)</span>
<span class="p_add">+				const struct qstr *qstr)</span>
 {
<span class="p_del">-	struct buffer_head *dir_bh = NULL;</span>
 	int ret = 0;
<span class="p_add">+	struct buffer_head *dir_bh = NULL;</span>
 
 	ret = ocfs2_init_security_get(inode, dir, qstr, NULL);
 	if (ret) {
<span class="p_chunk">@@ -7215,11 +7213,9 @@</span> <span class="p_context"> int ocfs2_init_security_and_acl(struct inode *dir,</span>
 		mlog_errno(ret);
 		goto leave;
 	}
<span class="p_del">-</span>
<span class="p_del">-	if (!ret &amp;&amp; default_acl)</span>
<span class="p_del">-		ret = ocfs2_iop_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);</span>
<span class="p_del">-	if (!ret &amp;&amp; acl)</span>
<span class="p_del">-		ret = ocfs2_iop_set_acl(inode, acl, ACL_TYPE_ACCESS);</span>
<span class="p_add">+	ret = ocfs2_init_acl(NULL, inode, dir, NULL, dir_bh, NULL, NULL);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		mlog_errno(ret);</span>
 
 	ocfs2_inode_unlock(dir, 0);
 	brelse(dir_bh);
<span class="p_header">diff --git a/fs/ocfs2/xattr.h b/fs/ocfs2/xattr.h</span>
<span class="p_header">index f10d5b93c366..1633cc15ea1f 100644</span>
<span class="p_header">--- a/fs/ocfs2/xattr.h</span>
<span class="p_header">+++ b/fs/ocfs2/xattr.h</span>
<span class="p_chunk">@@ -94,7 +94,5 @@</span> <span class="p_context"> int ocfs2_reflink_xattrs(struct inode *old_inode,</span>
 			 bool preserve_security);
 int ocfs2_init_security_and_acl(struct inode *dir,
 				struct inode *inode,
<span class="p_del">-				const struct qstr *qstr,</span>
<span class="p_del">-				struct posix_acl *default_acl,</span>
<span class="p_del">-				struct posix_acl *acl);</span>
<span class="p_add">+				const struct qstr *qstr);</span>
 #endif /* OCFS2_XATTR_H */
<span class="p_header">diff --git a/fs/open.c b/fs/open.c</span>
<span class="p_header">index 6a24f988d253..157b9940dd73 100644</span>
<span class="p_header">--- a/fs/open.c</span>
<span class="p_header">+++ b/fs/open.c</span>
<span class="p_chunk">@@ -840,16 +840,12 @@</span> <span class="p_context"> EXPORT_SYMBOL(file_path);</span>
 int vfs_open(const struct path *path, struct file *file,
 	     const struct cred *cred)
 {
<span class="p_del">-	struct dentry *dentry = path-&gt;dentry;</span>
<span class="p_del">-	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct inode *inode = vfs_select_inode(path-&gt;dentry, file-&gt;f_flags);</span>
 
<span class="p_del">-	file-&gt;f_path = *path;</span>
<span class="p_del">-	if (dentry-&gt;d_flags &amp; DCACHE_OP_SELECT_INODE) {</span>
<span class="p_del">-		inode = dentry-&gt;d_op-&gt;d_select_inode(dentry, file-&gt;f_flags);</span>
<span class="p_del">-		if (IS_ERR(inode))</span>
<span class="p_del">-			return PTR_ERR(inode);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (IS_ERR(inode))</span>
<span class="p_add">+		return PTR_ERR(inode);</span>
 
<span class="p_add">+	file-&gt;f_path = *path;</span>
 	return do_dentry_open(file, inode, NULL, cred);
 }
 
<span class="p_header">diff --git a/include/linux/bpf.h b/include/linux/bpf.h</span>
<span class="p_header">index 83d1926c61e4..67bc2da5d233 100644</span>
<span class="p_header">--- a/include/linux/bpf.h</span>
<span class="p_header">+++ b/include/linux/bpf.h</span>
<span class="p_chunk">@@ -165,12 +165,13 @@</span> <span class="p_context"> void bpf_register_prog_type(struct bpf_prog_type_list *tl);</span>
 void bpf_register_map_type(struct bpf_map_type_list *tl);
 
 struct bpf_prog *bpf_prog_get(u32 ufd);
<span class="p_add">+struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog);</span>
 void bpf_prog_put(struct bpf_prog *prog);
 void bpf_prog_put_rcu(struct bpf_prog *prog);
 
 struct bpf_map *bpf_map_get_with_uref(u32 ufd);
 struct bpf_map *__bpf_map_get(struct fd f);
<span class="p_del">-void bpf_map_inc(struct bpf_map *map, bool uref);</span>
<span class="p_add">+struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);</span>
 void bpf_map_put_with_uref(struct bpf_map *map);
 void bpf_map_put(struct bpf_map *map);
 
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index f513dd855cb2..d81746d3b2da 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -592,4 +592,16 @@</span> <span class="p_context"> static inline struct dentry *d_real(struct dentry *dentry)</span>
 		return dentry;
 }
 
<span class="p_add">+static inline struct inode *vfs_select_inode(struct dentry *dentry,</span>
<span class="p_add">+					     unsigned open_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = d_inode(dentry);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (inode &amp;&amp; unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_SELECT_INODE))</span>
<span class="p_add">+		inode = dentry-&gt;d_op-&gt;d_select_inode(dentry, open_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return inode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/mfd/samsung/s2mps11.h b/include/linux/mfd/samsung/s2mps11.h</span>
<span class="p_header">index b288965e8101..2c14eeca46f0 100644</span>
<span class="p_header">--- a/include/linux/mfd/samsung/s2mps11.h</span>
<span class="p_header">+++ b/include/linux/mfd/samsung/s2mps11.h</span>
<span class="p_chunk">@@ -173,10 +173,12 @@</span> <span class="p_context"> enum s2mps11_regulators {</span>
 
 #define S2MPS11_LDO_VSEL_MASK	0x3F
 #define S2MPS11_BUCK_VSEL_MASK	0xFF
<span class="p_add">+#define S2MPS11_BUCK9_VSEL_MASK	0x1F</span>
 #define S2MPS11_ENABLE_MASK	(0x03 &lt;&lt; S2MPS11_ENABLE_SHIFT)
 #define S2MPS11_ENABLE_SHIFT	0x06
 #define S2MPS11_LDO_N_VOLTAGES	(S2MPS11_LDO_VSEL_MASK + 1)
 #define S2MPS11_BUCK_N_VOLTAGES (S2MPS11_BUCK_VSEL_MASK + 1)
<span class="p_add">+#define S2MPS11_BUCK9_N_VOLTAGES (S2MPS11_BUCK9_VSEL_MASK + 1)</span>
 #define S2MPS11_RAMP_DELAY	25000		/* uV/us */
 
 #define S2MPS11_CTRL1_PWRHOLD_MASK	BIT(4)
<span class="p_header">diff --git a/include/linux/mlx5/driver.h b/include/linux/mlx5/driver.h</span>
<span class="p_header">index af3efd9157f0..412aa988c6ad 100644</span>
<span class="p_header">--- a/include/linux/mlx5/driver.h</span>
<span class="p_header">+++ b/include/linux/mlx5/driver.h</span>
<span class="p_chunk">@@ -792,9 +792,9 @@</span> <span class="p_context"> int mlx5_set_port_admin_status(struct mlx5_core_dev *dev,</span>
 int mlx5_query_port_admin_status(struct mlx5_core_dev *dev,
 				 enum mlx5_port_status *status);
 
<span class="p_del">-int mlx5_set_port_mtu(struct mlx5_core_dev *dev, int mtu, u8 port);</span>
<span class="p_del">-void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu, u8 port);</span>
<span class="p_del">-void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu,</span>
<span class="p_add">+int mlx5_set_port_mtu(struct mlx5_core_dev *dev, u16 mtu, u8 port);</span>
<span class="p_add">+void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, u16 *max_mtu, u8 port);</span>
<span class="p_add">+void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, u16 *oper_mtu,</span>
 			      u8 port);
 
 int mlx5_query_port_vl_hw_cap(struct mlx5_core_dev *dev,
<span class="p_header">diff --git a/include/linux/net.h b/include/linux/net.h</span>
<span class="p_header">index 0b4ac7da583a..25ef630f1bd6 100644</span>
<span class="p_header">--- a/include/linux/net.h</span>
<span class="p_header">+++ b/include/linux/net.h</span>
<span class="p_chunk">@@ -245,7 +245,15 @@</span> <span class="p_context"> do {								\</span>
 	net_ratelimited_function(pr_warn, fmt, ##__VA_ARGS__)
 #define net_info_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_info, fmt, ##__VA_ARGS__)
<span class="p_del">-#if defined(DEBUG)</span>
<span class="p_add">+#if defined(CONFIG_DYNAMIC_DEBUG)</span>
<span class="p_add">+#define net_dbg_ratelimited(fmt, ...)					\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);			\</span>
<span class="p_add">+	if (unlikely(descriptor.flags &amp; _DPRINTK_FLAGS_PRINT) &amp;&amp;	\</span>
<span class="p_add">+	    net_ratelimit())						\</span>
<span class="p_add">+		__dynamic_pr_debug(&amp;descriptor, fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#elif defined(DEBUG)</span>
 #define net_dbg_ratelimited(fmt, ...)				\
 	net_ratelimited_function(pr_debug, fmt, ##__VA_ARGS__)
 #else
<span class="p_header">diff --git a/include/net/codel.h b/include/net/codel.h</span>
<span class="p_header">index 267e70210061..d168aca115cc 100644</span>
<span class="p_header">--- a/include/net/codel.h</span>
<span class="p_header">+++ b/include/net/codel.h</span>
<span class="p_chunk">@@ -162,12 +162,14 @@</span> <span class="p_context"> struct codel_vars {</span>
  * struct codel_stats - contains codel shared variables and stats
  * @maxpacket:	largest packet we&#39;ve seen so far
  * @drop_count:	temp count of dropped packets in dequeue()
<span class="p_add">+ * @drop_len:	bytes of dropped packets in dequeue()</span>
  * ecn_mark:	number of packets we ECN marked instead of dropping
  * ce_mark:	number of packets CE marked because sojourn time was above ce_threshold
  */
 struct codel_stats {
 	u32		maxpacket;
 	u32		drop_count;
<span class="p_add">+	u32		drop_len;</span>
 	u32		ecn_mark;
 	u32		ce_mark;
 };
<span class="p_chunk">@@ -308,6 +310,7 @@</span> <span class="p_context"> static struct sk_buff *codel_dequeue(struct Qdisc *sch,</span>
 								  vars-&gt;rec_inv_sqrt);
 					goto end;
 				}
<span class="p_add">+				stats-&gt;drop_len += qdisc_pkt_len(skb);</span>
 				qdisc_drop(skb, sch);
 				stats-&gt;drop_count++;
 				skb = dequeue_func(vars, sch);
<span class="p_chunk">@@ -330,6 +333,7 @@</span> <span class="p_context"> static struct sk_buff *codel_dequeue(struct Qdisc *sch,</span>
 		if (params-&gt;ecn &amp;&amp; INET_ECN_set_ce(skb)) {
 			stats-&gt;ecn_mark++;
 		} else {
<span class="p_add">+			stats-&gt;drop_len += qdisc_pkt_len(skb);</span>
 			qdisc_drop(skb, sch);
 			stats-&gt;drop_count++;
 
<span class="p_header">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span>
<span class="p_header">index b2a8e6338576..86df0835f6b5 100644</span>
<span class="p_header">--- a/include/net/sch_generic.h</span>
<span class="p_header">+++ b/include/net/sch_generic.h</span>
<span class="p_chunk">@@ -396,7 +396,8 @@</span> <span class="p_context"> struct Qdisc *dev_graft_qdisc(struct netdev_queue *dev_queue,</span>
 			      struct Qdisc *qdisc);
 void qdisc_reset(struct Qdisc *qdisc);
 void qdisc_destroy(struct Qdisc *qdisc);
<span class="p_del">-void qdisc_tree_decrease_qlen(struct Qdisc *qdisc, unsigned int n);</span>
<span class="p_add">+void qdisc_tree_reduce_backlog(struct Qdisc *qdisc, unsigned int n,</span>
<span class="p_add">+			       unsigned int len);</span>
 struct Qdisc *qdisc_alloc(struct netdev_queue *dev_queue,
 			  const struct Qdisc_ops *ops);
 struct Qdisc *qdisc_create_dflt(struct netdev_queue *dev_queue,
<span class="p_chunk">@@ -698,6 +699,23 @@</span> <span class="p_context"> static inline void qdisc_reset_queue(struct Qdisc *sch)</span>
 	sch-&gt;qstats.backlog = 0;
 }
 
<span class="p_add">+static inline struct Qdisc *qdisc_replace(struct Qdisc *sch, struct Qdisc *new,</span>
<span class="p_add">+					  struct Qdisc **pold)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct Qdisc *old;</span>
<span class="p_add">+</span>
<span class="p_add">+	sch_tree_lock(sch);</span>
<span class="p_add">+	old = *pold;</span>
<span class="p_add">+	*pold = new;</span>
<span class="p_add">+	if (old != NULL) {</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(old, old-&gt;q.qlen, old-&gt;qstats.backlog);</span>
<span class="p_add">+		qdisc_reset(old);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	sch_tree_unlock(sch);</span>
<span class="p_add">+</span>
<span class="p_add">+	return old;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned int __qdisc_queue_drop(struct Qdisc *sch,
 					      struct sk_buff_head *list)
 {
<span class="p_header">diff --git a/include/uapi/linux/if.h b/include/uapi/linux/if.h</span>
<span class="p_header">index 9cf2394f0bcf..752f5dc040a5 100644</span>
<span class="p_header">--- a/include/uapi/linux/if.h</span>
<span class="p_header">+++ b/include/uapi/linux/if.h</span>
<span class="p_chunk">@@ -19,14 +19,20 @@</span> <span class="p_context"></span>
 #ifndef _LINUX_IF_H
 #define _LINUX_IF_H
 
<span class="p_add">+#include &lt;linux/libc-compat.h&gt;          /* for compatibility with glibc */</span>
 #include &lt;linux/types.h&gt;		/* for &quot;__kernel_caddr_t&quot; et al	*/
 #include &lt;linux/socket.h&gt;		/* for &quot;struct sockaddr&quot; et al	*/
 #include &lt;linux/compiler.h&gt;		/* for &quot;__user&quot; et al           */
 
<span class="p_add">+#if __UAPI_DEF_IF_IFNAMSIZ</span>
 #define	IFNAMSIZ	16
<span class="p_add">+#endif /* __UAPI_DEF_IF_IFNAMSIZ */</span>
 #define	IFALIASZ	256
 #include &lt;linux/hdlc/ioctl.h&gt;
 
<span class="p_add">+/* For glibc compatibility. An empty enum does not compile. */</span>
<span class="p_add">+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 &amp;&amp; \</span>
<span class="p_add">+    __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0</span>
 /**
  * enum net_device_flags - &amp;struct net_device flags
  *
<span class="p_chunk">@@ -68,6 +74,8 @@</span> <span class="p_context"></span>
  * @IFF_ECHO: echo sent packets. Volatile.
  */
 enum net_device_flags {
<span class="p_add">+/* for compatibility with glibc net/if.h */</span>
<span class="p_add">+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS</span>
 	IFF_UP				= 1&lt;&lt;0,  /* sysfs */
 	IFF_BROADCAST			= 1&lt;&lt;1,  /* volatile */
 	IFF_DEBUG			= 1&lt;&lt;2,  /* sysfs */
<span class="p_chunk">@@ -84,11 +92,17 @@</span> <span class="p_context"> enum net_device_flags {</span>
 	IFF_PORTSEL			= 1&lt;&lt;13, /* sysfs */
 	IFF_AUTOMEDIA			= 1&lt;&lt;14, /* sysfs */
 	IFF_DYNAMIC			= 1&lt;&lt;15, /* sysfs */
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */</span>
<span class="p_add">+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO</span>
 	IFF_LOWER_UP			= 1&lt;&lt;16, /* volatile */
 	IFF_DORMANT			= 1&lt;&lt;17, /* volatile */
 	IFF_ECHO			= 1&lt;&lt;18, /* volatile */
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */</span>
 };
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO != 0 &amp;&amp; __UAPI_DEF_IF_NET_DEVICE_FLAGS != 0 */</span>
 
<span class="p_add">+/* for compatibility with glibc net/if.h */</span>
<span class="p_add">+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS</span>
 #define IFF_UP				IFF_UP
 #define IFF_BROADCAST			IFF_BROADCAST
 #define IFF_DEBUG			IFF_DEBUG
<span class="p_chunk">@@ -105,9 +119,13 @@</span> <span class="p_context"> enum net_device_flags {</span>
 #define IFF_PORTSEL			IFF_PORTSEL
 #define IFF_AUTOMEDIA			IFF_AUTOMEDIA
 #define IFF_DYNAMIC			IFF_DYNAMIC
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS */</span>
<span class="p_add">+</span>
<span class="p_add">+#if __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO</span>
 #define IFF_LOWER_UP			IFF_LOWER_UP
 #define IFF_DORMANT			IFF_DORMANT
 #define IFF_ECHO			IFF_ECHO
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */</span>
 
 #define IFF_VOLATILE	(IFF_LOOPBACK|IFF_POINTOPOINT|IFF_BROADCAST|IFF_ECHO|\
 		IFF_MASTER|IFF_SLAVE|IFF_RUNNING|IFF_LOWER_UP|IFF_DORMANT)
<span class="p_chunk">@@ -166,6 +184,8 @@</span> <span class="p_context"> enum {</span>
  *	being very small might be worth keeping for clean configuration.
  */
 
<span class="p_add">+/* for compatibility with glibc net/if.h */</span>
<span class="p_add">+#if __UAPI_DEF_IF_IFMAP</span>
 struct ifmap {
 	unsigned long mem_start;
 	unsigned long mem_end;
<span class="p_chunk">@@ -175,6 +195,7 @@</span> <span class="p_context"> struct ifmap {</span>
 	unsigned char port;
 	/* 3 bytes spare */
 };
<span class="p_add">+#endif /* __UAPI_DEF_IF_IFMAP */</span>
 
 struct if_settings {
 	unsigned int type;	/* Type of physical device or protocol */
<span class="p_chunk">@@ -200,6 +221,8 @@</span> <span class="p_context"> struct if_settings {</span>
  * remainder may be interface specific.
  */
 
<span class="p_add">+/* for compatibility with glibc net/if.h */</span>
<span class="p_add">+#if __UAPI_DEF_IF_IFREQ</span>
 struct ifreq {
 #define IFHWADDRLEN	6
 	union
<span class="p_chunk">@@ -223,6 +246,7 @@</span> <span class="p_context"> struct ifreq {</span>
 		struct	if_settings ifru_settings;
 	} ifr_ifru;
 };
<span class="p_add">+#endif /* __UAPI_DEF_IF_IFREQ */</span>
 
 #define ifr_name	ifr_ifrn.ifrn_name	/* interface name 	*/
 #define ifr_hwaddr	ifr_ifru.ifru_hwaddr	/* MAC address 		*/
<span class="p_chunk">@@ -249,6 +273,8 @@</span> <span class="p_context"> struct ifreq {</span>
  * must know all networks accessible).
  */
 
<span class="p_add">+/* for compatibility with glibc net/if.h */</span>
<span class="p_add">+#if __UAPI_DEF_IF_IFCONF</span>
 struct ifconf  {
 	int	ifc_len;			/* size of buffer	*/
 	union {
<span class="p_chunk">@@ -256,6 +282,8 @@</span> <span class="p_context"> struct ifconf  {</span>
 		struct ifreq __user *ifcu_req;
 	} ifc_ifcu;
 };
<span class="p_add">+#endif /* __UAPI_DEF_IF_IFCONF */</span>
<span class="p_add">+</span>
 #define	ifc_buf	ifc_ifcu.ifcu_buf		/* buffer address	*/
 #define	ifc_req	ifc_ifcu.ifcu_req		/* array of structures	*/
 
<span class="p_header">diff --git a/include/uapi/linux/libc-compat.h b/include/uapi/linux/libc-compat.h</span>
<span class="p_header">index 7d024ceb075d..d5e38c73377c 100644</span>
<span class="p_header">--- a/include/uapi/linux/libc-compat.h</span>
<span class="p_header">+++ b/include/uapi/linux/libc-compat.h</span>
<span class="p_chunk">@@ -51,6 +51,40 @@</span> <span class="p_context"></span>
 /* We have included glibc headers... */
 #if defined(__GLIBC__)
 
<span class="p_add">+/* Coordinate with glibc net/if.h header. */</span>
<span class="p_add">+#if defined(_NET_IF_H)</span>
<span class="p_add">+</span>
<span class="p_add">+/* GLIBC headers included first so don&#39;t define anything</span>
<span class="p_add">+ * that would already be defined. */</span>
<span class="p_add">+</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFCONF 0</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFMAP 0</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFNAMSIZ 0</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFREQ 0</span>
<span class="p_add">+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 0</span>
<span class="p_add">+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */</span>
<span class="p_add">+#ifndef __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1</span>
<span class="p_add">+#endif /* __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO */</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* _NET_IF_H */</span>
<span class="p_add">+</span>
<span class="p_add">+/* Linux headers included first, and we must define everything</span>
<span class="p_add">+ * we need. The expectation is that glibc will check the</span>
<span class="p_add">+ * __UAPI_DEF_* defines and adjust appropriately. */</span>
<span class="p_add">+</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFCONF 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFMAP 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFNAMSIZ 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFREQ 1</span>
<span class="p_add">+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1</span>
<span class="p_add">+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _NET_IF_H */</span>
<span class="p_add">+</span>
 /* Coordinate with glibc netinet/in.h header. */
 #if defined(_NETINET_IN_H)
 
<span class="p_chunk">@@ -117,6 +151,16 @@</span> <span class="p_context"></span>
  * that we need. */
 #else /* !defined(__GLIBC__) */
 
<span class="p_add">+/* Definitions for if.h */</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFCONF 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFMAP 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFNAMSIZ 1</span>
<span class="p_add">+#define __UAPI_DEF_IF_IFREQ 1</span>
<span class="p_add">+/* Everything up to IFF_DYNAMIC, matches net/if.h until glibc 2.23 */</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS 1</span>
<span class="p_add">+/* For the future if glibc adds IFF_LOWER_UP, IFF_DORMANT and IFF_ECHO */</span>
<span class="p_add">+#define __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO 1</span>
<span class="p_add">+</span>
 /* Definitions for in.h */
 #define __UAPI_DEF_IN_ADDR		1
 #define __UAPI_DEF_IN_IPPROTO		1
<span class="p_header">diff --git a/kernel/bpf/inode.c b/kernel/bpf/inode.c</span>
<span class="p_header">index 5a8a797d50b7..d1a7646f79c5 100644</span>
<span class="p_header">--- a/kernel/bpf/inode.c</span>
<span class="p_header">+++ b/kernel/bpf/inode.c</span>
<span class="p_chunk">@@ -31,10 +31,10 @@</span> <span class="p_context"> static void *bpf_any_get(void *raw, enum bpf_type type)</span>
 {
 	switch (type) {
 	case BPF_TYPE_PROG:
<span class="p_del">-		atomic_inc(&amp;((struct bpf_prog *)raw)-&gt;aux-&gt;refcnt);</span>
<span class="p_add">+		raw = bpf_prog_inc(raw);</span>
 		break;
 	case BPF_TYPE_MAP:
<span class="p_del">-		bpf_map_inc(raw, true);</span>
<span class="p_add">+		raw = bpf_map_inc(raw, true);</span>
 		break;
 	default:
 		WARN_ON_ONCE(1);
<span class="p_chunk">@@ -277,7 +277,8 @@</span> <span class="p_context"> static void *bpf_obj_do_get(const struct filename *pathname,</span>
 		goto out;
 
 	raw = bpf_any_get(inode-&gt;i_private, *type);
<span class="p_del">-	touch_atime(&amp;path);</span>
<span class="p_add">+	if (!IS_ERR(raw))</span>
<span class="p_add">+		touch_atime(&amp;path);</span>
 
 	path_put(&amp;path);
 	return raw;
<span class="p_header">diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c</span>
<span class="p_header">index 3b39550d8485..4e32cc94edd9 100644</span>
<span class="p_header">--- a/kernel/bpf/syscall.c</span>
<span class="p_header">+++ b/kernel/bpf/syscall.c</span>
<span class="p_chunk">@@ -181,11 +181,18 @@</span> <span class="p_context"> struct bpf_map *__bpf_map_get(struct fd f)</span>
 	return f.file-&gt;private_data;
 }
 
<span class="p_del">-void bpf_map_inc(struct bpf_map *map, bool uref)</span>
<span class="p_add">+/* prog&#39;s and map&#39;s refcnt limit */</span>
<span class="p_add">+#define BPF_MAX_REFCNT 32768</span>
<span class="p_add">+</span>
<span class="p_add">+struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)</span>
 {
<span class="p_del">-	atomic_inc(&amp;map-&gt;refcnt);</span>
<span class="p_add">+	if (atomic_inc_return(&amp;map-&gt;refcnt) &gt; BPF_MAX_REFCNT) {</span>
<span class="p_add">+		atomic_dec(&amp;map-&gt;refcnt);</span>
<span class="p_add">+		return ERR_PTR(-EBUSY);</span>
<span class="p_add">+	}</span>
 	if (uref)
 		atomic_inc(&amp;map-&gt;usercnt);
<span class="p_add">+	return map;</span>
 }
 
 struct bpf_map *bpf_map_get_with_uref(u32 ufd)
<span class="p_chunk">@@ -197,7 +204,7 @@</span> <span class="p_context"> struct bpf_map *bpf_map_get_with_uref(u32 ufd)</span>
 	if (IS_ERR(map))
 		return map;
 
<span class="p_del">-	bpf_map_inc(map, true);</span>
<span class="p_add">+	map = bpf_map_inc(map, true);</span>
 	fdput(f);
 
 	return map;
<span class="p_chunk">@@ -580,6 +587,15 @@</span> <span class="p_context"> static struct bpf_prog *__bpf_prog_get(struct fd f)</span>
 	return f.file-&gt;private_data;
 }
 
<span class="p_add">+struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (atomic_inc_return(&amp;prog-&gt;aux-&gt;refcnt) &gt; BPF_MAX_REFCNT) {</span>
<span class="p_add">+		atomic_dec(&amp;prog-&gt;aux-&gt;refcnt);</span>
<span class="p_add">+		return ERR_PTR(-EBUSY);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return prog;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* called by sockets/tracing/seccomp before attaching program to an event
  * pairs with bpf_prog_put()
  */
<span class="p_chunk">@@ -592,7 +608,7 @@</span> <span class="p_context"> struct bpf_prog *bpf_prog_get(u32 ufd)</span>
 	if (IS_ERR(prog))
 		return prog;
 
<span class="p_del">-	atomic_inc(&amp;prog-&gt;aux-&gt;refcnt);</span>
<span class="p_add">+	prog = bpf_prog_inc(prog);</span>
 	fdput(f);
 
 	return prog;
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 2e7f7ab739e4..2cbfba78d3db 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -239,15 +239,6 @@</span> <span class="p_context"> static const char * const reg_type_str[] = {</span>
 	[CONST_IMM]		= &quot;imm&quot;,
 };
 
<span class="p_del">-static const struct {</span>
<span class="p_del">-	int map_type;</span>
<span class="p_del">-	int func_id;</span>
<span class="p_del">-} func_limit[] = {</span>
<span class="p_del">-	{BPF_MAP_TYPE_PROG_ARRAY, BPF_FUNC_tail_call},</span>
<span class="p_del">-	{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_read},</span>
<span class="p_del">-	{BPF_MAP_TYPE_PERF_EVENT_ARRAY, BPF_FUNC_perf_event_output},</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static void print_verifier_state(struct verifier_env *env)
 {
 	enum bpf_reg_type t;
<span class="p_chunk">@@ -898,24 +889,44 @@</span> <span class="p_context"> static int check_func_arg(struct verifier_env *env, u32 regno,</span>
 
 static int check_map_func_compatibility(struct bpf_map *map, int func_id)
 {
<span class="p_del">-	bool bool_map, bool_func;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
 	if (!map)
 		return 0;
 
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(func_limit); i++) {</span>
<span class="p_del">-		bool_map = (map-&gt;map_type == func_limit[i].map_type);</span>
<span class="p_del">-		bool_func = (func_id == func_limit[i].func_id);</span>
<span class="p_del">-		/* only when map &amp; func pair match it can continue.</span>
<span class="p_del">-		 * don&#39;t allow any other map type to be passed into</span>
<span class="p_del">-		 * the special func;</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (bool_func &amp;&amp; bool_map != bool_func)</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+	/* We need a two way check, first is from map perspective ... */</span>
<span class="p_add">+	switch (map-&gt;map_type) {</span>
<span class="p_add">+	case BPF_MAP_TYPE_PROG_ARRAY:</span>
<span class="p_add">+		if (func_id != BPF_FUNC_tail_call)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case BPF_MAP_TYPE_PERF_EVENT_ARRAY:</span>
<span class="p_add">+		if (func_id != BPF_FUNC_perf_event_read &amp;&amp;</span>
<span class="p_add">+		    func_id != BPF_FUNC_perf_event_output)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ... and second from the function itself. */</span>
<span class="p_add">+	switch (func_id) {</span>
<span class="p_add">+	case BPF_FUNC_tail_call:</span>
<span class="p_add">+		if (map-&gt;map_type != BPF_MAP_TYPE_PROG_ARRAY)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case BPF_FUNC_perf_event_read:</span>
<span class="p_add">+	case BPF_FUNC_perf_event_output:</span>
<span class="p_add">+		if (map-&gt;map_type != BPF_MAP_TYPE_PERF_EVENT_ARRAY)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	return 0;
<span class="p_add">+error:</span>
<span class="p_add">+	verbose(&quot;cannot pass map_type %d into func %d\n&quot;,</span>
<span class="p_add">+		map-&gt;map_type, func_id);</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int check_call(struct verifier_env *env, int func_id)
<span class="p_chunk">@@ -1348,6 +1359,7 @@</span> <span class="p_context"> static int check_ld_abs(struct verifier_env *env, struct bpf_insn *insn)</span>
 	}
 
 	if (insn-&gt;dst_reg != BPF_REG_0 || insn-&gt;off != 0 ||
<span class="p_add">+	    BPF_SIZE(insn-&gt;code) == BPF_DW ||</span>
 	    (mode == BPF_ABS &amp;&amp; insn-&gt;src_reg != BPF_REG_0)) {
 		verbose(&quot;BPF_LD_ABS uses reserved fields\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -2003,7 +2015,6 @@</span> <span class="p_context"> static int replace_map_fd_with_map_ptr(struct verifier_env *env)</span>
 			if (IS_ERR(map)) {
 				verbose(&quot;fd %d is not pointing to valid bpf_map\n&quot;,
 					insn-&gt;imm);
<span class="p_del">-				fdput(f);</span>
 				return PTR_ERR(map);
 			}
 
<span class="p_chunk">@@ -2023,15 +2034,18 @@</span> <span class="p_context"> static int replace_map_fd_with_map_ptr(struct verifier_env *env)</span>
 				return -E2BIG;
 			}
 
<span class="p_del">-			/* remember this map */</span>
<span class="p_del">-			env-&gt;used_maps[env-&gt;used_map_cnt++] = map;</span>
<span class="p_del">-</span>
 			/* hold the map. If the program is rejected by verifier,
 			 * the map will be released by release_maps() or it
 			 * will be used by the valid program until it&#39;s unloaded
 			 * and all maps are released in free_bpf_prog_info()
 			 */
<span class="p_del">-			bpf_map_inc(map, false);</span>
<span class="p_add">+			map = bpf_map_inc(map, false);</span>
<span class="p_add">+			if (IS_ERR(map)) {</span>
<span class="p_add">+				fdput(f);</span>
<span class="p_add">+				return PTR_ERR(map);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			env-&gt;used_maps[env-&gt;used_map_cnt++] = map;</span>
<span class="p_add">+</span>
 			fdput(f);
 next_insn:
 			insn++;
<span class="p_header">diff --git a/kernel/events/ring_buffer.c b/kernel/events/ring_buffer.c</span>
<span class="p_header">index adfdc0536117..014b69528194 100644</span>
<span class="p_header">--- a/kernel/events/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/events/ring_buffer.c</span>
<span class="p_chunk">@@ -347,6 +347,7 @@</span> <span class="p_context"> void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size,</span>
 			 bool truncated)
 {
 	struct ring_buffer *rb = handle-&gt;rb;
<span class="p_add">+	bool wakeup = truncated;</span>
 	unsigned long aux_head;
 	u64 flags = 0;
 
<span class="p_chunk">@@ -375,9 +376,16 @@</span> <span class="p_context"> void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size,</span>
 	aux_head = rb-&gt;user_page-&gt;aux_head = local_read(&amp;rb-&gt;aux_head);
 
 	if (aux_head - local_read(&amp;rb-&gt;aux_wakeup) &gt;= rb-&gt;aux_watermark) {
<span class="p_del">-		perf_output_wakeup(handle);</span>
<span class="p_add">+		wakeup = true;</span>
 		local_add(rb-&gt;aux_watermark, &amp;rb-&gt;aux_wakeup);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (wakeup) {</span>
<span class="p_add">+		if (truncated)</span>
<span class="p_add">+			handle-&gt;event-&gt;pending_disable = 1;</span>
<span class="p_add">+		perf_output_wakeup(handle);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	handle-&gt;event = NULL;
 
 	local_set(&amp;rb-&gt;aux_nest, 0);
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 0ec05948a97b..2c2f971f3e75 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -4457,6 +4457,17 @@</span> <span class="p_context"> static void rebind_workers(struct worker_pool *pool)</span>
 						  pool-&gt;attrs-&gt;cpumask) &lt; 0);
 
 	spin_lock_irq(&amp;pool-&gt;lock);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * XXX: CPU hotplug notifiers are weird and can call DOWN_FAILED</span>
<span class="p_add">+	 * w/o preceding DOWN_PREPARE.  Work around it.  CPU hotplug is</span>
<span class="p_add">+	 * being reworked and this can go away in time.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(pool-&gt;flags &amp; POOL_DISASSOCIATED)) {</span>
<span class="p_add">+		spin_unlock_irq(&amp;pool-&gt;lock);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;
 
 	for_each_pool_worker(worker, pool) {
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index fc083996e40a..c1ea19478119 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -1732,10 +1732,13 @@</span> <span class="p_context"> static struct page *isolate_source_page(struct size_class *class)</span>
 static unsigned long zs_can_compact(struct size_class *class)
 {
 	unsigned long obj_wasted;
<span class="p_add">+	unsigned long obj_allocated = zs_stat_get(class, OBJ_ALLOCATED);</span>
<span class="p_add">+	unsigned long obj_used = zs_stat_get(class, OBJ_USED);</span>
 
<span class="p_del">-	obj_wasted = zs_stat_get(class, OBJ_ALLOCATED) -</span>
<span class="p_del">-		zs_stat_get(class, OBJ_USED);</span>
<span class="p_add">+	if (obj_allocated &lt;= obj_used)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_add">+	obj_wasted = obj_allocated - obj_used;</span>
 	obj_wasted /= get_maxobj_per_zspage(class-&gt;size,
 			class-&gt;pages_per_zspage);
 
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index 263b4de4de57..60a3dbfca8a1 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -21,18 +21,19 @@</span> <span class="p_context"></span>
 #include &lt;asm/uaccess.h&gt;
 #include &quot;br_private.h&quot;
 
<span class="p_del">-/* called with RTNL */</span>
 static int get_bridge_ifindices(struct net *net, int *indices, int num)
 {
 	struct net_device *dev;
 	int i = 0;
 
<span class="p_del">-	for_each_netdev(net, dev) {</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for_each_netdev_rcu(net, dev) {</span>
 		if (i &gt;= num)
 			break;
 		if (dev-&gt;priv_flags &amp; IFF_EBRIDGE)
 			indices[i++] = dev-&gt;ifindex;
 	}
<span class="p_add">+	rcu_read_unlock();</span>
 
 	return i;
 }
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 03661d97463c..ea9893743a0f 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1270,6 +1270,7 @@</span> <span class="p_context"> static int br_ip4_multicast_query(struct net_bridge *br,</span>
 	struct br_ip saddr;
 	unsigned long max_delay;
 	unsigned long now = jiffies;
<span class="p_add">+	unsigned int offset = skb_transport_offset(skb);</span>
 	__be32 group;
 	int err = 0;
 
<span class="p_chunk">@@ -1280,14 +1281,14 @@</span> <span class="p_context"> static int br_ip4_multicast_query(struct net_bridge *br,</span>
 
 	group = ih-&gt;group;
 
<span class="p_del">-	if (skb-&gt;len == sizeof(*ih)) {</span>
<span class="p_add">+	if (skb-&gt;len == offset + sizeof(*ih)) {</span>
 		max_delay = ih-&gt;code * (HZ / IGMP_TIMER_SCALE);
 
 		if (!max_delay) {
 			max_delay = 10 * HZ;
 			group = 0;
 		}
<span class="p_del">-	} else if (skb-&gt;len &gt;= sizeof(*ih3)) {</span>
<span class="p_add">+	} else if (skb-&gt;len &gt;= offset + sizeof(*ih3)) {</span>
 		ih3 = igmpv3_query_hdr(skb);
 		if (ih3-&gt;nsrcs)
 			goto out;
<span class="p_chunk">@@ -1348,6 +1349,7 @@</span> <span class="p_context"> static int br_ip6_multicast_query(struct net_bridge *br,</span>
 	struct br_ip saddr;
 	unsigned long max_delay;
 	unsigned long now = jiffies;
<span class="p_add">+	unsigned int offset = skb_transport_offset(skb);</span>
 	const struct in6_addr *group = NULL;
 	bool is_general_query;
 	int err = 0;
<span class="p_chunk">@@ -1357,8 +1359,8 @@</span> <span class="p_context"> static int br_ip6_multicast_query(struct net_bridge *br,</span>
 	    (port &amp;&amp; port-&gt;state == BR_STATE_DISABLED))
 		goto out;
 
<span class="p_del">-	if (skb-&gt;len == sizeof(*mld)) {</span>
<span class="p_del">-		if (!pskb_may_pull(skb, sizeof(*mld))) {</span>
<span class="p_add">+	if (skb-&gt;len == offset + sizeof(*mld)) {</span>
<span class="p_add">+		if (!pskb_may_pull(skb, offset + sizeof(*mld))) {</span>
 			err = -EINVAL;
 			goto out;
 		}
<span class="p_chunk">@@ -1367,7 +1369,7 @@</span> <span class="p_context"> static int br_ip6_multicast_query(struct net_bridge *br,</span>
 		if (max_delay)
 			group = &amp;mld-&gt;mld_mca;
 	} else {
<span class="p_del">-		if (!pskb_may_pull(skb, sizeof(*mld2q))) {</span>
<span class="p_add">+		if (!pskb_may_pull(skb, offset + sizeof(*mld2q))) {</span>
 			err = -EINVAL;
 			goto out;
 		}
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index ca966f7de351..87b91ffbdec3 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1175,14 +1175,16 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 
 static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)
 {
<span class="p_del">-	struct rtnl_link_ifmap map = {</span>
<span class="p_del">-		.mem_start   = dev-&gt;mem_start,</span>
<span class="p_del">-		.mem_end     = dev-&gt;mem_end,</span>
<span class="p_del">-		.base_addr   = dev-&gt;base_addr,</span>
<span class="p_del">-		.irq         = dev-&gt;irq,</span>
<span class="p_del">-		.dma         = dev-&gt;dma,</span>
<span class="p_del">-		.port        = dev-&gt;if_port,</span>
<span class="p_del">-	};</span>
<span class="p_add">+	struct rtnl_link_ifmap map;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;map, 0, sizeof(map));</span>
<span class="p_add">+	map.mem_start   = dev-&gt;mem_start;</span>
<span class="p_add">+	map.mem_end     = dev-&gt;mem_end;</span>
<span class="p_add">+	map.base_addr   = dev-&gt;base_addr;</span>
<span class="p_add">+	map.irq         = dev-&gt;irq;</span>
<span class="p_add">+	map.dma         = dev-&gt;dma;</span>
<span class="p_add">+	map.port        = dev-&gt;if_port;</span>
<span class="p_add">+</span>
 	if (nla_put(skb, IFLA_MAP, sizeof(map), &amp;map))
 		return -EMSGSIZE;
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 8616d1147c93..9835d9a8a7a4 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -4427,15 +4427,16 @@</span> <span class="p_context"> int skb_vlan_push(struct sk_buff *skb, __be16 vlan_proto, u16 vlan_tci)</span>
 		__skb_push(skb, offset);
 		err = __vlan_insert_tag(skb, skb-&gt;vlan_proto,
 					skb_vlan_tag_get(skb));
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			__skb_pull(skb, offset);</span>
 			return err;
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		skb-&gt;protocol = skb-&gt;vlan_proto;
 		skb-&gt;mac_len += VLAN_HLEN;
<span class="p_del">-		__skb_pull(skb, offset);</span>
 
<span class="p_del">-		if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_del">-			skb-&gt;csum = csum_add(skb-&gt;csum, csum_partial(skb-&gt;data</span>
<span class="p_del">-					+ (2 * ETH_ALEN), VLAN_HLEN, 0));</span>
<span class="p_add">+		skb_postpush_rcsum(skb, skb-&gt;data + (2 * ETH_ALEN), VLAN_HLEN);</span>
<span class="p_add">+		__skb_pull(skb, offset);</span>
 	}
 	__vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci);
 	return 0;
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index 607a14f20d88..b1dc096d22f8 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -1034,10 +1034,13 @@</span> <span class="p_context"> source_ok:</span>
 	if (!fld.daddr) {
 		fld.daddr = fld.saddr;
 
<span class="p_del">-		err = -EADDRNOTAVAIL;</span>
 		if (dev_out)
 			dev_put(dev_out);
<span class="p_add">+		err = -EINVAL;</span>
 		dev_out = init_net.loopback_dev;
<span class="p_add">+		if (!dev_out-&gt;dn_ptr)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		err = -EADDRNOTAVAIL;</span>
 		dev_hold(dev_out);
 		if (!fld.daddr) {
 			fld.daddr =
<span class="p_chunk">@@ -1110,6 +1113,8 @@</span> <span class="p_context"> source_ok:</span>
 		if (dev_out == NULL)
 			goto out;
 		dn_db = rcu_dereference_raw(dev_out-&gt;dn_ptr);
<span class="p_add">+		if (!dn_db)</span>
<span class="p_add">+			goto e_inval;</span>
 		/* Possible improvement - check all devices for local addr */
 		if (dn_dev_islocal(dev_out, fld.daddr)) {
 			dev_put(dev_out);
<span class="p_chunk">@@ -1151,6 +1156,8 @@</span> <span class="p_context"> select_source:</span>
 			dev_put(dev_out);
 		dev_out = init_net.loopback_dev;
 		dev_hold(dev_out);
<span class="p_add">+		if (!dev_out-&gt;dn_ptr)</span>
<span class="p_add">+			goto e_inval;</span>
 		fld.flowidn_oif = dev_out-&gt;ifindex;
 		if (res.fi)
 			dn_fib_info_put(res.fi);
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 8a9246deccfe..63566ec54794 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -904,7 +904,11 @@</span> <span class="p_context"> void fib_del_ifaddr(struct in_ifaddr *ifa, struct in_ifaddr *iprim)</span>
 	if (ifa-&gt;ifa_flags &amp; IFA_F_SECONDARY) {
 		prim = inet_ifa_byprefix(in_dev, any, ifa-&gt;ifa_mask);
 		if (!prim) {
<span class="p_del">-			pr_warn(&quot;%s: bug: prim == NULL\n&quot;, __func__);</span>
<span class="p_add">+			/* if the device has been deleted, we don&#39;t perform</span>
<span class="p_add">+			 * address promotion</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!in_dev-&gt;dead)</span>
<span class="p_add">+				pr_warn(&quot;%s: bug: prim == NULL\n&quot;, __func__);</span>
 			return;
 		}
 		if (iprim &amp;&amp; iprim != prim) {
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index d97268e8ff10..2b68418c7198 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -975,6 +975,8 @@</span> <span class="p_context"> fib_convert_metrics(struct fib_info *fi, const struct fib_config *cfg)</span>
 			val = 65535 - 40;
 		if (type == RTAX_MTU &amp;&amp; val &gt; 65535 - 15)
 			val = 65535 - 15;
<span class="p_add">+		if (type == RTAX_HOPLIMIT &amp;&amp; val &gt; 255)</span>
<span class="p_add">+			val = 255;</span>
 		if (type == RTAX_FEATURES &amp;&amp; (val &amp; ~RTAX_FEATURE_MASK))
 			return -EINVAL;
 		fi-&gt;fib_metrics[type - 1] = val;
<span class="p_header">diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c</span>
<span class="p_header">index 614521437e30..7dc962b89fa1 100644</span>
<span class="p_header">--- a/net/ipv4/ip_gre.c</span>
<span class="p_header">+++ b/net/ipv4/ip_gre.c</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> static __be16 tnl_flags_to_gre_flags(__be16 tflags)</span>
 	return flags;
 }
 
<span class="p_add">+/* Fills in tpi and returns header length to be pulled. */</span>
 static int parse_gre_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,
 			    bool *csum_err)
 {
<span class="p_chunk">@@ -239,7 +240,7 @@</span> <span class="p_context"> static int parse_gre_header(struct sk_buff *skb, struct tnl_ptk_info *tpi,</span>
 				return -EINVAL;
 		}
 	}
<span class="p_del">-	return iptunnel_pull_header(skb, hdr_len, tpi-&gt;proto);</span>
<span class="p_add">+	return hdr_len;</span>
 }
 
 static void ipgre_err(struct sk_buff *skb, u32 info,
<span class="p_chunk">@@ -342,7 +343,7 @@</span> <span class="p_context"> static void gre_err(struct sk_buff *skb, u32 info)</span>
 	struct tnl_ptk_info tpi;
 	bool csum_err = false;
 
<span class="p_del">-	if (parse_gre_header(skb, &amp;tpi, &amp;csum_err)) {</span>
<span class="p_add">+	if (parse_gre_header(skb, &amp;tpi, &amp;csum_err) &lt; 0) {</span>
 		if (!csum_err)		/* ignore csum errors. */
 			return;
 	}
<span class="p_chunk">@@ -420,6 +421,7 @@</span> <span class="p_context"> static int gre_rcv(struct sk_buff *skb)</span>
 {
 	struct tnl_ptk_info tpi;
 	bool csum_err = false;
<span class="p_add">+	int hdr_len;</span>
 
 #ifdef CONFIG_NET_IPGRE_BROADCAST
 	if (ipv4_is_multicast(ip_hdr(skb)-&gt;daddr)) {
<span class="p_chunk">@@ -429,7 +431,10 @@</span> <span class="p_context"> static int gre_rcv(struct sk_buff *skb)</span>
 	}
 #endif
 
<span class="p_del">-	if (parse_gre_header(skb, &amp;tpi, &amp;csum_err) &lt; 0)</span>
<span class="p_add">+	hdr_len = parse_gre_header(skb, &amp;tpi, &amp;csum_err);</span>
<span class="p_add">+	if (hdr_len &lt; 0)</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+	if (iptunnel_pull_header(skb, hdr_len, tpi.proto) &lt; 0)</span>
 		goto drop;
 
 	if (ipgre_rcv(skb, &amp;tpi) == PACKET_RCVD)
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 02c62299d717..b050cf980a57 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -2045,6 +2045,18 @@</span> <span class="p_context"> static struct rtable *__mkroute_output(const struct fib_result *res,</span>
 		 */
 		if (fi &amp;&amp; res-&gt;prefixlen &lt; 4)
 			fi = NULL;
<span class="p_add">+	} else if ((type == RTN_LOCAL) &amp;&amp; (orig_oif != 0) &amp;&amp;</span>
<span class="p_add">+		   (orig_oif != dev_out-&gt;ifindex)) {</span>
<span class="p_add">+		/* For local routes that require a particular output interface</span>
<span class="p_add">+		 * we do not want to cache the result.  Caching the result</span>
<span class="p_add">+		 * causes incorrect behaviour when there are multiple source</span>
<span class="p_add">+		 * addresses on the interface, the end result being that if the</span>
<span class="p_add">+		 * intended recipient is waiting on that interface for the</span>
<span class="p_add">+		 * packet he won&#39;t receive it because it will be delivered on</span>
<span class="p_add">+		 * the loopback interface and the IP_PKTINFO ipi_ifindex will</span>
<span class="p_add">+		 * be set to the loopback interface as well.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		fi = NULL;</span>
 	}
 
 	fnhe = NULL;
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 9bfc39ff2285..7c9883ab56e5 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2625,8 +2625,10 @@</span> <span class="p_context"> int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb)</span>
 	 */
 	if (unlikely((NET_IP_ALIGN &amp;&amp; ((unsigned long)skb-&gt;data &amp; 3)) ||
 		     skb_headroom(skb) &gt;= 0xFFFF)) {
<span class="p_del">-		struct sk_buff *nskb = __pskb_copy(skb, MAX_TCP_HEADER,</span>
<span class="p_del">-						   GFP_ATOMIC);</span>
<span class="p_add">+		struct sk_buff *nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+		skb_mstamp_get(&amp;skb-&gt;skb_mstamp);</span>
<span class="p_add">+		nskb = __pskb_copy(skb, MAX_TCP_HEADER, GFP_ATOMIC);</span>
 		err = nskb ? tcp_transmit_skb(sk, nskb, 0, GFP_ATOMIC) :
 			     -ENOBUFS;
 	} else {
<span class="p_header">diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c</span>
<span class="p_header">index 45f5ae51de65..a234552a7e3d 100644</span>
<span class="p_header">--- a/net/ipv6/reassembly.c</span>
<span class="p_header">+++ b/net/ipv6/reassembly.c</span>
<span class="p_chunk">@@ -496,10 +496,8 @@</span> <span class="p_context"> static int ip6_frag_reasm(struct frag_queue *fq, struct sk_buff *prev,</span>
 	IP6CB(head)-&gt;flags |= IP6SKB_FRAGMENTED;
 
 	/* Yes, and fold redundant checksum back. 8) */
<span class="p_del">-	if (head-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_del">-		head-&gt;csum = csum_partial(skb_network_header(head),</span>
<span class="p_del">-					  skb_network_header_len(head),</span>
<span class="p_del">-					  head-&gt;csum);</span>
<span class="p_add">+	skb_postpush_rcsum(head, skb_network_header(head),</span>
<span class="p_add">+			   skb_network_header_len(head));</span>
 
 	rcu_read_lock();
 	IP6_INC_STATS_BH(net, __in6_dev_get(dev), IPSTATS_MIB_REASMOKS);
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 3f164d3aaee2..5af2cca0a46d 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1727,6 +1727,8 @@</span> <span class="p_context"> static int ip6_convert_metrics(struct mx6_config *mxc,</span>
 		} else {
 			val = nla_get_u32(nla);
 		}
<span class="p_add">+		if (type == RTAX_HOPLIMIT &amp;&amp; val &gt; 255)</span>
<span class="p_add">+			val = 255;</span>
 		if (type == RTAX_FEATURES &amp;&amp; (val &amp; ~RTAX_FEATURE_MASK))
 			goto err;
 
<span class="p_header">diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c</span>
<span class="p_header">index 8dab4e569571..bb8edb9ef506 100644</span>
<span class="p_header">--- a/net/llc/af_llc.c</span>
<span class="p_header">+++ b/net/llc/af_llc.c</span>
<span class="p_chunk">@@ -626,6 +626,7 @@</span> <span class="p_context"> static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)</span>
 	if (llc-&gt;cmsg_flags &amp; LLC_CMSG_PKTINFO) {
 		struct llc_pktinfo info;
 
<span class="p_add">+		memset(&amp;info, 0, sizeof(info));</span>
 		info.lpi_ifindex = llc_sk(skb-&gt;sk)-&gt;dev-&gt;ifindex;
 		llc_pdu_decode_dsap(skb, &amp;info.lpi_sap);
 		llc_pdu_decode_da(skb, info.lpi_mac);
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 3cb3cb831591..86a3c6f0c871 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -1757,6 +1757,7 @@</span> <span class="p_context"> void nf_conntrack_init_end(void)</span>
 
 int nf_conntrack_init_net(struct net *net)
 {
<span class="p_add">+	static atomic64_t unique_id;</span>
 	int ret = -ENOMEM;
 	int cpu;
 
<span class="p_chunk">@@ -1779,7 +1780,8 @@</span> <span class="p_context"> int nf_conntrack_init_net(struct net *net)</span>
 	if (!net-&gt;ct.stat)
 		goto err_pcpu_lists;
 
<span class="p_del">-	net-&gt;ct.slabname = kasprintf(GFP_KERNEL, &quot;nf_conntrack_%p&quot;, net);</span>
<span class="p_add">+	net-&gt;ct.slabname = kasprintf(GFP_KERNEL, &quot;nf_conntrack_%llu&quot;,</span>
<span class="p_add">+				(u64)atomic64_inc_return(&amp;unique_id));</span>
 	if (!net-&gt;ct.slabname)
 		goto err_slabname;
 
<span class="p_header">diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c</span>
<span class="p_header">index c88d0f2d3e01..7cb8184ac165 100644</span>
<span class="p_header">--- a/net/openvswitch/actions.c</span>
<span class="p_header">+++ b/net/openvswitch/actions.c</span>
<span class="p_chunk">@@ -158,9 +158,7 @@</span> <span class="p_context"> static int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,</span>
 	new_mpls_lse = (__be32 *)skb_mpls_header(skb);
 	*new_mpls_lse = mpls-&gt;mpls_lse;
 
<span class="p_del">-	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_del">-		skb-&gt;csum = csum_add(skb-&gt;csum, csum_partial(new_mpls_lse,</span>
<span class="p_del">-							     MPLS_HLEN, 0));</span>
<span class="p_add">+	skb_postpush_rcsum(skb, new_mpls_lse, MPLS_HLEN);</span>
 
 	hdr = eth_hdr(skb);
 	hdr-&gt;h_proto = mpls-&gt;mpls_ethertype;
<span class="p_chunk">@@ -280,7 +278,7 @@</span> <span class="p_context"> static int set_eth_addr(struct sk_buff *skb, struct sw_flow_key *flow_key,</span>
 	ether_addr_copy_masked(eth_hdr(skb)-&gt;h_dest, key-&gt;eth_dst,
 			       mask-&gt;eth_dst);
 
<span class="p_del">-	ovs_skb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);</span>
<span class="p_add">+	skb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);</span>
 
 	ether_addr_copy(flow_key-&gt;eth.src, eth_hdr(skb)-&gt;h_source);
 	ether_addr_copy(flow_key-&gt;eth.dst, eth_hdr(skb)-&gt;h_dest);
<span class="p_chunk">@@ -463,7 +461,7 @@</span> <span class="p_context"> static int set_ipv6(struct sk_buff *skb, struct sw_flow_key *flow_key,</span>
 		mask_ipv6_addr(saddr, key-&gt;ipv6_src, mask-&gt;ipv6_src, masked);
 
 		if (unlikely(memcmp(saddr, masked, sizeof(masked)))) {
<span class="p_del">-			set_ipv6_addr(skb, key-&gt;ipv6_proto, saddr, masked,</span>
<span class="p_add">+			set_ipv6_addr(skb, flow_key-&gt;ip.proto, saddr, masked,</span>
 				      true);
 			memcpy(&amp;flow_key-&gt;ipv6.addr.src, masked,
 			       sizeof(flow_key-&gt;ipv6.addr.src));
<span class="p_chunk">@@ -485,7 +483,7 @@</span> <span class="p_context"> static int set_ipv6(struct sk_buff *skb, struct sw_flow_key *flow_key,</span>
 							     NULL, &amp;flags)
 					       != NEXTHDR_ROUTING);
 
<span class="p_del">-			set_ipv6_addr(skb, key-&gt;ipv6_proto, daddr, masked,</span>
<span class="p_add">+			set_ipv6_addr(skb, flow_key-&gt;ip.proto, daddr, masked,</span>
 				      recalc_csum);
 			memcpy(&amp;flow_key-&gt;ipv6.addr.dst, masked,
 			       sizeof(flow_key-&gt;ipv6.addr.dst));
<span class="p_chunk">@@ -639,7 +637,7 @@</span> <span class="p_context"> static int ovs_vport_output(struct net *net, struct sock *sk, struct sk_buff *sk</span>
 	/* Reconstruct the MAC header.  */
 	skb_push(skb, data-&gt;l2_len);
 	memcpy(skb-&gt;data, &amp;data-&gt;l2_data, data-&gt;l2_len);
<span class="p_del">-	ovs_skb_postpush_rcsum(skb, skb-&gt;data, data-&gt;l2_len);</span>
<span class="p_add">+	skb_postpush_rcsum(skb, skb-&gt;data, data-&gt;l2_len);</span>
 	skb_reset_mac_header(skb);
 
 	ovs_vport_send(vport, skb);
<span class="p_header">diff --git a/net/openvswitch/vport-netdev.c b/net/openvswitch/vport-netdev.c</span>
<span class="p_header">index 6b0190b987ec..76fcaf1fd2a9 100644</span>
<span class="p_header">--- a/net/openvswitch/vport-netdev.c</span>
<span class="p_header">+++ b/net/openvswitch/vport-netdev.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> static void netdev_port_receive(struct sk_buff *skb)</span>
 		return;
 
 	skb_push(skb, ETH_HLEN);
<span class="p_del">-	ovs_skb_postpush_rcsum(skb, skb-&gt;data, ETH_HLEN);</span>
<span class="p_add">+	skb_postpush_rcsum(skb, skb-&gt;data, ETH_HLEN);</span>
 	ovs_vport_receive(vport, skb, skb_tunnel_info(skb));
 	return;
 error:
<span class="p_header">diff --git a/net/openvswitch/vport.h b/net/openvswitch/vport.h</span>
<span class="p_header">index 8ea3a96980ac..6e2b62f9d595 100644</span>
<span class="p_header">--- a/net/openvswitch/vport.h</span>
<span class="p_header">+++ b/net/openvswitch/vport.h</span>
<span class="p_chunk">@@ -184,13 +184,6 @@</span> <span class="p_context"> static inline struct vport *vport_from_priv(void *priv)</span>
 int ovs_vport_receive(struct vport *, struct sk_buff *,
 		      const struct ip_tunnel_info *);
 
<span class="p_del">-static inline void ovs_skb_postpush_rcsum(struct sk_buff *skb,</span>
<span class="p_del">-				      const void *start, unsigned int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_del">-		skb-&gt;csum = csum_add(skb-&gt;csum, csum_partial(start, len, 0));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline const char *ovs_vport_name(struct vport *vport)
 {
 	return vport-&gt;dev-&gt;name;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index da1ae0e13cb5..9cc7b512b472 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -3436,6 +3436,7 @@</span> <span class="p_context"> static int packet_mc_add(struct sock *sk, struct packet_mreq_max *mreq)</span>
 	i-&gt;ifindex = mreq-&gt;mr_ifindex;
 	i-&gt;alen = mreq-&gt;mr_alen;
 	memcpy(i-&gt;addr, mreq-&gt;mr_address, i-&gt;alen);
<span class="p_add">+	memset(i-&gt;addr + i-&gt;alen, 0, sizeof(i-&gt;addr) - i-&gt;alen);</span>
 	i-&gt;count = 1;
 	i-&gt;next = po-&gt;mclist;
 	po-&gt;mclist = i;
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index af1acf009866..95b560f0b253 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -744,14 +744,15 @@</span> <span class="p_context"> static u32 qdisc_alloc_handle(struct net_device *dev)</span>
 	return 0;
 }
 
<span class="p_del">-void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)</span>
<span class="p_add">+void qdisc_tree_reduce_backlog(struct Qdisc *sch, unsigned int n,</span>
<span class="p_add">+			       unsigned int len)</span>
 {
 	const struct Qdisc_class_ops *cops;
 	unsigned long cl;
 	u32 parentid;
 	int drops;
 
<span class="p_del">-	if (n == 0)</span>
<span class="p_add">+	if (n == 0 &amp;&amp; len == 0)</span>
 		return;
 	drops = max_t(int, n, 0);
 	rcu_read_lock();
<span class="p_chunk">@@ -774,11 +775,12 @@</span> <span class="p_context"> void qdisc_tree_decrease_qlen(struct Qdisc *sch, unsigned int n)</span>
 			cops-&gt;put(sch, cl);
 		}
 		sch-&gt;q.qlen -= n;
<span class="p_add">+		sch-&gt;qstats.backlog -= len;</span>
 		__qdisc_qstats_drop(sch, drops);
 	}
 	rcu_read_unlock();
 }
<span class="p_del">-EXPORT_SYMBOL(qdisc_tree_decrease_qlen);</span>
<span class="p_add">+EXPORT_SYMBOL(qdisc_tree_reduce_backlog);</span>
 
 static void notify_and_destroy(struct net *net, struct sk_buff *skb,
 			       struct nlmsghdr *n, u32 clid,
<span class="p_header">diff --git a/net/sched/sch_cbq.c b/net/sched/sch_cbq.c</span>
<span class="p_header">index c538d9e4a8f6..baafddf229ce 100644</span>
<span class="p_header">--- a/net/sched/sch_cbq.c</span>
<span class="p_header">+++ b/net/sched/sch_cbq.c</span>
<span class="p_chunk">@@ -1624,13 +1624,8 @@</span> <span class="p_context"> static int cbq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 			new-&gt;reshape_fail = cbq_reshape_fail;
 #endif
 	}
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = cl-&gt;q;</span>
<span class="p_del">-	cl-&gt;q = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
 
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;q);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1914,7 +1909,7 @@</span> <span class="p_context"> static int cbq_delete(struct Qdisc *sch, unsigned long arg)</span>
 {
 	struct cbq_sched_data *q = qdisc_priv(sch);
 	struct cbq_class *cl = (struct cbq_class *)arg;
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, backlog;</span>
 
 	if (cl-&gt;filters || cl-&gt;children || cl == &amp;q-&gt;link)
 		return -EBUSY;
<span class="p_chunk">@@ -1922,8 +1917,9 @@</span> <span class="p_context"> static int cbq_delete(struct Qdisc *sch, unsigned long arg)</span>
 	sch_tree_lock(sch);
 
 	qlen = cl-&gt;q-&gt;q.qlen;
<span class="p_add">+	backlog = cl-&gt;q-&gt;qstats.backlog;</span>
 	qdisc_reset(cl-&gt;q);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;q, qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;q, qlen, backlog);</span>
 
 	if (cl-&gt;next_alive)
 		cbq_deactivate_class(cl);
<span class="p_header">diff --git a/net/sched/sch_choke.c b/net/sched/sch_choke.c</span>
<span class="p_header">index 5ffb8b8337c7..0a08c860eee4 100644</span>
<span class="p_header">--- a/net/sched/sch_choke.c</span>
<span class="p_header">+++ b/net/sched/sch_choke.c</span>
<span class="p_chunk">@@ -128,8 +128,8 @@</span> <span class="p_context"> static void choke_drop_by_idx(struct Qdisc *sch, unsigned int idx)</span>
 		choke_zap_tail_holes(q);
 
 	qdisc_qstats_backlog_dec(sch, skb);
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, qdisc_pkt_len(skb));</span>
 	qdisc_drop(skb, sch);
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
 	--sch-&gt;q.qlen;
 }
 
<span class="p_chunk">@@ -456,6 +456,7 @@</span> <span class="p_context"> static int choke_change(struct Qdisc *sch, struct nlattr *opt)</span>
 		old = q-&gt;tab;
 		if (old) {
 			unsigned int oqlen = sch-&gt;q.qlen, tail = 0;
<span class="p_add">+			unsigned dropped = 0;</span>
 
 			while (q-&gt;head != q-&gt;tail) {
 				struct sk_buff *skb = q-&gt;tab[q-&gt;head];
<span class="p_chunk">@@ -467,11 +468,12 @@</span> <span class="p_context"> static int choke_change(struct Qdisc *sch, struct nlattr *opt)</span>
 					ntab[tail++] = skb;
 					continue;
 				}
<span class="p_add">+				dropped += qdisc_pkt_len(skb);</span>
 				qdisc_qstats_backlog_dec(sch, skb);
 				--sch-&gt;q.qlen;
 				qdisc_drop(skb, sch);
 			}
<span class="p_del">-			qdisc_tree_decrease_qlen(sch, oqlen - sch-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(sch, oqlen - sch-&gt;q.qlen, dropped);</span>
 			q-&gt;head = 0;
 			q-&gt;tail = tail;
 		}
<span class="p_header">diff --git a/net/sched/sch_codel.c b/net/sched/sch_codel.c</span>
<span class="p_header">index 535007d5f0b5..9b7e2980ee5c 100644</span>
<span class="p_header">--- a/net/sched/sch_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_codel.c</span>
<span class="p_chunk">@@ -79,12 +79,13 @@</span> <span class="p_context"> static struct sk_buff *codel_qdisc_dequeue(struct Qdisc *sch)</span>
 
 	skb = codel_dequeue(sch, &amp;q-&gt;params, &amp;q-&gt;vars, &amp;q-&gt;stats, dequeue);
 
<span class="p_del">-	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,</span>
<span class="p_add">+	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,</span>
 	 * or HTB crashes. Defer it for next round.
 	 */
 	if (q-&gt;stats.drop_count &amp;&amp; sch-&gt;q.qlen) {
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, q-&gt;stats.drop_count);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, q-&gt;stats.drop_count, q-&gt;stats.drop_len);</span>
 		q-&gt;stats.drop_count = 0;
<span class="p_add">+		q-&gt;stats.drop_len = 0;</span>
 	}
 	if (skb)
 		qdisc_bstats_update(sch, skb);
<span class="p_chunk">@@ -116,7 +117,7 @@</span> <span class="p_context"> static int codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct codel_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_CODEL_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	int err;
 
 	if (!opt)
<span class="p_chunk">@@ -156,10 +157,11 @@</span> <span class="p_context"> static int codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = __skb_dequeue(&amp;sch-&gt;q);
 
<span class="p_add">+		dropped += qdisc_pkt_len(skb);</span>
 		qdisc_qstats_backlog_dec(sch, skb);
 		qdisc_drop(skb, sch);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_drr.c b/net/sched/sch_drr.c</span>
<span class="p_header">index f26bdea875c1..d6e3ad43cecb 100644</span>
<span class="p_header">--- a/net/sched/sch_drr.c</span>
<span class="p_header">+++ b/net/sched/sch_drr.c</span>
<span class="p_chunk">@@ -53,9 +53,10 @@</span> <span class="p_context"> static struct drr_class *drr_find_class(struct Qdisc *sch, u32 classid)</span>
 static void drr_purge_queue(struct drr_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static const struct nla_policy drr_policy[TCA_DRR_MAX + 1] = {
<span class="p_chunk">@@ -226,11 +227,7 @@</span> <span class="p_context"> static int drr_graft_class(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	drr_purge_queue(cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c</span>
<span class="p_header">index f357f34d02d2..d0dff0cd8186 100644</span>
<span class="p_header">--- a/net/sched/sch_dsmark.c</span>
<span class="p_header">+++ b/net/sched/sch_dsmark.c</span>
<span class="p_chunk">@@ -73,13 +73,7 @@</span> <span class="p_context"> static int dsmark_graft(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = p-&gt;q;</span>
<span class="p_del">-	p-&gt;q = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;p-&gt;q);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -264,6 +258,7 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return err;
 	}
 
<span class="p_add">+	qdisc_qstats_backlog_inc(sch, skb);</span>
 	sch-&gt;q.qlen++;
 
 	return NET_XMIT_SUCCESS;
<span class="p_chunk">@@ -286,6 +281,7 @@</span> <span class="p_context"> static struct sk_buff *dsmark_dequeue(struct Qdisc *sch)</span>
 		return NULL;
 
 	qdisc_bstats_update(sch, skb);
<span class="p_add">+	qdisc_qstats_backlog_dec(sch, skb);</span>
 	sch-&gt;q.qlen--;
 
 	index = skb-&gt;tc_index &amp; (p-&gt;indices - 1);
<span class="p_chunk">@@ -401,6 +397,7 @@</span> <span class="p_context"> static void dsmark_reset(struct Qdisc *sch)</span>
 
 	pr_debug(&quot;%s(sch %p,[qdisc %p])\n&quot;, __func__, sch, p);
 	qdisc_reset(p-&gt;q);
<span class="p_add">+	sch-&gt;qstats.backlog = 0;</span>
 	sch-&gt;q.qlen = 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_fq.c b/net/sched/sch_fq.c</span>
<span class="p_header">index 109b2322778f..3c6a47d66a04 100644</span>
<span class="p_header">--- a/net/sched/sch_fq.c</span>
<span class="p_header">+++ b/net/sched/sch_fq.c</span>
<span class="p_chunk">@@ -662,6 +662,7 @@</span> <span class="p_context"> static int fq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct fq_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_FQ_MAX + 1];
 	int err, drop_count = 0;
<span class="p_add">+	unsigned drop_len = 0;</span>
 	u32 fq_log;
 
 	if (!opt)
<span class="p_chunk">@@ -736,10 +737,11 @@</span> <span class="p_context"> static int fq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 		if (!skb)
 			break;
<span class="p_add">+		drop_len += qdisc_pkt_len(skb);</span>
 		kfree_skb(skb);
 		drop_count++;
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, drop_count);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, drop_count, drop_len);</span>
 
 	sch_tree_unlock(sch);
 	return err;
<span class="p_header">diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c</span>
<span class="p_header">index 4c834e93dafb..d3fc8f9dd3d4 100644</span>
<span class="p_header">--- a/net/sched/sch_fq_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_fq_codel.c</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> static unsigned int fq_codel_qdisc_drop(struct Qdisc *sch)</span>
 static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct fq_codel_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	unsigned int idx;</span>
<span class="p_add">+	unsigned int idx, prev_backlog;</span>
 	struct fq_codel_flow *flow;
 	int uninitialized_var(ret);
 
<span class="p_chunk">@@ -203,6 +203,7 @@</span> <span class="p_context"> static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	if (++sch-&gt;q.qlen &lt;= sch-&gt;limit)
 		return NET_XMIT_SUCCESS;
 
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	q-&gt;drop_overlimit++;
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
<span class="p_chunk">@@ -211,7 +212,7 @@</span> <span class="p_context"> static int fq_codel_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, prev_backlog - sch-&gt;qstats.backlog);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -241,6 +242,7 @@</span> <span class="p_context"> static struct sk_buff *fq_codel_dequeue(struct Qdisc *sch)</span>
 	struct fq_codel_flow *flow;
 	struct list_head *head;
 	u32 prev_drop_count, prev_ecn_mark;
<span class="p_add">+	unsigned int prev_backlog;</span>
 
 begin:
 	head = &amp;q-&gt;new_flows;
<span class="p_chunk">@@ -259,6 +261,7 @@</span> <span class="p_context"> begin:</span>
 
 	prev_drop_count = q-&gt;cstats.drop_count;
 	prev_ecn_mark = q-&gt;cstats.ecn_mark;
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 
 	skb = codel_dequeue(sch, &amp;q-&gt;cparams, &amp;flow-&gt;cvars, &amp;q-&gt;cstats,
 			    dequeue);
<span class="p_chunk">@@ -276,12 +279,14 @@</span> <span class="p_context"> begin:</span>
 	}
 	qdisc_bstats_update(sch, skb);
 	flow-&gt;deficit -= qdisc_pkt_len(skb);
<span class="p_del">-	/* We cant call qdisc_tree_decrease_qlen() if our qlen is 0,</span>
<span class="p_add">+	/* We cant call qdisc_tree_reduce_backlog() if our qlen is 0,</span>
 	 * or HTB crashes. Defer it for next round.
 	 */
 	if (q-&gt;cstats.drop_count &amp;&amp; sch-&gt;q.qlen) {
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, q-&gt;cstats.drop_count);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, q-&gt;cstats.drop_count,</span>
<span class="p_add">+					  q-&gt;cstats.drop_len);</span>
 		q-&gt;cstats.drop_count = 0;
<span class="p_add">+		q-&gt;cstats.drop_len = 0;</span>
 	}
 	return skb;
 }
<span class="p_chunk">@@ -372,11 +377,13 @@</span> <span class="p_context"> static int fq_codel_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = fq_codel_dequeue(sch);
 
<span class="p_add">+		q-&gt;cstats.drop_len += qdisc_pkt_len(skb);</span>
 		kfree_skb(skb);
 		q-&gt;cstats.drop_count++;
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, q-&gt;cstats.drop_count);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, q-&gt;cstats.drop_count, q-&gt;cstats.drop_len);</span>
 	q-&gt;cstats.drop_count = 0;
<span class="p_add">+	q-&gt;cstats.drop_len = 0;</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index 16bc83b2842a..aa4725038f94 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -159,12 +159,15 @@</span> <span class="p_context"> int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,</span>
 	if (validate)
 		skb = validate_xmit_skb_list(skb, dev);
 
<span class="p_del">-	if (skb) {</span>
<span class="p_add">+	if (likely(skb)) {</span>
 		HARD_TX_LOCK(dev, txq, smp_processor_id());
 		if (!netif_xmit_frozen_or_stopped(txq))
 			skb = dev_hard_start_xmit(skb, dev, txq, &amp;ret);
 
 		HARD_TX_UNLOCK(dev, txq);
<span class="p_add">+	} else {</span>
<span class="p_add">+		spin_lock(root_lock);</span>
<span class="p_add">+		return qdisc_qlen(q);</span>
 	}
 	spin_lock(root_lock);
 
<span class="p_header">diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c</span>
<span class="p_header">index b7ebe2c87586..d783d7cc3348 100644</span>
<span class="p_header">--- a/net/sched/sch_hfsc.c</span>
<span class="p_header">+++ b/net/sched/sch_hfsc.c</span>
<span class="p_chunk">@@ -895,9 +895,10 @@</span> <span class="p_context"> static void</span>
 hfsc_purge_queue(struct Qdisc *sch, struct hfsc_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static void
<span class="p_chunk">@@ -1215,11 +1216,7 @@</span> <span class="p_context"> hfsc_graft_class(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	hfsc_purge_queue(sch, cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_hhf.c b/net/sched/sch_hhf.c</span>
<span class="p_header">index 86b04e31e60b..13d6f83ec491 100644</span>
<span class="p_header">--- a/net/sched/sch_hhf.c</span>
<span class="p_header">+++ b/net/sched/sch_hhf.c</span>
<span class="p_chunk">@@ -382,6 +382,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	struct hhf_sched_data *q = qdisc_priv(sch);
 	enum wdrr_bucket_idx idx;
 	struct wdrr_bucket *bucket;
<span class="p_add">+	unsigned int prev_backlog;</span>
 
 	idx = hhf_classify(skb, sch);
 
<span class="p_chunk">@@ -409,6 +410,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	if (++sch-&gt;q.qlen &lt;= sch-&gt;limit)
 		return NET_XMIT_SUCCESS;
 
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	q-&gt;drop_overlimit++;
 	/* Return Congestion Notification only if we dropped a packet from this
 	 * bucket.
<span class="p_chunk">@@ -417,7 +419,7 @@</span> <span class="p_context"> static int hhf_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this. */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, prev_backlog - sch-&gt;qstats.backlog);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -527,7 +529,7 @@</span> <span class="p_context"> static int hhf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct hhf_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_HHF_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, prev_backlog;</span>
 	int err;
 	u64 non_hh_quantum;
 	u32 new_quantum = q-&gt;quantum;
<span class="p_chunk">@@ -577,12 +579,14 @@</span> <span class="p_context"> static int hhf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	}
 
 	qlen = sch-&gt;q.qlen;
<span class="p_add">+	prev_backlog = sch-&gt;qstats.backlog;</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = hhf_dequeue(sch);
 
 		kfree_skb(skb);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen,</span>
<span class="p_add">+				  prev_backlog - sch-&gt;qstats.backlog);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c</span>
<span class="p_header">index 15ccd7f8fb2a..87b02ed3d5f2 100644</span>
<span class="p_header">--- a/net/sched/sch_htb.c</span>
<span class="p_header">+++ b/net/sched/sch_htb.c</span>
<span class="p_chunk">@@ -600,6 +600,7 @@</span> <span class="p_context"> static int htb_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		htb_activate(q, cl);
 	}
 
<span class="p_add">+	qdisc_qstats_backlog_inc(sch, skb);</span>
 	sch-&gt;q.qlen++;
 	return NET_XMIT_SUCCESS;
 }
<span class="p_chunk">@@ -889,6 +890,7 @@</span> <span class="p_context"> static struct sk_buff *htb_dequeue(struct Qdisc *sch)</span>
 ok:
 		qdisc_bstats_update(sch, skb);
 		qdisc_unthrottled(sch);
<span class="p_add">+		qdisc_qstats_backlog_dec(sch, skb);</span>
 		sch-&gt;q.qlen--;
 		return skb;
 	}
<span class="p_chunk">@@ -955,6 +957,7 @@</span> <span class="p_context"> static unsigned int htb_drop(struct Qdisc *sch)</span>
 			unsigned int len;
 			if (cl-&gt;un.leaf.q-&gt;ops-&gt;drop &amp;&amp;
 			    (len = cl-&gt;un.leaf.q-&gt;ops-&gt;drop(cl-&gt;un.leaf.q))) {
<span class="p_add">+				sch-&gt;qstats.backlog -= len;</span>
 				sch-&gt;q.qlen--;
 				if (!cl-&gt;un.leaf.q-&gt;q.qlen)
 					htb_deactivate(q, cl);
<span class="p_chunk">@@ -984,12 +987,12 @@</span> <span class="p_context"> static void htb_reset(struct Qdisc *sch)</span>
 			}
 			cl-&gt;prio_activity = 0;
 			cl-&gt;cmode = HTB_CAN_SEND;
<span class="p_del">-</span>
 		}
 	}
 	qdisc_watchdog_cancel(&amp;q-&gt;watchdog);
 	__skb_queue_purge(&amp;q-&gt;direct_queue);
 	sch-&gt;q.qlen = 0;
<span class="p_add">+	sch-&gt;qstats.backlog = 0;</span>
 	memset(q-&gt;hlevel, 0, sizeof(q-&gt;hlevel));
 	memset(q-&gt;row_mask, 0, sizeof(q-&gt;row_mask));
 	for (i = 0; i &lt; TC_HTB_NUMPRIO; i++)
<span class="p_chunk">@@ -1163,14 +1166,7 @@</span> <span class="p_context"> static int htb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 				     cl-&gt;common.classid)) == NULL)
 		return -ENOBUFS;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = cl-&gt;un.leaf.q;</span>
<span class="p_del">-	cl-&gt;un.leaf.q = new;</span>
<span class="p_del">-	if (*old != NULL) {</span>
<span class="p_del">-		qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-		qdisc_reset(*old);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;un.leaf.q);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1272,7 +1268,6 @@</span> <span class="p_context"> static int htb_delete(struct Qdisc *sch, unsigned long arg)</span>
 {
 	struct htb_sched *q = qdisc_priv(sch);
 	struct htb_class *cl = (struct htb_class *)arg;
<span class="p_del">-	unsigned int qlen;</span>
 	struct Qdisc *new_q = NULL;
 	int last_child = 0;
 
<span class="p_chunk">@@ -1292,9 +1287,11 @@</span> <span class="p_context"> static int htb_delete(struct Qdisc *sch, unsigned long arg)</span>
 	sch_tree_lock(sch);
 
 	if (!cl-&gt;level) {
<span class="p_del">-		qlen = cl-&gt;un.leaf.q-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int qlen = cl-&gt;un.leaf.q-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int backlog = cl-&gt;un.leaf.q-&gt;qstats.backlog;</span>
<span class="p_add">+</span>
 		qdisc_reset(cl-&gt;un.leaf.q);
<span class="p_del">-		qdisc_tree_decrease_qlen(cl-&gt;un.leaf.q, qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(cl-&gt;un.leaf.q, qlen, backlog);</span>
 	}
 
 	/* delete from hash and active; remainder in destroy_class */
<span class="p_chunk">@@ -1428,10 +1425,11 @@</span> <span class="p_context"> static int htb_change_class(struct Qdisc *sch, u32 classid,</span>
 		sch_tree_lock(sch);
 		if (parent &amp;&amp; !parent-&gt;level) {
 			unsigned int qlen = parent-&gt;un.leaf.q-&gt;q.qlen;
<span class="p_add">+			unsigned int backlog = parent-&gt;un.leaf.q-&gt;qstats.backlog;</span>
 
 			/* turn parent into inner node */
 			qdisc_reset(parent-&gt;un.leaf.q);
<span class="p_del">-			qdisc_tree_decrease_qlen(parent-&gt;un.leaf.q, qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(parent-&gt;un.leaf.q, qlen, backlog);</span>
 			qdisc_destroy(parent-&gt;un.leaf.q);
 			if (parent-&gt;prio_activity)
 				htb_deactivate(q, parent);
<span class="p_header">diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c</span>
<span class="p_header">index 4e904ca0af9d..bcdd54bb101c 100644</span>
<span class="p_header">--- a/net/sched/sch_multiq.c</span>
<span class="p_header">+++ b/net/sched/sch_multiq.c</span>
<span class="p_chunk">@@ -218,7 +218,8 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 		if (q-&gt;queues[i] != &amp;noop_qdisc) {
 			struct Qdisc *child = q-&gt;queues[i];
 			q-&gt;queues[i] = &amp;noop_qdisc;
<span class="p_del">-			qdisc_tree_decrease_qlen(child, child-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(child, child-&gt;q.qlen,</span>
<span class="p_add">+						  child-&gt;qstats.backlog);</span>
 			qdisc_destroy(child);
 		}
 	}
<span class="p_chunk">@@ -238,8 +239,9 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 				q-&gt;queues[i] = child;
 
 				if (old != &amp;noop_qdisc) {
<span class="p_del">-					qdisc_tree_decrease_qlen(old,</span>
<span class="p_del">-								 old-&gt;q.qlen);</span>
<span class="p_add">+					qdisc_tree_reduce_backlog(old,</span>
<span class="p_add">+								  old-&gt;q.qlen,</span>
<span class="p_add">+								  old-&gt;qstats.backlog);</span>
 					qdisc_destroy(old);
 				}
 				sch_tree_unlock(sch);
<span class="p_chunk">@@ -303,13 +305,7 @@</span> <span class="p_context"> static int multiq_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;queues[band];</span>
<span class="p_del">-	q-&gt;queues[band] = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;queues[band]);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c</span>
<span class="p_header">index 5abd1d9de989..4befe97a9034 100644</span>
<span class="p_header">--- a/net/sched/sch_netem.c</span>
<span class="p_header">+++ b/net/sched/sch_netem.c</span>
<span class="p_chunk">@@ -395,6 +395,25 @@</span> <span class="p_context"> static void tfifo_enqueue(struct sk_buff *nskb, struct Qdisc *sch)</span>
 	sch-&gt;q.qlen++;
 }
 
<span class="p_add">+/* netem can&#39;t properly corrupt a megapacket (like we get from GSO), so instead</span>
<span class="p_add">+ * when we statistically choose to corrupt one, we instead segment it, returning</span>
<span class="p_add">+ * the first packet to be corrupted, and re-enqueue the remaining frames</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sk_buff *netem_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *segs;</span>
<span class="p_add">+	netdev_features_t features = netif_skb_features(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs)) {</span>
<span class="p_add">+		qdisc_reshape_fail(skb, sch);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	return segs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Insert one skb into qdisc.
  * Note: parent depends on return value to account for queue length.
<span class="p_chunk">@@ -407,7 +426,11 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	/* We don&#39;t fill cb now as skb_unshare() may invalidate it */
 	struct netem_skb_cb *cb;
 	struct sk_buff *skb2;
<span class="p_add">+	struct sk_buff *segs = NULL;</span>
<span class="p_add">+	unsigned int len = 0, last_len, prev_len = qdisc_pkt_len(skb);</span>
<span class="p_add">+	int nb = 0;</span>
 	int count = 1;
<span class="p_add">+	int rc = NET_XMIT_SUCCESS;</span>
 
 	/* Random duplication */
 	if (q-&gt;duplicate &amp;&amp; q-&gt;duplicate &gt;= get_crandom(&amp;q-&gt;dup_cor))
<span class="p_chunk">@@ -453,10 +476,23 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	 * do it now in software before we mangle it.
 	 */
 	if (q-&gt;corrupt &amp;&amp; q-&gt;corrupt &gt;= get_crandom(&amp;q-&gt;corrupt_cor)) {
<span class="p_add">+		if (skb_is_gso(skb)) {</span>
<span class="p_add">+			segs = netem_segment(skb, sch);</span>
<span class="p_add">+			if (!segs)</span>
<span class="p_add">+				return NET_XMIT_DROP;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			segs = skb;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		skb = segs;</span>
<span class="p_add">+		segs = segs-&gt;next;</span>
<span class="p_add">+</span>
 		if (!(skb = skb_unshare(skb, GFP_ATOMIC)) ||
 		    (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;
<span class="p_del">-		     skb_checksum_help(skb)))</span>
<span class="p_del">-			return qdisc_drop(skb, sch);</span>
<span class="p_add">+		     skb_checksum_help(skb))) {</span>
<span class="p_add">+			rc = qdisc_drop(skb, sch);</span>
<span class="p_add">+			goto finish_segs;</span>
<span class="p_add">+		}</span>
 
 		skb-&gt;data[prandom_u32() % skb_headlen(skb)] ^=
 			1&lt;&lt;(prandom_u32() % 8);
<span class="p_chunk">@@ -516,6 +552,27 @@</span> <span class="p_context"> static int netem_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		sch-&gt;qstats.requeues++;
 	}
 
<span class="p_add">+finish_segs:</span>
<span class="p_add">+	if (segs) {</span>
<span class="p_add">+		while (segs) {</span>
<span class="p_add">+			skb2 = segs-&gt;next;</span>
<span class="p_add">+			segs-&gt;next = NULL;</span>
<span class="p_add">+			qdisc_skb_cb(segs)-&gt;pkt_len = segs-&gt;len;</span>
<span class="p_add">+			last_len = segs-&gt;len;</span>
<span class="p_add">+			rc = qdisc_enqueue(segs, sch);</span>
<span class="p_add">+			if (rc != NET_XMIT_SUCCESS) {</span>
<span class="p_add">+				if (net_xmit_drop_count(rc))</span>
<span class="p_add">+					qdisc_qstats_drop(sch);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				nb++;</span>
<span class="p_add">+				len += last_len;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			segs = skb2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		sch-&gt;q.qlen += nb;</span>
<span class="p_add">+		if (nb &gt; 1)</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(sch, 1 - nb, prev_len - len);</span>
<span class="p_add">+	}</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -598,7 +655,8 @@</span> <span class="p_context"> deliver:</span>
 				if (unlikely(err != NET_XMIT_SUCCESS)) {
 					if (net_xmit_drop_count(err)) {
 						qdisc_qstats_drop(sch);
<span class="p_del">-						qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+						qdisc_tree_reduce_backlog(sch, 1,</span>
<span class="p_add">+									  qdisc_pkt_len(skb));</span>
 					}
 				}
 				goto tfifo_dequeue;
<span class="p_chunk">@@ -1037,15 +1095,7 @@</span> <span class="p_context"> static int netem_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 {
 	struct netem_sched_data *q = qdisc_priv(sch);
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	if (*old) {</span>
<span class="p_del">-		qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-		qdisc_reset(*old);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_pie.c b/net/sched/sch_pie.c</span>
<span class="p_header">index b783a446d884..71ae3b9629f9 100644</span>
<span class="p_header">--- a/net/sched/sch_pie.c</span>
<span class="p_header">+++ b/net/sched/sch_pie.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static int pie_change(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct pie_sched_data *q = qdisc_priv(sch);
 	struct nlattr *tb[TCA_PIE_MAX + 1];
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	int err;
 
 	if (!opt)
<span class="p_chunk">@@ -232,10 +232,11 @@</span> <span class="p_context"> static int pie_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	while (sch-&gt;q.qlen &gt; sch-&gt;limit) {
 		struct sk_buff *skb = __skb_dequeue(&amp;sch-&gt;q);
 
<span class="p_add">+		dropped += qdisc_pkt_len(skb);</span>
 		qdisc_qstats_backlog_dec(sch, skb);
 		qdisc_drop(skb, sch);
 	}
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	sch_tree_unlock(sch);
 	return 0;
<span class="p_header">diff --git a/net/sched/sch_prio.c b/net/sched/sch_prio.c</span>
<span class="p_header">index ba6487f2741f..fee1b15506b2 100644</span>
<span class="p_header">--- a/net/sched/sch_prio.c</span>
<span class="p_header">+++ b/net/sched/sch_prio.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> static int prio_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 		struct Qdisc *child = q-&gt;queues[i];
 		q-&gt;queues[i] = &amp;noop_qdisc;
 		if (child != &amp;noop_qdisc) {
<span class="p_del">-			qdisc_tree_decrease_qlen(child, child-&gt;q.qlen);</span>
<span class="p_add">+			qdisc_tree_reduce_backlog(child, child-&gt;q.qlen, child-&gt;qstats.backlog);</span>
 			qdisc_destroy(child);
 		}
 	}
<span class="p_chunk">@@ -210,8 +210,9 @@</span> <span class="p_context"> static int prio_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 				q-&gt;queues[i] = child;
 
 				if (old != &amp;noop_qdisc) {
<span class="p_del">-					qdisc_tree_decrease_qlen(old,</span>
<span class="p_del">-								 old-&gt;q.qlen);</span>
<span class="p_add">+					qdisc_tree_reduce_backlog(old,</span>
<span class="p_add">+								  old-&gt;q.qlen,</span>
<span class="p_add">+								  old-&gt;qstats.backlog);</span>
 					qdisc_destroy(old);
 				}
 				sch_tree_unlock(sch);
<span class="p_chunk">@@ -268,13 +269,7 @@</span> <span class="p_context"> static int prio_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;queues[band];</span>
<span class="p_del">-	q-&gt;queues[band] = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;queues[band]);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_qfq.c b/net/sched/sch_qfq.c</span>
<span class="p_header">index 3dc3a6e56052..8d2d8d953432 100644</span>
<span class="p_header">--- a/net/sched/sch_qfq.c</span>
<span class="p_header">+++ b/net/sched/sch_qfq.c</span>
<span class="p_chunk">@@ -220,9 +220,10 @@</span> <span class="p_context"> static struct qfq_class *qfq_find_class(struct Qdisc *sch, u32 classid)</span>
 static void qfq_purge_queue(struct qfq_class *cl)
 {
 	unsigned int len = cl-&gt;qdisc-&gt;q.qlen;
<span class="p_add">+	unsigned int backlog = cl-&gt;qdisc-&gt;qstats.backlog;</span>
 
 	qdisc_reset(cl-&gt;qdisc);
<span class="p_del">-	qdisc_tree_decrease_qlen(cl-&gt;qdisc, len);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(cl-&gt;qdisc, len, backlog);</span>
 }
 
 static const struct nla_policy qfq_policy[TCA_QFQ_MAX + 1] = {
<span class="p_chunk">@@ -617,11 +618,7 @@</span> <span class="p_context"> static int qfq_graft_class(struct Qdisc *sch, unsigned long arg,</span>
 			new = &amp;noop_qdisc;
 	}
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	qfq_purge_queue(cl);</span>
<span class="p_del">-	*old = cl-&gt;qdisc;</span>
<span class="p_del">-	cl-&gt;qdisc = new;</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;cl-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_red.c b/net/sched/sch_red.c</span>
<span class="p_header">index 6c0534cc7758..8c0508c0e287 100644</span>
<span class="p_header">--- a/net/sched/sch_red.c</span>
<span class="p_header">+++ b/net/sched/sch_red.c</span>
<span class="p_chunk">@@ -210,7 +210,8 @@</span> <span class="p_context"> static int red_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	q-&gt;flags = ctl-&gt;flags;
 	q-&gt;limit = ctl-&gt;limit;
 	if (child) {
<span class="p_del">-		qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+					  q-&gt;qdisc-&gt;qstats.backlog);</span>
 		qdisc_destroy(q-&gt;qdisc);
 		q-&gt;qdisc = child;
 	}
<span class="p_chunk">@@ -313,12 +314,7 @@</span> <span class="p_context"> static int red_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_sfb.c b/net/sched/sch_sfb.c</span>
<span class="p_header">index 5bbb6332ec57..c69611640fa5 100644</span>
<span class="p_header">--- a/net/sched/sch_sfb.c</span>
<span class="p_header">+++ b/net/sched/sch_sfb.c</span>
<span class="p_chunk">@@ -510,7 +510,8 @@</span> <span class="p_context"> static int sfb_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch_tree_lock(sch);
 
<span class="p_del">-	qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+				  q-&gt;qdisc-&gt;qstats.backlog);</span>
 	qdisc_destroy(q-&gt;qdisc);
 	q-&gt;qdisc = child;
 
<span class="p_chunk">@@ -606,12 +607,7 @@</span> <span class="p_context"> static int sfb_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c</span>
<span class="p_header">index 3abab534eb5c..498f0a2cb47f 100644</span>
<span class="p_header">--- a/net/sched/sch_sfq.c</span>
<span class="p_header">+++ b/net/sched/sch_sfq.c</span>
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static int</span>
 sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 {
 	struct sfq_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	unsigned int hash;</span>
<span class="p_add">+	unsigned int hash, dropped;</span>
 	sfq_index x, qlen;
 	struct sfq_slot *slot;
 	int uninitialized_var(ret);
<span class="p_chunk">@@ -461,7 +461,7 @@</span> <span class="p_context"> enqueue:</span>
 		return NET_XMIT_SUCCESS;
 
 	qlen = slot-&gt;qlen;
<span class="p_del">-	sfq_drop(sch);</span>
<span class="p_add">+	dropped = sfq_drop(sch);</span>
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
 	 */
<span class="p_chunk">@@ -469,7 +469,7 @@</span> <span class="p_context"> enqueue:</span>
 		return NET_XMIT_CN;
 
 	/* As we dropped a packet, better let upper stack know this */
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, 1);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, 1, dropped);</span>
 	return NET_XMIT_SUCCESS;
 }
 
<span class="p_chunk">@@ -537,6 +537,7 @@</span> <span class="p_context"> static void sfq_rehash(struct Qdisc *sch)</span>
 	struct sfq_slot *slot;
 	struct sk_buff_head list;
 	int dropped = 0;
<span class="p_add">+	unsigned int drop_len = 0;</span>
 
 	__skb_queue_head_init(&amp;list);
 
<span class="p_chunk">@@ -565,6 +566,7 @@</span> <span class="p_context"> static void sfq_rehash(struct Qdisc *sch)</span>
 			if (x &gt;= SFQ_MAX_FLOWS) {
 drop:
 				qdisc_qstats_backlog_dec(sch, skb);
<span class="p_add">+				drop_len += qdisc_pkt_len(skb);</span>
 				kfree_skb(skb);
 				dropped++;
 				continue;
<span class="p_chunk">@@ -594,7 +596,7 @@</span> <span class="p_context"> drop:</span>
 		}
 	}
 	sch-&gt;q.qlen -= dropped;
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, dropped);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, dropped, drop_len);</span>
 }
 
 static void sfq_perturbation(unsigned long arg)
<span class="p_chunk">@@ -618,7 +620,7 @@</span> <span class="p_context"> static int sfq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct sfq_sched_data *q = qdisc_priv(sch);
 	struct tc_sfq_qopt *ctl = nla_data(opt);
 	struct tc_sfq_qopt_v1 *ctl_v1 = NULL;
<span class="p_del">-	unsigned int qlen;</span>
<span class="p_add">+	unsigned int qlen, dropped = 0;</span>
 	struct red_parms *p = NULL;
 
 	if (opt-&gt;nla_len &lt; nla_attr_size(sizeof(*ctl)))
<span class="p_chunk">@@ -667,8 +669,8 @@</span> <span class="p_context"> static int sfq_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	qlen = sch-&gt;q.qlen;
 	while (sch-&gt;q.qlen &gt; q-&gt;limit)
<span class="p_del">-		sfq_drop(sch);</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(sch, qlen - sch-&gt;q.qlen);</span>
<span class="p_add">+		dropped += sfq_drop(sch);</span>
<span class="p_add">+	qdisc_tree_reduce_backlog(sch, qlen - sch-&gt;q.qlen, dropped);</span>
 
 	del_timer(&amp;q-&gt;perturb_timer);
 	if (q-&gt;perturb_period) {
<span class="p_header">diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c</span>
<span class="p_header">index a4afde14e865..c2fbde742f37 100644</span>
<span class="p_header">--- a/net/sched/sch_tbf.c</span>
<span class="p_header">+++ b/net/sched/sch_tbf.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 	struct tbf_sched_data *q = qdisc_priv(sch);
 	struct sk_buff *segs, *nskb;
 	netdev_features_t features = netif_skb_features(skb);
<span class="p_add">+	unsigned int len = 0, prev_len = qdisc_pkt_len(skb);</span>
 	int ret, nb;
 
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
<span class="p_chunk">@@ -172,6 +173,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 		nskb = segs-&gt;next;
 		segs-&gt;next = NULL;
 		qdisc_skb_cb(segs)-&gt;pkt_len = segs-&gt;len;
<span class="p_add">+		len += segs-&gt;len;</span>
 		ret = qdisc_enqueue(segs, q-&gt;qdisc);
 		if (ret != NET_XMIT_SUCCESS) {
 			if (net_xmit_drop_count(ret))
<span class="p_chunk">@@ -183,7 +185,7 @@</span> <span class="p_context"> static int tbf_segment(struct sk_buff *skb, struct Qdisc *sch)</span>
 	}
 	sch-&gt;q.qlen += nb;
 	if (nb &gt; 1)
<span class="p_del">-		qdisc_tree_decrease_qlen(sch, 1 - nb);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 1 - nb, prev_len - len);</span>
 	consume_skb(skb);
 	return nb &gt; 0 ? NET_XMIT_SUCCESS : NET_XMIT_DROP;
 }
<span class="p_chunk">@@ -399,7 +401,8 @@</span> <span class="p_context"> static int tbf_change(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch_tree_lock(sch);
 	if (child) {
<span class="p_del">-		qdisc_tree_decrease_qlen(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen);</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(q-&gt;qdisc, q-&gt;qdisc-&gt;q.qlen,</span>
<span class="p_add">+					  q-&gt;qdisc-&gt;qstats.backlog);</span>
 		qdisc_destroy(q-&gt;qdisc);
 		q-&gt;qdisc = child;
 	}
<span class="p_chunk">@@ -502,13 +505,7 @@</span> <span class="p_context"> static int tbf_graft(struct Qdisc *sch, unsigned long arg, struct Qdisc *new,</span>
 	if (new == NULL)
 		new = &amp;noop_qdisc;
 
<span class="p_del">-	sch_tree_lock(sch);</span>
<span class="p_del">-	*old = q-&gt;qdisc;</span>
<span class="p_del">-	q-&gt;qdisc = new;</span>
<span class="p_del">-	qdisc_tree_decrease_qlen(*old, (*old)-&gt;q.qlen);</span>
<span class="p_del">-	qdisc_reset(*old);</span>
<span class="p_del">-	sch_tree_unlock(sch);</span>
<span class="p_del">-</span>
<span class="p_add">+	*old = qdisc_replace(sch, new, &amp;q-&gt;qdisc);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">index 7fd1220fbfa0..9b5bd6d142dc 100644</span>
<span class="p_header">--- a/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">+++ b/net/vmw_vsock/af_vsock.c</span>
<span class="p_chunk">@@ -1794,27 +1794,8 @@</span> <span class="p_context"> vsock_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,</span>
 	else if (sk-&gt;sk_shutdown &amp; RCV_SHUTDOWN)
 		err = 0;
 
<span class="p_del">-	if (copied &gt; 0) {</span>
<span class="p_del">-		/* We only do these additional bookkeeping/notification steps</span>
<span class="p_del">-		 * if we actually copied something out of the queue pair</span>
<span class="p_del">-		 * instead of just peeking ahead.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!(flags &amp; MSG_PEEK)) {</span>
<span class="p_del">-			/* If the other side has shutdown for sending and there</span>
<span class="p_del">-			 * is nothing more to read, then modify the socket</span>
<span class="p_del">-			 * state.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (vsk-&gt;peer_shutdown &amp; SEND_SHUTDOWN) {</span>
<span class="p_del">-				if (vsock_stream_has_data(vsk) &lt;= 0) {</span>
<span class="p_del">-					sk-&gt;sk_state = SS_UNCONNECTED;</span>
<span class="p_del">-					sock_set_flag(sk, SOCK_DONE);</span>
<span class="p_del">-					sk-&gt;sk_state_change(sk);</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (copied &gt; 0)</span>
 		err = copied;
<span class="p_del">-	}</span>
 
 out_wait:
 	finish_wait(sk_sleep(sk), &amp;wait);
<span class="p_header">diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c</span>
<span class="p_header">index 7ecd04c21360..997ff7b2509b 100644</span>
<span class="p_header">--- a/net/x25/x25_facilities.c</span>
<span class="p_header">+++ b/net/x25/x25_facilities.c</span>
<span class="p_chunk">@@ -277,6 +277,7 @@</span> <span class="p_context"> int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,</span>
 
 	memset(&amp;theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
<span class="p_add">+	memset(dte, 0, sizeof(*dte));</span>
 
 	len = x25_parse_facilities(skb, &amp;theirs, dte, &amp;x25-&gt;vc_facil_mask);
 	if (len &lt; 0)
<span class="p_header">diff --git a/samples/bpf/trace_output_kern.c b/samples/bpf/trace_output_kern.c</span>
<span class="p_header">index 8d8d1ec429eb..9b96f4fb8cea 100644</span>
<span class="p_header">--- a/samples/bpf/trace_output_kern.c</span>
<span class="p_header">+++ b/samples/bpf/trace_output_kern.c</span>
<span class="p_chunk">@@ -18,7 +18,6 @@</span> <span class="p_context"> int bpf_prog1(struct pt_regs *ctx)</span>
 		u64 cookie;
 	} data;
 
<span class="p_del">-	memset(&amp;data, 0, sizeof(data));</span>
 	data.pid = bpf_get_current_pid_tgid();
 	data.cookie = 0x12345678;
 
<span class="p_header">diff --git a/sound/pci/hda/hda_sysfs.c b/sound/pci/hda/hda_sysfs.c</span>
<span class="p_header">index 64e0d1d81ca5..9739fce9e032 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_sysfs.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_sysfs.c</span>
<span class="p_chunk">@@ -141,14 +141,6 @@</span> <span class="p_context"> static int reconfig_codec(struct hda_codec *codec)</span>
 	err = snd_hda_codec_configure(codec);
 	if (err &lt; 0)
 		goto error;
<span class="p_del">-	/* rebuild PCMs */</span>
<span class="p_del">-	err = snd_hda_codec_build_pcms(codec);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	/* rebuild mixers */</span>
<span class="p_del">-	err = snd_hda_codec_build_controls(codec);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto error;</span>
 	err = snd_card_register(codec-&gt;card);
  error:
 	snd_hda_power_down(codec);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index ac4490a96863..4918ffa5ba68 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -6426,6 +6426,7 @@</span> <span class="p_context"> enum {</span>
 	ALC668_FIXUP_DELL_DISABLE_AAMIX,
 	ALC668_FIXUP_DELL_XPS13,
 	ALC662_FIXUP_ASUS_Nx50,
<span class="p_add">+	ALC668_FIXUP_ASUS_Nx51,</span>
 };
 
 static const struct hda_fixup alc662_fixups[] = {
<span class="p_chunk">@@ -6672,6 +6673,15 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC662_FIXUP_BASS_1A
 	},
<span class="p_add">+	[ALC668_FIXUP_ASUS_Nx51] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{0x1a, 0x90170151}, /* bass speaker */</span>
<span class="p_add">+			{}</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC662_FIXUP_BASS_CHMAP,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
<span class="p_chunk">@@ -6694,11 +6704,14 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0698, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x069f, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1632, &quot;HP RP5800&quot;, ALC662_FIXUP_HP_RP5800),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x1080, &quot;Asus UX501VW&quot;, ALC668_FIXUP_HEADSET_MODE),</span>
 	SND_PCI_QUIRK(0x1043, 0x11cd, &quot;Asus N550&quot;, ALC662_FIXUP_ASUS_Nx50),
 	SND_PCI_QUIRK(0x1043, 0x13df, &quot;Asus N550JX&quot;, ALC662_FIXUP_BASS_1A),
 	SND_PCI_QUIRK(0x1043, 0x129d, &quot;Asus N750&quot;, ALC662_FIXUP_ASUS_Nx50),
 	SND_PCI_QUIRK(0x1043, 0x1477, &quot;ASUS N56VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x177d, &quot;ASUS N551&quot;, ALC668_FIXUP_ASUS_Nx51),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x17bd, &quot;ASUS N751&quot;, ALC668_FIXUP_ASUS_Nx51),</span>
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1bf3, &quot;ASUS N76VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x8469, &quot;ASUS mobo&quot;, ALC662_FIXUP_NO_JACK_DETECT),
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 001fb4dc0722..db11ecf0b74d 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1138,8 +1138,11 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x047F, 0x0415): /* Plantronics BT-300 */
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
<span class="p_add">+	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */</span>
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
<span class="p_add">+	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */</span>
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
<span class="p_add">+	case USB_ID(0x1de7, 0x0114): /* Phoenix Audio MT202pcs */</span>
 	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */
 		return true;
 	}
<span class="p_header">diff --git a/tools/lib/traceevent/parse-filter.c b/tools/lib/traceevent/parse-filter.c</span>
<span class="p_header">index 0144b3d1bb77..88cccea3ca99 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/parse-filter.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/parse-filter.c</span>
<span class="p_chunk">@@ -1164,11 +1164,11 @@</span> <span class="p_context"> process_filter(struct event_format *event, struct filter_arg **parg,</span>
 		current_op = current_exp;
 
 	ret = collapse_tree(current_op, parg, error_str);
<span class="p_add">+	/* collapse_tree() may free current_op, and updates parg accordingly */</span>
<span class="p_add">+	current_op = NULL;</span>
 	if (ret &lt; 0)
 		goto fail;
 
<span class="p_del">-	*parg = current_op;</span>
<span class="p_del">-</span>
 	free(token);
 	return 0;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



