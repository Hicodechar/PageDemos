
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 22, 2016, 10:44 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161022104457.GB10874@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9390643/mbox/"
   >mbox</a>
|
   <a href="/patch/9390643/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9390643/">/patch/9390643/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E479260762 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Oct 2016 10:45:26 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CD06828FAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Oct 2016 10:45:26 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BE75A28FBA; Sat, 22 Oct 2016 10:45:26 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F00BF28FAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Oct 2016 10:45:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S964921AbcJVKpE (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 22 Oct 2016 06:45:04 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:43113 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S936606AbcJVKpA (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 22 Oct 2016 06:45:00 -0400
Received: from localhost (m7926-0130885284.pck.nerim.net [62.212.119.48])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 5BF9094F;
	Sat, 22 Oct 2016 10:44:52 +0000 (UTC)
Date: Sat, 22 Oct 2016 12:44:57 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.4
Message-ID: &lt;20161022104457.GB10874@kroah.com&gt;
References: &lt;20161022104450.GA10874@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161022104450.GA10874@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 22, 2016, 10:44 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index f593300e310b..babaf8261941 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -12951,11 +12951,10 @@</span> <span class="p_context"> F:	arch/x86/xen/*swiotlb*</span>
 F:	drivers/xen/*swiotlb*
 
 XFS FILESYSTEM
<span class="p_del">-P:	Silicon Graphics Inc</span>
 M:	Dave Chinner &lt;david@fromorbit.com&gt;
<span class="p_del">-M:	xfs@oss.sgi.com</span>
<span class="p_del">-L:	xfs@oss.sgi.com</span>
<span class="p_del">-W:	http://oss.sgi.com/projects/xfs</span>
<span class="p_add">+M:	linux-xfs@vger.kernel.org</span>
<span class="p_add">+L:	linux-xfs@vger.kernel.org</span>
<span class="p_add">+W:	http://xfs.org/</span>
 T:	git git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs.git
 S:	Supported
 F:	Documentation/filesystems/xfs.txt
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 42eb45c86a42..82a36ab540a4 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 3</span>
<span class="p_add">+SUBLEVEL = 4</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arc/include/asm/irqflags-arcv2.h b/arch/arc/include/asm/irqflags-arcv2.h</span>
<span class="p_header">index d1ec7f6b31e0..e880dfa3fcd3 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/irqflags-arcv2.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/irqflags-arcv2.h</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"> static inline long arch_local_save_flags(void)</span>
 	 */
 	temp = (1 &lt;&lt; 5) |
 		((!!(temp &amp; STATUS_IE_MASK)) &lt;&lt; CLRI_STATUS_IE_BIT) |
<span class="p_del">-		(temp &amp; CLRI_STATUS_E_MASK);</span>
<span class="p_add">+		((temp &gt;&gt; 1) &amp; CLRI_STATUS_E_MASK);</span>
 	return temp;
 }
 
<span class="p_header">diff --git a/arch/arc/kernel/intc-arcv2.c b/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_header">index 6c24faf48b16..62b59409a5d9 100644</span>
<span class="p_header">--- a/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_header">+++ b/arch/arc/kernel/intc-arcv2.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> void arc_init_IRQ(void)</span>
 	tmp = read_aux_reg(0xa);
 	tmp |= STATUS_AD_MASK | (irq_prio &lt;&lt; 1);
 	tmp &amp;= ~STATUS_IE_MASK;
<span class="p_del">-	asm volatile(&quot;flag %0	\n&quot;::&quot;r&quot;(tmp));</span>
<span class="p_add">+	asm volatile(&quot;kflag %0	\n&quot;::&quot;r&quot;(tmp));</span>
 }
 
 static void arcv2_irq_mask(struct irq_data *data)
<span class="p_header">diff --git a/block/cfq-iosched.c b/block/cfq-iosched.c</span>
<span class="p_header">index cc2f6dbd4303..5e24d880306c 100644</span>
<span class="p_header">--- a/block/cfq-iosched.c</span>
<span class="p_header">+++ b/block/cfq-iosched.c</span>
<span class="p_chunk">@@ -3042,7 +3042,6 @@</span> <span class="p_context"> static struct request *cfq_check_fifo(struct cfq_queue *cfqq)</span>
 	if (ktime_get_ns() &lt; rq-&gt;fifo_time)
 		rq = NULL;
 
<span class="p_del">-	cfq_log_cfqq(cfqq-&gt;cfqd, cfqq, &quot;fifo=%p&quot;, rq);</span>
 	return rq;
 }
 
<span class="p_chunk">@@ -3420,6 +3419,9 @@</span> <span class="p_context"> static bool cfq_may_dispatch(struct cfq_data *cfqd, struct cfq_queue *cfqq)</span>
 {
 	unsigned int max_dispatch;
 
<span class="p_add">+	if (cfq_cfqq_must_dispatch(cfqq))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
 	/*
 	 * Drain async requests before we start sync IO
 	 */
<span class="p_chunk">@@ -3511,15 +3513,20 @@</span> <span class="p_context"> static bool cfq_dispatch_request(struct cfq_data *cfqd, struct cfq_queue *cfqq)</span>
 
 	BUG_ON(RB_EMPTY_ROOT(&amp;cfqq-&gt;sort_list));
 
<span class="p_add">+	rq = cfq_check_fifo(cfqq);</span>
<span class="p_add">+	if (rq)</span>
<span class="p_add">+		cfq_mark_cfqq_must_dispatch(cfqq);</span>
<span class="p_add">+</span>
 	if (!cfq_may_dispatch(cfqd, cfqq))
 		return false;
 
 	/*
 	 * follow expired path, else get first next available
 	 */
<span class="p_del">-	rq = cfq_check_fifo(cfqq);</span>
 	if (!rq)
 		rq = cfqq-&gt;next_rq;
<span class="p_add">+	else</span>
<span class="p_add">+		cfq_log_cfqq(cfqq-&gt;cfqd, cfqq, &quot;fifo=%p&quot;, rq);</span>
 
 	/*
 	 * insert request into driver dispatch list
<span class="p_chunk">@@ -3989,7 +3996,7 @@</span> <span class="p_context"> cfq_should_preempt(struct cfq_data *cfqd, struct cfq_queue *new_cfqq,</span>
 	 * if the new request is sync, but the currently running queue is
 	 * not, let the sync request have priority.
 	 */
<span class="p_del">-	if (rq_is_sync(rq) &amp;&amp; !cfq_cfqq_sync(cfqq))</span>
<span class="p_add">+	if (rq_is_sync(rq) &amp;&amp; !cfq_cfqq_sync(cfqq) &amp;&amp; !cfq_cfqq_must_dispatch(cfqq))</span>
 		return true;
 
 	/*
<span class="p_header">diff --git a/crypto/async_tx/async_pq.c b/crypto/async_tx/async_pq.c</span>
<span class="p_header">index 08b3ac68952b..f83de99d7d71 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_pq.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_pq.c</span>
<span class="p_chunk">@@ -368,8 +368,6 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 
 		dma_set_unmap(tx, unmap);
 		async_tx_submit(chan, tx, submit);
<span class="p_del">-</span>
<span class="p_del">-		return tx;</span>
 	} else {
 		struct page *p_src = P(blocks, disks);
 		struct page *q_src = Q(blocks, disks);
<span class="p_chunk">@@ -424,9 +422,11 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 		submit-&gt;cb_param = cb_param_orig;
 		submit-&gt;flags = flags_orig;
 		async_tx_sync_epilog(submit);
<span class="p_del">-</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		tx = NULL;</span>
 	}
<span class="p_add">+	dmaengine_unmap_put(unmap);</span>
<span class="p_add">+</span>
<span class="p_add">+	return tx;</span>
 }
 EXPORT_SYMBOL_GPL(async_syndrome_val);
 
<span class="p_header">diff --git a/crypto/ghash-generic.c b/crypto/ghash-generic.c</span>
<span class="p_header">index bac70995e064..12ad3e3a84e3 100644</span>
<span class="p_header">--- a/crypto/ghash-generic.c</span>
<span class="p_header">+++ b/crypto/ghash-generic.c</span>
<span class="p_chunk">@@ -14,24 +14,13 @@</span> <span class="p_context"></span>
 
 #include &lt;crypto/algapi.h&gt;
 #include &lt;crypto/gf128mul.h&gt;
<span class="p_add">+#include &lt;crypto/ghash.h&gt;</span>
 #include &lt;crypto/internal/hash.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/module.h&gt;
 
<span class="p_del">-#define GHASH_BLOCK_SIZE	16</span>
<span class="p_del">-#define GHASH_DIGEST_SIZE	16</span>
<span class="p_del">-</span>
<span class="p_del">-struct ghash_ctx {</span>
<span class="p_del">-	struct gf128mul_4k *gf128;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct ghash_desc_ctx {</span>
<span class="p_del">-	u8 buffer[GHASH_BLOCK_SIZE];</span>
<span class="p_del">-	u32 bytes;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_header">diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c</span>
<span class="p_header">index e1d5ea6d5e40..2accf784534e 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/core.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit/core.c</span>
<span class="p_chunk">@@ -2689,6 +2689,9 @@</span> <span class="p_context"> static void acpi_nfit_notify(struct acpi_device *adev, u32 event)</span>
 
 	dev_dbg(dev, &quot;%s: event: %d\n&quot;, __func__, event);
 
<span class="p_add">+	if (event != NFIT_NOTIFY_UPDATE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	device_lock(dev);
 	if (!dev-&gt;driver) {
 		/* dev-&gt;driver may be null if we&#39;re being removed */
<span class="p_header">diff --git a/drivers/acpi/nfit/nfit.h b/drivers/acpi/nfit/nfit.h</span>
<span class="p_header">index e894ded24d99..51d23f130d86 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/nfit.h</span>
<span class="p_header">+++ b/drivers/acpi/nfit/nfit.h</span>
<span class="p_chunk">@@ -78,6 +78,10 @@</span> <span class="p_context"> enum {</span>
 	NFIT_ARS_TIMEOUT = 90,
 };
 
<span class="p_add">+enum nfit_root_notifiers {</span>
<span class="p_add">+	NFIT_NOTIFY_UPDATE = 0x80,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct nfit_spa {
 	struct list_head list;
 	struct nd_region *nd_region;
<span class="p_header">diff --git a/drivers/base/dma-mapping.c b/drivers/base/dma-mapping.c</span>
<span class="p_header">index d799662f19eb..261420ddfe66 100644</span>
<span class="p_header">--- a/drivers/base/dma-mapping.c</span>
<span class="p_header">+++ b/drivers/base/dma-mapping.c</span>
<span class="p_chunk">@@ -334,7 +334,7 @@</span> <span class="p_context"> void dma_common_free_remap(void *cpu_addr, size_t size, unsigned long vm_flags)</span>
 		return;
 	}
 
<span class="p_del">-	unmap_kernel_range((unsigned long)cpu_addr, size);</span>
<span class="p_add">+	unmap_kernel_range((unsigned long)cpu_addr, PAGE_ALIGN(size));</span>
 	vunmap(cpu_addr);
 }
 #endif
<span class="p_header">diff --git a/drivers/clk/mvebu/cp110-system-controller.c b/drivers/clk/mvebu/cp110-system-controller.c</span>
<span class="p_header">index 7fa42d6b2b92..f2303da7fda7 100644</span>
<span class="p_header">--- a/drivers/clk/mvebu/cp110-system-controller.c</span>
<span class="p_header">+++ b/drivers/clk/mvebu/cp110-system-controller.c</span>
<span class="p_chunk">@@ -81,13 +81,6 @@</span> <span class="p_context"> enum {</span>
 #define CP110_GATE_EIP150		25
 #define CP110_GATE_EIP197		26
 
<span class="p_del">-static struct clk *cp110_clks[CP110_CLK_NUM];</span>
<span class="p_del">-</span>
<span class="p_del">-static struct clk_onecell_data cp110_clk_data = {</span>
<span class="p_del">-	.clks = cp110_clks,</span>
<span class="p_del">-	.clk_num = CP110_CLK_NUM,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 struct cp110_gate_clk {
 	struct clk_hw hw;
 	struct regmap *regmap;
<span class="p_chunk">@@ -142,6 +135,8 @@</span> <span class="p_context"> static struct clk *cp110_register_gate(const char *name,</span>
 	if (!gate)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	memset(&amp;init, 0, sizeof(init));</span>
<span class="p_add">+</span>
 	init.name = name;
 	init.ops = &amp;cp110_gate_ops;
 	init.parent_names = &amp;parent_name;
<span class="p_chunk">@@ -194,7 +189,8 @@</span> <span class="p_context"> static int cp110_syscon_clk_probe(struct platform_device *pdev)</span>
 	struct regmap *regmap;
 	struct device_node *np = pdev-&gt;dev.of_node;
 	const char *ppv2_name, *apll_name, *core_name, *eip_name, *nand_name;
<span class="p_del">-	struct clk *clk;</span>
<span class="p_add">+	struct clk_onecell_data *cp110_clk_data;</span>
<span class="p_add">+	struct clk *clk, **cp110_clks;</span>
 	u32 nand_clk_ctrl;
 	int i, ret;
 
<span class="p_chunk">@@ -207,6 +203,20 @@</span> <span class="p_context"> static int cp110_syscon_clk_probe(struct platform_device *pdev)</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	cp110_clks = devm_kcalloc(&amp;pdev-&gt;dev, sizeof(struct clk *),</span>
<span class="p_add">+				  CP110_CLK_NUM, GFP_KERNEL);</span>
<span class="p_add">+	if (!cp110_clks)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	cp110_clk_data = devm_kzalloc(&amp;pdev-&gt;dev,</span>
<span class="p_add">+				      sizeof(*cp110_clk_data),</span>
<span class="p_add">+				      GFP_KERNEL);</span>
<span class="p_add">+	if (!cp110_clk_data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	cp110_clk_data-&gt;clks = cp110_clks;</span>
<span class="p_add">+	cp110_clk_data-&gt;clk_num = CP110_CLK_NUM;</span>
<span class="p_add">+</span>
 	/* Register the APLL which is the root of the clk tree */
 	of_property_read_string_index(np, &quot;core-clock-output-names&quot;,
 				      CP110_CORE_APLL, &amp;apll_name);
<span class="p_chunk">@@ -334,10 +344,12 @@</span> <span class="p_context"> static int cp110_syscon_clk_probe(struct platform_device *pdev)</span>
 		cp110_clks[CP110_MAX_CORE_CLOCKS + i] = clk;
 	}
 
<span class="p_del">-	ret = of_clk_add_provider(np, cp110_of_clk_get, &amp;cp110_clk_data);</span>
<span class="p_add">+	ret = of_clk_add_provider(np, cp110_of_clk_get, cp110_clk_data);</span>
 	if (ret)
 		goto fail_clk_add;
 
<span class="p_add">+	platform_set_drvdata(pdev, cp110_clks);</span>
<span class="p_add">+</span>
 	return 0;
 
 fail_clk_add:
<span class="p_chunk">@@ -364,6 +376,7 @@</span> <span class="p_context"> fail0:</span>
 
 static int cp110_syscon_clk_remove(struct platform_device *pdev)
 {
<span class="p_add">+	struct clk **cp110_clks = platform_get_drvdata(pdev);</span>
 	int i;
 
 	of_clk_del_provider(pdev-&gt;dev.of_node);
<span class="p_header">diff --git a/drivers/crypto/vmx/ghash.c b/drivers/crypto/vmx/ghash.c</span>
<span class="p_header">index 6c999cb01b80..27a94a119009 100644</span>
<span class="p_header">--- a/drivers/crypto/vmx/ghash.c</span>
<span class="p_header">+++ b/drivers/crypto/vmx/ghash.c</span>
<span class="p_chunk">@@ -26,16 +26,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/hardirq.h&gt;
 #include &lt;asm/switch_to.h&gt;
 #include &lt;crypto/aes.h&gt;
<span class="p_add">+#include &lt;crypto/ghash.h&gt;</span>
 #include &lt;crypto/scatterwalk.h&gt;
 #include &lt;crypto/internal/hash.h&gt;
 #include &lt;crypto/b128ops.h&gt;
 
 #define IN_INTERRUPT in_interrupt()
 
<span class="p_del">-#define GHASH_BLOCK_SIZE (16)</span>
<span class="p_del">-#define GHASH_DIGEST_SIZE (16)</span>
<span class="p_del">-#define GHASH_KEY_LEN (16)</span>
<span class="p_del">-</span>
 void gcm_init_p8(u128 htable[16], const u64 Xi[2]);
 void gcm_gmult_p8(u64 Xi[2], const u128 htable[16]);
 void gcm_ghash_p8(u64 Xi[2], const u128 htable[16],
<span class="p_chunk">@@ -55,16 +52,11 @@</span> <span class="p_context"> struct p8_ghash_desc_ctx {</span>
 
 static int p8_ghash_init_tfm(struct crypto_tfm *tfm)
 {
<span class="p_del">-	const char *alg;</span>
<span class="p_add">+	const char *alg = &quot;ghash-generic&quot;;</span>
 	struct crypto_shash *fallback;
 	struct crypto_shash *shash_tfm = __crypto_shash_cast(tfm);
 	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(tfm);
 
<span class="p_del">-	if (!(alg = crypto_tfm_alg_name(tfm))) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;Failed to get algorithm name.\n&quot;);</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	fallback = crypto_alloc_shash(alg, 0, CRYPTO_ALG_NEED_FALLBACK);
 	if (IS_ERR(fallback)) {
 		printk(KERN_ERR
<span class="p_chunk">@@ -78,10 +70,18 @@</span> <span class="p_context"> static int p8_ghash_init_tfm(struct crypto_tfm *tfm)</span>
 	crypto_shash_set_flags(fallback,
 			       crypto_shash_get_flags((struct crypto_shash
 						       *) tfm));
<span class="p_del">-	ctx-&gt;fallback = fallback;</span>
 
<span class="p_del">-	shash_tfm-&gt;descsize = sizeof(struct p8_ghash_desc_ctx)</span>
<span class="p_del">-	    + crypto_shash_descsize(fallback);</span>
<span class="p_add">+	/* Check if the descsize defined in the algorithm is still enough. */</span>
<span class="p_add">+	if (shash_tfm-&gt;descsize &lt; sizeof(struct p8_ghash_desc_ctx)</span>
<span class="p_add">+	    + crypto_shash_descsize(fallback)) {</span>
<span class="p_add">+		printk(KERN_ERR</span>
<span class="p_add">+		       &quot;Desc size of the fallback implementation (%s) does not match the expected value: %lu vs %u\n&quot;,</span>
<span class="p_add">+		       alg,</span>
<span class="p_add">+		       shash_tfm-&gt;descsize - sizeof(struct p8_ghash_desc_ctx),</span>
<span class="p_add">+		       crypto_shash_descsize(fallback));</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ctx-&gt;fallback = fallback;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int p8_ghash_setkey(struct crypto_shash *tfm, const u8 *key,</span>
 {
 	struct p8_ghash_ctx *ctx = crypto_tfm_ctx(crypto_shash_tfm(tfm));
 
<span class="p_del">-	if (keylen != GHASH_KEY_LEN)</span>
<span class="p_add">+	if (keylen != GHASH_BLOCK_SIZE)</span>
 		return -EINVAL;
 
 	preempt_disable();
<span class="p_chunk">@@ -211,7 +211,8 @@</span> <span class="p_context"> struct shash_alg p8_ghash_alg = {</span>
 	.update = p8_ghash_update,
 	.final = p8_ghash_final,
 	.setkey = p8_ghash_setkey,
<span class="p_del">-	.descsize = sizeof(struct p8_ghash_desc_ctx),</span>
<span class="p_add">+	.descsize = sizeof(struct p8_ghash_desc_ctx)</span>
<span class="p_add">+		+ sizeof(struct ghash_desc_ctx),</span>
 	.base = {
 		 .cra_name = &quot;ghash&quot;,
 		 .cra_driver_name = &quot;p8_ghash&quot;,
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_drm_bus.c b/drivers/gpu/drm/virtio/virtgpu_drm_bus.c</span>
<span class="p_header">index 7f0e93f87a55..88a39165edd5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_drm_bus.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_drm_bus.c</span>
<span class="p_chunk">@@ -27,6 +27,16 @@</span> <span class="p_context"></span>
 
 #include &quot;virtgpu_drv.h&quot;
 
<span class="p_add">+int drm_virtio_set_busid(struct drm_device *dev, struct drm_master *master)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev = dev-&gt;pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pdev) {</span>
<span class="p_add">+		return drm_pci_set_busid(dev, master);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void virtio_pci_kick_out_firmware_fb(struct pci_dev *pci_dev)
 {
 	struct apertures_struct *ap;
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.c b/drivers/gpu/drm/virtio/virtgpu_drv.c</span>
<span class="p_header">index c13f70cfc461..5820b7020ae5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_drv.c</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> static const struct file_operations virtio_gpu_driver_fops = {</span>
 
 static struct drm_driver driver = {
 	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_PRIME | DRIVER_RENDER | DRIVER_ATOMIC,
<span class="p_add">+	.set_busid = drm_virtio_set_busid,</span>
 	.load = virtio_gpu_driver_load,
 	.unload = virtio_gpu_driver_unload,
 	.open = virtio_gpu_driver_open,
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_drv.h b/drivers/gpu/drm/virtio/virtgpu_drv.h</span>
<span class="p_header">index b18ef3111f0c..acf556a35cb2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_drv.h</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"></span>
 #define DRIVER_PATCHLEVEL 1
 
 /* virtgpu_drm_bus.c */
<span class="p_add">+int drm_virtio_set_busid(struct drm_device *dev, struct drm_master *master);</span>
 int drm_virtio_init(struct drm_driver *driver, struct virtio_device *vdev);
 
 struct virtio_gpu_object {
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/rc.c b/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_header">index 5da190e6011b..bcf76c33726b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/rc.c</span>
<span class="p_chunk">@@ -932,8 +932,10 @@</span> <span class="p_context"> void hfi1_send_rc_ack(struct hfi1_ctxtdata *rcd, struct rvt_qp *qp,</span>
 	return;
 
 queue_ack:
<span class="p_del">-	this_cpu_inc(*ibp-&gt;rvp.rc_qacks);</span>
 	spin_lock_irqsave(&amp;qp-&gt;s_lock, flags);
<span class="p_add">+	if (!(ib_rvt_state_ops[qp-&gt;state] &amp; RVT_PROCESS_RECV_OK))</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+	this_cpu_inc(*ibp-&gt;rvp.rc_qacks);</span>
 	qp-&gt;s_flags |= RVT_S_ACK_PENDING | RVT_S_RESP_PENDING;
 	qp-&gt;s_nak_state = qp-&gt;r_nak_state;
 	qp-&gt;s_ack_psn = qp-&gt;r_ack_psn;
<span class="p_chunk">@@ -942,6 +944,7 @@</span> <span class="p_context"> queue_ack:</span>
 
 	/* Schedule the send tasklet. */
 	hfi1_schedule_send(qp);
<span class="p_add">+unlock:</span>
 	spin_unlock_irqrestore(&amp;qp-&gt;s_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c</span>
<span class="p_header">index a039a5df6f21..fd9271bc1a11 100644</span>
<span class="p_header">--- a/drivers/misc/mei/amthif.c</span>
<span class="p_header">+++ b/drivers/misc/mei/amthif.c</span>
<span class="p_chunk">@@ -67,8 +67,12 @@</span> <span class="p_context"> int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)</span>
 	struct mei_cl *cl = &amp;dev-&gt;iamthif_cl;
 	int ret;
 
<span class="p_del">-	if (mei_cl_is_connected(cl))</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	mutex_lock(&amp;dev-&gt;device_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mei_cl_is_connected(cl)) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	dev-&gt;iamthif_state = MEI_IAMTHIF_IDLE;
 
<span class="p_chunk">@@ -77,11 +81,13 @@</span> <span class="p_context"> int mei_amthif_host_init(struct mei_device *dev, struct mei_me_client *me_cl)</span>
 	ret = mei_cl_link(cl);
 	if (ret &lt; 0) {
 		dev_err(dev-&gt;dev, &quot;amthif: failed cl_link %d\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	ret = mei_cl_connect(cl, me_cl, NULL);
 
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;dev-&gt;device_lock);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index 1f33fea9299f..e094df3cf2d5 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -983,12 +983,10 @@</span> <span class="p_context"> void mei_cl_bus_rescan_work(struct work_struct *work)</span>
 		container_of(work, struct mei_device, bus_rescan_work);
 	struct mei_me_client *me_cl;
 
<span class="p_del">-	mutex_lock(&amp;bus-&gt;device_lock);</span>
 	me_cl = mei_me_cl_by_uuid(bus, &amp;mei_amthif_guid);
 	if (me_cl)
 		mei_amthif_host_init(bus, me_cl);
 	mei_me_cl_put(me_cl);
<span class="p_del">-	mutex_unlock(&amp;bus-&gt;device_lock);</span>
 
 	mei_cl_bus_rescan(bus);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index d0b3a1bb82ca..dad15b6c66dd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -11360,6 +11360,12 @@</span> <span class="p_context"> static pci_ers_result_t i40e_pci_error_detected(struct pci_dev *pdev,</span>
 
 	dev_info(&amp;pdev-&gt;dev, &quot;%s: error %d\n&quot;, __func__, error);
 
<span class="p_add">+	if (!pf) {</span>
<span class="p_add">+		dev_info(&amp;pdev-&gt;dev,</span>
<span class="p_add">+			 &quot;Cannot recover - error happened during device probe\n&quot;);</span>
<span class="p_add">+		return PCI_ERS_RESULT_DISCONNECT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* shutdown all operations */
 	if (!test_bit(__I40E_SUSPENDED, &amp;pf-&gt;state)) {
 		rtnl_lock();
<span class="p_header">diff --git a/drivers/net/wireless/ath/carl9170/debug.c b/drivers/net/wireless/ath/carl9170/debug.c</span>
<span class="p_header">index 6808db433283..ec3a64e5d2bb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/carl9170/debug.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/carl9170/debug.c</span>
<span class="p_chunk">@@ -75,7 +75,8 @@</span> <span class="p_context"> static ssize_t carl9170_debugfs_read(struct file *file, char __user *userbuf,</span>
 
 	if (!ar)
 		return -ENODEV;
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct carl9170_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct carl9170_debugfs_fops, fops);</span>
 
 	if (!dfops-&gt;read)
 		return -ENOSYS;
<span class="p_chunk">@@ -127,7 +128,8 @@</span> <span class="p_context"> static ssize_t carl9170_debugfs_write(struct file *file,</span>
 
 	if (!ar)
 		return -ENODEV;
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct carl9170_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct carl9170_debugfs_fops, fops);</span>
 
 	if (!dfops-&gt;write)
 		return -ENOSYS;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/b43/debugfs.c b/drivers/net/wireless/broadcom/b43/debugfs.c</span>
<span class="p_header">index b4bcd94aff6c..77046384dd80 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/b43/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/b43/debugfs.c</span>
<span class="p_chunk">@@ -524,7 +524,8 @@</span> <span class="p_context"> static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct b43_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct b43_debugfs_fops, fops);</span>
 	if (!dfops-&gt;read) {
 		err = -ENOSYS;
 		goto out_unlock;
<span class="p_chunk">@@ -585,7 +586,8 @@</span> <span class="p_context"> static ssize_t b43_debugfs_write(struct file *file,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct b43_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct b43_debugfs_fops, fops);</span>
 	if (!dfops-&gt;write) {
 		err = -ENOSYS;
 		goto out_unlock;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/b43legacy/debugfs.c b/drivers/net/wireless/broadcom/b43legacy/debugfs.c</span>
<span class="p_header">index 090910ea259e..82ef56ed7ca1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/b43legacy/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/b43legacy/debugfs.c</span>
<span class="p_chunk">@@ -221,7 +221,8 @@</span> <span class="p_context"> static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct b43legacy_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct b43legacy_debugfs_fops, fops);</span>
 	if (!dfops-&gt;read) {
 		err = -ENOSYS;
 		goto out_unlock;
<span class="p_chunk">@@ -287,7 +288,8 @@</span> <span class="p_context"> static ssize_t b43legacy_debugfs_write(struct file *file,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	dfops = container_of(file-&gt;f_op, struct b43legacy_debugfs_fops, fops);</span>
<span class="p_add">+	dfops = container_of(debugfs_real_fops(file),</span>
<span class="p_add">+			     struct b43legacy_debugfs_fops, fops);</span>
 	if (!dfops-&gt;write) {
 		err = -ENOSYS;
 		goto out_unlock;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index b8aec5e5ef93..abaf003a5b39 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -2533,7 +2533,7 @@</span> <span class="p_context"> static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)</span>
 				     WL_BSS_INFO_MAX);
 	if (err) {
 		brcmf_err(&quot;Failed to get bss info (%d)\n&quot;, err);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_kfree;</span>
 	}
 	si-&gt;filled |= BIT(NL80211_STA_INFO_BSS_PARAM);
 	si-&gt;bss_param.beacon_interval = le16_to_cpu(buf-&gt;bss_le.beacon_period);
<span class="p_chunk">@@ -2545,6 +2545,9 @@</span> <span class="p_context"> static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)</span>
 		si-&gt;bss_param.flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE;
 	if (capability &amp; WLAN_CAPABILITY_SHORT_SLOT_TIME)
 		si-&gt;bss_param.flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME;
<span class="p_add">+</span>
<span class="p_add">+out_kfree:</span>
<span class="p_add">+	kfree(buf);</span>
 }
 
 static s32
<span class="p_chunk">@@ -3884,11 +3887,11 @@</span> <span class="p_context"> brcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,</span>
 	if (!check_vif_up(ifp-&gt;vif))
 		return -EIO;
 
<span class="p_del">-	brcmf_dbg(CONN, &quot;del_pmksa - PMK bssid = %pM\n&quot;, &amp;pmksa-&gt;bssid);</span>
<span class="p_add">+	brcmf_dbg(CONN, &quot;del_pmksa - PMK bssid = %pM\n&quot;, pmksa-&gt;bssid);</span>
 
 	npmk = le32_to_cpu(cfg-&gt;pmk_list.npmk);
 	for (i = 0; i &lt; npmk; i++)
<span class="p_del">-		if (!memcmp(&amp;pmksa-&gt;bssid, &amp;pmk[i].bssid, ETH_ALEN))</span>
<span class="p_add">+		if (!memcmp(pmksa-&gt;bssid, pmk[i].bssid, ETH_ALEN))</span>
 			break;
 
 	if ((npmk &gt; 0) &amp;&amp; (i &lt; npmk)) {
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c</span>
<span class="p_header">index 7e269f9aa607..63664442e687 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c</span>
<span class="p_chunk">@@ -234,13 +234,20 @@</span> <span class="p_context"> static void brcmf_flowring_block(struct brcmf_flowring *flow, u16 flowid,</span>
 
 void brcmf_flowring_delete(struct brcmf_flowring *flow, u16 flowid)
 {
<span class="p_add">+	struct brcmf_bus *bus_if = dev_get_drvdata(flow-&gt;dev);</span>
 	struct brcmf_flowring_ring *ring;
<span class="p_add">+	struct brcmf_if *ifp;</span>
 	u16 hash_idx;
<span class="p_add">+	u8 ifidx;</span>
 	struct sk_buff *skb;
 
 	ring = flow-&gt;rings[flowid];
 	if (!ring)
 		return;
<span class="p_add">+</span>
<span class="p_add">+	ifidx = brcmf_flowring_ifidx_get(flow, flowid);</span>
<span class="p_add">+	ifp = brcmf_get_ifp(bus_if-&gt;drvr, ifidx);</span>
<span class="p_add">+</span>
 	brcmf_flowring_block(flow, flowid, false);
 	hash_idx = ring-&gt;hash_id;
 	flow-&gt;hash[hash_idx].ifidx = BRCMF_FLOWRING_INVALID_IFIDX;
<span class="p_chunk">@@ -249,7 +256,7 @@</span> <span class="p_context"> void brcmf_flowring_delete(struct brcmf_flowring *flow, u16 flowid)</span>
 
 	skb = skb_dequeue(&amp;ring-&gt;skblist);
 	while (skb) {
<span class="p_del">-		brcmu_pkt_buf_free_skb(skb);</span>
<span class="p_add">+		brcmf_txfinalize(ifp, skb, false);</span>
 		skb = skb_dequeue(&amp;ring-&gt;skblist);
 	}
 
<span class="p_header">diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">index 7640498964a5..3d53d636b17b 100644</span>
<span class="p_header">--- a/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">+++ b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_chunk">@@ -2388,15 +2388,23 @@</span> <span class="p_context"> static int arcmsr_iop_message_xfer(struct AdapterControlBlock *acb,</span>
 	}
 	case ARCMSR_MESSAGE_WRITE_WQBUFFER: {
 		unsigned char *ver_addr;
<span class="p_del">-		int32_t user_len, cnt2end;</span>
<span class="p_add">+		uint32_t user_len;</span>
<span class="p_add">+		int32_t cnt2end;</span>
 		uint8_t *pQbuffer, *ptmpuserbuffer;
<span class="p_add">+</span>
<span class="p_add">+		user_len = pcmdmessagefld-&gt;cmdmessage.Length;</span>
<span class="p_add">+		if (user_len &gt; ARCMSR_API_DATA_BUFLEN) {</span>
<span class="p_add">+			retvalue = ARCMSR_MESSAGE_FAIL;</span>
<span class="p_add">+			goto message_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		ver_addr = kmalloc(ARCMSR_API_DATA_BUFLEN, GFP_ATOMIC);
 		if (!ver_addr) {
 			retvalue = ARCMSR_MESSAGE_FAIL;
 			goto message_out;
 		}
 		ptmpuserbuffer = ver_addr;
<span class="p_del">-		user_len = pcmdmessagefld-&gt;cmdmessage.Length;</span>
<span class="p_add">+</span>
 		memcpy(ptmpuserbuffer,
 			pcmdmessagefld-&gt;messagedatabuffer, user_len);
 		spin_lock_irqsave(&amp;acb-&gt;wqbuffer_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/ibmvscsi/ibmvfc.c b/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_header">index ab67ec4b6bd6..79c9860a165f 100644</span>
<span class="p_header">--- a/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_header">+++ b/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_chunk">@@ -717,7 +717,6 @@</span> <span class="p_context"> static int ibmvfc_reset_crq(struct ibmvfc_host *vhost)</span>
 	spin_lock_irqsave(vhost-&gt;host-&gt;host_lock, flags);
 	vhost-&gt;state = IBMVFC_NO_CRQ;
 	vhost-&gt;logged_in = 0;
<span class="p_del">-	ibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);</span>
 
 	/* Clean out the queue */
 	memset(crq-&gt;msgs, 0, PAGE_SIZE);
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c</span>
<span class="p_header">index e19969614203..b022f5a01e63 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_dw.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_dw.c</span>
<span class="p_chunk">@@ -462,7 +462,7 @@</span> <span class="p_context"> static int dw8250_probe(struct platform_device *pdev)</span>
 	}
 
 	data-&gt;pclk = devm_clk_get(&amp;pdev-&gt;dev, &quot;apb_pclk&quot;);
<span class="p_del">-	if (IS_ERR(data-&gt;clk) &amp;&amp; PTR_ERR(data-&gt;clk) == -EPROBE_DEFER) {</span>
<span class="p_add">+	if (IS_ERR(data-&gt;pclk) &amp;&amp; PTR_ERR(data-&gt;pclk) == -EPROBE_DEFER) {</span>
 		err = -EPROBE_DEFER;
 		goto err_clk;
 	}
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">index bdfa659b9606..858a54633664 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_port.c</span>
<span class="p_chunk">@@ -1414,12 +1414,8 @@</span> <span class="p_context"> static void __do_stop_tx_rs485(struct uart_8250_port *p)</span>
 	if (!(p-&gt;port.rs485.flags &amp; SER_RS485_RX_DURING_TX)) {
 		serial8250_clear_fifos(p);
 
<span class="p_del">-		serial8250_rpm_get(p);</span>
<span class="p_del">-</span>
 		p-&gt;ier |= UART_IER_RLSI | UART_IER_RDI;
 		serial_port_out(&amp;p-&gt;port, UART_IER, p-&gt;ier);
<span class="p_del">-</span>
<span class="p_del">-		serial8250_rpm_put(p);</span>
 	}
 }
 
<span class="p_chunk">@@ -1429,6 +1425,7 @@</span> <span class="p_context"> static void serial8250_em485_handle_stop_tx(unsigned long arg)</span>
 	struct uart_8250_em485 *em485 = p-&gt;em485;
 	unsigned long flags;
 
<span class="p_add">+	serial8250_rpm_get(p);</span>
 	spin_lock_irqsave(&amp;p-&gt;port.lock, flags);
 	if (em485 &amp;&amp;
 	    em485-&gt;active_timer == &amp;em485-&gt;stop_tx_timer) {
<span class="p_chunk">@@ -1436,6 +1433,7 @@</span> <span class="p_context"> static void serial8250_em485_handle_stop_tx(unsigned long arg)</span>
 		em485-&gt;active_timer = NULL;
 	}
 	spin_unlock_irqrestore(&amp;p-&gt;port.lock, flags);
<span class="p_add">+	serial8250_rpm_put(p);</span>
 }
 
 static void __stop_tx_rs485(struct uart_8250_port *p)
<span class="p_chunk">@@ -1475,7 +1473,7 @@</span> <span class="p_context"> static inline void __stop_tx(struct uart_8250_port *p)</span>
 		unsigned char lsr = serial_in(p, UART_LSR);
 		/*
 		 * To provide required timeing and allow FIFO transfer,
<span class="p_del">-		 * __stop_tx_rs485 must be called only when both FIFO and</span>
<span class="p_add">+		 * __stop_tx_rs485() must be called only when both FIFO and</span>
 		 * shift register are empty. It is for device driver to enable
 		 * interrupt on TEMT.
 		 */
<span class="p_chunk">@@ -1484,9 +1482,10 @@</span> <span class="p_context"> static inline void __stop_tx(struct uart_8250_port *p)</span>
 
 		del_timer(&amp;em485-&gt;start_tx_timer);
 		em485-&gt;active_timer = NULL;
<span class="p_add">+</span>
<span class="p_add">+		__stop_tx_rs485(p);</span>
 	}
 	__do_stop_tx(p);
<span class="p_del">-	__stop_tx_rs485(p);</span>
 }
 
 static void serial8250_stop_tx(struct uart_port *port)
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 2eaa18ddef61..8bbde52db376 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -1929,6 +1929,9 @@</span> <span class="p_context"> static void atmel_shutdown(struct uart_port *port)</span>
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
<span class="p_add">+	/* Disable modem control lines interrupts */</span>
<span class="p_add">+	atmel_disable_ms(port);</span>
<span class="p_add">+</span>
 	/* Disable interrupts at device level */
 	atmel_uart_writel(port, ATMEL_US_IDR, -1);
 
<span class="p_chunk">@@ -1979,8 +1982,6 @@</span> <span class="p_context"> static void atmel_shutdown(struct uart_port *port)</span>
 	 */
 	free_irq(port-&gt;irq, port);
 
<span class="p_del">-	atmel_port-&gt;ms_irq_enabled = false;</span>
<span class="p_del">-</span>
 	atmel_flush_buffer(port);
 }
 
<span class="p_header">diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c</span>
<span class="p_header">index 0df2b1c091ae..615c0279a1a6 100644</span>
<span class="p_header">--- a/drivers/tty/serial/imx.c</span>
<span class="p_header">+++ b/drivers/tty/serial/imx.c</span>
<span class="p_chunk">@@ -740,12 +740,13 @@</span> <span class="p_context"> static unsigned int imx_get_hwmctrl(struct imx_port *sport)</span>
 {
 	unsigned int tmp = TIOCM_DSR;
 	unsigned usr1 = readl(sport-&gt;port.membase + USR1);
<span class="p_add">+	unsigned usr2 = readl(sport-&gt;port.membase + USR2);</span>
 
 	if (usr1 &amp; USR1_RTSS)
 		tmp |= TIOCM_CTS;
 
 	/* in DCE mode DCDIN is always 0 */
<span class="p_del">-	if (!(usr1 &amp; USR2_DCDIN))</span>
<span class="p_add">+	if (!(usr2 &amp; USR2_DCDIN))</span>
 		tmp |= TIOCM_CAR;
 
 	if (sport-&gt;dte_mode)
<span class="p_header">diff --git a/fs/attr.c b/fs/attr.c</span>
<span class="p_header">index 42bb42bb3c72..3c42cab06b5d 100644</span>
<span class="p_header">--- a/fs/attr.c</span>
<span class="p_header">+++ b/fs/attr.c</span>
<span class="p_chunk">@@ -202,6 +202,21 @@</span> <span class="p_context"> int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **de</span>
 			return -EPERM;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If utimes(2) and friends are called with times == NULL (or both</span>
<span class="p_add">+	 * times are UTIME_NOW), then we need to check for write permission</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ia_valid &amp; ATTR_TOUCH) {</span>
<span class="p_add">+		if (IS_IMMUTABLE(inode))</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!inode_owner_or_capable(inode)) {</span>
<span class="p_add">+			error = inode_permission(inode, MAY_WRITE);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				return error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((ia_valid &amp; ATTR_MODE)) {
 		umode_t amode = attr-&gt;ia_mode;
 		/* Flag setting protected by i_mutex */
<span class="p_header">diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c</span>
<span class="p_header">index 431fd7ee3488..e44271dfceb6 100644</span>
<span class="p_header">--- a/fs/autofs4/waitq.c</span>
<span class="p_header">+++ b/fs/autofs4/waitq.c</span>
<span class="p_chunk">@@ -431,8 +431,8 @@</span> <span class="p_context"> int autofs4_wait(struct autofs_sb_info *sbi,</span>
 		memcpy(&amp;wq-&gt;name, &amp;qstr, sizeof(struct qstr));
 		wq-&gt;dev = autofs4_get_dev(sbi);
 		wq-&gt;ino = autofs4_get_ino(sbi);
<span class="p_del">-		wq-&gt;uid = current_uid();</span>
<span class="p_del">-		wq-&gt;gid = current_gid();</span>
<span class="p_add">+		wq-&gt;uid = current_real_cred()-&gt;uid;</span>
<span class="p_add">+		wq-&gt;gid = current_real_cred()-&gt;gid;</span>
 		wq-&gt;pid = pid;
 		wq-&gt;tgid = tgid;
 		wq-&gt;status = -EINTR; /* Status return if interrupted */
<span class="p_header">diff --git a/fs/btrfs/compression.c b/fs/btrfs/compression.c</span>
<span class="p_header">index 029db6e1105c..60a850ee8c78 100644</span>
<span class="p_header">--- a/fs/btrfs/compression.c</span>
<span class="p_header">+++ b/fs/btrfs/compression.c</span>
<span class="p_chunk">@@ -698,7 +698,7 @@</span> <span class="p_context"> int btrfs_submit_compressed_read(struct inode *inode, struct bio *bio,</span>
 
 			ret = btrfs_map_bio(root, comp_bio, mirror_num, 0);
 			if (ret) {
<span class="p_del">-				bio-&gt;bi_error = ret;</span>
<span class="p_add">+				comp_bio-&gt;bi_error = ret;</span>
 				bio_endio(comp_bio);
 			}
 
<span class="p_chunk">@@ -728,7 +728,7 @@</span> <span class="p_context"> int btrfs_submit_compressed_read(struct inode *inode, struct bio *bio,</span>
 
 	ret = btrfs_map_bio(root, comp_bio, mirror_num, 0);
 	if (ret) {
<span class="p_del">-		bio-&gt;bi_error = ret;</span>
<span class="p_add">+		comp_bio-&gt;bi_error = ret;</span>
 		bio_endio(comp_bio);
 	}
 
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index 33fe03551105..791e47ce9d27 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -251,7 +251,8 @@</span> <span class="p_context"> struct btrfs_super_block {</span>
 #define BTRFS_FEATURE_COMPAT_SAFE_CLEAR		0ULL
 
 #define BTRFS_FEATURE_COMPAT_RO_SUPP			\
<span class="p_del">-	(BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE)</span>
<span class="p_add">+	(BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE |	\</span>
<span class="p_add">+	 BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE_VALID)</span>
 
 #define BTRFS_FEATURE_COMPAT_RO_SAFE_SET	0ULL
 #define BTRFS_FEATURE_COMPAT_RO_SAFE_CLEAR	0ULL
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 54bc8c7c6bcd..3dede6d53bad 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -2566,6 +2566,7 @@</span> <span class="p_context"> int open_ctree(struct super_block *sb,</span>
 	int num_backups_tried = 0;
 	int backup_index = 0;
 	int max_active;
<span class="p_add">+	int clear_free_space_tree = 0;</span>
 
 	tree_root = fs_info-&gt;tree_root = btrfs_alloc_root(fs_info, GFP_KERNEL);
 	chunk_root = fs_info-&gt;chunk_root = btrfs_alloc_root(fs_info, GFP_KERNEL);
<span class="p_chunk">@@ -3129,6 +3130,26 @@</span> <span class="p_context"> retry_root_backup:</span>
 	if (sb-&gt;s_flags &amp; MS_RDONLY)
 		return 0;
 
<span class="p_add">+	if (btrfs_test_opt(fs_info, CLEAR_CACHE) &amp;&amp;</span>
<span class="p_add">+	    btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {</span>
<span class="p_add">+		clear_free_space_tree = 1;</span>
<span class="p_add">+	} else if (btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE) &amp;&amp;</span>
<span class="p_add">+		   !btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID)) {</span>
<span class="p_add">+		btrfs_warn(fs_info, &quot;free space tree is invalid&quot;);</span>
<span class="p_add">+		clear_free_space_tree = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (clear_free_space_tree) {</span>
<span class="p_add">+		btrfs_info(fs_info, &quot;clearing free space tree&quot;);</span>
<span class="p_add">+		ret = btrfs_clear_free_space_tree(fs_info);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			btrfs_warn(fs_info,</span>
<span class="p_add">+				   &quot;failed to clear free space tree: %d&quot;, ret);</span>
<span class="p_add">+			close_ctree(tree_root);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (btrfs_test_opt(tree_root-&gt;fs_info, FREE_SPACE_TREE) &amp;&amp;
 	    !btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {
 		btrfs_info(fs_info, &quot;creating free space tree&quot;);
<span class="p_chunk">@@ -3166,18 +3187,6 @@</span> <span class="p_context"> retry_root_backup:</span>
 
 	btrfs_qgroup_rescan_resume(fs_info);
 
<span class="p_del">-	if (btrfs_test_opt(tree_root-&gt;fs_info, CLEAR_CACHE) &amp;&amp;</span>
<span class="p_del">-	    btrfs_fs_compat_ro(fs_info, FREE_SPACE_TREE)) {</span>
<span class="p_del">-		btrfs_info(fs_info, &quot;clearing free space tree&quot;);</span>
<span class="p_del">-		ret = btrfs_clear_free_space_tree(fs_info);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			btrfs_warn(fs_info,</span>
<span class="p_del">-				&quot;failed to clear free space tree: %d&quot;, ret);</span>
<span class="p_del">-			close_ctree(tree_root);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (!fs_info-&gt;uuid_root) {
 		btrfs_info(fs_info, &quot;creating UUID tree&quot;);
 		ret = btrfs_create_uuid_tree(fs_info);
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index 44fe66b53c8b..c3ec30dea9a5 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -5524,17 +5524,45 @@</span> <span class="p_context"> void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * The extent buffer bitmap operations are done with byte granularity because</span>
<span class="p_del">- * bitmap items are not guaranteed to be aligned to a word and therefore a</span>
<span class="p_del">- * single word in a bitmap may straddle two pages in the extent buffer.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define BIT_BYTE(nr) ((nr) / BITS_PER_BYTE)</span>
<span class="p_del">-#define BYTE_MASK ((1 &lt;&lt; BITS_PER_BYTE) - 1)</span>
<span class="p_del">-#define BITMAP_FIRST_BYTE_MASK(start) \</span>
<span class="p_del">-	((BYTE_MASK &lt;&lt; ((start) &amp; (BITS_PER_BYTE - 1))) &amp; BYTE_MASK)</span>
<span class="p_del">-#define BITMAP_LAST_BYTE_MASK(nbits) \</span>
<span class="p_del">-	(BYTE_MASK &gt;&gt; (-(nbits) &amp; (BITS_PER_BYTE - 1)))</span>
<span class="p_add">+void le_bitmap_set(u8 *map, unsigned int start, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *p = map + BIT_BYTE(start);</span>
<span class="p_add">+	const unsigned int size = start + len;</span>
<span class="p_add">+	int bits_to_set = BITS_PER_BYTE - (start % BITS_PER_BYTE);</span>
<span class="p_add">+	u8 mask_to_set = BITMAP_FIRST_BYTE_MASK(start);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (len - bits_to_set &gt;= 0) {</span>
<span class="p_add">+		*p |= mask_to_set;</span>
<span class="p_add">+		len -= bits_to_set;</span>
<span class="p_add">+		bits_to_set = BITS_PER_BYTE;</span>
<span class="p_add">+		mask_to_set = ~(u8)0;</span>
<span class="p_add">+		p++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (len) {</span>
<span class="p_add">+		mask_to_set &amp;= BITMAP_LAST_BYTE_MASK(size);</span>
<span class="p_add">+		*p |= mask_to_set;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void le_bitmap_clear(u8 *map, unsigned int start, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *p = map + BIT_BYTE(start);</span>
<span class="p_add">+	const unsigned int size = start + len;</span>
<span class="p_add">+	int bits_to_clear = BITS_PER_BYTE - (start % BITS_PER_BYTE);</span>
<span class="p_add">+	u8 mask_to_clear = BITMAP_FIRST_BYTE_MASK(start);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (len - bits_to_clear &gt;= 0) {</span>
<span class="p_add">+		*p &amp;= ~mask_to_clear;</span>
<span class="p_add">+		len -= bits_to_clear;</span>
<span class="p_add">+		bits_to_clear = BITS_PER_BYTE;</span>
<span class="p_add">+		mask_to_clear = ~(u8)0;</span>
<span class="p_add">+		p++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (len) {</span>
<span class="p_add">+		mask_to_clear &amp;= BITMAP_LAST_BYTE_MASK(size);</span>
<span class="p_add">+		*p &amp;= ~mask_to_clear;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 /*
  * eb_bitmap_offset() - calculate the page and offset of the byte containing the
<span class="p_chunk">@@ -5578,7 +5606,7 @@</span> <span class="p_context"> static inline void eb_bitmap_offset(struct extent_buffer *eb,</span>
 int extent_buffer_test_bit(struct extent_buffer *eb, unsigned long start,
 			   unsigned long nr)
 {
<span class="p_del">-	char *kaddr;</span>
<span class="p_add">+	u8 *kaddr;</span>
 	struct page *page;
 	unsigned long i;
 	size_t offset;
<span class="p_chunk">@@ -5600,13 +5628,13 @@</span> <span class="p_context"> int extent_buffer_test_bit(struct extent_buffer *eb, unsigned long start,</span>
 void extent_buffer_bitmap_set(struct extent_buffer *eb, unsigned long start,
 			      unsigned long pos, unsigned long len)
 {
<span class="p_del">-	char *kaddr;</span>
<span class="p_add">+	u8 *kaddr;</span>
 	struct page *page;
 	unsigned long i;
 	size_t offset;
 	const unsigned int size = pos + len;
 	int bits_to_set = BITS_PER_BYTE - (pos % BITS_PER_BYTE);
<span class="p_del">-	unsigned int mask_to_set = BITMAP_FIRST_BYTE_MASK(pos);</span>
<span class="p_add">+	u8 mask_to_set = BITMAP_FIRST_BYTE_MASK(pos);</span>
 
 	eb_bitmap_offset(eb, start, pos, &amp;i, &amp;offset);
 	page = eb-&gt;pages[i];
<span class="p_chunk">@@ -5617,7 +5645,7 @@</span> <span class="p_context"> void extent_buffer_bitmap_set(struct extent_buffer *eb, unsigned long start,</span>
 		kaddr[offset] |= mask_to_set;
 		len -= bits_to_set;
 		bits_to_set = BITS_PER_BYTE;
<span class="p_del">-		mask_to_set = ~0U;</span>
<span class="p_add">+		mask_to_set = ~(u8)0;</span>
 		if (++offset &gt;= PAGE_SIZE &amp;&amp; len &gt; 0) {
 			offset = 0;
 			page = eb-&gt;pages[++i];
<span class="p_chunk">@@ -5642,13 +5670,13 @@</span> <span class="p_context"> void extent_buffer_bitmap_set(struct extent_buffer *eb, unsigned long start,</span>
 void extent_buffer_bitmap_clear(struct extent_buffer *eb, unsigned long start,
 				unsigned long pos, unsigned long len)
 {
<span class="p_del">-	char *kaddr;</span>
<span class="p_add">+	u8 *kaddr;</span>
 	struct page *page;
 	unsigned long i;
 	size_t offset;
 	const unsigned int size = pos + len;
 	int bits_to_clear = BITS_PER_BYTE - (pos % BITS_PER_BYTE);
<span class="p_del">-	unsigned int mask_to_clear = BITMAP_FIRST_BYTE_MASK(pos);</span>
<span class="p_add">+	u8 mask_to_clear = BITMAP_FIRST_BYTE_MASK(pos);</span>
 
 	eb_bitmap_offset(eb, start, pos, &amp;i, &amp;offset);
 	page = eb-&gt;pages[i];
<span class="p_chunk">@@ -5659,7 +5687,7 @@</span> <span class="p_context"> void extent_buffer_bitmap_clear(struct extent_buffer *eb, unsigned long start,</span>
 		kaddr[offset] &amp;= ~mask_to_clear;
 		len -= bits_to_clear;
 		bits_to_clear = BITS_PER_BYTE;
<span class="p_del">-		mask_to_clear = ~0U;</span>
<span class="p_add">+		mask_to_clear = ~(u8)0;</span>
 		if (++offset &gt;= PAGE_SIZE &amp;&amp; len &gt; 0) {
 			offset = 0;
 			page = eb-&gt;pages[++i];
<span class="p_header">diff --git a/fs/btrfs/extent_io.h b/fs/btrfs/extent_io.h</span>
<span class="p_header">index 28cd88fccc7e..1cf4e4226fc8 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.h</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.h</span>
<span class="p_chunk">@@ -59,6 +59,28 @@</span> <span class="p_context"></span>
  */
 #define EXTENT_PAGE_PRIVATE 1
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The extent buffer bitmap operations are done with byte granularity instead of</span>
<span class="p_add">+ * word granularity for two reasons:</span>
<span class="p_add">+ * 1. The bitmaps must be little-endian on disk.</span>
<span class="p_add">+ * 2. Bitmap items are not guaranteed to be aligned to a word and therefore a</span>
<span class="p_add">+ *    single word in a bitmap may straddle two pages in the extent buffer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define BIT_BYTE(nr) ((nr) / BITS_PER_BYTE)</span>
<span class="p_add">+#define BYTE_MASK ((1 &lt;&lt; BITS_PER_BYTE) - 1)</span>
<span class="p_add">+#define BITMAP_FIRST_BYTE_MASK(start) \</span>
<span class="p_add">+	((BYTE_MASK &lt;&lt; ((start) &amp; (BITS_PER_BYTE - 1))) &amp; BYTE_MASK)</span>
<span class="p_add">+#define BITMAP_LAST_BYTE_MASK(nbits) \</span>
<span class="p_add">+	(BYTE_MASK &gt;&gt; (-(nbits) &amp; (BITS_PER_BYTE - 1)))</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int le_test_bit(int nr, const u8 *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1U &amp; (addr[BIT_BYTE(nr)] &gt;&gt; (nr &amp; (BITS_PER_BYTE-1)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern void le_bitmap_set(u8 *map, unsigned int start, int len);</span>
<span class="p_add">+extern void le_bitmap_clear(u8 *map, unsigned int start, int len);</span>
<span class="p_add">+</span>
 struct extent_state;
 struct btrfs_root;
 struct btrfs_io_bio;
<span class="p_header">diff --git a/fs/btrfs/free-space-tree.c b/fs/btrfs/free-space-tree.c</span>
<span class="p_header">index 87e7e3d3e676..ea605ffd0e03 100644</span>
<span class="p_header">--- a/fs/btrfs/free-space-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/free-space-tree.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static inline u32 free_space_bitmap_size(u64 size, u32 sectorsize)</span>
 	return DIV_ROUND_UP((u32)div_u64(size, sectorsize), BITS_PER_BYTE);
 }
 
<span class="p_del">-static unsigned long *alloc_bitmap(u32 bitmap_size)</span>
<span class="p_add">+static u8 *alloc_bitmap(u32 bitmap_size)</span>
 {
 	void *mem;
 
<span class="p_chunk">@@ -180,8 +180,7 @@</span> <span class="p_context"> int convert_free_space_to_bitmaps(struct btrfs_trans_handle *trans,</span>
 	struct btrfs_free_space_info *info;
 	struct btrfs_key key, found_key;
 	struct extent_buffer *leaf;
<span class="p_del">-	unsigned long *bitmap;</span>
<span class="p_del">-	char *bitmap_cursor;</span>
<span class="p_add">+	u8 *bitmap, *bitmap_cursor;</span>
 	u64 start, end;
 	u64 bitmap_range, i;
 	u32 bitmap_size, flags, expected_extent_count;
<span class="p_chunk">@@ -231,7 +230,7 @@</span> <span class="p_context"> int convert_free_space_to_bitmaps(struct btrfs_trans_handle *trans,</span>
 						block_group-&gt;sectorsize);
 				last = div_u64(found_key.objectid + found_key.offset - start,
 					       block_group-&gt;sectorsize);
<span class="p_del">-				bitmap_set(bitmap, first, last - first);</span>
<span class="p_add">+				le_bitmap_set(bitmap, first, last - first);</span>
 
 				extent_count++;
 				nr++;
<span class="p_chunk">@@ -269,7 +268,7 @@</span> <span class="p_context"> int convert_free_space_to_bitmaps(struct btrfs_trans_handle *trans,</span>
 		goto out;
 	}
 
<span class="p_del">-	bitmap_cursor = (char *)bitmap;</span>
<span class="p_add">+	bitmap_cursor = bitmap;</span>
 	bitmap_range = block_group-&gt;sectorsize * BTRFS_FREE_SPACE_BITMAP_BITS;
 	i = start;
 	while (i &lt; end) {
<span class="p_chunk">@@ -318,7 +317,7 @@</span> <span class="p_context"> int convert_free_space_to_extents(struct btrfs_trans_handle *trans,</span>
 	struct btrfs_free_space_info *info;
 	struct btrfs_key key, found_key;
 	struct extent_buffer *leaf;
<span class="p_del">-	unsigned long *bitmap;</span>
<span class="p_add">+	u8 *bitmap;</span>
 	u64 start, end;
 	/* Initialize to silence GCC. */
 	u64 extent_start = 0;
<span class="p_chunk">@@ -362,7 +361,7 @@</span> <span class="p_context"> int convert_free_space_to_extents(struct btrfs_trans_handle *trans,</span>
 				break;
 			} else if (found_key.type == BTRFS_FREE_SPACE_BITMAP_KEY) {
 				unsigned long ptr;
<span class="p_del">-				char *bitmap_cursor;</span>
<span class="p_add">+				u8 *bitmap_cursor;</span>
 				u32 bitmap_pos, data_size;
 
 				ASSERT(found_key.objectid &gt;= start);
<span class="p_chunk">@@ -372,7 +371,7 @@</span> <span class="p_context"> int convert_free_space_to_extents(struct btrfs_trans_handle *trans,</span>
 				bitmap_pos = div_u64(found_key.objectid - start,
 						     block_group-&gt;sectorsize *
 						     BITS_PER_BYTE);
<span class="p_del">-				bitmap_cursor = ((char *)bitmap) + bitmap_pos;</span>
<span class="p_add">+				bitmap_cursor = bitmap + bitmap_pos;</span>
 				data_size = free_space_bitmap_size(found_key.offset,
 								   block_group-&gt;sectorsize);
 
<span class="p_chunk">@@ -409,7 +408,7 @@</span> <span class="p_context"> int convert_free_space_to_extents(struct btrfs_trans_handle *trans,</span>
 	offset = start;
 	bitnr = 0;
 	while (offset &lt; end) {
<span class="p_del">-		bit = !!test_bit(bitnr, bitmap);</span>
<span class="p_add">+		bit = !!le_test_bit(bitnr, bitmap);</span>
 		if (prev_bit == 0 &amp;&amp; bit == 1) {
 			extent_start = offset;
 		} else if (prev_bit == 1 &amp;&amp; bit == 0) {
<span class="p_chunk">@@ -1183,6 +1182,7 @@</span> <span class="p_context"> int btrfs_create_free_space_tree(struct btrfs_fs_info *fs_info)</span>
 	}
 
 	btrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE);
<span class="p_add">+	btrfs_set_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID);</span>
 	fs_info-&gt;creating_free_space_tree = 0;
 
 	ret = btrfs_commit_transaction(trans, tree_root);
<span class="p_chunk">@@ -1251,6 +1251,7 @@</span> <span class="p_context"> int btrfs_clear_free_space_tree(struct btrfs_fs_info *fs_info)</span>
 		return PTR_ERR(trans);
 
 	btrfs_clear_fs_compat_ro(fs_info, FREE_SPACE_TREE);
<span class="p_add">+	btrfs_clear_fs_compat_ro(fs_info, FREE_SPACE_TREE_VALID);</span>
 	fs_info-&gt;free_space_root = NULL;
 
 	ret = clear_free_space_tree(trans, free_space_root);
<span class="p_header">diff --git a/fs/cachefiles/interface.c b/fs/cachefiles/interface.c</span>
<span class="p_header">index ce5f345d70f5..e7f16a77a22a 100644</span>
<span class="p_header">--- a/fs/cachefiles/interface.c</span>
<span class="p_header">+++ b/fs/cachefiles/interface.c</span>
<span class="p_chunk">@@ -253,6 +253,8 @@</span> <span class="p_context"> static void cachefiles_drop_object(struct fscache_object *_object)</span>
 	struct cachefiles_object *object;
 	struct cachefiles_cache *cache;
 	const struct cred *saved_cred;
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+	blkcnt_t i_blocks = 0;</span>
 
 	ASSERT(_object);
 
<span class="p_chunk">@@ -279,6 +281,10 @@</span> <span class="p_context"> static void cachefiles_drop_object(struct fscache_object *_object)</span>
 		    _object != cache-&gt;cache.fsdef
 		    ) {
 			_debug(&quot;- retire object OBJ%x&quot;, object-&gt;fscache.debug_id);
<span class="p_add">+			inode = d_backing_inode(object-&gt;dentry);</span>
<span class="p_add">+			if (inode)</span>
<span class="p_add">+				i_blocks = inode-&gt;i_blocks;</span>
<span class="p_add">+</span>
 			cachefiles_begin_secure(cache, &amp;saved_cred);
 			cachefiles_delete_object(cache, object);
 			cachefiles_end_secure(cache, saved_cred);
<span class="p_chunk">@@ -292,7 +298,7 @@</span> <span class="p_context"> static void cachefiles_drop_object(struct fscache_object *_object)</span>
 
 	/* note that the object is now inactive */
 	if (test_bit(CACHEFILES_OBJECT_ACTIVE, &amp;object-&gt;flags))
<span class="p_del">-		cachefiles_mark_object_inactive(cache, object);</span>
<span class="p_add">+		cachefiles_mark_object_inactive(cache, object, i_blocks);</span>
 
 	dput(object-&gt;dentry);
 	object-&gt;dentry = NULL;
<span class="p_header">diff --git a/fs/cachefiles/internal.h b/fs/cachefiles/internal.h</span>
<span class="p_header">index 2fcde1a34b7c..cd1effee8a49 100644</span>
<span class="p_header">--- a/fs/cachefiles/internal.h</span>
<span class="p_header">+++ b/fs/cachefiles/internal.h</span>
<span class="p_chunk">@@ -160,7 +160,8 @@</span> <span class="p_context"> extern char *cachefiles_cook_key(const u8 *raw, int keylen, uint8_t type);</span>
  * namei.c
  */
 extern void cachefiles_mark_object_inactive(struct cachefiles_cache *cache,
<span class="p_del">-					    struct cachefiles_object *object);</span>
<span class="p_add">+					    struct cachefiles_object *object,</span>
<span class="p_add">+					    blkcnt_t i_blocks);</span>
 extern int cachefiles_delete_object(struct cachefiles_cache *cache,
 				    struct cachefiles_object *object);
 extern int cachefiles_walk_to_object(struct cachefiles_object *parent,
<span class="p_header">diff --git a/fs/cachefiles/namei.c b/fs/cachefiles/namei.c</span>
<span class="p_header">index 3f7c2cd41f8f..c6ee4b5fb7e6 100644</span>
<span class="p_header">--- a/fs/cachefiles/namei.c</span>
<span class="p_header">+++ b/fs/cachefiles/namei.c</span>
<span class="p_chunk">@@ -261,10 +261,9 @@</span> <span class="p_context"> requeue:</span>
  * Mark an object as being inactive.
  */
 void cachefiles_mark_object_inactive(struct cachefiles_cache *cache,
<span class="p_del">-				     struct cachefiles_object *object)</span>
<span class="p_add">+				     struct cachefiles_object *object,</span>
<span class="p_add">+				     blkcnt_t i_blocks)</span>
 {
<span class="p_del">-	blkcnt_t i_blocks = d_backing_inode(object-&gt;dentry)-&gt;i_blocks;</span>
<span class="p_del">-</span>
 	write_lock(&amp;cache-&gt;active_lock);
 	rb_erase(&amp;object-&gt;active_node, &amp;cache-&gt;active_nodes);
 	clear_bit(CACHEFILES_OBJECT_ACTIVE, &amp;object-&gt;flags);
<span class="p_chunk">@@ -707,7 +706,8 @@</span> <span class="p_context"> mark_active_timed_out:</span>
 
 check_error:
 	_debug(&quot;check error %d&quot;, ret);
<span class="p_del">-	cachefiles_mark_object_inactive(cache, object);</span>
<span class="p_add">+	cachefiles_mark_object_inactive(</span>
<span class="p_add">+		cache, object, d_backing_inode(object-&gt;dentry)-&gt;i_blocks);</span>
 release_dentry:
 	dput(object-&gt;dentry);
 	object-&gt;dentry = NULL;
<span class="p_header">diff --git a/fs/debugfs/file.c b/fs/debugfs/file.c</span>
<span class="p_header">index 592059f88e04..309f4e9b2419 100644</span>
<span class="p_header">--- a/fs/debugfs/file.c</span>
<span class="p_header">+++ b/fs/debugfs/file.c</span>
<span class="p_chunk">@@ -97,9 +97,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(debugfs_use_file_finish);</span>
 
 #define F_DENTRY(filp) ((filp)-&gt;f_path.dentry)
 
<span class="p_del">-#define REAL_FOPS_DEREF(dentry)					\</span>
<span class="p_del">-	((const struct file_operations *)(dentry)-&gt;d_fsdata)</span>
<span class="p_del">-</span>
 static int open_proxy_open(struct inode *inode, struct file *filp)
 {
 	const struct dentry *dentry = F_DENTRY(filp);
<span class="p_chunk">@@ -112,7 +109,7 @@</span> <span class="p_context"> static int open_proxy_open(struct inode *inode, struct file *filp)</span>
 		goto out;
 	}
 
<span class="p_del">-	real_fops = REAL_FOPS_DEREF(dentry);</span>
<span class="p_add">+	real_fops = debugfs_real_fops(filp);</span>
 	real_fops = fops_get(real_fops);
 	if (!real_fops) {
 		/* Huh? Module did not clean up after itself at exit? */
<span class="p_chunk">@@ -143,7 +140,7 @@</span> <span class="p_context"> static ret_type full_proxy_ ## name(proto)				\</span>
 {									\
 	const struct dentry *dentry = F_DENTRY(filp);			\
 	const struct file_operations *real_fops =			\
<span class="p_del">-		REAL_FOPS_DEREF(dentry);				\</span>
<span class="p_add">+		debugfs_real_fops(filp);				\</span>
 	int srcu_idx;							\
 	ret_type r;							\
 									\
<span class="p_chunk">@@ -176,7 +173,7 @@</span> <span class="p_context"> static unsigned int full_proxy_poll(struct file *filp,</span>
 				struct poll_table_struct *wait)
 {
 	const struct dentry *dentry = F_DENTRY(filp);
<span class="p_del">-	const struct file_operations *real_fops = REAL_FOPS_DEREF(dentry);</span>
<span class="p_add">+	const struct file_operations *real_fops = debugfs_real_fops(filp);</span>
 	int srcu_idx;
 	unsigned int r = 0;
 
<span class="p_chunk">@@ -193,7 +190,7 @@</span> <span class="p_context"> static unsigned int full_proxy_poll(struct file *filp,</span>
 static int full_proxy_release(struct inode *inode, struct file *filp)
 {
 	const struct dentry *dentry = F_DENTRY(filp);
<span class="p_del">-	const struct file_operations *real_fops = REAL_FOPS_DEREF(dentry);</span>
<span class="p_add">+	const struct file_operations *real_fops = debugfs_real_fops(filp);</span>
 	const struct file_operations *proxy_fops = filp-&gt;f_op;
 	int r = 0;
 
<span class="p_chunk">@@ -241,7 +238,7 @@</span> <span class="p_context"> static int full_proxy_open(struct inode *inode, struct file *filp)</span>
 		goto out;
 	}
 
<span class="p_del">-	real_fops = REAL_FOPS_DEREF(dentry);</span>
<span class="p_add">+	real_fops = debugfs_real_fops(filp);</span>
 	real_fops = fops_get(real_fops);
 	if (!real_fops) {
 		/* Huh? Module did not cleanup after itself at exit? */
<span class="p_header">diff --git a/fs/dlm/lowcomms.c b/fs/dlm/lowcomms.c</span>
<span class="p_header">index 963016c8f3d1..609998de533e 100644</span>
<span class="p_header">--- a/fs/dlm/lowcomms.c</span>
<span class="p_header">+++ b/fs/dlm/lowcomms.c</span>
<span class="p_chunk">@@ -1656,16 +1656,12 @@</span> <span class="p_context"> void dlm_lowcomms_stop(void)</span>
 	mutex_lock(&amp;connections_lock);
 	dlm_allow_conn = 0;
 	foreach_conn(stop_conn);
<span class="p_add">+	clean_writequeues();</span>
<span class="p_add">+	foreach_conn(free_conn);</span>
 	mutex_unlock(&amp;connections_lock);
 
 	work_stop();
 
<span class="p_del">-	mutex_lock(&amp;connections_lock);</span>
<span class="p_del">-	clean_writequeues();</span>
<span class="p_del">-</span>
<span class="p_del">-	foreach_conn(free_conn);</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;connections_lock);</span>
 	kmem_cache_destroy(con_cache);
 }
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index d7ccb7f51dfc..7f69347bd5a5 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -5734,6 +5734,9 @@</span> <span class="p_context"> int ext4_insert_range(struct inode *inode, loff_t offset, loff_t len)</span>
 			up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 			goto out_stop;
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		ext4_ext_drop_refs(path);</span>
<span class="p_add">+		kfree(path);</span>
 	}
 
 	ret = ext4_es_remove_extent(inode, offset_lblk,
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index c6ea25a190f8..f4cdc647ecfc 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -647,11 +647,19 @@</span> <span class="p_context"> found:</span>
 		/*
 		 * We have to zeroout blocks before inserting them into extent
 		 * status tree. Otherwise someone could look them up there and
<span class="p_del">-		 * use them before they are really zeroed.</span>
<span class="p_add">+		 * use them before they are really zeroed. We also have to</span>
<span class="p_add">+		 * unmap metadata before zeroing as otherwise writeback can</span>
<span class="p_add">+		 * overwrite zeros with stale data from block device.</span>
 		 */
 		if (flags &amp; EXT4_GET_BLOCKS_ZERO &amp;&amp;
 		    map-&gt;m_flags &amp; EXT4_MAP_MAPPED &amp;&amp;
 		    map-&gt;m_flags &amp; EXT4_MAP_NEW) {
<span class="p_add">+			ext4_lblk_t i;</span>
<span class="p_add">+</span>
<span class="p_add">+			for (i = 0; i &lt; map-&gt;m_len; i++) {</span>
<span class="p_add">+				unmap_underlying_metadata(inode-&gt;i_sb-&gt;s_bdev,</span>
<span class="p_add">+							  map-&gt;m_pblk + i);</span>
<span class="p_add">+			}</span>
 			ret = ext4_issue_zeroout(inode, map-&gt;m_lblk,
 						 map-&gt;m_pblk, map-&gt;m_len);
 			if (ret) {
<span class="p_chunk">@@ -1649,6 +1657,8 @@</span> <span class="p_context"> static void mpage_release_unused_pages(struct mpage_da_data *mpd,</span>
 			BUG_ON(!PageLocked(page));
 			BUG_ON(PageWriteback(page));
 			if (invalidate) {
<span class="p_add">+				if (page_mapped(page))</span>
<span class="p_add">+					clear_page_dirty_for_io(page);</span>
 				block_invalidatepage(page, 0, PAGE_SIZE);
 				ClearPageUptodate(page);
 			}
<span class="p_chunk">@@ -3890,7 +3900,7 @@</span> <span class="p_context"> int ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,</span>
 }
 
 /*
<span class="p_del">- * ext4_punch_hole: punches a hole in a file by releaseing the blocks</span>
<span class="p_add">+ * ext4_punch_hole: punches a hole in a file by releasing the blocks</span>
  * associated with the given offset and length
  *
  * @inode:  File inode
<span class="p_chunk">@@ -3919,7 +3929,7 @@</span> <span class="p_context"> int ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)</span>
 	 * Write out all dirty pages to avoid race conditions
 	 * Then release them.
 	 */
<span class="p_del">-	if (mapping-&gt;nrpages &amp;&amp; mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {</span>
<span class="p_add">+	if (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {</span>
 		ret = filemap_write_and_wait_range(mapping, offset,
 						   offset + length - 1);
 		if (ret)
<span class="p_chunk">@@ -4814,14 +4824,14 @@</span> <span class="p_context"> static int ext4_do_update_inode(handle_t *handle,</span>
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
<span class="p_del">-		if (!ei-&gt;i_dtime) {</span>
<span class="p_add">+		if (ei-&gt;i_dtime &amp;&amp; list_empty(&amp;ei-&gt;i_orphan)) {</span>
<span class="p_add">+			raw_inode-&gt;i_uid_high = 0;</span>
<span class="p_add">+			raw_inode-&gt;i_gid_high = 0;</span>
<span class="p_add">+		} else {</span>
 			raw_inode-&gt;i_uid_high =
 				cpu_to_le16(high_16_bits(i_uid));
 			raw_inode-&gt;i_gid_high =
 				cpu_to_le16(high_16_bits(i_gid));
<span class="p_del">-		} else {</span>
<span class="p_del">-			raw_inode-&gt;i_uid_high = 0;</span>
<span class="p_del">-			raw_inode-&gt;i_gid_high = 0;</span>
 		}
 	} else {
 		raw_inode-&gt;i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));
<span class="p_header">diff --git a/fs/ext4/move_extent.c b/fs/ext4/move_extent.c</span>
<span class="p_header">index a920c5d29fac..6fc14def0c70 100644</span>
<span class="p_header">--- a/fs/ext4/move_extent.c</span>
<span class="p_header">+++ b/fs/ext4/move_extent.c</span>
<span class="p_chunk">@@ -598,6 +598,13 @@</span> <span class="p_context"> ext4_move_extents(struct file *o_filp, struct file *d_filp, __u64 orig_blk,</span>
 		return -EOPNOTSUPP;
 	}
 
<span class="p_add">+	if (ext4_encrypted_inode(orig_inode) ||</span>
<span class="p_add">+	    ext4_encrypted_inode(donor_inode)) {</span>
<span class="p_add">+		ext4_msg(orig_inode-&gt;i_sb, KERN_ERR,</span>
<span class="p_add">+			 &quot;Online defrag not supported for encrypted files&quot;);</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Protect orig and donor inodes against a truncate */
 	lock_two_nondirectories(orig_inode, donor_inode);
 
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 34c0142caf6a..7e2f8c3c11ce 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -2044,33 +2044,31 @@</span> <span class="p_context"> static int make_indexed_dir(handle_t *handle, struct ext4_filename *fname,</span>
 	frame-&gt;entries = entries;
 	frame-&gt;at = entries;
 	frame-&gt;bh = bh;
<span class="p_del">-	bh = bh2;</span>
 
 	retval = ext4_handle_dirty_dx_node(handle, dir, frame-&gt;bh);
 	if (retval)
 		goto out_frames;	
<span class="p_del">-	retval = ext4_handle_dirty_dirent_node(handle, dir, bh);</span>
<span class="p_add">+	retval = ext4_handle_dirty_dirent_node(handle, dir, bh2);</span>
 	if (retval)
 		goto out_frames;	
 
<span class="p_del">-	de = do_split(handle,dir, &amp;bh, frame, &amp;fname-&gt;hinfo);</span>
<span class="p_add">+	de = do_split(handle,dir, &amp;bh2, frame, &amp;fname-&gt;hinfo);</span>
 	if (IS_ERR(de)) {
 		retval = PTR_ERR(de);
 		goto out_frames;
 	}
<span class="p_del">-	dx_release(frames);</span>
 
<span class="p_del">-	retval = add_dirent_to_buf(handle, fname, dir, inode, de, bh);</span>
<span class="p_del">-	brelse(bh);</span>
<span class="p_del">-	return retval;</span>
<span class="p_add">+	retval = add_dirent_to_buf(handle, fname, dir, inode, de, bh2);</span>
 out_frames:
 	/*
 	 * Even if the block split failed, we have to properly write
 	 * out all the changes we did so far. Otherwise we can end up
 	 * with corrupted filesystem.
 	 */
<span class="p_del">-	ext4_mark_inode_dirty(handle, dir);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		ext4_mark_inode_dirty(handle, dir);</span>
 	dx_release(frames);
<span class="p_add">+	brelse(bh2);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c</span>
<span class="p_header">index 4d83d9e05f2e..04a7850a0d45 100644</span>
<span class="p_header">--- a/fs/ext4/symlink.c</span>
<span class="p_header">+++ b/fs/ext4/symlink.c</span>
<span class="p_chunk">@@ -65,13 +65,12 @@</span> <span class="p_context"> static const char *ext4_encrypted_get_link(struct dentry *dentry,</span>
 	res = fscrypt_fname_alloc_buffer(inode, cstr.len, &amp;pstr);
 	if (res)
 		goto errout;
<span class="p_add">+	paddr = pstr.name;</span>
 
 	res = fscrypt_fname_disk_to_usr(inode, 0, 0, &amp;cstr, &amp;pstr);
 	if (res &lt; 0)
 		goto errout;
 
<span class="p_del">-	paddr = pstr.name;</span>
<span class="p_del">-</span>
 	/* Null-terminate the name */
 	if (res &lt;= pstr.len)
 		paddr[res] = &#39;\0&#39;;
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index c47b7780ce37..4ff9251e9d3a 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1702,14 +1702,46 @@</span> <span class="p_context"> error:</span>
 static int fuse_setattr(struct dentry *entry, struct iattr *attr)
 {
 	struct inode *inode = d_inode(entry);
<span class="p_add">+	struct file *file = (attr-&gt;ia_valid &amp; ATTR_FILE) ? attr-&gt;ia_file : NULL;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return -EACCES;
 
<span class="p_del">-	if (attr-&gt;ia_valid &amp; ATTR_FILE)</span>
<span class="p_del">-		return fuse_do_setattr(inode, attr, attr-&gt;ia_file);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return fuse_do_setattr(inode, attr, NULL);</span>
<span class="p_add">+	if (attr-&gt;ia_valid &amp; (ATTR_KILL_SUID | ATTR_KILL_SGID)) {</span>
<span class="p_add">+		int kill;</span>
<span class="p_add">+</span>
<span class="p_add">+		attr-&gt;ia_valid &amp;= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |</span>
<span class="p_add">+				    ATTR_MODE);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ia_mode calculation may have used stale i_mode.  Refresh and</span>
<span class="p_add">+		 * recalculate.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = fuse_do_getattr(inode, NULL, file);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		attr-&gt;ia_mode = inode-&gt;i_mode;</span>
<span class="p_add">+		kill = should_remove_suid(entry);</span>
<span class="p_add">+		if (kill &amp; ATTR_KILL_SUID) {</span>
<span class="p_add">+			attr-&gt;ia_valid |= ATTR_MODE;</span>
<span class="p_add">+			attr-&gt;ia_mode &amp;= ~S_ISUID;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (kill &amp; ATTR_KILL_SGID) {</span>
<span class="p_add">+			attr-&gt;ia_valid |= ATTR_MODE;</span>
<span class="p_add">+			attr-&gt;ia_mode &amp;= ~S_ISGID;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!attr-&gt;ia_valid)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = fuse_do_setattr(inode, attr, file);</span>
<span class="p_add">+	if (!ret) {</span>
<span class="p_add">+		/* Directory mode changed, may need to revalidate access */</span>
<span class="p_add">+		if (d_is_dir(entry) &amp;&amp; (attr-&gt;ia_valid &amp; ATTR_MODE))</span>
<span class="p_add">+			fuse_invalidate_entry_cache(entry);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
<span class="p_chunk">@@ -1801,6 +1833,23 @@</span> <span class="p_context"> static ssize_t fuse_getxattr(struct dentry *entry, struct inode *inode,</span>
 	return ret;
 }
 
<span class="p_add">+static int fuse_verify_xattr_list(char *list, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t origsize = size;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (size) {</span>
<span class="p_add">+		size_t thislen = strnlen(list, size);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!thislen || thislen == size)</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+		size -= thislen + 1;</span>
<span class="p_add">+		list += thislen + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return origsize;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 {
 	struct inode *inode = d_inode(entry);
<span class="p_chunk">@@ -1836,6 +1885,8 @@</span> <span class="p_context"> static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)</span>
 	ret = fuse_simple_request(fc, &amp;args);
 	if (!ret &amp;&amp; !size)
 		ret = outarg.size;
<span class="p_add">+	if (ret &gt; 0 &amp;&amp; size)</span>
<span class="p_add">+		ret = fuse_verify_xattr_list(list, ret);</span>
 	if (ret == -ENOSYS) {
 		fc-&gt;no_listxattr = 1;
 		ret = -EOPNOTSUPP;
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index b5bc3e249163..3d8246a9faa4 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -159,6 +159,7 @@</span> <span class="p_context"> static void wait_transaction_locked(journal_t *journal)</span>
 	read_unlock(&amp;journal-&gt;j_state_lock);
 	if (need_to_start)
 		jbd2_log_start_commit(journal, tid);
<span class="p_add">+	jbd2_might_wait_for_commit(journal);</span>
 	schedule();
 	finish_wait(&amp;journal-&gt;j_wait_transaction_locked, &amp;wait);
 }
<span class="p_chunk">@@ -182,8 +183,6 @@</span> <span class="p_context"> static int add_transaction_credits(journal_t *journal, int blocks,</span>
 	int needed;
 	int total = blocks + rsv_blocks;
 
<span class="p_del">-	jbd2_might_wait_for_commit(journal);</span>
<span class="p_del">-</span>
 	/*
 	 * If the current transaction is locked down for commit, wait
 	 * for the lock to be released.
<span class="p_chunk">@@ -214,6 +213,7 @@</span> <span class="p_context"> static int add_transaction_credits(journal_t *journal, int blocks,</span>
 		if (atomic_read(&amp;journal-&gt;j_reserved_credits) + total &gt;
 		    journal-&gt;j_max_transaction_buffers) {
 			read_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+			jbd2_might_wait_for_commit(journal);</span>
 			wait_event(journal-&gt;j_wait_reserved,
 				   atomic_read(&amp;journal-&gt;j_reserved_credits) + total &lt;=
 				   journal-&gt;j_max_transaction_buffers);
<span class="p_chunk">@@ -238,6 +238,7 @@</span> <span class="p_context"> static int add_transaction_credits(journal_t *journal, int blocks,</span>
 	if (jbd2_log_space_left(journal) &lt; jbd2_space_needed(journal)) {
 		atomic_sub(total, &amp;t-&gt;t_outstanding_credits);
 		read_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+		jbd2_might_wait_for_commit(journal);</span>
 		write_lock(&amp;journal-&gt;j_state_lock);
 		if (jbd2_log_space_left(journal) &lt; jbd2_space_needed(journal))
 			__jbd2_log_wait_for_space(journal);
<span class="p_chunk">@@ -255,6 +256,7 @@</span> <span class="p_context"> static int add_transaction_credits(journal_t *journal, int blocks,</span>
 		sub_reserved_credits(journal, rsv_blocks);
 		atomic_sub(total, &amp;t-&gt;t_outstanding_credits);
 		read_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+		jbd2_might_wait_for_commit(journal);</span>
 		wait_event(journal-&gt;j_wait_reserved,
 			 atomic_read(&amp;journal-&gt;j_reserved_credits) + rsv_blocks
 			 &lt;= journal-&gt;j_max_transaction_buffers / 2);
<span class="p_header">diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c</span>
<span class="p_header">index 7a4a85a6821e..74d5ddd26296 100644</span>
<span class="p_header">--- a/fs/reiserfs/super.c</span>
<span class="p_header">+++ b/fs/reiserfs/super.c</span>
<span class="p_chunk">@@ -190,7 +190,15 @@</span> <span class="p_context"> static int remove_save_link_only(struct super_block *s,</span>
 static int reiserfs_quota_on_mount(struct super_block *, int);
 #endif
 
<span class="p_del">-/* look for uncompleted unlinks and truncates and complete them */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Look for uncompleted unlinks and truncates and complete them</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called with superblock write locked.  If quotas are enabled, we have to</span>
<span class="p_add">+ * release/retake lest we call dquot_quota_on_mount(), proceed to</span>
<span class="p_add">+ * schedule_on_each_cpu() in invalidate_bdev() and deadlock waiting for the per</span>
<span class="p_add">+ * cpu worklets to complete flush_async_commits() that in turn wait for the</span>
<span class="p_add">+ * superblock write lock.</span>
<span class="p_add">+ */</span>
 static int finish_unfinished(struct super_block *s)
 {
 	INITIALIZE_PATH(path);
<span class="p_chunk">@@ -237,7 +245,9 @@</span> <span class="p_context"> static int finish_unfinished(struct super_block *s)</span>
 				quota_enabled[i] = 0;
 				continue;
 			}
<span class="p_add">+			reiserfs_write_unlock(s);</span>
 			ret = reiserfs_quota_on_mount(s, i);
<span class="p_add">+			reiserfs_write_lock(s);</span>
 			if (ret &lt; 0)
 				reiserfs_warning(s, &quot;reiserfs-2500&quot;,
 						 &quot;cannot turn on journaled &quot;
<span class="p_header">diff --git a/fs/utimes.c b/fs/utimes.c</span>
<span class="p_header">index 794f5f5b1fb5..ba54b9e648c9 100644</span>
<span class="p_header">--- a/fs/utimes.c</span>
<span class="p_header">+++ b/fs/utimes.c</span>
<span class="p_chunk">@@ -87,21 +87,7 @@</span> <span class="p_context"> static int utimes_common(struct path *path, struct timespec *times)</span>
 		 */
 		newattrs.ia_valid |= ATTR_TIMES_SET;
 	} else {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If times is NULL (or both times are UTIME_NOW),</span>
<span class="p_del">-		 * then we need to check permissions, because</span>
<span class="p_del">-		 * inode_change_ok() won&#39;t do it.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		error = -EPERM;</span>
<span class="p_del">-                if (IS_IMMUTABLE(inode))</span>
<span class="p_del">-			goto mnt_drop_write_and_out;</span>
<span class="p_del">-</span>
<span class="p_del">-		error = -EACCES;</span>
<span class="p_del">-		if (!inode_owner_or_capable(inode)) {</span>
<span class="p_del">-			error = inode_permission(inode, MAY_WRITE);</span>
<span class="p_del">-			if (error)</span>
<span class="p_del">-				goto mnt_drop_write_and_out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		newattrs.ia_valid |= ATTR_TOUCH;</span>
 	}
 retry_deleg:
 	inode_lock(inode);
<span class="p_chunk">@@ -113,7 +99,6 @@</span> <span class="p_context"> retry_deleg:</span>
 			goto retry_deleg;
 	}
 
<span class="p_del">-mnt_drop_write_and_out:</span>
 	mnt_drop_write(path-&gt;mnt);
 out:
 	return error;
<span class="p_header">diff --git a/include/crypto/ghash.h b/include/crypto/ghash.h</span>
new file mode 100644
<span class="p_header">index 000000000000..2a61c9bbab8f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/include/crypto/ghash.h</span>
<span class="p_chunk">@@ -0,0 +1,23 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Common values for GHASH algorithms</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __CRYPTO_GHASH_H__</span>
<span class="p_add">+#define __CRYPTO_GHASH_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;crypto/gf128mul.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define GHASH_BLOCK_SIZE	16</span>
<span class="p_add">+#define GHASH_DIGEST_SIZE	16</span>
<span class="p_add">+</span>
<span class="p_add">+struct ghash_ctx {</span>
<span class="p_add">+	struct gf128mul_4k *gf128;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct ghash_desc_ctx {</span>
<span class="p_add">+	u8 buffer[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u32 bytes;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/include/linux/debugfs.h b/include/linux/debugfs.h</span>
<span class="p_header">index 1438e2322d5c..4d3f0d1aec73 100644</span>
<span class="p_header">--- a/include/linux/debugfs.h</span>
<span class="p_header">+++ b/include/linux/debugfs.h</span>
<span class="p_chunk">@@ -45,6 +45,23 @@</span> <span class="p_context"> extern struct dentry *arch_debugfs_dir;</span>
 
 extern struct srcu_struct debugfs_srcu;
 
<span class="p_add">+/**</span>
<span class="p_add">+ * debugfs_real_fops - getter for the real file operation</span>
<span class="p_add">+ * @filp: a pointer to a struct file</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Must only be called under the protection established by</span>
<span class="p_add">+ * debugfs_use_file_start().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline const struct file_operations *debugfs_real_fops(struct file *filp)</span>
<span class="p_add">+	__must_hold(&amp;debugfs_srcu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Neither the pointer to the struct file_operations, nor its</span>
<span class="p_add">+	 * contents ever change -- srcu_dereference() is not needed here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return filp-&gt;f_path.dentry-&gt;d_fsdata;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #if defined(CONFIG_DEBUG_FS)
 
 struct dentry *debugfs_create_file(const char *name, umode_t mode,
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 901e25d495cc..7c391366fb43 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -224,6 +224,7 @@</span> <span class="p_context"> typedef int (dio_iodone_t)(struct kiocb *iocb, loff_t offset,</span>
 #define ATTR_KILL_PRIV	(1 &lt;&lt; 14)
 #define ATTR_OPEN	(1 &lt;&lt; 15) /* Truncating from open(O_TRUNC) */
 #define ATTR_TIMES_SET	(1 &lt;&lt; 16)
<span class="p_add">+#define ATTR_TOUCH	(1 &lt;&lt; 17)</span>
 
 /*
  * Whiteout is represented by a char device.  The following constants define the
<span class="p_header">diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h</span>
<span class="p_header">index 4c45105dece3..52b97db93830 100644</span>
<span class="p_header">--- a/include/linux/radix-tree.h</span>
<span class="p_header">+++ b/include/linux/radix-tree.h</span>
<span class="p_chunk">@@ -280,9 +280,9 @@</span> <span class="p_context"> bool __radix_tree_delete_node(struct radix_tree_root *root,</span>
 			      struct radix_tree_node *node);
 void *radix_tree_delete_item(struct radix_tree_root *, unsigned long, void *);
 void *radix_tree_delete(struct radix_tree_root *, unsigned long);
<span class="p_del">-struct radix_tree_node *radix_tree_replace_clear_tags(</span>
<span class="p_del">-				struct radix_tree_root *root,</span>
<span class="p_del">-				unsigned long index, void *entry);</span>
<span class="p_add">+void radix_tree_clear_tags(struct radix_tree_root *root,</span>
<span class="p_add">+			   struct radix_tree_node *node,</span>
<span class="p_add">+			   void **slot);</span>
 unsigned int radix_tree_gang_lookup(struct radix_tree_root *root,
 			void **results, unsigned long first_index,
 			unsigned int max_items);
<span class="p_header">diff --git a/include/linux/sem.h b/include/linux/sem.h</span>
<span class="p_header">index 976ce3a19f1b..d0efd6e6c20a 100644</span>
<span class="p_header">--- a/include/linux/sem.h</span>
<span class="p_header">+++ b/include/linux/sem.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> struct sem_array {</span>
 	struct list_head	list_id;	/* undo requests on this array */
 	int			sem_nsems;	/* no. of semaphores in array */
 	int			complex_count;	/* pending complex operations */
<span class="p_add">+	bool			complex_mode;	/* no parallel simple ops */</span>
 };
 
 #ifdef CONFIG_SYSVIPC
<span class="p_header">diff --git a/include/uapi/linux/btrfs.h b/include/uapi/linux/btrfs.h</span>
<span class="p_header">index ac5eacd3055b..db4c253f8011 100644</span>
<span class="p_header">--- a/include/uapi/linux/btrfs.h</span>
<span class="p_header">+++ b/include/uapi/linux/btrfs.h</span>
<span class="p_chunk">@@ -239,7 +239,17 @@</span> <span class="p_context"> struct btrfs_ioctl_fs_info_args {</span>
  * Used by:
  * struct btrfs_ioctl_feature_flags
  */
<span class="p_del">-#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE	(1ULL &lt;&lt; 0)</span>
<span class="p_add">+#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE		(1ULL &lt;&lt; 0)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Older kernels (&lt; 4.9) on big-endian systems produced broken free space tree</span>
<span class="p_add">+ * bitmaps, and btrfs-progs also used to corrupt the free space tree (versions</span>
<span class="p_add">+ * &lt; 4.7.3).  If this bit is clear, then the free space tree cannot be trusted.</span>
<span class="p_add">+ * btrfs-progs can also intentionally clear this bit to ask the kernel to</span>
<span class="p_add">+ * rebuild the free space tree, however this might not work on older kernels</span>
<span class="p_add">+ * that do not know about this bit. If not sure, clear the cache manually on</span>
<span class="p_add">+ * first mount when booting older kernel versions.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define BTRFS_FEATURE_COMPAT_RO_FREE_SPACE_TREE_VALID	(1ULL &lt;&lt; 1)</span>
 
 #define BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF	(1ULL &lt;&lt; 0)
 #define BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL	(1ULL &lt;&lt; 1)
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index 7c9d4f7683c0..5e318c5f749d 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -162,14 +162,21 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it);</span>
 
 /*
  * Locking:
<span class="p_add">+ * a) global sem_lock() for read/write</span>
  *	sem_undo.id_next,
  *	sem_array.complex_count,
<span class="p_del">- *	sem_array.pending{_alter,_cont},</span>
<span class="p_del">- *	sem_array.sem_undo: global sem_lock() for read/write</span>
<span class="p_del">- *	sem_undo.proc_next: only &quot;current&quot; is allowed to read/write that field.</span>
<span class="p_add">+ *	sem_array.complex_mode</span>
<span class="p_add">+ *	sem_array.pending{_alter,_const},</span>
<span class="p_add">+ *	sem_array.sem_undo</span>
  *
<span class="p_add">+ * b) global or semaphore sem_lock() for read/write:</span>
  *	sem_array.sem_base[i].pending_{const,alter}:
<span class="p_del">- *		global or semaphore sem_lock() for read/write</span>
<span class="p_add">+ *	sem_array.complex_mode (for read)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * c) special:</span>
<span class="p_add">+ *	sem_undo_list.list_proc:</span>
<span class="p_add">+ *	* undo_list-&gt;lock for write</span>
<span class="p_add">+ *	* rcu for read</span>
  */
 
 #define sc_semmsl	sem_ctls[0]
<span class="p_chunk">@@ -260,30 +267,61 @@</span> <span class="p_context"> static void sem_rcu_free(struct rcu_head *head)</span>
 }
 
 /*
<span class="p_del">- * Wait until all currently ongoing simple ops have completed.</span>
<span class="p_add">+ * Enter the mode suitable for non-simple operations:</span>
  * Caller must own sem_perm.lock.
<span class="p_del">- * New simple ops cannot start, because simple ops first check</span>
<span class="p_del">- * that sem_perm.lock is free.</span>
<span class="p_del">- * that a) sem_perm.lock is free and b) complex_count is 0.</span>
  */
<span class="p_del">-static void sem_wait_array(struct sem_array *sma)</span>
<span class="p_add">+static void complexmode_enter(struct sem_array *sma)</span>
 {
 	int i;
 	struct sem *sem;
 
<span class="p_del">-	if (sma-&gt;complex_count)  {</span>
<span class="p_del">-		/* The thread that increased sma-&gt;complex_count waited on</span>
<span class="p_del">-		 * all sem-&gt;lock locks. Thus we don&#39;t need to wait again.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+	if (sma-&gt;complex_mode)  {</span>
<span class="p_add">+		/* We are already in complex_mode. Nothing to do */</span>
 		return;
 	}
 
<span class="p_add">+	/* We need a full barrier after seting complex_mode:</span>
<span class="p_add">+	 * The write to complex_mode must be visible</span>
<span class="p_add">+	 * before we read the first sem-&gt;lock spinlock state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_mb(sma-&gt;complex_mode, true);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; sma-&gt;sem_nsems; i++) {
 		sem = sma-&gt;sem_base + i;
 		spin_unlock_wait(&amp;sem-&gt;lock);
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin_unlock_wait() is not a memory barriers, it is only a</span>
<span class="p_add">+	 * control barrier. The code must pair with spin_unlock(&amp;sem-&gt;lock),</span>
<span class="p_add">+	 * thus just the control barrier is insufficient.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * smp_rmb() is sufficient, as writes cannot pass the control barrier.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_rmb();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Try to leave the mode that disallows simple operations:</span>
<span class="p_add">+ * Caller must own sem_perm.lock.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void complexmode_tryleave(struct sem_array *sma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (sma-&gt;complex_count)  {</span>
<span class="p_add">+		/* Complex ops are sleeping.</span>
<span class="p_add">+		 * We must stay in complex mode</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Immediately after setting complex_mode to false,</span>
<span class="p_add">+	 * a simple op can start. Thus: all memory writes</span>
<span class="p_add">+	 * performed by the current operation must be visible</span>
<span class="p_add">+	 * before we set complex_mode to false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;sma-&gt;complex_mode, false);</span>
 }
 
<span class="p_add">+#define SEM_GLOBAL_LOCK	(-1)</span>
 /*
  * If the request contains only one semaphore operation, and there are
  * no complex transactions pending, lock only the semaphore involved.
<span class="p_chunk">@@ -300,56 +338,42 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Complex operation - acquire a full lock */
 		ipc_lock_object(&amp;sma-&gt;sem_perm);
 
<span class="p_del">-		/* And wait until all simple ops that are processed</span>
<span class="p_del">-		 * right now have dropped their locks.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		/* Prevent parallel simple ops */</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 
 	/*
 	 * Only one semaphore affected - try to optimize locking.
<span class="p_del">-	 * The rules are:</span>
<span class="p_del">-	 * - optimized locking is possible if no complex operation</span>
<span class="p_del">-	 *   is either enqueued or processed right now.</span>
<span class="p_del">-	 * - The test for enqueued complex ops is simple:</span>
<span class="p_del">-	 *      sma-&gt;complex_count != 0</span>
<span class="p_del">-	 * - Testing for complex ops that are processed right now is</span>
<span class="p_del">-	 *   a bit more difficult. Complex ops acquire the full lock</span>
<span class="p_del">-	 *   and first wait that the running simple ops have completed.</span>
<span class="p_del">-	 *   (see above)</span>
<span class="p_del">-	 *   Thus: If we own a simple lock and the global lock is free</span>
<span class="p_del">-	 *	and complex_count is now 0, then it will stay 0 and</span>
<span class="p_del">-	 *	thus just locking sem-&gt;lock is sufficient.</span>
<span class="p_add">+	 * Optimized locking is possible if no complex operation</span>
<span class="p_add">+	 * is either enqueued or processed right now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Both facts are tracked by complex_mode.</span>
 	 */
 	sem = sma-&gt;sem_base + sops-&gt;sem_num;
 
<span class="p_del">-	if (sma-&gt;complex_count == 0) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initial check for complex_mode. Just an optimization,</span>
<span class="p_add">+	 * no locking, no memory barrier.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!sma-&gt;complex_mode) {</span>
 		/*
 		 * It appears that no complex operation is around.
 		 * Acquire the per-semaphore lock.
 		 */
 		spin_lock(&amp;sem-&gt;lock);
 
<span class="p_del">-		/* Then check that the global lock is free */</span>
<span class="p_del">-		if (!spin_is_locked(&amp;sma-&gt;sem_perm.lock)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We need a memory barrier with acquire semantics,</span>
<span class="p_del">-			 * otherwise we can race with another thread that does:</span>
<span class="p_del">-			 *	complex_count++;</span>
<span class="p_del">-			 *	spin_unlock(sem_perm.lock);</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			smp_acquire__after_ctrl_dep();</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * See 51d7d5205d33</span>
<span class="p_add">+		 * (&quot;powerpc: Add smp_mb() to arch_spin_is_locked()&quot;):</span>
<span class="p_add">+		 * A full barrier is required: the write of sem-&gt;lock</span>
<span class="p_add">+		 * must be visible before the read is executed</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb();</span>
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Now repeat the test of complex_count:</span>
<span class="p_del">-			 * It can&#39;t change anymore until we drop sem-&gt;lock.</span>
<span class="p_del">-			 * Thus: if is now 0, then it will stay 0.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (sma-&gt;complex_count == 0) {</span>
<span class="p_del">-				/* fast path successful! */</span>
<span class="p_del">-				return sops-&gt;sem_num;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		if (!smp_load_acquire(&amp;sma-&gt;complex_mode)) {</span>
<span class="p_add">+			/* fast path successful! */</span>
<span class="p_add">+			return sops-&gt;sem_num;</span>
 		}
 		spin_unlock(&amp;sem-&gt;lock);
 	}
<span class="p_chunk">@@ -369,15 +393,16 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Not a false alarm, thus complete the sequence for a
 		 * full lock.
 		 */
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 }
 
 static inline void sem_unlock(struct sem_array *sma, int locknum)
 {
<span class="p_del">-	if (locknum == -1) {</span>
<span class="p_add">+	if (locknum == SEM_GLOBAL_LOCK) {</span>
 		unmerge_queues(sma);
<span class="p_add">+		complexmode_tryleave(sma);</span>
 		ipc_unlock_object(&amp;sma-&gt;sem_perm);
 	} else {
 		struct sem *sem = sma-&gt;sem_base + locknum;
<span class="p_chunk">@@ -529,6 +554,7 @@</span> <span class="p_context"> static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	}
 
 	sma-&gt;complex_count = 0;
<span class="p_add">+	sma-&gt;complex_mode = true; /* dropped by sem_unlock below */</span>
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_alter);
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_const);
 	INIT_LIST_HEAD(&amp;sma-&gt;list_id);
<span class="p_chunk">@@ -2184,10 +2210,10 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it)</span>
 	/*
 	 * The proc interface isn&#39;t aware of sem_lock(), it calls
 	 * ipc_lock_object() directly (in sysvipc_find_ipc).
<span class="p_del">-	 * In order to stay compatible with sem_lock(), we must wait until</span>
<span class="p_del">-	 * all simple semop() calls have left their critical regions.</span>
<span class="p_add">+	 * In order to stay compatible with sem_lock(), we must</span>
<span class="p_add">+	 * enter / leave complex_mode.</span>
 	 */
<span class="p_del">-	sem_wait_array(sma);</span>
<span class="p_add">+	complexmode_enter(sma);</span>
 
 	sem_otime = get_semotime(sma);
 
<span class="p_chunk">@@ -2204,6 +2230,8 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it)</span>
 		   sem_otime,
 		   sma-&gt;sem_ctime);
 
<span class="p_add">+	complexmode_tryleave(sma);</span>
<span class="p_add">+</span>
 	return 0;
 }
 #endif
<span class="p_header">diff --git a/lib/radix-tree.c b/lib/radix-tree.c</span>
<span class="p_header">index 91f0727e3cad..8e6d552c40dd 100644</span>
<span class="p_header">--- a/lib/radix-tree.c</span>
<span class="p_header">+++ b/lib/radix-tree.c</span>
<span class="p_chunk">@@ -1583,15 +1583,10 @@</span> <span class="p_context"> void *radix_tree_delete(struct radix_tree_root *root, unsigned long index)</span>
 }
 EXPORT_SYMBOL(radix_tree_delete);
 
<span class="p_del">-struct radix_tree_node *radix_tree_replace_clear_tags(</span>
<span class="p_del">-			struct radix_tree_root *root,</span>
<span class="p_del">-			unsigned long index, void *entry)</span>
<span class="p_add">+void radix_tree_clear_tags(struct radix_tree_root *root,</span>
<span class="p_add">+			   struct radix_tree_node *node,</span>
<span class="p_add">+			   void **slot)</span>
 {
<span class="p_del">-	struct radix_tree_node *node;</span>
<span class="p_del">-	void **slot;</span>
<span class="p_del">-</span>
<span class="p_del">-	__radix_tree_lookup(root, index, &amp;node, &amp;slot);</span>
<span class="p_del">-</span>
 	if (node) {
 		unsigned int tag, offset = get_slot_offset(node, slot);
 		for (tag = 0; tag &lt; RADIX_TREE_MAX_TAGS; tag++)
<span class="p_chunk">@@ -1600,9 +1595,6 @@</span> <span class="p_context"> struct radix_tree_node *radix_tree_replace_clear_tags(</span>
 		/* Clear root node tags */
 		root-&gt;gfp_mask &amp;= __GFP_BITS_MASK;
 	}
<span class="p_del">-</span>
<span class="p_del">-	radix_tree_replace_slot(slot, entry);</span>
<span class="p_del">-	return node;</span>
 }
 
 /**
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 2d0986a64f1f..ced9ef6c06b0 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -169,33 +169,35 @@</span> <span class="p_context"> static int page_cache_tree_insert(struct address_space *mapping,</span>
 static void page_cache_tree_delete(struct address_space *mapping,
 				   struct page *page, void *shadow)
 {
<span class="p_del">-	struct radix_tree_node *node;</span>
 	int i, nr = PageHuge(page) ? 1 : hpage_nr_pages(page);
 
 	VM_BUG_ON_PAGE(!PageLocked(page), page);
 	VM_BUG_ON_PAGE(PageTail(page), page);
 	VM_BUG_ON_PAGE(nr != 1 &amp;&amp; shadow, page);
 
<span class="p_del">-	if (shadow) {</span>
<span class="p_del">-		mapping-&gt;nrexceptional += nr;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Make sure the nrexceptional update is committed before</span>
<span class="p_del">-		 * the nrpages update so that final truncate racing</span>
<span class="p_del">-		 * with reclaim does not see both counters 0 at the</span>
<span class="p_del">-		 * same time and miss a shadow entry.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		smp_wmb();</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mapping-&gt;nrpages -= nr;</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; nr; i++) {
<span class="p_del">-		node = radix_tree_replace_clear_tags(&amp;mapping-&gt;page_tree,</span>
<span class="p_del">-				page-&gt;index + i, shadow);</span>
<span class="p_add">+		struct radix_tree_node *node;</span>
<span class="p_add">+		void **slot;</span>
<span class="p_add">+</span>
<span class="p_add">+		__radix_tree_lookup(&amp;mapping-&gt;page_tree, page-&gt;index + i,</span>
<span class="p_add">+				    &amp;node, &amp;slot);</span>
<span class="p_add">+</span>
<span class="p_add">+		radix_tree_clear_tags(&amp;mapping-&gt;page_tree, node, slot);</span>
<span class="p_add">+</span>
 		if (!node) {
 			VM_BUG_ON_PAGE(nr != 1, page);
<span class="p_del">-			return;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We need a node to properly account shadow</span>
<span class="p_add">+			 * entries. Don&#39;t plant any without. XXX</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			shadow = NULL;</span>
 		}
 
<span class="p_add">+		radix_tree_replace_slot(slot, shadow);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!node)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		workingset_node_pages_dec(node);
 		if (shadow)
 			workingset_node_shadows_inc(node);
<span class="p_chunk">@@ -219,6 +221,18 @@</span> <span class="p_context"> static void page_cache_tree_delete(struct address_space *mapping,</span>
 					&amp;node-&gt;private_list);
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (shadow) {</span>
<span class="p_add">+		mapping-&gt;nrexceptional += nr;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure the nrexceptional update is committed before</span>
<span class="p_add">+		 * the nrpages update so that final truncate racing</span>
<span class="p_add">+		 * with reclaim does not see both counters 0 at the</span>
<span class="p_add">+		 * same time and miss a shadow entry.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_wmb();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mapping-&gt;nrpages -= nr;</span>
 }
 
 /*
<span class="p_chunk">@@ -619,7 +633,6 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 		__delete_from_page_cache(old, NULL);
 		error = page_cache_tree_insert(mapping, new, NULL);
 		BUG_ON(error);
<span class="p_del">-		mapping-&gt;nrpages++;</span>
 
 		/*
 		 * hugetlb pages do not participate in page cache accounting.
<span class="p_chunk">@@ -1674,6 +1687,10 @@</span> <span class="p_context"> static ssize_t do_generic_file_read(struct file *filp, loff_t *ppos,</span>
 	unsigned int prev_offset;
 	int error = 0;
 
<span class="p_add">+	if (unlikely(*ppos &gt;= inode-&gt;i_sb-&gt;s_maxbytes))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	iov_iter_truncate(iter, inode-&gt;i_sb-&gt;s_maxbytes);</span>
<span class="p_add">+</span>
 	index = *ppos &gt;&gt; PAGE_SHIFT;
 	prev_index = ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT;
 	prev_offset = ra-&gt;prev_pos &amp; (PAGE_SIZE-1);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 87e11d8ad536..603bdd01ec2c 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1443,13 +1443,14 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
 {
 	spin_lock(&amp;hugetlb_lock);
 	if (PageHuge(page) &amp;&amp; !page_count(page)) {
<span class="p_del">-		struct hstate *h = page_hstate(page);</span>
<span class="p_del">-		int nid = page_to_nid(page);</span>
<span class="p_del">-		list_del(&amp;page-&gt;lru);</span>
<span class="p_add">+		struct page *head = compound_head(page);</span>
<span class="p_add">+		struct hstate *h = page_hstate(head);</span>
<span class="p_add">+		int nid = page_to_nid(head);</span>
<span class="p_add">+		list_del(&amp;head-&gt;lru);</span>
 		h-&gt;free_huge_pages--;
 		h-&gt;free_huge_pages_node[nid]--;
 		h-&gt;max_huge_pages--;
<span class="p_del">-		update_and_free_page(h, page);</span>
<span class="p_add">+		update_and_free_page(h, head);</span>
 	}
 	spin_unlock(&amp;hugetlb_lock);
 }
<span class="p_chunk">@@ -1457,7 +1458,8 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
 /*
  * Dissolve free hugepages in a given pfn range. Used by memory hotplug to
  * make specified memory blocks removable from the system.
<span class="p_del">- * Note that start_pfn should aligned with (minimum) hugepage size.</span>
<span class="p_add">+ * Note that this will dissolve a free gigantic hugepage completely, if any</span>
<span class="p_add">+ * part of it lies within the given range.</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_chunk">@@ -1466,7 +1468,6 @@</span> <span class="p_context"> void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
 	if (!hugepages_supported())
 		return;
 
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
 	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
<span class="p_header">diff --git a/sound/soc/codecs/nau8825.c b/sound/soc/codecs/nau8825.c</span>
<span class="p_header">index 2e59a85e360b..ff566376da40 100644</span>
<span class="p_header">--- a/sound/soc/codecs/nau8825.c</span>
<span class="p_header">+++ b/sound/soc/codecs/nau8825.c</span>
<span class="p_chunk">@@ -1907,7 +1907,7 @@</span> <span class="p_context"> static int nau8825_calc_fll_param(unsigned int fll_in, unsigned int fs,</span>
 	/* Calculate the FLL 10-bit integer input and the FLL 16-bit fractional
 	 * input based on FDCO, FREF and FLL ratio.
 	 */
<span class="p_del">-	fvco = div_u64(fvco &lt;&lt; 16, fref * fll_param-&gt;ratio);</span>
<span class="p_add">+	fvco = div_u64(fvco_max &lt;&lt; 16, fref * fll_param-&gt;ratio);</span>
 	fll_param-&gt;fll_int = (fvco &gt;&gt; 16) &amp; 0x3FF;
 	fll_param-&gt;fll_frac = fvco &amp; 0xFFFF;
 	return 0;
<span class="p_header">diff --git a/sound/soc/intel/atom/sst/sst_pvt.c b/sound/soc/intel/atom/sst/sst_pvt.c</span>
<span class="p_header">index adb32fefd693..b1e6b8f34a6a 100644</span>
<span class="p_header">--- a/sound/soc/intel/atom/sst/sst_pvt.c</span>
<span class="p_header">+++ b/sound/soc/intel/atom/sst/sst_pvt.c</span>
<span class="p_chunk">@@ -279,17 +279,15 @@</span> <span class="p_context"> int sst_prepare_and_post_msg(struct intel_sst_drv *sst,</span>
 
 	if (response) {
 		ret = sst_wait_timeout(sst, block);
<span class="p_del">-		if (ret &lt; 0) {</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto out;
<span class="p_del">-		} else if(block-&gt;data) {</span>
<span class="p_del">-			if (!data)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			*data = kzalloc(block-&gt;size, GFP_KERNEL);</span>
<span class="p_del">-			if (!(*data)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (data &amp;&amp; block-&gt;data) {</span>
<span class="p_add">+			*data = kmemdup(block-&gt;data, block-&gt;size, GFP_KERNEL);</span>
<span class="p_add">+			if (!*data) {</span>
 				ret = -ENOMEM;
 				goto out;
<span class="p_del">-			} else</span>
<span class="p_del">-				memcpy(data, (void *) block-&gt;data, block-&gt;size);</span>
<span class="p_add">+			}</span>
 		}
 	}
 out:

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



