
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] EFI changes for v4.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] EFI changes for v4.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 17, 2016, 8:22 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160317082229.GA23661@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8607851/mbox/"
   >mbox</a>
|
   <a href="/patch/8607851/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8607851/">/patch/8607851/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 1D7319F6E1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Mar 2016 08:23:03 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 91209202EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Mar 2016 08:22:59 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id C513320279
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Mar 2016 08:22:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932796AbcCQIWv (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 17 Mar 2016 04:22:51 -0400
Received: from mail-wm0-f47.google.com ([74.125.82.47]:36868 &quot;EHLO
	mail-wm0-f47.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755499AbcCQIWf (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 17 Mar 2016 04:22:35 -0400
Received: by mail-wm0-f47.google.com with SMTP id p65so105500126wmp.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Thu, 17 Mar 2016 01:22:33 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:content-transfer-encoding:user-agent;
	bh=/MGXrWXNBNr0bHuVbJBMk4bQf8Aof4b2YGrq87KEfNs=;
	b=KjnU4SXytD7ZOyju2nmDTVYa9HvGmR9pEVW4hu36MLCJFyY4ECfL5k8IW9xTvr6g2w
	BHF6dEu7NhY/XFxlnHU/yeJq/pUTEgPY4ZJOsm4LvTaQU79CtoMobfzHFwuSqK52ydeE
	66TU+jz6Vo/8ZS3muNWgYBwfWtTBIXbE5r1zN2tkrADFRN+K3A/ZnXrEdUI92HTpgWhv
	Qu+LEW6xJQnAOOX9p3BgRMSgeXX+7v+WIEq+2HC3GrDLb/Dgwb5Xbxu6SYBf+frBLgom
	JTLFwlLvc9lg7Sc017Pt8RV75PNxlgM+Lt31kPV3bM34dbWCVumt19GqlT6C4ahbjTHL
	YWiQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:content-transfer-encoding
	:user-agent;
	bh=/MGXrWXNBNr0bHuVbJBMk4bQf8Aof4b2YGrq87KEfNs=;
	b=CUVFPtBMkDcQrfuBmTP4jIxB8i7ZFCxS2/MqVacEv/vb5qqsHH8DUk9Zym0Afunv2b
	R/ymBrEfjE2YXHrGhwtwPwQS+05Z8gXsqzR3bIGtJCs2ebuf05DauNPWvsNP6n2Jhn/Z
	LJ3DMdpSVf4UR4znQf63SrsJvtjOzkCzsZ1FY4jszcpFF8o6M5fBB1s4FWjB9r9Aotsn
	LWAo0K09epZPt4Zb+XEO4qzW3+qUvjgAeRzQlqBjPc22IXxiyNO9Dji23zFJSgC2sX87
	W2MIEC7/82Ndwsu09CNl00zJ/rCot32V1JtulSmmkzscQjzv6AqrlcCTvuqmd4Ouc6RO
	aNhA==
X-Gm-Message-State: AD7BkJLvqsUpK+oCSyGXL3LwsPczM+1ElRZQPXNxlJTRZq78YSjCKNSuaQH8Qoyh46pa5g==
X-Received: by 10.194.123.102 with SMTP id lz6mr9265494wjb.2.1458202952476; 
	Thu, 17 Mar 2016 01:22:32 -0700 (PDT)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	63sm6982735wms.1.2016.03.17.01.22.30
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Thu, 17 Mar 2016 01:22:31 -0700 (PDT)
Date: Thu, 17 Mar 2016 09:22:29 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Sai Praneeth &lt;sai.praneeth.prakhya@intel.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] EFI changes for v4.6
Message-ID: &lt;20160317082229.GA23661@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,RP_MATCHES_RCVD,T_DKIM_INVALID,UNPARSEABLE_RELAY
	autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - March 17, 2016, 8:22 a.m.</div>
<pre class="content">
Linus,

Please pull the latest efi-core-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git efi-core-for-linus

   # HEAD: d367cef0a7f0c6ee86e997c0cb455b21b3c6b9ba x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU

The main changes are:

 - Use separate EFI page tables when executing EFI firmware code. This isolates 
   the EFI context from the rest of the kernel, which has security and general 
   robustness advantages. (Matt Fleming)

 - Run regular UEFI firmware with interrupts enabled. This is already
   the status quo under other OSs. (Ard Biesheuvel)

 - Various x86 EFI enhancements, such as the use of non-executable attributes for 
   EFI memory mappings. (Sai Praneeth Prakhya)

 - Various arm64 UEFI enhancements. (Ard Biesheuvel)

 - ... various fixes and cleanups.

The separate EFI page tables feature got delayed twice already, because it&#39;s an 
intrusive change and we didn&#39;t feel confident about it - third time&#39;s the charm we 
hope!

 Thanks,

	Ingo

------------------&gt;
Alan Ott (1):
      doc: efi-stub.txt: Fix arm64 paths

Ard Biesheuvel (14):
      efi: Expose non-blocking set_variable() wrapper to efivars
      efi: Remove redundant efi_set_variable_nonblocking() prototype
      efi/runtime-wrappers: Add a nonblocking version of QueryVariableInfo()
      efi: Add nonblocking option to efi_query_variable_store()
      efi/runtime-wrappers: Remove out of date comment regarding in_nmi()
      efi: Runtime-wrapper: Get rid of the rtc_lock spinlock
      efi/runtime-wrappers: Run UEFI Runtime Services with interrupts enabled
      efi/arm64: Drop __init annotation from handle_kernel_image()
      arm64/vmlinux.lds.S: Handle .init.rodata.xxx and .init.bss sections
      efi/efistub: Prevent __init annotations from being used
      efi/arm-init: Use read-only early mappings
      efi/arm: Check for LPAE support before booting a LPAE kernel
      efi/arm64: Check for h/w support before booting a &gt;4 KB granular kernel
      efi/arm*: Perform hardware compatibility check

Geliang Tang (1):
      efivars: Use to_efivar_entry

Matt Fleming (10):
      x86/mm: Page align the &#39;_end&#39; symbol to avoid pfn conversion bugs
      x86/mm/pat: Ensure cpa-&gt;pfn only contains page frame numbers
      x86/efi: Map RAM into the identity page table for mixed mode
      x86/efi: Hoist page table switching code into efi_call_virt()
      x86/efi: Build our own page table structures
      Documentation/x86: Update EFI memory region description
      x86/efi: Preface all print statements with efi* tag
      x86/efi-bgrt: Replace early_memremap() with memremap()
      x86/efi: Setup separate EFI page tables in kexec paths
      x86/mm/pat: Fix boot crash when 1GB pages are not supported by the CPU

MÃ´she van der Sterre (1):
      x86/efi/bgrt: Don&#39;t ignore the BGRT if the &#39;valid&#39; bit is 0

Peter Jones (1):
      efi: Reformat GUID tables to follow the format in UEFI spec

Rasmus Villemoes (1):
      efi/esrt: Don&#39;t preformat name

Robert Elliott (3):
      x86/efi: Show actual ending addresses in efi_print_memmap
      efi: Add NV memory attribute
      efi: Add Persistent Memory type name

Sai Praneeth (5):
      x86/efi-bgrt: Fix kernel panic when mapping BGRT data
      x86/mm/pat: Use _PAGE_GLOBAL bit for EFI page table mappings
      x86/mm/pat: Don&#39;t implicitly allow _PAGE_RW in kernel_map_pages_in_pgd()
      x86/efi: Map EFI_MEMORY_{XP,RO} memory region bits to EFI page tables
      x86/efi: Only map kernel text for EFI mixed mode


 Documentation/efi-stub.txt                |   4 +-
 Documentation/x86/x86_64/mm.txt           |  12 +-
 arch/arm64/kernel/vmlinux.lds.S           |   1 +
 arch/x86/include/asm/efi.h                |  28 +++-
 arch/x86/kernel/vmlinux.lds.S             |   1 +
 arch/x86/mm/pageattr.c                    |  34 +++--
 arch/x86/platform/efi/efi-bgrt.c          |  52 ++++----
 arch/x86/platform/efi/efi.c               |  67 +++++-----
 arch/x86/platform/efi/efi_32.c            |   7 +-
 arch/x86/platform/efi/efi_64.c            | 206 ++++++++++++++++++++++++------
 arch/x86/platform/efi/efi_stub_64.S       |  43 -------
 arch/x86/platform/efi/quirks.c            |  37 +++++-
 drivers/firmware/efi/arm-init.c           |  14 +-
 drivers/firmware/efi/efi.c                |  41 +-----
 drivers/firmware/efi/efivars.c            |   2 +-
 drivers/firmware/efi/esrt.c               |   5 +-
 drivers/firmware/efi/libstub/arm-stub.c   |   4 +
 drivers/firmware/efi/libstub/arm32-stub.c |  17 +++
 drivers/firmware/efi/libstub/arm64-stub.c |  34 ++++-
 drivers/firmware/efi/libstub/efistub.h    |  12 ++
 drivers/firmware/efi/runtime-wrappers.c   | 113 ++++++----------
 drivers/firmware/efi/vars.c               |  16 ++-
 include/linux/efi.h                       |  85 +++++++-----
 23 files changed, 512 insertions(+), 323 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/efi-stub.txt b/Documentation/efi-stub.txt</span>
<span class="p_header">index 7747024d3bb7..e15746988261 100644</span>
<span class="p_header">--- a/Documentation/efi-stub.txt</span>
<span class="p_header">+++ b/Documentation/efi-stub.txt</span>
<span class="p_chunk">@@ -10,12 +10,12 @@</span> <span class="p_context"> arch/x86/boot/header.S and arch/x86/boot/compressed/eboot.c,</span>
 respectively. For ARM the EFI stub is implemented in
 arch/arm/boot/compressed/efi-header.S and
 arch/arm/boot/compressed/efi-stub.c. EFI stub code that is shared
<span class="p_del">-between architectures is in drivers/firmware/efi/efi-stub-helper.c.</span>
<span class="p_add">+between architectures is in drivers/firmware/efi/libstub.</span>
 
 For arm64, there is no compressed kernel support, so the Image itself
 masquerades as a PE/COFF image and the EFI stub is linked into the
 kernel. The arm64 EFI stub lives in arch/arm64/kernel/efi-entry.S
<span class="p_del">-and arch/arm64/kernel/efi-stub.c.</span>
<span class="p_add">+and drivers/firmware/efi/libstub/arm64-stub.c.</span>
 
 By using the EFI boot stub it&#39;s possible to boot a Linux kernel
 without the use of a conventional EFI boot loader, such as grub or
<span class="p_header">diff --git a/Documentation/x86/x86_64/mm.txt b/Documentation/x86/x86_64/mm.txt</span>
<span class="p_header">index 05712ac83e38..c518dce7da4d 100644</span>
<span class="p_header">--- a/Documentation/x86/x86_64/mm.txt</span>
<span class="p_header">+++ b/Documentation/x86/x86_64/mm.txt</span>
<span class="p_chunk">@@ -16,6 +16,8 @@</span> <span class="p_context"> ffffec0000000000 - fffffc0000000000 (=44 bits) kasan shadow memory (16TB)</span>
 ... unused hole ...
 ffffff0000000000 - ffffff7fffffffff (=39 bits) %esp fixup stacks
 ... unused hole ...
<span class="p_add">+ffffffef00000000 - ffffffff00000000 (=64 GB) EFI region mapping space</span>
<span class="p_add">+... unused hole ...</span>
 ffffffff80000000 - ffffffffa0000000 (=512 MB)  kernel text mapping, from phys 0
 ffffffffa0000000 - ffffffffff5fffff (=1525 MB) module mapping space
 ffffffffff600000 - ffffffffffdfffff (=8 MB) vsyscalls
<span class="p_chunk">@@ -32,11 +34,9 @@</span> <span class="p_context"> reference.</span>
 Current X86-64 implementations only support 40 bits of address space,
 but we support up to 46 bits. This expands into MBZ space in the page tables.
 
<span class="p_del">--&gt;trampoline_pgd:</span>
<span class="p_del">-</span>
<span class="p_del">-We map EFI runtime services in the aforementioned PGD in the virtual</span>
<span class="p_del">-range of 64Gb (arbitrarily set, can be raised if needed)</span>
<span class="p_del">-</span>
<span class="p_del">-0xffffffef00000000 - 0xffffffff00000000</span>
<span class="p_add">+We map EFI runtime services in the &#39;efi_pgd&#39; PGD in a 64Gb large virtual</span>
<span class="p_add">+memory window (this size is arbitrary, it can be raised later if needed).</span>
<span class="p_add">+The mappings are not part of any other kernel PGD and are only available</span>
<span class="p_add">+during EFI runtime calls.</span>
 
 -Andi Kleen, Jul 2004
<span class="p_header">diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">index e3928f578891..cbf4db440e9c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -134,6 +134,7 @@</span> <span class="p_context"> SECTIONS</span>
 		CON_INITCALL
 		SECURITY_INITCALL
 		INIT_RAM_FS
<span class="p_add">+		*(.init.rodata.* .init.bss)	/* from the EFI stub */</span>
 	}
 	.exit.data : {
 		ARM_EXIT_KEEP(EXIT_DATA)
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 0010c78c4998..7bb206f73915 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/fpu/api.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/tlb.h&gt;</span>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
<span class="p_chunk">@@ -64,6 +65,17 @@</span> <span class="p_context"> extern u64 asmlinkage efi_call(void *fp, ...);</span>
 
 #define efi_call_phys(f, args...)		efi_call((f), args)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct efi_scratch {</span>
<span class="p_add">+	u64	r15;</span>
<span class="p_add">+	u64	prev_cr3;</span>
<span class="p_add">+	pgd_t	*efi_pgt;</span>
<span class="p_add">+	bool	use_pgd;</span>
<span class="p_add">+	u64	phys_stack;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
 #define efi_call_virt(f, ...)						\
 ({									\
 	efi_status_t __s;						\
<span class="p_chunk">@@ -71,7 +83,20 @@</span> <span class="p_context"> extern u64 asmlinkage efi_call(void *fp, ...);</span>
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
<span class="p_add">+									\</span>
<span class="p_add">+	if (efi_scratch.use_pgd) {					\</span>
<span class="p_add">+		efi_scratch.prev_cr3 = read_cr3();			\</span>
<span class="p_add">+		write_cr3((unsigned long)efi_scratch.efi_pgt);		\</span>
<span class="p_add">+		__flush_tlb_all();					\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
 	__s = efi_call((void *)efi.systab-&gt;runtime-&gt;f, __VA_ARGS__);	\
<span class="p_add">+									\</span>
<span class="p_add">+	if (efi_scratch.use_pgd) {					\</span>
<span class="p_add">+		write_cr3(efi_scratch.prev_cr3);			\</span>
<span class="p_add">+		__flush_tlb_all();					\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 	__s;								\
<span class="p_chunk">@@ -111,11 +136,12 @@</span> <span class="p_context"> extern void __init efi_memory_uc(u64 addr, unsigned long size);</span>
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
<span class="p_add">+extern int __init efi_alloc_page_tables(void);</span>
 extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
 extern void __init runtime_code_page_mkexec(void);
<span class="p_del">-extern void __init efi_runtime_mkexec(void);</span>
<span class="p_add">+extern void __init efi_runtime_update_mappings(void);</span>
 extern void __init efi_dump_pagetable(void);
 extern void __init efi_apply_memmap_quirks(void);
 extern int __init efi_reuse_config(u64 tables, int nr_tables);
<span class="p_header">diff --git a/arch/x86/kernel/vmlinux.lds.S b/arch/x86/kernel/vmlinux.lds.S</span>
<span class="p_header">index 74e4bf11f562..4f1994257a18 100644</span>
<span class="p_header">--- a/arch/x86/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/x86/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -325,6 +325,7 @@</span> <span class="p_context"> SECTIONS</span>
 		__brk_limit = .;
 	}
 
<span class="p_add">+	. = ALIGN(PAGE_SIZE);</span>
 	_end = .;
 
         STABS_DEBUG
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index 2440814b0069..fcf8e290740a 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -909,16 +909,25 @@</span> <span class="p_context"> static void populate_pte(struct cpa_data *cpa,</span>
 
 	pte = pte_offset_kernel(pmd, start);
 
<span class="p_del">-	while (num_pages-- &amp;&amp; start &lt; end) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the GLOBAL flags only if the PRESENT flag is</span>
<span class="p_add">+	 * set otherwise pte_present will return true even on</span>
<span class="p_add">+	 * a non present pte. The canon_pgprot will clear</span>
<span class="p_add">+	 * _PAGE_GLOBAL for the ancient hardware that doesn&#39;t</span>
<span class="p_add">+	 * support it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pgprot_val(pgprot) &amp; _PAGE_PRESENT)</span>
<span class="p_add">+		pgprot_val(pgprot) |= _PAGE_GLOBAL;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pgprot_val(pgprot) &amp;= ~_PAGE_GLOBAL;</span>
 
<span class="p_del">-		/* deal with the NX bit */</span>
<span class="p_del">-		if (!(pgprot_val(pgprot) &amp; _PAGE_NX))</span>
<span class="p_del">-			cpa-&gt;pfn &amp;= ~_PAGE_NX;</span>
<span class="p_add">+	pgprot = canon_pgprot(pgprot);</span>
 
<span class="p_del">-		set_pte(pte, pfn_pte(cpa-&gt;pfn &gt;&gt; PAGE_SHIFT, pgprot));</span>
<span class="p_add">+	while (num_pages-- &amp;&amp; start &lt; end) {</span>
<span class="p_add">+		set_pte(pte, pfn_pte(cpa-&gt;pfn, pgprot));</span>
 
 		start	 += PAGE_SIZE;
<span class="p_del">-		cpa-&gt;pfn += PAGE_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn++;</span>
 		pte++;
 	}
 }
<span class="p_chunk">@@ -974,11 +983,11 @@</span> <span class="p_context"> static int populate_pmd(struct cpa_data *cpa,</span>
 
 		pmd = pmd_offset(pud, start);
 
<span class="p_del">-		set_pmd(pmd, __pmd(cpa-&gt;pfn | _PAGE_PSE |</span>
<span class="p_add">+		set_pmd(pmd, __pmd(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
 				   massage_pgprot(pmd_pgprot)));
 
 		start	  += PMD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PMD_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn  += PMD_SIZE &gt;&gt; PAGE_SHIFT;</span>
 		cur_pages += PMD_SIZE &gt;&gt; PAGE_SHIFT;
 	}
 
<span class="p_chunk">@@ -1046,12 +1055,12 @@</span> <span class="p_context"> static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
 	/*
 	 * Map everything starting from the Gb boundary, possibly with 1G pages
 	 */
<span class="p_del">-	while (end - start &gt;= PUD_SIZE) {</span>
<span class="p_del">-		set_pud(pud, __pud(cpa-&gt;pfn | _PAGE_PSE |</span>
<span class="p_add">+	while (cpu_has_gbpages &amp;&amp; end - start &gt;= PUD_SIZE) {</span>
<span class="p_add">+		set_pud(pud, __pud(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
 				   massage_pgprot(pud_pgprot)));
 
 		start	  += PUD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PUD_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn  += PUD_SIZE &gt;&gt; PAGE_SHIFT;</span>
 		cur_pages += PUD_SIZE &gt;&gt; PAGE_SHIFT;
 		pud++;
 	}
<span class="p_chunk">@@ -1962,6 +1971,9 @@</span> <span class="p_context"> int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,</span>
 	if (!(page_flags &amp; _PAGE_NX))
 		cpa.mask_clr = __pgprot(_PAGE_NX);
 
<span class="p_add">+	if (!(page_flags &amp; _PAGE_RW))</span>
<span class="p_add">+		cpa.mask_clr = __pgprot(_PAGE_RW);</span>
<span class="p_add">+</span>
 	cpa.mask_set = __pgprot(_PAGE_PRESENT | page_flags);
 
 	retval = __change_page_attr_set_clr(&amp;cpa, 0);
<span class="p_header">diff --git a/arch/x86/platform/efi/efi-bgrt.c b/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_header">index ea48449b2e63..a2433817c987 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_chunk">@@ -10,6 +10,9 @@</span> <span class="p_context"></span>
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="p_add">+</span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/acpi.h&gt;
<span class="p_chunk">@@ -28,8 +31,7 @@</span> <span class="p_context"> struct bmp_header {</span>
 void __init efi_bgrt_init(void)
 {
 	acpi_status status;
<span class="p_del">-	void __iomem *image;</span>
<span class="p_del">-	bool ioremapped = false;</span>
<span class="p_add">+	void *image;</span>
 	struct bmp_header bmp_header;
 
 	if (acpi_disabled)
<span class="p_chunk">@@ -55,11 +57,6 @@</span> <span class="p_context"> void __init efi_bgrt_init(void)</span>
 		       bgrt_tab-&gt;status);
 		return;
 	}
<span class="p_del">-	if (bgrt_tab-&gt;status != 1) {</span>
<span class="p_del">-		pr_debug(&quot;Ignoring BGRT: invalid status %u (expected 1)\n&quot;,</span>
<span class="p_del">-			 bgrt_tab-&gt;status);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 	if (bgrt_tab-&gt;image_type != 0) {
 		pr_err(&quot;Ignoring BGRT: invalid image type %u (expected 0)\n&quot;,
 		       bgrt_tab-&gt;image_type);
<span class="p_chunk">@@ -70,20 +67,19 @@</span> <span class="p_context"> void __init efi_bgrt_init(void)</span>
 		return;
 	}
 
<span class="p_del">-	image = efi_lookup_mapped_addr(bgrt_tab-&gt;image_address);</span>
<span class="p_add">+	image = memremap(bgrt_tab-&gt;image_address, sizeof(bmp_header), MEMREMAP_WB);</span>
 	if (!image) {
<span class="p_del">-		image = early_ioremap(bgrt_tab-&gt;image_address,</span>
<span class="p_del">-				       sizeof(bmp_header));</span>
<span class="p_del">-		ioremapped = true;</span>
<span class="p_del">-		if (!image) {</span>
<span class="p_del">-			pr_err(&quot;Ignoring BGRT: failed to map image header memory\n&quot;);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		pr_err(&quot;Ignoring BGRT: failed to map image header memory\n&quot;);</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_del">-	memcpy_fromio(&amp;bmp_header, image, sizeof(bmp_header));</span>
<span class="p_del">-	if (ioremapped)</span>
<span class="p_del">-		early_iounmap(image, sizeof(bmp_header));</span>
<span class="p_add">+	memcpy(&amp;bmp_header, image, sizeof(bmp_header));</span>
<span class="p_add">+	memunmap(image);</span>
<span class="p_add">+	if (bmp_header.id != 0x4d42) {</span>
<span class="p_add">+		pr_err(&quot;Ignoring BGRT: Incorrect BMP magic number 0x%x (expected 0x4d42)\n&quot;,</span>
<span class="p_add">+			bmp_header.id);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	bgrt_image_size = bmp_header.size;
 
 	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL | __GFP_NOWARN);
<span class="p_chunk">@@ -93,18 +89,14 @@</span> <span class="p_context"> void __init efi_bgrt_init(void)</span>
 		return;
 	}
 
<span class="p_del">-	if (ioremapped) {</span>
<span class="p_del">-		image = early_ioremap(bgrt_tab-&gt;image_address,</span>
<span class="p_del">-				       bmp_header.size);</span>
<span class="p_del">-		if (!image) {</span>
<span class="p_del">-			pr_err(&quot;Ignoring BGRT: failed to map image memory\n&quot;);</span>
<span class="p_del">-			kfree(bgrt_image);</span>
<span class="p_del">-			bgrt_image = NULL;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	image = memremap(bgrt_tab-&gt;image_address, bmp_header.size, MEMREMAP_WB);</span>
<span class="p_add">+	if (!image) {</span>
<span class="p_add">+		pr_err(&quot;Ignoring BGRT: failed to map image memory\n&quot;);</span>
<span class="p_add">+		kfree(bgrt_image);</span>
<span class="p_add">+		bgrt_image = NULL;</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_del">-	memcpy_fromio(bgrt_image, image, bgrt_image_size);</span>
<span class="p_del">-	if (ioremapped)</span>
<span class="p_del">-		early_iounmap(image, bmp_header.size);</span>
<span class="p_add">+	memcpy(bgrt_image, image, bgrt_image_size);</span>
<span class="p_add">+	memunmap(image);</span>
 }
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index ad285404ea7f..994a7df84a7b 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -235,10 +235,10 @@</span> <span class="p_context"> void __init efi_print_memmap(void)</span>
 		char buf[64];
 
 		md = p;
<span class="p_del">-		pr_info(&quot;mem%02u: %s range=[0x%016llx-0x%016llx) (%lluMB)\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;mem%02u: %s range=[0x%016llx-0x%016llx] (%lluMB)\n&quot;,</span>
 			i, efi_md_typeattr_format(buf, sizeof(buf), md),
 			md-&gt;phys_addr,
<span class="p_del">-			md-&gt;phys_addr + (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT),</span>
<span class="p_add">+			md-&gt;phys_addr + (md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT) - 1,</span>
 			(md-&gt;num_pages &gt;&gt; (20 - EFI_PAGE_SHIFT)));
 	}
 #endif  /*  EFI_DEBUG  */
<span class="p_chunk">@@ -815,6 +815,7 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 {
 #ifdef CONFIG_KEXEC_CORE
 	efi_memory_desc_t *md;
<span class="p_add">+	unsigned int num_pages;</span>
 	void *p;
 
 	efi.systab = NULL;
<span class="p_chunk">@@ -829,6 +830,12 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 		return;
 	}
 
<span class="p_add">+	if (efi_alloc_page_tables()) {</span>
<span class="p_add">+		pr_err(&quot;Failed to allocate EFI page tables\n&quot;);</span>
<span class="p_add">+		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	* Map efi regions which were passed via setup_data. The virt_addr is a
 	* fixed addr which was used in first kernel of a kexec boot.
<span class="p_chunk">@@ -843,6 +850,14 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
 
 	BUG_ON(!efi.systab);
 
<span class="p_add">+	num_pages = ALIGN(memmap.nr_map * memmap.desc_size, PAGE_SIZE);</span>
<span class="p_add">+	num_pages &gt;&gt;= PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_setup_page_tables(memmap.phys_map, num_pages)) {</span>
<span class="p_add">+		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	efi_sync_low_kernel_mappings();
 
 	/*
<span class="p_chunk">@@ -869,7 +884,7 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  * This function will switch the EFI runtime services to virtual mode.
  * Essentially, we look through the EFI memmap and map every region that
  * has the runtime attribute bit set in its memory descriptor into the
<span class="p_del">- * -&gt;trampoline_pgd page table using a top-down VA allocation scheme.</span>
<span class="p_add">+ * efi_pgd page table.</span>
  *
  * The old method which used to update that memory descriptor with the
  * virtual address obtained from ioremap() is still supported when the
<span class="p_chunk">@@ -879,8 +894,8 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  *
  * The new method does a pagetable switch in a preemption-safe manner
  * so that we&#39;re in a different address space when calling a runtime
<span class="p_del">- * function. For function arguments passing we do copy the PGDs of the</span>
<span class="p_del">- * kernel page table into -&gt;trampoline_pgd prior to each call.</span>
<span class="p_add">+ * function. For function arguments passing we do copy the PUDs of the</span>
<span class="p_add">+ * kernel page table into efi_pgd prior to each call.</span>
  *
  * Specially for kexec boot, efi runtime maps in previous kernel should
  * be passed in via setup_data. In that case runtime ranges will be mapped
<span class="p_chunk">@@ -895,6 +910,12 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 
 	efi.systab = NULL;
 
<span class="p_add">+	if (efi_alloc_page_tables()) {</span>
<span class="p_add">+		pr_err(&quot;Failed to allocate EFI page tables\n&quot;);</span>
<span class="p_add">+		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	efi_merge_regions();
 	new_memmap = efi_map_regions(&amp;count, &amp;pg_shift);
 	if (!new_memmap) {
<span class="p_chunk">@@ -913,7 +934,6 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 	}
 
 	efi_sync_low_kernel_mappings();
<span class="p_del">-	efi_dump_pagetable();</span>
 
 	if (efi_is_native()) {
 		status = phys_efi_set_virtual_address_map(
<span class="p_chunk">@@ -951,31 +971,20 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 
 	efi.set_virtual_address_map = NULL;
 
<span class="p_del">-	efi_runtime_mkexec();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Apply more restrictive page table mapping attributes now that</span>
<span class="p_add">+	 * SVAM() has been called and the firmware has performed all</span>
<span class="p_add">+	 * necessary relocation fixups for the new virtual addresses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	efi_runtime_update_mappings();</span>
<span class="p_add">+	efi_dump_pagetable();</span>
 
 	/*
<span class="p_del">-	 * We mapped the descriptor array into the EFI pagetable above but we&#39;re</span>
<span class="p_del">-	 * not unmapping it here. Here&#39;s why:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We&#39;re copying select PGDs from the kernel page table to the EFI page</span>
<span class="p_del">-	 * table and when we do so and make changes to those PGDs like unmapping</span>
<span class="p_del">-	 * stuff from them, those changes appear in the kernel page table and we</span>
<span class="p_del">-	 * go boom.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * From setup_real_mode():</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * ...</span>
<span class="p_del">-	 * trampoline_pgd[0] = init_level4_pgt[pgd_index(__PAGE_OFFSET)].pgd;</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * In this particular case, our allocation is in PGD 0 of the EFI page</span>
<span class="p_del">-	 * table but we&#39;ve copied that PGD from PGD[272] of the EFI page table:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *	pgd_index(__PAGE_OFFSET = 0xffff880000000000) = 272</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * where the direct memory mapping in kernel space is.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * new_memmap&#39;s VA comes from that direct mapping and thus clearing it,</span>
<span class="p_del">-	 * it would get cleared in the kernel page table too.</span>
<span class="p_add">+	 * We mapped the descriptor array into the EFI pagetable above</span>
<span class="p_add">+	 * but we&#39;re not unmapping it here because if we&#39;re running in</span>
<span class="p_add">+	 * EFI mixed mode we need all of memory to be accessible when</span>
<span class="p_add">+	 * we pass parameters to the EFI runtime services in the</span>
<span class="p_add">+	 * thunking code.</span>
 	 *
 	 * efi_cleanup_page_tables(__pa(new_memmap), 1 &lt;&lt; pg_shift);
 	 */
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index ed5b67338294..338402b91d2e 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -38,6 +38,11 @@</span> <span class="p_context"></span>
  * say 0 - 3G.
  */
 
<span class="p_add">+int __init efi_alloc_page_tables(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void efi_sync_low_kernel_mappings(void) {}
 void __init efi_dump_pagetable(void) {}
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
<span class="p_chunk">@@ -85,7 +90,7 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	__flush_tlb_all();
 }
 
<span class="p_del">-void __init efi_runtime_mkexec(void)</span>
<span class="p_add">+void __init efi_runtime_update_mappings(void)</span>
 {
 	if (__supported_pte_mask &amp; _PAGE_NX)
 		runtime_code_page_mkexec();
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index a0ac0f9c307f..49e4dd4a1f58 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -15,6 +15,8 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#define pr_fmt(fmt) &quot;efi: &quot; fmt</span>
<span class="p_add">+</span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_chunk">@@ -40,6 +42,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/realmode.h&gt;
 #include &lt;asm/time.h&gt;
<span class="p_add">+#include &lt;asm/pgalloc.h&gt;</span>
 
 /*
  * We allocate runtime services regions bottom-up, starting from -4G, i.e.
<span class="p_chunk">@@ -47,16 +50,7 @@</span> <span class="p_context"></span>
  */
 static u64 efi_va = EFI_VA_START;
 
<span class="p_del">-/*</span>
<span class="p_del">- * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_del">- */</span>
<span class="p_del">-struct efi_scratch {</span>
<span class="p_del">-	u64 r15;</span>
<span class="p_del">-	u64 prev_cr3;</span>
<span class="p_del">-	pgd_t *efi_pgt;</span>
<span class="p_del">-	bool use_pgd;</span>
<span class="p_del">-	u64 phys_stack;</span>
<span class="p_del">-} __packed;</span>
<span class="p_add">+struct efi_scratch efi_scratch;</span>
 
 static void __init early_code_mapping_set_exec(int executable)
 {
<span class="p_chunk">@@ -83,8 +77,11 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 	int pgd;
 	int n_pgds;
 
<span class="p_del">-	if (!efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_add">+		save_pgd = (pgd_t *)read_cr3();</span>
<span class="p_add">+		write_cr3((unsigned long)efi_scratch.efi_pgt);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	early_code_mapping_set_exec(1);
 
<span class="p_chunk">@@ -96,6 +93,7 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
 	}
<span class="p_add">+out:</span>
 	__flush_tlb_all();
 
 	return save_pgd;
<span class="p_chunk">@@ -109,8 +107,11 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	int pgd_idx;
 	int nr_pgds;
 
<span class="p_del">-	if (!save_pgd)</span>
<span class="p_add">+	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_add">+		write_cr3((unsigned long)save_pgd);</span>
<span class="p_add">+		__flush_tlb_all();</span>
 		return;
<span class="p_add">+	}</span>
 
 	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);
 
<span class="p_chunk">@@ -123,27 +124,98 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_add">+static pgd_t *efi_pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We need our own copy of the higher levels of the page tables</span>
<span class="p_add">+ * because we want to avoid inserting EFI region mappings (EFI_VA_END</span>
<span class="p_add">+ * to EFI_VA_START) into the standard kernel page tables. Everything</span>
<span class="p_add">+ * else can be shared, see efi_sync_low_kernel_mappings().</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init efi_alloc_page_tables(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	gfp_t gfp_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfp_mask = GFP_KERNEL | __GFP_NOTRACK | __GFP_REPEAT | __GFP_ZERO;</span>
<span class="p_add">+	efi_pgd = (pgd_t *)__get_free_page(gfp_mask);</span>
<span class="p_add">+	if (!efi_pgd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_add">+</span>
<span class="p_add">+	pud = pud_alloc_one(NULL, 0);</span>
<span class="p_add">+	if (!pud) {</span>
<span class="p_add">+		free_page((unsigned long)efi_pgd);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_populate(NULL, pgd, pud);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Add low kernel mappings for passing arguments to EFI functions.
  */
 void efi_sync_low_kernel_mappings(void)
 {
<span class="p_del">-	unsigned num_pgds;</span>
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_add">+	unsigned num_entries;</span>
<span class="p_add">+	pgd_t *pgd_k, *pgd_efi;</span>
<span class="p_add">+	pud_t *pud_k, *pud_efi;</span>
 
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return;
 
<span class="p_del">-	num_pgds = pgd_index(MODULES_END - 1) - pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can share all PGD entries apart from the one entry that</span>
<span class="p_add">+	 * covers the EFI runtime mapping space.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Make sure the EFI runtime region mappings are guaranteed to</span>
<span class="p_add">+	 * only span a single PGD entry and that the entry also maps</span>
<span class="p_add">+	 * other important kernel regions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(pgd_index(EFI_VA_END) != pgd_index(MODULES_END));</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_START &amp; PGDIR_MASK) !=</span>
<span class="p_add">+			(EFI_VA_END &amp; PGDIR_MASK));</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_efi = efi_pgd + pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	pgd_k = pgd_offset_k(PAGE_OFFSET);</span>
 
<span class="p_del">-	memcpy(pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_del">-		init_mm.pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_del">-		sizeof(pgd_t) * num_pgds);</span>
<span class="p_add">+	num_entries = pgd_index(EFI_VA_END) - pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	memcpy(pgd_efi, pgd_k, sizeof(pgd_t) * num_entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We share all the PUD entries apart from those that map the</span>
<span class="p_add">+	 * EFI regions. Copy around them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_START &amp; ~PUD_MASK) != 0);</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_END &amp; ~PUD_MASK) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_efi = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_add">+	pud_efi = pud_offset(pgd_efi, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_k = pgd_offset_k(EFI_VA_END);</span>
<span class="p_add">+	pud_k = pud_offset(pgd_k, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	num_entries = pud_index(EFI_VA_END);</span>
<span class="p_add">+	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	pud_efi = pud_offset(pgd_efi, EFI_VA_START);</span>
<span class="p_add">+	pud_k = pud_offset(pgd_k, EFI_VA_START);</span>
<span class="p_add">+</span>
<span class="p_add">+	num_entries = PTRS_PER_PUD - pud_index(EFI_VA_START);</span>
<span class="p_add">+	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
 }
 
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	unsigned long text;</span>
<span class="p_add">+	unsigned long pfn, text;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
 	struct page *page;
 	unsigned npages;
 	pgd_t *pgd;
<span class="p_chunk">@@ -151,8 +223,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
<span class="p_del">-	efi_scratch.efi_pgt = (pgd_t *)(unsigned long)real_mode_header-&gt;trampoline_pgd;</span>
<span class="p_del">-	pgd = __va(efi_scratch.efi_pgt);</span>
<span class="p_add">+	efi_scratch.efi_pgt = (pgd_t *)__pa(efi_pgd);</span>
<span class="p_add">+	pgd = efi_pgd;</span>
 
 	/*
 	 * It can happen that the physical address of new_memmap lands in memory
<span class="p_chunk">@@ -160,7 +232,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	 * and ident-map those pages containing the map before calling
 	 * phys_efi_set_virtual_address_map().
 	 */
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, pa_memmap, pa_memmap, num_pages, _PAGE_NX)) {</span>
<span class="p_add">+	pfn = pa_memmap &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, pa_memmap, num_pages, _PAGE_NX | _PAGE_RW)) {</span>
 		pr_err(&quot;Error ident-mapping new memmap (0x%lx)!\n&quot;, pa_memmap);
 		return 1;
 	}
<span class="p_chunk">@@ -176,6 +249,25 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	if (!IS_ENABLED(CONFIG_EFI_MIXED))
 		return 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Map all of RAM so that we can access arguments in the 1:1</span>
<span class="p_add">+	 * mapping when making EFI runtime calls.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for_each_efi_memory_desc(&amp;memmap, md) {</span>
<span class="p_add">+		if (md-&gt;type != EFI_CONVENTIONAL_MEMORY &amp;&amp;</span>
<span class="p_add">+		    md-&gt;type != EFI_LOADER_DATA &amp;&amp;</span>
<span class="p_add">+		    md-&gt;type != EFI_LOADER_CODE)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		pfn = md-&gt;phys_addr &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		npages = md-&gt;num_pages;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (kernel_map_pages_in_pgd(pgd, pfn, md-&gt;phys_addr, npages, _PAGE_RW)) {</span>
<span class="p_add">+			pr_err(&quot;Failed to map 1:1 memory\n&quot;);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	page = alloc_page(GFP_KERNEL|__GFP_DMA32);
 	if (!page)
 		panic(&quot;Unable to allocate EFI runtime stack &lt; 4GB\n&quot;);
<span class="p_chunk">@@ -183,10 +275,11 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	efi_scratch.phys_stack = virt_to_phys(page_address(page));
 	efi_scratch.phys_stack += PAGE_SIZE; /* stack grows down */
 
<span class="p_del">-	npages = (_end - _text) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	npages = (_etext - _text) &gt;&gt; PAGE_SHIFT;</span>
 	text = __pa(_text);
<span class="p_add">+	pfn = text &gt;&gt; PAGE_SHIFT;</span>
 
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, text &gt;&gt; PAGE_SHIFT, text, npages, 0)) {</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, text, npages, _PAGE_RW)) {</span>
 		pr_err(&quot;Failed to map kernel text 1:1\n&quot;);
 		return 1;
 	}
<span class="p_chunk">@@ -196,20 +289,20 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 
 void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	kernel_unmap_pages_in_pgd(pgd, pa_memmap, num_pages);</span>
<span class="p_add">+	kernel_unmap_pages_in_pgd(efi_pgd, pa_memmap, num_pages);</span>
 }
 
 static void __init __map_region(efi_memory_desc_t *md, u64 va)
 {
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-	unsigned long pf = 0;</span>
<span class="p_add">+	unsigned long flags = _PAGE_RW;</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+	pgd_t *pgd = efi_pgd;</span>
 
 	if (!(md-&gt;attribute &amp; EFI_MEMORY_WB))
<span class="p_del">-		pf |= _PAGE_PCD;</span>
<span class="p_add">+		flags |= _PAGE_PCD;</span>
 
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, md-&gt;phys_addr, va, md-&gt;num_pages, pf))</span>
<span class="p_add">+	pfn = md-&gt;phys_addr &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, va, md-&gt;num_pages, flags))</span>
 		pr_warn(&quot;Error mapping PA 0x%llx -&gt; VA 0x%llx!\n&quot;,
 			   md-&gt;phys_addr, va);
 }
<span class="p_chunk">@@ -300,21 +393,56 @@</span> <span class="p_context"> void __init parse_efi_setup(u64 phys_addr, u32 data_len)</span>
 	efi_setup = phys_addr + sizeof(struct setup_data);
 }
 
<span class="p_del">-void __init efi_runtime_mkexec(void)</span>
<span class="p_add">+void __init efi_runtime_update_mappings(void)</span>
 {
<span class="p_del">-	if (!efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+	pgd_t *pgd = efi_pgd;</span>
<span class="p_add">+	efi_memory_desc_t *md;</span>
<span class="p_add">+	void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_add">+		if (__supported_pte_mask &amp; _PAGE_NX)</span>
<span class="p_add">+			runtime_code_page_mkexec();</span>
 		return;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!efi_enabled(EFI_NX_PE_DATA))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (p = memmap.map; p &lt; memmap.map_end; p += memmap.desc_size) {</span>
<span class="p_add">+		unsigned long pf = 0;</span>
<span class="p_add">+		md = p;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-	if (__supported_pte_mask &amp; _PAGE_NX)</span>
<span class="p_del">-		runtime_code_page_mkexec();</span>
<span class="p_add">+		if (!(md-&gt;attribute &amp; EFI_MEMORY_WB))</span>
<span class="p_add">+			pf |= _PAGE_PCD;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((md-&gt;attribute &amp; EFI_MEMORY_XP) ||</span>
<span class="p_add">+			(md-&gt;type == EFI_RUNTIME_SERVICES_DATA))</span>
<span class="p_add">+			pf |= _PAGE_NX;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!(md-&gt;attribute &amp; EFI_MEMORY_RO) &amp;&amp;</span>
<span class="p_add">+			(md-&gt;type != EFI_RUNTIME_SERVICES_CODE))</span>
<span class="p_add">+			pf |= _PAGE_RW;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update the 1:1 mapping */</span>
<span class="p_add">+		pfn = md-&gt;phys_addr &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		if (kernel_map_pages_in_pgd(pgd, pfn, md-&gt;phys_addr, md-&gt;num_pages, pf))</span>
<span class="p_add">+			pr_warn(&quot;Error mapping PA 0x%llx -&gt; VA 0x%llx!\n&quot;,</span>
<span class="p_add">+				   md-&gt;phys_addr, md-&gt;virt_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (kernel_map_pages_in_pgd(pgd, pfn, md-&gt;virt_addr, md-&gt;num_pages, pf))</span>
<span class="p_add">+			pr_warn(&quot;Error mapping PA 0x%llx -&gt; VA 0x%llx!\n&quot;,</span>
<span class="p_add">+				   md-&gt;phys_addr, md-&gt;virt_addr);</span>
<span class="p_add">+	}</span>
 }
 
 void __init efi_dump_pagetable(void)
 {
 #ifdef CONFIG_EFI_PGT_DUMP
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	ptdump_walk_pgd_level(NULL, pgd);</span>
<span class="p_add">+	ptdump_walk_pgd_level(NULL, efi_pgd);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_stub_64.S b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">index 86d0f9e08dd9..32020cb8bb08 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_chunk">@@ -38,41 +38,6 @@</span> <span class="p_context"></span>
 	mov %rsi, %cr0;			\
 	mov (%rsp), %rsp
 
<span class="p_del">-	/* stolen from gcc */</span>
<span class="p_del">-	.macro FLUSH_TLB_ALL</span>
<span class="p_del">-	movq %r15, efi_scratch(%rip)</span>
<span class="p_del">-	movq %r14, efi_scratch+8(%rip)</span>
<span class="p_del">-	movq %cr4, %r15</span>
<span class="p_del">-	movq %r15, %r14</span>
<span class="p_del">-	andb $0x7f, %r14b</span>
<span class="p_del">-	movq %r14, %cr4</span>
<span class="p_del">-	movq %r15, %cr4</span>
<span class="p_del">-	movq efi_scratch+8(%rip), %r14</span>
<span class="p_del">-	movq efi_scratch(%rip), %r15</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
<span class="p_del">-	.macro SWITCH_PGT</span>
<span class="p_del">-	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_del">-	je 1f</span>
<span class="p_del">-	movq %r15, efi_scratch(%rip)		# r15</span>
<span class="p_del">-	# save previous CR3</span>
<span class="p_del">-	movq %cr3, %r15</span>
<span class="p_del">-	movq %r15, efi_scratch+8(%rip)		# prev_cr3</span>
<span class="p_del">-	movq efi_scratch+16(%rip), %r15		# EFI pgt</span>
<span class="p_del">-	movq %r15, %cr3</span>
<span class="p_del">-	1:</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
<span class="p_del">-	.macro RESTORE_PGT</span>
<span class="p_del">-	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_del">-	je 2f</span>
<span class="p_del">-	movq efi_scratch+8(%rip), %r15</span>
<span class="p_del">-	movq %r15, %cr3</span>
<span class="p_del">-	movq efi_scratch(%rip), %r15</span>
<span class="p_del">-	FLUSH_TLB_ALL</span>
<span class="p_del">-	2:</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
 ENTRY(efi_call)
 	SAVE_XMM
 	mov (%rsp), %rax
<span class="p_chunk">@@ -83,16 +48,8 @@</span> <span class="p_context"> ENTRY(efi_call)</span>
 	mov %r8, %r9
 	mov %rcx, %r8
 	mov %rsi, %rcx
<span class="p_del">-	SWITCH_PGT</span>
 	call *%rdi
<span class="p_del">-	RESTORE_PGT</span>
 	addq $48, %rsp
 	RESTORE_XMM
 	ret
 ENDPROC(efi_call)
<span class="p_del">-</span>
<span class="p_del">-	.data</span>
<span class="p_del">-ENTRY(efi_scratch)</span>
<span class="p_del">-	.fill 3,8,0</span>
<span class="p_del">-	.byte 0</span>
<span class="p_del">-	.quad 0</span>
<span class="p_header">diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">index 2d66db8f80f9..2326bf51978f 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/quirks.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/quirks.c</span>
<span class="p_chunk">@@ -1,3 +1,5 @@</span> <span class="p_context"></span>
<span class="p_add">+#define pr_fmt(fmt) &quot;efi: &quot; fmt</span>
<span class="p_add">+</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/string.h&gt;
<span class="p_chunk">@@ -55,13 +57,41 @@</span> <span class="p_context"> void efi_delete_dummy_variable(void)</span>
 }
 
 /*
<span class="p_add">+ * In the nonblocking case we do not attempt to perform garbage</span>
<span class="p_add">+ * collection if we do not have enough free space. Rather, we do the</span>
<span class="p_add">+ * bare minimum check and give up immediately if the available space</span>
<span class="p_add">+ * is below EFI_MIN_RESERVE.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function is intended to be small and simple because it is</span>
<span class="p_add">+ * invoked from crash handler paths.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+query_variable_store_nonblocking(u32 attributes, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+	u64 storage_size, remaining_size, max_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi.query_variable_info_nonblocking(attributes, &amp;storage_size,</span>
<span class="p_add">+						     &amp;remaining_size,</span>
<span class="p_add">+						     &amp;max_size);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (remaining_size - size &lt; EFI_MIN_RESERVE)</span>
<span class="p_add">+		return EFI_OUT_OF_RESOURCES;</span>
<span class="p_add">+</span>
<span class="p_add">+	return EFI_SUCCESS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Some firmware implementations refuse to boot if there&#39;s insufficient space
  * in the variable store. Ensure that we never use more than a safe limit.
  *
  * Return EFI_SUCCESS if it is safe to write &#39;size&#39; bytes to the variable
  * store.
  */
<span class="p_del">-efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)</span>
<span class="p_add">+efi_status_t efi_query_variable_store(u32 attributes, unsigned long size,</span>
<span class="p_add">+				      bool nonblocking)</span>
 {
 	efi_status_t status;
 	u64 storage_size, remaining_size, max_size;
<span class="p_chunk">@@ -69,6 +99,9 @@</span> <span class="p_context"> efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)</span>
 	if (!(attributes &amp; EFI_VARIABLE_NON_VOLATILE))
 		return 0;
 
<span class="p_add">+	if (nonblocking)</span>
<span class="p_add">+		return query_variable_store_nonblocking(attributes, size);</span>
<span class="p_add">+</span>
 	status = efi.query_variable_info(attributes, &amp;storage_size,
 					 &amp;remaining_size, &amp;max_size);
 	if (status != EFI_SUCCESS)
<span class="p_chunk">@@ -267,7 +300,7 @@</span> <span class="p_context"> void __init efi_apply_memmap_quirks(void)</span>
 	 * services.
 	 */
 	if (!efi_runtime_supported()) {
<span class="p_del">-		pr_info(&quot;efi: Setup done, disabling due to 32/64-bit mismatch\n&quot;);</span>
<span class="p_add">+		pr_info(&quot;Setup done, disabling due to 32/64-bit mismatch\n&quot;);</span>
 		efi_unmap_memmap();
 	}
 
<span class="p_header">diff --git a/drivers/firmware/efi/arm-init.c b/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">index 9e15d571b53c..aa1f743152a2 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/arm-init.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/arm-init.c</span>
<span class="p_chunk">@@ -61,8 +61,8 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 	char vendor[100] = &quot;unknown&quot;;
 	int i, retval;
 
<span class="p_del">-	efi.systab = early_memremap(efi_system_table,</span>
<span class="p_del">-				    sizeof(efi_system_table_t));</span>
<span class="p_add">+	efi.systab = early_memremap_ro(efi_system_table,</span>
<span class="p_add">+				       sizeof(efi_system_table_t));</span>
 	if (efi.systab == NULL) {
 		pr_warn(&quot;Unable to map EFI system table.\n&quot;);
 		return -ENOMEM;
<span class="p_chunk">@@ -86,8 +86,8 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 			efi.systab-&gt;hdr.revision &amp; 0xffff);
 
 	/* Show what we know for posterity */
<span class="p_del">-	c16 = early_memremap(efi_to_phys(efi.systab-&gt;fw_vendor),</span>
<span class="p_del">-			     sizeof(vendor) * sizeof(efi_char16_t));</span>
<span class="p_add">+	c16 = early_memremap_ro(efi_to_phys(efi.systab-&gt;fw_vendor),</span>
<span class="p_add">+				sizeof(vendor) * sizeof(efi_char16_t));</span>
 	if (c16) {
 		for (i = 0; i &lt; (int) sizeof(vendor) - 1 &amp;&amp; *c16; ++i)
 			vendor[i] = c16[i];
<span class="p_chunk">@@ -100,8 +100,8 @@</span> <span class="p_context"> static int __init uefi_init(void)</span>
 		efi.systab-&gt;hdr.revision &amp; 0xffff, vendor);
 
 	table_size = sizeof(efi_config_table_64_t) * efi.systab-&gt;nr_tables;
<span class="p_del">-	config_tables = early_memremap(efi_to_phys(efi.systab-&gt;tables),</span>
<span class="p_del">-				       table_size);</span>
<span class="p_add">+	config_tables = early_memremap_ro(efi_to_phys(efi.systab-&gt;tables),</span>
<span class="p_add">+					  table_size);</span>
 	if (config_tables == NULL) {
 		pr_warn(&quot;Unable to map EFI config table array.\n&quot;);
 		retval = -ENOMEM;
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> void __init efi_init(void)</span>
 	efi_system_table = params.system_table;
 
 	memmap.phys_map = params.mmap;
<span class="p_del">-	memmap.map = early_memremap(params.mmap, params.mmap_size);</span>
<span class="p_add">+	memmap.map = early_memremap_ro(params.mmap, params.mmap_size);</span>
 	if (memmap.map == NULL) {
 		/*
 		* If we are booting via UEFI, the UEFI memory map is the only
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 2cd37dad67a6..3a69ed5ecfcb 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -182,6 +182,7 @@</span> <span class="p_context"> static int generic_ops_register(void)</span>
 {
 	generic_ops.get_variable = efi.get_variable;
 	generic_ops.set_variable = efi.set_variable;
<span class="p_add">+	generic_ops.set_variable_nonblocking = efi.set_variable_nonblocking;</span>
 	generic_ops.get_next_variable = efi.get_next_variable;
 	generic_ops.query_variable_store = efi_query_variable_store;
 
<span class="p_chunk">@@ -326,38 +327,6 @@</span> <span class="p_context"> u64 __init efi_mem_desc_end(efi_memory_desc_t *md)</span>
 	return end;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * We can&#39;t ioremap data in EFI boot services RAM, because we&#39;ve already mapped</span>
<span class="p_del">- * it as RAM.  So, look it up in the existing EFI memory map instead.  Only</span>
<span class="p_del">- * callable after efi_enter_virtual_mode and before efi_free_boot_services.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __iomem *efi_lookup_mapped_addr(u64 phys_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_memory_map *map;</span>
<span class="p_del">-	void *p;</span>
<span class="p_del">-	map = efi.memmap;</span>
<span class="p_del">-	if (!map)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	if (WARN_ON(!map-&gt;map))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	for (p = map-&gt;map; p &lt; map-&gt;map_end; p += map-&gt;desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_del">-		u64 size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_del">-		u64 end = md-&gt;phys_addr + size;</span>
<span class="p_del">-		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME) &amp;&amp;</span>
<span class="p_del">-		    md-&gt;type != EFI_BOOT_SERVICES_CODE &amp;&amp;</span>
<span class="p_del">-		    md-&gt;type != EFI_BOOT_SERVICES_DATA)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (!md-&gt;virt_addr)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (phys_addr &gt;= md-&gt;phys_addr &amp;&amp; phys_addr &lt; end) {</span>
<span class="p_del">-			phys_addr += md-&gt;virt_addr - md-&gt;phys_addr;</span>
<span class="p_del">-			return (__force void __iomem *)(unsigned long)phys_addr;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, &quot;ACPI 2.0&quot;, &amp;efi.acpi20},
 	{ACPI_TABLE_GUID, &quot;ACPI&quot;, &amp;efi.acpi},
<span class="p_chunk">@@ -586,7 +555,8 @@</span> <span class="p_context"> static __initdata char memory_type_name[][20] = {</span>
 	&quot;ACPI Memory NVS&quot;,
 	&quot;Memory Mapped I/O&quot;,
 	&quot;MMIO Port Space&quot;,
<span class="p_del">-	&quot;PAL Code&quot;</span>
<span class="p_add">+	&quot;PAL Code&quot;,</span>
<span class="p_add">+	&quot;Persistent Memory&quot;,</span>
 };
 
 char * __init efi_md_typeattr_format(char *buf, size_t size,
<span class="p_chunk">@@ -613,13 +583,16 @@</span> <span class="p_context"> char * __init efi_md_typeattr_format(char *buf, size_t size,</span>
 	if (attr &amp; ~(EFI_MEMORY_UC | EFI_MEMORY_WC | EFI_MEMORY_WT |
 		     EFI_MEMORY_WB | EFI_MEMORY_UCE | EFI_MEMORY_RO |
 		     EFI_MEMORY_WP | EFI_MEMORY_RP | EFI_MEMORY_XP |
<span class="p_add">+		     EFI_MEMORY_NV |</span>
 		     EFI_MEMORY_RUNTIME | EFI_MEMORY_MORE_RELIABLE))
 		snprintf(pos, size, &quot;|attr=0x%016llx]&quot;,
 			 (unsigned long long)attr);
 	else
<span class="p_del">-		snprintf(pos, size, &quot;|%3s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]&quot;,</span>
<span class="p_add">+		snprintf(pos, size,</span>
<span class="p_add">+			 &quot;|%3s|%2s|%2s|%2s|%2s|%2s|%2s|%3s|%2s|%2s|%2s|%2s]&quot;,</span>
 			 attr &amp; EFI_MEMORY_RUNTIME ? &quot;RUN&quot; : &quot;&quot;,
 			 attr &amp; EFI_MEMORY_MORE_RELIABLE ? &quot;MR&quot; : &quot;&quot;,
<span class="p_add">+			 attr &amp; EFI_MEMORY_NV      ? &quot;NV&quot;  : &quot;&quot;,</span>
 			 attr &amp; EFI_MEMORY_XP      ? &quot;XP&quot;  : &quot;&quot;,
 			 attr &amp; EFI_MEMORY_RP      ? &quot;RP&quot;  : &quot;&quot;,
 			 attr &amp; EFI_MEMORY_WP      ? &quot;WP&quot;  : &quot;&quot;,
<span class="p_header">diff --git a/drivers/firmware/efi/efivars.c b/drivers/firmware/efi/efivars.c</span>
<span class="p_header">index 10e6774ab2a2..b23a271c6ae5 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efivars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efivars.c</span>
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static const struct sysfs_ops efivar_attr_ops = {</span>
 
 static void efivar_release(struct kobject *kobj)
 {
<span class="p_del">-	struct efivar_entry *var = container_of(kobj, struct efivar_entry, kobj);</span>
<span class="p_add">+	struct efivar_entry *var = to_efivar_entry(kobj);</span>
 	kfree(var);
 }
 
<span class="p_header">diff --git a/drivers/firmware/efi/esrt.c b/drivers/firmware/efi/esrt.c</span>
<span class="p_header">index 22c5285f7705..75feb3f5829b 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/esrt.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/esrt.c</span>
<span class="p_chunk">@@ -167,14 +167,11 @@</span> <span class="p_context"> static struct kset *esrt_kset;</span>
 static int esre_create_sysfs_entry(void *esre, int entry_num)
 {
 	struct esre_entry *entry;
<span class="p_del">-	char name[20];</span>
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		return -ENOMEM;
 
<span class="p_del">-	sprintf(name, &quot;entry%d&quot;, entry_num);</span>
<span class="p_del">-</span>
 	entry-&gt;kobj.kset = esrt_kset;
 
 	if (esrt-&gt;fw_resource_version == 1) {
<span class="p_chunk">@@ -182,7 +179,7 @@</span> <span class="p_context"> static int esre_create_sysfs_entry(void *esre, int entry_num)</span>
 
 		entry-&gt;esre.esre1 = esre;
 		rc = kobject_init_and_add(&amp;entry-&gt;kobj, &amp;esre1_ktype, NULL,
<span class="p_del">-					  &quot;%s&quot;, name);</span>
<span class="p_add">+					  &quot;entry%d&quot;, entry_num);</span>
 		if (rc) {
 			kfree(entry);
 			return rc;
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/arm-stub.c b/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_header">index 3397902e4040..6086a874fa3c 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/arm-stub.c</span>
<span class="p_chunk">@@ -190,6 +190,10 @@</span> <span class="p_context"> unsigned long efi_entry(void *handle, efi_system_table_t *sys_table,</span>
 
 	pr_efi(sys_table, &quot;Booting Linux Kernel...\n&quot;);
 
<span class="p_add">+	status = check_platform_features(sys_table);</span>
<span class="p_add">+	if (status != EFI_SUCCESS)</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
 	/*
 	 * Get a handle to the loaded image protocol.  This is used to get
 	 * information about the running image, such as size and the command
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/arm32-stub.c b/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_header">index 495ebd657e38..6f42be4d0084 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/arm32-stub.c</span>
<span class="p_chunk">@@ -9,6 +9,23 @@</span> <span class="p_context"></span>
 #include &lt;linux/efi.h&gt;
 #include &lt;asm/efi.h&gt;
 
<span class="p_add">+efi_status_t check_platform_features(efi_system_table_t *sys_table_arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int block;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* non-LPAE kernels can run anywhere */</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_ARM_LPAE))</span>
<span class="p_add">+		return EFI_SUCCESS;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* LPAE kernels need compatible hardware */</span>
<span class="p_add">+	block = cpuid_feature_extract(CPUID_EXT_MMFR0, 0);</span>
<span class="p_add">+	if (block &lt; 5) {</span>
<span class="p_add">+		pr_efi_err(sys_table_arg, &quot;This LPAE kernel is not supported by your CPU\n&quot;);</span>
<span class="p_add">+		return EFI_UNSUPPORTED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return EFI_SUCCESS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 efi_status_t handle_kernel_image(efi_system_table_t *sys_table,
 				 unsigned long *image_addr,
 				 unsigned long *image_size,
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/arm64-stub.c b/drivers/firmware/efi/libstub/arm64-stub.c</span>
<span class="p_header">index 78dfbd34b6bf..047fc343665a 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/arm64-stub.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/arm64-stub.c</span>
<span class="p_chunk">@@ -12,14 +12,34 @@</span> <span class="p_context"></span>
 #include &lt;linux/efi.h&gt;
 #include &lt;asm/efi.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_add">+#include &lt;asm/sysreg.h&gt;</span>
 
<span class="p_del">-efi_status_t __init handle_kernel_image(efi_system_table_t *sys_table_arg,</span>
<span class="p_del">-					unsigned long *image_addr,</span>
<span class="p_del">-					unsigned long *image_size,</span>
<span class="p_del">-					unsigned long *reserve_addr,</span>
<span class="p_del">-					unsigned long *reserve_size,</span>
<span class="p_del">-					unsigned long dram_base,</span>
<span class="p_del">-					efi_loaded_image_t *image)</span>
<span class="p_add">+efi_status_t check_platform_features(efi_system_table_t *sys_table_arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 tg;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* UEFI mandates support for 4 KB granularity, no need to check */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_ARM64_4K_PAGES))</span>
<span class="p_add">+		return EFI_SUCCESS;</span>
<span class="p_add">+</span>
<span class="p_add">+	tg = (read_cpuid(ID_AA64MMFR0_EL1) &gt;&gt; ID_AA64MMFR0_TGRAN_SHIFT) &amp; 0xf;</span>
<span class="p_add">+	if (tg != ID_AA64MMFR0_TGRAN_SUPPORTED) {</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_ARM64_64K_PAGES))</span>
<span class="p_add">+			pr_efi_err(sys_table_arg, &quot;This 64 KB granular kernel is not supported by your CPU\n&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pr_efi_err(sys_table_arg, &quot;This 16 KB granular kernel is not supported by your CPU\n&quot;);</span>
<span class="p_add">+		return EFI_UNSUPPORTED;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return EFI_SUCCESS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+efi_status_t handle_kernel_image(efi_system_table_t *sys_table_arg,</span>
<span class="p_add">+				 unsigned long *image_addr,</span>
<span class="p_add">+				 unsigned long *image_size,</span>
<span class="p_add">+				 unsigned long *reserve_addr,</span>
<span class="p_add">+				 unsigned long *reserve_size,</span>
<span class="p_add">+				 unsigned long dram_base,</span>
<span class="p_add">+				 efi_loaded_image_t *image)</span>
 {
 	efi_status_t status;
 	unsigned long kernel_size, kernel_memsize = 0;
<span class="p_header">diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_header">index 6b6548fda089..981c6035ce09 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_header">+++ b/drivers/firmware/efi/libstub/efistub.h</span>
<span class="p_chunk">@@ -5,6 +5,16 @@</span> <span class="p_context"></span>
 /* error code which can&#39;t be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * __init annotations should not be used in the EFI stub, since the code is</span>
<span class="p_add">+ * either included in the decompressor (x86, ARM) where they have no effect,</span>
<span class="p_add">+ * or the whole stub is __init annotated at the section level (arm64), by</span>
<span class="p_add">+ * renaming the sections, in which case the __init annotation will be</span>
<span class="p_add">+ * redundant, and will result in section names like .init.init.text, and our</span>
<span class="p_add">+ * linker script does not expect that.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#undef __init</span>
<span class="p_add">+</span>
 void efi_char16_printk(efi_system_table_t *, efi_char16_t *);
 
 efi_status_t efi_open_volume(efi_system_table_t *sys_table_arg, void *__image,
<span class="p_chunk">@@ -43,4 +53,6 @@</span> <span class="p_context"> void efi_get_virtmap(efi_memory_desc_t *memory_map, unsigned long map_size,</span>
 		     unsigned long desc_size, efi_memory_desc_t *runtime_map,
 		     int *count);
 
<span class="p_add">+efi_status_t check_platform_features(efi_system_table_t *sys_table_arg);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-wrappers.c b/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_header">index 228bbf910461..de6953039af6 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-wrappers.c</span>
<span class="p_chunk">@@ -61,63 +61,23 @@</span> <span class="p_context"></span>
  */
 static DEFINE_SPINLOCK(efi_runtime_lock);
 
<span class="p_del">-/*</span>
<span class="p_del">- * Some runtime services calls can be reentrant under NMI, even if the table</span>
<span class="p_del">- * above says they are not. (source: UEFI Specification v2.4A)</span>
<span class="p_del">- *</span>
<span class="p_del">- * Table 32. Functions that may be called after Machine Check, INIT and NMI</span>
<span class="p_del">- * +----------------------------+------------------------------------------+</span>
<span class="p_del">- * | Function			| Called after Machine Check, INIT and NMI |</span>
<span class="p_del">- * +----------------------------+------------------------------------------+</span>
<span class="p_del">- * | GetTime()			| Yes, even if previously busy.		   |</span>
<span class="p_del">- * | GetVariable()		| Yes, even if previously busy		   |</span>
<span class="p_del">- * | GetNextVariableName()	| Yes, even if previously busy		   |</span>
<span class="p_del">- * | QueryVariableInfo()	| Yes, even if previously busy		   |</span>
<span class="p_del">- * | SetVariable()		| Yes, even if previously busy		   |</span>
<span class="p_del">- * | UpdateCapsule()		| Yes, even if previously busy		   |</span>
<span class="p_del">- * | QueryCapsuleCapabilities()	| Yes, even if previously busy		   |</span>
<span class="p_del">- * | ResetSystem()		| Yes, even if previously busy		   |</span>
<span class="p_del">- * +----------------------------+------------------------------------------+</span>
<span class="p_del">- *</span>
<span class="p_del">- * In order to prevent deadlocks under NMI, the wrappers for these functions</span>
<span class="p_del">- * may only grab the efi_runtime_lock or rtc_lock spinlocks if !efi_in_nmi().</span>
<span class="p_del">- * However, not all of the services listed are reachable through NMI code paths,</span>
<span class="p_del">- * so the the special handling as suggested by the UEFI spec is only implemented</span>
<span class="p_del">- * for QueryVariableInfo() and SetVariable(), as these can be reached in NMI</span>
<span class="p_del">- * context through efi_pstore_write().</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * As per commit ef68c8f87ed1 (&quot;x86: Serialize EFI time accesses on rtc_lock&quot;),</span>
<span class="p_del">- * the EFI specification requires that callers of the time related runtime</span>
<span class="p_del">- * functions serialize with other CMOS accesses in the kernel, as the EFI time</span>
<span class="p_del">- * functions may choose to also use the legacy CMOS RTC.</span>
<span class="p_del">- */</span>
<span class="p_del">-__weak DEFINE_SPINLOCK(rtc_lock);</span>
<span class="p_del">-</span>
 static efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;rtc_lock, flags);</span>
 	spin_lock(&amp;efi_runtime_lock);
 	status = efi_call_virt(get_time, tm, tc);
 	spin_unlock(&amp;efi_runtime_lock);
<span class="p_del">-	spin_unlock_irqrestore(&amp;rtc_lock, flags);</span>
 	return status;
 }
 
 static efi_status_t virt_efi_set_time(efi_time_t *tm)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;rtc_lock, flags);</span>
 	spin_lock(&amp;efi_runtime_lock);
 	status = efi_call_virt(set_time, tm);
 	spin_unlock(&amp;efi_runtime_lock);
<span class="p_del">-	spin_unlock_irqrestore(&amp;rtc_lock, flags);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -125,27 +85,21 @@</span> <span class="p_context"> static efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,</span>
 					     efi_bool_t *pending,
 					     efi_time_t *tm)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;rtc_lock, flags);</span>
 	spin_lock(&amp;efi_runtime_lock);
 	status = efi_call_virt(get_wakeup_time, enabled, pending, tm);
 	spin_unlock(&amp;efi_runtime_lock);
<span class="p_del">-	spin_unlock_irqrestore(&amp;rtc_lock, flags);</span>
 	return status;
 }
 
 static efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;rtc_lock, flags);</span>
 	spin_lock(&amp;efi_runtime_lock);
 	status = efi_call_virt(set_wakeup_time, enabled, tm);
 	spin_unlock(&amp;efi_runtime_lock);
<span class="p_del">-	spin_unlock_irqrestore(&amp;rtc_lock, flags);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -155,13 +109,12 @@</span> <span class="p_context"> static efi_status_t virt_efi_get_variable(efi_char16_t *name,</span>
 					  unsigned long *data_size,
 					  void *data)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(get_variable, name, vendor, attr, data_size,
 			       data);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -169,12 +122,11 @@</span> <span class="p_context"> static efi_status_t virt_efi_get_next_variable(unsigned long *name_size,</span>
 					       efi_char16_t *name,
 					       efi_guid_t *vendor)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(get_next_variable, name_size, name, vendor);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -184,13 +136,12 @@</span> <span class="p_context"> static efi_status_t virt_efi_set_variable(efi_char16_t *name,</span>
 					  unsigned long data_size,
 					  void *data)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(set_variable, name, vendor, attr, data_size,
 			       data);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -199,15 +150,14 @@</span> <span class="p_context"> virt_efi_set_variable_nonblocking(efi_char16_t *name, efi_guid_t *vendor,</span>
 				  u32 attr, unsigned long data_size,
 				  void *data)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	if (!spin_trylock_irqsave(&amp;efi_runtime_lock, flags))</span>
<span class="p_add">+	if (!spin_trylock(&amp;efi_runtime_lock))</span>
 		return EFI_NOT_READY;
 
 	status = efi_call_virt(set_variable, name, vendor, attr, data_size,
 			       data);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -217,27 +167,45 @@</span> <span class="p_context"> static efi_status_t virt_efi_query_variable_info(u32 attr,</span>
 						 u64 *remaining_space,
 						 u64 *max_variable_size)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
 	if (efi.runtime_version &lt; EFI_2_00_SYSTEM_TABLE_REVISION)
 		return EFI_UNSUPPORTED;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(query_variable_info, attr, storage_space,
 			       remaining_space, max_variable_size);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+virt_efi_query_variable_info_nonblocking(u32 attr,</span>
<span class="p_add">+					 u64 *storage_space,</span>
<span class="p_add">+					 u64 *remaining_space,</span>
<span class="p_add">+					 u64 *max_variable_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	efi_status_t status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi.runtime_version &lt; EFI_2_00_SYSTEM_TABLE_REVISION)</span>
<span class="p_add">+		return EFI_UNSUPPORTED;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!spin_trylock(&amp;efi_runtime_lock))</span>
<span class="p_add">+		return EFI_NOT_READY;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = efi_call_virt(query_variable_info, attr, storage_space,</span>
<span class="p_add">+			       remaining_space, max_variable_size);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
 static efi_status_t virt_efi_get_next_high_mono_count(u32 *count)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(get_next_high_mono_count, count);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -246,26 +214,23 @@</span> <span class="p_context"> static void virt_efi_reset_system(int reset_type,</span>
 				  unsigned long data_size,
 				  efi_char16_t *data)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	__efi_call_virt(reset_system, reset_type, status, data_size, data);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 }
 
 static efi_status_t virt_efi_update_capsule(efi_capsule_header_t **capsules,
 					    unsigned long count,
 					    unsigned long sg_list)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
 	if (efi.runtime_version &lt; EFI_2_00_SYSTEM_TABLE_REVISION)
 		return EFI_UNSUPPORTED;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(update_capsule, capsules, count, sg_list);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -274,16 +239,15 @@</span> <span class="p_context"> static efi_status_t virt_efi_query_capsule_caps(efi_capsule_header_t **capsules,</span>
 						u64 *max_size,
 						int *reset_type)
 {
<span class="p_del">-	unsigned long flags;</span>
 	efi_status_t status;
 
 	if (efi.runtime_version &lt; EFI_2_00_SYSTEM_TABLE_REVISION)
 		return EFI_UNSUPPORTED;
 
<span class="p_del">-	spin_lock_irqsave(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;efi_runtime_lock);</span>
 	status = efi_call_virt(query_capsule_caps, capsules, count, max_size,
 			       reset_type);
<span class="p_del">-	spin_unlock_irqrestore(&amp;efi_runtime_lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;efi_runtime_lock);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -300,6 +264,7 @@</span> <span class="p_context"> void efi_native_runtime_setup(void)</span>
 	efi.get_next_high_mono_count = virt_efi_get_next_high_mono_count;
 	efi.reset_system = virt_efi_reset_system;
 	efi.query_variable_info = virt_efi_query_variable_info;
<span class="p_add">+	efi.query_variable_info_nonblocking = virt_efi_query_variable_info_nonblocking;</span>
 	efi.update_capsule = virt_efi_update_capsule;
 	efi.query_capsule_caps = virt_efi_query_capsule_caps;
 }
<span class="p_header">diff --git a/drivers/firmware/efi/vars.c b/drivers/firmware/efi/vars.c</span>
<span class="p_header">index 7f2ea21c730d..0ac594c0a234 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/vars.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/vars.c</span>
<span class="p_chunk">@@ -300,7 +300,18 @@</span> <span class="p_context"> check_var_size(u32 attributes, unsigned long size)</span>
 	if (!fops-&gt;query_variable_store)
 		return EFI_UNSUPPORTED;
 
<span class="p_del">-	return fops-&gt;query_variable_store(attributes, size);</span>
<span class="p_add">+	return fops-&gt;query_variable_store(attributes, size, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static efi_status_t</span>
<span class="p_add">+check_var_size_nonblocking(u32 attributes, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct efivar_operations *fops = __efivars-&gt;ops;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!fops-&gt;query_variable_store)</span>
<span class="p_add">+		return EFI_UNSUPPORTED;</span>
<span class="p_add">+</span>
<span class="p_add">+	return fops-&gt;query_variable_store(attributes, size, true);</span>
 }
 
 static int efi_status_to_err(efi_status_t status)
<span class="p_chunk">@@ -681,7 +692,8 @@</span> <span class="p_context"> efivar_entry_set_nonblocking(efi_char16_t *name, efi_guid_t vendor,</span>
 	if (!spin_trylock_irqsave(&amp;__efivars-&gt;lock, flags))
 		return -EBUSY;
 
<span class="p_del">-	status = check_var_size(attributes, size + ucs2_strsize(name, 1024));</span>
<span class="p_add">+	status = check_var_size_nonblocking(attributes,</span>
<span class="p_add">+					    size + ucs2_strsize(name, 1024));</span>
 	if (status != EFI_SUCCESS) {
 		spin_unlock_irqrestore(&amp;__efivars-&gt;lock, flags);
 		return -ENOSPC;
<span class="p_header">diff --git a/include/linux/efi.h b/include/linux/efi.h</span>
<span class="p_header">index 47be3ad7d3e5..42be9c92fdf0 100644</span>
<span class="p_header">--- a/include/linux/efi.h</span>
<span class="p_header">+++ b/include/linux/efi.h</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> typedef	struct {</span>
 #define EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	/* write-protect */
 #define EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	/* read-protect */
 #define EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	/* execute-protect */
<span class="p_add">+#define EFI_MEMORY_NV		((u64)0x0000000000008000ULL)	/* non-volatile */</span>
 #define EFI_MEMORY_MORE_RELIABLE \
 				((u64)0x0000000000010000ULL)	/* higher reliability */
 #define EFI_MEMORY_RO		((u64)0x0000000000020000ULL)	/* read-only */
<span class="p_chunk">@@ -507,10 +508,6 @@</span> <span class="p_context"> typedef efi_status_t efi_get_next_variable_t (unsigned long *name_size, efi_char</span>
 typedef efi_status_t efi_set_variable_t (efi_char16_t *name, efi_guid_t *vendor, 
 					 u32 attr, unsigned long data_size,
 					 void *data);
<span class="p_del">-typedef efi_status_t</span>
<span class="p_del">-efi_set_variable_nonblocking_t(efi_char16_t *name, efi_guid_t *vendor,</span>
<span class="p_del">-			       u32 attr, unsigned long data_size, void *data);</span>
<span class="p_del">-</span>
 typedef efi_status_t efi_get_next_high_mono_count_t (u32 *count);
 typedef void efi_reset_system_t (int reset_type, efi_status_t status,
 				 unsigned long data_size, efi_char16_t *data);
<span class="p_chunk">@@ -529,7 +526,9 @@</span> <span class="p_context"> typedef efi_status_t efi_query_capsule_caps_t(efi_capsule_header_t **capsules,</span>
 					      unsigned long count,
 					      u64 *max_size,
 					      int *reset_type);
<span class="p_del">-typedef efi_status_t efi_query_variable_store_t(u32 attributes, unsigned long size);</span>
<span class="p_add">+typedef efi_status_t efi_query_variable_store_t(u32 attributes,</span>
<span class="p_add">+						unsigned long size,</span>
<span class="p_add">+						bool nonblocking);</span>
 
 void efi_native_runtime_setup(void);
 
<span class="p_chunk">@@ -537,67 +536,88 @@</span> <span class="p_context"> void efi_native_runtime_setup(void);</span>
  *  EFI Configuration Table and GUID definitions
  */
 #define NULL_GUID \
<span class="p_del">-    EFI_GUID(  0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 )</span>
<span class="p_add">+	EFI_GUID(0x00000000, 0x0000, 0x0000, \</span>
<span class="p_add">+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)</span>
 
 #define MPS_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0xeb9d2d2f, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )</span>
<span class="p_add">+	EFI_GUID(0xeb9d2d2f, 0x2d88, 0x11d3, \</span>
<span class="p_add">+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)</span>
 
 #define ACPI_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0xeb9d2d30, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )</span>
<span class="p_add">+	EFI_GUID(0xeb9d2d30, 0x2d88, 0x11d3, \</span>
<span class="p_add">+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)</span>
 
 #define ACPI_20_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0x8868e871, 0xe4f1, 0x11d3, 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 )</span>
<span class="p_add">+	EFI_GUID(0x8868e871, 0xe4f1, 0x11d3, \</span>
<span class="p_add">+		 0xbc, 0x22, 0x00, 0x80, 0xc7, 0x3c, 0x88, 0x81)</span>
 
 #define SMBIOS_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )</span>
<span class="p_add">+	EFI_GUID(0xeb9d2d31, 0x2d88, 0x11d3, \</span>
<span class="p_add">+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)</span>
 
 #define SMBIOS3_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0xf2fd1544, 0x9794, 0x4a2c, 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94 )</span>
<span class="p_add">+	EFI_GUID(0xf2fd1544, 0x9794, 0x4a2c, \</span>
<span class="p_add">+		 0x99, 0x2e, 0xe5, 0xbb, 0xcf, 0x20, 0xe3, 0x94)</span>
 
 #define SAL_SYSTEM_TABLE_GUID    \
<span class="p_del">-    EFI_GUID(  0xeb9d2d32, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d )</span>
<span class="p_add">+	EFI_GUID(0xeb9d2d32, 0x2d88, 0x11d3, \</span>
<span class="p_add">+		 0x9a, 0x16, 0x00, 0x90, 0x27, 0x3f, 0xc1, 0x4d)</span>
 
 #define HCDP_TABLE_GUID	\
<span class="p_del">-    EFI_GUID(  0xf951938d, 0x620b, 0x42ef, 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98 )</span>
<span class="p_add">+	EFI_GUID(0xf951938d, 0x620b, 0x42ef, \</span>
<span class="p_add">+		 0x82, 0x79, 0xa8, 0x4b, 0x79, 0x61, 0x78, 0x98)</span>
 
 #define UGA_IO_PROTOCOL_GUID \
<span class="p_del">-    EFI_GUID(  0x61a4d49e, 0x6f68, 0x4f1b, 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0xb, 0x7, 0xa2 )</span>
<span class="p_add">+	EFI_GUID(0x61a4d49e, 0x6f68, 0x4f1b, \</span>
<span class="p_add">+		 0xb9, 0x22, 0xa8, 0x6e, 0xed, 0x0b, 0x07, 0xa2)</span>
 
 #define EFI_GLOBAL_VARIABLE_GUID \
<span class="p_del">-    EFI_GUID(  0x8be4df61, 0x93ca, 0x11d2, 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c )</span>
<span class="p_add">+	EFI_GUID(0x8be4df61, 0x93ca, 0x11d2, \</span>
<span class="p_add">+		 0xaa, 0x0d, 0x00, 0xe0, 0x98, 0x03, 0x2b, 0x8c)</span>
 
 #define UV_SYSTEM_TABLE_GUID \
<span class="p_del">-    EFI_GUID(  0x3b13a7d4, 0x633e, 0x11dd, 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93 )</span>
<span class="p_add">+	EFI_GUID(0x3b13a7d4, 0x633e, 0x11dd, \</span>
<span class="p_add">+		 0x93, 0xec, 0xda, 0x25, 0x56, 0xd8, 0x95, 0x93)</span>
 
 #define LINUX_EFI_CRASH_GUID \
<span class="p_del">-    EFI_GUID(  0xcfc8fc79, 0xbe2e, 0x4ddc, 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0 )</span>
<span class="p_add">+	EFI_GUID(0xcfc8fc79, 0xbe2e, 0x4ddc, \</span>
<span class="p_add">+		 0x97, 0xf0, 0x9f, 0x98, 0xbf, 0xe2, 0x98, 0xa0)</span>
 
 #define LOADED_IMAGE_PROTOCOL_GUID \
<span class="p_del">-    EFI_GUID(  0x5b1b31a1, 0x9562, 0x11d2, 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )</span>
<span class="p_add">+	EFI_GUID(0x5b1b31a1, 0x9562, 0x11d2, \</span>
<span class="p_add">+		 0x8e, 0x3f, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)</span>
 
 #define EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID \
<span class="p_del">-    EFI_GUID(  0x9042a9de, 0x23dc, 0x4a38, 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a )</span>
<span class="p_add">+	EFI_GUID(0x9042a9de, 0x23dc, 0x4a38, \</span>
<span class="p_add">+		 0x96, 0xfb, 0x7a, 0xde, 0xd0, 0x80, 0x51, 0x6a)</span>
 
 #define EFI_UGA_PROTOCOL_GUID \
<span class="p_del">-    EFI_GUID(  0x982c298b, 0xf4fa, 0x41cb, 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39 )</span>
<span class="p_add">+	EFI_GUID(0x982c298b, 0xf4fa, 0x41cb, \</span>
<span class="p_add">+		 0xb8, 0x38, 0x77, 0xaa, 0x68, 0x8f, 0xb8, 0x39)</span>
 
 #define EFI_PCI_IO_PROTOCOL_GUID \
<span class="p_del">-    EFI_GUID(  0x4cf5b200, 0x68b8, 0x4ca5, 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x2, 0x9a )</span>
<span class="p_add">+	EFI_GUID(0x4cf5b200, 0x68b8, 0x4ca5, \</span>
<span class="p_add">+		 0x9e, 0xec, 0xb2, 0x3e, 0x3f, 0x50, 0x02, 0x9a)</span>
 
 #define EFI_FILE_INFO_ID \
<span class="p_del">-    EFI_GUID(  0x9576e92, 0x6d3f, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )</span>
<span class="p_add">+	EFI_GUID(0x9576e92, 0x6d3f, 0x11d2, \</span>
<span class="p_add">+		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)</span>
 
 #define EFI_SYSTEM_RESOURCE_TABLE_GUID \
<span class="p_del">-    EFI_GUID(  0xb122a263, 0x3661, 0x4f68, 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80 )</span>
<span class="p_add">+	EFI_GUID(0xb122a263, 0x3661, 0x4f68, \</span>
<span class="p_add">+		 0x99, 0x29, 0x78, 0xf8, 0xb0, 0xd6, 0x21, 0x80)</span>
 
 #define EFI_FILE_SYSTEM_GUID \
<span class="p_del">-    EFI_GUID(  0x964e5b22, 0x6459, 0x11d2, 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b )</span>
<span class="p_add">+	EFI_GUID(0x964e5b22, 0x6459, 0x11d2, \</span>
<span class="p_add">+		 0x8e, 0x39, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)</span>
 
 #define DEVICE_TREE_GUID \
<span class="p_del">-    EFI_GUID(  0xb1b621d5, 0xf19c, 0x41a5, 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0 )</span>
<span class="p_add">+	EFI_GUID(0xb1b621d5, 0xf19c, 0x41a5, \</span>
<span class="p_add">+		 0x83, 0x0b, 0xd9, 0x15, 0x2c, 0x69, 0xaa, 0xe0)</span>
 
 #define EFI_PROPERTIES_TABLE_GUID \
<span class="p_del">-    EFI_GUID(  0x880aaca3, 0x4adc, 0x4a04, 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5 )</span>
<span class="p_add">+	EFI_GUID(0x880aaca3, 0x4adc, 0x4a04, \</span>
<span class="p_add">+		 0x90, 0x79, 0xb7, 0x47, 0x34, 0x08, 0x25, 0xe5)</span>
 
 typedef struct {
 	efi_guid_t guid;
<span class="p_chunk">@@ -851,8 +871,9 @@</span> <span class="p_context"> extern struct efi {</span>
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
<span class="p_del">-	efi_set_variable_nonblocking_t *set_variable_nonblocking;</span>
<span class="p_add">+	efi_set_variable_t *set_variable_nonblocking;</span>
 	efi_query_variable_info_t *query_variable_info;
<span class="p_add">+	efi_query_variable_info_t *query_variable_info_nonblocking;</span>
 	efi_update_capsule_t *update_capsule;
 	efi_query_capsule_caps_t *query_capsule_caps;
 	efi_get_next_high_mono_count_t *get_next_high_mono_count;
<span class="p_chunk">@@ -884,13 +905,17 @@</span> <span class="p_context"> extern void efi_enter_virtual_mode (void);	/* switch EFI to virtual mode, if pos</span>
 #ifdef CONFIG_X86
 extern void efi_late_init(void);
 extern void efi_free_boot_services(void);
<span class="p_del">-extern efi_status_t efi_query_variable_store(u32 attributes, unsigned long size);</span>
<span class="p_add">+extern efi_status_t efi_query_variable_store(u32 attributes,</span>
<span class="p_add">+					     unsigned long size,</span>
<span class="p_add">+					     bool nonblocking);</span>
 extern void efi_find_mirror(void);
 #else
 static inline void efi_late_init(void) {}
 static inline void efi_free_boot_services(void) {}
 
<span class="p_del">-static inline efi_status_t efi_query_variable_store(u32 attributes, unsigned long size)</span>
<span class="p_add">+static inline efi_status_t efi_query_variable_store(u32 attributes,</span>
<span class="p_add">+						    unsigned long size,</span>
<span class="p_add">+						    bool nonblocking)</span>
 {
 	return EFI_SUCCESS;
 }
<span class="p_chunk">@@ -1091,7 +1116,7 @@</span> <span class="p_context"> struct efivar_operations {</span>
 	efi_get_variable_t *get_variable;
 	efi_get_next_variable_t *get_next_variable;
 	efi_set_variable_t *set_variable;
<span class="p_del">-	efi_set_variable_nonblocking_t *set_variable_nonblocking;</span>
<span class="p_add">+	efi_set_variable_t *set_variable_nonblocking;</span>
 	efi_query_variable_store_t *query_variable_store;
 };
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



