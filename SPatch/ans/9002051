
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[Question] Missing data after DMA read transfer - mm issue with transparent huge page? - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [Question] Missing data after DMA read transfer - mm issue with transparent huge page?</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 3, 2016, 10:11 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160503101153.GA7241@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9002051/mbox/"
   >mbox</a>
|
   <a href="/patch/9002051/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9002051/">/patch/9002051/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id DDBD59F372
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 May 2016 10:14:51 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id BE877202EB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 May 2016 10:14:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 805A2201F2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 May 2016 10:14:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933103AbcECKOl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 3 May 2016 06:14:41 -0400
Received: from mail-qg0-f46.google.com ([209.85.192.46]:35050 &quot;EHLO
	mail-qg0-f46.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932758AbcECKMF (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 3 May 2016 06:12:05 -0400
Received: by mail-qg0-f46.google.com with SMTP id f74so5995870qge.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 03 May 2016 03:12:04 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=date:from:to:cc:subject:message-id:references:mime-version
	:content-disposition:content-transfer-encoding:in-reply-to
	:user-agent; bh=AWigSy33z6J15DrYfcP2q+9i9M1XC46vl5WU9QZGfVE=;
	b=vaGoZcdEI5Z7i4M4fKQM+D93Okxziqef3M4WvWNBXvb6slV/s3imZAP2JrYuPm82tU
	Sf8sGzrSVCjlUBovQ+tF5Qnq9kLdHmvqXwb3LO3tSdSB0OV7HsKlCugS/maRhyDg0t1S
	STv/eoP/NTbNnrglyZu8MbGWhAZkgijm0LmOQ7Qe9t8a4elmYhazMNoZkTeTbxPjM85U
	6/xMkllweDh788NkyOsEYEJClKzwdflPJM3v7agK8RqMP/JkxLOALJAEfZ4kYbCbCtC/
	vP3yqgF7LLnEcOjw9YDRnbYeyI3FhKQ9zqi7wa2QD0w7LNZuGE0Grzg26SSKltH4K8Wg
	3sdw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:date:from:to:cc:subject:message-id:references
	:mime-version:content-disposition:content-transfer-encoding
	:in-reply-to:user-agent;
	bh=AWigSy33z6J15DrYfcP2q+9i9M1XC46vl5WU9QZGfVE=;
	b=LWTDG0n61kKFN0tXQT1cnmFWLiUXrhIavFnxTE3+Wi8ev9+87g3T7FEq5dCxl2UI9g
	zl1E9IUfkYqs1GvZe6VkA7kX26KDC8VLMcszm+jTp6DCOr8wLTPW2BDZzP/tE3oUDxtB
	6y0pGlbWVx01/ObkQ37XwF05vjjDiK/25r45JyDvx0WVxfMoxApgNpaZL8p0Kt8gzQYe
	VyiZAwMxmXcE9rxobPMNisIgBs7quqMCn5FkKWTXqTFGT9YY+YYWRpL7RbozjccIadJf
	X54ZBs8dV6VQQSwbZ1r01uuEf5XG0fPSqivEQkQQzPiLNBfHSq7PlGuCntj14Ev5AalR
	OEFw==
X-Gm-Message-State: AOPr4FXogeTc3zbMPa7C5rxm57jcUxJh2eGyOFy73MqU8zMwaMNPl+UnJXpyC8inwQNGdQ==
X-Received: by 10.140.201.143 with SMTP id w137mr1445134qha.66.1462270324268;
	Tue, 03 May 2016 03:12:04 -0700 (PDT)
Received: from gmail.com (pha75-18-88-178-180-173.fbx.proxad.net.
	[88.178.180.173])
	by smtp.gmail.com with ESMTPSA id 71sm891279qgh.9.2016.05.03.03.12.02
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 03 May 2016 03:12:03 -0700 (PDT)
Date: Tue, 3 May 2016 12:11:54 +0200
From: Jerome Glisse &lt;j.glisse@gmail.com&gt;
To: Hugh Dickins &lt;hughd@google.com&gt;
Cc: Nicolas Morey Chaisemartin &lt;devel@morey-chaisemartin.com&gt;,
	Mel Gorman &lt;mgorman@techsingularity.net&gt;,
	Andrea Arcangeli &lt;aarcange@redhat.com&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill@shutemov.name&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	Alex Williamson &lt;alex.williamson@redhat.com&gt;,
	One Thousand Gnomes &lt;gnomes@lxorguk.ukuu.org.uk&gt;,
	linux-kernel@vger.kernel.org, linux-mm@kvack.org
Subject: Re: [Question] Missing data after DMA read transfer - mm issue with
	transparent huge page?
Message-ID: &lt;20160503101153.GA7241@gmail.com&gt;
References: &lt;15edf085-c21b-aa1c-9f1f-057d17b8a1a3@morey-chaisemartin.com&gt;
	&lt;alpine.LSU.2.11.1605022020560.5004@eggly.anvils&gt;
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=&quot;G4iJoqBmSsgzjUCe&quot;
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;alpine.LSU.2.11.1605022020560.5004@eggly.anvils&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM, RCVD_IN_DNSWL_HI,
	RP_MATCHES_RCVD, 
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 3, 2016, 10:11 a.m.</div>
<pre class="content">
On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:
<span class="quote">&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Hi everyone,</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This is a repost from a different address as it seems the previous one ended in Gmail junk due to a domain error..</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; linux-kernel is a very high volume list which few are reading:</span>
<span class="quote">&gt; that also will account for your lack of response so far</span>
<span class="quote">&gt; (apart from the indefatigable Alan).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ve added linux-mm, and some people from another thread regarding</span>
<span class="quote">&gt; THP and get_user_pages() pins which has been discussed in recent days.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Make no mistake, the issue you&#39;re raising here is definitely not the</span>
<span class="quote">&gt; same as that one (which is specifically about the new THP refcounting</span>
<span class="quote">&gt; in v4.5+, whereas you&#39;re reporting a problem you&#39;ve seen in both a</span>
<span class="quote">&gt; v3.10-based kernel and in v4.5).  But I think their heads are in</span>
<span class="quote">&gt; gear, much more so than mine, and likely to spot something.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; I added more info found while blindly debugging the issue.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Short version:</span>
<span class="quote">&gt; &gt; I&#39;m having an issue with direct DMA transfer from a device to host memory.</span>
<span class="quote">&gt; &gt; It seems some of the data is not transferring to the appropriate page.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Some more details:</span>
<span class="quote">&gt; &gt; I&#39;m debugging a home made PCI driver for our board (Kalray), attached to a x86_64 host running centos7 (3.10.0-327.el7.x86_64)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In the current case, a userland application transfers back and forth data through read/write operations on a file.</span>
<span class="quote">&gt; &gt; On the kernel side, it triggers DMA transfers through the PCI to/from our board memory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; We followed what pretty much all docs said about direct I/O to user buffers:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 1) get_user_pages() (in the current case, it&#39;s at most 16 pages at once)</span>
<span class="quote">&gt; &gt; 2) convert to a scatterlist</span>
<span class="quote">&gt; &gt; 3) pci_map_sg</span>
<span class="quote">&gt; &gt; 4) eventually coalesce sg (Intel IOMMU is enabled, so it&#39;s usually possible)</span>
<span class="quote">&gt; &gt; 4) A lot of DMA engine handling code, using the dmaengine layer and virt-dma</span>
<span class="quote">&gt; &gt; 5) wait for transfer complete, in the mean time, go back to (1) to schedule more work, if any</span>
<span class="quote">&gt; &gt; 6) pci_unmap_sg</span>
<span class="quote">&gt; &gt; 7) for read (card2host) transfer, set_page_dirty_lock</span>
<span class="quote">&gt; &gt; 8) page_cache_release</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In 99,9999% it works perfectly.</span>
<span class="quote">&gt; &gt; However, I have one userland application where a few pages are not written by a read (card2host) transfer.</span>
<span class="quote">&gt; &gt; The buffer is memset them to a different value so I can check that nothing has overwritten them.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I know (PCI protocol analyser) that the data left our board for the &quot;right&quot; address (the one set in the sg by pci_map_sg).</span>
<span class="quote">&gt; &gt; I tried reading the data between the pci_unmap_sg and the set_page_dirty, using</span>
<span class="quote">&gt; &gt;         uint32_t *addr = page_address(trans-&gt;pages[0]);</span>
<span class="quote">&gt; &gt;         dev_warn(&amp;pdata-&gt;pdev-&gt;dev, &quot;val = %x\n&quot;, *addr);</span>
<span class="quote">&gt; &gt; and it has the expected value.</span>
<span class="quote">&gt; &gt; But if I try to copy_from_user (using the address coming from userland, the one passed to get_user_pages), the data has not been written and I see the memset value.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; New infos:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The issue happens with IOMMU on or off.</span>
<span class="quote">&gt; &gt; I compiled a kernel with DMA_API_DEBUG enabled and got no warnings or errors.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I digged a little bit deeper with my very small understanding of linux mm and I discovered that:</span>
<span class="quote">&gt; &gt;  * we are using transparent huge pages</span>
<span class="quote">&gt; &gt;  * the page &#39;not transferred&#39; are the last few of a huge page</span>
<span class="quote">&gt; &gt; More precisely:</span>
<span class="quote">&gt; &gt; - We have several transfer in flight from the same user buffer</span>
<span class="quote">&gt; &gt; - Each transfer is 16 pages long</span>
<span class="quote">&gt; &gt; - At one point in time, we start transferring from another huge page (transfers are still in flight from the previous one)</span>
<span class="quote">&gt; &gt; - When a transfer from the previous huge page completes, I dumped at the mapcount of the pages from the previous transfers,</span>
<span class="quote">&gt; &gt;   they are all to 0. The pages are still mapped to dma at this point.</span>
<span class="quote">&gt; &gt; - A get_user_page to the address of the completed transfer returns return a different struct page * then the on I had.</span>
<span class="quote">&gt; &gt; But this is before I have unmapped/put_page them back. From my understanding this should not have happened.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I tried the same code with a kernel 4.5 and encountered the same issue</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Disabling transparent huge pages makes the issue disapear</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Thanks in advance</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It does look to me as if pages are being migrated, despite being pinned</span>
<span class="quote">&gt; by get_user_pages(): and that would be wrong.  Originally I intended</span>
<span class="quote">&gt; to suggest that THP is probably merely the cause of compaction, with</span>
<span class="quote">&gt; compaction causing the page migration.  But you posted very interesting</span>
<span class="quote">&gt; details in an earlier mail on 27th April from &lt;nmorey@kalray.eu&gt;:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; I ran some more tests:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; * Test is OK if transparent huge tlb are disabled</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; * For all the page where data are not transfered, and only those pages, a call to get_user_page(user vaddr) just before dma_unmap_sg returns a different page from the original one.</span>
<span class="quote">&gt; &gt; [436477.927279] mppa 0000:03:00.0: org_page= ffffea0009f60080 cur page = ffffea00074e0080</span>
<span class="quote">&gt; &gt; [436477.927298] page:ffffea0009f60080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt; [436477.927314] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt; [436477.927354] page dumped because: org_page</span>
<span class="quote">&gt; &gt; [436477.927369] page:ffffea00074e0080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt; [436477.927382] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt; [436477.927421] page dumped because: cur_page</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I&#39;m not sure what to make of this...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That (on the older kernel I think) seems clearly to show that a THP</span>
<span class="quote">&gt; itself has been migrated: which makes me suspect NUMA migration of</span>
<span class="quote">&gt; mispaced THPs - migrate_misplaced_transhuge_page().  I&#39;d hoped to</span>
<span class="quote">&gt; find something obviously wrong there, but haven&#39;t quite managed</span>
<span class="quote">&gt; to bring my brain fully to bear on it, and hope the others Cc&#39;ed</span>
<span class="quote">&gt; will do so more quickly (or spot the error of your ways instead).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I do find it suspect, how the migrate_page_copy() is done rather</span>
<span class="quote">&gt; early, while the old page is still mapped in the pagetable.  And</span>
<span class="quote">&gt; odd how it inserts the new pmd for a moment, before checking old</span>
<span class="quote">&gt; page_count and backing out.  But I don&#39;t see how either of those</span>
<span class="quote">&gt; would cause the trouble you see, where the migration goes ahead.</span>

So i do not think there is a bug migrate_misplaced_transhuge_page()
but i think something is wrong in it see attached patch. I still
want to convince myself i am not missing anything before posting
that one.


Now about this bug, dumb question but do you do get_user_pages with
write = 1 because if your device is writting to the page then you
must set write to 1.

get_user_pages(vaddr, nrpages, 1, 0|1, pages, NULL|vmas);


Cheers,
Jérôme
From 9ded2a5da75a5e736fb36a2c4e2511d9516ecc37 Mon Sep 17 00:00:00 2001
<span class="from">From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Glisse?= &lt;jglisse@redhat.com&gt;</span>
Date: Tue, 3 May 2016 11:53:24 +0200
Subject: [PATCH] mm/numa/thp: fix assumptions of
 migrate_misplaced_transhuge_page()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Fix assumptions in migrate_misplaced_transhuge_page() which is only
call by do_huge_pmd_numa_page() itself only call by __handle_mm_fault()
for pmd with PROT_NONE. This means that if the pmd stays the same
then there can be no concurrent get_user_pages / get_user_pages_fast
(GUP/GUP_fast). More over because migrate_misplaced_transhuge_page()
only do something is page is map once then there can be no GUP from
a different process. Finaly, holding the pmd lock assure us that no
other part of the kernel will take an extre reference on the page.

In the end this means that the failure code path should never be
taken unless something is horribly wrong, so convert it to BUG_ON().
<span class="signed-off-by">
Signed-off-by: Jérôme Glisse &lt;jglisse@redhat.com&gt;</span>
Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com
Cc: Mel Gorman &lt;mgorman@suse.de&gt;
Cc: Hugh Dickins &lt;hughd@google.com&gt;
Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;
---
 mm/migrate.c | 31 +++++++++++++++++++++----------
 1 file changed, 21 insertions(+), 10 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - May 3, 2016, 11:03 a.m.</div>
<pre class="content">
On Tue, May 03, 2016 at 12:11:54PM +0200, Jerome Glisse wrote:
<span class="quote">&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Hi everyone,</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; This is a repost from a different address as it seems the previous one ended in Gmail junk due to a domain error..</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; linux-kernel is a very high volume list which few are reading:</span>
<span class="quote">&gt; &gt; that also will account for your lack of response so far</span>
<span class="quote">&gt; &gt; (apart from the indefatigable Alan).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I&#39;ve added linux-mm, and some people from another thread regarding</span>
<span class="quote">&gt; &gt; THP and get_user_pages() pins which has been discussed in recent days.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Make no mistake, the issue you&#39;re raising here is definitely not the</span>
<span class="quote">&gt; &gt; same as that one (which is specifically about the new THP refcounting</span>
<span class="quote">&gt; &gt; in v4.5+, whereas you&#39;re reporting a problem you&#39;ve seen in both a</span>
<span class="quote">&gt; &gt; v3.10-based kernel and in v4.5).  But I think their heads are in</span>
<span class="quote">&gt; &gt; gear, much more so than mine, and likely to spot something.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I added more info found while blindly debugging the issue.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Short version:</span>
<span class="quote">&gt; &gt; &gt; I&#39;m having an issue with direct DMA transfer from a device to host memory.</span>
<span class="quote">&gt; &gt; &gt; It seems some of the data is not transferring to the appropriate page.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Some more details:</span>
<span class="quote">&gt; &gt; &gt; I&#39;m debugging a home made PCI driver for our board (Kalray), attached to a x86_64 host running centos7 (3.10.0-327.el7.x86_64)</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; In the current case, a userland application transfers back and forth data through read/write operations on a file.</span>
<span class="quote">&gt; &gt; &gt; On the kernel side, it triggers DMA transfers through the PCI to/from our board memory.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; We followed what pretty much all docs said about direct I/O to user buffers:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; 1) get_user_pages() (in the current case, it&#39;s at most 16 pages at once)</span>
<span class="quote">&gt; &gt; &gt; 2) convert to a scatterlist</span>
<span class="quote">&gt; &gt; &gt; 3) pci_map_sg</span>
<span class="quote">&gt; &gt; &gt; 4) eventually coalesce sg (Intel IOMMU is enabled, so it&#39;s usually possible)</span>
<span class="quote">&gt; &gt; &gt; 4) A lot of DMA engine handling code, using the dmaengine layer and virt-dma</span>
<span class="quote">&gt; &gt; &gt; 5) wait for transfer complete, in the mean time, go back to (1) to schedule more work, if any</span>
<span class="quote">&gt; &gt; &gt; 6) pci_unmap_sg</span>
<span class="quote">&gt; &gt; &gt; 7) for read (card2host) transfer, set_page_dirty_lock</span>
<span class="quote">&gt; &gt; &gt; 8) page_cache_release</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; In 99,9999% it works perfectly.</span>
<span class="quote">&gt; &gt; &gt; However, I have one userland application where a few pages are not written by a read (card2host) transfer.</span>
<span class="quote">&gt; &gt; &gt; The buffer is memset them to a different value so I can check that nothing has overwritten them.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I know (PCI protocol analyser) that the data left our board for the &quot;right&quot; address (the one set in the sg by pci_map_sg).</span>
<span class="quote">&gt; &gt; &gt; I tried reading the data between the pci_unmap_sg and the set_page_dirty, using</span>
<span class="quote">&gt; &gt; &gt;         uint32_t *addr = page_address(trans-&gt;pages[0]);</span>
<span class="quote">&gt; &gt; &gt;         dev_warn(&amp;pdata-&gt;pdev-&gt;dev, &quot;val = %x\n&quot;, *addr);</span>
<span class="quote">&gt; &gt; &gt; and it has the expected value.</span>
<span class="quote">&gt; &gt; &gt; But if I try to copy_from_user (using the address coming from userland, the one passed to get_user_pages), the data has not been written and I see the memset value.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; New infos:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The issue happens with IOMMU on or off.</span>
<span class="quote">&gt; &gt; &gt; I compiled a kernel with DMA_API_DEBUG enabled and got no warnings or errors.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I digged a little bit deeper with my very small understanding of linux mm and I discovered that:</span>
<span class="quote">&gt; &gt; &gt;  * we are using transparent huge pages</span>
<span class="quote">&gt; &gt; &gt;  * the page &#39;not transferred&#39; are the last few of a huge page</span>
<span class="quote">&gt; &gt; &gt; More precisely:</span>
<span class="quote">&gt; &gt; &gt; - We have several transfer in flight from the same user buffer</span>
<span class="quote">&gt; &gt; &gt; - Each transfer is 16 pages long</span>
<span class="quote">&gt; &gt; &gt; - At one point in time, we start transferring from another huge page (transfers are still in flight from the previous one)</span>
<span class="quote">&gt; &gt; &gt; - When a transfer from the previous huge page completes, I dumped at the mapcount of the pages from the previous transfers,</span>
<span class="quote">&gt; &gt; &gt;   they are all to 0. The pages are still mapped to dma at this point.</span>
<span class="quote">&gt; &gt; &gt; - A get_user_page to the address of the completed transfer returns return a different struct page * then the on I had.</span>
<span class="quote">&gt; &gt; &gt; But this is before I have unmapped/put_page them back. From my understanding this should not have happened.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I tried the same code with a kernel 4.5 and encountered the same issue</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Disabling transparent huge pages makes the issue disapear</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Thanks in advance</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; It does look to me as if pages are being migrated, despite being pinned</span>
<span class="quote">&gt; &gt; by get_user_pages(): and that would be wrong.  Originally I intended</span>
<span class="quote">&gt; &gt; to suggest that THP is probably merely the cause of compaction, with</span>
<span class="quote">&gt; &gt; compaction causing the page migration.  But you posted very interesting</span>
<span class="quote">&gt; &gt; details in an earlier mail on 27th April from &lt;nmorey@kalray.eu&gt;:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I ran some more tests:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; * Test is OK if transparent huge tlb are disabled</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; * For all the page where data are not transfered, and only those pages, a call to get_user_page(user vaddr) just before dma_unmap_sg returns a different page from the original one.</span>
<span class="quote">&gt; &gt; &gt; [436477.927279] mppa 0000:03:00.0: org_page= ffffea0009f60080 cur page = ffffea00074e0080</span>
<span class="quote">&gt; &gt; &gt; [436477.927298] page:ffffea0009f60080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt; &gt; [436477.927314] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt; &gt; [436477.927354] page dumped because: org_page</span>
<span class="quote">&gt; &gt; &gt; [436477.927369] page:ffffea00074e0080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt; &gt; [436477.927382] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt; &gt; [436477.927421] page dumped because: cur_page</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I&#39;m not sure what to make of this...</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; That (on the older kernel I think) seems clearly to show that a THP</span>
<span class="quote">&gt; &gt; itself has been migrated: which makes me suspect NUMA migration of</span>
<span class="quote">&gt; &gt; mispaced THPs - migrate_misplaced_transhuge_page().  I&#39;d hoped to</span>
<span class="quote">&gt; &gt; find something obviously wrong there, but haven&#39;t quite managed</span>
<span class="quote">&gt; &gt; to bring my brain fully to bear on it, and hope the others Cc&#39;ed</span>
<span class="quote">&gt; &gt; will do so more quickly (or spot the error of your ways instead).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I do find it suspect, how the migrate_page_copy() is done rather</span>
<span class="quote">&gt; &gt; early, while the old page is still mapped in the pagetable.  And</span>
<span class="quote">&gt; &gt; odd how it inserts the new pmd for a moment, before checking old</span>
<span class="quote">&gt; &gt; page_count and backing out.  But I don&#39;t see how either of those</span>
<span class="quote">&gt; &gt; would cause the trouble you see, where the migration goes ahead.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So i do not think there is a bug migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; but i think something is wrong in it see attached patch. I still</span>
<span class="quote">&gt; want to convince myself i am not missing anything before posting</span>
<span class="quote">&gt; that one.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Now about this bug, dumb question but do you do get_user_pages with</span>
<span class="quote">&gt; write = 1 because if your device is writting to the page then you</span>
<span class="quote">&gt; must set write to 1.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; get_user_pages(vaddr, nrpages, 1, 0|1, pages, NULL|vmas);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cheers,</span>
<span class="quote">&gt; Jérôme</span>
<span class="quote">
&gt; From 9ded2a5da75a5e736fb36a2c4e2511d9516ecc37 Mon Sep 17 00:00:00 2001</span>
<span class="quote">&gt; From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Glisse?= &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; Date: Tue, 3 May 2016 11:53:24 +0200</span>
<span class="quote">&gt; Subject: [PATCH] mm/numa/thp: fix assumptions of</span>
<span class="quote">&gt;  migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; MIME-Version: 1.0</span>
<span class="quote">&gt; Content-Type: text/plain; charset=UTF-8</span>
<span class="quote">&gt; Content-Transfer-Encoding: 8bit</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fix assumptions in migrate_misplaced_transhuge_page() which is only</span>
<span class="quote">&gt; call by do_huge_pmd_numa_page() itself only call by __handle_mm_fault()</span>
<span class="quote">&gt; for pmd with PROT_NONE. This means that if the pmd stays the same</span>
<span class="quote">&gt; then there can be no concurrent get_user_pages / get_user_pages_fast</span>
<span class="quote">&gt; (GUP/GUP_fast). More over because migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; only do something is page is map once then there can be no GUP from</span>
<span class="quote">&gt; a different process. Finaly, holding the pmd lock assure us that no</span>
<span class="quote">&gt; other part of the kernel will take an extre reference on the page.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In the end this means that the failure code path should never be</span>
<span class="quote">&gt; taken unless something is horribly wrong, so convert it to BUG_ON().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Jérôme Glisse &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com</span>
<span class="quote">&gt; Cc: Mel Gorman &lt;mgorman@suse.de&gt;</span>
<span class="quote">&gt; Cc: Hugh Dickins &lt;hughd@google.com&gt;</span>
<span class="quote">&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>

The logic looks valid to me:
<span class="acked-by">
Acked-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;  mm/migrate.c | 31 +++++++++++++++++++++----------</span>
<span class="quote">&gt;  1 file changed, 21 insertions(+), 10 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt; index 6c822a7..6315aac 100644</span>
<span class="quote">&gt; --- a/mm/migrate.c</span>
<span class="quote">&gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt; @@ -1757,6 +1757,14 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt;  	pmd_t orig_entry;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; +	 * What we do here is only valid if pmd_protnone(entry) is true and it</span>
<span class="quote">&gt; +	 * is map in only one vma numamigrate_isolate_page() takes care of that</span>
<span class="quote">&gt; +	 * check.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (!pmd_protnone(entry))</span>
<span class="quote">&gt; +		goto out_unlock;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt;  	 * Rate-limit the amount of data that is being migrated to a node.</span>
<span class="quote">&gt;  	 * Optimal placement is no good if the memory bus is saturated and</span>
<span class="quote">&gt;  	 * all the time is being spent migrating!</span>
<span class="quote">&gt; @@ -1797,7 +1805,6 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt;  	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt;  	ptl = pmd_lock(mm, pmd);</span>
<span class="quote">&gt;  	if (unlikely(!pmd_same(*pmd, entry) || page_count(page) != 2)) {</span>
<span class="quote">&gt; -fail_putback:</span>
<span class="quote">&gt;  		spin_unlock(ptl);</span>
<span class="quote">&gt;  		mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -1819,7 +1826,12 @@ fail_putback:</span>
<span class="quote">&gt;  		goto out_unlock;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	orig_entry = *pmd;</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * We are holding the lock so no one can set a new pmd and original pmd</span>
<span class="quote">&gt; +	 * is PROT_NONE thus no one can get_user_pages or get_user_pages_fast</span>
<span class="quote">&gt; +	 * (GUP or GUP_fast) from this point on we can not fail.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	orig_entry = entry;</span>
<span class="quote">&gt;  	entry = mk_pmd(new_page, vma-&gt;vm_page_prot);</span>
<span class="quote">&gt;  	entry = pmd_mkhuge(entry);</span>
<span class="quote">&gt;  	entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);</span>
<span class="quote">&gt; @@ -1837,14 +1849,13 @@ fail_putback:</span>
<span class="quote">&gt;  	set_pmd_at(mm, mmun_start, pmd, entry);</span>
<span class="quote">&gt;  	update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	if (page_count(page) != 2) {</span>
<span class="quote">&gt; -		set_pmd_at(mm, mmun_start, pmd, orig_entry);</span>
<span class="quote">&gt; -		flush_pmd_tlb_range(vma, mmun_start, mmun_end);</span>
<span class="quote">&gt; -		mmu_notifier_invalidate_range(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt; -		update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt; -		page_remove_rmap(new_page, true);</span>
<span class="quote">&gt; -		goto fail_putback;</span>
<span class="quote">&gt; -	}</span>
<span class="quote">&gt; +	/* As said above no one can get reference on the old page nor through</span>
<span class="quote">&gt; +	 * get_user_pages or get_user_pages_fast (GUP/GUP_fast) or through</span>
<span class="quote">&gt; +	 * any other means. To get reference on huge page you need to hold</span>
<span class="quote">&gt; +	 * pmd_lock and we are already holding that lock here and the page</span>
<span class="quote">&gt; +	 * is only mapped once.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	BUG_ON(page_count(page) != 2);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	mlock_migrate_page(new_page, page);</span>
<span class="quote">&gt;  	page_remove_rmap(page, true);</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.1.0</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 10, 2016, 10:01 a.m.</div>
<pre class="content">
On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:
<span class="quote">&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Hi everyone,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; This is a repost from a different address as it seems the previous one ended in Gmail junk due to a domain error..</span>
<span class="quote">&gt; &gt;&gt; linux-kernel is a very high volume list which few are reading:</span>
<span class="quote">&gt; &gt;&gt; that also will account for your lack of response so far</span>
<span class="quote">&gt; &gt;&gt; (apart from the indefatigable Alan).</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I&#39;ve added linux-mm, and some people from another thread regarding</span>
<span class="quote">&gt; &gt;&gt; THP and get_user_pages() pins which has been discussed in recent days.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Make no mistake, the issue you&#39;re raising here is definitely not the</span>
<span class="quote">&gt; &gt;&gt; same as that one (which is specifically about the new THP refcounting</span>
<span class="quote">&gt; &gt;&gt; in v4.5+, whereas you&#39;re reporting a problem you&#39;ve seen in both a</span>
<span class="quote">&gt; &gt;&gt; v3.10-based kernel and in v4.5).  But I think their heads are in</span>
<span class="quote">&gt; &gt;&gt; gear, much more so than mine, and likely to spot something.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I added more info found while blindly debugging the issue.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Short version:</span>
<span class="quote">&gt; &gt;&gt;&gt; I&#39;m having an issue with direct DMA transfer from a device to host memory.</span>
<span class="quote">&gt; &gt;&gt;&gt; It seems some of the data is not transferring to the appropriate page.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Some more details:</span>
<span class="quote">&gt; &gt;&gt;&gt; I&#39;m debugging a home made PCI driver for our board (Kalray), attached to a x86_64 host running centos7 (3.10.0-327.el7.x86_64)</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; In the current case, a userland application transfers back and forth data through read/write operations on a file.</span>
<span class="quote">&gt; &gt;&gt;&gt; On the kernel side, it triggers DMA transfers through the PCI to/from our board memory.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; We followed what pretty much all docs said about direct I/O to user buffers:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; 1) get_user_pages() (in the current case, it&#39;s at most 16 pages at once)</span>
<span class="quote">&gt; &gt;&gt;&gt; 2) convert to a scatterlist</span>
<span class="quote">&gt; &gt;&gt;&gt; 3) pci_map_sg</span>
<span class="quote">&gt; &gt;&gt;&gt; 4) eventually coalesce sg (Intel IOMMU is enabled, so it&#39;s usually possible)</span>
<span class="quote">&gt; &gt;&gt;&gt; 4) A lot of DMA engine handling code, using the dmaengine layer and virt-dma</span>
<span class="quote">&gt; &gt;&gt;&gt; 5) wait for transfer complete, in the mean time, go back to (1) to schedule more work, if any</span>
<span class="quote">&gt; &gt;&gt;&gt; 6) pci_unmap_sg</span>
<span class="quote">&gt; &gt;&gt;&gt; 7) for read (card2host) transfer, set_page_dirty_lock</span>
<span class="quote">&gt; &gt;&gt;&gt; 8) page_cache_release</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; In 99,9999% it works perfectly.</span>
<span class="quote">&gt; &gt;&gt;&gt; However, I have one userland application where a few pages are not written by a read (card2host) transfer.</span>
<span class="quote">&gt; &gt;&gt;&gt; The buffer is memset them to a different value so I can check that nothing has overwritten them.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I know (PCI protocol analyser) that the data left our board for the &quot;right&quot; address (the one set in the sg by pci_map_sg).</span>
<span class="quote">&gt; &gt;&gt;&gt; I tried reading the data between the pci_unmap_sg and the set_page_dirty, using</span>
<span class="quote">&gt; &gt;&gt;&gt;         uint32_t *addr = page_address(trans-&gt;pages[0]);</span>
<span class="quote">&gt; &gt;&gt;&gt;         dev_warn(&amp;pdata-&gt;pdev-&gt;dev, &quot;val = %x\n&quot;, *addr);</span>
<span class="quote">&gt; &gt;&gt;&gt; and it has the expected value.</span>
<span class="quote">&gt; &gt;&gt;&gt; But if I try to copy_from_user (using the address coming from userland, the one passed to get_user_pages), the data has not been written and I see the memset value.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; New infos:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; The issue happens with IOMMU on or off.</span>
<span class="quote">&gt; &gt;&gt;&gt; I compiled a kernel with DMA_API_DEBUG enabled and got no warnings or errors.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I digged a little bit deeper with my very small understanding of linux mm and I discovered that:</span>
<span class="quote">&gt; &gt;&gt;&gt;  * we are using transparent huge pages</span>
<span class="quote">&gt; &gt;&gt;&gt;  * the page &#39;not transferred&#39; are the last few of a huge page</span>
<span class="quote">&gt; &gt;&gt;&gt; More precisely:</span>
<span class="quote">&gt; &gt;&gt;&gt; - We have several transfer in flight from the same user buffer</span>
<span class="quote">&gt; &gt;&gt;&gt; - Each transfer is 16 pages long</span>
<span class="quote">&gt; &gt;&gt;&gt; - At one point in time, we start transferring from another huge page (transfers are still in flight from the previous one)</span>
<span class="quote">&gt; &gt;&gt;&gt; - When a transfer from the previous huge page completes, I dumped at the mapcount of the pages from the previous transfers,</span>
<span class="quote">&gt; &gt;&gt;&gt;   they are all to 0. The pages are still mapped to dma at this point.</span>
<span class="quote">&gt; &gt;&gt;&gt; - A get_user_page to the address of the completed transfer returns return a different struct page * then the on I had.</span>
<span class="quote">&gt; &gt;&gt;&gt; But this is before I have unmapped/put_page them back. From my understanding this should not have happened.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I tried the same code with a kernel 4.5 and encountered the same issue</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Disabling transparent huge pages makes the issue disapear</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Thanks in advance</span>
<span class="quote">&gt; &gt;&gt; It does look to me as if pages are being migrated, despite being pinned</span>
<span class="quote">&gt; &gt;&gt; by get_user_pages(): and that would be wrong.  Originally I intended</span>
<span class="quote">&gt; &gt;&gt; to suggest that THP is probably merely the cause of compaction, with</span>
<span class="quote">&gt; &gt;&gt; compaction causing the page migration.  But you posted very interesting</span>
<span class="quote">&gt; &gt;&gt; details in an earlier mail on 27th April from &lt;nmorey@kalray.eu&gt;:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I ran some more tests:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; * Test is OK if transparent huge tlb are disabled</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; * For all the page where data are not transfered, and only those pages, a call to get_user_page(user vaddr) just before dma_unmap_sg returns a different page from the original one.</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927279] mppa 0000:03:00.0: org_page= ffffea0009f60080 cur page = ffffea00074e0080</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927298] page:ffffea0009f60080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927314] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927354] page dumped because: org_page</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927369] page:ffffea00074e0080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927382] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt; &gt;&gt;&gt; [436477.927421] page dumped because: cur_page</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I&#39;m not sure what to make of this...</span>
<span class="quote">&gt; &gt;&gt; That (on the older kernel I think) seems clearly to show that a THP</span>
<span class="quote">&gt; &gt;&gt; itself has been migrated: which makes me suspect NUMA migration of</span>
<span class="quote">&gt; &gt;&gt; mispaced THPs - migrate_misplaced_transhuge_page().  I&#39;d hoped to</span>
<span class="quote">&gt; &gt;&gt; find something obviously wrong there, but haven&#39;t quite managed</span>
<span class="quote">&gt; &gt;&gt; to bring my brain fully to bear on it, and hope the others Cc&#39;ed</span>
<span class="quote">&gt; &gt;&gt; will do so more quickly (or spot the error of your ways instead).</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I do find it suspect, how the migrate_page_copy() is done rather</span>
<span class="quote">&gt; &gt;&gt; early, while the old page is still mapped in the pagetable.  And</span>
<span class="quote">&gt; &gt;&gt; odd how it inserts the new pmd for a moment, before checking old</span>
<span class="quote">&gt; &gt;&gt; page_count and backing out.  But I don&#39;t see how either of those</span>
<span class="quote">&gt; &gt;&gt; would cause the trouble you see, where the migration goes ahead.</span>
<span class="quote">&gt; &gt; So i do not think there is a bug migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; &gt; but i think something is wrong in it see attached patch. I still</span>
<span class="quote">&gt; &gt; want to convince myself i am not missing anything before posting</span>
<span class="quote">&gt; &gt; that one.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Now about this bug, dumb question but do you do get_user_pages with</span>
<span class="quote">&gt; &gt; write = 1 because if your device is writting to the page then you</span>
<span class="quote">&gt; &gt; must set write to 1.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; get_user_pages(vaddr, nrpages, 1, 0|1, pages, NULL|vmas);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Cheers,</span>
<span class="quote">&gt; &gt; Jérôme</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 0001-mm-numa-thp-fix-assumptions-of-migrate_misplaced_tra.patch</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; From 9ded2a5da75a5e736fb36a2c4e2511d9516ecc37 Mon Sep 17 00:00:00 2001</span>
<span class="quote">&gt; &gt; From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Glisse?= &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Date: Tue, 3 May 2016 11:53:24 +0200</span>
<span class="quote">&gt; &gt; Subject: [PATCH] mm/numa/thp: fix assumptions of</span>
<span class="quote">&gt; &gt;  migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; &gt; MIME-Version: 1.0</span>
<span class="quote">&gt; &gt; Content-Type: text/plain; charset=UTF-8</span>
<span class="quote">&gt; &gt; Content-Transfer-Encoding: 8bit</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Fix assumptions in migrate_misplaced_transhuge_page() which is only</span>
<span class="quote">&gt; &gt; call by do_huge_pmd_numa_page() itself only call by __handle_mm_fault()</span>
<span class="quote">&gt; &gt; for pmd with PROT_NONE. This means that if the pmd stays the same</span>
<span class="quote">&gt; &gt; then there can be no concurrent get_user_pages / get_user_pages_fast</span>
<span class="quote">&gt; &gt; (GUP/GUP_fast). More over because migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt; &gt; only do something is page is map once then there can be no GUP from</span>
<span class="quote">&gt; &gt; a different process. Finaly, holding the pmd lock assure us that no</span>
<span class="quote">&gt; &gt; other part of the kernel will take an extre reference on the page.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; In the end this means that the failure code path should never be</span>
<span class="quote">&gt; &gt; taken unless something is horribly wrong, so convert it to BUG_ON().</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Jérôme Glisse &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com</span>
<span class="quote">&gt; &gt; Cc: Mel Gorman &lt;mgorman@suse.de&gt;</span>
<span class="quote">&gt; &gt; Cc: Hugh Dickins &lt;hughd@google.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  mm/migrate.c | 31 +++++++++++++++++++++----------</span>
<span class="quote">&gt; &gt;  1 file changed, 21 insertions(+), 10 deletions(-)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt; &gt; index 6c822a7..6315aac 100644</span>
<span class="quote">&gt; &gt; --- a/mm/migrate.c</span>
<span class="quote">&gt; &gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt; &gt; @@ -1757,6 +1757,14 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt; &gt;  	pmd_t orig_entry;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	/*</span>
<span class="quote">&gt; &gt; +	 * What we do here is only valid if pmd_protnone(entry) is true and it</span>
<span class="quote">&gt; &gt; +	 * is map in only one vma numamigrate_isolate_page() takes care of that</span>
<span class="quote">&gt; &gt; +	 * check.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	if (!pmd_protnone(entry))</span>
<span class="quote">&gt; &gt; +		goto out_unlock;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt;  	 * Rate-limit the amount of data that is being migrated to a node.</span>
<span class="quote">&gt; &gt;  	 * Optimal placement is no good if the memory bus is saturated and</span>
<span class="quote">&gt; &gt;  	 * all the time is being spent migrating!</span>
<span class="quote">&gt; &gt; @@ -1797,7 +1805,6 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt; &gt;  	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt; &gt;  	ptl = pmd_lock(mm, pmd);</span>
<span class="quote">&gt; &gt;  	if (unlikely(!pmd_same(*pmd, entry) || page_count(page) != 2)) {</span>
<span class="quote">&gt; &gt; -fail_putback:</span>
<span class="quote">&gt; &gt;  		spin_unlock(ptl);</span>
<span class="quote">&gt; &gt;  		mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; @@ -1819,7 +1826,12 @@ fail_putback:</span>
<span class="quote">&gt; &gt;  		goto out_unlock;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	orig_entry = *pmd;</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * We are holding the lock so no one can set a new pmd and original pmd</span>
<span class="quote">&gt; &gt; +	 * is PROT_NONE thus no one can get_user_pages or get_user_pages_fast</span>
<span class="quote">&gt; &gt; +	 * (GUP or GUP_fast) from this point on we can not fail.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	orig_entry = entry;</span>
<span class="quote">&gt; &gt;  	entry = mk_pmd(new_page, vma-&gt;vm_page_prot);</span>
<span class="quote">&gt; &gt;  	entry = pmd_mkhuge(entry);</span>
<span class="quote">&gt; &gt;  	entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);</span>
<span class="quote">&gt; &gt; @@ -1837,14 +1849,13 @@ fail_putback:</span>
<span class="quote">&gt; &gt;  	set_pmd_at(mm, mmun_start, pmd, entry);</span>
<span class="quote">&gt; &gt;  	update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	if (page_count(page) != 2) {</span>
<span class="quote">&gt; &gt; -		set_pmd_at(mm, mmun_start, pmd, orig_entry);</span>
<span class="quote">&gt; &gt; -		flush_pmd_tlb_range(vma, mmun_start, mmun_end);</span>
<span class="quote">&gt; &gt; -		mmu_notifier_invalidate_range(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt; &gt; -		update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt; &gt; -		page_remove_rmap(new_page, true);</span>
<span class="quote">&gt; &gt; -		goto fail_putback;</span>
<span class="quote">&gt; &gt; -	}</span>
<span class="quote">&gt; &gt; +	/* As said above no one can get reference on the old page nor through</span>
<span class="quote">&gt; &gt; +	 * get_user_pages or get_user_pages_fast (GUP/GUP_fast) or through</span>
<span class="quote">&gt; &gt; +	 * any other means. To get reference on huge page you need to hold</span>
<span class="quote">&gt; &gt; +	 * pmd_lock and we are already holding that lock here and the page</span>
<span class="quote">&gt; &gt; +	 * is only mapped once.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	BUG_ON(page_count(page) != 2);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	mlock_migrate_page(new_page, page);</span>
<span class="quote">&gt; &gt;  	page_remove_rmap(page, true);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt; </span>

This patch is not a fix, do you see bug message in kernel log ? Because if
you do that it means we have a bigger issue.

You did not answer one of my previous question, do you set get_user_pages
with write = 1 as a paremeter ?

Also it would be a lot easier if you were testing with lastest 4.6 or 4.5
not RHEL kernel as they are far appart and what might looks like same issue
on both might be totaly different bugs.

If you only really care about RHEL kernel then open a bug with Red Hat and
you can add me in bug-cc &lt;jglisse@redhat.com&gt;

Cheers,
Jérôme
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 10, 2016, 11:15 a.m.</div>
<pre class="content">
Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :
<span class="quote">&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Hi everyone,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; This is a repost from a different address as it seems the previous one ended in Gmail junk due to a domain error..</span>
<span class="quote">&gt;&gt;&gt;&gt; linux-kernel is a very high volume list which few are reading:</span>
<span class="quote">&gt;&gt;&gt;&gt; that also will account for your lack of response so far</span>
<span class="quote">&gt;&gt;&gt;&gt; (apart from the indefatigable Alan).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I&#39;ve added linux-mm, and some people from another thread regarding</span>
<span class="quote">&gt;&gt;&gt;&gt; THP and get_user_pages() pins which has been discussed in recent days.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Make no mistake, the issue you&#39;re raising here is definitely not the</span>
<span class="quote">&gt;&gt;&gt;&gt; same as that one (which is specifically about the new THP refcounting</span>
<span class="quote">&gt;&gt;&gt;&gt; in v4.5+, whereas you&#39;re reporting a problem you&#39;ve seen in both a</span>
<span class="quote">&gt;&gt;&gt;&gt; v3.10-based kernel and in v4.5).  But I think their heads are in</span>
<span class="quote">&gt;&gt;&gt;&gt; gear, much more so than mine, and likely to spot something.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I added more info found while blindly debugging the issue.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Short version:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I&#39;m having an issue with direct DMA transfer from a device to host memory.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; It seems some of the data is not transferring to the appropriate page.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Some more details:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I&#39;m debugging a home made PCI driver for our board (Kalray), attached to a x86_64 host running centos7 (3.10.0-327.el7.x86_64)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; In the current case, a userland application transfers back and forth data through read/write operations on a file.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On the kernel side, it triggers DMA transfers through the PCI to/from our board memory.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; We followed what pretty much all docs said about direct I/O to user buffers:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 1) get_user_pages() (in the current case, it&#39;s at most 16 pages at once)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 2) convert to a scatterlist</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 3) pci_map_sg</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 4) eventually coalesce sg (Intel IOMMU is enabled, so it&#39;s usually possible)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 4) A lot of DMA engine handling code, using the dmaengine layer and virt-dma</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 5) wait for transfer complete, in the mean time, go back to (1) to schedule more work, if any</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 6) pci_unmap_sg</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 7) for read (card2host) transfer, set_page_dirty_lock</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; 8) page_cache_release</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; In 99,9999% it works perfectly.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; However, I have one userland application where a few pages are not written by a read (card2host) transfer.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; The buffer is memset them to a different value so I can check that nothing has overwritten them.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I know (PCI protocol analyser) that the data left our board for the &quot;right&quot; address (the one set in the sg by pci_map_sg).</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I tried reading the data between the pci_unmap_sg and the set_page_dirty, using</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;         uint32_t *addr = page_address(trans-&gt;pages[0]);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;         dev_warn(&amp;pdata-&gt;pdev-&gt;dev, &quot;val = %x\n&quot;, *addr);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; and it has the expected value.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; But if I try to copy_from_user (using the address coming from userland, the one passed to get_user_pages), the data has not been written and I see the memset value.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; New infos:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; The issue happens with IOMMU on or off.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I compiled a kernel with DMA_API_DEBUG enabled and got no warnings or errors.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I digged a little bit deeper with my very small understanding of linux mm and I discovered that:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  * we are using transparent huge pages</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  * the page &#39;not transferred&#39; are the last few of a huge page</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; More precisely:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; - We have several transfer in flight from the same user buffer</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; - Each transfer is 16 pages long</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; - At one point in time, we start transferring from another huge page (transfers are still in flight from the previous one)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; - When a transfer from the previous huge page completes, I dumped at the mapcount of the pages from the previous transfers,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;   they are all to 0. The pages are still mapped to dma at this point.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; - A get_user_page to the address of the completed transfer returns return a different struct page * then the on I had.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; But this is before I have unmapped/put_page them back. From my understanding this should not have happened.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I tried the same code with a kernel 4.5 and encountered the same issue</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Disabling transparent huge pages makes the issue disapear</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Thanks in advance</span>
<span class="quote">&gt;&gt;&gt;&gt; It does look to me as if pages are being migrated, despite being pinned</span>
<span class="quote">&gt;&gt;&gt;&gt; by get_user_pages(): and that would be wrong.  Originally I intended</span>
<span class="quote">&gt;&gt;&gt;&gt; to suggest that THP is probably merely the cause of compaction, with</span>
<span class="quote">&gt;&gt;&gt;&gt; compaction causing the page migration.  But you posted very interesting</span>
<span class="quote">&gt;&gt;&gt;&gt; details in an earlier mail on 27th April from &lt;nmorey@kalray.eu&gt;:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I ran some more tests:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; * Test is OK if transparent huge tlb are disabled</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; * For all the page where data are not transfered, and only those pages, a call to get_user_page(user vaddr) just before dma_unmap_sg returns a different page from the original one.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927279] mppa 0000:03:00.0: org_page= ffffea0009f60080 cur page = ffffea00074e0080</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927298] page:ffffea0009f60080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927314] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927354] page dumped because: org_page</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927369] page:ffffea00074e0080 count:0 mapcount:1 mapping:          (null) index:0x2</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927382] page flags: 0x2fffff00008000(tail)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; [436477.927421] page dumped because: cur_page</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; I&#39;m not sure what to make of this...</span>
<span class="quote">&gt;&gt;&gt;&gt; That (on the older kernel I think) seems clearly to show that a THP</span>
<span class="quote">&gt;&gt;&gt;&gt; itself has been migrated: which makes me suspect NUMA migration of</span>
<span class="quote">&gt;&gt;&gt;&gt; mispaced THPs - migrate_misplaced_transhuge_page().  I&#39;d hoped to</span>
<span class="quote">&gt;&gt;&gt;&gt; find something obviously wrong there, but haven&#39;t quite managed</span>
<span class="quote">&gt;&gt;&gt;&gt; to bring my brain fully to bear on it, and hope the others Cc&#39;ed</span>
<span class="quote">&gt;&gt;&gt;&gt; will do so more quickly (or spot the error of your ways instead).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I do find it suspect, how the migrate_page_copy() is done rather</span>
<span class="quote">&gt;&gt;&gt;&gt; early, while the old page is still mapped in the pagetable.  And</span>
<span class="quote">&gt;&gt;&gt;&gt; odd how it inserts the new pmd for a moment, before checking old</span>
<span class="quote">&gt;&gt;&gt;&gt; page_count and backing out.  But I don&#39;t see how either of those</span>
<span class="quote">&gt;&gt;&gt;&gt; would cause the trouble you see, where the migration goes ahead.</span>
<span class="quote">&gt;&gt;&gt; So i do not think there is a bug migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt;&gt;&gt; but i think something is wrong in it see attached patch. I still</span>
<span class="quote">&gt;&gt;&gt; want to convince myself i am not missing anything before posting</span>
<span class="quote">&gt;&gt;&gt; that one.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Now about this bug, dumb question but do you do get_user_pages with</span>
<span class="quote">&gt;&gt;&gt; write = 1 because if your device is writting to the page then you</span>
<span class="quote">&gt;&gt;&gt; must set write to 1.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; get_user_pages(vaddr, nrpages, 1, 0|1, pages, NULL|vmas);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 0001-mm-numa-thp-fix-assumptions-of-migrate_misplaced_tra.patch</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From 9ded2a5da75a5e736fb36a2c4e2511d9516ecc37 Mon Sep 17 00:00:00 2001</span>
<span class="quote">&gt;&gt;&gt; From: =?UTF-8?q?J=C3=A9r=C3=B4me=20Glisse?= &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Date: Tue, 3 May 2016 11:53:24 +0200</span>
<span class="quote">&gt;&gt;&gt; Subject: [PATCH] mm/numa/thp: fix assumptions of</span>
<span class="quote">&gt;&gt;&gt;  migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt;&gt;&gt; MIME-Version: 1.0</span>
<span class="quote">&gt;&gt;&gt; Content-Type: text/plain; charset=UTF-8</span>
<span class="quote">&gt;&gt;&gt; Content-Transfer-Encoding: 8bit</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Fix assumptions in migrate_misplaced_transhuge_page() which is only</span>
<span class="quote">&gt;&gt;&gt; call by do_huge_pmd_numa_page() itself only call by __handle_mm_fault()</span>
<span class="quote">&gt;&gt;&gt; for pmd with PROT_NONE. This means that if the pmd stays the same</span>
<span class="quote">&gt;&gt;&gt; then there can be no concurrent get_user_pages / get_user_pages_fast</span>
<span class="quote">&gt;&gt;&gt; (GUP/GUP_fast). More over because migrate_misplaced_transhuge_page()</span>
<span class="quote">&gt;&gt;&gt; only do something is page is map once then there can be no GUP from</span>
<span class="quote">&gt;&gt;&gt; a different process. Finaly, holding the pmd lock assure us that no</span>
<span class="quote">&gt;&gt;&gt; other part of the kernel will take an extre reference on the page.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; In the end this means that the failure code path should never be</span>
<span class="quote">&gt;&gt;&gt; taken unless something is horribly wrong, so convert it to BUG_ON().</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Jérôme Glisse &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com</span>
<span class="quote">&gt;&gt;&gt; Cc: Mel Gorman &lt;mgorman@suse.de&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Hugh Dickins &lt;hughd@google.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;  mm/migrate.c | 31 +++++++++++++++++++++----------</span>
<span class="quote">&gt;&gt;&gt;  1 file changed, 21 insertions(+), 10 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt;&gt;&gt; index 6c822a7..6315aac 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/mm/migrate.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt;&gt;&gt; @@ -1757,6 +1757,14 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt;&gt;&gt;  	pmd_t orig_entry;</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;  	/*</span>
<span class="quote">&gt;&gt;&gt; +	 * What we do here is only valid if pmd_protnone(entry) is true and it</span>
<span class="quote">&gt;&gt;&gt; +	 * is map in only one vma numamigrate_isolate_page() takes care of that</span>
<span class="quote">&gt;&gt;&gt; +	 * check.</span>
<span class="quote">&gt;&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt;&gt; +	if (!pmd_protnone(entry))</span>
<span class="quote">&gt;&gt;&gt; +		goto out_unlock;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt;&gt;  	 * Rate-limit the amount of data that is being migrated to a node.</span>
<span class="quote">&gt;&gt;&gt;  	 * Optimal placement is no good if the memory bus is saturated and</span>
<span class="quote">&gt;&gt;&gt;  	 * all the time is being spent migrating!</span>
<span class="quote">&gt;&gt;&gt; @@ -1797,7 +1805,6 @@ int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
<span class="quote">&gt;&gt;&gt;  	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt;&gt;&gt;  	ptl = pmd_lock(mm, pmd);</span>
<span class="quote">&gt;&gt;&gt;  	if (unlikely(!pmd_same(*pmd, entry) || page_count(page) != 2)) {</span>
<span class="quote">&gt;&gt;&gt; -fail_putback:</span>
<span class="quote">&gt;&gt;&gt;  		spin_unlock(ptl);</span>
<span class="quote">&gt;&gt;&gt;  		mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt; @@ -1819,7 +1826,12 @@ fail_putback:</span>
<span class="quote">&gt;&gt;&gt;  		goto out_unlock;</span>
<span class="quote">&gt;&gt;&gt;  	}</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt; -	orig_entry = *pmd;</span>
<span class="quote">&gt;&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt;&gt; +	 * We are holding the lock so no one can set a new pmd and original pmd</span>
<span class="quote">&gt;&gt;&gt; +	 * is PROT_NONE thus no one can get_user_pages or get_user_pages_fast</span>
<span class="quote">&gt;&gt;&gt; +	 * (GUP or GUP_fast) from this point on we can not fail.</span>
<span class="quote">&gt;&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt;&gt; +	orig_entry = entry;</span>
<span class="quote">&gt;&gt;&gt;  	entry = mk_pmd(new_page, vma-&gt;vm_page_prot);</span>
<span class="quote">&gt;&gt;&gt;  	entry = pmd_mkhuge(entry);</span>
<span class="quote">&gt;&gt;&gt;  	entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);</span>
<span class="quote">&gt;&gt;&gt; @@ -1837,14 +1849,13 @@ fail_putback:</span>
<span class="quote">&gt;&gt;&gt;  	set_pmd_at(mm, mmun_start, pmd, entry);</span>
<span class="quote">&gt;&gt;&gt;  	update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt; -	if (page_count(page) != 2) {</span>
<span class="quote">&gt;&gt;&gt; -		set_pmd_at(mm, mmun_start, pmd, orig_entry);</span>
<span class="quote">&gt;&gt;&gt; -		flush_pmd_tlb_range(vma, mmun_start, mmun_end);</span>
<span class="quote">&gt;&gt;&gt; -		mmu_notifier_invalidate_range(mm, mmun_start, mmun_end);</span>
<span class="quote">&gt;&gt;&gt; -		update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="quote">&gt;&gt;&gt; -		page_remove_rmap(new_page, true);</span>
<span class="quote">&gt;&gt;&gt; -		goto fail_putback;</span>
<span class="quote">&gt;&gt;&gt; -	}</span>
<span class="quote">&gt;&gt;&gt; +	/* As said above no one can get reference on the old page nor through</span>
<span class="quote">&gt;&gt;&gt; +	 * get_user_pages or get_user_pages_fast (GUP/GUP_fast) or through</span>
<span class="quote">&gt;&gt;&gt; +	 * any other means. To get reference on huge page you need to hold</span>
<span class="quote">&gt;&gt;&gt; +	 * pmd_lock and we are already holding that lock here and the page</span>
<span class="quote">&gt;&gt;&gt; +	 * is only mapped once.</span>
<span class="quote">&gt;&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt;&gt; +	BUG_ON(page_count(page) != 2);</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;  	mlock_migrate_page(new_page, page);</span>
<span class="quote">&gt;&gt;&gt;  	page_remove_rmap(page, true);</span>
<span class="quote">&gt;&gt; Hi,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; you do that it means we have a bigger issue.</span>
I don&#39;t see any on my 3.10. I have DMA_API_DEBUG enabled but I don&#39;t think it has an impact.
<span class="quote">&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; with write = 1 as a paremeter ?</span>
For the read from the device, yes:
        down_read(&amp;current-&gt;mm-&gt;mmap_sem);
        res = get_user_pages(
                current,
                current-&gt;mm,
                (unsigned long) iov-&gt;host_addr,
                page_count,
                (write_mode == 0) ? 1 : 0,      /* write */
                0,      /* force */
                &amp;trans-&gt;pages[sg_o],
                NULL);
        up_read(&amp;current-&gt;mm-&gt;mmap_sem);
<span class="quote">
&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; on both might be totaly different bugs.</span>
Is a RPM from elrepo ok?
http://elrepo.org/linux/kernel/el7/SRPMS/

I don&#39;t know why but a simple make install from the kernel source tree won&#39;t boot. I&#39;m working remotely so it&#39;s hard to debug.
Rebuilding a kernel RPM seems to work though.
<span class="quote">&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
I opened one. I&#39;ll CC you

Thanks

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 10, 2016, 1:34 p.m.</div>
<pre class="content">
On Tue, May 10, 2016 at 01:15:02PM +0200, Nicolas Morey Chaisemartin wrote:
<span class="quote">&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>

[...]
<span class="quote">
&gt; &gt;&gt; Hi,</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt; &gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; &gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt; I don&#39;t see any on my 3.10. I have DMA_API_DEBUG enabled but I don&#39;t think it has an impact.</span>

My patch can&#39;t be backported to 3.10 as is, you most likely need to replace
pmd_protnone() by pmd_numa()
<span class="quote">
&gt; &gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; &gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt; For the read from the device, yes:</span>
<span class="quote">&gt;         down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;         res = get_user_pages(</span>
<span class="quote">&gt;                 current,</span>
<span class="quote">&gt;                 current-&gt;mm,</span>
<span class="quote">&gt;                 (unsigned long) iov-&gt;host_addr,</span>
<span class="quote">&gt;                 page_count,</span>
<span class="quote">&gt;                 (write_mode == 0) ? 1 : 0,      /* write */</span>
<span class="quote">&gt;                 0,      /* force */</span>
<span class="quote">&gt;                 &amp;trans-&gt;pages[sg_o],</span>
<span class="quote">&gt;                 NULL);</span>
<span class="quote">&gt;         up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>

As i don&#39;t have context to infer how write_mode is set above, do you mind
retesting your driver and always asking for write no matter what ?
<span class="quote">
&gt; &gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; &gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; &gt; on both might be totaly different bugs.</span>
<span class="quote">&gt; Is a RPM from elrepo ok?</span>
<span class="quote">&gt; http://elrepo.org/linux/kernel/el7/SRPMS/</span>

Yes should be ok for testing.

Cheers,
Jérôme
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 11, 2016, 9:14 a.m.</div>
<pre class="content">
Le 05/10/2016 à 03:34 PM, Jerome Glisse a écrit :
<span class="quote">&gt; On Tue, May 10, 2016 at 01:15:02PM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Hi,</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt;&gt;&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt;&gt;&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt;&gt; I don&#39;t see any on my 3.10. I have DMA_API_DEBUG enabled but I don&#39;t think it has an impact.</span>
<span class="quote">&gt; My patch can&#39;t be backported to 3.10 as is, you most likely need to replace</span>
<span class="quote">&gt; pmd_protnone() by pmd_numa()</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt;&gt;&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt;&gt; For the read from the device, yes:</span>
<span class="quote">&gt;&gt;         down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;&gt;         res = get_user_pages(</span>
<span class="quote">&gt;&gt;                 current,</span>
<span class="quote">&gt;&gt;                 current-&gt;mm,</span>
<span class="quote">&gt;&gt;                 (unsigned long) iov-&gt;host_addr,</span>
<span class="quote">&gt;&gt;                 page_count,</span>
<span class="quote">&gt;&gt;                 (write_mode == 0) ? 1 : 0,      /* write */</span>
<span class="quote">&gt;&gt;                 0,      /* force */</span>
<span class="quote">&gt;&gt;                 &amp;trans-&gt;pages[sg_o],</span>
<span class="quote">&gt;&gt;                 NULL);</span>
<span class="quote">&gt;&gt;         up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; As i don&#39;t have context to infer how write_mode is set above, do you mind</span>
<span class="quote">&gt; retesting your driver and always asking for write no matter what ?</span>
write_mode is 0 for car2host transfers so yes, write_mode is 1.
During debug I tried with write_mode=1 and force=1 in all cases and it failed too.
<span class="quote">&gt;&gt;&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt;&gt;&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt;&gt;&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt;&gt; Is a RPM from elrepo ok?</span>
<span class="quote">&gt;&gt; http://elrepo.org/linux/kernel/el7/SRPMS/</span>
<span class="quote">&gt; Yes should be ok for testing.</span>
<span class="quote">&gt;</span>
I tried the elrpo 4.5.2 package without your patch and my test fails, sadly the src rpm from elrepo does not contaisn the kernel sources and I haven&#39;t looked how to get the proper tarball.
I tried to rebuild a src rpm for a fedora 24 (kernel 4.5.3) and it works without your patch. I&#39;m not sure what differs in their config. I&#39;ll keep digging.

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 11, 2016, 11:15 a.m.</div>
<pre class="content">
Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :
<span class="quote">&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
[...]
<span class="quote">&gt;&gt; Hi,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cheers,</span>
<span class="quote">&gt; Jérôme</span>

I finally managed to get a proper setup.
I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.
I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.

Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 11, 2016, 2:51 p.m.</div>
<pre class="content">
On Wed, May 11, 2016 at 01:15:54PM +0200, Nicolas Morey Chaisemartin wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt; Hi,</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt; &gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; &gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; &gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; &gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; &gt; on both might be totaly different bugs.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt; &gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Cheers,</span>
<span class="quote">&gt; &gt; Jérôme</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I finally managed to get a proper setup.</span>
<span class="quote">&gt; I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.</span>
<span class="quote">&gt; I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.</span>
<span class="quote">&gt; </span>

Still an issue if you boot with transparent_hugepage=never ?

Also to simplify investigation force write to 1 all the time no matter what.

Cheers,
Jérôme
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 12, 2016, 6:07 a.m.</div>
<pre class="content">
Le 05/11/2016 à 04:51 PM, Jerome Glisse a écrit :
<span class="quote">&gt; On Wed, May 11, 2016 at 01:15:54PM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt;&gt; Hi,</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt;&gt;&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt;&gt;&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt;&gt;&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt;&gt;&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt;&gt;&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt;&gt;&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt;&gt; I finally managed to get a proper setup.</span>
<span class="quote">&gt;&gt; I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.</span>
<span class="quote">&gt;&gt; I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; Still an issue if you boot with transparent_hugepage=never ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Also to simplify investigation force write to 1 all the time no matter what.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cheers,</span>
<span class="quote">&gt; Jérôme</span>

With transparent_hugepage=never I can&#39;t see the bug anymore.

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 12, 2016, 9:36 a.m.</div>
<pre class="content">
On Thu, May 12, 2016 at 08:07:59AM +0200, Nicolas Morey-Chaisemartin wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Le 05/11/2016 à 04:51 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Wed, May 11, 2016 at 01:15:54PM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Hi,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; &gt;&gt;&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; &gt;&gt;&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; &gt;&gt;&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; &gt;&gt;&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt; &gt;&gt;&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt; &gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt; &gt;&gt; I finally managed to get a proper setup.</span>
<span class="quote">&gt; &gt;&gt; I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.</span>
<span class="quote">&gt; &gt;&gt; I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; Still an issue if you boot with transparent_hugepage=never ?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Also to simplify investigation force write to 1 all the time no matter what.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Cheers,</span>
<span class="quote">&gt; &gt; Jérôme</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; With transparent_hugepage=never I can&#39;t see the bug anymore.</span>
<span class="quote">&gt; </span>

Can you test https://patchwork.kernel.org/patch/9061351/ with 4.5
(does not apply to 3.10) and without transparent_hugepage=never

Jérôme
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 12, 2016, 1:30 p.m.</div>
<pre class="content">
Le 05/12/2016 à 11:36 AM, Jerome Glisse a écrit :
<span class="quote">&gt; On Thu, May 12, 2016 at 08:07:59AM +0200, Nicolas Morey-Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Le 05/11/2016 à 04:51 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Wed, May 11, 2016 at 01:15:54PM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; Hi,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt;&gt;&gt;&gt; I finally managed to get a proper setup.</span>
<span class="quote">&gt;&gt;&gt;&gt; I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.</span>
<span class="quote">&gt;&gt;&gt;&gt; I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Still an issue if you boot with transparent_hugepage=never ?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Also to simplify investigation force write to 1 all the time no matter what.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt;&gt; With transparent_hugepage=never I can&#39;t see the bug anymore.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; Can you test https://patchwork.kernel.org/patch/9061351/ with 4.5</span>
<span class="quote">&gt; (does not apply to 3.10) and without transparent_hugepage=never</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Jérôme</span>

Fails with 4.5 + this patch and with 4.5 + this patch + yours

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11822">Jerome Glisse</a> - May 12, 2016, 1:52 p.m.</div>
<pre class="content">
On Thu, May 12, 2016 at 03:30:24PM +0200, Nicolas Morey-Chaisemartin wrote:
<span class="quote">&gt; Le 05/12/2016 à 11:36 AM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Thu, May 12, 2016 at 08:07:59AM +0200, Nicolas Morey-Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Le 05/11/2016 à 04:51 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt; On Wed, May 11, 2016 at 01:15:54PM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Le 05/10/2016 à 12:01 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; On Tue, May 10, 2016 at 09:04:36AM +0200, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; Le 05/03/2016 à 12:11 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, May 02, 2016 at 09:04:02PM -0700, Hugh Dickins wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, 29 Apr 2016, Nicolas Morey Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; Hi,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; I backported the patch to 3.10 (had to copy paste pmd_protnone defitinition from 4.5) and it&#39;s working !</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; I&#39;ll open a ticket in Redhat tracker to try and get this fixed in RHEL7.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt; I have a dumb question though: how can we end up in numa/misplaced memory code on a single socket system?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; This patch is not a fix, do you see bug message in kernel log ? Because if</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; you do that it means we have a bigger issue.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; You did not answer one of my previous question, do you set get_user_pages</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; with write = 1 as a paremeter ?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; Also it would be a lot easier if you were testing with lastest 4.6 or 4.5</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; not RHEL kernel as they are far appart and what might looks like same issue</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; on both might be totaly different bugs.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; If you only really care about RHEL kernel then open a bug with Red Hat and</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; you can add me in bug-cc &lt;jglisse@redhat.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I finally managed to get a proper setup.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I build a vanilla 4.5 kernel from git tree using the Centos7 config, my test fails as usual.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; I applied your patch, rebuild =&gt; still fails and no new messages in dmesg.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Now that I don&#39;t have to go through the RPM repackaging, I can try out things much quicker if you have any ideas.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Still an issue if you boot with transparent_hugepage=never ?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Also to simplify investigation force write to 1 all the time no matter what.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Cheers,</span>
<span class="quote">&gt; &gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt; &gt;&gt; With transparent_hugepage=never I can&#39;t see the bug anymore.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; Can you test https://patchwork.kernel.org/patch/9061351/ with 4.5</span>
<span class="quote">&gt; &gt; (does not apply to 3.10) and without transparent_hugepage=never</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Jérôme</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fails with 4.5 + this patch and with 4.5 + this patch + yours</span>
<span class="quote">&gt; </span>

There must be some bug in your code, we have upstream user that works
fine with the above combination (see drivers/vfio/vfio_iommu_type1.c)
i suspect you might be releasing the page pin too early (put_page()).

If you really believe it is bug upstream we would need a dumb kernel
module that does gup like you do and that shows the issue. Right now
looking at code (assuming above patches applied) i can&#39;t see anything
that can go wrong with THP.

Cheers,
Jérôme
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166491">Nicolas Morey Chaisemartin</a> - May 12, 2016, 3:31 p.m.</div>
<pre class="content">
Le 05/12/2016 à 03:52 PM, Jerome Glisse a écrit :
<span class="quote">&gt; On Thu, May 12, 2016 at 03:30:24PM +0200, Nicolas Morey-Chaisemartin wrote:</span>
<span class="quote">&gt;&gt; Le 05/12/2016 à 11:36 AM, Jerome Glisse a écrit :</span>
<span class="quote">&gt;&gt;&gt; On Thu, May 12, 2016 at 08:07:59AM +0200, Nicolas Morey-Chaisemartin wrote:</span>
[...]
<span class="quote">&gt;&gt;&gt;&gt; With transparent_hugepage=never I can&#39;t see the bug anymore.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Can you test https://patchwork.kernel.org/patch/9061351/ with 4.5</span>
<span class="quote">&gt;&gt;&gt; (does not apply to 3.10) and without transparent_hugepage=never</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt;&gt; Fails with 4.5 + this patch and with 4.5 + this patch + yours</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; There must be some bug in your code, we have upstream user that works</span>
<span class="quote">&gt; fine with the above combination (see drivers/vfio/vfio_iommu_type1.c)</span>
<span class="quote">&gt; i suspect you might be releasing the page pin too early (put_page()).</span>
In my previous tests, I checked the page before calling put_page and it has already changed.
And I also checked that there is not multiple transfers in a single page at once.
So I doubt it&#39;s that.
<span class="quote">&gt;</span>
<span class="quote">&gt; If you really believe it is bug upstream we would need a dumb kernel</span>
<span class="quote">&gt; module that does gup like you do and that shows the issue. Right now</span>
<span class="quote">&gt; looking at code (assuming above patches applied) i can&#39;t see anything</span>
<span class="quote">&gt; that can go wrong with THP.</span>

The issue is that I doubt I&#39;ll be able to do that. We have had code running in production for at least a year without the issue showing up and now a single test shows this.
And some tweak to the test (meaning memory footprint in the user space) can make the problem disappear.

Is there a way to track what is happening to the THP? From the looks of it, the refcount are changed behind my back? Would kgdb with watch point work on this?
Is there a less painful way?

Thanks

Nicolas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=965">Andrea Arcangeli</a> - May 12, 2016, 3:57 p.m.</div>
<pre class="content">
Hello Nicolas,

On Thu, May 12, 2016 at 05:31:52PM +0200, Nicolas Morey-Chaisemartin wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Le 05/12/2016 à 03:52 PM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt; On Thu, May 12, 2016 at 03:30:24PM +0200, Nicolas Morey-Chaisemartin wrote:</span>
<span class="quote">&gt; &gt;&gt; Le 05/12/2016 à 11:36 AM, Jerome Glisse a écrit :</span>
<span class="quote">&gt; &gt;&gt;&gt; On Thu, May 12, 2016 at 08:07:59AM +0200, Nicolas Morey-Chaisemartin wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; With transparent_hugepage=never I can&#39;t see the bug anymore.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Can you test https://patchwork.kernel.org/patch/9061351/ with 4.5</span>
<span class="quote">&gt; &gt;&gt;&gt; (does not apply to 3.10) and without transparent_hugepage=never</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Jérôme</span>
<span class="quote">&gt; &gt;&gt; Fails with 4.5 + this patch and with 4.5 + this patch + yours</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; There must be some bug in your code, we have upstream user that works</span>
<span class="quote">&gt; &gt; fine with the above combination (see drivers/vfio/vfio_iommu_type1.c)</span>
<span class="quote">&gt; &gt; i suspect you might be releasing the page pin too early (put_page()).</span>
<span class="quote">&gt; In my previous tests, I checked the page before calling put_page and it has already changed.</span>
<span class="quote">&gt; And I also checked that there is not multiple transfers in a single page at once.</span>
<span class="quote">&gt; So I doubt it&#39;s that.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If you really believe it is bug upstream we would need a dumb kernel</span>
<span class="quote">&gt; &gt; module that does gup like you do and that shows the issue. Right now</span>
<span class="quote">&gt; &gt; looking at code (assuming above patches applied) i can&#39;t see anything</span>
<span class="quote">&gt; &gt; that can go wrong with THP.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The issue is that I doubt I&#39;ll be able to do that. We have had code running in production for at least a year without the issue showing up and now a single test shows this.</span>
<span class="quote">&gt; And some tweak to the test (meaning memory footprint in the user space) can make the problem disappear.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is there a way to track what is happening to the THP? From the looks of it, the refcount are changed behind my back? Would kgdb with watch point work on this?</span>
<span class="quote">&gt; Is there a less painful way?</span>

Do you use fork()?

If you have threads and your DMA I/O granularity is smaller than
PAGE_SIZE, and a thread of the application in parent or child is
writing to another part of the page, the I/O can get lost (worse, it
doesn&#39;t get really lost but it goes to the child by mistake, instead
of sticking to the &quot;mm&quot; where you executed get_user_pages). This is
practically a bug in fork() but it&#39;s known. It can affect any app that
uses get_user_pages/O_DIRECT, fork() and uses thread and the I/O
granularity is smaller than PAGE_SIZE.

The same bug cannot happen with KSM or other things that can wrprotect
a page out of app control, because all things out of app control
checks there are no page pins before wrprotecting the page. So it&#39;s up
to the app to control &quot;fork()&quot;.

To fix it, you should do one of: 1) use MADV_DONTFORK on the pinned
region, 2) prevent fork to run while you&#39;ve pins taken with
get_user_pages or anyway while get_user_pages may be running
concurrently, 3) use a PAGE_SIZE I/O granularity and/or prevent the
threads to write to the other part of the page while DMA is running.

I&#39;m not aware of other issues that could screw with page pins with THP
on kernels &lt;=4.4, if there were, everything should fall apart
including O_DIRECT and qemu cache=none. The only issue I&#39;m aware of
that can cause DMA to get lost with page pins is the aforementioned
one.

To debug it further, I would suggest to start by searching for &quot;fork&quot;
calls, and adding MADV_DONTFORK to the pinned region if there&#39;s any
fork() in your testcase.

Without being allowed to see the source there&#39;s not much else we can
do considering there&#39;s no sign of unknown bugs in this area in kernels
&lt;=4.4.

All there is, is the known bug above, but apps that could be affected
by it, actively avoid it by using MADV_DONTFORK like with qemu
cache=none.

Thanks,
Andrea
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index 6c822a7..6315aac 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -1757,6 +1757,14 @@</span> <span class="p_context"> int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
 	pmd_t orig_entry;
 
 	/*
<span class="p_add">+	 * What we do here is only valid if pmd_protnone(entry) is true and it</span>
<span class="p_add">+	 * is map in only one vma numamigrate_isolate_page() takes care of that</span>
<span class="p_add">+	 * check.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!pmd_protnone(entry))</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Rate-limit the amount of data that is being migrated to a node.
 	 * Optimal placement is no good if the memory bus is saturated and
 	 * all the time is being spent migrating!
<span class="p_chunk">@@ -1797,7 +1805,6 @@</span> <span class="p_context"> int migrate_misplaced_transhuge_page(struct mm_struct *mm,</span>
 	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);
 	ptl = pmd_lock(mm, pmd);
 	if (unlikely(!pmd_same(*pmd, entry) || page_count(page) != 2)) {
<span class="p_del">-fail_putback:</span>
 		spin_unlock(ptl);
 		mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
 
<span class="p_chunk">@@ -1819,7 +1826,12 @@</span> <span class="p_context"> fail_putback:</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	orig_entry = *pmd;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We are holding the lock so no one can set a new pmd and original pmd</span>
<span class="p_add">+	 * is PROT_NONE thus no one can get_user_pages or get_user_pages_fast</span>
<span class="p_add">+	 * (GUP or GUP_fast) from this point on we can not fail.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	orig_entry = entry;</span>
 	entry = mk_pmd(new_page, vma-&gt;vm_page_prot);
 	entry = pmd_mkhuge(entry);
 	entry = maybe_pmd_mkwrite(pmd_mkdirty(entry), vma);
<span class="p_chunk">@@ -1837,14 +1849,13 @@</span> <span class="p_context"> fail_putback:</span>
 	set_pmd_at(mm, mmun_start, pmd, entry);
 	update_mmu_cache_pmd(vma, address, &amp;entry);
 
<span class="p_del">-	if (page_count(page) != 2) {</span>
<span class="p_del">-		set_pmd_at(mm, mmun_start, pmd, orig_entry);</span>
<span class="p_del">-		flush_pmd_tlb_range(vma, mmun_start, mmun_end);</span>
<span class="p_del">-		mmu_notifier_invalidate_range(mm, mmun_start, mmun_end);</span>
<span class="p_del">-		update_mmu_cache_pmd(vma, address, &amp;entry);</span>
<span class="p_del">-		page_remove_rmap(new_page, true);</span>
<span class="p_del">-		goto fail_putback;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* As said above no one can get reference on the old page nor through</span>
<span class="p_add">+	 * get_user_pages or get_user_pages_fast (GUP/GUP_fast) or through</span>
<span class="p_add">+	 * any other means. To get reference on huge page you need to hold</span>
<span class="p_add">+	 * pmd_lock and we are already holding that lock here and the page</span>
<span class="p_add">+	 * is only mapped once.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUG_ON(page_count(page) != 2);</span>
 
 	mlock_migrate_page(new_page, page);
 	page_remove_rmap(page, true);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



