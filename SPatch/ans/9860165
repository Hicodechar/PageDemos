
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,Part1,v3,14/17] x86/boot: Add early boot support when running with SEV active - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,Part1,v3,14/17] x86/boot: Add early boot support when running with SEV active</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=150921">Brijesh Singh</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 24, 2017, 7:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170724190757.11278-15-brijesh.singh@amd.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9860165/mbox/"
   >mbox</a>
|
   <a href="/patch/9860165/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9860165/">/patch/9860165/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3745B60349 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 24 Jul 2017 19:15:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 282BB27E71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 24 Jul 2017 19:15:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1C8FA28558; Mon, 24 Jul 2017 19:15:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2376D27E71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 24 Jul 2017 19:15:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753893AbdGXTPb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 24 Jul 2017 15:15:31 -0400
Received: from mail-sn1nam01on0078.outbound.protection.outlook.com
	([104.47.32.78]:14752
	&quot;EHLO NAM01-SN1-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1756351AbdGXTLU (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 24 Jul 2017 15:11:20 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=TGM62Fi+vyy0j8H+gBjAWJv92ARTJsztvZLhbznqguc=;
	b=hqzA0VfdtE3PWFYsccyl9uOkkRxO4K8dNJm5KmecxqkhUPhKb71sHTwtt1CAwPJ7PwVp0/AWcRCmNYAZlV61hrpaHujdusoxFzK+xCNkFSPv9r/E8kDfMgPNGqbkY/R6SwB5AZsYkc+t7yI/DnsmBb7d+XgmJjJWrP04Dwit7bk=
Authentication-Results: spf=none (sender IP is )
	smtp.mailfrom=brijesh.singh@amd.com; 
Received: from ubuntu-010236106000.amd.com (165.204.78.1) by
	CY1PR12MB0150.namprd12.prod.outlook.com (10.161.173.20) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1282.10; Mon, 24 Jul 2017 19:08:39 +0000
From: Brijesh Singh &lt;brijesh.singh@amd.com&gt;
To: linux-kernel@vger.kernel.org, x86@kernel.org,
	linux-efi@vger.kernel.org, linuxppc-dev@lists.ozlabs.org,
	kvm@vger.kernel.org
Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	&quot;H . Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Borislav Petkov &lt;bp@suse.de&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, Tony Luck &lt;tony.luck@intel.com&gt;,
	Piotr Luc &lt;piotr.luc@intel.com&gt;, Tom Lendacky &lt;thomas.lendacky@amd.com&gt;,
	Fenghua Yu &lt;fenghua.yu@intel.com&gt;, Lu Baolu &lt;baolu.lu@linux.intel.com&gt;,
	Reza Arbab &lt;arbab@linux.vnet.ibm.com&gt;,
	David Howells &lt;dhowells@redhat.com&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	&quot;Kirill A . Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	Laura Abbott &lt;labbott@redhat.com&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Eric Biederman &lt;ebiederm@xmission.com&gt;,
	Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;,
	Paul Mackerras &lt;paulus@samba.org&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Jonathan Corbet &lt;corbet@lwn.net&gt;, Dave Airlie &lt;airlied@redhat.com&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, Paolo Bonzini &lt;pbonzini@redhat.com&gt;,
	=?UTF-8?q?Radim=20Kr=C4=8Dm=C3=A1=C5=99?= &lt;rkrcmar@redhat.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;, Tejun Heo &lt;tj@kernel.org&gt;,
	Christoph Lameter &lt;cl@linux.com&gt;, Brijesh Singh &lt;brijesh.singh@amd.com&gt;
Subject: [RFC Part1 PATCH v3 14/17] x86/boot: Add early boot support when
	running with SEV active
Date: Mon, 24 Jul 2017 14:07:54 -0500
Message-Id: &lt;20170724190757.11278-15-brijesh.singh@amd.com&gt;
X-Mailer: git-send-email 2.9.4
In-Reply-To: &lt;20170724190757.11278-1-brijesh.singh@amd.com&gt;
References: &lt;20170724190757.11278-1-brijesh.singh@amd.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [165.204.78.1]
X-ClientProxiedBy: CY4PR04CA0049.namprd04.prod.outlook.com (10.171.243.142)
	To CY1PR12MB0150.namprd12.prod.outlook.com (10.161.173.20)
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 3c4b05fa-2c71-44ec-0553-08d4d2c7653e
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(300000500095)(300135000095)(300000501095)(300135300095)(22001)(300000502095)(300135100095)(48565401081)(300000503095)(300135400095)(201703131423075)(201703031133081)(300000504095)(300135200095)(300000505095)(300135600095)(300000506095)(300135500095);
	SRVR:CY1PR12MB0150; 
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	3:Wq0TNCjlHBD9RQjPr72xJjlDQB+q0/W7aJYDzCLCChtLoMNHvlz8AXIVgLpm33cRUJ0WuR944ZS+SadQ2YTlheb/+V8HT8iJGJeadjCsGC1q2VOJ4huxxV24pt2E2aVle/T9jI2TU0scBFi4HvQevv5tSCT3YfZmookG2UQOZsUCB+lXdMhHs83jk/JZnk/MlnCf8j6+sTB/McrznjZX+gIKKYCNbdgpwLFR66hbLcUaKL64iSOy5INc9QpXudeV38k+LOYQ4SS8kAVk3SaHERdEuPagI/oRFC5nC1vM+FBXkgz61ajtKFZl4+mKkZzvjBrS7hO+Ql3Z6qt9/V0I8wJWUYgG3P48U5dBZHEDwfgCQbo9iBUl/2LANbzzRXDsd9jCnLhWuUK7PEj4+nDWW4wl6Br/rpjfEsu39xjXIgj8xzusAcSMOYIUO2YuM/xcWeqtvD2rVFjdELElYhLxCqJnNIry2GtaClfkRdwd7HGWrbvfXb/UHHyP0kR7KdtsWAXyB5RQ67AcSZKuPuXYhg+Ayxa456osn9GNYYZ0SHZ+d2VYJPGLqOJFOz7F6tDTeUhGcTKaFpq1cMSW4Vxkg7yg9Vh2ziWkfKrYTlgzZGWMK+sSOk8iUdfQrgonPOuz6R8nj69StaOfnoraD8yuT86BIp4Dhs4ZDh0ek/Z6xZF06dp8gzG3Fb6UtTNPe3ufmQr1b8qjiI4gk1NLItXNvCbZ5CL9cQmGixS9n4mbzPOTkYdw+LJy6vny4yw6yin1oY7myl9W/uJQYDzxFudNqQ==
X-MS-TrafficTypeDiagnostic: CY1PR12MB0150:
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	25:BFMk5OiA907A9U402x8khImw4iOAHPJvgPG2MrHem1OAvgBSdBa1dmzLHh5XNWhTk6sKC2lL+PQItNNcI3ie+4oH+oF0cHXkY4cA+MZIgm7ZSPTtPK0sAe5nTtg7y+Ya3yHnxa3ii1JOm06QoJaCWTLCtOef6gN+YMd17Q8Ee9Ce/g1LQzTcTn1zaR2NPrcKS1Xaizncl4xs0U120liSyDQ9UnLSY9eWtUjyGo8/GJ6pQ8mvWQbFR7YGbnxyXk3x0XMGDkR5xb9hgh90OovDi9NltfkYAisUdY5QMNQYT62lZ+DlqvxbRcQD4QsIjA+fWvLbFe/UV8Qc7DVmKUsjSeWHzUtSx7/ZHo5Ar8qXyXkyU1b/4UMaSOgdzQynABNkcvTFFlMNcofKup6lLhqHgzLZx+yrKaNUX/OSoTEZBNiXEKBaUvKsZNApz5K83qaRjwsEw2Y/l7EWnaURh7znKRSe9OBoYrB7iZbhOnvvILacnqGf3N3YUXIg8+L1HROcXML9ZZbnRnrkm4mf5BY0MumlfkomuwexDr6EbVdxOeq9V9CRplKX7sYqCiJR5PDWimBN59xn7nAnjySnCDxIupELjPiAOf0LgC8XWCxKiSZ6W4yxnJOczjbx4w0JlVxO26IDWFGfBXC96gGfHD06Uuo4+mfbSIds0vr1WTBilEfwe4GKkmfwkKgC1c3arG1okVhp224KvA9gZGPiVsVR7/QmdmjoG17dR56gwVqaYtvQIg2pJK9dydxmv/kLYXM9qCPOkjsGV2IHC+vs8/5PI4nUamdV8mi8xA874KaZG3u54thFO8go+tvb8kvPwfxGOG+7zmHVRVbd8Hlbi/R09wlkEjwioa5d4rEr5cijEXgCCvjFWckrYjhX4yuCJusDFoW9ZRY+NqrY1m/NAh8dEu0QkrYpZG0SLDQ1AV2hr
	Y8=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	31:rAp4YysNYRIXdsJJ1CoEVKXQlWItJXkr9zWXDnLyiJ+pSOu3N6x9HCcL6jS+fEQzKboVtfvCPqB6R+zOjRTNlbrAqejjyh1WahBZCzPOzd/tBHS4LFHaTyHU3+MWYa2CyyAqY1io3c/+yR6auK1ZYnNk0Crp+4e+DZ7k3egFORwzglLqbR0kGZoxLI4hFQvMKKoTcyXdHXTJIhYhDdMcgr7nswNCZXVtgesvJK7EWhmkW/zW9vPe0GQ9TtKhmQf3C3M/mZuN03CepvFEoXerFE+omM79ck9/PODgcwcVi6usk2VkMhhl5gT3Cwb7HHVyA9j7Pwj1vCxuiS5vrcib9UDi5LIEVSWJvlJ/BySGiJH084y+tZ7qh/Baav04ucY1dhgymYYoYyQgT14M9WGlOIqbL8DNHFwdoznT+QBtaF+L7D4JxJkQJ/+tzg/SYP4iZdHuhIL2W3bhG2qRSeJqcGBaaEwEXxBEO03XqvG6Ws2pNPJ1FpcTkHYDuyiqkUOGm1tc543MNFMFfX9KkEUqkFC0JbAbbAcSE1SPh4GGuYKm8otybQLSJYYdDl/ZiYEB5ehpGKWGoQOQJ9Em2UU7t/LRW5byGPfYRg0L6x/O7OVU8A0DkkDh896O8+UeZ2KNOiVCMJEsE5O0X2JlLUmxG6AWsY5zXy/LMGkH8Cre1Ug=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	20:Z3ppGPb4nMKFRjps0AFC0wgAB/3f/iROqFZ3ixi602YwkuQp7geoKt1TlGLL7rMRAVIH90nGhIQWUyIpAg+FOfqD9cCfPTRyLvvIw5uy9LrGVc1OdC3RuDr7BOP4KSruqsZgfkaEkB9ViEx1OWORnZXfI0Nf6gJWh+IxoC2HeZVecmwpo4La6ErTn6fyU6EdRzaDUKip7Qn4sxUACDuw6xTB/zCdgJwOEhjukJ/6yJF0joRunVVP+q/tVmP9fQs69+MuytWiBf549Qvzu18ULiwvLUeyXmifUD2lYV6RsX5avpzOSGzRiZnoYtoi0br2WYwb9+qKcUMEgwrykxytchohBnIJnZSNFdBcENfhixEJTrcpFZrI/a9jscy+7+T5vUib5F9NszmCYHx4T//PMFfxiKH5A5eHGGRWPNQEddJ1Ls53sMtP1gZs0g4V1OLe2UlYoEfyYBFhIu1RfZ5assPFkBt8S93Ke7gOXYAP+PJhZgBT4ql4GZomII6mRmGo
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Microsoft-Antispam-PRVS: &lt;CY1PR12MB0150973F0809CE4F9E7F050EE5BB0@CY1PR12MB0150.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(6040450)(601004)(2401047)(8121501046)(5005006)(93006095)(93001095)(10201501046)(100000703101)(100105400095)(3002001)(6055026)(6041248)(20161123564025)(20161123555025)(20161123560025)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123558100)(20161123562025)(6072148)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:CY1PR12MB0150; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:CY1PR12MB0150; 
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR12MB0150;
	4:5nx2Ze9mnlcUb89JP1BcOBsTKi3xZB+iim0VrY116+?=
	=?us-ascii?Q?b6TktMxxqz/iTJPFIa6NL22pP0rxUXYJXsDY3QBKyxZl8nug1Gk+bPpk8Wkn?=
	=?us-ascii?Q?QD7wWVSs7wzBbo5oUwp5AIbjMuCOYW37McL2FQZ1LgvoRwnxLhv5WIpAhiQw?=
	=?us-ascii?Q?9IheTo+VQ1ZyqLeAk3v4AwwRSLKFH4dC4OAqqQ4IMISbuFuYLxB3n5w9FuCB?=
	=?us-ascii?Q?5vdXbfoBTHHjoeagNUYvLkuE1KkHiuinpY4VpzPk6LaNJkPdKnAC0P+aweL3?=
	=?us-ascii?Q?ispM9T19twVconYUmDR/twryepWhL0cTnCJlL2MA+HaI1z+Rx95WZ3CaqhEy?=
	=?us-ascii?Q?EWOnXUndtYxtmLn4mddyVIph1k9c0/5HVXeS6UUyKinwmS7jII58KmsQUPcd?=
	=?us-ascii?Q?KSTyo7KDAg+RgK9GWraBwAigftPjm8wM695KzgWiRFplPQXZUmzkRYGlSreM?=
	=?us-ascii?Q?Ocy5c2zUvmYsiPz1kmCUyjub2bycIhqVa2nKp6EdTZ/4l2w56hmeL4G5DyJs?=
	=?us-ascii?Q?aoCdPC27WodvbDNb6SI5iKi92ajw414ZS8WQ662ZljPLO1aQRSH2/ebnu9tY?=
	=?us-ascii?Q?GkT6SkGU0C89S4gPOS5064qtNX8i9CEZC+Vx5bTaMDb9TIRkz2g3j0r3HGEn?=
	=?us-ascii?Q?vFZv/up+znY23quTWx6tXDi1E3r06xTBc34XMLynn9gyw/Nv3smrz/FgG/VF?=
	=?us-ascii?Q?qzohtPmavmVVMgG6yUydx5MCP8e4LZthvxmEkWtkJO8wM1mD/EjD3qhQsXr0?=
	=?us-ascii?Q?eFNwBEJYhn/OLZG5Wi7/ywMBZQ/sN4N5Rdhgls5wq1x21R1NBQ/oWqmuvHsA?=
	=?us-ascii?Q?B7yn0ZlieTE2qkaNZE0TINg6cjCAV2eVxQlR6L0qS/YCcGQVijBDzLVHNRD1?=
	=?us-ascii?Q?Nzjcy59bJH2618pJ+FP2/pkNRLjahehDVaQWPEf2SaW8gjSxYH4kt2oIys06?=
	=?us-ascii?Q?Fii4x71YXCqOO0VgGhHOP/tSzheB5rN6etzoFAhXmvIWPtnPObCKqhWXPFFU?=
	=?us-ascii?Q?Hm86hrx5hYBRuhyejO+8CWG0wq+DeL6GtmcP5w6WIo6Oj1y4MMbL7KTMLZgc?=
	=?us-ascii?Q?0UwK+m77zTD3Dv5Ar9oZKHsitpHr8Beud3h904UJvb4+vzgTC0ScBpaM+vdG?=
	=?us-ascii?Q?ItvfgiIfifEwDfVWLoV0GD1hDzZS0wyHz/jSAb7UspKyfDZYCutjO5X1AvX3?=
	=?us-ascii?Q?jQ6X6cdacZnuq0S4W46Vvqf2D0kMfto+h9?=
X-Forefront-PRVS: 0378F1E47A
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(7370300001)(6009001)(39840400002)(39850400002)(39450400003)(39400400002)(39410400002)(39860400002)(199003)(189002)(4326008)(81156014)(7350300001)(81166006)(50226002)(50466002)(68736007)(36756003)(38730400002)(1076002)(110136004)(53936002)(6116002)(25786009)(48376002)(575784001)(8676002)(86362001)(305945005)(54906002)(7736002)(2950100002)(6666003)(50986999)(101416001)(47776003)(105586002)(5660300001)(5003940100001)(7416002)(33646002)(106356001)(66066001)(6486002)(7406005)(97736004)(189998001)(3846002)(76176999)(2906002)(53416004)(42186005)(478600001)(2004002);
	DIR:OUT; SFP:1101; SCL:1; SRVR:CY1PR12MB0150;
	H:ubuntu-010236106000.amd.com; FPR:; SPF:None;
	PTR:InfoNoRecords; A:1; MX:1; LANG:en; 
Received-SPF: None (protection.outlook.com: amd.com does not designate
	permitted sender hosts)
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR12MB0150;
	23:wnIXDRWr333pdevr1iniuBLH2UKAE1ceJBP5DT/9r?=
	=?us-ascii?Q?zgmdLaz4ybzu6FYO/l1lsgfN0BIi2TLqt5JJaPDcT0EgQNg5Vt7wzXoL2tpX?=
	=?us-ascii?Q?mN+E0Q1CpuA9iMKfV/QrHIgTE3nv0QlE+1uF6NKDmkb4/xJWyZuEwBW7kYNv?=
	=?us-ascii?Q?FfKCUlU9PJnNFSWv6eQBXzMbyFIGQLrsK4x5zp6d6lSatM+ptN6QrRfU3F3k?=
	=?us-ascii?Q?VUxInpjwJmzFPUV2Z3dn5UJp+a4dDbQsffKDIIf0Tma0vYhTw/onf2lB6aL7?=
	=?us-ascii?Q?nzwgfIbJi/VrrZkZ8FqvjrkoByFLVV5z9cPrhJg3vkkFp40OiPCUBfFnoV4C?=
	=?us-ascii?Q?v5cGcIigo6Q41VVNKNDlwu7Pyn48wGPcTQ+wbVci5omGRuWHu9RNnS/tGShC?=
	=?us-ascii?Q?YKr/TMNsBtc/kZIKUmZjY6lmmeUdaEUePLwUkYaOliE0RAtopMwYbMX3of/F?=
	=?us-ascii?Q?+P3rhbKgEukjWGbH23yUYsec6UyjTZkdgpsuBsKzUw1v/uBJZ9Pbn1OBUKt6?=
	=?us-ascii?Q?fw3SwrbanA2X6LxYyoPCRFxJKZN4uDVYbhcmPKGRKMpzyeJwR67YXMOnRmDH?=
	=?us-ascii?Q?8iCzGA9BuKpOO4VVRpATGkZsjIWUAriBOf/zT8tEwrzLdgbnBdmd6Z3dgSc8?=
	=?us-ascii?Q?cNMe3libf8bXAhMph6/u5o7wkPLIHWcZ9tvEyFzY9GOzx08DCbCIbwfyAbm3?=
	=?us-ascii?Q?gnfiNaangxd8IKLFhcuCarRvRSeM8ZagJVga4ZNLiUWJuLZQR333DHDWbrDZ?=
	=?us-ascii?Q?leJAPsdZJ6pr1JxANHfqALnOmNT+C3oNVU5+8lWfIsESudvA4ui+x8Fj/+tD?=
	=?us-ascii?Q?+H1fjVVG30vJ91mqwp6TcK15oBRC7jc6YGOZjBG1syOq9ymRN/eZx7+6oq1q?=
	=?us-ascii?Q?DWs3h3iLgbCB24vIRI0PnGxi2ko1xO1pD6Ohl4X+pHfuACG0WJjAgqBmbhK6?=
	=?us-ascii?Q?FNAt+v3U8pPUXmxm/8zdV/+PBEU/ZCTvMlmLphCkQfKbL42uUnAZUU1UbSxj?=
	=?us-ascii?Q?b2hAEEwlrXIN1S71WcKCNDIm8TEw1wgsIMWDy5itKS6J41oOAttdvpUWCQc5?=
	=?us-ascii?Q?ozNiaY3jGChTMvcGtlgq1D40cArzBUHQcXpWDA3799x0ZTPQBBP116/fx8h8?=
	=?us-ascii?Q?nak/o5PYudU+b0rI6l8aYmeTV6AdSgfCcUxu+8wP3nxJbFLZGqOaJrCmhM5a?=
	=?us-ascii?Q?2mYu9K0NNsqbwE1aheRjjikyQKjlE77Q4w5hwFLG0rmfSi3oRvcwpUFNXGEJ?=
	=?us-ascii?Q?ZmZPAzcmMYvErxA6j6zC/kGMLRm44pzvcVQ2SxOb2rd4OYg26H2dw9KWIUY0?=
	=?us-ascii?Q?T84I+MFP2KdgCSzRSFQ521BGHUOKZcTlt82+OIaIeRJAHBxqC/ZmFkAnIyHZ?=
	=?us-ascii?Q?xJ0LA=3D=3D?=
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR12MB0150;
	6:LiMM3p2+fkmTHJz27Lr+oDs69l/OLSndHVqGPYUYnZ?=
	=?us-ascii?Q?imYEgDXlCMbUj3Elnk+CFg5kbcW9x6yduEYFMtRwQZEh3/8SwRYodxf3O7B9?=
	=?us-ascii?Q?xMuiqJEZ2gkYkRWcaEQpi8wHeeRvRZtPah58JvfUuP9gItktC0hl1+56/zJK?=
	=?us-ascii?Q?ZP7RKYZ0Z8vdifzYHKFpYLJKgjwyfoXFOqj4tt9CsNh3qybBuM8PPEG8vo/d?=
	=?us-ascii?Q?ZJ+2T52w8MOI2DENrmAbpd7d9sFVSJMP8+558LOrxvMXQg3kwvSd2r3Bix6b?=
	=?us-ascii?Q?19JIpiLzFX+Xk2BNzFjPQae0azeARY65pliqrBc4p4T6h9NMPjUSdWvdWEDr?=
	=?us-ascii?Q?+82H6Vu4lDcO31uBFf34BaOCKC+rbwNMOAZe6XvNoQMhnSV0V+xTZqJIEDv/?=
	=?us-ascii?Q?WBWQVBzRLEf6ZSljs7Wnd/7aflJIadDcAabZZX0bF97fvxOTflJyeOrzj9Hh?=
	=?us-ascii?Q?yC2iHJpobuP1EKoU0ISKOdUGEqTnQyoE8SoG6SvmoEatm4u8iWS7lLi7Z/+E?=
	=?us-ascii?Q?MQdllsvUv3kB2sazXwrMp41WEzTicfKfIhH0u1egtqHt+n4MhC63pce4mysf?=
	=?us-ascii?Q?5vbXw/AxD6EqTRWz2v4JsvWeAAPZRUjhFkyOHpNdV9G2y6b/0p1KJtR/YwVn?=
	=?us-ascii?Q?OxmkWipygOlVwu3XE/Op7nF18BOBA+G1YpNVG9O9vGicotGc3EWwKyogg8nZ?=
	=?us-ascii?Q?4k66SiDKkhXWsEmtVpLAs6zl+ilApj/fawi3FoFg702rOq2+ZXxOdNoj+82j?=
	=?us-ascii?Q?UFRAPGQjhohoGTsReXHbqZuaqhcWzBpqrajNS651m5GT0nZQyZrE58uD0ERs?=
	=?us-ascii?Q?/bB+mOLxJlbvowWStAy7mr9yXdjJtJrlw0+PMr3i6CF3RvoKtNYnb5Mll846?=
	=?us-ascii?Q?5TDBwcQfDLWkLZrcBUu37OEvmAbbZnQW6hKbIQOZgvS4rWa0CQE9UTq0KWeS?=
	=?us-ascii?Q?nVahfF6wb83HYjoDGE8Noe6qKQLnXH5jeVTOBGlGXcCBO+lLV+8jysmZ94vo?=
	=?us-ascii?Q?DObaxLWv6AjUgH3m0xaaHR?=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	5:20FqVSlNrgUuS25kX8H1cI49H6b/abiBWR/yArR7lYUO6ENmG62vX+4tIL8ZSQp9u46eoZjQjMX3p0gfwMv012k+wZcpHUeRalZcYBrzJXL95LuEPSwl1qciDcLtrrDjR1/efINdl6LGa1Dje5KZPAtWFbPyyLiGUs1xEtLzvr0bjmolf4sl6O3a/9BrLPbw9IbwJrQKczTKFfSWhaqFtHnXTM/otM6lR/JeRnE4vG8H0aZTT52uXQPJPYysOaehpSJOnoT81W9p/Jb+xQv2f4Kp01JyPdC+YbubERdwgpWbqzJp6frygofJ0V4E5RF5GPLLGLyxVJ5tX7YVJSnKZm2M7fL9HhiVkLW5JVyt2OKDlUorKMZGpK7DMmRNErhw6BN4yez56buIRFe9TnClEjPaheMUiDSoP7Uflfpy/MAVbvxhG4xfZnJgeT0ZS/XfFKwCe3Xlqk8McoLT09QGBmvsRvIjijslL0bIb8upG2AN/3k4vcJqBp2YDmyn9ynZ;
	24:YXJl+MY2WgAS4FbUwcfDeizT4uzeTczAdb2Z+oP+lQ8B/l26Qif7GxNIqYAQrZ+JzwjJ+tjz5ZQBmKih4+YfIUJDijB7XO1LZYIWk8ZAYns=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	7:aaoLM9bBmFGUstC6gH2hISMv/qKxZ/rt8+ljfbhd8IsEvVffJ4J+1b+ebtsrUvjmxtuQC0g4QqO0jUsDP8RmhBlIG4xZgALsVtzP6ZicKc03CYKL42DXYwT5GNuapdUsCkumzC8zjng2Jc0whqNlxEplGDOt1Aj4vu/Edne0bd9onnmGfbQpMXYDNwDuWSH1sT4VkkSKjzrqlT3yP9IIU0Ga8MA306cUBTLm052exsP8H1w1EpzfZ7vHGdCVJS1PO671J9b2RlZ/Ehgd9/LjhuSJIKfU7NX0PRWF3iprcnw1CE/+HgQmc56T2CbOJUfNbhzpnzRg14koO/c7N5diDqUgvvBpDWv87pYU2YC+UoOl6S3IDuPKKERhAEOMAnTlhejgVVWSkX/SR+Faes1kX7ho+q0slF9BtGdUC8aOWBRSHlgH5BejdrMv747RVssDe8ooWw5tqGqFw1Os6olWeTr3vJgy7upU2QcfAPbr+K8svoCVvLwzNNsfAVqFUWSAMVmOWVPl47NiFEkTSnXN4g93LC+xiNMIDLSsb/ibPE+yQcEKJYCgpvh8ahV33ZcWxuAyIowIGa2HD9gOBxy/GRNe2+hcs9HHMMDP0PJhG/ZmOV5frkt2W4dYOj43clRWzjN0SZIwc7FZHyMslbOve9ADIHYBaa0s23I/0NSOBuFz6gsZWgWw/iJStwtBIKxTAOudNY2hZQVX8oYrU5sZuweZZ4rztTgjgkBQz4zAhuHylGxBPetXNX2cBXqFJzrALpfp8IoEvbcogabNow86Ts7uSYqczMvGQeIqp3+9Zoo=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR12MB0150;
	20:jHRU7e4hZd0k+8FylWc5lvk75ssF8HXJcxCORv6AoXyGD1VJpD0xNPvWUO9QGcP89f9k4kR5RMuuLxqjHYbSf9SR2lPO5Yuv74Oz/mOdjA61IXuhUv3mehWZfmz7uxkI6Do1v+eq78MjO5mIB8Fqr0ZlfGYdNSSxbc3FVjQQZzl/p+67HKJofkrUygBriaceWU4k6s3Cnv1HFG60XDGA30xuHwKDJ7578WpK0jhHrdDRhaM/dW4+kQh5PD/Qrn5L
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 24 Jul 2017 19:08:39.0283
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY1PR12MB0150
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=150921">Brijesh Singh</a> - July 24, 2017, 7:07 p.m.</div>
<pre class="content">
<span class="from">From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>

Early in the boot process, add checks to determine if the kernel is
running with Secure Encrypted Virtualization (SEV) active.

Checking for SEV requires checking that the kernel is running under a
hypervisor (CPUID 0x00000001, bit 31), that the SEV feature is available
(CPUID 0x8000001f, bit 1) and then check a non-interceptable SEV MSR
(0xc0010131, bit 0).

This check is required so that during early compressed kernel booting the
pagetables (both the boot pagetables and KASLR pagetables (if enabled) are
updated to include the encryption mask so that when the kernel is
decompressed into encrypted memory.

After the kernel is decompressed and continues booting the same logic is
used to check if SEV is active and set a flag indicating so.  This allows
us to distinguish between SME and SEV, each of which have unique
differences in how certain things are handled: e.g. DMA (always bounce
buffered with SEV) or EFI tables (always access decrypted with SME).
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Brijesh Singh &lt;brijesh.singh@amd.com&gt;</span>
---
 arch/x86/boot/compressed/Makefile      |   2 +
 arch/x86/boot/compressed/head_64.S     |  16 +++++
 arch/x86/boot/compressed/mem_encrypt.S | 103 +++++++++++++++++++++++++++++++++
 arch/x86/boot/compressed/misc.h        |   2 +
 arch/x86/boot/compressed/pagetable.c   |   8 ++-
 arch/x86/include/asm/mem_encrypt.h     |   3 +
 arch/x86/include/asm/msr-index.h       |   3 +
 arch/x86/include/uapi/asm/kvm_para.h   |   1 -
 arch/x86/mm/mem_encrypt.c              |  42 +++++++++++---
 9 files changed, 169 insertions(+), 11 deletions(-)
 create mode 100644 arch/x86/boot/compressed/mem_encrypt.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - Aug. 23, 2017, 3:30 p.m.</div>
<pre class="content">
On Mon, Jul 24, 2017 at 02:07:54PM -0500, Brijesh Singh wrote:
<span class="quote">&gt; From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Early in the boot process, add checks to determine if the kernel is</span>
<span class="quote">&gt; running with Secure Encrypted Virtualization (SEV) active.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Checking for SEV requires checking that the kernel is running under a</span>
<span class="quote">&gt; hypervisor (CPUID 0x00000001, bit 31), that the SEV feature is available</span>
<span class="quote">&gt; (CPUID 0x8000001f, bit 1) and then check a non-interceptable SEV MSR</span>
<span class="quote">&gt; (0xc0010131, bit 0).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This check is required so that during early compressed kernel booting the</span>
<span class="quote">&gt; pagetables (both the boot pagetables and KASLR pagetables (if enabled) are</span>
<span class="quote">&gt; updated to include the encryption mask so that when the kernel is</span>
<span class="quote">&gt; decompressed into encrypted memory.</span>

				    , it can boot properly.

:)
<span class="quote">
&gt; After the kernel is decompressed and continues booting the same logic is</span>
<span class="quote">&gt; used to check if SEV is active and set a flag indicating so.  This allows</span>
<span class="quote">&gt; us to distinguish between SME and SEV, each of which have unique</span>
<span class="quote">&gt; differences in how certain things are handled: e.g. DMA (always bounce</span>
<span class="quote">&gt; buffered with SEV) or EFI tables (always access decrypted with SME).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Brijesh Singh &lt;brijesh.singh@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/boot/compressed/Makefile      |   2 +</span>
<span class="quote">&gt;  arch/x86/boot/compressed/head_64.S     |  16 +++++</span>
<span class="quote">&gt;  arch/x86/boot/compressed/mem_encrypt.S | 103 +++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/x86/boot/compressed/misc.h        |   2 +</span>
<span class="quote">&gt;  arch/x86/boot/compressed/pagetable.c   |   8 ++-</span>
<span class="quote">&gt;  arch/x86/include/asm/mem_encrypt.h     |   3 +</span>
<span class="quote">&gt;  arch/x86/include/asm/msr-index.h       |   3 +</span>
<span class="quote">&gt;  arch/x86/include/uapi/asm/kvm_para.h   |   1 -</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c              |  42 +++++++++++---</span>
<span class="quote">&gt;  9 files changed, 169 insertions(+), 11 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 arch/x86/boot/compressed/mem_encrypt.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt; index 2c860ad..d2fe901 100644</span>
<span class="quote">&gt; --- a/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt; +++ b/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt; @@ -72,6 +72,8 @@ vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \</span>
<span class="quote">&gt;  	$(obj)/string.o $(obj)/cmdline.o $(obj)/error.o \</span>
<span class="quote">&gt;  	$(obj)/piggy.o $(obj)/cpuflags.o</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +vmlinux-objs-$(CONFIG_X86_64) += $(obj)/mem_encrypt.o</span>

There&#39;s a

ifdef CONFIG_X86_64

a couple of lines below. Just put it there.

...
<span class="quote">
&gt; +++ b/arch/x86/boot/compressed/mem_encrypt.S</span>
<span class="quote">&gt; @@ -0,0 +1,103 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * AMD Memory Encryption Support</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2017 Advanced Micro Devices, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/msr.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/asm-offsets.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.text</span>
<span class="quote">&gt; +	.code32</span>
<span class="quote">&gt; +ENTRY(get_sev_encryption_bit)</span>
<span class="quote">&gt; +	xor	%eax, %eax</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt; +	push	%ebx</span>
<span class="quote">&gt; +	push	%ecx</span>
<span class="quote">&gt; +	push	%edx</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Check if running under a hypervisor */</span>
<span class="quote">&gt; +	movl	$1, %eax</span>
<span class="quote">&gt; +	cpuid</span>
<span class="quote">&gt; +	bt	$31, %ecx		/* Check the hypervisor bit */</span>
<span class="quote">&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movl	$0x80000000, %eax	/* CPUID to check the highest leaf */</span>
<span class="quote">&gt; +	cpuid</span>
<span class="quote">&gt; +	cmpl	$0x8000001f, %eax	/* See if 0x8000001f is available */</span>
<span class="quote">&gt; +	jb	.Lno_sev</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Check for the SEV feature:</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	movl	$0x8000001f, %eax</span>
<span class="quote">&gt; +	cpuid</span>
<span class="quote">&gt; +	bt	$1, %eax		/* Check if SEV is available */</span>
<span class="quote">&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movl	$MSR_F17H_SEV, %ecx	/* Read the SEV MSR */</span>
<span class="quote">&gt; +	rdmsr</span>
<span class="quote">&gt; +	bt	$MSR_F17H_SEV_ENABLED_BIT, %eax	/* Check if SEV is active */</span>
<span class="quote">&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Get memory encryption information:</span>
<span class="quote">&gt; +	 */</span>

The side-comment is enough. This one above can go.
<span class="quote">
&gt; +	movl	%ebx, %eax</span>
<span class="quote">&gt; +	andl	$0x3f, %eax		/* Return the encryption bit location */</span>
<span class="quote">&gt; +	jmp	.Lsev_exit</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lno_sev:</span>
<span class="quote">&gt; +	xor	%eax, %eax</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lsev_exit:</span>
<span class="quote">&gt; +	pop	%edx</span>
<span class="quote">&gt; +	pop	%ecx</span>
<span class="quote">&gt; +	pop	%ebx</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#endif	/* CONFIG_AMD_MEM_ENCRYPT */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret</span>
<span class="quote">&gt; +ENDPROC(get_sev_encryption_bit)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.code64</span>
<span class="quote">&gt; +ENTRY(get_sev_encryption_mask)</span>
<span class="quote">&gt; +	xor	%rax, %rax</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt; +	push	%rbp</span>
<span class="quote">&gt; +	push	%rdx</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	call	get_sev_encryption_bit	/* Get the encryption bit position */</span>

So we get to call get_sev_encryption_bit() here again and noodle through
the CPUID discovery and MSR access. We should instead cache that info
and return the encryption bit directly on a second call. (And initialize
it to -1 to denote that get_sev_encryption_bit() hasn&#39;t run yet).

...
<span class="quote">
&gt; diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; index 9274ec7..9cb6472 100644</span>
<span class="quote">&gt; --- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; @@ -19,6 +19,9 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/bootparam.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define AMD_SME_FEATURE_BIT	BIT(0)</span>
<span class="quote">&gt; +#define AMD_SEV_FEATURE_BIT	BIT(1)</span>

s/_FEATURE//

AMD_SME_BIT and AMD_SEV_BIT is good enough :)

And frankly, if you&#39;re going to use them only below in sme_enable() - I
need to check more thoroughly the remaining patches - but if you only
are going to use them there, just define them inside the function so
that they&#39;re close.
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  #ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern unsigned long sme_me_mask;</span>
<span class="quote">&gt; diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt; index e399d68..530020f 100644</span>
<span class="quote">&gt; --- a/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt; @@ -326,6 +326,9 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Fam 17h MSRs */</span>
<span class="quote">&gt;  #define MSR_F17H_IRPERF			0xc00000e9</span>
<span class="quote">&gt; +#define MSR_F17H_SEV			0xc0010131</span>

If that MSR is going to be used later on - and I don&#39;t see why not - you
probably should make it an arch one: MSR_AMD64_SEV. Even if it isn&#39;t yet
officially. :-)
<span class="quote">
&gt; +#define MSR_F17H_SEV_ENABLED_BIT	0</span>
<span class="quote">&gt; +#define MSR_F17H_SEV_ENABLED		BIT_ULL(MSR_F17H_SEV_ENABLED_BIT)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Fam 16h MSRs */</span>
<span class="quote">&gt;  #define MSR_F16H_L2I_PERF_CTL		0xc0010230</span>
<span class="quote">&gt; diff --git a/arch/x86/include/uapi/asm/kvm_para.h b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt; index a965e5b..c202ba3 100644</span>
<span class="quote">&gt; --- a/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt; @@ -109,5 +109,4 @@ struct kvm_vcpu_pv_apf_data {</span>
<span class="quote">&gt;  #define KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK</span>
<span class="quote">&gt;  #define KVM_PV_EOI_DISABLED 0x0</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #endif /* _UAPI_ASM_X86_KVM_PARA_H */</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; index 5e5d460..ed8780e 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; @@ -288,7 +288,9 @@ void __init mem_encrypt_init(void)</span>
<span class="quote">&gt;  	if (sev_active())</span>
<span class="quote">&gt;  		dma_ops = &amp;sme_dma_ops;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);</span>
<span class="quote">&gt; +	pr_info(&quot;AMD %s active\n&quot;,</span>
<span class="quote">&gt; +		sev_active() ? &quot;Secure Encrypted Virtualization (SEV)&quot;</span>
<span class="quote">&gt; +			     : &quot;Secure Memory Encryption (SME)&quot;);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="quote">&gt; @@ -616,12 +618,23 @@ void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt;  	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt; +	unsigned long feature_mask;</span>
<span class="quote">&gt;  	bool active_by_default;</span>
<span class="quote">&gt;  	unsigned long me_mask;</span>
<span class="quote">&gt;  	char buffer[16];</span>
<span class="quote">&gt;  	u64 msr;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	/* Check for the SME support leaf */</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Set the feature mask (SME or SEV) based on whether we are</span>
<span class="quote">&gt; +	 * running under a hypervisor.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	eax = 1;</span>
<span class="quote">&gt; +	ecx = 0;</span>
<span class="quote">&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; +	feature_mask = (ecx &amp; BIT(31)) ? AMD_SEV_FEATURE_BIT</span>
<span class="quote">&gt; +				       : AMD_SME_FEATURE_BIT;</span>

Set that feature mask before using it...
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	/* Check for the SME/SEV support leaf */</span>

... because if that check exits due to no SME leaf, you&#39;re uselessly
doing all the above.
<span class="quote">
&gt;  	eax = 0x80000000;</span>
<span class="quote">&gt;  	ecx = 0;</span>
<span class="quote">&gt;  	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; @@ -629,24 +642,39 @@ void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt; -	 * Check for the SME feature:</span>
<span class="quote">&gt; +	 * Check for the SME/SEV feature:</span>
<span class="quote">&gt;  	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt;  	 *     Secure Memory Encryption support</span>
<span class="quote">&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>

No need to repeat the CPUID leaf here - only Bit 1:

         *   CPUID Fn8000_001F[EAX]
	 * - Bit 0:  Secure Memory Encryption support
         * - Bit 1:  Secure Encrypted Virtualization support
<span class="quote">

&gt; +	 *     Secure Encrypted Virtualization support</span>
<span class="quote">&gt;  	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt;  	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	eax = 0x8000001f;</span>
<span class="quote">&gt;  	ecx = 0;</span>
<span class="quote">&gt;  	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt; -	if (!(eax &amp; 1))</span>
<span class="quote">&gt; +	if (!(eax &amp; feature_mask))</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	/* Check if SME is enabled */</span>
<span class="quote">&gt; -	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt; -	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt; +	/* Check if memory encryption is enabled */</span>
<span class="quote">&gt; +	if (feature_mask == AMD_SME_FEATURE_BIT) {</span>
<span class="quote">&gt; +		/* For SME, check the SYSCFG MSR */</span>
<span class="quote">&gt; +		msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt; +		if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt; +			return;</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		/* For SEV, check the SEV MSR */</span>
<span class="quote">&gt; +		msr = __rdmsr(MSR_F17H_SEV);</span>
<span class="quote">&gt; +		if (!(msr &amp; MSR_F17H_SEV_ENABLED))</span>
<span class="quote">&gt; +			return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		/* SEV state cannot be controlled by a command line option */</span>
<span class="quote">&gt; +		sme_me_mask = me_mask;</span>
<span class="quote">&gt; +		sev_enabled = 1;</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt; +	}</span>

Nice. Two birds with one stone is always better. :)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - Aug. 24, 2017, 6:54 p.m.</div>
<pre class="content">
On 8/23/2017 10:30 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Mon, Jul 24, 2017 at 02:07:54PM -0500, Brijesh Singh wrote:</span>
<span class="quote">&gt;&gt; From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Early in the boot process, add checks to determine if the kernel is</span>
<span class="quote">&gt;&gt; running with Secure Encrypted Virtualization (SEV) active.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Checking for SEV requires checking that the kernel is running under a</span>
<span class="quote">&gt;&gt; hypervisor (CPUID 0x00000001, bit 31), that the SEV feature is available</span>
<span class="quote">&gt;&gt; (CPUID 0x8000001f, bit 1) and then check a non-interceptable SEV MSR</span>
<span class="quote">&gt;&gt; (0xc0010131, bit 0).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This check is required so that during early compressed kernel booting the</span>
<span class="quote">&gt;&gt; pagetables (both the boot pagetables and KASLR pagetables (if enabled) are</span>
<span class="quote">&gt;&gt; updated to include the encryption mask so that when the kernel is</span>
<span class="quote">&gt;&gt; decompressed into encrypted memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 				    , it can boot properly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; :)</span>
<span class="quote">&gt; </span>

Yup, kinda didn&#39;t complete that sentence.
<span class="quote">
&gt;&gt; After the kernel is decompressed and continues booting the same logic is</span>
<span class="quote">&gt;&gt; used to check if SEV is active and set a flag indicating so.  This allows</span>
<span class="quote">&gt;&gt; us to distinguish between SME and SEV, each of which have unique</span>
<span class="quote">&gt;&gt; differences in how certain things are handled: e.g. DMA (always bounce</span>
<span class="quote">&gt;&gt; buffered with SEV) or EFI tables (always access decrypted with SME).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Brijesh Singh &lt;brijesh.singh@amd.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;   arch/x86/boot/compressed/Makefile      |   2 +</span>
<span class="quote">&gt;&gt;   arch/x86/boot/compressed/head_64.S     |  16 +++++</span>
<span class="quote">&gt;&gt;   arch/x86/boot/compressed/mem_encrypt.S | 103 +++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;   arch/x86/boot/compressed/misc.h        |   2 +</span>
<span class="quote">&gt;&gt;   arch/x86/boot/compressed/pagetable.c   |   8 ++-</span>
<span class="quote">&gt;&gt;   arch/x86/include/asm/mem_encrypt.h     |   3 +</span>
<span class="quote">&gt;&gt;   arch/x86/include/asm/msr-index.h       |   3 +</span>
<span class="quote">&gt;&gt;   arch/x86/include/uapi/asm/kvm_para.h   |   1 -</span>
<span class="quote">&gt;&gt;   arch/x86/mm/mem_encrypt.c              |  42 +++++++++++---</span>
<span class="quote">&gt;&gt;   9 files changed, 169 insertions(+), 11 deletions(-)</span>
<span class="quote">&gt;&gt;   create mode 100644 arch/x86/boot/compressed/mem_encrypt.S</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt;&gt; index 2c860ad..d2fe901 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/boot/compressed/Makefile</span>
<span class="quote">&gt;&gt; @@ -72,6 +72,8 @@ vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \</span>
<span class="quote">&gt;&gt;   	$(obj)/string.o $(obj)/cmdline.o $(obj)/error.o \</span>
<span class="quote">&gt;&gt;   	$(obj)/piggy.o $(obj)/cpuflags.o</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; +vmlinux-objs-$(CONFIG_X86_64) += $(obj)/mem_encrypt.o</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There&#39;s a</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ifdef CONFIG_X86_64</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; a couple of lines below. Just put it there.</span>

Will do.
<span class="quote">
&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; +++ b/arch/x86/boot/compressed/mem_encrypt.S</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,103 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * AMD Memory Encryption Support</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2017 Advanced Micro Devices, Inc.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt;&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt;&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/msr.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/asm-offsets.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	.text</span>
<span class="quote">&gt;&gt; +	.code32</span>
<span class="quote">&gt;&gt; +ENTRY(get_sev_encryption_bit)</span>
<span class="quote">&gt;&gt; +	xor	%eax, %eax</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt;&gt; +	push	%ebx</span>
<span class="quote">&gt;&gt; +	push	%ecx</span>
<span class="quote">&gt;&gt; +	push	%edx</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check if running under a hypervisor */</span>
<span class="quote">&gt;&gt; +	movl	$1, %eax</span>
<span class="quote">&gt;&gt; +	cpuid</span>
<span class="quote">&gt;&gt; +	bt	$31, %ecx		/* Check the hypervisor bit */</span>
<span class="quote">&gt;&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movl	$0x80000000, %eax	/* CPUID to check the highest leaf */</span>
<span class="quote">&gt;&gt; +	cpuid</span>
<span class="quote">&gt;&gt; +	cmpl	$0x8000001f, %eax	/* See if 0x8000001f is available */</span>
<span class="quote">&gt;&gt; +	jb	.Lno_sev</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Check for the SEV feature:</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt;&gt; +	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	movl	$0x8000001f, %eax</span>
<span class="quote">&gt;&gt; +	cpuid</span>
<span class="quote">&gt;&gt; +	bt	$1, %eax		/* Check if SEV is available */</span>
<span class="quote">&gt;&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movl	$MSR_F17H_SEV, %ecx	/* Read the SEV MSR */</span>
<span class="quote">&gt;&gt; +	rdmsr</span>
<span class="quote">&gt;&gt; +	bt	$MSR_F17H_SEV_ENABLED_BIT, %eax	/* Check if SEV is active */</span>
<span class="quote">&gt;&gt; +	jnc	.Lno_sev</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Get memory encryption information:</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The side-comment is enough. This one above can go.</span>

Done.
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; +	movl	%ebx, %eax</span>
<span class="quote">&gt;&gt; +	andl	$0x3f, %eax		/* Return the encryption bit location */</span>
<span class="quote">&gt;&gt; +	jmp	.Lsev_exit</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +.Lno_sev:</span>
<span class="quote">&gt;&gt; +	xor	%eax, %eax</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +.Lsev_exit:</span>
<span class="quote">&gt;&gt; +	pop	%edx</span>
<span class="quote">&gt;&gt; +	pop	%ecx</span>
<span class="quote">&gt;&gt; +	pop	%ebx</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#endif	/* CONFIG_AMD_MEM_ENCRYPT */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	ret</span>
<span class="quote">&gt;&gt; +ENDPROC(get_sev_encryption_bit)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	.code64</span>
<span class="quote">&gt;&gt; +ENTRY(get_sev_encryption_mask)</span>
<span class="quote">&gt;&gt; +	xor	%rax, %rax</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt;&gt; +	push	%rbp</span>
<span class="quote">&gt;&gt; +	push	%rdx</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	call	get_sev_encryption_bit	/* Get the encryption bit position */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So we get to call get_sev_encryption_bit() here again and noodle through</span>
<span class="quote">&gt; the CPUID discovery and MSR access. We should instead cache that info</span>
<span class="quote">&gt; and return the encryption bit directly on a second call. (And initialize</span>
<span class="quote">&gt; it to -1 to denote that get_sev_encryption_bit() hasn&#39;t run yet).</span>

Ok, I&#39;ll look into that optimization.
<span class="quote">
&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; index 9274ec7..9cb6472 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; @@ -19,6 +19,9 @@</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   #include &lt;asm/bootparam.h&gt;</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; +#define AMD_SME_FEATURE_BIT	BIT(0)</span>
<span class="quote">&gt;&gt; +#define AMD_SEV_FEATURE_BIT	BIT(1)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; s/_FEATURE//</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; AMD_SME_BIT and AMD_SEV_BIT is good enough :)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And frankly, if you&#39;re going to use them only below in sme_enable() - I</span>
<span class="quote">&gt; need to check more thoroughly the remaining patches - but if you only</span>
<span class="quote">&gt; are going to use them there, just define them inside the function so</span>
<span class="quote">&gt; that they&#39;re close.</span>

Sounds good. I believe that is the only place they are/will be used
so I&#39;ll make that change.
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;   #ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   extern unsigned long sme_me_mask;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt;&gt; index e399d68..530020f 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/include/asm/msr-index.h</span>
<span class="quote">&gt;&gt; @@ -326,6 +326,9 @@</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   /* Fam 17h MSRs */</span>
<span class="quote">&gt;&gt;   #define MSR_F17H_IRPERF			0xc00000e9</span>
<span class="quote">&gt;&gt; +#define MSR_F17H_SEV			0xc0010131</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If that MSR is going to be used later on - and I don&#39;t see why not - you</span>
<span class="quote">&gt; probably should make it an arch one: MSR_AMD64_SEV. Even if it isn&#39;t yet</span>
<span class="quote">&gt; officially. :-)</span>
<span class="quote">&gt; </span>

Will do.
<span class="quote">
&gt;&gt; +#define MSR_F17H_SEV_ENABLED_BIT	0</span>
<span class="quote">&gt;&gt; +#define MSR_F17H_SEV_ENABLED		BIT_ULL(MSR_F17H_SEV_ENABLED_BIT)</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   /* Fam 16h MSRs */</span>
<span class="quote">&gt;&gt;   #define MSR_F16H_L2I_PERF_CTL		0xc0010230</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/include/uapi/asm/kvm_para.h b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt;&gt; index a965e5b..c202ba3 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="quote">&gt;&gt; @@ -109,5 +109,4 @@ struct kvm_vcpu_pv_apf_data {</span>
<span class="quote">&gt;&gt;   #define KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK</span>
<span class="quote">&gt;&gt;   #define KVM_PV_EOI_DISABLED 0x0</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; -</span>
<span class="quote">&gt;&gt;   #endif /* _UAPI_ASM_X86_KVM_PARA_H */</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; index 5e5d460..ed8780e 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; @@ -288,7 +288,9 @@ void __init mem_encrypt_init(void)</span>
<span class="quote">&gt;&gt;   	if (sev_active())</span>
<span class="quote">&gt;&gt;   		dma_ops = &amp;sme_dma_ops;</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; -	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);</span>
<span class="quote">&gt;&gt; +	pr_info(&quot;AMD %s active\n&quot;,</span>
<span class="quote">&gt;&gt; +		sev_active() ? &quot;Secure Encrypted Virtualization (SEV)&quot;</span>
<span class="quote">&gt;&gt; +			     : &quot;Secure Memory Encryption (SME)&quot;);</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="quote">&gt;&gt; @@ -616,12 +618,23 @@ void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;   	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;</span>
<span class="quote">&gt;&gt;   	unsigned int eax, ebx, ecx, edx;</span>
<span class="quote">&gt;&gt; +	unsigned long feature_mask;</span>
<span class="quote">&gt;&gt;   	bool active_by_default;</span>
<span class="quote">&gt;&gt;   	unsigned long me_mask;</span>
<span class="quote">&gt;&gt;   	char buffer[16];</span>
<span class="quote">&gt;&gt;   	u64 msr;</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; -	/* Check for the SME support leaf */</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Set the feature mask (SME or SEV) based on whether we are</span>
<span class="quote">&gt;&gt; +	 * running under a hypervisor.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	eax = 1;</span>
<span class="quote">&gt;&gt; +	ecx = 0;</span>
<span class="quote">&gt;&gt; +	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; +	feature_mask = (ecx &amp; BIT(31)) ? AMD_SEV_FEATURE_BIT</span>
<span class="quote">&gt;&gt; +				       : AMD_SME_FEATURE_BIT;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Set that feature mask before using it...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Check for the SME/SEV support leaf */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ... because if that check exits due to no SME leaf, you&#39;re uselessly</span>
<span class="quote">&gt; doing all the above.</span>

Ok, I&#39;ll move that down after the leaf check.
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt;   	eax = 0x80000000;</span>
<span class="quote">&gt;&gt;   	ecx = 0;</span>
<span class="quote">&gt;&gt;   	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; @@ -629,24 +642,39 @@ void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
<span class="quote">&gt;&gt;   		return;</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   	/*</span>
<span class="quote">&gt;&gt; -	 * Check for the SME feature:</span>
<span class="quote">&gt;&gt; +	 * Check for the SME/SEV feature:</span>
<span class="quote">&gt;&gt;   	 *   CPUID Fn8000_001F[EAX] - Bit 0</span>
<span class="quote">&gt;&gt;   	 *     Secure Memory Encryption support</span>
<span class="quote">&gt;&gt; +	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; No need to repeat the CPUID leaf here - only Bit 1:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;           *   CPUID Fn8000_001F[EAX]</span>
<span class="quote">&gt; 	 * - Bit 0:  Secure Memory Encryption support</span>
<span class="quote">&gt;           * - Bit 1:  Secure Encrypted Virtualization support</span>
<span class="quote">&gt; </span>

Ok, I&#39;ll clean that up.

Thanks,
Tom
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; +	 *     Secure Encrypted Virtualization support</span>
<span class="quote">&gt;&gt;   	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="quote">&gt;&gt;   	 *     Pagetable bit position used to indicate encryption</span>
<span class="quote">&gt;&gt;   	 */</span>
<span class="quote">&gt;&gt;   	eax = 0x8000001f;</span>
<span class="quote">&gt;&gt;   	ecx = 0;</span>
<span class="quote">&gt;&gt;   	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="quote">&gt;&gt; -	if (!(eax &amp; 1))</span>
<span class="quote">&gt;&gt; +	if (!(eax &amp; feature_mask))</span>
<span class="quote">&gt;&gt;   		return;</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt;   	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);</span>
<span class="quote">&gt;&gt;   </span>
<span class="quote">&gt;&gt; -	/* Check if SME is enabled */</span>
<span class="quote">&gt;&gt; -	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt;&gt; -	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt;&gt; +	/* Check if memory encryption is enabled */</span>
<span class="quote">&gt;&gt; +	if (feature_mask == AMD_SME_FEATURE_BIT) {</span>
<span class="quote">&gt;&gt; +		/* For SME, check the SYSCFG MSR */</span>
<span class="quote">&gt;&gt; +		msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="quote">&gt;&gt; +		if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="quote">&gt;&gt; +			return;</span>
<span class="quote">&gt;&gt; +	} else {</span>
<span class="quote">&gt;&gt; +		/* For SEV, check the SEV MSR */</span>
<span class="quote">&gt;&gt; +		msr = __rdmsr(MSR_F17H_SEV);</span>
<span class="quote">&gt;&gt; +		if (!(msr &amp; MSR_F17H_SEV_ENABLED))</span>
<span class="quote">&gt;&gt; +			return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		/* SEV state cannot be controlled by a command line option */</span>
<span class="quote">&gt;&gt; +		sme_me_mask = me_mask;</span>
<span class="quote">&gt;&gt; +		sev_enabled = 1;</span>
<span class="quote">&gt;&gt;   		return;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nice. Two birds with one stone is always better. :)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=57321">Borislav Petkov</a> - Aug. 25, 2017, 12:54 p.m.</div>
<pre class="content">
Btw,

I don&#39;t see our SEV-specific chicken bit which disables SEV only.

Do we need it? If so, maybe something like

mem_encrypt=sme_only

or so.

Or is the mem_encrypt=off chicken bit enough?

What about the use case where you want SME but no encrypted guests?

A bunch of hmmm.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/boot/compressed/Makefile b/arch/x86/boot/compressed/Makefile</span>
<span class="p_header">index 2c860ad..d2fe901 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/Makefile</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/Makefile</span>
<span class="p_chunk">@@ -72,6 +72,8 @@</span> <span class="p_context"> vmlinux-objs-y := $(obj)/vmlinux.lds $(obj)/head_$(BITS).o $(obj)/misc.o \</span>
 	$(obj)/string.o $(obj)/cmdline.o $(obj)/error.o \
 	$(obj)/piggy.o $(obj)/cpuflags.o
 
<span class="p_add">+vmlinux-objs-$(CONFIG_X86_64) += $(obj)/mem_encrypt.o</span>
<span class="p_add">+</span>
 vmlinux-objs-$(CONFIG_EARLY_PRINTK) += $(obj)/early_serial_console.o
 vmlinux-objs-$(CONFIG_RANDOMIZE_BASE) += $(obj)/kaslr.o
 ifdef CONFIG_X86_64
<span class="p_header">diff --git a/arch/x86/boot/compressed/head_64.S b/arch/x86/boot/compressed/head_64.S</span>
<span class="p_header">index fbf4c32..6179d43 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/head_64.S</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/head_64.S</span>
<span class="p_chunk">@@ -130,6 +130,19 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
  /*
   * Build early 4G boot pagetable
   */
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If SEV is active then set the encryption mask in the page tables.</span>
<span class="p_add">+	 * This will insure that when the kernel is copied and decompressed</span>
<span class="p_add">+	 * it will be done so encrypted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	call	get_sev_encryption_bit</span>
<span class="p_add">+	xorl	%edx, %edx</span>
<span class="p_add">+	testl	%eax, %eax</span>
<span class="p_add">+	jz	1f</span>
<span class="p_add">+	subl	$32, %eax	/* Encryption bit is always above bit 31 */</span>
<span class="p_add">+	bts	%eax, %edx	/* Set encryption mask for page tables */</span>
<span class="p_add">+1:</span>
<span class="p_add">+</span>
 	/* Initialize Page tables to 0 */
 	leal	pgtable(%ebx), %edi
 	xorl	%eax, %eax
<span class="p_chunk">@@ -140,12 +153,14 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
 	leal	pgtable + 0(%ebx), %edi
 	leal	0x1007 (%edi), %eax
 	movl	%eax, 0(%edi)
<span class="p_add">+	addl	%edx, 4(%edi)</span>
 
 	/* Build Level 3 */
 	leal	pgtable + 0x1000(%ebx), %edi
 	leal	0x1007(%edi), %eax
 	movl	$4, %ecx
 1:	movl	%eax, 0x00(%edi)
<span class="p_add">+	addl	%edx, 0x04(%edi)</span>
 	addl	$0x00001000, %eax
 	addl	$8, %edi
 	decl	%ecx
<span class="p_chunk">@@ -156,6 +171,7 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
 	movl	$0x00000183, %eax
 	movl	$2048, %ecx
 1:	movl	%eax, 0(%edi)
<span class="p_add">+	addl	%edx, 4(%edi)</span>
 	addl	$0x00200000, %eax
 	addl	$8, %edi
 	decl	%ecx
<span class="p_header">diff --git a/arch/x86/boot/compressed/mem_encrypt.S b/arch/x86/boot/compressed/mem_encrypt.S</span>
new file mode 100644
<span class="p_header">index 0000000..696716e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/mem_encrypt.S</span>
<span class="p_chunk">@@ -0,0 +1,103 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * AMD Memory Encryption Support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2017 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.code32</span>
<span class="p_add">+ENTRY(get_sev_encryption_bit)</span>
<span class="p_add">+	xor	%eax, %eax</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="p_add">+	push	%ebx</span>
<span class="p_add">+	push	%ecx</span>
<span class="p_add">+	push	%edx</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if running under a hypervisor */</span>
<span class="p_add">+	movl	$1, %eax</span>
<span class="p_add">+	cpuid</span>
<span class="p_add">+	bt	$31, %ecx		/* Check the hypervisor bit */</span>
<span class="p_add">+	jnc	.Lno_sev</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	$0x80000000, %eax	/* CPUID to check the highest leaf */</span>
<span class="p_add">+	cpuid</span>
<span class="p_add">+	cmpl	$0x8000001f, %eax	/* See if 0x8000001f is available */</span>
<span class="p_add">+	jb	.Lno_sev</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for the SEV feature:</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>
<span class="p_add">+	 *   CPUID Fn8000_001F[EBX] - Bits 5:0</span>
<span class="p_add">+	 *     Pagetable bit position used to indicate encryption</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	movl	$0x8000001f, %eax</span>
<span class="p_add">+	cpuid</span>
<span class="p_add">+	bt	$1, %eax		/* Check if SEV is available */</span>
<span class="p_add">+	jnc	.Lno_sev</span>
<span class="p_add">+</span>
<span class="p_add">+	movl	$MSR_F17H_SEV, %ecx	/* Read the SEV MSR */</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	bt	$MSR_F17H_SEV_ENABLED_BIT, %eax	/* Check if SEV is active */</span>
<span class="p_add">+	jnc	.Lno_sev</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Get memory encryption information:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	movl	%ebx, %eax</span>
<span class="p_add">+	andl	$0x3f, %eax		/* Return the encryption bit location */</span>
<span class="p_add">+	jmp	.Lsev_exit</span>
<span class="p_add">+</span>
<span class="p_add">+.Lno_sev:</span>
<span class="p_add">+	xor	%eax, %eax</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsev_exit:</span>
<span class="p_add">+	pop	%edx</span>
<span class="p_add">+	pop	%ecx</span>
<span class="p_add">+	pop	%ebx</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* CONFIG_AMD_MEM_ENCRYPT */</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(get_sev_encryption_bit)</span>
<span class="p_add">+</span>
<span class="p_add">+	.code64</span>
<span class="p_add">+ENTRY(get_sev_encryption_mask)</span>
<span class="p_add">+	xor	%rax, %rax</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_AMD_MEM_ENCRYPT</span>
<span class="p_add">+	push	%rbp</span>
<span class="p_add">+	push	%rdx</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+	call	get_sev_encryption_bit	/* Get the encryption bit position */</span>
<span class="p_add">+	testl	%eax, %eax</span>
<span class="p_add">+	jz	.Lno_sev_mask</span>
<span class="p_add">+</span>
<span class="p_add">+	xor	%rdx, %rdx</span>
<span class="p_add">+	bts	%rax, %rdx		/* Create the encryption mask */</span>
<span class="p_add">+	mov	%rdx, %rax		/* ... and return it */</span>
<span class="p_add">+</span>
<span class="p_add">+.Lno_sev_mask:</span>
<span class="p_add">+	movq	%rbp, %rsp		/* Restore original stack pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	%rdx</span>
<span class="p_add">+	pop	%rbp</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(get_sev_encryption_mask)</span>
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.h b/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">index 766a521..38c5f0e 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.h</span>
<span class="p_chunk">@@ -108,4 +108,6 @@</span> <span class="p_context"> static inline void console_init(void)</span>
 { }
 #endif
 
<span class="p_add">+unsigned long get_sev_encryption_mask(void);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/x86/boot/compressed/pagetable.c b/arch/x86/boot/compressed/pagetable.c</span>
<span class="p_header">index f1aa438..a577329 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/pagetable.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/pagetable.c</span>
<span class="p_chunk">@@ -76,16 +76,18 @@</span> <span class="p_context"> static unsigned long top_level_pgt;</span>
  * Mapping information structure passed to kernel_ident_mapping_init().
  * Due to relocation, pointers must be assigned at run time not build time.
  */
<span class="p_del">-static struct x86_mapping_info mapping_info = {</span>
<span class="p_del">-	.page_flag       = __PAGE_KERNEL_LARGE_EXEC,</span>
<span class="p_del">-};</span>
<span class="p_add">+static struct x86_mapping_info mapping_info;</span>
 
 /* Locates and clears a region for a new top level page table. */
 void initialize_identity_maps(void)
 {
<span class="p_add">+	unsigned long sev_me_mask = get_sev_encryption_mask();</span>
<span class="p_add">+</span>
 	/* Init mapping_info with run-time function/buffer pointers. */
 	mapping_info.alloc_pgt_page = alloc_pgt_page;
 	mapping_info.context = &amp;pgt_data;
<span class="p_add">+	mapping_info.page_flag = __PAGE_KERNEL_LARGE_EXEC | sev_me_mask;</span>
<span class="p_add">+	mapping_info.kernpg_flag = _KERNPG_TABLE | sev_me_mask;</span>
 
 	/*
 	 * It should be impossible for this not to already be true,
<span class="p_header">diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">index 9274ec7..9cb6472 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_chunk">@@ -19,6 +19,9 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/bootparam.h&gt;
 
<span class="p_add">+#define AMD_SME_FEATURE_BIT	BIT(0)</span>
<span class="p_add">+#define AMD_SEV_FEATURE_BIT	BIT(1)</span>
<span class="p_add">+</span>
 #ifdef CONFIG_AMD_MEM_ENCRYPT
 
 extern unsigned long sme_me_mask;
<span class="p_header">diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h</span>
<span class="p_header">index e399d68..530020f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/msr-index.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/msr-index.h</span>
<span class="p_chunk">@@ -326,6 +326,9 @@</span> <span class="p_context"></span>
 
 /* Fam 17h MSRs */
 #define MSR_F17H_IRPERF			0xc00000e9
<span class="p_add">+#define MSR_F17H_SEV			0xc0010131</span>
<span class="p_add">+#define MSR_F17H_SEV_ENABLED_BIT	0</span>
<span class="p_add">+#define MSR_F17H_SEV_ENABLED		BIT_ULL(MSR_F17H_SEV_ENABLED_BIT)</span>
 
 /* Fam 16h MSRs */
 #define MSR_F16H_L2I_PERF_CTL		0xc0010230
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/kvm_para.h b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="p_header">index a965e5b..c202ba3 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/kvm_para.h</span>
<span class="p_chunk">@@ -109,5 +109,4 @@</span> <span class="p_context"> struct kvm_vcpu_pv_apf_data {</span>
 #define KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK
 #define KVM_PV_EOI_DISABLED 0x0
 
<span class="p_del">-</span>
 #endif /* _UAPI_ASM_X86_KVM_PARA_H */
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index 5e5d460..ed8780e 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -288,7 +288,9 @@</span> <span class="p_context"> void __init mem_encrypt_init(void)</span>
 	if (sev_active())
 		dma_ops = &amp;sme_dma_ops;
 
<span class="p_del">-	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);</span>
<span class="p_add">+	pr_info(&quot;AMD %s active\n&quot;,</span>
<span class="p_add">+		sev_active() ? &quot;Secure Encrypted Virtualization (SEV)&quot;</span>
<span class="p_add">+			     : &quot;Secure Memory Encryption (SME)&quot;);</span>
 }
 
 void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)
<span class="p_chunk">@@ -616,12 +618,23 @@</span> <span class="p_context"> void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
 {
 	const char *cmdline_ptr, *cmdline_arg, *cmdline_on, *cmdline_off;
 	unsigned int eax, ebx, ecx, edx;
<span class="p_add">+	unsigned long feature_mask;</span>
 	bool active_by_default;
 	unsigned long me_mask;
 	char buffer[16];
 	u64 msr;
 
<span class="p_del">-	/* Check for the SME support leaf */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the feature mask (SME or SEV) based on whether we are</span>
<span class="p_add">+	 * running under a hypervisor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	eax = 1;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	feature_mask = (ecx &amp; BIT(31)) ? AMD_SEV_FEATURE_BIT</span>
<span class="p_add">+				       : AMD_SME_FEATURE_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check for the SME/SEV support leaf */</span>
 	eax = 0x80000000;
 	ecx = 0;
 	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
<span class="p_chunk">@@ -629,24 +642,39 @@</span> <span class="p_context"> void __init __nostackprotector sme_enable(struct boot_params *bp)</span>
 		return;
 
 	/*
<span class="p_del">-	 * Check for the SME feature:</span>
<span class="p_add">+	 * Check for the SME/SEV feature:</span>
 	 *   CPUID Fn8000_001F[EAX] - Bit 0
 	 *     Secure Memory Encryption support
<span class="p_add">+	 *   CPUID Fn8000_001F[EAX] - Bit 1</span>
<span class="p_add">+	 *     Secure Encrypted Virtualization support</span>
 	 *   CPUID Fn8000_001F[EBX] - Bits 5:0
 	 *     Pagetable bit position used to indicate encryption
 	 */
 	eax = 0x8000001f;
 	ecx = 0;
 	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
<span class="p_del">-	if (!(eax &amp; 1))</span>
<span class="p_add">+	if (!(eax &amp; feature_mask))</span>
 		return;
 
 	me_mask = 1UL &lt;&lt; (ebx &amp; 0x3f);
 
<span class="p_del">-	/* Check if SME is enabled */</span>
<span class="p_del">-	msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="p_del">-	if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="p_add">+	/* Check if memory encryption is enabled */</span>
<span class="p_add">+	if (feature_mask == AMD_SME_FEATURE_BIT) {</span>
<span class="p_add">+		/* For SME, check the SYSCFG MSR */</span>
<span class="p_add">+		msr = __rdmsr(MSR_K8_SYSCFG);</span>
<span class="p_add">+		if (!(msr &amp; MSR_K8_SYSCFG_MEM_ENCRYPT))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* For SEV, check the SEV MSR */</span>
<span class="p_add">+		msr = __rdmsr(MSR_F17H_SEV);</span>
<span class="p_add">+		if (!(msr &amp; MSR_F17H_SEV_ENABLED))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* SEV state cannot be controlled by a command line option */</span>
<span class="p_add">+		sme_me_mask = me_mask;</span>
<span class="p_add">+		sev_enabled = 1;</span>
 		return;
<span class="p_add">+	}</span>
 
 	/*
 	 * Fixups have not been applied to phys_base yet and we&#39;re running

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



