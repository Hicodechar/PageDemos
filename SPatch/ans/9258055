
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,4/5] powerpc/pm: support deep sleep feature on T104x - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,4/5] powerpc/pm: support deep sleep feature on T104x</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=161471">Chenhui Zhao</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 2, 2016, 11:59 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1470139172-12699-5-git-send-email-chenhui.zhao@nxp.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9258055/mbox/"
   >mbox</a>
|
   <a href="/patch/9258055/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9258055/">/patch/9258055/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	416026077C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Aug 2016 15:12:35 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 30FB827CF9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Aug 2016 15:12:35 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2563C28529; Tue,  2 Aug 2016 15:12:35 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4581A28346
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  2 Aug 2016 15:12:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756684AbcHBPMX (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 2 Aug 2016 11:12:23 -0400
Received: from mail-bn3nam01on0085.outbound.protection.outlook.com
	([104.47.33.85]:59744
	&quot;EHLO NAM01-BN3-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S965092AbcHBMfJ (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 2 Aug 2016 08:35:09 -0400
Received: from BN6PR03CA0038.namprd03.prod.outlook.com (10.175.124.24) by
	CY1PR0301MB0698.namprd03.prod.outlook.com (10.160.159.140) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384) id 15.1.549.15;
	Tue, 2 Aug 2016 12:00:15 +0000
Received: from BL2FFO11FD040.protection.gbl (2a01:111:f400:7c09::183) by
	BN6PR03CA0038.outlook.office365.com (2603:10b6:404:10c::24) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384) id 15.1.549.15 via
	Frontend Transport; Tue, 2 Aug 2016 12:00:15 +0000
Authentication-Results: spf=fail (sender IP is 192.88.158.2)
	smtp.mailfrom=nxp.com; nxp.com; dkim=none (message not signed)
	header.d=none; nxp.com; dmarc=fail action=none header.from=nxp.com;
	nxp.com; 
	dkim=none (message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of nxp.com does not
	designate 192.88.158.2 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.158.2; helo=az84smr01.freescale.net;
Received: from az84smr01.freescale.net (192.88.158.2) by
	BL2FFO11FD040.mail.protection.outlook.com (10.173.161.136) with
	Microsoft
	SMTP Server (version=TLS1_0, cipher=TLS_RSA_WITH_AES_256_CBC_SHA) id
	15.1.549.5 via Frontend Transport; Tue, 2 Aug 2016 12:00:12 +0000
Received: from localhost.localdomain ([10.193.20.174])
	by az84smr01.freescale.net (8.14.3/8.14.0) with ESMTP id
	u72BxpRT032590; Tue, 2 Aug 2016 05:00:08 -0700
From: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;
To: &lt;oss@buserror.net&gt;, &lt;linuxppc-dev@lists.ozlabs.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;
CC: &lt;jason.jin@nxp.com&gt;, &lt;z.chenhui@gmail.com&gt;,
	Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;
Subject: [PATCH v3 4/5] powerpc/pm: support deep sleep feature on T104x
Date: Tue, 2 Aug 2016 19:59:31 +0800
Message-ID: &lt;1470139172-12699-5-git-send-email-chenhui.zhao@nxp.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1470139172-12699-1-git-send-email-chenhui.zhao@nxp.com&gt;
References: &lt;1470139172-12699-1-git-send-email-chenhui.zhao@nxp.com&gt;
X-EOPAttributedMessage: 0
X-Matching-Connectors: 131146128147176837;
	(91ab9b29-cfa4-454e-5278-08d120cd25b8); ()
X-Forefront-Antispam-Report: CIP:192.88.158.2; IPV:NLI; CTRY:US; EFV:NLI;
	SFV:NSPM;
	SFS:(10009020)(979002)(6009001)(7916002)(2980300002)(1109001)(1110001)(339900001)(189002)(199003)(106466001)(189998001)(8666005)(33646002)(4326007)(356003)(19580395003)(36756003)(2906002)(92566002)(229853001)(68736007)(76176999)(50986999)(19580405001)(586003)(5001770100001)(69596002)(7846002)(104016004)(11100500001)(305945005)(97736004)(5003940100001)(85426001)(50226002)(86362001)(77096005)(2950100001)(575784001)(105606002)(48376002)(2201001)(47776003)(50466002)(49486002)(87936001)(8936002)(81166006)(81156014)(8676002)(7059030)(2004002)(2101003)(969003)(989001)(999001)(1009001)(1019001);
	DIR:OUT; SFP:1101; SCL:1; SRVR:CY1PR0301MB0698;
	H:az84smr01.freescale.net; FPR:; SPF:Fail;
	PTR:InfoDomainNonexistent; MX:1; A:1; LANG:en; 
X-Microsoft-Exchange-Diagnostics: 1; BL2FFO11FD040;
	1:vuEEoWVM74Te2ELZJ8ELa5Y9S+bB64DxTPQ6rc1JHwZOExV6ohGYGosMrMrR1/Uto6kCanAc7MyOCoVzNI2ySaXlm/nd5JQTi7EEUvEc2iG/3n2/AOYL4CIsfjLF47LZhmq1duj49EWWjkxVC6BYWWS25uABu3hWsg97rZe+MsI6NgJUdnrp5v/yyWJsUyV+Ie/gw/vTdnEu0ZsoCLLTBm0lZUy8S/8zf7tci1umOS7jaWMiYHbL5To98iiDv/pHOAfkYswhTEF0k6X0F5TRpj1qzh8E0irWJ1Gu/SM3q81VgXr/ou3r7CQAPWYTvbWSWO4ynNexxLsiIMbWlGshC4Bg0kIs8y7ZDlVZjN0W9CANEcNo5vX23bF1kZfaPHWvUN8znl07P2/2dzg7ixmQmRgBOUZFFm+VG1kZR7uoi4qry6voT6WbUKUxbkiUcwptXfqUikMWOK4ZR8uL2SHutwY3+OXgQviHDZ8Cw5E2cH1Llz8fAhqjFBvioJctg0ezvp060MxDNHDVxmLck/aBDGsbPLiOFbVsscpdtRb9eabbP6OR+jdF905eH4uuB9ERE9zY9tvwLninQ25OXVueo4CLJoeCEJOJu6o+VKorAjD55HThi0ivQiku1lNQGPV3ejFw2WDeXcRXh+pcCEQYO/3VFXCOzfGXVFKOL/GdEBBtUYL63a3+pZto77hlFZBZ/AuHm5dA+YR0AwetcsPdjSIZg5cFk2zmpfk1K8AaMos=
MIME-Version: 1.0
Content-Type: text/plain
X-MS-Office365-Filtering-Correlation-Id: 0717ebb2-657a-414e-fc23-08d3bacc9055
X-Microsoft-Exchange-Diagnostics: 1; CY1PR0301MB0698;
	2:iseqmOxyt3W9MQJHEYeH+z6sWC1uwJoPvkTf/mAdARsYQWO+ERMKL4FQn/aXFfPS9Atb/s3B5NccQjoZj3VO0wuDC5vZ3xYd0GPzh7psYCZaqZAu3Rv3v6woruGRJ7tkJb6r0RuNgTvbSUeyuBNjtqKmKwLWVp1ugVCEGY9s8UdwFrubw75Ul5qP+fmanfXS;
	3:xVXvkOLJwl7sqKDrTcpWQhQodzY9pr9LH3zxgsp3FjXLciiKH5FDdrbPWDzOCz8UXg7qGFEq4hQJefo1KLyriyTiT8JXnLgYgNkyVrpDTFl0WZPk/ZokgjokOrMfaI8mh96mjZZmgxOYa98x+mFmHuRmHcTDaJFpG95LOCsQ2qaICZIAG6JXKKp1qfy4Jq9eWLNrVw44JFYeaqG8Pnsr8b0qeT1HOQ9LwvZE7MyU14g=
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:CY1PR0301MB0698;
X-Microsoft-Exchange-Diagnostics: 1; CY1PR0301MB0698;
	25:/XTHs4uc2eL2Rx5FXTTRvbHq4zU4jicc+2g++lCC38SCWTskiFU7RUcLcJ+0icxjwiKqfK51UN0QXaass1fDYa583lgmtkQOagNIlH8SUNuK3HqgDGcQIr7piEmM7mvIMaegy3RV4hyvRaM3pEVXyxqlb/PC+kf3dyo1nh9o54EeA5XXXhuvBkHyZO4bqlHrGpFqmfMH6/WmmcTpkh7HbeG/ZDU35ld9ksZ6DaFgxe+TBQbHR8L+wZIx+R/BHYJXi6dlPErJoCgKj31EDFE36K2ukdSRRjEOm+e0OWO7QLoXl3USxsUxSRTAmIn3SqohXsB7yEGipcETOML2lPps429ZyzLknrDoW5DMuAgLvZv0jqqIiCAvwWumE0TODFnPerpIlmnlU+7x0kPd5+7LEn8zyhCvFYGR4NSnCZFEqYnbTvS1a46mjw2QHA8uZxqO+Z9bbgeRhwxORk5W1C6A2Du+YdWsewLolGSk+NlWYOguu+bwPQQrsvkLKfCPIM0suGuhg51NsTxwUB1AFy5ppuFmrPqv00z8rcINw8LN3TiI2FxiNNQi7YNnAwLxoVTptgGePV0FcODE4HxEgCltTuqX7SjQsrREqCDmbziUHe7z4I6vbZs0tj9RyVOCe99z3u4w1KVAlh3X2xMj+Hxe21VEuBNfrvg3DQQ2TWyDlWiESgaESg2p/oR2jBCPR+8bast2WGPr9Tb4QaD6Med8YUeybD7VDN3q7kToI8RJ2YqjlnlocKIknTFemDJXWvh0jwW/45s/qF8OOQiquL5z9Q==
X-Microsoft-Exchange-Diagnostics: 1; CY1PR0301MB0698;
	31:qfILDDQ+dK4tWnKznVk6FxArvjMboCFd2BRcQub1eFl7Z8YvUvhW2JR6ke0HayhW1OYbFxxADdUKALItwOc4Zpf3hOe//sJi4+NBcLDZwNgCiyPitE6sWM4cmzxWqo3yKBnQQ9IPQjgRB0x5svZ5My8hgTJtiwDQOIhbrQbSJ/NQaogEX6FRVXE118ggMfoq8vGu8+V3KFoSjBSRcJV1IxdSmFoEUf6x4Jey/jef6f0=;
	4:zTB1qob5y6Hye1jN9DptNfkhR7RCaFYjIKojUlOqjhfr7DHzC+/I6P24s8lC3TglOsptsfrL5QeGbalmiVVjcAHUAHZ35KOWK32iHrBxHoVqyI+GM1YVBpmLocKEQ/xIXLwsTIgWwr2Y2f7i/IDGW2Uo5kWY9YUQSOOipv7kDIa43t2ShuqgH1KB+XnPhbP1SEZAv4Zo4O8Py7bMpM+psaszbhaB1dJQ61O0DlVc3J3cH6caXRj3Pr25NEV5Xg9U21L6qP+Zj7CnS5Nozxcu21RF6MCqFmSsDQYZQtT0gAcB3vSF9yQABVWyFhA4sqL3fsc+L7iX/kvY7i9YQ7D+MU1lzq3yf5cnO+AYLo3wcGBQ1+c0f7ExJSnZkes1jxAxGcwICQH32EP3gAdY2f1zPvpKeD9MLHBZvzUjuOlllF+AxrAVbb7zi78qYjc8P7slwNi7IGym1kkF90+QBWwveeRfrCK6wQG8/61C+YKLppTjUS0+e6+1BOnbYmbhIBkwd2gmoOiTOxCjdWvhgmxik/0Qw1roVl9TU4IQjurltbj09zFbANAXxro2tJKsqqQd
X-Microsoft-Antispam-PRVS: &lt;CY1PR0301MB06980F933FAA409D9FE1817A95050@CY1PR0301MB0698.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(185117386973197)(17755550239193);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(2401047)(8121501046)(13018025)(5005006)(13024025)(13015025)(13023025)(13017025)(3002001)(10201501046)(6055026);
	SRVR:CY1PR0301MB0698; BCL:0; PCL:0; RULEID:(400006);
	SRVR:CY1PR0301MB0698; 
X-Forefront-PRVS: 0022134A87
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR0301MB0698;
	23:sZ479fS/xQFpxDrafyTMPdVVn5WljP/Joo8KJf6?=
	=?us-ascii?Q?GRf6JetNJIbWao6G/33VyegPURQwJ/MjOKOzYmJ/Q3Nad2peae5QvOGvIXUU?=
	=?us-ascii?Q?zyecCl1JGhJfBGdNabt73P3RxCp7uFr5Zsgtb2qTzQsHXvAZzZcfycM26wMG?=
	=?us-ascii?Q?cRkADFTEM6IAzqzP53bm0bYft5g7uaP7xwRDolKay21eVgfvvEKLYCUG1hzO?=
	=?us-ascii?Q?YU+hewuNyWqAwW9DVmH+/VuL3PBuFG2f/RGVncU16EYvNCrx02J2+msL3Xn7?=
	=?us-ascii?Q?IJfvDJ+AQPkPYwNliFESBRDxnf6LWFFP/q/iNQ0wzRE6JdT7RYUfpTjJrHWI?=
	=?us-ascii?Q?YpyUdavbRQuxXgCCcwZptO49fTqQD67/t09L2gvdFyu7tsPy15gwHFjisiv6?=
	=?us-ascii?Q?3OFpGbS+m71/rAD95ujfvgzv5jUw95yvREEcpWOG4w+SYGf46ycgSyXEgn4w?=
	=?us-ascii?Q?29Uuc6JVoJhx5XNnx4e6PeZMSsPqT3C6ARkMTJ6Dut6Mums7GkROHtqyGZuE?=
	=?us-ascii?Q?pVduA/188tY0/B6haDvJkx+dIx5K4LVwtDQ3NTnVpoJAY7YGkwcQJsLLRhvh?=
	=?us-ascii?Q?PBV8x9f4uSpdsGwmyAKsgnPH0hFd2X76CmvkRCmLvOqzP1v/eQfkhEoVz9SE?=
	=?us-ascii?Q?ymGzem6+Qbw7VmMq2neBb7yQHUdf76HmrgMmjFiX2pRl3AsFQY+9U8sIhoii?=
	=?us-ascii?Q?MFisXgRYRF4Jm00eGn7yCReAmmwvAoHhYqqTaSO+cqKqgnYBFoLkkVrbeMX4?=
	=?us-ascii?Q?FYnIwMQGHsYjp5qfAqCYIVjzFU9shKUpSh5ykcY2DzDu0Oko1az9z937MPRj?=
	=?us-ascii?Q?8K0d3ud81prk9Pzf8qkNEu8sr4zDwYFCT2WYtP0CwQm/SScmG0P8C/GrzTU2?=
	=?us-ascii?Q?qLNCfTZxaKLup/19rupQd3DuL1xUrbbUxNJsltS1/hqO48bIHh+RJr3TqlTv?=
	=?us-ascii?Q?76xu1TtJZd22jx3da+6ctaQwescLr6PBAavVV6UBvRVSng8agCzr6IXrCB9N?=
	=?us-ascii?Q?7DKqDA89OafBm90czthpUF1Xw09cZfHUCHxEeGhmyrmlvCmiOcoJ5XJhI14i?=
	=?us-ascii?Q?VgpzmhqgIqsdSsKW+8qo31fx6LDTL+gtA05cqttwP8A3zWFYw38KIIksQkk9?=
	=?us-ascii?Q?cmsoSSq7hSelfGbFsuI13vlXMBzudKR3NPi9e8Gu97BK89Ng1ssHRswTHPN+?=
	=?us-ascii?Q?jHeiQUM0gCgSO50n3uzNVqwF8c1PMtgWj7d0a0VxHmp6onLKIfoa03un8+sm?=
	=?us-ascii?Q?QQpSBi/KPhblQ0Fyc0fngzqvbnMW9PWEkKCSB3Sp8L4wHslfUmk6fgCNpMVx?=
	=?us-ascii?Q?8LczJgR22uFQ4fGZGI6fksQu1BFGXY0nOjD9KpH6EZmxF?=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR0301MB0698;
	6:MfG1uqpu/qvXTQ5tqMp8mzAZdiHj9bGzv3Q8Sj/oOaeSfgBDwJgK5/CkAiPa1UGTc9POYEA/BCkN63coxUw/77dseFPahqncBKTL8sh+KUnf4De1BsnQvKcT0rGGnmDf6IhukacMyp8Ic9yHqG6gXwyTSmBBk2aLR2SKdj+EPsiS8zegUVUJhp5LRKmbr1AlqPHceKFg1TGuuqfBBTZtn+ZpSJq1cZTez/sO2XuYkVWztCz0qfYpDJvtGkTvi8Oa05WbwYMbhcJ1TwS61G8I5bJQZUOKC+lp4sCojLXZuIU=;
	5:p9dIRm4pFSE08quTfUV1BA8qeu2yAOlzTqFX38c8IpZ3LYKPp95eQzc7yBSMHDhQTnu49XY1dNjYSupoN4q1uzxdVuKj28hgoHUTNiX4oBeoCDD8uSXam0rMd0epWMbVi5zVyBjFUF/ArwNRAwObiqTwr3c24EDzSpAYr/mx8rg=;
	24:aKSSt2a6RMMkA/nJTECyo/0OY39NaGMLsjlXevhOsK8mF5g4Dyqj+8pepkAgGV6YakOsA4Mg0sUTqCTMSJt7Li73kHWPK1NrBSUScn6reCk=;
	7:L3cYrih7oE5Zsga6lkKvUl2yjg38Rv3QjumHLItsls+FDwXtGsghF4r4atSqzHFsU2hAqlIAxxpwCC/fGD+P0v1qLmazN1pV2k6E52nlwaBhDezLSJokjohEzCOIP7T1qJYkX5jLbvLPOur7oIe1o33gkmnvi7Ui74pfg1hdu/VRc7khEog6nYKlPwJzsZpC9RwqoIPVFMVDzh/unSNsYD9X48nJ+c1Mtpb8Vu7MHbc/qRvEi7QMZ8UnzA5AwS1h
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 02 Aug 2016 12:00:12.3464
	(UTC)
X-MS-Exchange-CrossTenant-Id: 5afe0b00-7697-4969-b663-5eab37d5f47e
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=5afe0b00-7697-4969-b663-5eab37d5f47e;
	Ip=[192.88.158.2]; Helo=[az84smr01.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY1PR0301MB0698
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161471">Chenhui Zhao</a> - Aug. 2, 2016, 11:59 a.m.</div>
<pre class="content">
T104x has deep sleep feature, which can switch off most parts of
the SoC when it is in deep sleep mode. This way, it becomes more
energy-efficient.

The DDR controller will also be powered off in deep sleep. Therefore,
the last stage (the latter part of fsl_dp_enter_low) will run without DDR
access. This piece of code and related TLBs are prefetched in advance.

Due to the different initialization code between 32-bit and 64-bit, they
have separate resume entry and precedure.

The feature supports 32-bit and 64-bit kernel mode.
<span class="signed-off-by">
Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
---
 arch/powerpc/include/asm/fsl_pm.h             |  24 ++
 arch/powerpc/kernel/asm-offsets.c             |  12 +
 arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +
 arch/powerpc/kernel/head_64.S                 |   2 +-
 arch/powerpc/platforms/85xx/Makefile          |   1 +
 arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++
 arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++
 arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531 ++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-
 9 files changed, 889 insertions(+), 2 deletions(-)
 create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c
 create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=151011">Scott Wood</a> - Sept. 25, 2016, 7:24 a.m.</div>
<pre class="content">
On Tue, Aug 02, 2016 at 07:59:31PM +0800, Chenhui Zhao wrote:
<span class="quote">&gt; T104x has deep sleep feature, which can switch off most parts of</span>
<span class="quote">&gt; the SoC when it is in deep sleep mode. This way, it becomes more</span>
<span class="quote">&gt; energy-efficient.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The DDR controller will also be powered off in deep sleep. Therefore,</span>
<span class="quote">&gt; the last stage (the latter part of fsl_dp_enter_low) will run without DDR</span>
<span class="quote">&gt; access. This piece of code and related TLBs are prefetched in advance.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Due to the different initialization code between 32-bit and 64-bit, they</span>
<span class="quote">&gt; have separate resume entry and precedure.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The feature supports 32-bit and 64-bit kernel mode.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/include/asm/fsl_pm.h             |  24 ++</span>
<span class="quote">&gt;  arch/powerpc/kernel/asm-offsets.c             |  12 +</span>
<span class="quote">&gt;  arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +</span>
<span class="quote">&gt;  arch/powerpc/kernel/head_64.S                 |   2 +-</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/Makefile          |   1 +</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531 ++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-</span>
<span class="quote">&gt;  9 files changed, 889 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; index e05049b..48c2631 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define PLAT_PM_SLEEP	20</span>
<span class="quote">&gt;  #define PLAT_PM_LPM20	30</span>
<span class="quote">&gt; +#define PLAT_PM_LPM35	40</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define FSL_PM_SLEEP		(1 &lt;&lt; 0)</span>
<span class="quote">&gt;  #define FSL_PM_DEEP_SLEEP	(1 &lt;&lt; 1)</span>
<span class="quote">&gt; @@ -48,4 +49,27 @@ extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  int __init fsl_rcpm_init(void);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; +int fsl_enter_deepsleep(void);</span>
<span class="quote">&gt; +int fsl_deepsleep_init(void);</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="quote">&gt; +static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="quote">&gt; +#endif</span>

Please return proper error codes.

Where can fsl_deepsleep_init() be called without CONFIG_FSL_QORIQ_PM?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +extern void fsl_dp_enter_low(void *priv);</span>
<span class="quote">&gt; +extern void fsl_booke_deep_sleep_resume(void);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct fsl_iomap {</span>
<span class="quote">&gt; +	void *ccsr_scfg_base;</span>
<span class="quote">&gt; +	void *ccsr_rcpm_base;</span>
<span class="quote">&gt; +	void *ccsr_ddr_base;</span>
<span class="quote">&gt; +	void *ccsr_gpio1_base;</span>
<span class="quote">&gt; +	void *ccsr_cpc_base;</span>
<span class="quote">&gt; +	void *dcsr_epu_base;</span>
<span class="quote">&gt; +	void *dcsr_npc_base;</span>
<span class="quote">&gt; +	void *dcsr_rcpm_base;</span>
<span class="quote">&gt; +	void *cpld_base;</span>
<span class="quote">&gt; +	void *fpga_base;</span>
<span class="quote">&gt; +};</span>

__iomem
<span class="quote">
&gt;  #endif /* __PPC_FSL_PM_H */</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; index 9ea0955..cc488f9 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; @@ -68,6 +68,10 @@</span>
<span class="quote">&gt;  #include &quot;../mm/mmu_decl.h&quot;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; +#include &lt;asm/fsl_pm.h&gt;</span>
<span class="quote">&gt; +#endif</span>

I know this file ifdefs headers a lot, but it&#39;s generally not good
practice.  Does including this file cause any harm on other platforms?
<span class="quote">
&gt; diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; index 83dd0f6..659b059 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; @@ -173,6 +173,10 @@ skpinv:	addi	r6,r6,1				/* Increment */</span>
<span class="quote">&gt;  	lis	r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@h</span>
<span class="quote">&gt;  	ori	r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@l</span>
<span class="quote">&gt;  	mtspr	SPRN_MAS2,r6</span>
<span class="quote">&gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; +	LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="quote">&gt; +	ori	r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_MAS3,r8</span>
<span class="quote">&gt;  	tlbwe</span>
<span class="quote">&gt;  </span>

Have you tried this with a relocatable kernel?
<span class="quote">
&gt; +static void fsl_dp_set_resume_pointer(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 resume_addr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* the bootloader will finally jump to this address to return kernel */</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC32</span>
<span class="quote">&gt; +	resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +	resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="quote">&gt; +			    &amp; 0xffffffff);</span>
<span class="quote">&gt; +#endif</span>

Why are you masking the physical address by 0xffffffff?  Besides the
(u32) cast accomplishing the same thing, wouldn&#39;t it be a problem if
(e.g. due to a relocatable kernel) the address is above 4 GiB?
<span class="quote">
&gt; +static void fsl_dp_pins_setup(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 mask = BIT(31 - fsl_gpio_mcke);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* set GPIO1_29 as an output pin (not open-drain), and output 0 */</span>
<span class="quote">&gt; +	clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDAT, mask);</span>
<span class="quote">&gt; +	clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPODR, mask);</span>
<span class="quote">&gt; +	setbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDIR, mask);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* wait for the stabilization of GPIO1_29 */</span>
<span class="quote">&gt; +	udelay(10);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* enable the functionality of pins relevant to deep sleep */</span>
<span class="quote">&gt; +	if (fsl_dp_priv.cpld_base) {</span>
<span class="quote">&gt; +		setbits8(fsl_dp_priv.cpld_base + QORIQ_CPLD_MISCCSR,</span>
<span class="quote">&gt; +			 QORIQ_CPLD_MISCCSR_SLEEPEN);</span>
<span class="quote">&gt; +	} else if (fsl_dp_priv.fpga_base) {</span>
<span class="quote">&gt; +		setbits8(fsl_dp_priv.fpga_base + QIXIS_PWR_CTL2,</span>
<span class="quote">&gt; +			 QIXIS_PWR_CTL2_PCTL);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +}</span>

Please use callbacks to handle board-specific things.
<span class="quote">
&gt; +/* reset time base to prevent from overflow */</span>
<span class="quote">&gt; +#define DELAY(count)		\</span>
<span class="quote">&gt; +	li	r3, count;	\</span>
<span class="quote">&gt; +	li	r4, 0;		\</span>
<span class="quote">&gt; +	mtspr	SPRN_TBWL, r4;	\</span>
<span class="quote">&gt; +101:	mfspr	r4, SPRN_TBRL;	\</span>
<span class="quote">&gt; +	cmpw	r4, r3;		\</span>
<span class="quote">&gt; +	blt	101b</span>

Please find a better way of dealing with overflow than writing to the
timebase.

-Scott
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161471">Chenhui Zhao</a> - Sept. 27, 2016, 11:05 a.m.</div>
<pre class="content">
<span class="from">From: Scott Wood &lt;oss@buserror.net&gt;</span>
Sent: Sunday, September 25, 2016 3:24 PM
To: C.H. Zhao
Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui@gmail.com; Jason Jin
Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x
    
On Tue, Aug 02, 2016 at 07:59:31PM +0800, Chenhui Zhao wrote:
<span class="quote">&gt; T104x has deep sleep feature, which can switch off most parts of</span>
<span class="quote">&gt; the SoC when it is in deep sleep mode. This way, it becomes more</span>
<span class="quote">&gt; energy-efficient.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The DDR controller will also be powered off in deep sleep. Therefore,</span>
<span class="quote">&gt; the last stage (the latter part of fsl_dp_enter_low) will run without DDR</span>
<span class="quote">&gt; access. This piece of code and related TLBs are prefetched in advance.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Due to the different initialization code between 32-bit and 64-bit, they</span>
<span class="quote">&gt; have separate resume entry and precedure.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The feature supports 32-bit and 64-bit kernel mode.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/include/asm/fsl_pm.h             |  24 ++</span>
<span class="quote">&gt;  arch/powerpc/kernel/asm-offsets.c             |  12 +</span>
<span class="quote">&gt;  arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +</span>
<span class="quote">&gt;  arch/powerpc/kernel/head_64.S                 |   2 +-</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/Makefile          |   1 +</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++</span>
<span class="quote">&gt;  arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531 ++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-</span>
<span class="quote">&gt;  9 files changed, 889 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; index e05049b..48c2631 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define PLAT_PM_SLEEP        20</span>
<span class="quote">&gt;  #define PLAT_PM_LPM20        30</span>
<span class="quote">&gt; +#define PLAT_PM_LPM35        40</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define FSL_PM_SLEEP         (1 &lt;&lt; 0)</span>
<span class="quote">&gt;  #define FSL_PM_DEEP_SLEEP    (1 &lt;&lt; 1)</span>
<span class="quote">&gt; @@ -48,4 +49,27 @@ extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  int __init fsl_rcpm_init(void);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; +int fsl_enter_deepsleep(void);</span>
<span class="quote">&gt; +int fsl_deepsleep_init(void);</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="quote">&gt; +static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="quote">&gt; +#endif</span>

Please return proper error codes.

Where can fsl_deepsleep_init() be called without CONFIG_FSL_QORIQ_PM?

[Chenhui] I can get rid of the ifdef here. And add it in arch/powerpc/sysdev/fsl_rcpm.c.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +extern void fsl_dp_enter_low(void *priv);</span>
<span class="quote">&gt; +extern void fsl_booke_deep_sleep_resume(void);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct fsl_iomap {</span>
<span class="quote">&gt; +     void *ccsr_scfg_base;</span>
<span class="quote">&gt; +     void *ccsr_rcpm_base;</span>
<span class="quote">&gt; +     void *ccsr_ddr_base;</span>
<span class="quote">&gt; +     void *ccsr_gpio1_base;</span>
<span class="quote">&gt; +     void *ccsr_cpc_base;</span>
<span class="quote">&gt; +     void *dcsr_epu_base;</span>
<span class="quote">&gt; +     void *dcsr_npc_base;</span>
<span class="quote">&gt; +     void *dcsr_rcpm_base;</span>
<span class="quote">&gt; +     void *cpld_base;</span>
<span class="quote">&gt; +     void *fpga_base;</span>
<span class="quote">&gt; +};</span>

__iomem

[Chenhui] Yes. Will add it.
<span class="quote">
&gt;  #endif /* __PPC_FSL_PM_H */</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; index 9ea0955..cc488f9 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="quote">&gt; @@ -68,6 +68,10 @@</span>
<span class="quote">&gt;  #include &quot;../mm/mmu_decl.h&quot;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; +#include &lt;asm/fsl_pm.h&gt;</span>
<span class="quote">&gt; +#endif</span>

I know this file ifdefs headers a lot, but it&#39;s generally not good
practice.  Does including this file cause any harm on other platforms?

[Chenhui] Not at all. Will remove it.
<span class="quote">
&gt; diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; index 83dd0f6..659b059 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; @@ -173,6 +173,10 @@ skpinv:  addi    r6,r6,1                         /* Increment */</span>
<span class="quote">&gt;        lis     r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@h</span>
<span class="quote">&gt;        ori     r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@l</span>
<span class="quote">&gt;        mtspr   SPRN_MAS2,r6</span>
<span class="quote">&gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; +     LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="quote">&gt; +     ori     r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;        mtspr   SPRN_MAS3,r8</span>
<span class="quote">&gt;        tlbwe</span>
<span class="quote">&gt;  </span>

Have you tried this with a relocatable kernel?

[Chenhui] Not yet. Not sure whether it has been supported on QorIQ platform.
<span class="quote">
&gt; +static void fsl_dp_set_resume_pointer(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     u32 resume_addr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /* the bootloader will finally jump to this address to return kernel */</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC32</span>
<span class="quote">&gt; +     resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +     resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="quote">&gt; +                         &amp; 0xffffffff);</span>
<span class="quote">&gt; +#endif</span>

Why are you masking the physical address by 0xffffffff?  Besides the
(u32) cast accomplishing the same thing, wouldn&#39;t it be a problem if
(e.g. due to a relocatable kernel) the address is above 4 GiB?

[Chenhui] Here, I assumed kernel is below 4 GiB. Maybe I should add a comment here.
<span class="quote">
&gt; +static void fsl_dp_pins_setup(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +     u32 mask = BIT(31 - fsl_gpio_mcke);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /* set GPIO1_29 as an output pin (not open-drain), and output 0 */</span>
<span class="quote">&gt; +     clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDAT, mask);</span>
<span class="quote">&gt; +     clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPODR, mask);</span>
<span class="quote">&gt; +     setbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDIR, mask);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /* wait for the stabilization of GPIO1_29 */</span>
<span class="quote">&gt; +     udelay(10);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +     /* enable the functionality of pins relevant to deep sleep */</span>
<span class="quote">&gt; +     if (fsl_dp_priv.cpld_base) {</span>
<span class="quote">&gt; +             setbits8(fsl_dp_priv.cpld_base + QORIQ_CPLD_MISCCSR,</span>
<span class="quote">&gt; +                      QORIQ_CPLD_MISCCSR_SLEEPEN);</span>
<span class="quote">&gt; +     } else if (fsl_dp_priv.fpga_base) {</span>
<span class="quote">&gt; +             setbits8(fsl_dp_priv.fpga_base + QIXIS_PWR_CTL2,</span>
<span class="quote">&gt; +                      QIXIS_PWR_CTL2_PCTL);</span>
<span class="quote">&gt; +     }</span>
<span class="quote">&gt; +}</span>

Please use callbacks to handle board-specific things.

[Chenhui] Yes. Will do it as you said.
<span class="quote">
&gt; +/* reset time base to prevent from overflow */</span>
<span class="quote">&gt; +#define DELAY(count)         \</span>
<span class="quote">&gt; +     li      r3, count;      \</span>
<span class="quote">&gt; +     li      r4, 0;          \</span>
<span class="quote">&gt; +     mtspr   SPRN_TBWL, r4;  \</span>
<span class="quote">&gt; +101: mfspr   r4, SPRN_TBRL;  \</span>
<span class="quote">&gt; +     cmpw    r4, r3;         \</span>
<span class="quote">&gt; +     blt     101b</span>

Please find a better way of dealing with overflow than writing to the
timebase.

-Scott

[Chenhui] OK. Let me try other way. Thank you for your time.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=151011">Scott Wood</a> - Sept. 28, 2016, 8:03 p.m.</div>
<pre class="content">
On Tue, 2016-09-27 at 11:05 +0000, C.H. Zhao wrote:
<span class="quote">&gt; From: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; Sent: Sunday, September 25, 2016 3:24 PM</span>
<span class="quote">&gt; To: C.H. Zhao</span>
<span class="quote">&gt; Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui@g</span>
<span class="quote">&gt; mail.com; Jason Jin</span>
<span class="quote">&gt; Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x</span>
<span class="quote">&gt;     </span>
<span class="quote">&gt; On Tue, Aug 02, 2016 at 07:59:31PM +0800, Chenhui Zhao wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; T104x has deep sleep feature, which can switch off most parts of</span>
<span class="quote">&gt; &gt; the SoC when it is in deep sleep mode. This way, it becomes more</span>
<span class="quote">&gt; &gt; energy-efficient.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The DDR controller will also be powered off in deep sleep. Therefore,</span>
<span class="quote">&gt; &gt; the last stage (the latter part of fsl_dp_enter_low) will run without DDR</span>
<span class="quote">&gt; &gt; access. This piece of code and related TLBs are prefetched in advance.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Due to the different initialization code between 32-bit and 64-bit, they</span>
<span class="quote">&gt; &gt; have separate resume entry and precedure.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The feature supports 32-bit and 64-bit kernel mode.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;   arch/powerpc/include/asm/fsl_pm.h             |  24 ++</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/asm-offsets.c             |  12 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/head_64.S                 |   2 +-</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/Makefile          |   1 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531</span>
<span class="quote">&gt; &gt; ++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;   arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-</span>
<span class="quote">&gt; &gt;   9 files changed, 889 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="quote">&gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; index e05049b..48c2631 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   #define PLAT_PM_SLEEP        20</span>
<span class="quote">&gt; &gt;   #define PLAT_PM_LPM20        30</span>
<span class="quote">&gt; &gt; +#define PLAT_PM_LPM35        40</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   #define FSL_PM_SLEEP         (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt;   #define FSL_PM_DEEP_SLEEP    (1 &lt;&lt; 1)</span>
<span class="quote">&gt; &gt; @@ -48,4 +49,27 @@ extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   int __init fsl_rcpm_init(void);</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; &gt; +int fsl_enter_deepsleep(void);</span>
<span class="quote">&gt; &gt; +int fsl_deepsleep_init(void);</span>
<span class="quote">&gt; &gt; +#else</span>
<span class="quote">&gt; &gt; +static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="quote">&gt; &gt; +static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; Please return proper error codes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Where can fsl_deepsleep_init() be called without CONFIG_FSL_QORIQ_PM?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] I can get rid of the ifdef here. And add it</span>
<span class="quote">&gt; in arch/powerpc/sysdev/fsl_rcpm.c.</span>

No, this is the right place for the ifdef for functions that are called from
code that doesn&#39;t depend on CONFIG_FSL_QORIQ_PM.  But fsl_deepsleep_init() is
called from deepsleep.c which is only built with CONFIG_FSL_QORIQ_PM, and it&#39;s
hard to picture a scenario where it would be called from elsewhere.
<span class="quote">
&gt; &gt; diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; index 83dd0f6..659b059 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; @@ -173,6 +173,10 @@ skpinv:  addi    r6,r6,1                         /*</span>
<span class="quote">&gt; &gt; Increment */</span>
<span class="quote">&gt; &gt;         lis     r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@h</span>
<span class="quote">&gt; &gt;         ori     r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M,</span>
<span class="quote">&gt; &gt; M_IF_NEEDED)@l</span>
<span class="quote">&gt; &gt;         mtspr   SPRN_MAS2,r6</span>
<span class="quote">&gt; &gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; &gt; +     LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="quote">&gt; &gt; +     ori     r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; &gt;         mtspr   SPRN_MAS3,r8</span>
<span class="quote">&gt; &gt;         tlbwe</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; Have you tried this with a relocatable kernel?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] Not yet. Not sure whether it has been supported on QorIQ platform.</span>

It is supported, and deep sleep needs to work with it.
<span class="quote">
&gt; &gt; +static void fsl_dp_set_resume_pointer(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +     u32 resume_addr;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +     /* the bootloader will finally jump to this address to return kernel</span>
<span class="quote">&gt; &gt; */</span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_PPC32</span>
<span class="quote">&gt; &gt; +     resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="quote">&gt; &gt; +#else</span>
<span class="quote">&gt; &gt; +     resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="quote">&gt; &gt; +                         &amp; 0xffffffff);</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; Why are you masking the physical address by 0xffffffff?  Besides the</span>
<span class="quote">&gt; (u32) cast accomplishing the same thing, wouldn&#39;t it be a problem if</span>
<span class="quote">&gt; (e.g. due to a relocatable kernel) the address is above 4 GiB?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] Here, I assumed kernel is below 4 GiB. Maybe I should add a</span>
<span class="quote">&gt; comment here.</span>

It needs a fix rather than a comment, unless you can show that the relocatable
mechanism doesn&#39;t support kernels over 4 GiB (I don&#39;t remember of the top of
my head whether it does).

-Scott
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161471">Chenhui Zhao</a> - Sept. 29, 2016, 10:21 a.m.</div>
<pre class="content">
<span class="from">From: Scott Wood &lt;oss@buserror.net&gt;</span>
Sent: Thursday, September 29, 2016 4:03 AM
To: C.H. Zhao
Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui@gmail.com; Jason Jin
Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x
    
On Tue, 2016-09-27 at 11:05 +0000, C.H. Zhao wrote:
<span class="quote">&gt; From: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; Sent: Sunday, September 25, 2016 3:24 PM</span>
<span class="quote">&gt; To: C.H. Zhao</span>
<span class="quote">&gt; Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui@g</span>
<span class="quote">&gt; mail.com; Jason Jin</span>
<span class="quote">&gt; Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x</span>
<span class="quote">&gt;     </span>
<span class="quote">&gt; On Tue, Aug 02, 2016 at 07:59:31PM +0800, Chenhui Zhao wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; T104x has deep sleep feature, which can switch off most parts of</span>
<span class="quote">&gt; &gt; the SoC when it is in deep sleep mode. This way, it becomes more</span>
<span class="quote">&gt; &gt; energy-efficient.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The DDR controller will also be powered off in deep sleep. Therefore,</span>
<span class="quote">&gt; &gt; the last stage (the latter part of fsl_dp_enter_low) will run without DDR</span>
<span class="quote">&gt; &gt; access. This piece of code and related TLBs are prefetched in advance.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Due to the different initialization code between 32-bit and 64-bit, they</span>
<span class="quote">&gt; &gt; have separate resume entry and precedure.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The feature supports 32-bit and 64-bit kernel mode.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;   arch/powerpc/include/asm/fsl_pm.h             |  24 ++</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/asm-offsets.c             |  12 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/kernel/head_64.S                 |   2 +-</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/Makefile          |   1 +</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++</span>
<span class="quote">&gt; &gt;   arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531</span>
<span class="quote">&gt; &gt; ++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;   arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-</span>
<span class="quote">&gt; &gt;   9 files changed, 889 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="quote">&gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; index e05049b..48c2631 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   #define PLAT_PM_SLEEP        20</span>
<span class="quote">&gt; &gt;   #define PLAT_PM_LPM20        30</span>
<span class="quote">&gt; &gt; +#define PLAT_PM_LPM35        40</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   #define FSL_PM_SLEEP         (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt;   #define FSL_PM_DEEP_SLEEP    (1 &lt;&lt; 1)</span>
<span class="quote">&gt; &gt; @@ -48,4 +49,27 @@ extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;   int __init fsl_rcpm_init(void);</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; &gt; +int fsl_enter_deepsleep(void);</span>
<span class="quote">&gt; &gt; +int fsl_deepsleep_init(void);</span>
<span class="quote">&gt; &gt; +#else</span>
<span class="quote">&gt; &gt; +static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="quote">&gt; &gt; +static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; Please return proper error codes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Where can fsl_deepsleep_init() be called without CONFIG_FSL_QORIQ_PM?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] I can get rid of the ifdef here. And add it</span>
<span class="quote">&gt; in arch/powerpc/sysdev/fsl_rcpm.c.</span>

No, this is the right place for the ifdef for functions that are called from
code that doesn&#39;t depend on CONFIG_FSL_QORIQ_PM.  But fsl_deepsleep_init() is
called from deepsleep.c which is only built with CONFIG_FSL_QORIQ_PM, and it&#39;s
hard to picture a scenario where it would be called from elsewhere.


[Chenhui] You are right. No need to enclose fsl_deepsleep_init() in the ifdef.
                 But regarding fsl_enter_deepsleep(), it is called in rcpm_v2_plat_enter_sleep()
                 in arch/powerpc/sysdev/fsl_rcpm.c. It still needs to be enclosed in the ifdef.
                 I would change it like:

int fsl_deepsleep_init(void);                                              
#ifdef CONFIG_FSL_QORIQ_PM                                                 
int fsl_enter_deepsleep(void);
#else           
static inline int fsl_enter_deepsleep(void) { return -EINVAL; }            
#endif
<span class="quote">

&gt; &gt; diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; index 83dd0f6..659b059 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="quote">&gt; &gt; @@ -173,6 +173,10 @@ skpinv:  addi    r6,r6,1                         /*</span>
<span class="quote">&gt; &gt; Increment */</span>
<span class="quote">&gt; &gt;         lis     r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@h</span>
<span class="quote">&gt; &gt;         ori     r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M,</span>
<span class="quote">&gt; &gt; M_IF_NEEDED)@l</span>
<span class="quote">&gt; &gt;         mtspr   SPRN_MAS2,r6</span>
<span class="quote">&gt; &gt; +#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="quote">&gt; &gt; +     LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="quote">&gt; &gt; +     ori     r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; &gt;         mtspr   SPRN_MAS3,r8</span>
<span class="quote">&gt; &gt;         tlbwe</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; Have you tried this with a relocatable kernel?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] Not yet. Not sure whether it has been supported on QorIQ platform.</span>

It is supported, and deep sleep needs to work with it.


[Chenhui] OK. I&#39;m going to work something out.
<span class="quote">
&gt; &gt; +static void fsl_dp_set_resume_pointer(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +     u32 resume_addr;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +     /* the bootloader will finally jump to this address to return kernel</span>
<span class="quote">&gt; &gt; */</span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_PPC32</span>
<span class="quote">&gt; &gt; +     resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="quote">&gt; &gt; +#else</span>
<span class="quote">&gt; &gt; +     resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="quote">&gt; &gt; +                         &amp; 0xffffffff);</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; Why are you masking the physical address by 0xffffffff?  Besides the</span>
<span class="quote">&gt; (u32) cast accomplishing the same thing, wouldn&#39;t it be a problem if</span>
<span class="quote">&gt; (e.g. due to a relocatable kernel) the address is above 4 GiB?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] Here, I assumed kernel is below 4 GiB. Maybe I should add a</span>
<span class="quote">&gt; comment here.</span>

It needs a fix rather than a comment, unless you can show that the relocatable
mechanism doesn&#39;t support kernels over 4 GiB (I don&#39;t remember of the top of
my head whether it does).

-Scott

[Chenhui] OK. I&#39;m going to work something out.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=151011">Scott Wood</a> - Oct. 3, 2016, 5:22 p.m.</div>
<pre class="content">
On Thu, 2016-09-29 at 10:21 +0000, C.H. Zhao wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; From: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; Sent: Thursday, September 29, 2016 4:03 AM</span>
<span class="quote">&gt; To: C.H. Zhao</span>
<span class="quote">&gt; Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui@g</span>
<span class="quote">&gt; mail.com; Jason Jin</span>
<span class="quote">&gt; Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x</span>
<span class="quote">&gt;     </span>
<span class="quote">&gt; On Tue, 2016-09-27 at 11:05 +0000, C.H. Zhao wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; From: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; &gt; Sent: Sunday, September 25, 2016 3:24 PM</span>
<span class="quote">&gt; &gt; To: C.H. Zhao</span>
<span class="quote">&gt; &gt; Cc: linuxppc-dev@lists.ozlabs.org; linux-kernel@vger.kernel.org; z.chenhui</span>
<span class="quote">&gt; &gt; @g</span>
<span class="quote">&gt; &gt; mail.com; Jason Jin</span>
<span class="quote">&gt; &gt; Subject: Re: [v3,4/5] powerpc/pm: support deep sleep feature on T104x</span>
<span class="quote">&gt; &gt;     </span>
<span class="quote">&gt; &gt; On Tue, Aug 02, 2016 at 07:59:31PM +0800, Chenhui Zhao wrote:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; T104x has deep sleep feature, which can switch off most parts of</span>
<span class="quote">&gt; &gt; &gt; the SoC when it is in deep sleep mode. This way, it becomes more</span>
<span class="quote">&gt; &gt; &gt; energy-efficient.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The DDR controller will also be powered off in deep sleep. Therefore,</span>
<span class="quote">&gt; &gt; &gt; the last stage (the latter part of fsl_dp_enter_low) will run without</span>
<span class="quote">&gt; &gt; &gt; DDR</span>
<span class="quote">&gt; &gt; &gt; access. This piece of code and related TLBs are prefetched in advance.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Due to the different initialization code between 32-bit and 64-bit, they</span>
<span class="quote">&gt; &gt; &gt; have separate resume entry and precedure.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The feature supports 32-bit and 64-bit kernel mode.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="quote">&gt; &gt; &gt; ---</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/include/asm/fsl_pm.h             |  24 ++</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/kernel/asm-offsets.c             |  12 +</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/kernel/fsl_booke_entry_mapping.S |  10 +</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/kernel/head_64.S                 |   2 +-</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/platforms/85xx/Makefile          |   1 +</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/platforms/85xx/deepsleep.c       | 278 ++++++++++++++</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/platforms/85xx/qoriq_pm.c        |  25 ++</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/platforms/85xx/t104x_deepsleep.S | 531</span>
<span class="quote">&gt; &gt; &gt; ++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt;   arch/powerpc/sysdev/fsl_rcpm.c                |   8 +-</span>
<span class="quote">&gt; &gt; &gt;   9 files changed, 889 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; &gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="quote">&gt; &gt; &gt;   create mode 100644 arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; diff --git a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; &gt; b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; &gt; index e05049b..48c2631 100644</span>
<span class="quote">&gt; &gt; &gt; --- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; &gt; +++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="quote">&gt; &gt; &gt; @@ -20,6 +20,7 @@</span>
<span class="quote">&gt; &gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt;   #define PLAT_PM_SLEEP        20</span>
<span class="quote">&gt; &gt; &gt;   #define PLAT_PM_LPM20        30</span>
<span class="quote">&gt; &gt; &gt; +#define PLAT_PM_LPM35        40</span>
<span class="quote">&gt; &gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt;   #define FSL_PM_SLEEP         (1 &lt;&lt; 0)</span>
<span class="quote">&gt; &gt; &gt;   #define FSL_PM_DEEP_SLEEP    (1 &lt;&lt; 1)</span>
<span class="quote">&gt; &gt; &gt; @@ -48,4 +49,27 @@ extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
<span class="quote">&gt; &gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt;   int __init fsl_rcpm_init(void);</span>
<span class="quote">&gt; &gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt; +#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="quote">&gt; &gt; &gt; +int fsl_enter_deepsleep(void);</span>
<span class="quote">&gt; &gt; &gt; +int fsl_deepsleep_init(void);</span>
<span class="quote">&gt; &gt; &gt; +#else</span>
<span class="quote">&gt; &gt; &gt; +static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="quote">&gt; &gt; &gt; +static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="quote">&gt; &gt; &gt; +#endif</span>
<span class="quote">&gt; &gt; Please return proper error codes.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Where can fsl_deepsleep_init() be called without CONFIG_FSL_QORIQ_PM?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; [Chenhui] I can get rid of the ifdef here. And add it</span>
<span class="quote">&gt; &gt; in arch/powerpc/sysdev/fsl_rcpm.c.</span>
<span class="quote">&gt; No, this is the right place for the ifdef for functions that are called from</span>
<span class="quote">&gt; code that doesn&#39;t depend on CONFIG_FSL_QORIQ_PM.  But fsl_deepsleep_init()</span>
<span class="quote">&gt; is</span>
<span class="quote">&gt; called from deepsleep.c which is only built with CONFIG_FSL_QORIQ_PM, and</span>
<span class="quote">&gt; it&#39;s</span>
<span class="quote">&gt; hard to picture a scenario where it would be called from elsewhere.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Chenhui] You are right. No need to enclose fsl_deepsleep_init() in the</span>
<span class="quote">&gt; ifdef.</span>
<span class="quote">&gt;                  But regarding fsl_enter_deepsleep(), it is called in</span>
<span class="quote">&gt; rcpm_v2_plat_enter_sleep()</span>
<span class="quote">&gt;                  in arch/powerpc/sysdev/fsl_rcpm.c. It still needs to be</span>
<span class="quote">&gt; enclosed in the ifdef.</span>

Right.  That&#39;s why I specifically asked about fsl_deepsleep_init(). :-)

-Scott
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_header">index e05049b..48c2631 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/fsl_pm.h</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 
 #define PLAT_PM_SLEEP	20
 #define PLAT_PM_LPM20	30
<span class="p_add">+#define PLAT_PM_LPM35	40</span>
 
 #define FSL_PM_SLEEP		(1 &lt;&lt; 0)
 #define FSL_PM_DEEP_SLEEP	(1 &lt;&lt; 1)
<span class="p_chunk">@@ -48,4 +49,27 @@</span> <span class="p_context"> extern const struct fsl_pm_ops *qoriq_pm_ops;</span>
 
 int __init fsl_rcpm_init(void);
 
<span class="p_add">+#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="p_add">+int fsl_enter_deepsleep(void);</span>
<span class="p_add">+int fsl_deepsleep_init(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline int fsl_enter_deepsleep(void) { return -1; }</span>
<span class="p_add">+static inline int fsl_deepsleep_init(void) { return -1; }</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+extern void fsl_dp_enter_low(void *priv);</span>
<span class="p_add">+extern void fsl_booke_deep_sleep_resume(void);</span>
<span class="p_add">+</span>
<span class="p_add">+struct fsl_iomap {</span>
<span class="p_add">+	void *ccsr_scfg_base;</span>
<span class="p_add">+	void *ccsr_rcpm_base;</span>
<span class="p_add">+	void *ccsr_ddr_base;</span>
<span class="p_add">+	void *ccsr_gpio1_base;</span>
<span class="p_add">+	void *ccsr_cpc_base;</span>
<span class="p_add">+	void *dcsr_epu_base;</span>
<span class="p_add">+	void *dcsr_npc_base;</span>
<span class="p_add">+	void *dcsr_rcpm_base;</span>
<span class="p_add">+	void *cpld_base;</span>
<span class="p_add">+	void *fpga_base;</span>
<span class="p_add">+};</span>
 #endif /* __PPC_FSL_PM_H */
<span class="p_header">diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">index 9ea0955..cc488f9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -68,6 +68,10 @@</span> <span class="p_context"></span>
 #include &quot;../mm/mmu_decl.h&quot;
 #endif
 
<span class="p_add">+#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="p_add">+#include &lt;asm/fsl_pm.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 int main(void)
 {
 	DEFINE(THREAD, offsetof(struct task_struct, thread));
<span class="p_chunk">@@ -783,5 +787,13 @@</span> <span class="p_context"> int main(void)</span>
 
 	DEFINE(PPC_DBELL_SERVER, PPC_DBELL_SERVER);
 
<span class="p_add">+#ifdef CONFIG_FSL_QORIQ_PM</span>
<span class="p_add">+	DEFINE(CCSR_CPC_BASE, offsetof(struct fsl_iomap, ccsr_cpc_base));</span>
<span class="p_add">+	DEFINE(CCSR_GPIO1_BASE, offsetof(struct fsl_iomap, ccsr_gpio1_base));</span>
<span class="p_add">+	DEFINE(CCSR_RCPM_BASE, offsetof(struct fsl_iomap, ccsr_rcpm_base));</span>
<span class="p_add">+	DEFINE(CCSR_DDR_BASE, offsetof(struct fsl_iomap, ccsr_ddr_base));</span>
<span class="p_add">+	DEFINE(CCSR_SCFG_BASE, offsetof(struct fsl_iomap, ccsr_scfg_base));</span>
<span class="p_add">+	DEFINE(DCSR_EPU_BASE, offsetof(struct fsl_iomap, dcsr_epu_base));</span>
<span class="p_add">+#endif</span>
 	return 0;
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/fsl_booke_entry_mapping.S b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_header">index 83dd0f6..659b059 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/fsl_booke_entry_mapping.S</span>
<span class="p_chunk">@@ -173,6 +173,10 @@</span> <span class="p_context"> skpinv:	addi	r6,r6,1				/* Increment */</span>
 	lis	r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@h
 	ori	r6,r6,MAS2_VAL(PAGE_OFFSET, BOOK3E_PAGESZ_64M, M_IF_NEEDED)@l
 	mtspr	SPRN_MAS2,r6
<span class="p_add">+#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+	LOAD_REG_IMMEDIATE(r8, MEMORY_START)</span>
<span class="p_add">+	ori	r8,r8,(MAS3_SX|MAS3_SW|MAS3_SR)</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_MAS3,r8
 	tlbwe
 
<span class="p_chunk">@@ -215,12 +219,18 @@</span> <span class="p_context"> next_tlb_setup:</span>
 	#error You need to specify the mapping or not use this at all.
 #endif
 
<span class="p_add">+#ifdef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+	LOAD_REG_ADDR(r6, 2f)</span>
<span class="p_add">+	mfmsr	r7</span>
<span class="p_add">+	rlwinm	r7,r7,0,~(MSR_IS|MSR_DS)</span>
<span class="p_add">+#else</span>
 	lis	r7,MSR_KERNEL@h
 	ori	r7,r7,MSR_KERNEL@l
 	bl	1f			/* Find our address */
 1:	mflr	r9
 	rlwimi	r6,r9,0,20,31
 	addi	r6,r6,(2f - 1b)
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR0,r6
 	mtspr	SPRN_SRR1,r7
 	rfi				/* start execution out of TLB1[0] entry */
<span class="p_header">diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S</span>
<span class="p_header">index 2d14774..21fa124 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/head_64.S</span>
<span class="p_chunk">@@ -829,7 +829,7 @@</span> <span class="p_context"> _GLOBAL(start_secondary_resume)</span>
 /*
  * This subroutine clobbers r11 and r12
  */
<span class="p_del">-enable_64b_mode:</span>
<span class="p_add">+_GLOBAL(enable_64b_mode)</span>
 	mfmsr	r11			/* grab the current MSR */
 #ifdef CONFIG_PPC_BOOK3E
 	oris	r11,r11,0x8000		/* CM bit set, we&#39;ll set ICM later */
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_header">index 87fb847..a73d563 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/Makefile</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 obj-$(CONFIG_SMP) += smp.o
 obj-$(CONFIG_FSL_PMC)		  += mpc85xx_pm_ops.o
 obj-$(CONFIG_FSL_QORIQ_PM)	  += qoriq_pm.o sleep_fsm.o
<span class="p_add">+obj-$(CONFIG_FSL_QORIQ_PM)	  += deepsleep.o t104x_deepsleep.o</span>
 
 obj-y += common.o
 
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/deepsleep.c b/arch/powerpc/platforms/85xx/deepsleep.c</span>
new file mode 100644
<span class="p_header">index 0000000..9521d99</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/deepsleep.c</span>
<span class="p_chunk">@@ -0,0 +1,278 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Support deep sleep feature for T104x</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2016 Freescale Semiconductor Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Chenhui Zhao &lt;chenhui.zhao@nxp.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute	it and/or modify it</span>
<span class="p_add">+ * under  the terms of	the GNU General	 Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;%s: &quot; fmt, __func__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;sysdev/fsl_soc.h&gt;</span>
<span class="p_add">+#include &lt;asm/machdep.h&gt;</span>
<span class="p_add">+#include &lt;asm/fsl_pm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;sleep_fsm.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPC_CPCHDBCR0		0x0f00</span>
<span class="p_add">+#define CPC_CPCHDBCR0_SPEC_DIS	0x08000000</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_SCFG_DPSLPCR	0x000</span>
<span class="p_add">+#define CCSR_SCFG_DPSLPCR_WDRR_EN	0x1</span>
<span class="p_add">+#define CCSR_SCFG_SPARECR2	0x504</span>
<span class="p_add">+#define CCSR_SCFG_SPARECR3	0x508</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_GPIO1_GPDIR	0x000</span>
<span class="p_add">+#define CCSR_GPIO1_GPODR	0x004</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT	0x008</span>
<span class="p_add">+</span>
<span class="p_add">+#define QIXIS_PWR_CTL2		0x21</span>
<span class="p_add">+#define QIXIS_PWR_CTL2_PCTL	0x2</span>
<span class="p_add">+</span>
<span class="p_add">+#define QORIQ_CPLD_MISCCSR		0x17</span>
<span class="p_add">+#define QORIQ_CPLD_MISCCSR_SLEEPEN	0x40</span>
<span class="p_add">+</span>
<span class="p_add">+/* 128 bytes buffer for restoring data broke by DDR training initialization */</span>
<span class="p_add">+#define DDR_BUF_SIZE	128</span>
<span class="p_add">+static u8 ddr_buff[DDR_BUF_SIZE] __aligned(64);</span>
<span class="p_add">+static int fsl_gpio_mcke;</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_iounmap(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct fsl_iomap fsl_dp_priv;</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id fsl_dp_cpld_ids[] __initconst = {</span>
<span class="p_add">+	{ .compatible = &quot;fsl,t1024-cpld&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,t1040rdb-cpld&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,t1042rdb-cpld&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,t1042rdb_pi-cpld&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,t1040d4rdb-cpld&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id fsl_dp_fpga_ids[] __initconst = {</span>
<span class="p_add">+	{ .compatible = &quot;fsl,fpga-qixis&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;fsl,tetra-fpga&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_set_resume_pointer(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 resume_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the bootloader will finally jump to this address to return kernel */</span>
<span class="p_add">+#ifdef CONFIG_PPC32</span>
<span class="p_add">+	resume_addr = (u32)(__pa(fsl_booke_deep_sleep_resume));</span>
<span class="p_add">+#else</span>
<span class="p_add">+	resume_addr = (u32)(__pa(*(u64 *)fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+			    &amp; 0xffffffff);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* use the register SPARECR2 to save the resume address */</span>
<span class="p_add">+	out_be32(fsl_dp_priv.ccsr_scfg_base + CCSR_SCFG_SPARECR2,</span>
<span class="p_add">+							resume_addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_pins_setup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 mask = BIT(31 - fsl_gpio_mcke);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* set GPIO1_29 as an output pin (not open-drain), and output 0 */</span>
<span class="p_add">+	clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDAT, mask);</span>
<span class="p_add">+	clrbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPODR, mask);</span>
<span class="p_add">+	setbits32(fsl_dp_priv.ccsr_gpio1_base + CCSR_GPIO1_GPDIR, mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait for the stabilization of GPIO1_29 */</span>
<span class="p_add">+	udelay(10);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable the functionality of pins relevant to deep sleep */</span>
<span class="p_add">+	if (fsl_dp_priv.cpld_base) {</span>
<span class="p_add">+		setbits8(fsl_dp_priv.cpld_base + QORIQ_CPLD_MISCCSR,</span>
<span class="p_add">+			 QORIQ_CPLD_MISCCSR_SLEEPEN);</span>
<span class="p_add">+	} else if (fsl_dp_priv.fpga_base) {</span>
<span class="p_add">+		setbits8(fsl_dp_priv.fpga_base + QIXIS_PWR_CTL2,</span>
<span class="p_add">+			 QIXIS_PWR_CTL2_PCTL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fsl_dp_ddr_save(void *scfg_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 ddr_buff_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * DDR training initialization will break 128 bytes at the beginning</span>
<span class="p_add">+	 * of DDR, therefore, save them so that the bootloader will restore</span>
<span class="p_add">+	 * them. Assume that DDR is mapped to the address space started with</span>
<span class="p_add">+	 * CONFIG_PAGE_OFFSET.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memcpy(ddr_buff, (void *)CONFIG_PAGE_OFFSET, DDR_BUF_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* assume ddr_buff is in the physical address space of 4GB */</span>
<span class="p_add">+	ddr_buff_addr = (u32)(__pa(ddr_buff) &amp; 0xffffffff);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * the bootloader will restore the first 128 bytes of DDR from</span>
<span class="p_add">+	 * the location indicated by the register SPARECR3</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	out_be32(scfg_base + CCSR_SCFG_SPARECR3, ddr_buff_addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int fsl_enter_deepsleep(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	fsl_dp_ddr_save(fsl_dp_priv.ccsr_scfg_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_set_resume_pointer();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*  enable Warm Device Reset request. */</span>
<span class="p_add">+	setbits32(fsl_dp_priv.ccsr_scfg_base + CCSR_SCFG_DPSLPCR,</span>
<span class="p_add">+					CCSR_SCFG_DPSLPCR_WDRR_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable CPC speculation to avoid deep sleep hang, especially</span>
<span class="p_add">+	 * in secure boot mode. This bit will be cleared automatically</span>
<span class="p_add">+	 * when resuming from deep sleep.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	setbits32(fsl_dp_priv.ccsr_cpc_base + CPC_CPCHDBCR0,</span>
<span class="p_add">+					CPC_CPCHDBCR0_SPEC_DIS);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_epu_setup_default(fsl_dp_priv.dcsr_epu_base);</span>
<span class="p_add">+	fsl_npc_setup_default(fsl_dp_priv.dcsr_npc_base);</span>
<span class="p_add">+	fsl_dcsr_rcpm_setup(fsl_dp_priv.dcsr_rcpm_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_pins_setup();</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_enter_low(&amp;fsl_dp_priv);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable Warm Device Reset request */</span>
<span class="p_add">+	clrbits32(fsl_dp_priv.ccsr_scfg_base + CCSR_SCFG_DPSLPCR,</span>
<span class="p_add">+					CCSR_SCFG_DPSLPCR_WDRR_EN);</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_epu_clean_default(fsl_dp_priv.dcsr_epu_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init *fsl_of_iomap(char *comp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	void *addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, comp);</span>
<span class="p_add">+	if (np) {</span>
<span class="p_add">+		addr = of_iomap(np, 0);</span>
<span class="p_add">+		of_node_put(np);</span>
<span class="p_add">+		return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct device_node __init *fsl_get_gpio_node(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	u32 val[3];</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;fsl,qoriq-rcpm-2.1&quot;);</span>
<span class="p_add">+	ret = of_property_read_u32_array(np, &quot;mcke-gpios&quot;, val, 3);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_gpio_mcke = val[1];</span>
<span class="p_add">+	np = of_find_node_by_phandle((phandle)val[0]);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return np;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init fsl_dp_iomap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_matching_node(NULL, fsl_dp_cpld_ids);</span>
<span class="p_add">+	if (np) {</span>
<span class="p_add">+		fsl_dp_priv.cpld_base = of_iomap(np, 0);</span>
<span class="p_add">+		of_node_put(np);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		np = of_find_matching_node(NULL, fsl_dp_fpga_ids);</span>
<span class="p_add">+		if (np) {</span>
<span class="p_add">+			fsl_dp_priv.fpga_base = of_iomap(np, 0);</span>
<span class="p_add">+			of_node_put(np);</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.ccsr_scfg_base = fsl_of_iomap(&quot;fsl,t1040-scfg&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.ccsr_scfg_base) {</span>
<span class="p_add">+		fsl_dp_priv.ccsr_scfg_base = fsl_of_iomap(&quot;fsl,t1023-scfg&quot;);</span>
<span class="p_add">+		if (!fsl_dp_priv.ccsr_scfg_base)</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.ccsr_rcpm_base = fsl_of_iomap(&quot;fsl,qoriq-rcpm-2.1&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.ccsr_rcpm_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.ccsr_ddr_base = fsl_of_iomap(&quot;fsl,qoriq-memory-controller&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.ccsr_ddr_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	np = fsl_get_gpio_node();</span>
<span class="p_add">+	fsl_dp_priv.ccsr_gpio1_base = of_iomap(np, 0);</span>
<span class="p_add">+	if (!fsl_dp_priv.ccsr_gpio1_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.ccsr_cpc_base =</span>
<span class="p_add">+			fsl_of_iomap(&quot;fsl,t1040-l3-cache-controller&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.ccsr_cpc_base) {</span>
<span class="p_add">+		fsl_dp_priv.ccsr_cpc_base =</span>
<span class="p_add">+			fsl_of_iomap(&quot;fsl,t1023-l3-cache-controlle&quot;);</span>
<span class="p_add">+		if (!fsl_dp_priv.ccsr_cpc_base)</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.dcsr_epu_base = fsl_of_iomap(&quot;fsl,dcsr-epu&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.dcsr_epu_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.dcsr_npc_base = fsl_of_iomap(&quot;fsl,dcsr-cnpc&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.dcsr_npc_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	fsl_dp_priv.dcsr_rcpm_base = fsl_of_iomap(&quot;fsl,dcsr-rcpm&quot;);</span>
<span class="p_add">+	if (!fsl_dp_priv.dcsr_rcpm_base)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	fsl_dp_iounmap();</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init fsl_dp_iounmap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void **p = (void *)&amp;fsl_dp_priv;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; sizeof(struct fsl_iomap)/sizeof(void *); i++) {</span>
<span class="p_add">+		iounmap(*p);</span>
<span class="p_add">+		*p = NULL;</span>
<span class="p_add">+		p++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __init fsl_deepsleep_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return fsl_dp_iomap();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/qoriq_pm.c b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_header">index c97ef8f..ff6e46a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/qoriq_pm.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/of_platform.h&gt;
<span class="p_add">+#include &lt;linux/of_fdt.h&gt;</span>
 
 #include &lt;asm/fsl_pm.h&gt;
 
<span class="p_chunk">@@ -27,6 +28,11 @@</span> <span class="p_context"> static int qoriq_suspend_enter(suspend_state_t state)</span>
 	case PM_SUSPEND_STANDBY:
 		ret = qoriq_pm_ops-&gt;plat_enter_sleep(FSL_PM_SLEEP);
 		break;
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		ret = qoriq_pm_ops-&gt;plat_enter_sleep(FSL_PM_DEEP_SLEEP);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	default:
 		ret = -EINVAL;
 	}
<span class="p_chunk">@@ -40,9 +46,24 @@</span> <span class="p_context"> static int qoriq_suspend_valid(suspend_state_t state)</span>
 	if (state == PM_SUSPEND_STANDBY &amp;&amp; (pm_modes &amp; FSL_PM_SLEEP))
 		return 1;
 
<span class="p_add">+	if (state == PM_SUSPEND_MEM &amp;&amp; (pm_modes &amp; FSL_PM_DEEP_SLEEP))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+static const char * const boards_deepsleep[] __initconst = {</span>
<span class="p_add">+	&quot;fsl,T1024QDS&quot;,</span>
<span class="p_add">+	&quot;fsl,T1024RDB&quot;,</span>
<span class="p_add">+	&quot;fsl,T1040QDS&quot;,</span>
<span class="p_add">+	&quot;fsl,T1040RDB&quot;,</span>
<span class="p_add">+	&quot;fsl,T1040D4RDB&quot;,</span>
<span class="p_add">+	&quot;fsl,T1042QDS&quot;,</span>
<span class="p_add">+	&quot;fsl,T1042D4RDB&quot;,</span>
<span class="p_add">+	&quot;fsl,T1042RDB&quot;,</span>
<span class="p_add">+	&quot;fsl,T1042RDB_PI&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct platform_suspend_ops qoriq_suspend_ops = {
 	.valid = qoriq_suspend_valid,
 	.enter = qoriq_suspend_enter,
<span class="p_chunk">@@ -53,6 +74,10 @@</span> <span class="p_context"> static int __init qoriq_suspend_init(void)</span>
 	/* support sleep by default */
 	pm_modes |= FSL_PM_SLEEP;
 
<span class="p_add">+	if (of_flat_dt_match(of_get_flat_dt_root(), boards_deepsleep) &amp;&amp;</span>
<span class="p_add">+	    !fsl_deepsleep_init())</span>
<span class="p_add">+		pm_modes |= FSL_PM_DEEP_SLEEP;</span>
<span class="p_add">+</span>
 	suspend_set_ops(&amp;qoriq_suspend_ops);
 	return 0;
 }
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/t104x_deepsleep.S b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
new file mode 100644
<span class="p_header">index 0000000..aefce20</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/t104x_deepsleep.S</span>
<span class="p_chunk">@@ -0,0 +1,531 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Enter and resume from deep sleep state</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2016 Freescale Semiconductor Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute	it and/or modify it</span>
<span class="p_add">+ * under  the terms of	the GNU General	 Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/ppc_asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/reg.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the number of bytes occupied by one register</span>
<span class="p_add">+ * the value of 8 is compatible with both 32-bit and 64-bit registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define STRIDE_SIZE		8</span>
<span class="p_add">+</span>
<span class="p_add">+/* GPR0 - GPR31 */</span>
<span class="p_add">+#define BOOKE_GPR0_OFF		0x0000</span>
<span class="p_add">+#define BOOKE_GPR_COUNT		32</span>
<span class="p_add">+/* IVOR0 - IVOR42 */</span>
<span class="p_add">+#define BOOKE_IVOR0_OFF	   (BOOKE_GPR0_OFF + BOOKE_GPR_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_IVOR_COUNT	43</span>
<span class="p_add">+/* SPRG0 - SPRG9 */</span>
<span class="p_add">+#define BOOKE_SPRG0_OFF	   (BOOKE_IVOR0_OFF + BOOKE_IVOR_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_SPRG_COUNT	10</span>
<span class="p_add">+/* IVPR */</span>
<span class="p_add">+#define BOOKE_IVPR_OFF	   (BOOKE_SPRG0_OFF + BOOKE_SPRG_COUNT * STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BOOKE_LR_OFF		(BOOKE_IVPR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_MSR_OFF		(BOOKE_LR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_TBU_OFF		(BOOKE_MSR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_TBL_OFF		(BOOKE_TBU_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_EPCR_OFF		(BOOKE_TBL_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_HID0_OFF		(BOOKE_EPCR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_PIR_OFF		(BOOKE_HID0_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_PID0_OFF		(BOOKE_PIR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+#define BOOKE_BUCSR_OFF		(BOOKE_PID0_OFF + STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE		(BOOKE_BUCSR_OFF + STRIDE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+#undef SAVE_GPR</span>
<span class="p_add">+#define SAVE_GPR(gpr, offset) \</span>
<span class="p_add">+	PPC_STL gpr, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_GPR(gpr, offset) \</span>
<span class="p_add">+	PPC_LL gpr, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_SPR(spr, offset)	\</span>
<span class="p_add">+	mfspr	r0, spr;	\</span>
<span class="p_add">+	PPC_STL	r0, offset(r10)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_SPR(spr, offset) \</span>
<span class="p_add">+	PPC_LL	r0, offset(r10); \</span>
<span class="p_add">+	mtspr	spr, r0</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_GPR \</span>
<span class="p_add">+	SAVE_GPR(r1, BOOKE_GPR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_GPR(r2, BOOKE_GPR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_GPR(r13, BOOKE_GPR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	SAVE_GPR(r14, BOOKE_GPR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	SAVE_GPR(r15, BOOKE_GPR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	SAVE_GPR(r16, BOOKE_GPR0_OFF + STRIDE_SIZE * 16) ;\</span>
<span class="p_add">+	SAVE_GPR(r17, BOOKE_GPR0_OFF + STRIDE_SIZE * 17) ;\</span>
<span class="p_add">+	SAVE_GPR(r18, BOOKE_GPR0_OFF + STRIDE_SIZE * 18) ;\</span>
<span class="p_add">+	SAVE_GPR(r19, BOOKE_GPR0_OFF + STRIDE_SIZE * 19) ;\</span>
<span class="p_add">+	SAVE_GPR(r20, BOOKE_GPR0_OFF + STRIDE_SIZE * 20) ;\</span>
<span class="p_add">+	SAVE_GPR(r21, BOOKE_GPR0_OFF + STRIDE_SIZE * 21) ;\</span>
<span class="p_add">+	SAVE_GPR(r22, BOOKE_GPR0_OFF + STRIDE_SIZE * 22) ;\</span>
<span class="p_add">+	SAVE_GPR(r23, BOOKE_GPR0_OFF + STRIDE_SIZE * 23) ;\</span>
<span class="p_add">+	SAVE_GPR(r24, BOOKE_GPR0_OFF + STRIDE_SIZE * 24) ;\</span>
<span class="p_add">+	SAVE_GPR(r25, BOOKE_GPR0_OFF + STRIDE_SIZE * 25) ;\</span>
<span class="p_add">+	SAVE_GPR(r26, BOOKE_GPR0_OFF + STRIDE_SIZE * 26) ;\</span>
<span class="p_add">+	SAVE_GPR(r27, BOOKE_GPR0_OFF + STRIDE_SIZE * 27) ;\</span>
<span class="p_add">+	SAVE_GPR(r28, BOOKE_GPR0_OFF + STRIDE_SIZE * 28) ;\</span>
<span class="p_add">+	SAVE_GPR(r29, BOOKE_GPR0_OFF + STRIDE_SIZE * 29) ;\</span>
<span class="p_add">+	SAVE_GPR(r30, BOOKE_GPR0_OFF + STRIDE_SIZE * 30) ;\</span>
<span class="p_add">+	SAVE_GPR(r31, BOOKE_GPR0_OFF + STRIDE_SIZE * 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_GPR \</span>
<span class="p_add">+	RESTORE_GPR(r1, BOOKE_GPR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_GPR(r2, BOOKE_GPR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_GPR(r13, BOOKE_GPR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	RESTORE_GPR(r14, BOOKE_GPR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	RESTORE_GPR(r15, BOOKE_GPR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	RESTORE_GPR(r16, BOOKE_GPR0_OFF + STRIDE_SIZE * 16) ;\</span>
<span class="p_add">+	RESTORE_GPR(r17, BOOKE_GPR0_OFF + STRIDE_SIZE * 17) ;\</span>
<span class="p_add">+	RESTORE_GPR(r18, BOOKE_GPR0_OFF + STRIDE_SIZE * 18) ;\</span>
<span class="p_add">+	RESTORE_GPR(r19, BOOKE_GPR0_OFF + STRIDE_SIZE * 19) ;\</span>
<span class="p_add">+	RESTORE_GPR(r20, BOOKE_GPR0_OFF + STRIDE_SIZE * 20) ;\</span>
<span class="p_add">+	RESTORE_GPR(r21, BOOKE_GPR0_OFF + STRIDE_SIZE * 21) ;\</span>
<span class="p_add">+	RESTORE_GPR(r22, BOOKE_GPR0_OFF + STRIDE_SIZE * 22) ;\</span>
<span class="p_add">+	RESTORE_GPR(r23, BOOKE_GPR0_OFF + STRIDE_SIZE * 23) ;\</span>
<span class="p_add">+	RESTORE_GPR(r24, BOOKE_GPR0_OFF + STRIDE_SIZE * 24) ;\</span>
<span class="p_add">+	RESTORE_GPR(r25, BOOKE_GPR0_OFF + STRIDE_SIZE * 25) ;\</span>
<span class="p_add">+	RESTORE_GPR(r26, BOOKE_GPR0_OFF + STRIDE_SIZE * 26) ;\</span>
<span class="p_add">+	RESTORE_GPR(r27, BOOKE_GPR0_OFF + STRIDE_SIZE * 27) ;\</span>
<span class="p_add">+	RESTORE_GPR(r28, BOOKE_GPR0_OFF + STRIDE_SIZE * 28) ;\</span>
<span class="p_add">+	RESTORE_GPR(r29, BOOKE_GPR0_OFF + STRIDE_SIZE * 29) ;\</span>
<span class="p_add">+	RESTORE_GPR(r30, BOOKE_GPR0_OFF + STRIDE_SIZE * 30) ;\</span>
<span class="p_add">+	RESTORE_GPR(r31, BOOKE_GPR0_OFF + STRIDE_SIZE * 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_SPRG \</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG0, BOOKE_SPRG0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG1, BOOKE_SPRG0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG2, BOOKE_SPRG0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG3, BOOKE_SPRG0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG4, BOOKE_SPRG0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG5, BOOKE_SPRG0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG6, BOOKE_SPRG0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG7, BOOKE_SPRG0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG8, BOOKE_SPRG0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_SPRG9, BOOKE_SPRG0_OFF + STRIDE_SIZE * 9)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_SPRG \</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG0, BOOKE_SPRG0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG1, BOOKE_SPRG0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG2, BOOKE_SPRG0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG3, BOOKE_SPRG0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG4, BOOKE_SPRG0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG5, BOOKE_SPRG0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG6, BOOKE_SPRG0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG7, BOOKE_SPRG0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG8, BOOKE_SPRG0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_SPRG9, BOOKE_SPRG0_OFF + STRIDE_SIZE * 9)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SAVE_ALL_IVOR \</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR0, BOOKE_IVOR0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR1, BOOKE_IVOR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR2, BOOKE_IVOR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR3, BOOKE_IVOR0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR4, BOOKE_IVOR0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR5, BOOKE_IVOR0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR6, BOOKE_IVOR0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR7, BOOKE_IVOR0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR8, BOOKE_IVOR0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR9, BOOKE_IVOR0_OFF + STRIDE_SIZE * 9) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR10, BOOKE_IVOR0_OFF + STRIDE_SIZE * 10) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR11, BOOKE_IVOR0_OFF + STRIDE_SIZE * 11) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR12, BOOKE_IVOR0_OFF + STRIDE_SIZE * 12) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR13, BOOKE_IVOR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR14, BOOKE_IVOR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR15, BOOKE_IVOR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR35, BOOKE_IVOR0_OFF + STRIDE_SIZE * 35) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR36, BOOKE_IVOR0_OFF + STRIDE_SIZE * 36) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR37, BOOKE_IVOR0_OFF + STRIDE_SIZE * 37) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR38, BOOKE_IVOR0_OFF + STRIDE_SIZE * 38) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR39, BOOKE_IVOR0_OFF + STRIDE_SIZE * 39) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR40, BOOKE_IVOR0_OFF + STRIDE_SIZE * 40) ;\</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVOR41, BOOKE_IVOR0_OFF + STRIDE_SIZE * 41)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RESTORE_ALL_IVOR \</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR0, BOOKE_IVOR0_OFF + STRIDE_SIZE * 0) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR1, BOOKE_IVOR0_OFF + STRIDE_SIZE * 1) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR2, BOOKE_IVOR0_OFF + STRIDE_SIZE * 2) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR3, BOOKE_IVOR0_OFF + STRIDE_SIZE * 3) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR4, BOOKE_IVOR0_OFF + STRIDE_SIZE * 4) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR5, BOOKE_IVOR0_OFF + STRIDE_SIZE * 5) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR6, BOOKE_IVOR0_OFF + STRIDE_SIZE * 6) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR7, BOOKE_IVOR0_OFF + STRIDE_SIZE * 7) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR8, BOOKE_IVOR0_OFF + STRIDE_SIZE * 8) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR9, BOOKE_IVOR0_OFF + STRIDE_SIZE * 9) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR10, BOOKE_IVOR0_OFF + STRIDE_SIZE * 10) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR11, BOOKE_IVOR0_OFF + STRIDE_SIZE * 11) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR12, BOOKE_IVOR0_OFF + STRIDE_SIZE * 12) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR13, BOOKE_IVOR0_OFF + STRIDE_SIZE * 13) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR14, BOOKE_IVOR0_OFF + STRIDE_SIZE * 14) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR15, BOOKE_IVOR0_OFF + STRIDE_SIZE * 15) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR35, BOOKE_IVOR0_OFF + STRIDE_SIZE * 35) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR36, BOOKE_IVOR0_OFF + STRIDE_SIZE * 36) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR37, BOOKE_IVOR0_OFF + STRIDE_SIZE * 37) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR38, BOOKE_IVOR0_OFF + STRIDE_SIZE * 38) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR39, BOOKE_IVOR0_OFF + STRIDE_SIZE * 39) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR40, BOOKE_IVOR0_OFF + STRIDE_SIZE * 40) ;\</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVOR41, BOOKE_IVOR0_OFF + STRIDE_SIZE * 41)</span>
<span class="p_add">+</span>
<span class="p_add">+/* reset time base to prevent from overflow */</span>
<span class="p_add">+#define DELAY(count)		\</span>
<span class="p_add">+	li	r3, count;	\</span>
<span class="p_add">+	li	r4, 0;		\</span>
<span class="p_add">+	mtspr	SPRN_TBWL, r4;	\</span>
<span class="p_add">+101:	mfspr	r4, SPRN_TBRL;	\</span>
<span class="p_add">+	cmpw	r4, r3;		\</span>
<span class="p_add">+	blt	101b</span>
<span class="p_add">+</span>
<span class="p_add">+#define FSL_DIS_ALL_IRQ		\</span>
<span class="p_add">+	mfmsr	r8;			\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_CE;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_ME;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_EE;	\</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~MSR_DE;	\</span>
<span class="p_add">+	mtmsr	r8;			\</span>
<span class="p_add">+	isync</span>
<span class="p_add">+</span>
<span class="p_add">+	.section .data</span>
<span class="p_add">+	.align	6</span>
<span class="p_add">+regs_buffer:</span>
<span class="p_add">+	.space BUFFER_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+	.section .text</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save CPU registers</span>
<span class="p_add">+ * r3 : the base address of the buffer which stores the values of registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+e5500_cpu_state_save:</span>
<span class="p_add">+	/* store the base address to r10 */</span>
<span class="p_add">+	mr	r10, r3</span>
<span class="p_add">+</span>
<span class="p_add">+	SAVE_ALL_GPR</span>
<span class="p_add">+	SAVE_ALL_SPRG</span>
<span class="p_add">+	SAVE_ALL_IVOR</span>
<span class="p_add">+</span>
<span class="p_add">+	SAVE_SPR(SPRN_IVPR, BOOKE_IVPR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_PID0, BOOKE_PID0_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_EPCR, BOOKE_EPCR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_HID0, BOOKE_HID0_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_PIR, BOOKE_PIR_OFF)</span>
<span class="p_add">+	SAVE_SPR(SPRN_BUCSR, BOOKE_BUCSR_OFF)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	mfspr	r5, SPRN_TBRU</span>
<span class="p_add">+	mfspr	r4, SPRN_TBRL</span>
<span class="p_add">+	SAVE_GPR(r5, BOOKE_TBU_OFF)</span>
<span class="p_add">+	SAVE_GPR(r4, BOOKE_TBL_OFF)</span>
<span class="p_add">+	mfspr	r3, SPRN_TBRU</span>
<span class="p_add">+	cmpw	r3, r5</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restore CPU registers</span>
<span class="p_add">+ * r3 : the base address of the buffer which stores the values of registers</span>
<span class="p_add">+ */</span>
<span class="p_add">+e5500_cpu_state_restore:</span>
<span class="p_add">+	/* store the base address to r10 */</span>
<span class="p_add">+	mr	r10, r3</span>
<span class="p_add">+</span>
<span class="p_add">+	RESTORE_ALL_GPR</span>
<span class="p_add">+	RESTORE_ALL_SPRG</span>
<span class="p_add">+	RESTORE_ALL_IVOR</span>
<span class="p_add">+</span>
<span class="p_add">+	RESTORE_SPR(SPRN_IVPR, BOOKE_IVPR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_PID0, BOOKE_PID0_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_EPCR, BOOKE_EPCR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_HID0, BOOKE_HID0_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_PIR, BOOKE_PIR_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_BUCSR, BOOKE_BUCSR_OFF)</span>
<span class="p_add">+</span>
<span class="p_add">+	li	r0, 0</span>
<span class="p_add">+	mtspr	SPRN_TBWL, r0</span>
<span class="p_add">+	RESTORE_SPR(SPRN_TBWU, BOOKE_TBU_OFF)</span>
<span class="p_add">+	RESTORE_SPR(SPRN_TBWL, BOOKE_TBL_OFF)</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPC_CPCCSR0		0x0</span>
<span class="p_add">+#define CPC_CPCCSR0_CPCFL	0x800</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Flush the CPC cache.</span>
<span class="p_add">+ * r3 : the base address of CPC</span>
<span class="p_add">+ */</span>
<span class="p_add">+flush_cpc_cache:</span>
<span class="p_add">+	lwz	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	ori	r6, r6, CPC_CPCCSR0_CPCFL</span>
<span class="p_add">+	stw	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait until completing the flush */</span>
<span class="p_add">+1:	lwz	r6, CPC_CPCCSR0(r3)</span>
<span class="p_add">+	andi.	r6, r6, CPC_CPCCSR0_CPCFL</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the last stage to enter deep sleep</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.align 6</span>
<span class="p_add">+_GLOBAL(fsl_dp_enter_low)</span>
<span class="p_add">+deepsleep_start:</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, buf_tmp)</span>
<span class="p_add">+	/* save the return address and MSR */</span>
<span class="p_add">+	mflr	r8</span>
<span class="p_add">+	PPC_STL r8, 0(r9)</span>
<span class="p_add">+	mfmsr	r8</span>
<span class="p_add">+	PPC_STL r8, 8(r9)</span>
<span class="p_add">+	mfspr	r8, SPRN_TCR</span>
<span class="p_add">+	PPC_STL r8, 16(r9)</span>
<span class="p_add">+	mfcr	r8</span>
<span class="p_add">+	PPC_STL	r8, 24(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	li	r8, 0</span>
<span class="p_add">+	mtspr	SPRN_TCR, r8</span>
<span class="p_add">+</span>
<span class="p_add">+	/* save the parameters */</span>
<span class="p_add">+	PPC_STL	r3, 32(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_save</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore the parameters */</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, buf_tmp)</span>
<span class="p_add">+	PPC_LL	r31, 32(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* flush caches inside CPU */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, cur_cpu_spec)</span>
<span class="p_add">+	PPC_LL	r3, 0(r3)</span>
<span class="p_add">+	PPC_LL	r3, CPU_DOWN_FLUSH(r3)</span>
<span class="p_add">+	PPC_LCMPI  0, r3, 0</span>
<span class="p_add">+	beq	10f</span>
<span class="p_add">+#ifdef CONFIG_PPC64</span>
<span class="p_add">+	PPC_LL	r3, 0(r3)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	bctrl</span>
<span class="p_add">+10:</span>
<span class="p_add">+	/* Flush the CPC cache */</span>
<span class="p_add">+	PPC_LL	r3, CCSR_CPC_BASE(r31)</span>
<span class="p_add">+	bl	flush_cpc_cache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prefecth TLB */</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT	0x0008</span>
<span class="p_add">+#define CCSR_GPIO1_GPDAT_29	0x4</span>
<span class="p_add">+	PPC_LL	r11, CCSR_GPIO1_BASE(r31)</span>
<span class="p_add">+	addi	r11, r11, CCSR_GPIO1_GPDAT</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_RCPM_PCPH15SETR	0x0b4</span>
<span class="p_add">+#define CCSR_RCPM_PCPH15SETR_CORE0	0x1</span>
<span class="p_add">+	PPC_LL	r12, CCSR_RCPM_BASE(r31)</span>
<span class="p_add">+	addi	r12, r12, CCSR_RCPM_PCPH15SETR</span>
<span class="p_add">+	lwz	r10, 0(r12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_DDR_SDRAM_CFG_2	0x114</span>
<span class="p_add">+#define CCSR_DDR_SDRAM_CFG_2_FRC_SR	0x80000000</span>
<span class="p_add">+	PPC_LL	r13, CCSR_DDR_BASE(r31)</span>
<span class="p_add">+	addi	r13, r13, CCSR_DDR_SDRAM_CFG_2</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+#define	DCSR_EPU_EPGCR		0x000</span>
<span class="p_add">+#define DCSR_EPU_EPGCR_GCE	0x80000000</span>
<span class="p_add">+	PPC_LL	r14, DCSR_EPU_BASE(r31)</span>
<span class="p_add">+	addi	r14, r14, DCSR_EPU_EPGCR</span>
<span class="p_add">+	lwz	r10, 0(r14)</span>
<span class="p_add">+</span>
<span class="p_add">+#define	DCSR_EPU_EPECR15	0x33C</span>
<span class="p_add">+#define DCSR_EPU_EPECR15_IC0	0x80000000</span>
<span class="p_add">+	PPC_LL	r15, DCSR_EPU_BASE(r31)</span>
<span class="p_add">+	addi	r15, r15, DCSR_EPU_EPECR15</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR_SCFG_QMIFRSTCR		0x40c</span>
<span class="p_add">+#define CCSR_SCFG_QMIFRSTCR_QMIFRST	0x80000000</span>
<span class="p_add">+	PPC_LL	r16, CCSR_SCFG_BASE(r31)</span>
<span class="p_add">+	addi	r16, r16, CCSR_SCFG_QMIFRSTCR</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+</span>
<span class="p_add">+	LOAD_REG_ADDR(r8, deepsleep_start)</span>
<span class="p_add">+	LOAD_REG_ADDR(r9, deepsleep_end)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* prefecth code to cache so that executing code after disable DDR */</span>
<span class="p_add">+1:	icbtls	2, 0, r8</span>
<span class="p_add">+	addi	r8, r8, 64</span>
<span class="p_add">+	cmpw	r8, r9</span>
<span class="p_add">+	blt	1b</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Place DDR controller in self refresh mode.</span>
<span class="p_add">+	 * From here on, can&#39;t access DDR any more.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+	oris	r10, r10, CCSR_DDR_SDRAM_CFG_2_FRC_SR@h</span>
<span class="p_add">+	stw	r10, 0(r13)</span>
<span class="p_add">+	lwz	r10, 0(r13)</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	DELAY(500)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set GPIO1_29 to lock the signal MCKE down during deep sleep.</span>
<span class="p_add">+	 * The bootloader will clear it when wakeup.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+	ori	r10, r10, CCSR_GPIO1_GPDAT_29</span>
<span class="p_add">+	stw	r10, 0(r11)</span>
<span class="p_add">+	lwz	r10, 0(r11)</span>
<span class="p_add">+</span>
<span class="p_add">+	DELAY(100)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reset QMan system bus interface */</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+	oris	r10, r10, CCSR_SCFG_QMIFRSTCR_QMIFRST@h</span>
<span class="p_add">+	stw	r10, 0(r16)</span>
<span class="p_add">+	lwz	r10, 0(r16)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable all EPU Counters */</span>
<span class="p_add">+	li	r10, 0</span>
<span class="p_add">+	oris	r10, r10, DCSR_EPU_EPGCR_GCE@h</span>
<span class="p_add">+	stw	r10, 0(r14)</span>
<span class="p_add">+	lwz	r10, 0(r14)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable SCU15 to trigger on RCPM Concentrator 0 */</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+	oris	r10, r10, DCSR_EPU_EPECR15_IC0@h</span>
<span class="p_add">+	stw	r10, 0(r15)</span>
<span class="p_add">+	lwz	r10, 0(r15)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* put Core0 in PH15 mode, trigger EPU FSM */</span>
<span class="p_add">+	lwz	r10, 0(r12)</span>
<span class="p_add">+	ori	r10, r10, CCSR_RCPM_PCPH15SETR_CORE0</span>
<span class="p_add">+	stw	r10, 0(r12)</span>
<span class="p_add">+2:</span>
<span class="p_add">+	b 2b</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Leave some space to prevent prefeching instruction</span>
<span class="p_add">+	 * beyond deepsleep_end. The space also can be used as heap.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+buf_tmp:</span>
<span class="p_add">+	.space 128</span>
<span class="p_add">+	.align 6</span>
<span class="p_add">+deepsleep_end:</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 12</span>
<span class="p_add">+#ifdef CONFIG_PPC32</span>
<span class="p_add">+_GLOBAL(fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+	/* disable interrupts */</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+#define ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+#define ENTRY_MAPPING_BOOT_SETUP</span>
<span class="p_add">+#include &lt;../../kernel/fsl_booke_entry_mapping.S&gt;</span>
<span class="p_add">+#undef ENTRY_DEEPSLEEP_SETUP</span>
<span class="p_add">+#undef ENTRY_MAPPING_BOOT_SETUP</span>
<span class="p_add">+</span>
<span class="p_add">+	li	r3, 0</span>
<span class="p_add">+	mfspr   r4, SPRN_PIR</span>
<span class="p_add">+	bl	call_setup_cpu</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load each CAM entry */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, tlbcam_index)</span>
<span class="p_add">+	lwz	r3, 0(r3)</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	li	r9, 0</span>
<span class="p_add">+3:	mr	r3, r9</span>
<span class="p_add">+	bl	loadcam_entry</span>
<span class="p_add">+	addi	r9, r9, 1</span>
<span class="p_add">+	bdnz	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore cpu registers */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_restore</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore return address */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, buf_tmp)</span>
<span class="p_add">+	lwz	r4, 16(r3)</span>
<span class="p_add">+	mtspr	SPRN_TCR, r4</span>
<span class="p_add">+	lwz	r4, 0(r3)</span>
<span class="p_add">+	mtlr	r4</span>
<span class="p_add">+	lwz	r4, 8(r3)</span>
<span class="p_add">+	mtmsr	r4</span>
<span class="p_add">+	lwz	r4, 24(r3)</span>
<span class="p_add">+	mtcr	r4</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* CONFIG_PPC32 */</span>
<span class="p_add">+</span>
<span class="p_add">+_GLOBAL(fsl_booke_deep_sleep_resume)</span>
<span class="p_add">+	/* disable interrupts */</span>
<span class="p_add">+	FSL_DIS_ALL_IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+	/* switch to 64-bit mode */</span>
<span class="p_add">+	bl	.enable_64b_mode</span>
<span class="p_add">+</span>
<span class="p_add">+	/* set TOC pointer */</span>
<span class="p_add">+	bl	.relative_toc</span>
<span class="p_add">+</span>
<span class="p_add">+	/* setup initial TLBs, switch to kernel space ... */</span>
<span class="p_add">+	bl	.start_initialization_book3e</span>
<span class="p_add">+</span>
<span class="p_add">+	/* address space changed, set TOC pointer again */</span>
<span class="p_add">+	bl	.relative_toc</span>
<span class="p_add">+</span>
<span class="p_add">+	/* call a cpu state restore handler */</span>
<span class="p_add">+	LOAD_REG_ADDR(r23, cur_cpu_spec)</span>
<span class="p_add">+	ld	r23,0(r23)</span>
<span class="p_add">+	ld	r23,CPU_SPEC_RESTORE(r23)</span>
<span class="p_add">+	cmpdi	0,r23,0</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	ld	r23,0(r23)</span>
<span class="p_add">+	mtctr	r23</span>
<span class="p_add">+	bctrl</span>
<span class="p_add">+1:</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, regs_buffer)</span>
<span class="p_add">+	bl	e5500_cpu_state_restore</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load each CAM entry */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, tlbcam_index)</span>
<span class="p_add">+	lwz	r3, 0(r3)</span>
<span class="p_add">+	mtctr	r3</span>
<span class="p_add">+	li	r0, 0</span>
<span class="p_add">+3:	mr	r3, r0</span>
<span class="p_add">+	bl	loadcam_entry</span>
<span class="p_add">+	addi	r0, r0, 1</span>
<span class="p_add">+	bdnz	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore return address */</span>
<span class="p_add">+	LOAD_REG_ADDR(r3, buf_tmp)</span>
<span class="p_add">+	ld	r4, 16(r3)</span>
<span class="p_add">+	mtspr	SPRN_TCR, r4</span>
<span class="p_add">+	ld	r4, 0(r3)</span>
<span class="p_add">+	mtlr	r4</span>
<span class="p_add">+	ld	r4, 8(r3)</span>
<span class="p_add">+	mtmsr	r4</span>
<span class="p_add">+	ld	r4, 24(r3)</span>
<span class="p_add">+	mtcr	r4</span>
<span class="p_add">+</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PPC32 */</span>
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_rcpm.c b/arch/powerpc/sysdev/fsl_rcpm.c</span>
<span class="p_header">index e5447ac..c2d8d37 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_rcpm.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_rcpm.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> static int rcpm_v2_plat_enter_sleep(int state)</span>
 {
 	u32 *pmcsr_reg = &amp;rcpm_v2_regs-&gt;powmgtcsr;
 	int ret = 0;
<span class="p_del">-	int result;</span>
<span class="p_add">+	int result, cpu;</span>
 
 	switch (state) {
 	case FSL_PM_SLEEP:
<span class="p_chunk">@@ -269,6 +269,12 @@</span> <span class="p_context"> static int rcpm_v2_plat_enter_sleep(int state)</span>
 			ret = -ETIMEDOUT;
 		}
 		break;
<span class="p_add">+	case FSL_PM_DEEP_SLEEP:</span>
<span class="p_add">+		cpu = smp_processor_id();</span>
<span class="p_add">+		rcpm_v2_irq_mask(cpu);</span>
<span class="p_add">+		ret = fsl_enter_deepsleep();</span>
<span class="p_add">+		rcpm_v2_irq_unmask(cpu);</span>
<span class="p_add">+		break;</span>
 	default:
 		pr_warn(&quot;Unknown platform PM state (%d)\n&quot;, state);
 		ret = -EINVAL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



