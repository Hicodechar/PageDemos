
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v5,5/6] iommu/mediatek: Add mt8173 IOMMU driver - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v5,5/6] iommu/mediatek: Add mt8173 IOMMU driver</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 9, 2015, 2:23 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1444357388-30257-6-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7358841/mbox/"
   >mbox</a>
|
   <a href="/patch/7358841/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7358841/">/patch/7358841/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id B7FE8BEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 02:24:50 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 99CBE20825
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 02:24:48 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 99B9D20819
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 02:24:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934771AbbJICYk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 8 Oct 2015 22:24:40 -0400
Received: from mailgw02.mediatek.com ([210.61.82.184]:47217 &quot;EHLO
	mailgw02.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S934747AbbJICYg (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 8 Oct 2015 22:24:36 -0400
X-Listener-Flag: 11101
Received: from mtkhts09.mediatek.inc [(172.21.101.70)] by
	mailgw02.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 1502909456; Fri, 09 Oct 2015 10:24:34 +0800
Received: from localhost.localdomain (10.17.3.153) by mtkhts09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.181.6;
	Fri, 9 Oct 2015 10:24:32 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;, Thierry Reding &lt;treding@nvidia.com&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;, Rob Herring &lt;robh+dt@kernel.org&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;,
	Sricharan R &lt;sricharan@codeaurora.org&gt;,
	&lt;youhua.li@mediatek.com&gt;, &lt;k.zhang@mediatek.com&gt;,
	&lt;kendrick.hsu@mediatek.com&gt;, Yong Wu &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v5 5/6] iommu/mediatek: Add mt8173 IOMMU driver
Date: Fri, 9 Oct 2015 10:23:07 +0800
Message-ID: &lt;1444357388-30257-6-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1444357388-30257-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1444357388-30257-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Oct. 9, 2015, 2:23 a.m.</div>
<pre class="content">
This patch adds support for mediatek m4u (MultiMedia Memory Management
Unit).
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig     |  15 +
 drivers/iommu/Makefile    |   1 +
 drivers/iommu/mtk_iommu.c | 767 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 783 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Oct. 14, 2015, 12:53 p.m.</div>
<pre class="content">
On Fri, Oct 09, 2015 at 10:23:07AM +0800, Yong Wu wrote:
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * There is a domain for each a iommu device in normal case.</span>
<span class="quote">&gt; +	 * But MTK only has one iommu domain called the m4u domain which all</span>
<span class="quote">&gt; +	 * the multimedia HW share. Here we reserve one as the m4u domain and</span>
<span class="quote">&gt; +	 * free the others.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * And the attach_device that from __iommu_setup_dma_ops</span>
<span class="quote">&gt; +	 * will be called earlier than probe.</span>
<span class="quote">&gt; +	 */</span>

Okay, with this being the case, you need to put all devices behind one
IOMMU into the same iommu-group, because the IOMMU can&#39;t really isolate
the devices from each other.
<span class="quote">
&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; +	struct iommu_domain *domain;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; +	if (!group) {</span>
<span class="quote">&gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; +		goto err_group_put;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	domain = iommu_get_domain_for_dev(dev);</span>
<span class="quote">&gt; +	if (!domain) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Get the m4u iommu domain from the m4u device.</span>
<span class="quote">&gt; +		 * Attach all the client devices into the m4u domain.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +		m4udom = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; +		if (ret)</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_group_put:</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>

Here it looks like you are allocating one group for each device. As I
said, all devices need to be in one group.



	Joerg

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Oct. 26, 2015, 5:23 a.m.</div>
<pre class="content">
On Wed, 2015-10-14 at 14:53 +0200, Joerg Roedel wrote:
<span class="quote">&gt; On Fri, Oct 09, 2015 at 10:23:07AM +0800, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * There is a domain for each a iommu device in normal case.</span>
<span class="quote">&gt; &gt; +	 * But MTK only has one iommu domain called the m4u domain which all</span>
<span class="quote">&gt; &gt; +	 * the multimedia HW share. Here we reserve one as the m4u domain and</span>
<span class="quote">&gt; &gt; +	 * free the others.</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * And the attach_device that from __iommu_setup_dma_ops</span>
<span class="quote">&gt; &gt; +	 * will be called earlier than probe.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Okay, with this being the case, you need to put all devices behind one</span>
<span class="quote">&gt; IOMMU into the same iommu-group, because the IOMMU can&#39;t really isolate</span>
<span class="quote">&gt; the devices from each other.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; &gt; +	struct iommu_domain *domain;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; &gt; +	if (!group) {</span>
<span class="quote">&gt; &gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +		goto err_group_put;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	domain = iommu_get_domain_for_dev(dev);</span>
<span class="quote">&gt; &gt; +	if (!domain) {</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * Get the m4u iommu domain from the m4u device.</span>
<span class="quote">&gt; &gt; +		 * Attach all the client devices into the m4u domain.</span>
<span class="quote">&gt; &gt; +		 */</span>
<span class="quote">&gt; &gt; +		priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +		m4udom = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; &gt; +		if (ret)</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_group_put:</span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here it looks like you are allocating one group for each device. As I</span>
<span class="quote">&gt; said, all devices need to be in one group.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	Joerg</span>
<span class="quote">&gt; </span>

Thanks for this suggestion. I have put all the iommu client devices into
the same iommu group, the code looks like below.
And I will send this in the next version after the Short descriptor is
reviewed.


static int mtk_iommu_add_device(struct device *dev)
{
	struct iommu_group *group;
	struct mtk_iommu_client_priv *priv;
	struct mtk_iommu_domain *m4udom;
	struct iommu_domain *domain;
	int ret;

	priv = dev-&gt;archdata.iommu;
	if (!priv) /* Not a iommu client device */
		return -ENODEV;
	m4udom = dev_get_drvdata(priv-&gt;m4udev);

	group = iommu_group_get(dev);
	if (!group) {
		/*
		 * All the iommu client devices are in the m4u domain,
		 * they all are in the same m4u iommu-group too here.
		 */
		if (!m4udom-&gt;m4u_group) {
			group = iommu_group_alloc();
			if (IS_ERR(group)) {
				dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);
				return PTR_ERR(group);
			}
			m4udom-&gt;m4u_group = group;
		} else {
			group = m4udom-&gt;m4u_group;
		}
	}

	ret = iommu_group_add_device(group, dev);
	if (ret) {
		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);
		goto err_group_put;
	}

	domain = iommu_get_domain_for_dev(dev);
	if (!domain)
		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);

err_group_put:
	iommu_group_put(group);
	return ret;
}

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Oct. 27, 2015, 1:25 p.m.</div>
<pre class="content">
On 09/10/15 03:23, Yong Wu wrote:
[...]
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/dma-iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_platform.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/list.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/clk.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iopoll.h&gt;</span>

Nit: ordering?
<span class="quote">
&gt; +#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; +#include &quot;io-pgtable.h&quot;</span>

[...]
<span class="quote">&gt; +struct mtk_iommu_data {</span>
<span class="quote">&gt; +	void __iomem			*base;</span>
<span class="quote">&gt; +	int				irq;</span>
<span class="quote">&gt; +	struct device			*dev;</span>
<span class="quote">&gt; +	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; +	struct clk			*bclk;</span>
<span class="quote">&gt; +	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="quote">&gt; +	int				larb_nr;/* local arbiter number */</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg	reg;</span>
<span class="quote">&gt; +};</span>

I think I&#39;ve finally got my head round the way this hardware works - 
each LARB can be configured to block or allow transactions from the 
client device behind each port, but they _don&#39;t_ otherwise pass any 
information downstream such that the M4U itself can identify individual 
transactions, right? If that is indeed the case, then Joerg is totally 
correct that all clients of one M4U should be in a single group, so you 
might as well keep a handy iommu_group pointer here. I&#39;ll refer back to 
that idea later...

[...]
<span class="quote">&gt; +static void mtk_iommu_clear_intr(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	val = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +	val |= F_INT_L2_CLR_BIT;</span>
<span class="quote">&gt; +	writel_relaxed(val, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +}</span>

Do you anticipate any other callers of this? AFAICS these 3 lines could 
just be rolled into mtk_iommu_isr().
<span class="quote">
&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +	void __iomem *base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +	writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +	mb();/* Make sure flush all done */</span>

If it&#39;s purely to make sure the write has completed, would wmb() be 
sufficient here?
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; +				    bool leaf, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; +	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>

Nit: why not simply name the argument iova_start in the first place, or 
just use iova below?
<span class="quote">
&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +	writel_relaxed(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +	writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +	u32 tmp;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,</span>
<span class="quote">&gt; +					tmp != 0, 10, 1000000);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_warn(domain-&gt;data-&gt;dev,</span>
<span class="quote">&gt; +			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="quote">&gt; +		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	writel_relaxed(0, base + REG_MMU_CPE_DONE);</span>

Do you still need this writeback in the ret==0 case when you&#39;ve already 
read CPE_DONE as 0, or should this be inside the condition? (in which 
case you could also use an early return to lose the indent)
<span class="quote">
&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdom)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +	u32 regval;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed to enable iommu clk(%d)\n&quot;, ret);</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +	}</span>

I&#39;m not sure about the asymmetry here; the clock gets enabled when 
attaching clients to a domain, but not disabled until the IOMMU itself 
is torn down in mtk_iommu_remove() (i.e. never). It seems like either 
the clock should be enabled in mtk_iommu_probe(), or disabled in domain 
detach.
<span class="quote">
&gt; +	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; +		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="quote">&gt; +		F_COHERENCE_EN;</span>
<span class="quote">&gt; +	writel_relaxed(regval, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; +		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="quote">&gt; +		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="quote">&gt; +		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="quote">&gt; +	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; +		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; +		F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; +		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; +		F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; +		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="quote">&gt; +		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="quote">&gt; +	writel_relaxed(regval, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = ALIGN(data-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; +	regval = F_MMU_IVRP_PA_SET(regval);</span>

 From the look of it, it might not hurt to just fold the ALIGN() into 
the F_MMU_IVRP_PA_SET() macro itself.
<span class="quote">
&gt; +	writel_relaxed(regval, base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(0, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +	writel_relaxed(0, base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; +			     dev_name(data-&gt;dev), (void *)mtkdom)) {</span>
<span class="quote">&gt; +		writel_relaxed(0, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	}</span>

Maybe balance this with a devm_free_irq() in mtk_iommu_domain_free()? 
(otherwise it&#39;s hanging around forever since the platform bus never 
seems to get destroyed)
<span class="quote">
&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_config(struct mtk_iommu_domain *mtkdom</span>
<span class="quote">&gt; +			    struct device *dev, bool enable)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; +		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {</span>
<span class="quote">&gt; +			dev_err(data-&gt;dev, &quot;Invalid larb:%d\n&quot;, cur-&gt;larbid);</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="quote">&gt; +				    cur-&gt;portid, enable);</span>
<span class="quote">&gt; +		if (!enable) {</span>
<span class="quote">&gt; +			list_del(&amp;cur-&gt;client);</span>
<span class="quote">&gt; +			kfree(cur);</span>
<span class="quote">&gt; +		}</span>

This list wasn&#39;t created by attach_device(), so it doesn&#39;t look right 
that detach_device() should cause it to be freed - I think this teardown 
belongs in mtk_iommu_remove_device(), as the counterpoint to the 
of_xlate/add_device operation.
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!enable) {</span>
<span class="quote">&gt; +		kfree(head);</span>
<span class="quote">&gt; +		dev-&gt;archdata.iommu = NULL;</span>

Ditto.
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				   struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *priv = to_mtk_domain(domain), *m4udom;</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *clientpriv;</span>
<span class="quote">&gt; +	struct device *m4udev;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	clientpriv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!clientpriv)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	m4udev = clientpriv-&gt;m4udev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * There is a domain for each a iommu device in normal case.</span>
<span class="quote">&gt; +	 * But MTK only has one iommu domain called the m4u domain which all</span>
<span class="quote">&gt; +	 * the multimedia HW share. Here we reserve one as the m4u domain and</span>
<span class="quote">&gt; +	 * free the others.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * And the attach_device that from __iommu_setup_dma_ops</span>
<span class="quote">&gt; +	 * will be called earlier than probe.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	m4udom = dev_get_drvdata(m4udev);</span>
<span class="quote">&gt; +	if (!m4udom)</span>
<span class="quote">&gt; +		dev_set_drvdata(m4udev, priv);</span>
<span class="quote">&gt; +	else if (m4udom != priv)</span>
<span class="quote">&gt; +		iommu_domain_free(domain);</span>

With the client devices in a single group, then I realise we shouldn&#39;t 
actually need any special handling of domains at all - we can freely 
create multiple domains, and since the group can only be attached to one 
at a time, all we do is point the hardware at the relevant page table on 
attach, and reset it on detach. That should make life somewhat easier, 
and means we no longer have to subvert the IOMMU API like this.
<span class="quote">
&gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; +	if (!group)</span>

Either way you shouldn&#39;t need this - you&#39;ve already bailed out if this 
isn&#39;t one of your client devices (via the dev-&gt;archdata.iommu check), 
and if it is, then it already has a group by virtue of 
mtk_iommu_add_device()...
<span class="quote">
&gt; +		return 0;</span>

...and regardless, indicating success without attaching anything to 
anything looks very off.
<span class="quote">
&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Initial the m4u domain context which is from the add_device */</span>
<span class="quote">&gt; +	ret = mtk_iommu_init_domain_context(priv);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return mtk_iommu_config(priv, dev, true);</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; +	struct iommu_domain *domain;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get(dev);</span>

If this became just a case of looking up mtk_iommu_data-&gt;group in 
archdata.iommu and adding this device to it, then everything else here 
should be able to go away - the arch code will create a default domain 
for the first device in the group, then sees each subsequent device 
appear in that domain as you add them, so just sets their dma_ops 
without any further interference (I have tested multi-device groups!)
<span class="quote">
&gt; +	if (!group) {</span>
<span class="quote">&gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>

(although you might still need the lazy group allocation here if 
mtk_iommu_probe() turns out to run too early to do it).
<span class="quote">
&gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; +		goto err_group_put;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	domain = iommu_get_domain_for_dev(dev);</span>
<span class="quote">&gt; +	if (!domain) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Get the m4u iommu domain from the m4u device.</span>
<span class="quote">&gt; +		 * Attach all the client devices into the m4u domain.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +		m4udom = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; +		if (ret)</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_group_put:</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct platform_device *pdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>

Hmm, is it OK that the driver isn&#39;t yet registered at this point? If you 
can guarantee that none of the client devices will also be registering 
their drivers at subsys_initcall level, then I guess it works out 
reasonably safe in practice, but it still smells a bit racy.
<span class="quote">
&gt; +	if (IS_ERR(pdev))</span>
<span class="quote">&gt; +		return PTR_ERR(pdev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data   *data;</span>
<span class="quote">&gt; +	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; +	void __iomem	        *protect;</span>
<span class="quote">&gt; +	int                     ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!data)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	data-&gt;dev = dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; +	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!protect)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		return ret;</span>

Hopefully you could allocate your group here and avoid the extra 
complication in add_device, but it might be problematic if the early 
device creation means this gets called before sysfs is fully up and running.
<span class="quote">
&gt; +	m4udom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	if (m4udom)</span>
<span class="quote">&gt; +		m4udom-&gt;data = data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg *reg;</span>
<span class="quote">&gt; +	void __iomem *base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mtkdom)</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="quote">&gt; +	base = mtkdom-&gt;data-&gt;base;</span>
<span class="quote">&gt; +	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; +		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;ivrp_paddr, base + REG_MMU_IVRP_PADDR);</span>

On closer inspection, it looks pretty cheap to recalculate this one from 
data-&gt;protect_base, so perhaps that could be one less thing to save.
<span class="quote">
&gt; +	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>

Robin.

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Oct. 31, 2015, 8:28 a.m.</div>
<pre class="content">
On Tue, 2015-10-27 at 13:25 +0000, Robin Murphy wrote:
<span class="quote">&gt; On 09/10/15 03:23, Yong Wu wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/dma-iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/of_platform.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/list.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/clk.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/iopoll.h&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: ordering?</span>

Yes. Thanks. I will order them in next time.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; &gt; +#include &quot;io-pgtable.h&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +struct mtk_iommu_data {</span>
<span class="quote">&gt; &gt; +	void __iomem			*base;</span>
<span class="quote">&gt; &gt; +	int				irq;</span>
<span class="quote">&gt; &gt; +	struct device			*dev;</span>
<span class="quote">&gt; &gt; +	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; &gt; +	struct clk			*bclk;</span>
<span class="quote">&gt; &gt; +	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="quote">&gt; &gt; +	int				larb_nr;/* local arbiter number */</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_suspend_reg	reg;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think I&#39;ve finally got my head round the way this hardware works - </span>
<span class="quote">&gt; each LARB can be configured to block or allow transactions from the </span>
<span class="quote">&gt; client device behind each port, but they _don&#39;t_ otherwise pass any </span>
<span class="quote">&gt; information downstream such that the M4U itself can identify individual </span>
<span class="quote">&gt; transactions, right? If that is indeed the case, then Joerg is totally </span>
<span class="quote">&gt; correct that all clients of one M4U should be in a single group, so you </span>
<span class="quote">&gt; might as well keep a handy iommu_group pointer here. I&#39;ll refer back to </span>
<span class="quote">&gt; that idea later...</span>

I will put them into a single group and rebase Joerg&#39;s patchset(iommu:
Make core iommu-groups code more generic) too. see later.
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_clear_intr(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	val = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +	val |= F_INT_L2_CLR_BIT;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(val, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Do you anticipate any other callers of this? AFAICS these 3 lines could </span>
<span class="quote">&gt; just be rolled into mtk_iommu_isr().</span>

Yes. Thanks. We can put it into the isr.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +	void __iomem *base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +	mb();/* Make sure flush all done */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If it&#39;s purely to make sure the write has completed, would wmb() be </span>
<span class="quote">&gt; sufficient here?</span>

YES.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; &gt; +				    bool leaf, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: why not simply name the argument iova_start in the first place, or </span>
<span class="quote">&gt; just use iova below?</span>

I will delete them and just use &quot;iova&quot; below.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +	u32 tmp;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,</span>
<span class="quote">&gt; &gt; +					tmp != 0, 10, 1000000);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_warn(domain-&gt;data-&gt;dev,</span>
<span class="quote">&gt; &gt; +			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="quote">&gt; &gt; +		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	writel_relaxed(0, base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Do you still need this writeback in the ret==0 case when you&#39;ve already </span>
<span class="quote">&gt; read CPE_DONE as 0, or should this be inside the condition? (in which </span>
<span class="quote">&gt; case you could also use an early return to lose the indent)</span>

Yes. I still need this writeback in the ret==0 case.

REG_MMU_CPE_DONE is the state of CPE. It&#39;s 1 while the non-secure range
invalidation is done. Write 1&#39;b0 is for the purpose of clearing the
current status, then we could check the next status again. So &quot;write 1&quot;
is also needed in ret==0 case.

so I will keep it and add a comment for more readable here.

writel_relaxed(0, base + REG_MMU_CPE_DONE);/* Clear the CPE state */
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdom)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; &gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt; +	u32 regval;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_err(data-&gt;dev, &quot;Failed to enable iommu clk(%d)\n&quot;, ret);</span>
<span class="quote">&gt; &gt; +		return ret;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not sure about the asymmetry here; the clock gets enabled when </span>
<span class="quote">&gt; attaching clients to a domain, but not disabled until the IOMMU itself </span>
<span class="quote">&gt; is torn down in mtk_iommu_remove() (i.e. never). It seems like either </span>
<span class="quote">&gt; the clock should be enabled in mtk_iommu_probe(), or disabled in domain </span>
<span class="quote">&gt; detach.</span>

From your comment, I realize that some places here is not asymmetry.
I will move this mtk_iommu_hw_init into mtk_iommu_probe.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; &gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; &gt; +		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="quote">&gt; &gt; +		F_COHERENCE_EN;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; &gt; +		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="quote">&gt; &gt; +		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; &gt; +		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; &gt; +		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="quote">&gt; &gt; +		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="quote">&gt; &gt; +		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	regval = ALIGN(data-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; &gt; +	regval = F_MMU_IVRP_PA_SET(regval);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  From the look of it, it might not hurt to just fold the ALIGN() into </span>
<span class="quote">&gt; the F_MMU_IVRP_PA_SET() macro itself.</span>

      If the ALIGN is moved into the macro, that line will be over 80
chars. so I seperate them.
      In the next version I will align data-&gt;protect_base in probe,
then the code here will be more simply. and it also could be used in
mtk_iommu_resume.
<span class="quote">      
&gt; </span>
<span class="quote">&gt; &gt; +	writel_relaxed(regval, base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	writel_relaxed(0, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(0, base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; &gt; +			     dev_name(data-&gt;dev), (void *)mtkdom)) {</span>
<span class="quote">&gt; &gt; +		writel_relaxed(0, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe balance this with a devm_free_irq() in mtk_iommu_domain_free()? </span>
<span class="quote">&gt; (otherwise it&#39;s hanging around forever since the platform bus never </span>
<span class="quote">&gt; seems to get destroyed)</span>

I will move the mtk_iommu_hw_init into mtk_iommu_probe, and add
devm_free_irq into mtk_iommu_remove.
(I cann&#39;t add devm_free_irq in mtk_iommu_domain_free and detach_device)
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_config(struct mtk_iommu_domain *mtkdom</span>
<span class="quote">&gt; &gt; +			    struct device *dev, bool enable)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; &gt; +		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {</span>
<span class="quote">&gt; &gt; +			dev_err(data-&gt;dev, &quot;Invalid larb:%d\n&quot;, cur-&gt;larbid);</span>
<span class="quote">&gt; &gt; +			return -EINVAL;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="quote">&gt; &gt; +				    cur-&gt;portid, enable);</span>
<span class="quote">&gt; &gt; +		if (!enable) {</span>
<span class="quote">&gt; &gt; +			list_del(&amp;cur-&gt;client);</span>
<span class="quote">&gt; &gt; +			kfree(cur);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This list wasn&#39;t created by attach_device(), so it doesn&#39;t look right </span>
<span class="quote">&gt; that detach_device() should cause it to be freed - I think this teardown </span>
<span class="quote">&gt; belongs in mtk_iommu_remove_device(), as the counterpoint to the </span>
<span class="quote">&gt; of_xlate/add_device operation.</span>

It is also asymmetry here. I will move kfree into
mtk_iommu_remove_device.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!enable) {</span>
<span class="quote">&gt; &gt; +		kfree(head);</span>
<span class="quote">&gt; &gt; +		dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +				   struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *priv = to_mtk_domain(domain), *m4udom;</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *clientpriv;</span>
<span class="quote">&gt; &gt; +	struct device *m4udev;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	clientpriv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	if (!clientpriv)</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +	m4udev = clientpriv-&gt;m4udev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * There is a domain for each a iommu device in normal case.</span>
<span class="quote">&gt; &gt; +	 * But MTK only has one iommu domain called the m4u domain which all</span>
<span class="quote">&gt; &gt; +	 * the multimedia HW share. Here we reserve one as the m4u domain and</span>
<span class="quote">&gt; &gt; +	 * free the others.</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * And the attach_device that from __iommu_setup_dma_ops</span>
<span class="quote">&gt; &gt; +	 * will be called earlier than probe.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	m4udom = dev_get_drvdata(m4udev);</span>
<span class="quote">&gt; &gt; +	if (!m4udom)</span>
<span class="quote">&gt; &gt; +		dev_set_drvdata(m4udev, priv);</span>
<span class="quote">&gt; &gt; +	else if (m4udom != priv)</span>
<span class="quote">&gt; &gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; With the client devices in a single group, then I realise we shouldn&#39;t </span>
<span class="quote">&gt; actually need any special handling of domains at all - we can freely </span>
<span class="quote">&gt; create multiple domains, and since the group can only be attached to one </span>
<span class="quote">&gt; at a time, all we do is point the hardware at the relevant page table on </span>
<span class="quote">&gt; attach, and reset it on detach. That should make life somewhat easier, </span>
<span class="quote">&gt; and means we no longer have to subvert the IOMMU API like this.</span>

&quot;we can freely create multiple domains&quot;, 
Do we need to free the unnecessary domain here?

This function also is a little complex after changed to a single group.
see below.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; &gt; +	if (!group)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Either way you shouldn&#39;t need this - you&#39;ve already bailed out if this </span>
<span class="quote">&gt; isn&#39;t one of your client devices (via the dev-&gt;archdata.iommu check), </span>
<span class="quote">&gt; and if it is, then it already has a group by virtue of </span>
<span class="quote">&gt; mtk_iommu_add_device()...</span>

I think I can not use &quot;dev-&gt;archdata.iommu&quot; to break here.
Like the comment &quot;the attach_device that from __iommu_setup_dma_ops
will be called earlier than probe.&quot;

If I use dev-&gt;archdata.iommu, the code will also go down. But at that
time some data has not been initialization(dev_get_drvdata is null).

So I use iommu_group_get to guarantee the sequence: The code could go
down only after the mtk_iommu_probe.
<span class="quote">

&gt; </span>
<span class="quote">&gt; &gt; +		return 0;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...and regardless, indicating success without attaching anything to </span>
<span class="quote">&gt; anything looks very off.</span>

I have to return &quot;0&quot; here.
I need the DMA help update dev-&gt;archdata.dma_ops into iommu_dma_ops.
(If I don&#39;t return 0 here, the do_iommu_attach will never update
archdata-&gt;dma_ops for the client device.)

If I am wrong, please tell me. Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Initial the m4u domain context which is from the add_device */</span>
<span class="quote">&gt; &gt; +	ret = mtk_iommu_init_domain_context(priv);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		return ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return mtk_iommu_config(priv, dev, true);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; &gt; +	struct iommu_domain *domain;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	group = iommu_group_get(dev);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If this became just a case of looking up mtk_iommu_data-&gt;group in </span>
<span class="quote">&gt; archdata.iommu and adding this device to it, then everything else here </span>
<span class="quote">&gt; should be able to go away - the arch code will create a default domain </span>
<span class="quote">&gt; for the first device in the group, then sees each subsequent device </span>
<span class="quote">&gt; appear in that domain as you add them, so just sets their dma_ops </span>
<span class="quote">&gt; without any further interference (I have tested multi-device groups!)</span>

Do you mean this function &quot;iommu_group_get_for_dev&quot; which will create a
default domain?
I also notice that Joerg&#39;s &quot;iommu: Make core iommu-groups code more
generic&quot; patchset has a device_group callback, then I could return the
same iommu group easily.
So I add this patchset and test, then the code flow is changed greatly.
see below.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	if (!group) {</span>
<span class="quote">&gt; &gt; +		group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(group)) {</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +			return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (although you might still need the lazy group allocation here if </span>
<span class="quote">&gt; mtk_iommu_probe() turns out to run too early to do it).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; &gt; +	if (ret) {</span>
<span class="quote">&gt; &gt; +		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +		goto err_group_put;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	domain = iommu_get_domain_for_dev(dev);</span>
<span class="quote">&gt; &gt; +	if (!domain) {</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * Get the m4u iommu domain from the m4u device.</span>
<span class="quote">&gt; &gt; +		 * Attach all the client devices into the m4u domain.</span>
<span class="quote">&gt; &gt; +		 */</span>
<span class="quote">&gt; &gt; +		priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +		m4udom = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="quote">&gt; &gt; +		if (ret)</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_group_put:</span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +	return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct platform_device *pdev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, is it OK that the driver isn&#39;t yet registered at this point? If you </span>
<span class="quote">&gt; can guarantee that none of the client devices will also be registering </span>
<span class="quote">&gt; their drivers at subsys_initcall level, then I guess it works out </span>
<span class="quote">&gt; reasonably safe in practice, but it still smells a bit racy.</span>

Do you means that we could delete of_platform_device_create here if I
can guarantee none of the client devices is registered at
subsys_initcall level?

I think all the iommu client devices should be called after our iommu
device, but it will be more safe if there is of_platform_device_create
here.

sorry, I may misunderstand here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	if (IS_ERR(pdev))</span>
<span class="quote">&gt; &gt; +		return PTR_ERR(pdev);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data   *data;</span>
<span class="quote">&gt; &gt; +	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *m4udom;</span>
<span class="quote">&gt; &gt; +	void __iomem	        *protect;</span>
<span class="quote">&gt; &gt; +	int                     ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!data)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +	data-&gt;dev = dev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; &gt; +	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!protect)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +	data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="quote">&gt; &gt; +	if (ret)</span>
<span class="quote">&gt; &gt; +		return ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hopefully you could allocate your group here and avoid the extra </span>
<span class="quote">&gt; complication in add_device, but it might be problematic if the early </span>
<span class="quote">&gt; device creation means this gets called before sysfs is fully up and running.</span>

If I use Joerg&#39;s patch, then we don&#39;t need allocate the group here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	m4udom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +	if (m4udom)</span>
<span class="quote">&gt; &gt; +		m4udom-&gt;data = data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_suspend_reg *reg;</span>
<span class="quote">&gt; &gt; +	void __iomem *base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!mtkdom)</span>
<span class="quote">&gt; &gt; +		return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="quote">&gt; &gt; +	base = mtkdom-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; &gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; &gt; +		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;ivrp_paddr, base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On closer inspection, it looks pretty cheap to recalculate this one from </span>
<span class="quote">&gt; data-&gt;protect_base, so perhaps that could be one less thing to save.</span>

Yes, It&#39;s OK.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>

After add Joerg&#39;s patchset[1], I test locally and it looks ok.

I copy most of the code here for your confirm.
If there is some place I don&#39;t understand your comment exactly, please
help tell me.
(I will sent it as the next version after the Short-desc is reviewed.)

[1]:
http://lists.linuxfoundation.org/pipermail/iommu/2015-October/014764.html

//===========================

struct mtk_iommu_domain {
	struct imu_pgd_t		*pgd;
	spinlock_t			pgtlock; /* lock for page table */

	struct io_pgtable_cfg		cfg;
	struct io_pgtable_ops		*iop;

	struct iommu_domain		domain;
};

struct mtk_iommu_data {
	void __iomem			*base;
	int				irq;
	struct device			*dev;
	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];
	struct clk			*bclk;
	phys_addr_t			protect_base; /* protect memory base */
	int				larb_nr;/* local arbiter number */
	struct mtk_iommu_suspend_reg	reg;
	struct mtk_iommu_domain		*m4udom;
	struct iommu_group		*m4ugroup;
};

static void mtk_iommu_tlb_flush_all(void *cookie)
{
	struct mtk_iommu_data *data = cookie;
	void __iomem *base = data-&gt;base;

	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);
	writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);
	wmb();/* Make sure tlb flush all done */
}

static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,
				    bool leaf, void *cookie)
{
	struct mtk_iommu_data *data = cookie;
	void __iomem *base = data-&gt;base;

	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);

	writel_relaxed(iova, base + REG_MMU_INVLD_START_A);
	writel_relaxed(iova + size - 1, base + REG_MMU_INVLD_END_A);
	writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);
}

static void mtk_iommu_tlb_sync(void *cookie)
{
	struct mtk_iommu_data *data = cookie;
	void __iomem *base = data-&gt;base;
	int ret;
	u32 tmp;

	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,
					tmp != 0, 10, 1000000);
	if (ret) {
		dev_warn(data-&gt;dev,
			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);
		mtk_iommu_tlb_flush_all(cookie);
	}
	writel_relaxed(0, base + REG_MMU_CPE_DONE); /* Clear the CPE status */
}

static struct iommu_gather_ops mtk_iommu_gather_ops = {
	.tlb_flush_all = mtk_iommu_tlb_flush_all,
	.tlb_add_flush = mtk_iommu_tlb_add_flush,
	.tlb_sync = mtk_iommu_tlb_sync,
};

static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)
{
	struct mtk_iommu_data *data = dev_id;
	struct mtk_iommu_domain *mtkdom = data-&gt;m4udom;
	u32 int_state, regval, fault_iova, fault_pa;
	unsigned int fault_larb, fault_port;
	bool layer, write;

	/* Read error info from registers */
	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);
	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);
	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;
	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;
	fault_iova &amp;= F_MMU_FAULT_VA_MSK;
	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);
	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);
	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);
	fault_port = F_MMU0_INT_ID_PORT_ID(regval);

	if (report_iommu_fault(&amp;mtkdom-&gt;domain, data-&gt;dev, fault_iova,
			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {
		dev_err_ratelimited(
			data-&gt;dev,
			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,
			int_state, fault_iova, fault_pa, fault_larb, fault_port,
			layer, write ? &quot;write&quot; : &quot;read&quot;);
	}

	/* Interrupt clear */
	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);
	regval |= F_INT_CLR_BIT;
	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);

	mtk_iommu_tlb_flush_all(data);

	return IRQ_HANDLED;
}

static int mtk_iommu_parse_dt(struct platform_device *pdev,
			      struct mtk_iommu_data *data)
{
	[...]
}

static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)
{
	void __iomem *base = data-&gt;base;
	u32 regval;
	int ret;

	ret = clk_prepare_enable(data-&gt;bclk);
	if (ret) {
		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);
		return ret;
	}

	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |
		F_MMU_TF_PROTECT_SEL(2) |
		F_COHERENCE_EN;
	writel_relaxed(regval, base + REG_MMU_CTRL_REG);

	regval = F_L2_MULIT_HIT_EN |
		F_TABLE_WALK_FAULT_INT_EN |
		F_PREETCH_FIFO_OVERFLOW_INT_EN |
		F_MISS_FIFO_OVERFLOW_INT_EN |
		F_PREFETCH_FIFO_ERR_INT_EN |
		F_MISS_FIFO_ERR_INT_EN;
	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);

	regval = F_INT_TRANSLATION_FAULT |
		F_INT_MAIN_MULTI_HIT_FAULT |
		F_INT_INVALID_PA_FAULT |
		F_INT_ENTRY_REPLACEMENT_FAULT |
		F_INT_TLB_MISS_FAULT |
		F_INT_MISS_TRANSATION_FIFO_FAULT |
		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;
	writel_relaxed(regval, base + REG_MMU_INT_MAIN_CONTROL);

	regval = F_MMU_IVRP_PA_SET(data-&gt;protect_base);
	writel_relaxed(regval, base + REG_MMU_IVRP_PADDR);

	writel_relaxed(0, base + REG_MMU_DCM_DIS);
	writel_relaxed(0, base + REG_MMU_STANDARD_AXI_MODE);

	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,
			     dev_name(data-&gt;dev), (void *)data)) {
		writel_relaxed(0, base + REG_MMU_PT_BASE_ADDR);
		clk_disable_unprepare(data-&gt;bclk);
		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);
		return -ENODEV;
	}

	return 0;
}

static int mtk_iommu_config(struct mtk_iommu_data *data,
			    struct device *dev, bool enable)
{
	struct mtk_iommu_client_priv *head, *cur, *next;
	int ret;

	head = dev-&gt;archdata.iommu;
	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {
		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {
			dev_err(data-&gt;dev, &quot;Invalid larb: %d\n&quot;, cur-&gt;larbid);
			return -EINVAL;
		}

		ret = mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],
					  cur-&gt;portid, enable);
		if (ret)
			return ret;
	}

	return 0;
}

static int mtk_iommu_init_domain_context(struct mtk_iommu_data *data)
{
	struct mtk_iommu_domain *dom = data-&gt;m4udom;

	if (dom-&gt;iop)
		return 0;

	spin_lock_init(&amp;dom-&gt;pgtlock);
	dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |
			IO_PGTABLE_QUIRK_NO_PERMS |
			IO_PGTABLE_QUIRK_TLBI_ON_MAP |
			IO_PGTABLE_QUIRK_SHORT_SUPERSECTION;
	dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,
	dom-&gt;cfg.ias = 32;
	dom-&gt;cfg.oas = 32;
	dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;
	dom-&gt;cfg.iommu_dev = data-&gt;dev;

	dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, data);
	if (!dom-&gt;iop) {
		dev_err(data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);
		return -EINVAL;
	}

	/* Update our support page sizes bitmap */
	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;

        /* Update the pagetable base address */
	writel_relaxed(data-&gt;m4udom-&gt;cfg.arm_short_cfg.ttbr[0],
		       data-&gt;base + REG_MMU_PT_BASE_ADDR);
	return 0;
}

static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)
{
	struct mtk_iommu_domain *priv;

	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)
		return NULL;

	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return NULL;

	if (type == IOMMU_DOMAIN_DMA &amp;&amp; iommu_get_dma_cookie(&amp;priv-&gt;domain)) {
		kfree(priv);
		return NULL;
	}

	priv-&gt;domain.geometry.aperture_start = 0;
	priv-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);
	priv-&gt;domain.geometry.force_aperture = true;

	return &amp;priv-&gt;domain;
}

static void mtk_iommu_domain_free(struct iommu_domain *domain)
{
	if (domain-&gt;type == IOMMU_DOMAIN_DMA)
		iommu_put_dma_cookie(domain);
	kfree(to_mtk_domain(domain));
}

static int mtk_iommu_attach_device(struct iommu_domain *domain,
				   struct device *dev)
{
	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
	struct iommu_group *group;
	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;
	struct mtk_iommu_data *m4udata;
	int ret;

	if (!priv)
		return -ENODEV;

	group = iommu_group_get(dev);
	if (!group) {
		/* __iommu_setup_dma_ops will create a domain for each a device
		 * defaultly, But MTK only has only one iommu domain called the
		 * m4u domain which all the multimedia HW share.
		 * We don&#39;t need its default domain here.
		 */
		iommu_domain_free(domain);
		return 0;
	}
	iommu_group_put(group);

	/*
	 * The iommu core will create a default domain for each a iommu group.
	 * This default domain is used for the m4u domain here.
	 */
	m4udata = dev_get_drvdata(priv-&gt;m4udev);
	if (!m4udata-&gt;m4udom) {
		m4udata-&gt;m4udom = dom;
		ret = iommu_dma_init_domain(domain, 0, DMA_BIT_MASK(32));

       &lt;&lt;&lt;=== iommu_group_get_for_dev don&#39;t help initialize the domain,
I have to initialize it here.

		if (ret)
			return ret;
	}

	/*
	 * All the client devices are in the same group, they also are in the
	 * same domain. confirm it here.
	 */
	WARN_ON(dom != m4udata-&gt;m4udom);

	ret = mtk_iommu_init_domain_context(m4udata);
	if (ret)
		return ret;

	return mtk_iommu_config(m4udata, dev, true);
}

static void mtk_iommu_detach_device(struct iommu_domain *domain,
				    struct device *dev)
{
	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;
	struct mtk_iommu_data *m4udata;
	struct iommu_group *group;

	if (!priv)
		return;

	group = iommu_group_get(dev);
	if (!group)
		return;
	iommu_group_put(group);

	m4udata = dev_get_drvdata(priv-&gt;m4udev);
	mtk_iommu_config(m4udata, dev, false);
}

static int mtk_iommu_map(struct iommu_domain *domain, unsigned long
iova,
			 phys_addr_t paddr, size_t size, int prot)
{
	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);
	ret = dom-&gt;iop-&gt;map(dom-&gt;iop, iova, paddr, size, prot);
	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);

	return ret;
}

static size_t mtk_iommu_unmap(struct iommu_domain *domain,
			      unsigned long iova, size_t size)
{
	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
	unsigned long flags;
	size_t unmapsize;

	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);
	unmapsize = dom-&gt;iop-&gt;unmap(dom-&gt;iop, iova, size);
	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);

	return unmapsize;
}

static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,
					  dma_addr_t iova)
{
	struct mtk_iommu_domain *dom = to_mtk_domain(domain);
	unsigned long flags;
	phys_addr_t pa;

	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);
	pa = dom-&gt;iop-&gt;iova_to_phys(dom-&gt;iop, iova);
	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);

	return pa;
}

static int mtk_iommu_add_device(struct device *dev)
{
	struct iommu_group *group;

	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */
		return -ENODEV;

	group = iommu_group_get_for_dev(dev);
	if (IS_ERR(group))
		return PTR_ERR(group);

	iommu_group_put(group);
	return 0;
}

static void mtk_iommu_remove_device(struct device *dev)
{
	struct mtk_iommu_client_priv *head, *cur, *next;

	head = dev-&gt;archdata.iommu;
	if (!head)
		return;

	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {
		list_del(&amp;cur-&gt;client);
		kfree(cur);
	}
	kfree(head);
	dev-&gt;archdata.iommu = NULL;

	iommu_group_remove_device(dev);
}

static struct iommu_group *mtk_iommu_device_group(struct device *dev)
{
	struct mtk_iommu_data *m4udata;
	struct mtk_iommu_client_priv *priv;

	priv = dev-&gt;archdata.iommu;
	if (!priv)
		return ERR_PTR(-ENODEV);
	m4udata = dev_get_drvdata(priv-&gt;m4udev);

	/* All the client devices are in the same m4u iommu-group */
	if (!m4udata-&gt;m4ugroup) {
		m4udata-&gt;m4ugroup = iommu_group_alloc();
		if (IS_ERR(m4udata-&gt;m4ugroup))
			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);
	}
	return m4udata-&gt;m4ugroup;
}

static int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args
*args)
{
[...]
}

static struct iommu_ops mtk_iommu_ops = {
	.domain_alloc	= mtk_iommu_domain_alloc,
	.domain_free	= mtk_iommu_domain_free,
	.attach_dev	= mtk_iommu_attach_device,
	.detach_dev	= mtk_iommu_detach_device,
	.map		= mtk_iommu_map,
	.unmap		= mtk_iommu_unmap,
	.map_sg		= default_iommu_map_sg,
	.iova_to_phys	= mtk_iommu_iova_to_phys,
	.add_device	= mtk_iommu_add_device,
	.remove_device	= mtk_iommu_remove_device,
	.device_group	= mtk_iommu_device_group,
	.of_xlate	= mtk_iommu_of_xlate,
	.pgsize_bitmap	= SZ_4K | SZ_64K | SZ_1M | SZ_16M,
};

static const struct of_device_id mtk_iommu_of_ids[] = {
	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },
	{}
};

static int mtk_iommu_init_fn(struct device_node *np)
{
	struct platform_device *pdev;

	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);
	if (IS_ERR(pdev))
		return PTR_ERR(pdev);

	of_iommu_set_ops(np, &amp;mtk_iommu_ops);

	return 0;
}

IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);

static int mtk_iommu_probe(struct platform_device *pdev)
{
	struct mtk_iommu_data   *data;
	struct device           *dev = &amp;pdev-&gt;dev;
	void __iomem	        *protect;
	int                     ret;

	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data-&gt;dev = dev;

	/* Protect memory. HW will access here while translation fault.*/
	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);
	if (!protect)
		return -ENOMEM;
	data-&gt;protect_base = ALIGN(virt_to_phys(protect),
MTK_PROTECT_PA_ALIGN);

	ret = mtk_iommu_parse_dt(pdev, data);
	if (ret)
		return ret;

	ret = mtk_iommu_hw_init(data);
	if (ret)
		return ret;

	dev_set_drvdata(dev, data);

	return 0;
}

static int mtk_iommu_remove(struct platform_device *pdev)
{
	struct mtk_iommu_data *data = dev_get_drvdata(&amp;pdev-&gt;dev);

	free_io_pgtable_ops(data-&gt;m4udom-&gt;iop); /* Destroy domain context */
       &lt;&lt;&lt;===== the free domain-context is also asymmetric too, but I
can not move it into detach_device, the detach_device may be called the
client device. the domain cann&#39;t be freed by a client device.

	clk_disable_unprepare(data-&gt;bclk);
	devm_free_irq(&amp;pdev-&gt;dev, data-&gt;irq, data);
	return 0;
}

//===========================


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index a7920fb..b964364 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -387,4 +387,19 @@</span> <span class="p_context"> config ARM_SMMU_V3</span>
 	  Say Y here if your system includes an IOMMU device implementing
 	  the ARM SMMUv3 architecture.
 
<span class="p_add">+config MTK_IOMMU</span>
<span class="p_add">+	bool &quot;MTK IOMMU Support&quot;</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the M4U on certain Mediatek SOCs. M4U is MultiMedia</span>
<span class="p_add">+	  Memory Management Unit. This option enables remapping of DMA memory</span>
<span class="p_add">+	  accesses for the multimedia subsystem.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 06df3e6..f4f2f2c 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
 obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
 obj-$(CONFIG_SHMOBILE_IOMMU) += shmobile-iommu.o
 obj-$(CONFIG_SHMOBILE_IPMMU) += shmobile-ipmmu.o
 obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
new file mode 100644
<span class="p_header">index 0000000..39839f7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -0,0 +1,767 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x020</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x024</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x028</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x038</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="p_add">+#define REG_MMU_DCM_DIS				0x050</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x110</span>
<span class="p_add">+#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_COHERENCE_EN				BIT(8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="p_add">+#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="p_add">+#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="p_add">+#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="p_add">+#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="p_add">+#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="p_add">+#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="p_add">+#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="p_add">+#define F_INT_L2_CLR_BIT			BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="p_add">+#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x12C</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST1			0x134</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x13c</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="p_add">+#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x140</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x150</span>
<span class="p_add">+#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="p_add">+#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="p_add">+#define MTK_IOMMU_REG_NR			10</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_suspend_reg {</span>
<span class="p_add">+	u32				standard_axi_mode;</span>
<span class="p_add">+	u32				dcm_dis;</span>
<span class="p_add">+	u32				ctrl_reg;</span>
<span class="p_add">+	u32				ivrp_paddr;</span>
<span class="p_add">+	u32				int_control0;</span>
<span class="p_add">+	u32				int_main_control;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_data {</span>
<span class="p_add">+	void __iomem			*base;</span>
<span class="p_add">+	int				irq;</span>
<span class="p_add">+	struct device			*dev;</span>
<span class="p_add">+	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+	struct clk			*bclk;</span>
<span class="p_add">+	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="p_add">+	int				larb_nr;/* local arbiter number */</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg	reg;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	struct imu_pgd_t		*pgd;</span>
<span class="p_add">+	spinlock_t			pgtlock; /* lock for page table */</span>
<span class="p_add">+</span>
<span class="p_add">+	struct io_pgtable_cfg		cfg;</span>
<span class="p_add">+	struct io_pgtable_ops		*iop;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct mtk_iommu_data		*data;</span>
<span class="p_add">+	struct iommu_domain		domain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_client_priv {</span>
<span class="p_add">+	struct list_head		client;</span>
<span class="p_add">+	unsigned int			larbid;</span>
<span class="p_add">+	unsigned int			portid;</span>
<span class="p_add">+	struct device			*m4udev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_clear_intr(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	val |= F_INT_L2_CLR_BIT;</span>
<span class="p_add">+	writel_relaxed(val, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+	mb();/* Make sure flush all done */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="p_add">+				    bool leaf, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel_relaxed(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel_relaxed(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,</span>
<span class="p_add">+					tmp != 0, 10, 1000000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(domain-&gt;data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="p_add">+	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="p_add">+	.tlb_sync = mtk_iommu_tlb_sync,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+	bool layer, write;</span>
<span class="p_add">+</span>
<span class="p_add">+	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Read error info */</span>
<span class="p_add">+	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="p_add">+	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="p_add">+	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (report_iommu_fault(&amp;mtkdom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {</span>
<span class="p_add">+		dev_err_ratelimited(</span>
<span class="p_add">+			data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="p_add">+			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_clear_intr(data);</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(mtkdom);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="p_add">+			      struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct device_node *ofnode;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	ofnode = dev-&gt;of_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="p_add">+					ofnode, &quot;mediatek,larb&quot;, NULL);</span>
<span class="p_add">+	if (data-&gt;larb_nr &lt; 0)</span>
<span class="p_add">+		return data-&gt;larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(ofnode, &quot;mediatek,larb&quot;, i);</span>
<span class="p_add">+		if (!larbnode)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev)</span>
<span class="p_add">+			return -EPROBE_DEFER;</span>
<span class="p_add">+		data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu clk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="p_add">+		F_COHERENCE_EN;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_L2_MULIT_HIT_EN |</span>
<span class="p_add">+		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="p_add">+		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="p_add">+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = ALIGN(data-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+	regval = F_MMU_IVRP_PA_SET(regval);</span>
<span class="p_add">+	writel_relaxed(regval, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(0, base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)mtkdom)) {</span>
<span class="p_add">+		writel_relaxed(0, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_config(struct mtk_iommu_domain *mtkdom,</span>
<span class="p_add">+			    struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {</span>
<span class="p_add">+			dev_err(data-&gt;dev, &quot;Invalid larb:%d\n&quot;, cur-&gt;larbid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="p_add">+				    cur-&gt;portid, enable);</span>
<span class="p_add">+		if (!enable) {</span>
<span class="p_add">+			list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+			kfree(cur);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!enable) {</span>
<span class="p_add">+		kfree(head);</span>
<span class="p_add">+		dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_domain_context(struct mtk_iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dom-&gt;iop)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+	dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_NO_PERMS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_TLBI_ON_MAP |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_SUPERSECTION;</span>
<span class="p_add">+	dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="p_add">+	dom-&gt;cfg.ias = 32;</span>
<span class="p_add">+	dom-&gt;cfg.oas = 32;</span>
<span class="p_add">+	dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="p_add">+	dom-&gt;cfg.iommu_dev = dom-&gt;data-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, dom);</span>
<span class="p_add">+	if (!dom-&gt;iop) {</span>
<span class="p_add">+		dev_err(dom-&gt;data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update our support page sizes bitmap */</span>
<span class="p_add">+	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(dom);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		free_io_pgtable_ops(dom-&gt;iop);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == IOMMU_DOMAIN_DMA &amp;&amp; iommu_get_dma_cookie(&amp;priv-&gt;domain)) {</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="p_add">+	priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;priv-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (domain-&gt;type == IOMMU_DOMAIN_DMA)</span>
<span class="p_add">+		iommu_put_dma_cookie(domain);</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain), *m4udom;</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *clientpriv;</span>
<span class="p_add">+	struct device *m4udev;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	clientpriv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!clientpriv)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	m4udev = clientpriv-&gt;m4udev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There is a domain for each a iommu device in normal case.</span>
<span class="p_add">+	 * But MTK only has one iommu domain called the m4u domain which all</span>
<span class="p_add">+	 * the multimedia HW share. Here we reserve one as the m4u domain and</span>
<span class="p_add">+	 * free the others.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * And the attach_device that from __iommu_setup_dma_ops</span>
<span class="p_add">+	 * will be called earlier than probe.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	m4udom = dev_get_drvdata(m4udev);</span>
<span class="p_add">+	if (!m4udom)</span>
<span class="p_add">+		dev_set_drvdata(m4udev, priv);</span>
<span class="p_add">+	else if (m4udom != priv)</span>
<span class="p_add">+		iommu_domain_free(domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initial the m4u domain context which is from the add_device */</span>
<span class="p_add">+	ret = mtk_iommu_init_domain_context(priv);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mtk_iommu_config(priv, dev, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mtk_iommu_config(to_mtk_domain(domain), dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	ret = priv-&gt;iop-&gt;map(priv-&gt;iop, iova, paddr, size, prot);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	size_t unmapsize;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	unmapsize = priv-&gt;iop-&gt;unmap(priv-&gt;iop, iova, size);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return unmapsize;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = priv-&gt;iop-&gt;iova_to_phys(priv-&gt;iop, iova);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv;</span>
<span class="p_add">+	struct mtk_iommu_domain *m4udom;</span>
<span class="p_add">+	struct iommu_domain *domain;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group) {</span>
<span class="p_add">+		group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(group)) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="p_add">+			return PTR_ERR(group);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iommu_group_add_device(group, dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="p_add">+		goto err_group_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	domain = iommu_get_domain_for_dev(dev);</span>
<span class="p_add">+	if (!domain) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Get the m4u iommu domain from the m4u device.</span>
<span class="p_add">+		 * Attach all the client devices into the m4u domain.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+		m4udom = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+		ret = iommu_attach_group(&amp;m4udom-&gt;domain, group);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+err_group_put:</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_remove_device(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+	struct platform_device *m4updev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 2) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		/* Get the m4u device */</span>
<span class="p_add">+		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="p_add">+		of_node_put(args-&gt;np);</span>
<span class="p_add">+		if (WARN_ON(!m4updev))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;larbid = args-&gt;args[0];</span>
<span class="p_add">+	priv-&gt;portid = args-&gt;args[1];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.remove_device	= mtk_iommu_remove_device,</span>
<span class="p_add">+	.of_xlate	= mtk_iommu_of_xlate,</span>
<span class="p_add">+	.pgsize_bitmap	= SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="p_add">+	if (IS_ERR(pdev))</span>
<span class="p_add">+		return PTR_ERR(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data   *data;</span>
<span class="p_add">+	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct mtk_iommu_domain *m4udom;</span>
<span class="p_add">+	void __iomem	        *protect;</span>
<span class="p_add">+	int                     ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	m4udom = dev_get_drvdata(dev);</span>
<span class="p_add">+	if (m4udom)</span>
<span class="p_add">+		m4udom-&gt;data = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mtkdom)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	free_io_pgtable_ops(mtkdom-&gt;iop); /* Destroy domain context */</span>
<span class="p_add">+	clk_disable_unprepare(mtkdom-&gt;data-&gt;bclk);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mtkdom)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="p_add">+	base = mtkdom-&gt;data-&gt;base;</span>
<span class="p_add">+	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="p_add">+					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	reg-&gt;ivrp_paddr = readl_relaxed(base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	reg-&gt;int_main_control = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mtkdom)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = &amp;mtkdom-&gt;data-&gt;reg;</span>
<span class="p_add">+	base = mtkdom-&gt;data-&gt;base;</span>
<span class="p_add">+	writel_relaxed(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="p_add">+		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ivrp_paddr, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mtk_iommu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mtk_iommu_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_unregister(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mtk_iommu_init);</span>
<span class="p_add">+module_exit(mtk_iommu_exit);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



