
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v7,24/36] x86, swiotlb: Add memory encryption support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v7,24/36] x86, swiotlb: Add memory encryption support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 16, 2017, 6:54 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170616185423.18967.19605.stgit@tlendack-t1.amdoffice.net&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9793257/mbox/"
   >mbox</a>
|
   <a href="/patch/9793257/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9793257/">/patch/9793257/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5BA1B60325 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 18:54:48 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4CB042865B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 18:54:48 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3FE1028670; Fri, 16 Jun 2017 18:54:48 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 03F732865B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 18:54:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752829AbdFPSym (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 16 Jun 2017 14:54:42 -0400
Received: from mail-by2nam01on0064.outbound.protection.outlook.com
	([104.47.34.64]:13319
	&quot;EHLO NAM01-BY2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1750797AbdFPSyf (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 16 Jun 2017 14:54:35 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=VcPyQAZ4376KPIpFnIeKAcAQMdM4+v6n6+iynUuEW00=;
	b=CZod/hrHdreJuOIMdD2cOSTEbwiFt5QOnZMqJzPhQmly1VmfhdfPHJGxV/tzCOMJLG/9+K1rcJsbyOYLo5tJHRqbUil6FlgLTWDlEy1oei09wMWuXJ24CPMC2aVLHoqyREaa6JBgY+Alj+tVTUpewupN5MkeBaIYjGwSusSXvco=
Authentication-Results: vger.kernel.org; dkim=none (message not signed)
	header.d=none; vger.kernel.org;
	dmarc=none action=none header.from=amd.com; 
Received: from tlendack-t1.amdoffice.net (165.204.77.1) by
	DM5PR12MB1148.namprd12.prod.outlook.com (10.168.236.143) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1157.12; Fri, 16 Jun 2017 18:54:27 +0000
From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
Subject: [PATCH v7 24/36] x86, swiotlb: Add memory encryption support
To: linux-arch@vger.kernel.org, linux-efi@vger.kernel.org,
	kvm@vger.kernel.org, linux-doc@vger.kernel.org, x86@kernel.org,
	kexec@lists.infradead.org, linux-kernel@vger.kernel.org,
	kasan-dev@googlegroups.com, xen-devel@lists.xen.org,
	linux-mm@kvack.org, iommu@lists.linux-foundation.org
Cc: Brijesh Singh &lt;brijesh.singh@amd.com&gt;,
	Toshimitsu Kani &lt;toshi.kani@hpe.com&gt;,
	Radim =?utf-8?b?S3LEjW3DocWZ?= &lt;rkrcmar@redhat.com&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Alexander Potapenko &lt;glider@google.com&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Larry Woodman &lt;lwoodman@redhat.com&gt;,
	Jonathan Corbet &lt;corbet@lwn.net&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	&quot;Michael S. Tsirkin&quot; &lt;mst@redhat.com&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	Dave Young &lt;dyoung@redhat.com&gt;, Rik van Riel &lt;riel@redhat.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Borislav Petkov &lt;bp@alien8.de&gt;, Andy Lutomirski &lt;luto@kernel.org&gt;,
	Boris Ostrovsky &lt;boris.ostrovsky@oracle.com&gt;,
	Dmitry Vyukov &lt;dvyukov@google.com&gt;, Juergen Gross &lt;jgross@suse.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Paolo Bonzini &lt;pbonzini@redhat.com&gt;
Date: Fri, 16 Jun 2017 13:54:24 -0500
Message-ID: &lt;20170616185423.18967.19605.stgit@tlendack-t1.amdoffice.net&gt;
In-Reply-To: &lt;20170616184947.18967.84890.stgit@tlendack-t1.amdoffice.net&gt;
References: &lt;20170616184947.18967.84890.stgit@tlendack-t1.amdoffice.net&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: MWHPR02CA0016.namprd02.prod.outlook.com (10.168.209.154)
	To
	DM5PR12MB1148.namprd12.prod.outlook.com (10.168.236.143)
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: DM5PR12MB1148:
X-MS-Office365-Filtering-Correlation-Id: d89684f0-8705-4c97-0d20-08d4b4e91f0c
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(48565401081)(201703131423075)(201703031133081);
	SRVR:DM5PR12MB1148; 
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	3:m+OrAhdAywkfzfRQ55XgPQhU/mCXYoVO9iQVr+uOHOWSFp7PDgvG9GMEaMPDm0rwayDljk35tIASB1JiIutNARTGFSFHAQ2ureMRouPNeB2ZpaFBf+cSHrwJdUsaQgAmesG0uTpRuPTkQJWgOuT/CNmy1hYdLF2ybcO0IoyJLKF9hmbGSXsbfOk5GL5zKa7awO56SjE6jxTuaIcDiM4sePG1+JzdhXNOXOlL20l6EJKxTxUJ/OAUP9LKMi1gvAdh/BBWntAlt7t8ukiN74YWmkWxZu7SPL4MmL0Tnu8FUxWv9hMTTaaScx8VsOhPII6nuqZt96QVmg/TtP+p8XFCVaxAiNuLM4oj44OtaX0Igw8=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	25:IQznxlYufDS8PzZDX3aiIRVZFW/5fQR3s3dsgSxdjQ5Vw7nMUu0pyCSV1fx5/QbpBeyeS75lVCBL1qD5BCiKBJ3mQYA3RzB2zRBGQGRu2mcM72uVPUVnHYSSINH21t4daVJR6xTrtV3XfFRsZhUeWcADdQMq17EEdpSUpehzQQFQtqYN3dl+Q/0/Y29w8eyvv7ZrDjn9/O8AuOWoCIeO2i/Wq8XCTwTJmFSMqFvCFbKZBdXjqq78fHW5K2UdlspJf1vAHcp/6OgT6zcKimCIQaW5D89HBtLY06/wdOBKYDIpNj6PXe06NKL4DEQtZP8Ruvn6C63gIzAHzE+IutttaBVTHiedlrN6p0qjpddLf7MQwNY7gdZ9iH/ZUs7tAwVdlfb+RbvillrDHW5TQnYVirCZmzdJ6jIdYNjlj4dzLAqqUQgIkQTubBWSreCtAV7pNPyElno34sW8WL1wne07w4UyR7erWiKVqJkh0RgUMgPARdJNwLdFT/PFishP9taLpAMMtK/U68AqKcINorhjnbhKMk5JPcxZUYNz7nHGMB0gfoXWsPnhGP/aUZBi2j//yANaW03mWe8bKSNkI918KRXhsRjyeOGJ46VSZaZ6yxo7d/Vg2y5L77jSBt0buCfOf9l4A9XP3JqATw5zd7CBjcFrdWDR1QLXa1AeqlBy8BT0SnYwAO0u/pLjBWhgzgkBBBgvtA4YDgrmNhYinGnf9D6WYBfqgK4zbu3aWJ69L9jQjYy8aOeyg5408U401c/OtAs7mAKA4EamhFyHRjp5WcAzW3t8NOM/noRVhLpQShiyJu7TEO9is/DRph+gSDtJgYzKLfpSxxg5xGos6eIoI2AFA98/B4sNuhCCVjHraRl7+Q7Twq/7cjxZkg8Y1D2BGlftA2UFzgLq6sX7WoZ8xmDCcmHnN+/fQHtaOWFWN
	Wk=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	31:73jRBe0cWYnPTD+MDCbpp5A84nwwyG2jxgP4t/X2ZjTG28oBwjdkTjGAlNYJOPD3nLWPYM4CdOJxe7yMdw3BqBGYUZw8Teg+oPsvUduyUmiFOWZusYkFv49dW14Ju1RmLpjceynGK8wiu2iUZME7zMhVhfBHaCKWnlmRcX1KF8FzMXdTMGWALKem+GycGf68rlAdxqH8beZ5+jXn9cOf2qibPKELlmJxsCU/ZoAjED0mKpJMwLWxWho6U0XoT5q9rp4TH6qI7bVZ+lBWNjjJMkYGLQ6Lmp1H8BYSyE1bwqTCcn2Y6CvATO1X9+Df1Ayhvp+K/40FtwvoGYRcie7Hs2tkEmnUz2hw3ZGwJQuRTuZcM7+rXFyyEPGSxtxSjkxDwV2avq6jB/fX3ik2hg7UypKCmdCe8n7ENgjuMqerun8X3Fc2KHbvaPYBLJHCorp4FVN7ISDKprV8WQa/BgdELnXd0i2d4hNHVY6M4Uj9gxb3vIcz/kJOvWjgqeBCcZxmwbQjr1E7AVymNUmWXuOAScUSMFERTXWAqZcZzdE26bMHi4IsoWCDLa6/qZjH7dG5nZP0+ePge5XVDC18BOJicw60GPsJ1KRLTwPcShiUnNtb37N6xgk6ZlZ9pgj7PXjTG2M8tL/jMsT7AdH9Fr7JncAugI13yGW+njDCvllZAqw=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	20:x9a4WUpvu9Kbg1I/FiRT9kd1zCHFNcurmG5FRtzPhF2ICDvkQUP2pdgoFZGolt7OBXjd4vGwUdGueP15nozZHFbZpbaAtBDgrqdWGnRKApePxDDDurZEB8zkqVANN2dFY1A7jLt9Xgm+KO8FvfdmgMQRLmjShlOduOO2J+pzDP/i6FH+RA7Dbp3sGhgNgiouQpA7n28foKgML/87ws4GDpwdjmLxCd0C35hl3Wjdl5Bk8KkRyDG2NeNm+thvqbJoH5EmmXN1fvJZfcQ/4J1U3LaqaoSD9yDtUSjT6tRsNb/wmamcDvTAuh7TmGiv0bDWLoXa7m1CS6ucHLdu8CF24pd4c6V0Wm+rd1edWtxGmHaXBanCVjMMIQKVIxxTsKYanB/vBazyvXXh3H1ihybfYd3rAaSXwRjtsU/LSsovonN6GXGZUvR4oUfbt2gmwMXwzL3pDhRS+UAKnKaSAEHDRO33KRrPIHMhwPDRSrJ+hXtuh7MRIZS0sB5C5WfjMhYm
X-Microsoft-Antispam-PRVS: &lt;DM5PR12MB1148152683F886B62765E44FECC10@DM5PR12MB1148.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(6040450)(601004)(2401047)(5005006)(8121501046)(10201501046)(3002001)(100000703101)(100105400095)(93006095)(93001095)(6055026)(6041248)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123555025)(20161123560025)(20161123562025)(20161123558100)(20161123564025)(6072148)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:DM5PR12MB1148; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:DM5PR12MB1148; 
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtETTVQUjEyTUIxMTQ4OzQ6ZXI5UHF4NDNhT0xhL3NQUjRxVCtSTzRiODlT?=
	=?utf-8?B?U2pGZk5YZzFQVU1ZWk16L3ZXbCs1L0tLWThLMU9LN2FqRXU3Y3IxWmN2MEVj?=
	=?utf-8?B?dGRraXRJa08zREpYc0hxM2xsUTNsOC9tT3N3SUpNNC9jUCtWUHRYNzhwMUNZ?=
	=?utf-8?B?OG40SEkyR0RTd25QVFFxakRUakJQZzkrT1ZJaXFiNGZXa2s3dFVlN1YxcEFQ?=
	=?utf-8?B?Qis5dXNhRktWVmpLeWdnZFZRYlpnMWRSL0NOb2Q3bGRGOWRtY3NnbGdyVWFx?=
	=?utf-8?B?dGphamFpd21qa0NIUXlwYWJRTWRsRVlPNmh2WTVDK0NEcmViSHRTbFYvZzVI?=
	=?utf-8?B?NmlnM0lGSFhaVkYveHZaNnBwZnRSS0hmUE5nVWNFUnFKN1lzWlpIMlYwa08r?=
	=?utf-8?B?cVUyempURXZ6UUdtaFpwaGk1WW05QWNSSnFjZy8vTGVyV0pQUFVOaVphKzJW?=
	=?utf-8?B?Z3JhT0Y3Zk5HWktqL3AzKzBsU0Q3MldoWUY4cmcwMzgxZnVBRFQ1c3JBT2Nh?=
	=?utf-8?B?ZzZuaEtlVkJ4aDhhSU9WWVBUTWtwYnVrS2IrQ3F3T2R1OWZVUUxGeXhUNEZU?=
	=?utf-8?B?UkEyR3ZnNHRlSHJ5T1poSE82aHcxMkVsUmZjY2FYbGVxclpqSXpaZE4xYXNE?=
	=?utf-8?B?YzRmNEhDbU9OT3hqRVF6V3E2bEVTNjlCa2pTaGVGVm4xWStxSXpBS05Cc2Qr?=
	=?utf-8?B?T0wvT2tmWWY3WFRacm5vNEdWZFZhL2E4Um9IYVVhOWc1NkNEcUwyQlFvTVow?=
	=?utf-8?B?a2NpbTFlSkt3QVVMR3E2dWVtcnNsUjhxWitXaDR0MUhNWU9kMGxWL0F6bVpx?=
	=?utf-8?B?aW50TytBMVNXL3IrOUpmaVpmRHVGRlJySE5rZ3dadkVkWTFjWmFNOUt2Nm5h?=
	=?utf-8?B?MUR3ckUva0w3T0tqZ0gxZFBPUkRtY2RuWU1NRjlBOC8rMVN5ZGpqYk1qWVov?=
	=?utf-8?B?SWFySTF2OEJ4VERYcldVY24zNVFzdHdNNm80QXltODNRc3dRYk5oMVNUenlY?=
	=?utf-8?B?enlvQkltb1Q3ZTdabzJFZE41Q0pDWFJDSU81aGxVK3lVV3k4T0prRnk2cVlO?=
	=?utf-8?B?VDRRSnU2aEc2cHROeC84MjhwVkFVT2t6RHlKTkxoS0dYanlFVTlVVHczeENk?=
	=?utf-8?B?bXBoMFY0c2dzQ3lJTE93ZklublJzUmQ2dnQrRXZYL1NmZTZKTjR3b0hiUU1C?=
	=?utf-8?B?NUN5SC9aTEhLcGFBNVkvUC9qaDJ3blozV21iUTJFekoyU2hVc2hoaGh1UGtO?=
	=?utf-8?B?T280RlF4WVV0cWhIR2g3cGJzUEVJeEt5N241ZTVIRTg2VXlFN3hDb0JmdDhP?=
	=?utf-8?B?WWxRYlE5Y01tQ0FaWEVla2Uva1BxeEhUMGFrcW1wOTgvSkFrdXZibDcwOHVa?=
	=?utf-8?B?OFYzRHNmS2E5aUFLRmdDWFM1S0wrYjI5azl1c01aWXp2cXpUdzZxaC9EYUxZ?=
	=?utf-8?B?NjhrV0hsaGY5ZXRFZFlEdjVMOFUrOFVxRnU1amUwNzVROTlQT09EWW4vVmRu?=
	=?utf-8?B?SDllQWNUcnpoZzN1QmJJek5LbmYxTC8zbHVXN1NreWhYQ1VoeWFyY3dmOW54?=
	=?utf-8?B?VHJnVTMzUWUwRjMxTHBzc2ZYV3ZWSFY0bWJvU0gzbkFzZHdaNXVLZDdnWnA1?=
	=?utf-8?Q?Y67LoUX39wJ6IwU3aAU?=
X-Forefront-PRVS: 0340850FCD
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6009001)(39410400002)(39860400002)(39850400002)(39400400002)(39840400002)(39450400003)(53416004)(7416002)(7406005)(6666003)(33646002)(8676002)(478600001)(42186005)(25786009)(2950100002)(4001350100001)(81166006)(6116002)(3846002)(23676002)(83506001)(1076002)(189998001)(47776003)(72206003)(5660300001)(6506006)(2906002)(230700001)(305945005)(55016002)(7736002)(4326008)(9686003)(54906002)(110136004)(38730400002)(103116003)(50986999)(50466002)(54356999)(53936002)(86362001)(66066001)(76176999)(921003)(1121003);
	DIR:OUT; SFP:1101; SCL:1; SRVR:DM5PR12MB1148;
	H:tlendack-t1.amdoffice.net; FPR:; SPF:None; MLV:sfv; LANG:en;
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtETTVQUjEyTUIxMTQ4OzIzOnRrRnRLOG5Gc01SRGx3ZzFkS09JQ0xWL3Rr?=
	=?utf-8?B?UWdiOWdrSUswb1hucFVZdU9jS21DaGVpY0lEOWgwTFl3QUptdGZaLzk3YXJm?=
	=?utf-8?B?Z3NFa2dyQitpd09rYmVuMENwbW91cHRCMXNReGpKZjl0R0paVVMwRk9zZFRs?=
	=?utf-8?B?czNJejEwNGpESkwwOWF1b3lIb2FzZS9GV2xPZy9ZRDdhbDI3bUNvUG82OXJF?=
	=?utf-8?B?Y3ZDbHJHYUhkQlBYT3hneUp3MVdtYUxyRlRlME9pdWdvOWtvREFiOEtHc3VS?=
	=?utf-8?B?aDVvVXlNSDVzMEJ3WTdDT0M0bHR3NlJLRlQwbWtNSmVHWWNvVjY5ck5tdUgy?=
	=?utf-8?B?dm83TkNVQjBPN1RON1N3c3pkNUU3ODJiZkxvL21RcllmSHE0eHZLZCtoOFNK?=
	=?utf-8?B?QmlHTWdWVU9Za0RaSUR6NEU3NGZsSVY4eElJMmQ4MklUeVBpYkRzRXRTSmlI?=
	=?utf-8?B?UDVaMjVySW84NnQ5YnN0eDRxeEY5azNiOWlYbTJVNS9oaHBIbU8rLzNheU44?=
	=?utf-8?B?WWZWN2N0MkJhN2hmM2Q3NGQvNU53TmRuNldNSWFpZWZoM1lVU0tINmNCSThB?=
	=?utf-8?B?M3FGVU5MTldlTlhhWmpnaDRzMGt2ckJacG9PcS90T0FKeXN2WStMWEo2WWlM?=
	=?utf-8?B?T2c5SEI3aUl5emtTd3Bla0FONzZmUm9sUkpXLzFueDFKT2QwK29LaWplRktC?=
	=?utf-8?B?OGpwbHFMSm1wdm95NDErZlRETGxwTFZqak5EWUFtcnNkNVRqRlQ1SGVOWHZl?=
	=?utf-8?B?MFAzWDQ2NjcyZEFLeE5pdmdJbWZqOWlCd0JZUVR4VHkyZmtBVUVRYnluNlky?=
	=?utf-8?B?djhialU3SloxREJLVU45UkdRQi9zNUxYUnRwVlZERS9FNnIvRVFBenV4czNz?=
	=?utf-8?B?bVdEa1hNZWNHbzNtSXB6SThHNjhwcmJJWFRkcTNZOVVZQTI4dyswQ05KeXor?=
	=?utf-8?B?ZFhaOGk1TjYxbjkzaytCTmdkWUxGb1Avd29qN2hmOVppM1BxeGFybE1QZ2o5?=
	=?utf-8?B?RmduSzc2dG5udTVvMXVDZGpRdVVqRkppeldDcHJVYkwzdE45VklpbVFpcWlC?=
	=?utf-8?B?QUJvdk5mV2R6bWNQSG9YUVNPcnBhQXMySm10UytiajM3S3lEUVA2TDJ2a2ti?=
	=?utf-8?B?SXRSaW0zUExmUHNOMWx4UUR4U05FTmF6b3lnR0dBckRwSVZmMldIaFZtZXVL?=
	=?utf-8?B?Y2pOYmROQTZCelp0VjVKOVJLT3hrTkFKa2d3NFJzY3Z5OWpvcWRaVGZFTlls?=
	=?utf-8?B?NzdMUndpZ242UkNHV3lmbmxnTG5vcVgwY2JxdGJrU1ZRdXFSQ2E3azl6ZHBt?=
	=?utf-8?B?Zmh6M1YxR2NkK2NNN1l4SGlOMk1ueGk0bzAxaHlidjBaeWYxbnJIeVFQZ0lK?=
	=?utf-8?B?YnQvY0VZdG1YS2ZnQjN1VXRyQ244SlhlU1N0ejNlV1pQdlcwTWRwT3lPaDhL?=
	=?utf-8?B?TWRXblltUzdHbVd5NzdKMmhGd2JqMHNKN016ck4vQWl4aGdFbk9iTUh0cnQ3?=
	=?utf-8?B?UGJ6bnNaUWdHS1dtSGsrektDZ3hzM0w1VlFQMmFJQWQ2MW9iT05kdlFJRzd6?=
	=?utf-8?B?M2FHSExYcEszMnluTG01V3IvQlJ6emJUWTc4dktJZEw2eFA2cGlUQVBZb0dQ?=
	=?utf-8?B?bk56Z29wUUU0MDZSSlJHZXl2QnFDQ2FoaDhSUmp3R01icGxIS0ZyUW9BPT0=?=
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtETTVQUjEyTUIxMTQ4OzY6RGVhcEYwRUJaajBYUXk4QUY4Ymp0bENPYWU1?=
	=?utf-8?B?bFUyNlAxZWNZWUloL1YxdGZJWmJBSEo1R3lPcXdSZjlrUkRlcVhKZlhjRkRl?=
	=?utf-8?B?U3V3R3l5WWVYY2FubFN2aHBJWWh4Zmd6U1dhM05DS0V3TkRpMFhKazd6VHBa?=
	=?utf-8?B?cWNJUGladmlnRmNpN0FTa0RONGlYa3FnZG9vQjF5UzFTWTMwcFEyUHpKbWRI?=
	=?utf-8?B?ZHVaV2Nsc0luTjIzN3hid0ZhTzIyaFRCZ2NaZktqdnF5UVhrU2x1RjIreWw0?=
	=?utf-8?B?TnVkcHFML1J4T0NQSjc0aW1xOC9QbFVLZkVLakR5NFhXeVlyUENqbFdVV3hy?=
	=?utf-8?B?MVRlNUVaYUNoclhEMHVuTEkvVXlxUjJPdnNrMG1MUmJOdUpYM1J6SzJXcEtw?=
	=?utf-8?B?YkcwVytaQzN5anNWdmk5SEtMaHRpdWFJZTZNanZ6U0ozYnhMM1JiWkMyMFFs?=
	=?utf-8?B?cjhCR252ZkJEWEg3RWF5U3dhUXpUUFlYQkV3Z0VUd1J6a1dXNlZISGxMemdu?=
	=?utf-8?B?b1VhaXN2Q3hmYTJGbVlDOHlOS1F0cjZsZ0dwbFZIL2dLS1Z3MUdxMXBqWG91?=
	=?utf-8?B?Qm1nT1RpZjR4MnRJNU00b1Q3bkhoVnJUKzZCY0xkVmIyVFNnd1UyNGx1RnhV?=
	=?utf-8?B?TW5BVFJ6bW9EYUJtN2RHUDdSOS9YMHFaRFFDVDlobWZiclFqbHNjdDQ4SFpa?=
	=?utf-8?B?cFZmakgrUGlGS0RWMDRkeW9pU01aZ0ZIcXY3OFdVbzV5U1phOGtvSjR6Q0Nj?=
	=?utf-8?B?a1NEY1hHMURBWW1EOWh2NUZXWmFQaldEeTVFaU4wbEJNUmtaME1tV0VjYysx?=
	=?utf-8?B?RHFmeldHTVdHdGRBak45Q01BY3ZFVHZqUlk2dnlsZDJmRXFtWDlpU05Pb0Vl?=
	=?utf-8?B?MkZqMjJibks4LzdKSWw4Y0hLa3VwZTRSS2ozOWVvRGJzRUJLeHZhRGN6ZjUw?=
	=?utf-8?B?bzVYSkNIWnVSbXBCUUcwc3NwUWwrL3RubUVKWGRLbFdZRWU3RTRJZFh0T2VZ?=
	=?utf-8?B?bk5pdW5PbTF6NTRCTUR2a2JwblRYYWtZK29rRjJkODVkc1pkeStYSHlYK1NN?=
	=?utf-8?B?cWJhaTR0UFhPcTR6Uks1anI4VmNkVmhsUXVPWng4dHVLRUR4RXovazMvNmFT?=
	=?utf-8?B?TDBmWFNQSHpxUkRjYlJTSzRraSt0VW5ZT1BmZ05iQkVpbzhHYTNTTWRJUHhQ?=
	=?utf-8?B?by8zMmdqUjltcXdQVkRBbldnYlkxR2Nnc1E4L1k5WFBTU2UvWFNzN1dHU3l2?=
	=?utf-8?B?Rms0c0g1dWtBYWJjaUlFS3JvbnFzWityWTVuYzd0OVVpKzlwK1pVcmgra2ox?=
	=?utf-8?B?cW1xOUdlYkdPT01Lb0FFcDlTekFlTUtUVXMxcXJCZXBEc21xZ0szQTJnTHFv?=
	=?utf-8?Q?gHtC2RI?=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	5:OyrievMjhTjBvSmllHI1crxvCnK/6mPaEsHpWjiSHvhg7yL0CLN829jpWH5Va/kn9+t3F2zw9v84aTe8mZR0dSWoZ+JIsC8JIo/4OF5Dv2EWsfWP1Msu1mlI2GaLh3q4B9h7xn1B6UIKY1u/btT0i4Bwh3511L0cZDoJGscvZ+zuQCe2wBIeIAz2L7fP/kR6cnAn0omGkbJ+ThaTI4rLgEToQJ3lrOJ6SwGSGhkPB5nr2sBphF3oAgizM8Af88i09vme2iMJDK2IbewoWFB2QJH10RO9slCz9Hb0h2+x98vgTKbWyUFKBRATtx62acuhNHsH0l3ufo0D+r38ns10VS3cGLF0Sr/6ALfCnUiUpIFhuOa0mIF5C3opJrb8J9NJkkt9mS6k+qdKA9T6GUKJppMxwq6UIVbkwgzfRsbAUPKUt66ZsXt17lLxal6kIX37ts44PuKmLUyONtimdEWPwHtO6JmciqA5TlfEX1cOE70Xx2VeXiyjsPQSEoyVHHAg;
	24:SO0e3g0DperlrHmnXGcDNqsC9M0FEy72SeYxGmN8rBNnG0Bw2SGTSjKsLIZKvnt4BbheEQShziFulUcP+D2SZIhH8kl3hWvFeCDnPLMTLe0=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	7:haMAjfOJSYJfOtCdPg4s/SDAXX2oUFtqNRwBbkCKas1oQeQvNYSUPjjqdOPXToHOTxk01zBoWFqe//MYUbt4FseRrLO8Qo0VaTZCTqOYPoPp+uuY8M4ZA9683zUjX+UF4rNzG3B0OyYfZExTeplx1evSavI5eMiF8yl67BCKhD++1NUwJsJih+OmS/RftqDx1OUNkDtZJ2C7FcCot+BRuo0ogzLo1oYgDR/Ufcd9gD+ISxcAM2IrQ797B6Pn5qjl5lKzHCPAFPZBANGj3ZWix8zCc2ftg5ppDY3aY6ulkKBOa2xPwbhmW7bzUY0vuWj6RY0IGkIC7GItWq+AGp8t/MbWglhAXfozC+mroZaA3BzKxdnTKPxuKlFu1gWTCCVt0c08HaASCIIvbz+50jrzYKrkCpdLhz12IMyQu+nY90fNXPaW6abhCv3erKYyTIAJO67j956C4wKJPbqHEuRnetVV8VK8tpS81rCLsh6h/mI+jiJ6DggHIpQFJr5H66Os7mrjmcGy1TXxxOTaUVapQX4qnpaJOhSiDmTFQdOCQwoCL87O7FUXqCLv6FLdqnf2ptG9fTJ5jB4CLK5uD2E384PHRUwTBa9H8gC3mD/Z59gbpd2S4driKYkndY2mtk862vnm/ySpie+8lrAbw3YRpgwag8mZy9cSB7G/JMdZc5XnP/zhmFEWS/P9MZHbvl4zanp6nj/A+ib1foO8kFeOPlU1MBb2NqqFWIO/lTP1lfmLYMrY+EyDCa3RWTXUpVSUJz2eIt6oLb7ng0vs+bWItRXWT5w4/AOiGJ4kNXEoCio=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1148;
	20:f8dJ8ssFyRe6FzWNUlxBSeZX3K2wAzPoiXmrW31HFw4TcHMsuSmHlJy2iqMAeAvN5G68qvdy7P75BdnF3mm1Z+qs7w8F+1OwJ7p1vb2ST90XTlBZomg1pIVJZ31Qm8wiDX0c+Mqp4nFSn0rEmGK+QYxuYag2/dEHH8MJAio64SSXMRbcVSVNgTrNq6ez7p9tpuGdcY73qpN4Lis8B+5U1LMQRBKzkIHf6ABSTCuVo17zYO8YuxlJ7jwXaUWwiwNI
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 16 Jun 2017 18:54:27.4064
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM5PR12MB1148
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - June 16, 2017, 6:54 p.m.</div>
<pre class="content">
Since DMA addresses will effectively look like 48-bit addresses when the
memory encryption mask is set, SWIOTLB is needed if the DMA mask of the
device performing the DMA does not support 48-bits. SWIOTLB will be
initialized to create decrypted bounce buffers for use by these devices.
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
---
 arch/x86/include/asm/dma-mapping.h |    5 ++-
 arch/x86/include/asm/mem_encrypt.h |    5 +++
 arch/x86/kernel/pci-dma.c          |   11 +++++--
 arch/x86/kernel/pci-nommu.c        |    2 +
 arch/x86/kernel/pci-swiotlb.c      |   15 +++++++++-
 arch/x86/mm/mem_encrypt.c          |   22 +++++++++++++++
 include/linux/swiotlb.h            |    1 +
 init/main.c                        |   10 +++++++
 lib/swiotlb.c                      |   54 +++++++++++++++++++++++++++++++-----
 9 files changed, 108 insertions(+), 17 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - June 21, 2017, 9:54 a.m.</div>
<pre class="content">
On Fri, Jun 16, 2017 at 01:54:24PM -0500, Tom Lendacky wrote:
<span class="quote">&gt; Since DMA addresses will effectively look like 48-bit addresses when the</span>
<span class="quote">&gt; memory encryption mask is set, SWIOTLB is needed if the DMA mask of the</span>
<span class="quote">&gt; device performing the DMA does not support 48-bits. SWIOTLB will be</span>
<span class="quote">&gt; initialized to create decrypted bounce buffers for use by these devices.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/include/asm/dma-mapping.h |    5 ++-</span>
<span class="quote">&gt;  arch/x86/include/asm/mem_encrypt.h |    5 +++</span>
<span class="quote">&gt;  arch/x86/kernel/pci-dma.c          |   11 +++++--</span>
<span class="quote">&gt;  arch/x86/kernel/pci-nommu.c        |    2 +</span>
<span class="quote">&gt;  arch/x86/kernel/pci-swiotlb.c      |   15 +++++++++-</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c          |   22 +++++++++++++++</span>
<span class="quote">&gt;  include/linux/swiotlb.h            |    1 +</span>
<span class="quote">&gt;  init/main.c                        |   10 +++++++</span>
<span class="quote">&gt;  lib/swiotlb.c                      |   54 +++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt;  9 files changed, 108 insertions(+), 17 deletions(-)</span>
<span class="reviewed-by">
Reviewed-by: Borislav Petkov &lt;bp@suse.de&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/dma-mapping.h b/arch/x86/include/asm/dma-mapping.h</span>
<span class="p_header">index 08a0838..191f9a5 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/io.h&gt;
 #include &lt;asm/swiotlb.h&gt;
 #include &lt;linux/dma-contiguous.h&gt;
<span class="p_add">+#include &lt;linux/mem_encrypt.h&gt;</span>
 
 #ifdef CONFIG_ISA
 # define ISA_DMA_BIT_MASK DMA_BIT_MASK(24)
<span class="p_chunk">@@ -62,12 +63,12 @@</span> <span class="p_context"> static inline bool dma_capable(struct device *dev, dma_addr_t addr, size_t size)</span>
 
 static inline dma_addr_t phys_to_dma(struct device *dev, phys_addr_t paddr)
 {
<span class="p_del">-	return paddr;</span>
<span class="p_add">+	return __sme_set(paddr);</span>
 }
 
 static inline phys_addr_t dma_to_phys(struct device *dev, dma_addr_t daddr)
 {
<span class="p_del">-	return daddr;</span>
<span class="p_add">+	return __sme_clr(daddr);</span>
 }
 #endif /* CONFIG_X86_DMA_REMAP */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">index 3ffa5fa..af835cf 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_chunk">@@ -33,6 +33,11 @@</span> <span class="p_context"> void __init sme_early_decrypt(resource_size_t paddr,</span>
 
 void __init sme_enable(void);
 
<span class="p_add">+/* Architecture __weak replacement functions */</span>
<span class="p_add">+void __init mem_encrypt_init(void);</span>
<span class="p_add">+</span>
<span class="p_add">+void swiotlb_set_mem_attributes(void *vaddr, unsigned long size);</span>
<span class="p_add">+</span>
 #else	/* !CONFIG_AMD_MEM_ENCRYPT */
 
 #define sme_me_mask	0UL
<span class="p_header">diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c</span>
<span class="p_header">index 3a216ec..72d96d4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -93,9 +93,12 @@</span> <span class="p_context"> void *dma_generic_alloc_coherent(struct device *dev, size_t size,</span>
 	if (gfpflags_allow_blocking(flag)) {
 		page = dma_alloc_from_contiguous(dev, count, get_order(size),
 						 flag);
<span class="p_del">-		if (page &amp;&amp; page_to_phys(page) + size &gt; dma_mask) {</span>
<span class="p_del">-			dma_release_from_contiguous(dev, page, count);</span>
<span class="p_del">-			page = NULL;</span>
<span class="p_add">+		if (page) {</span>
<span class="p_add">+			addr = phys_to_dma(dev, page_to_phys(page));</span>
<span class="p_add">+			if (addr + size &gt; dma_mask) {</span>
<span class="p_add">+				dma_release_from_contiguous(dev, page, count);</span>
<span class="p_add">+				page = NULL;</span>
<span class="p_add">+			}</span>
 		}
 	}
 	/* fallback */
<span class="p_chunk">@@ -104,7 +107,7 @@</span> <span class="p_context"> void *dma_generic_alloc_coherent(struct device *dev, size_t size,</span>
 	if (!page)
 		return NULL;
 
<span class="p_del">-	addr = page_to_phys(page);</span>
<span class="p_add">+	addr = phys_to_dma(dev, page_to_phys(page));</span>
 	if (addr + size &gt; dma_mask) {
 		__free_pages(page, get_order(size));
 
<span class="p_header">diff --git a/arch/x86/kernel/pci-nommu.c b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">index a88952e..98b576a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-nommu.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-nommu.c</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> static dma_addr_t nommu_map_page(struct device *dev, struct page *page,</span>
 				 enum dma_data_direction dir,
 				 unsigned long attrs)
 {
<span class="p_del">-	dma_addr_t bus = page_to_phys(page) + offset;</span>
<span class="p_add">+	dma_addr_t bus = phys_to_dma(dev, page_to_phys(page)) + offset;</span>
 	WARN_ON(size == 0);
 	if (!check_addr(&quot;map_single&quot;, dev, bus, size))
 		return DMA_ERROR_CODE;
<span class="p_header">diff --git a/arch/x86/kernel/pci-swiotlb.c b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">index 1e23577..6770775 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-swiotlb.c</span>
<span class="p_chunk">@@ -6,12 +6,14 @@</span> <span class="p_context"></span>
 #include &lt;linux/swiotlb.h&gt;
 #include &lt;linux/bootmem.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/mem_encrypt.h&gt;</span>
 
 #include &lt;asm/iommu.h&gt;
 #include &lt;asm/swiotlb.h&gt;
 #include &lt;asm/dma.h&gt;
 #include &lt;asm/xen/swiotlb-xen.h&gt;
 #include &lt;asm/iommu_table.h&gt;
<span class="p_add">+</span>
 int swiotlb __read_mostly;
 
 void *x86_swiotlb_alloc_coherent(struct device *hwdev, size_t size,
<span class="p_chunk">@@ -79,8 +81,8 @@</span> <span class="p_context"> int __init pci_swiotlb_detect_override(void)</span>
 		  pci_swiotlb_late_init);
 
 /*
<span class="p_del">- * if 4GB or more detected (and iommu=off not set) return 1</span>
<span class="p_del">- * and set swiotlb to 1.</span>
<span class="p_add">+ * If 4GB or more detected (and iommu=off not set) or if SME is active</span>
<span class="p_add">+ * then set swiotlb to 1 and return 1.</span>
  */
 int __init pci_swiotlb_detect_4gb(void)
 {
<span class="p_chunk">@@ -89,6 +91,15 @@</span> <span class="p_context"> int __init pci_swiotlb_detect_4gb(void)</span>
 	if (!no_iommu &amp;&amp; max_possible_pfn &gt; MAX_DMA32_PFN)
 		swiotlb = 1;
 #endif
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If SME is active then swiotlb will be set to 1 so that bounce</span>
<span class="p_add">+	 * buffers are allocated and used for devices that do not support</span>
<span class="p_add">+	 * the addressing range required for the encryption mask.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sme_active())</span>
<span class="p_add">+		swiotlb = 1;</span>
<span class="p_add">+</span>
 	return swiotlb;
 }
 IOMMU_INIT(pci_swiotlb_detect_4gb,
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index ea5e3a6..842c8a6 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -16,11 +16,14 @@</span> <span class="p_context"></span>
 #ifdef CONFIG_AMD_MEM_ENCRYPT
 
 #include &lt;linux/mm.h&gt;
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/swiotlb.h&gt;</span>
 
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/bootparam.h&gt;
<span class="p_add">+#include &lt;asm/set_memory.h&gt;</span>
 
 /*
  * Since SME related variables are set early in the boot process they must
<span class="p_chunk">@@ -187,6 +190,25 @@</span> <span class="p_context"> void __init sme_early_init(void)</span>
 		protection_map[i] = pgprot_encrypted(protection_map[i]);
 }
 
<span class="p_add">+/* Architecture __weak replacement functions */</span>
<span class="p_add">+void __init mem_encrypt_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!sme_me_mask)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Call into SWIOTLB to update the SWIOTLB DMA buffers */</span>
<span class="p_add">+	swiotlb_update_mem_attributes();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN(PAGE_ALIGN(size) != size,</span>
<span class="p_add">+	     &quot;size is not page-aligned (%#lx)\n&quot;, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make the SWIOTLB buffer area decrypted */</span>
<span class="p_add">+	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init sme_encrypt_kernel(void)
 {
 }
<span class="p_header">diff --git a/include/linux/swiotlb.h b/include/linux/swiotlb.h</span>
<span class="p_header">index 4ee479f..15e7160 100644</span>
<span class="p_header">--- a/include/linux/swiotlb.h</span>
<span class="p_header">+++ b/include/linux/swiotlb.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"> enum swiotlb_force {</span>
 extern unsigned long swiotlb_nr_tbl(void);
 unsigned long swiotlb_size_or_default(void);
 extern int swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs);
<span class="p_add">+extern void __init swiotlb_update_mem_attributes(void);</span>
 
 /*
  * Enumeration for sync targets
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index df58a41..5013cbc 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -488,6 +488,8 @@</span> <span class="p_context"> void __init __weak thread_stack_cache_init(void)</span>
 }
 #endif
 
<span class="p_add">+void __init __weak mem_encrypt_init(void) { }</span>
<span class="p_add">+</span>
 /*
  * Set up kernel memory allocators
  */
<span class="p_chunk">@@ -640,6 +642,14 @@</span> <span class="p_context"> asmlinkage __visible void __init start_kernel(void)</span>
 	 */
 	locking_selftest();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This needs to be called before any devices perform DMA</span>
<span class="p_add">+	 * operations that might use the SWIOTLB bounce buffers. It will</span>
<span class="p_add">+	 * mark the bounce buffers as decrypted so that their usage will</span>
<span class="p_add">+	 * not cause &quot;plain-text&quot; data to be decrypted when accessed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mem_encrypt_init();</span>
<span class="p_add">+</span>
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;
 	    page_to_pfn(virt_to_page((void *)initrd_start)) &lt; min_low_pfn) {
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index a8d74a7..04ac91a 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/gfp.h&gt;
 #include &lt;linux/scatterlist.h&gt;
<span class="p_add">+#include &lt;linux/mem_encrypt.h&gt;</span>
 
 #include &lt;asm/io.h&gt;
 #include &lt;asm/dma.h&gt;
<span class="p_chunk">@@ -155,6 +156,15 @@</span> <span class="p_context"> unsigned long swiotlb_size_or_default(void)</span>
 	return size ? size : (IO_TLB_DEFAULT_SIZE);
 }
 
<span class="p_add">+void __weak swiotlb_set_mem_attributes(void *vaddr, unsigned long size) { }</span>
<span class="p_add">+</span>
<span class="p_add">+/* For swiotlb, clear memory encryption mask from dma addresses */</span>
<span class="p_add">+static dma_addr_t swiotlb_phys_to_dma(struct device *hwdev,</span>
<span class="p_add">+				      phys_addr_t address)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __sme_clr(phys_to_dma(hwdev, address));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Note that this doesn&#39;t work with highmem page */
 static dma_addr_t swiotlb_virt_to_bus(struct device *hwdev,
 				      volatile void *address)
<span class="p_chunk">@@ -183,6 +193,31 @@</span> <span class="p_context"> void swiotlb_print_info(void)</span>
 	       bytes &gt;&gt; 20, vstart, vend - 1);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Early SWIOTLB allocation may be too early to allow an architecture to</span>
<span class="p_add">+ * perform the desired operations.  This function allows the architecture to</span>
<span class="p_add">+ * call SWIOTLB when the operations are possible.  It needs to be called</span>
<span class="p_add">+ * before the SWIOTLB memory is used.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init swiotlb_update_mem_attributes(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *vaddr;</span>
<span class="p_add">+	unsigned long bytes;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (no_iotlb_memory || late_alloc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vaddr = phys_to_virt(io_tlb_start);</span>
<span class="p_add">+	bytes = PAGE_ALIGN(io_tlb_nslabs &lt;&lt; IO_TLB_SHIFT);</span>
<span class="p_add">+	swiotlb_set_mem_attributes(vaddr, bytes);</span>
<span class="p_add">+	memset(vaddr, 0, bytes);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaddr = phys_to_virt(io_tlb_overflow_buffer);</span>
<span class="p_add">+	bytes = PAGE_ALIGN(io_tlb_overflow);</span>
<span class="p_add">+	swiotlb_set_mem_attributes(vaddr, bytes);</span>
<span class="p_add">+	memset(vaddr, 0, bytes);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)
 {
 	void *v_overflow_buffer;
<span class="p_chunk">@@ -320,6 +355,7 @@</span> <span class="p_context"> int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)</span>
 	io_tlb_start = virt_to_phys(tlb);
 	io_tlb_end = io_tlb_start + bytes;
 
<span class="p_add">+	swiotlb_set_mem_attributes(tlb, bytes);</span>
 	memset(tlb, 0, bytes);
 
 	/*
<span class="p_chunk">@@ -330,6 +366,8 @@</span> <span class="p_context"> int __init swiotlb_init_with_tbl(char *tlb, unsigned long nslabs, int verbose)</span>
 	if (!v_overflow_buffer)
 		goto cleanup2;
 
<span class="p_add">+	swiotlb_set_mem_attributes(v_overflow_buffer, io_tlb_overflow);</span>
<span class="p_add">+	memset(v_overflow_buffer, 0, io_tlb_overflow);</span>
 	io_tlb_overflow_buffer = virt_to_phys(v_overflow_buffer);
 
 	/*
<span class="p_chunk">@@ -581,7 +619,7 @@</span> <span class="p_context"> phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,</span>
 		return SWIOTLB_MAP_ERROR;
 	}
 
<span class="p_del">-	start_dma_addr = phys_to_dma(hwdev, io_tlb_start);</span>
<span class="p_add">+	start_dma_addr = swiotlb_phys_to_dma(hwdev, io_tlb_start);</span>
 	return swiotlb_tbl_map_single(hwdev, start_dma_addr, phys, size,
 				      dir, attrs);
 }
<span class="p_chunk">@@ -702,7 +740,7 @@</span> <span class="p_context"> void swiotlb_tbl_sync_single(struct device *hwdev, phys_addr_t tlb_addr,</span>
 			goto err_warn;
 
 		ret = phys_to_virt(paddr);
<span class="p_del">-		dev_addr = phys_to_dma(hwdev, paddr);</span>
<span class="p_add">+		dev_addr = swiotlb_phys_to_dma(hwdev, paddr);</span>
 
 		/* Confirm address can be DMA&#39;d by device */
 		if (dev_addr + size - 1 &gt; dma_mask) {
<span class="p_chunk">@@ -812,10 +850,10 @@</span> <span class="p_context"> dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,</span>
 	map = map_single(dev, phys, size, dir, attrs);
 	if (map == SWIOTLB_MAP_ERROR) {
 		swiotlb_full(dev, size, dir, 1);
<span class="p_del">-		return phys_to_dma(dev, io_tlb_overflow_buffer);</span>
<span class="p_add">+		return swiotlb_phys_to_dma(dev, io_tlb_overflow_buffer);</span>
 	}
 
<span class="p_del">-	dev_addr = phys_to_dma(dev, map);</span>
<span class="p_add">+	dev_addr = swiotlb_phys_to_dma(dev, map);</span>
 
 	/* Ensure that the address returned is DMA&#39;ble */
 	if (dma_capable(dev, dev_addr, size))
<span class="p_chunk">@@ -824,7 +862,7 @@</span> <span class="p_context"> dma_addr_t swiotlb_map_page(struct device *dev, struct page *page,</span>
 	attrs |= DMA_ATTR_SKIP_CPU_SYNC;
 	swiotlb_tbl_unmap_single(dev, map, size, dir, attrs);
 
<span class="p_del">-	return phys_to_dma(dev, io_tlb_overflow_buffer);</span>
<span class="p_add">+	return swiotlb_phys_to_dma(dev, io_tlb_overflow_buffer);</span>
 }
 EXPORT_SYMBOL_GPL(swiotlb_map_page);
 
<span class="p_chunk">@@ -958,7 +996,7 @@</span> <span class="p_context"> void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,</span>
 				sg_dma_len(sgl) = 0;
 				return 0;
 			}
<span class="p_del">-			sg-&gt;dma_address = phys_to_dma(hwdev, map);</span>
<span class="p_add">+			sg-&gt;dma_address = swiotlb_phys_to_dma(hwdev, map);</span>
 		} else
 			sg-&gt;dma_address = dev_addr;
 		sg_dma_len(sg) = sg-&gt;length;
<span class="p_chunk">@@ -1026,7 +1064,7 @@</span> <span class="p_context"> void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,</span>
 int
 swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t dma_addr)
 {
<span class="p_del">-	return (dma_addr == phys_to_dma(hwdev, io_tlb_overflow_buffer));</span>
<span class="p_add">+	return (dma_addr == swiotlb_phys_to_dma(hwdev, io_tlb_overflow_buffer));</span>
 }
 EXPORT_SYMBOL(swiotlb_dma_mapping_error);
 
<span class="p_chunk">@@ -1039,6 +1077,6 @@</span> <span class="p_context"> void swiotlb_unmap_page(struct device *hwdev, dma_addr_t dev_addr,</span>
 int
 swiotlb_dma_supported(struct device *hwdev, u64 mask)
 {
<span class="p_del">-	return phys_to_dma(hwdev, io_tlb_end - 1) &lt;= mask;</span>
<span class="p_add">+	return swiotlb_phys_to_dma(hwdev, io_tlb_end - 1) &lt;= mask;</span>
 }
 EXPORT_SYMBOL(swiotlb_dma_supported);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



