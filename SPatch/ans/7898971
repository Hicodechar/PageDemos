
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[POC,60/83] switch obvious cases to get_free_pages() - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [POC,60/83] switch obvious cases to get_free_pages()</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=159">Al Viro</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 21, 2015, 11:47 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1450741676-5865-60-git-send-email-viro@ZenIV.linux.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7898971/mbox/"
   >mbox</a>
|
   <a href="/patch/7898971/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7898971/">/patch/7898971/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id AF082BEEE5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 23:55:48 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 4F489205AA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 23:55:43 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 9554E2058E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 21 Dec 2015 23:55:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753272AbbLUXyh (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 21 Dec 2015 18:54:37 -0500
Received: from zeniv.linux.org.uk ([195.92.253.2]:33097 &quot;EHLO
	ZenIV.linux.org.uk&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752354AbbLUXsK (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 21 Dec 2015 18:48:10 -0500
Received: from viro by ZenIV.linux.org.uk with local (Exim 4.76 #1 (Red Hat
	Linux)) id 1aBABU-0001as-Ln; Mon, 21 Dec 2015 23:48:08 +0000
From: Al Viro &lt;viro@ZenIV.linux.org.uk&gt;
To: linux-kernel@vger.kernel.org
Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Subject: [POC][PATCH 60/83] switch obvious cases to get_free_pages()
Date: Mon, 21 Dec 2015 23:47:33 +0000
Message-Id: &lt;1450741676-5865-60-git-send-email-viro@ZenIV.linux.org.uk&gt;
X-Mailer: git-send-email 1.7.7.6
In-Reply-To: &lt;20151221234615.GW20997@ZenIV.linux.org.uk&gt;
References: &lt;20151221234615.GW20997@ZenIV.linux.org.uk&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=159">Al Viro</a> - Dec. 21, 2015, 11:47 p.m.</div>
<pre class="content">
<span class="from">From: Al Viro &lt;viro@zeniv.linux.org.uk&gt;</span>
<span class="signed-off-by">
Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;</span>
---
 arch/alpha/include/asm/agp.h                       |  2 +-
 arch/alpha/kernel/pci-noop.c                       |  2 +-
 arch/alpha/kernel/pci_iommu.c                      |  2 +-
 arch/arc/include/asm/pgalloc.h                     |  6 +++---
 arch/arm/include/asm/tlb.h                         |  4 ++--
 arch/arm/kvm/mmu.c                                 |  4 ++--
 arch/arm/mm/pgd.c                                  |  2 +-
 arch/blackfin/include/asm/mmu_context.h            |  4 ++--
 arch/cris/arch-v32/drivers/pci/dma.c               |  2 +-
 arch/frv/mm/dma-alloc.c                            |  2 +-
 arch/h8300/kernel/dma.c                            |  2 +-
 arch/ia64/hp/common/sba_iommu.c                    | 10 ++++------
 arch/ia64/include/asm/agp.h                        |  2 +-
 arch/ia64/include/asm/tlb.h                        |  4 ++--
 arch/ia64/kernel/mca.c                             |  3 +--
 arch/ia64/sn/pci/pci_dma.c                         |  2 +-
 arch/m68k/kernel/dma.c                             |  2 +-
 arch/microblaze/include/asm/pgalloc.h              |  2 +-
 arch/microblaze/mm/consistent.c                    |  2 +-
 arch/mips/include/asm/pgalloc.h                    |  6 +++---
 arch/mips/jazz/jazzdma.c                           |  3 +--
 arch/mips/mm/dma-default.c                         |  2 +-
 arch/nios2/include/asm/pgalloc.h                   |  2 +-
 arch/nios2/mm/dma-mapping.c                        |  2 +-
 arch/nios2/mm/pgtable.c                            |  2 +-
 arch/parisc/include/asm/agp.h                      |  2 +-
 arch/parisc/include/asm/pgalloc.h                  |  6 ++----
 arch/parisc/kernel/pci-dma.c                       |  5 ++---
 arch/powerpc/include/asm/agp.h                     |  2 +-
 arch/powerpc/kernel/fadump.c                       |  2 +-
 arch/powerpc/kvm/book3s_64_mmu_hv.c                |  2 +-
 arch/powerpc/mm/pgtable_32.c                       |  2 +-
 arch/powerpc/platforms/cell/spufs/inode.c          |  2 +-
 arch/s390/hypfs/hypfs_diag.c                       |  2 +-
 arch/s390/include/asm/idals.h                      |  3 +--
 arch/s390/kernel/smp.c                             |  3 +--
 arch/s390/mm/vmem.c                                |  2 +-
 arch/s390/pci/pci_clp.c                            |  2 +-
 arch/score/include/asm/pgalloc.h                   |  4 ++--
 arch/sh/mm/consistent.c                            |  2 +-
 arch/sparc/include/asm/agp.h                       |  2 +-
 arch/sparc/kernel/ioport.c                         |  4 ++--
 arch/sparc/kernel/irq_64.c                         |  3 +--
 arch/sparc/kernel/ldc.c                            |  5 ++---
 arch/sparc/kernel/pci_fire.c                       |  2 +-
 arch/sparc/kernel/pci_sun4v.c                      |  2 +-
 arch/sparc/kernel/traps_64.c                       |  3 +--
 arch/um/drivers/net_kern.c                         |  2 +-
 arch/um/kernel/process.c                           |  2 +-
 arch/unicore32/mm/pgd.c                            |  2 +-
 arch/x86/include/asm/agp.h                         |  2 +-
 arch/x86/include/asm/xen/page-coherent.h           |  2 +-
 arch/x86/kernel/amd_gart_64.c                      |  4 ++--
 arch/x86/kernel/pci-calgary_64.c                   |  2 +-
 arch/x86/mm/init.c                                 |  2 +-
 arch/x86/platform/efi/efi.c                        |  2 +-
 arch/x86/um/ldt.c                                  |  3 +--
 arch/xtensa/include/asm/pgalloc.h                  |  2 +-
 crypto/xor.c                                       |  2 +-
 drivers/base/devres.c                              |  2 +-
 drivers/block/ps3vram.c                            |  3 +--
 drivers/block/xen-blkfront.c                       |  3 +--
 drivers/block/zram/zcomp.c                         |  2 +-
 drivers/char/agp/hp-agp.c                          |  2 +-
 drivers/char/agp/uninorth-agp.c                    |  2 +-
 drivers/crypto/atmel-aes.c                         |  4 ++--
 drivers/crypto/atmel-tdes.c                        |  4 ++--
 drivers/crypto/nx/nx-842.c                         |  4 ++--
 drivers/crypto/omap-aes.c                          |  4 ++--
 drivers/crypto/omap-des.c                          |  4 ++--
 drivers/dma/ste_dma40.c                            |  2 +-
 drivers/firmware/dell_rbu.c                        |  6 ++----
 drivers/gpu/drm/amd/amdkfd/kfd_events.c            |  2 +-
 drivers/hv/channel.c                               |  6 +++---
 drivers/hv/connection.c                            |  7 +++----
 drivers/iommu/amd_iommu_init.c                     | 16 ++++++++--------
 drivers/iommu/exynos-iommu.c                       |  4 ++--
 drivers/iommu/msm_iommu.c                          |  8 +++-----
 drivers/irqchip/irq-gic-v3-its.c                   |  2 +-
 drivers/md/bcache/bset.c                           |  8 ++++----
 drivers/md/bcache/btree.c                          |  3 +--
 drivers/md/bcache/journal.c                        |  4 ++--
 drivers/md/bcache/super.c                          |  2 +-
 drivers/md/dm-bufio.c                              |  3 +--
 drivers/media/pci/solo6x10/solo6x10-p2m.c          |  4 ++--
 drivers/media/platform/davinci/dm644x_ccdc.c       |  3 +--
 drivers/misc/cxl/native.c                          |  4 ++--
 drivers/misc/mic/card/mic_virtio.c                 |  2 +-
 drivers/misc/mic/host/mic_virtio.c                 |  5 ++---
 drivers/misc/mic/scif/scif_rma.h                   |  2 +-
 drivers/net/ethernet/cavium/liquidio/octeon_main.h |  4 +---
 drivers/net/ethernet/sgi/ioc3-eth.c                |  2 +-
 drivers/net/irda/au1k_ir.c                         |  2 +-
 drivers/net/rionet.c                               |  2 +-
 drivers/net/wireless/b43/debugfs.c                 |  2 +-
 drivers/net/wireless/b43legacy/debugfs.c           |  2 +-
 drivers/net/wireless/ti/wlcore/main.c              |  2 +-
 drivers/parisc/ccio-dma.c                          |  8 +++-----
 drivers/parisc/ccio-rm-dma.c                       |  2 +-
 drivers/parisc/sba_iommu.c                         |  7 +++----
 drivers/pci/host/pci-tegra.c                       |  2 +-
 drivers/pci/host/pcie-designware.c                 |  2 +-
 drivers/pci/host/pcie-rcar.c                       |  2 +-
 drivers/pci/host/pcie-xilinx.c                     |  2 +-
 drivers/s390/block/dasd.c                          |  2 +-
 drivers/s390/char/hmcdrv_cache.c                   |  2 +-
 drivers/s390/char/hmcdrv_ftp.c                     |  2 +-
 drivers/s390/char/tty3270.c                        |  4 ++--
 drivers/s390/char/vmcp.c                           |  2 +-
 drivers/s390/cio/cmf.c                             |  2 +-
 drivers/scsi/cxlflash/main.c                       |  2 +-
 drivers/scsi/libiscsi.c                            |  3 +--
 drivers/scsi/lpfc/lpfc_init.c                      |  6 ++----
 drivers/scsi/megaraid/megaraid_sas_base.c          |  2 +-
 drivers/scsi/megaraid/megaraid_sas_fusion.c        |  4 ++--
 drivers/scsi/mpt3sas/mpt3sas_base.c                |  5 ++---
 drivers/scsi/sym53c8xx_2/sym_hipd.h                |  2 +-
 drivers/scsi/vmw_pvscsi.c                          |  3 +--
 drivers/sh/maple/maple.c                           |  3 +--
 drivers/usb/core/devices.c                         |  2 +-
 drivers/video/fbdev/fb-puv3.c                      |  2 +-
 drivers/video/fbdev/ssd1307fb.c                    |  2 +-
 fs/ceph/mds_client.c                               |  3 +--
 fs/configfs/file.c                                 |  2 +-
 fs/hfs/mdb.c                                       |  2 +-
 fs/jbd2/journal.c                                  |  4 ++--
 fs/nilfs2/ioctl.c                                  |  2 +-
 fs/proc/vmcore.c                                   |  4 ++--
 fs/quota/dquot.c                                   |  2 +-
 kernel/trace/ftrace.c                              |  2 +-
 kernel/trace/trace_events.c                        |  6 ++----
 lib/percpu_ida.c                                   |  2 +-
 lib/raid6/algos.c                                  |  2 +-
 lib/swiotlb.c                                      | 12 +++++-------
 mm/memory.c                                        |  2 +-
 mm/page_alloc.c                                    |  4 ++--
 mm/slub.c                                          |  2 +-
 net/core/neighbour.c                               |  3 +--
 net/dccp/proto.c                                   |  8 ++++----
 net/decnet/dn_route.c                              |  3 +--
 net/ipv4/fib_semantics.c                           |  3 +--
 net/netfilter/nf_conntrack_core.c                  |  2 +-
 net/netlink/af_netlink.c                           |  4 ++--
 net/packet/af_packet.c                             |  4 ++--
 net/sched/sch_api.c                                |  3 +--
 net/sctp/protocol.c                                |  8 ++++----
 net/sctp/ssnmap.c                                  |  3 +--
 net/xfrm/xfrm_hash.c                               |  3 +--
 security/integrity/ima/ima_crypto.c                |  4 ++--
 sound/core/memalloc.c                              |  2 +-
 sound/oss/dmabuf.c                                 |  2 +-
 sound/usb/usx2y/usb_stream.c                       |  5 ++---
 152 files changed, 222 insertions(+), 269 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/include/asm/agp.h b/arch/alpha/include/asm/agp.h</span>
<span class="p_header">index 2fe5800..6179691 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/agp.h</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/alpha/kernel/pci-noop.c b/arch/alpha/kernel/pci-noop.c</span>
<span class="p_header">index d3bcb88..543e3e7 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci-noop.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci-noop.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static void *alpha_noop_alloc_coherent(struct device *dev, size_t size,</span>
 
 	if (!dev || *dev-&gt;dma_mask &gt;= 0xffffffffUL)
 		gfp &amp;= ~GFP_DMA;
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 	if (ret) {
 		memset(ret, 0, size);
 		*dma_handle = virt_to_phys(ret);
<span class="p_header">diff --git a/arch/alpha/kernel/pci_iommu.c b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">index fb0b20ee..b9b910f 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> static void *alpha_pci_alloc_coherent(struct device *dev, size_t size,</span>
 	gfp &amp;= ~GFP_DMA;
 
 try_again:
<span class="p_del">-	cpu_addr = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	cpu_addr = get_free_pages(gfp, order);</span>
 	if (! cpu_addr) {
 		printk(KERN_INFO &quot;pci_alloc_consistent: &quot;
 		       &quot;get_free_pages failed from %pf\n&quot;,
<span class="p_header">diff --git a/arch/arc/include/asm/pgalloc.h b/arch/arc/include/asm/pgalloc.h</span>
<span class="p_header">index 1200117..a540e9b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> static inline int __get_order_pgd(void)</span>
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
 	int num, num2;
<span class="p_del">-	pgd_t *ret = (pgd_t *) __get_free_pages(GFP_KERNEL, __get_order_pgd());</span>
<span class="p_add">+	pgd_t *ret = get_free_pages(GFP_KERNEL, __get_order_pgd());</span>
 
 	if (ret) {
 		num = USER_PTRS_PER_PGD + USER_KERNEL_GUTTER / PGDIR_SIZE;
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *) __get_free_pages(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO,</span>
<span class="p_add">+	pte = get_free_pages(GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO,</span>
 					 __get_order_pte());
 
 	return pte;
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 	pgtable_t pte_pg;
 	struct page *page;
 
<span class="p_del">-	pte_pg = (pgtable_t)__get_free_pages(GFP_KERNEL | __GFP_REPEAT, __get_order_pte());</span>
<span class="p_add">+	pte_pg = get_free_pages(GFP_KERNEL | __GFP_REPEAT, __get_order_pte());</span>
 	if (!pte_pg)
 		return 0;
 	memzero((void *)pte_pg, PTRS_PER_PTE * sizeof(pte_t));
<span class="p_header">diff --git a/arch/arm/include/asm/tlb.h b/arch/arm/include/asm/tlb.h</span>
<span class="p_header">index c8611f2..21300f4 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/tlb.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/tlb.h</span>
<span class="p_chunk">@@ -117,10 +117,10 @@</span> <span class="p_context"> static inline void tlb_add_flush(struct mmu_gather *tlb, unsigned long addr)</span>
 
 static inline void __tlb_alloc_page(struct mmu_gather *tlb)
 {
<span class="p_del">-	unsigned long addr = __get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
<span class="p_add">+	void *addr = get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
 
 	if (addr) {
<span class="p_del">-		tlb-&gt;pages = (void *)addr;</span>
<span class="p_add">+		tlb-&gt;pages = addr;</span>
 		tlb-&gt;max = PAGE_SIZE / sizeof(struct page *);
 	}
 }
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 190e9fb..429b673 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -1657,8 +1657,8 @@</span> <span class="p_context"> int kvm_mmu_init(void)</span>
 	 */
 	BUG_ON((hyp_idmap_start ^ (hyp_idmap_end - 1)) &amp; PAGE_MASK);
 
<span class="p_del">-	hyp_pgd = (pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, hyp_pgd_order);</span>
<span class="p_del">-	boot_hyp_pgd = (pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, hyp_pgd_order);</span>
<span class="p_add">+	hyp_pgd = get_free_pages(GFP_KERNEL | __GFP_ZERO, hyp_pgd_order);</span>
<span class="p_add">+	boot_hyp_pgd = get_free_pages(GFP_KERNEL | __GFP_ZERO, hyp_pgd_order);</span>
 
 	if (!hyp_pgd || !boot_hyp_pgd) {
 		kvm_err(&quot;Hyp mode PGD not allocated\n&quot;);
<span class="p_header">diff --git a/arch/arm/mm/pgd.c b/arch/arm/mm/pgd.c</span>
<span class="p_header">index b8799fa..f65e684 100644</span>
<span class="p_header">--- a/arch/arm/mm/pgd.c</span>
<span class="p_header">+++ b/arch/arm/mm/pgd.c</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"></span>
 #define __pgd_alloc()	kmalloc(PTRS_PER_PGD * sizeof(pgd_t), GFP_KERNEL)
 #define __pgd_free(pgd)	kfree(pgd)
 #else
<span class="p_del">-#define __pgd_alloc()	(pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_REPEAT, 2)</span>
<span class="p_add">+#define __pgd_alloc()	get_free_pages(GFP_KERNEL | __GFP_REPEAT, 2)</span>
 #define __pgd_free(pgd)	free_pages(pgd, 2)
 #endif
 
<span class="p_header">diff --git a/arch/blackfin/include/asm/mmu_context.h b/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_header">index 198cb70..75147aa 100644</span>
<span class="p_header">--- a/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -173,8 +173,8 @@</span> <span class="p_context"> static inline int</span>
 init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
 #ifdef CONFIG_MPU
<span class="p_del">-	unsigned long p = __get_free_pages(GFP_KERNEL, page_mask_order);</span>
<span class="p_del">-	mm-&gt;context.page_rwx_mask = (unsigned long *)p;</span>
<span class="p_add">+	unsigned long *p = get_free_pages(GFP_KERNEL, page_mask_order);</span>
<span class="p_add">+	mm-&gt;context.page_rwx_mask = p;</span>
 	memset(mm-&gt;context.page_rwx_mask, 0,
 	       page_mask_nelts * 3 * sizeof(long));
 #endif
<span class="p_header">diff --git a/arch/cris/arch-v32/drivers/pci/dma.c b/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_header">index 9b43cec..979a2c7 100644</span>
<span class="p_header">--- a/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_header">+++ b/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> void *dma_alloc_coherent(struct device *dev, size_t size,</span>
 	if (dev == NULL || (dev-&gt;coherent_dma_mask &lt; 0xffffffff))
 		gfp |= GFP_DMA;
 
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	ret = get_free_pages(gfp, order);</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/arch/frv/mm/dma-alloc.c b/arch/frv/mm/dma-alloc.c</span>
<span class="p_header">index 62268e1..60dea14 100644</span>
<span class="p_header">--- a/arch/frv/mm/dma-alloc.c</span>
<span class="p_header">+++ b/arch/frv/mm/dma-alloc.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)</span>
 	size = PAGE_ALIGN(size);
 	order = get_order(size);
 
<span class="p_del">-	page = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	page = get_free_pages(gfp, order);</span>
 	if (!page) {
 		BUG();
 		return NULL;
<span class="p_header">diff --git a/arch/h8300/kernel/dma.c b/arch/h8300/kernel/dma.c</span>
<span class="p_header">index 063a0f5..3092f45 100644</span>
<span class="p_header">--- a/arch/h8300/kernel/dma.c</span>
<span class="p_header">+++ b/arch/h8300/kernel/dma.c</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> static void *dma_alloc(struct device *dev, size_t size,</span>
 
 	if (dev == NULL || (*dev-&gt;dma_mask &lt; 0xffffffff))
 		gfp |= GFP_DMA;
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/arch/ia64/hp/common/sba_iommu.c b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">index 2988500..c721949 100644</span>
<span class="p_header">--- a/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">+++ b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_chunk">@@ -1149,7 +1149,7 @@</span> <span class="p_context"> sba_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,</span>
 		addr = page_address(page);
 	}
 #else
<span class="p_del">-	addr = (void *) __get_free_pages(flags, get_order(size));</span>
<span class="p_add">+	addr = get_free_pages(flags, get_order(size));</span>
 #endif
 	if (unlikely(!addr))
 		return NULL;
<span class="p_chunk">@@ -1631,8 +1631,7 @@</span> <span class="p_context"> ioc_iova_init(struct ioc *ioc)</span>
 	WRITE_REG(tcnfg, ioc-&gt;ioc_hpa + IOC_TCNFG);
 
 	ioc-&gt;pdir_size = (ioc-&gt;iov_size / iovp_size) * PDIR_ENTRY_SIZE;
<span class="p_del">-	ioc-&gt;pdir_base = (void *) __get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-						   get_order(ioc-&gt;pdir_size));</span>
<span class="p_add">+	ioc-&gt;pdir_base = get_free_pages(GFP_KERNEL, get_order(ioc-&gt;pdir_size));</span>
 	if (!ioc-&gt;pdir_base)
 		panic(PFX &quot;Couldn&#39;t allocate I/O Page Table\n&quot;);
 
<span class="p_chunk">@@ -1671,7 +1670,7 @@</span> <span class="p_context"> ioc_iova_init(struct ioc *ioc)</span>
 		int poison_size = 16;
 		void *poison_addr, *addr;
 
<span class="p_del">-		addr = (void *)__get_free_pages(GFP_KERNEL, get_order(iovp_size));</span>
<span class="p_add">+		addr = get_free_pages(GFP_KERNEL, get_order(iovp_size));</span>
 		if (!addr)
 			panic(PFX &quot;Couldn&#39;t allocate PDIR spill page\n&quot;);
 
<span class="p_chunk">@@ -1712,8 +1711,7 @@</span> <span class="p_context"> ioc_resource_init(struct ioc *ioc)</span>
 	ioc-&gt;res_size &gt;&gt;= 3;  /* convert bit count to byte count */
 	DBG_INIT(&quot;%s() res_size 0x%x\n&quot;, __func__, ioc-&gt;res_size);
 
<span class="p_del">-	ioc-&gt;res_map = (char *) __get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-						 get_order(ioc-&gt;res_size));</span>
<span class="p_add">+	ioc-&gt;res_map = get_free_pages(GFP_KERNEL, get_order(ioc-&gt;res_size));</span>
 	if (!ioc-&gt;res_map)
 		panic(PFX &quot;Couldn&#39;t allocate resource map\n&quot;);
 
<span class="p_header">diff --git a/arch/ia64/include/asm/agp.h b/arch/ia64/include/asm/agp.h</span>
<span class="p_header">index 80c30d4..4f360b9 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/agp.h</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/ia64/include/asm/tlb.h b/arch/ia64/include/asm/tlb.h</span>
<span class="p_header">index 52ab3a9..06dc9e3 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/tlb.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/tlb.h</span>
<span class="p_chunk">@@ -158,10 +158,10 @@</span> <span class="p_context"> ia64_tlb_flush_mmu (struct mmu_gather *tlb, unsigned long start, unsigned long e</span>
 
 static inline void __tlb_alloc_page(struct mmu_gather *tlb)
 {
<span class="p_del">-	unsigned long addr = __get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
<span class="p_add">+	void *addr = get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
 
 	if (addr) {
<span class="p_del">-		tlb-&gt;pages = (void *)addr;</span>
<span class="p_add">+		tlb-&gt;pages = addr;</span>
 		tlb-&gt;max = PAGE_SIZE / sizeof(void *);
 	}
 }
<span class="p_header">diff --git a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c</span>
<span class="p_header">index 2889412..2648a6f 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/mca.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/mca.c</span>
<span class="p_chunk">@@ -1858,8 +1858,7 @@</span> <span class="p_context"> ia64_mca_cpu_init(void *cpu_data)</span>
 			data = mca_bootmem();
 			first_time = 0;
 		} else
<span class="p_del">-			data = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-							get_order(sz));</span>
<span class="p_add">+			data = get_free_pages(GFP_KERNEL, get_order(sz));</span>
 		if (!data)
 			panic(&quot;Could not allocate MCA memory for cpu %d\n&quot;,
 					cpu);
<span class="p_header">diff --git a/arch/ia64/sn/pci/pci_dma.c b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">index f25c898..2126b54 100644</span>
<span class="p_header">--- a/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static void *sn_dma_alloc_coherent(struct device *dev, size_t size,</span>
 		else
 			return NULL;
 	} else
<span class="p_del">-		cpuaddr = (void *)__get_free_pages(flags, get_order(size));</span>
<span class="p_add">+		cpuaddr = get_free_pages(flags, get_order(size));</span>
 
 	if (unlikely(!cpuaddr))
 		return NULL;
<span class="p_header">diff --git a/arch/m68k/kernel/dma.c b/arch/m68k/kernel/dma.c</span>
<span class="p_header">index 2bdf7bf..da443983 100644</span>
<span class="p_header">--- a/arch/m68k/kernel/dma.c</span>
<span class="p_header">+++ b/arch/m68k/kernel/dma.c</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> void *dma_alloc_coherent(struct device *dev, size_t size,</span>
 
 	if (dev == NULL || (*dev-&gt;dma_mask &lt; 0xffffffff))
 		gfp |= GFP_DMA;
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/arch/microblaze/include/asm/pgalloc.h b/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_header">index 5e3fc6c..13030db 100644</span>
<span class="p_header">--- a/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/microblaze/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> static inline pgd_t *get_pgd_slow(void)</span>
 {
 	pgd_t *ret;
 
<span class="p_del">-	ret = (pgd_t *)__get_free_pages(GFP_KERNEL, PGDIR_ORDER);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, PGDIR_ORDER);</span>
 	if (ret != NULL)
 		clear_page(ret);
 	return ret;
<span class="p_header">diff --git a/arch/microblaze/mm/consistent.c b/arch/microblaze/mm/consistent.c</span>
<span class="p_header">index bdeb2cb..335f006 100644</span>
<span class="p_header">--- a/arch/microblaze/mm/consistent.c</span>
<span class="p_header">+++ b/arch/microblaze/mm/consistent.c</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)</span>
 	size = PAGE_ALIGN(size);
 	order = get_order(size);
 
<span class="p_del">-	vaddr = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	vaddr = get_free_pages(gfp, order);</span>
 	if (!vaddr)
 		return NULL;
 
<span class="p_header">diff --git a/arch/mips/include/asm/pgalloc.h b/arch/mips/include/asm/pgalloc.h</span>
<span class="p_header">index e29cc40..820ca21 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 {
 	pgd_t *ret, *init;
 
<span class="p_del">-	ret = (pgd_t *) __get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
 	if (ret) {
 		init = pgd_offset(&amp;init_mm, 0UL);
 		pgd_init((unsigned long)ret);
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *) __get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, PTE_ORDER);</span>
<span class="p_add">+	pte = get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO, PTE_ORDER);</span>
 
 	return pte;
 }
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 {
 	pmd_t *pmd;
 
<span class="p_del">-	pmd = (pmd_t *) __get_free_pages(GFP_KERNEL|__GFP_REPEAT, PMD_ORDER);</span>
<span class="p_add">+	pmd = get_free_pages(GFP_KERNEL|__GFP_REPEAT, PMD_ORDER);</span>
 	if (pmd)
 		pmd_init((unsigned long)pmd, (unsigned long)invalid_pte_table);
 	return pmd;
<span class="p_header">diff --git a/arch/mips/jazz/jazzdma.c b/arch/mips/jazz/jazzdma.c</span>
<span class="p_header">index db6f5af..8f65436 100644</span>
<span class="p_header">--- a/arch/mips/jazz/jazzdma.c</span>
<span class="p_header">+++ b/arch/mips/jazz/jazzdma.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> static int __init vdma_init(void)</span>
 	 * aligned and should be uncached to avoid cache flushing after every
 	 * update.
 	 */
<span class="p_del">-	pgtbl = (VDMA_PGTBL_ENTRY *)__get_free_pages(GFP_KERNEL | GFP_DMA,</span>
<span class="p_del">-						    get_order(VDMA_PGTBL_SIZE));</span>
<span class="p_add">+	pgtbl = get_free_pages(GFP_KERNEL | GFP_DMA, get_order(VDMA_PGTBL_SIZE));</span>
 	BUG_ON(!pgtbl);
 	dma_cache_wback_inv((unsigned long)pgtbl, VDMA_PGTBL_SIZE);
 	pgtbl = (VDMA_PGTBL_ENTRY *)KSEG1ADDR(pgtbl);
<span class="p_header">diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c</span>
<span class="p_header">index d3c1cec..c0863e9 100644</span>
<span class="p_header">--- a/arch/mips/mm/dma-default.c</span>
<span class="p_header">+++ b/arch/mips/mm/dma-default.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static void *mips_dma_alloc_noncoherent(struct device *dev, size_t size,</span>
 
 	gfp = massage_gfp_flags(dev, gfp);
 
<span class="p_del">-	ret = (void *) __get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/arch/nios2/include/asm/pgalloc.h b/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_header">index 91cd323..12cfc5e 100644</span>
<span class="p_header">--- a/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *) __get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO,</span>
<span class="p_add">+	pte = get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO,</span>
 					PTE_ORDER);
 
 	return pte;
<span class="p_header">diff --git a/arch/nios2/mm/dma-mapping.c b/arch/nios2/mm/dma-mapping.c</span>
<span class="p_header">index 0195f8f..7efef15 100644</span>
<span class="p_header">--- a/arch/nios2/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/nios2/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> void *dma_alloc_coherent(struct device *dev, size_t size,</span>
 	if (dev == NULL || (dev-&gt;coherent_dma_mask &lt; 0xffffffff))
 		gfp |= GFP_DMA;
 
<span class="p_del">-	ret = (void *) __get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 	if (ret != NULL) {
 		*dma_handle = virt_to_phys(ret);
 		flush_dcache_range((unsigned long) ret,
<span class="p_header">diff --git a/arch/nios2/mm/pgtable.c b/arch/nios2/mm/pgtable.c</span>
<span class="p_header">index 61e24a2..9af52c7 100644</span>
<span class="p_header">--- a/arch/nios2/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/nios2/mm/pgtable.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 {
 	pgd_t *ret, *init;
 
<span class="p_del">-	ret = (pgd_t *) __get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
 	if (ret) {
 		init = pgd_offset(&amp;init_mm, 0UL);
 		pgd_init(ret);
<span class="p_header">diff --git a/arch/parisc/include/asm/agp.h b/arch/parisc/include/asm/agp.h</span>
<span class="p_header">index 31f67a5..4ecd394 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/agp.h</span>
<span class="p_chunk">@@ -13,7 +13,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/parisc/include/asm/pgalloc.h b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">index 51cb827..5c10934 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -20,8 +20,7 @@</span> <span class="p_context"></span>
  * kernel for machines with under 4GB of memory) */
 static inline pgd_t *pgd_alloc(struct mm_struct *mm)
 {
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-					       PGD_ALLOC_ORDER);</span>
<span class="p_add">+	pgd_t *pgd = get_free_pages(GFP_KERNEL, PGD_ALLOC_ORDER);</span>
 	pgd_t *actual_pgd = pgd;
 
 	if (likely(pgd != NULL)) {
<span class="p_chunk">@@ -63,8 +62,7 @@</span> <span class="p_context"> static inline void pgd_populate(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmd)</span>
 
 static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)
 {
<span class="p_del">-	pmd_t *pmd = (pmd_t *)__get_free_pages(GFP_KERNEL|__GFP_REPEAT,</span>
<span class="p_del">-					       PMD_ORDER);</span>
<span class="p_add">+	pmd_t *pmd = get_free_pages(GFP_KERNEL|__GFP_REPEAT, PMD_ORDER);</span>
 	if (pmd)
 		memset(pmd, 0, PAGE_SIZE&lt;&lt;PMD_ORDER);
 	return pmd;
<span class="p_header">diff --git a/arch/parisc/kernel/pci-dma.c b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">index 3c4ebba..6f15633 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -393,8 +393,7 @@</span> <span class="p_context"> pcxl_dma_init(void)</span>
 	spin_lock_init(&amp;pcxl_res_lock);
 	pcxl_res_size = PCXL_DMA_MAP_SIZE &gt;&gt; (PAGE_SHIFT + 3);
 	pcxl_res_hint = 0;
<span class="p_del">-	pcxl_res_map = (char *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-					    get_order(pcxl_res_size));</span>
<span class="p_add">+	pcxl_res_map = get_free_pages(GFP_KERNEL, get_order(pcxl_res_size));</span>
 	memset(pcxl_res_map, 0, pcxl_res_size);
 	proc_gsc_root = proc_mkdir(&quot;gsc&quot;, NULL);
 	if (!proc_gsc_root)
<span class="p_chunk">@@ -571,7 +570,7 @@</span> <span class="p_context"> static void *pa11_dma_alloc_noncoherent(struct device *dev, size_t size,</span>
 {
 	void *addr;
 
<span class="p_del">-	addr = (void *)__get_free_pages(flag, get_order(size));</span>
<span class="p_add">+	addr = get_free_pages(flag, get_order(size));</span>
 	if (addr)
 		*dma_handle = (dma_addr_t)virt_to_phys(addr);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/agp.h b/arch/powerpc/include/asm/agp.h</span>
<span class="p_header">index 06df165..3c16089 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/agp.h</span>
<span class="p_chunk">@@ -10,7 +10,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/powerpc/kernel/fadump.c b/arch/powerpc/kernel/fadump.c</span>
<span class="p_header">index 26d091a..63fdb91 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/fadump.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/fadump.c</span>
<span class="p_chunk">@@ -551,7 +551,7 @@</span> <span class="p_context"> static void *fadump_cpu_notes_buf_alloc(unsigned long size)</span>
 	unsigned long order, count, i;
 
 	order = get_order(size);
<span class="p_del">-	vaddr = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, order);</span>
<span class="p_add">+	vaddr = get_free_pages(GFP_KERNEL|__GFP_ZERO, order);</span>
 	if (!vaddr)
 		return NULL;
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">index 3dd6f8e..3e5c71c 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> long kvmppc_alloc_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
 	/* Lastly try successively smaller sizes from the page allocator */
 	/* Only do this if userspace didn&#39;t specify a size via ioctl */
 	while (!hpt &amp;&amp; order &gt; PPC_MIN_HPT_ORDER &amp;&amp; !htab_orderp) {
<span class="p_del">-		hpt = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO|</span>
<span class="p_add">+		hpt = get_free_pages(GFP_KERNEL|__GFP_ZERO|</span>
 					__GFP_REPEAT| __GFP_NOWARN,
 					order - PAGE_SHIFT);
 		if (!hpt)
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">index 89bfc17..6e6c311 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 #ifndef CONFIG_PPC_4K_PAGES
 	ret = kmem_cache_alloc(pgtable_cache, GFP_KERNEL | __GFP_ZERO);
 #else
<span class="p_del">-	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
 			PGDIR_ORDER - PAGE_SHIFT);
 #endif
 	return ret;
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/spufs/inode.c b/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_header">index 14a47f9..9ef5a940 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_chunk">@@ -668,7 +668,7 @@</span> <span class="p_context"> spufs_init_isolated_loader(void)</span>
 		return;
 
 	/* the loader must be align on a 16 byte boundary */
<span class="p_del">-	isolated_loader = (char *)__get_free_pages(GFP_KERNEL, get_order(size));</span>
<span class="p_add">+	isolated_loader = get_free_pages(GFP_KERNEL, get_order(size));</span>
 	if (!isolated_loader)
 		return;
 
<span class="p_header">diff --git a/arch/s390/hypfs/hypfs_diag.c b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">index 08f71f8..dda5bf0 100644</span>
<span class="p_header">--- a/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">+++ b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_chunk">@@ -396,7 +396,7 @@</span> <span class="p_context"> static void *diag204_alloc_vbuf(int pages)</span>
 
 static void *diag204_alloc_rbuf(void)
 {
<span class="p_del">-	diag204_buf = (void*)__get_free_pages(GFP_KERNEL,0);</span>
<span class="p_add">+	diag204_buf = get_free_pages(GFP_KERNEL,0);</span>
 	if (!diag204_buf)
 		return ERR_PTR(-ENOMEM);
 	diag204_buf_pages = 1;
<span class="p_header">diff --git a/arch/s390/include/asm/idals.h b/arch/s390/include/asm/idals.h</span>
<span class="p_header">index 56b1baf..cdbf89a 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/idals.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/idals.h</span>
<span class="p_chunk">@@ -132,8 +132,7 @@</span> <span class="p_context"> idal_buffer_alloc(size_t size, int page_order)</span>
 			ib-&gt;data[i] = ib-&gt;data[i-1] + IDA_BLOCK_SIZE;
 			continue;
 		}
<span class="p_del">-		ib-&gt;data[i] = (void *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL, page_order);</span>
<span class="p_add">+		ib-&gt;data[i] = get_free_pages(GFP_KERNEL, page_order);</span>
 		if (ib-&gt;data[i] != NULL)
 			continue;
 		// Not enough memory
<span class="p_header">diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c</span>
<span class="p_header">index 63c1c8c..34a5041 100644</span>
<span class="p_header">--- a/arch/s390/kernel/smp.c</span>
<span class="p_header">+++ b/arch/s390/kernel/smp.c</span>
<span class="p_chunk">@@ -183,8 +183,7 @@</span> <span class="p_context"> static int pcpu_alloc_lowcore(struct pcpu *pcpu, int cpu)</span>
 	struct _lowcore *lc;
 
 	if (pcpu != &amp;pcpu_devices[0]) {
<span class="p_del">-		pcpu-&gt;lowcore =	(struct _lowcore *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL | GFP_DMA, LC_ORDER);</span>
<span class="p_add">+		pcpu-&gt;lowcore =	get_free_pages(GFP_KERNEL | GFP_DMA, LC_ORDER);</span>
 		async_stack = __get_free_pages(GFP_KERNEL, ASYNC_ORDER);
 		panic_stack = __get_free_page(GFP_KERNEL);
 		if (!pcpu-&gt;lowcore || !panic_stack || !async_stack)
<span class="p_header">diff --git a/arch/s390/mm/vmem.c b/arch/s390/mm/vmem.c</span>
<span class="p_header">index ef7d6c8..44cb4af 100644</span>
<span class="p_header">--- a/arch/s390/mm/vmem.c</span>
<span class="p_header">+++ b/arch/s390/mm/vmem.c</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> static LIST_HEAD(mem_segs);</span>
 static void __ref *vmem_alloc_pages(unsigned int order)
 {
 	if (slab_is_available())
<span class="p_del">-		return (void *)__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+		return get_free_pages(GFP_KERNEL, order);</span>
 	return alloc_bootmem_pages((1 &lt;&lt; order) * PAGE_SIZE);
 }
 
<span class="p_header">diff --git a/arch/s390/pci/pci_clp.c b/arch/s390/pci/pci_clp.c</span>
<span class="p_header">index 5914a16..162d9b6 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_clp.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_clp.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static inline u8 clp_instr(void *data)</span>
 
 static void *clp_alloc_block(gfp_t gfp_mask)
 {
<span class="p_del">-	return (void *) __get_free_pages(gfp_mask, get_order(CLP_BLK_SIZE));</span>
<span class="p_add">+	return get_free_pages(gfp_mask, get_order(CLP_BLK_SIZE));</span>
 }
 
 static void clp_free_block(void *ptr)
<span class="p_header">diff --git a/arch/score/include/asm/pgalloc.h b/arch/score/include/asm/pgalloc.h</span>
<span class="p_header">index 55fb080..6e07805 100644</span>
<span class="p_header">--- a/arch/score/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/score/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 {
 	pgd_t *ret, *init;
 
<span class="p_del">-	ret = (pgd_t *) __get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, PGD_ORDER);</span>
 	if (ret) {
 		init = pgd_offset(&amp;init_mm, 0UL);
 		pgd_init((unsigned long)ret);
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,</span>
 {
 	pte_t *pte;
 
<span class="p_del">-	pte = (pte_t *) __get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO,</span>
<span class="p_add">+	pte = get_free_pages(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO,</span>
 					PTE_ORDER);
 
 	return pte;
<span class="p_header">diff --git a/arch/sh/mm/consistent.c b/arch/sh/mm/consistent.c</span>
<span class="p_header">index 4721e24..6324c40 100644</span>
<span class="p_header">--- a/arch/sh/mm/consistent.c</span>
<span class="p_header">+++ b/arch/sh/mm/consistent.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> void *dma_generic_alloc_coherent(struct device *dev, size_t size,</span>
 
 	gfp |= __GFP_ZERO;
 
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	ret = get_free_pages(gfp, order);</span>
 	if (!ret)
 		return NULL;
 
<span class="p_header">diff --git a/arch/sparc/include/asm/agp.h b/arch/sparc/include/asm/agp.h</span>
<span class="p_header">index 363d3e6..dd31037 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/agp.h</span>
<span class="p_chunk">@@ -9,7 +9,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/sparc/kernel/ioport.c b/arch/sparc/kernel/ioport.c</span>
<span class="p_header">index 3bd3481..1ff0516 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ioport.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ioport.c</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> static void *sbus_alloc_coherent(struct device *dev, size_t len,</span>
 	}
 
 	order = get_order(len_total);
<span class="p_del">-	va = (void *)__get_free_pages(gfp, order);</span>
<span class="p_add">+	va = get_free_pages(gfp, order);</span>
 	if (!va)
 		goto err_nopages;
 
<span class="p_chunk">@@ -444,7 +444,7 @@</span> <span class="p_context"> static void *pci32_alloc_coherent(struct device *dev, size_t len,</span>
 	}
 
 	order = get_order(len_total);
<span class="p_del">-	va = (void *) __get_free_pages(gfp, order);</span>
<span class="p_add">+	va = get_free_pages(gfp, order);</span>
 	if (va == NULL) {
 		printk(&quot;pci_alloc_consistent: no %ld pages\n&quot;, len_total&gt;&gt;PAGE_SHIFT);
 		goto err_nopages;
<span class="p_header">diff --git a/arch/sparc/kernel/irq_64.c b/arch/sparc/kernel/irq_64.c</span>
<span class="p_header">index e2d198d..8858bb0 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/irq_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/irq_64.c</span>
<span class="p_chunk">@@ -1095,8 +1095,7 @@</span> <span class="p_context"> static void __init irq_ivector_init(void)</span>
 	ivecs = size_nr_ivec();
 	size = sizeof(struct ino_bucket) * ivecs;
 	order = get_order(size);
<span class="p_del">-	ivector_table = (struct ino_bucket *)</span>
<span class="p_del">-		__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
<span class="p_add">+	ivector_table = get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
 	if (!ivector_table) {
 		prom_printf(&quot;Fatal error, cannot allocate ivector_table\n&quot;);
 		prom_halt();
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 1cba9b7..05fe8eb 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -975,7 +975,7 @@</span> <span class="p_context"> static int alloc_queue(const char *name, unsigned long num_entries,</span>
 	size = num_entries * LDC_PACKET_SIZE;
 	order = get_order(size);
 
<span class="p_del">-	q = (void *) __get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	q = get_free_pages(GFP_KERNEL, order);</span>
 	if (!q) {
 		printk(KERN_ERR PFX &quot;Alloc of %s queue failed with &quot;
 		       &quot;size=%lu order=%lu\n&quot;, name, size, order);
<span class="p_chunk">@@ -1059,8 +1059,7 @@</span> <span class="p_context"> static int ldc_iommu_init(const char *name, struct ldc_channel *lp)</span>
 
 	order = get_order(tsbsize);
 
<span class="p_del">-	table = (struct ldc_mtable_entry *)</span>
<span class="p_del">-		__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	table = get_free_pages(GFP_KERNEL, order);</span>
 	err = -ENOMEM;
 	if (!table) {
 		printk(KERN_ERR PFX &quot;Alloc of MTE table failed, &quot;
<span class="p_header">diff --git a/arch/sparc/kernel/pci_fire.c b/arch/sparc/kernel/pci_fire.c</span>
<span class="p_header">index ff44386..59c96bf 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_fire.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_fire.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static int pci_fire_msiq_alloc(struct pci_pbm_info *pbm)</span>
 	void *pages;
 
 	order = get_order(512 * 1024);
<span class="p_del">-	pages = (void *)__get_free_pages(GFP_KERNEL | __GFP_COMP, order);</span>
<span class="p_add">+	pages = get_free_pages(GFP_KERNEL | __GFP_COMP, order);</span>
 	if (!pages) {
 		printk(KERN_ERR &quot;MSI: Cannot allocate MSI queues (o=%lu).\n&quot;,
 		       order);
<span class="p_header">diff --git a/arch/sparc/kernel/pci_sun4v.c b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">index 9d84e4e..d700a73 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_chunk">@@ -753,7 +753,7 @@</span> <span class="p_context"> static int pci_sun4v_msiq_alloc(struct pci_pbm_info *pbm)</span>
 	q_size = pbm-&gt;msiq_ent_count * sizeof(struct pci_sun4v_msiq_entry);
 	alloc_size = (pbm-&gt;msiq_num * q_size);
 	order = get_order(alloc_size);
<span class="p_del">-	pages = (void *)__get_free_pages(GFP_KERNEL | __GFP_COMP, order);</span>
<span class="p_add">+	pages = get_free_pages(GFP_KERNEL | __GFP_COMP, order);</span>
 	if (!pages) {
 		printk(KERN_ERR &quot;MSI: Cannot allocate MSI queues (o=%lu).\n&quot;,
 		       order);
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index d21cd62..cc04b28 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -872,8 +872,7 @@</span> <span class="p_context"> void __init cheetah_ecache_flush_init(void)</span>
 		if ((PAGE_SIZE &lt;&lt; order) &gt;= sz)
 			break;
 	}
<span class="p_del">-	cheetah_error_log = (struct cheetah_err_info *)</span>
<span class="p_del">-		__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	cheetah_error_log = get_free_pages(GFP_KERNEL, order);</span>
 	if (!cheetah_error_log) {
 		prom_printf(&quot;cheetah_ecache_flush_init: Failed to allocate &quot;
 			    &quot;error logging scoreboard (%d bytes).\n&quot;, sz);
<span class="p_header">diff --git a/arch/um/drivers/net_kern.c b/arch/um/drivers/net_kern.c</span>
<span class="p_header">index 504f60b..3d2ced3 100644</span>
<span class="p_header">--- a/arch/um/drivers/net_kern.c</span>
<span class="p_header">+++ b/arch/um/drivers/net_kern.c</span>
<span class="p_chunk">@@ -880,7 +880,7 @@</span> <span class="p_context"> void *get_output_buffer(int *len_out)</span>
 {
 	void *ret;
 
<span class="p_del">-	ret = (void *) __get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, 0);</span>
 	if (ret) *len_out = PAGE_SIZE;
 	else *len_out = 0;
 	return ret;
<span class="p_header">diff --git a/arch/um/kernel/process.c b/arch/um/kernel/process.c</span>
<span class="p_header">index 69c8d56..05826e3 100644</span>
<span class="p_header">--- a/arch/um/kernel/process.c</span>
<span class="p_header">+++ b/arch/um/kernel/process.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> void *alloc_stack(int order, int atomic)</span>
 
 	if (atomic)
 		flags = GFP_ATOMIC;
<span class="p_del">-	return (void *)__get_free_pages(flags, order);</span>
<span class="p_add">+	return get_free_pages(flags, order);</span>
 }
 
 static inline void set_current(struct task_struct *task)
<span class="p_header">diff --git a/arch/unicore32/mm/pgd.c b/arch/unicore32/mm/pgd.c</span>
<span class="p_header">index 9485183..cf141a1c 100644</span>
<span class="p_header">--- a/arch/unicore32/mm/pgd.c</span>
<span class="p_header">+++ b/arch/unicore32/mm/pgd.c</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> pgd_t *get_pgd_slow(struct mm_struct *mm)</span>
 	pmd_t *new_pmd, *init_pmd;
 	pte_t *new_pte, *init_pte;
 
<span class="p_del">-	new_pgd = (pgd_t *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	new_pgd = get_free_pages(GFP_KERNEL, 0);</span>
 	if (!new_pgd)
 		goto no_pgd;
 
<span class="p_header">diff --git a/arch/x86/include/asm/agp.h b/arch/x86/include/asm/agp.h</span>
<span class="p_header">index 4f98370..84a43f3 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/agp.h</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
 
 /* GATT allocation. Returns/accepts GATT kernel virtual address. */
 #define alloc_gatt_pages(order)		\
<span class="p_del">-	((char *)__get_free_pages(GFP_KERNEL, (order)))</span>
<span class="p_add">+	((char *)get_free_pages(GFP_KERNEL, (order)))</span>
 #define free_gatt_pages(table, order)	\
 	free_pages((table), (order))
 
<span class="p_header">diff --git a/arch/x86/include/asm/xen/page-coherent.h b/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_header">index 8a55a89..1de4d93 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_chunk">@@ -9,7 +9,7 @@</span> <span class="p_context"> static inline void *xen_alloc_coherent_pages(struct device *hwdev, size_t size,</span>
 		dma_addr_t *dma_handle, gfp_t flags,
 		struct dma_attrs *attrs)
 {
<span class="p_del">-	void *vstart = (void*)__get_free_pages(flags, get_order(size));</span>
<span class="p_add">+	void *vstart = get_free_pages(flags, get_order(size));</span>
 	*dma_handle = virt_to_phys(vstart);
 	return vstart;
 }
<span class="p_header">diff --git a/arch/x86/kernel/amd_gart_64.c b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">index 94da9dd..5bc0312 100644</span>
<span class="p_header">--- a/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/amd_gart_64.c</span>
<span class="p_chunk">@@ -671,7 +671,7 @@</span> <span class="p_context"> static __init int init_amd_gatt(struct agp_kern_info *info)</span>
 	info-&gt;aper_size = aper_size &gt;&gt; 20;
 
 	gatt_size = (aper_size &gt;&gt; PAGE_SHIFT) * sizeof(u32);
<span class="p_del">-	gatt = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	gatt = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					get_order(gatt_size));
 	if (!gatt)
 		panic(&quot;Cannot allocate GATT table&quot;);
<span class="p_chunk">@@ -776,7 +776,7 @@</span> <span class="p_context"> int __init gart_iommu_init(void)</span>
 	iommu_size = check_iommu_size(info.aper_base, aper_size);
 	iommu_pages = iommu_size &gt;&gt; PAGE_SHIFT;
 
<span class="p_del">-	iommu_gart_bitmap = (void *) __get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	iommu_gart_bitmap = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 						      get_order(iommu_pages/8));
 	if (!iommu_gart_bitmap)
 		panic(&quot;Cannot allocate iommu bitmap\n&quot;);
<span class="p_header">diff --git a/arch/x86/kernel/pci-calgary_64.c b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">index 97e092d..738ed3e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> static void* calgary_alloc_coherent(struct device *dev, size_t size,</span>
 	flag &amp;= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);
 
 	/* alloc enough pages (and possibly more) */
<span class="p_del">-	ret = (void *)__get_free_pages(flag, order);</span>
<span class="p_add">+	ret = get_free_pages(flag, order);</span>
 	if (!ret)
 		goto error;
 	memset(ret, 0, size);
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 493f541..bce45cf 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> __ref void *alloc_low_pages(unsigned int num)</span>
 		unsigned int order;
 
 		order = get_order((unsigned long)num &lt;&lt; PAGE_SHIFT);
<span class="p_del">-		return (void *)__get_free_pages(GFP_ATOMIC | __GFP_NOTRACK |</span>
<span class="p_add">+		return get_free_pages(GFP_ATOMIC | __GFP_NOTRACK |</span>
 						__GFP_ZERO, order);
 	}
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index ed873dd..0478d9f 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -687,7 +687,7 @@</span> <span class="p_context"> static void *realloc_pages(void *old_memmap, int old_shift)</span>
 {
 	void *ret;
 
<span class="p_del">-	ret = (void *)__get_free_pages(GFP_KERNEL, old_shift + 1);</span>
<span class="p_add">+	ret = get_free_pages(GFP_KERNEL, old_shift + 1);</span>
 	if (!ret)
 		goto out;
 
<span class="p_header">diff --git a/arch/x86/um/ldt.c b/arch/x86/um/ldt.c</span>
<span class="p_header">index 52e173d..5264f55 100644</span>
<span class="p_header">--- a/arch/x86/um/ldt.c</span>
<span class="p_header">+++ b/arch/x86/um/ldt.c</span>
<span class="p_chunk">@@ -247,8 +247,7 @@</span> <span class="p_context"> static void ldt_get_host_info(void)</span>
 	for (i = LDT_PAGES_MAX-1, order=0; i; i&gt;&gt;=1, order++)
 		;
 
<span class="p_del">-	ldt = (struct ldt_entry *)</span>
<span class="p_del">-	      __get_free_pages(GFP_KERNEL|__GFP_ZERO, order);</span>
<span class="p_add">+	ldt = get_free_pages(GFP_KERNEL|__GFP_ZERO, order);</span>
 	if (ldt == NULL) {
 		printk(KERN_ERR &quot;ldt_get_host_info: couldn&#39;t allocate buffer &quot;
 		       &quot;for host ldt\n&quot;);
<span class="p_header">diff --git a/arch/xtensa/include/asm/pgalloc.h b/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_header">index 022b9b3..2a7631f 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"></span>
 static inline pgd_t*
 pgd_alloc(struct mm_struct *mm)
 {
<span class="p_del">-	return (pgd_t*) __get_free_pages(GFP_KERNEL | __GFP_ZERO, PGD_ORDER);</span>
<span class="p_add">+	return get_free_pages(GFP_KERNEL | __GFP_ZERO, PGD_ORDER);</span>
 }
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
<span class="p_header">diff --git a/crypto/xor.c b/crypto/xor.c</span>
<span class="p_header">index 20060f8..e25b834 100644</span>
<span class="p_header">--- a/crypto/xor.c</span>
<span class="p_header">+++ b/crypto/xor.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> calibrate_xor_blocks(void)</span>
 	 * test the XOR speed, we don&#39;t really want kmemcheck to warn about
 	 * reading uninitialized bytes here.
 	 */
<span class="p_del">-	b1 = (void *) __get_free_pages(GFP_KERNEL | __GFP_NOTRACK, 2);</span>
<span class="p_add">+	b1 = get_free_pages(GFP_KERNEL | __GFP_NOTRACK, 2);</span>
 	if (!b1) {
 		printk(KERN_WARNING &quot;xor: Yikes!  No memory available.\n&quot;);
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/base/devres.c b/drivers/base/devres.c</span>
<span class="p_header">index 414ac33..16876fa 100644</span>
<span class="p_header">--- a/drivers/base/devres.c</span>
<span class="p_header">+++ b/drivers/base/devres.c</span>
<span class="p_chunk">@@ -947,7 +947,7 @@</span> <span class="p_context"> void *devm_get_free_pages(struct device *dev,</span>
 				  gfp_t gfp_mask, unsigned int order)
 {
 	struct pages_devres *devres;
<span class="p_del">-	void *addr = (void *)__get_free_pages(gfp_mask, order);</span>
<span class="p_add">+	void *addr = get_free_pages(gfp_mask, order);</span>
 
 	if (unlikely(!addr))
 		return 0;
<span class="p_header">diff --git a/drivers/block/ps3vram.c b/drivers/block/ps3vram.c</span>
<span class="p_header">index db7ece5..9fbd9e8 100644</span>
<span class="p_header">--- a/drivers/block/ps3vram.c</span>
<span class="p_header">+++ b/drivers/block/ps3vram.c</span>
<span class="p_chunk">@@ -644,8 +644,7 @@</span> <span class="p_context"> static int ps3vram_probe(struct ps3_system_bus_device *dev)</span>
 	ps3_system_bus_set_drvdata(dev, priv);
 
 	/* Allocate XDR buffer (1MiB aligned) */
<span class="p_del">-	priv-&gt;xdr_buf = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-		get_order(XDR_BUF_SIZE));</span>
<span class="p_add">+	priv-&gt;xdr_buf = get_free_pages(GFP_KERNEL, get_order(XDR_BUF_SIZE));</span>
 	if (priv-&gt;xdr_buf == NULL) {
 		dev_err(&amp;dev-&gt;core, &quot;Could not allocate XDR buffer\n&quot;);
 		error = -ENOMEM;
<span class="p_header">diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c</span>
<span class="p_header">index c5873c2..fa97cc3 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkfront.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkfront.c</span>
<span class="p_chunk">@@ -1418,8 +1418,7 @@</span> <span class="p_context"> static int setup_blkring(struct xenbus_device *dev,</span>
 	for (i = 0; i &lt; info-&gt;nr_ring_pages; i++)
 		info-&gt;ring_ref[i] = GRANT_INVALID_REF;
 
<span class="p_del">-	sring = (struct blkif_sring *)__get_free_pages(GFP_NOIO | __GFP_HIGH,</span>
<span class="p_del">-						       get_order(ring_size));</span>
<span class="p_add">+	sring = get_free_pages(GFP_NOIO | __GFP_HIGH, get_order(ring_size));</span>
 	if (!sring) {
 		xenbus_dev_fatal(dev, -ENOMEM, &quot;allocating shared ring&quot;);
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/block/zram/zcomp.c b/drivers/block/zram/zcomp.c</span>
<span class="p_header">index efaa135..806546c 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)</span>
 	 * allocate 2 pages. 1 for compressed data, plus 1 extra for the
 	 * case when compressed size is larger than the original one
 	 */
<span class="p_del">-	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
<span class="p_add">+	zstrm-&gt;buffer = get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
 	if (!zstrm-&gt;private || !zstrm-&gt;buffer) {
 		zcomp_strm_free(comp, zstrm);
 		zstrm = NULL;
<span class="p_header">diff --git a/drivers/char/agp/hp-agp.c b/drivers/char/agp/hp-agp.c</span>
<span class="p_header">index 9f83f13..5a7fe5f 100644</span>
<span class="p_header">--- a/drivers/char/agp/hp-agp.c</span>
<span class="p_header">+++ b/drivers/char/agp/hp-agp.c</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> hp_zx1_create_gatt_table (struct agp_bridge_data *bridge)</span>
 	int i;
 
 	if (hp-&gt;io_pdir_owner) {
<span class="p_del">-		hp-&gt;io_pdir = (u64 *) __get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		hp-&gt;io_pdir = get_free_pages(GFP_KERNEL,</span>
 						get_order(hp-&gt;io_pdir_size));
 		if (!hp-&gt;io_pdir) {
 			printk(KERN_ERR PFX &quot;Couldn&#39;t allocate contiguous &quot;
<span class="p_header">diff --git a/drivers/char/agp/uninorth-agp.c b/drivers/char/agp/uninorth-agp.c</span>
<span class="p_header">index bcbe6a5..71d3f1a 100644</span>
<span class="p_header">--- a/drivers/char/agp/uninorth-agp.c</span>
<span class="p_header">+++ b/drivers/char/agp/uninorth-agp.c</span>
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> static int uninorth_create_gatt_table(struct agp_bridge_data *bridge)</span>
 		page_order = A_SIZE_32(temp)-&gt;page_order;
 		num_entries = A_SIZE_32(temp)-&gt;num_entries;
 
<span class="p_del">-		table = (char *) __get_free_pages(GFP_KERNEL, page_order);</span>
<span class="p_add">+		table = get_free_pages(GFP_KERNEL, page_order);</span>
 
 		if (table == NULL) {
 			i++;
<span class="p_header">diff --git a/drivers/crypto/atmel-aes.c b/drivers/crypto/atmel-aes.c</span>
<span class="p_header">index bf75457..dc99f80 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-aes.c</span>
<span class="p_chunk">@@ -652,8 +652,8 @@</span> <span class="p_context"> static int atmel_aes_buff_init(struct atmel_aes_dev *dd)</span>
 {
 	int err = -ENOMEM;
 
<span class="p_del">-	dd-&gt;buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_del">-	dd-&gt;buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	dd-&gt;buf_in = get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	dd-&gt;buf_out = get_free_pages(GFP_KERNEL, 0);</span>
 	dd-&gt;buflen = PAGE_SIZE;
 	dd-&gt;buflen &amp;= ~(AES_BLOCK_SIZE - 1);
 
<span class="p_header">diff --git a/drivers/crypto/atmel-tdes.c b/drivers/crypto/atmel-tdes.c</span>
<span class="p_header">index 0219027e..5f69db6 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-tdes.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-tdes.c</span>
<span class="p_chunk">@@ -347,8 +347,8 @@</span> <span class="p_context"> static int atmel_tdes_buff_init(struct atmel_tdes_dev *dd)</span>
 {
 	int err = -ENOMEM;
 
<span class="p_del">-	dd-&gt;buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_del">-	dd-&gt;buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	dd-&gt;buf_in = get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	dd-&gt;buf_out = get_free_pages(GFP_KERNEL, 0);</span>
 	dd-&gt;buflen = PAGE_SIZE;
 	dd-&gt;buflen &amp;= ~(DES_BLOCK_SIZE - 1);
 
<span class="p_header">diff --git a/drivers/crypto/nx/nx-842.c b/drivers/crypto/nx/nx-842.c</span>
<span class="p_header">index ce459cb..be7cdf6 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-842.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-842.c</span>
<span class="p_chunk">@@ -117,8 +117,8 @@</span> <span class="p_context"> int nx842_crypto_init(struct crypto_tfm *tfm, struct nx842_driver *driver)</span>
 	spin_lock_init(&amp;ctx-&gt;lock);
 	ctx-&gt;driver = driver;
 	ctx-&gt;wmem = kmalloc(driver-&gt;workmem_size, GFP_KERNEL);
<span class="p_del">-	ctx-&gt;sbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);</span>
<span class="p_del">-	ctx-&gt;dbounce = (u8 *)__get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);</span>
<span class="p_add">+	ctx-&gt;sbounce = get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);</span>
<span class="p_add">+	ctx-&gt;dbounce = get_free_pages(GFP_KERNEL, BOUNCE_BUFFER_ORDER);</span>
 	if (!ctx-&gt;wmem || !ctx-&gt;sbounce || !ctx-&gt;dbounce) {
 		kfree(ctx-&gt;wmem);
 		free_page(ctx-&gt;sbounce);
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index cd41ce7..4c91b97 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -582,8 +582,8 @@</span> <span class="p_context"> static int omap_aes_copy_sgs(struct omap_aes_dev *dd)</span>
 	total = ALIGN(dd-&gt;total, AES_BLOCK_SIZE);
 	pages = get_order(total);
 
<span class="p_del">-	buf_in = (void *)__get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_del">-	buf_out = (void *)__get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_add">+	buf_in = get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_add">+	buf_out = get_free_pages(GFP_ATOMIC, pages);</span>
 
 	if (!buf_in || !buf_out) {
 		pr_err(&quot;Couldn&#39;t allocated pages for unaligned cases.\n&quot;);
<span class="p_header">diff --git a/drivers/crypto/omap-des.c b/drivers/crypto/omap-des.c</span>
<span class="p_header">index 462f2bc..35c916e 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-des.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-des.c</span>
<span class="p_chunk">@@ -563,8 +563,8 @@</span> <span class="p_context"> static int omap_des_copy_sgs(struct omap_des_dev *dd)</span>
 
 	BUG_ON(!pages);
 
<span class="p_del">-	buf_in = (void *)__get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_del">-	buf_out = (void *)__get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_add">+	buf_in = get_free_pages(GFP_ATOMIC, pages);</span>
<span class="p_add">+	buf_out = get_free_pages(GFP_ATOMIC, pages);</span>
 
 	if (!buf_in || !buf_out) {
 		pr_err(&quot;Couldn&#39;t allocated pages for unaligned cases.\n&quot;);
<span class="p_header">diff --git a/drivers/dma/ste_dma40.c b/drivers/dma/ste_dma40.c</span>
<span class="p_header">index e2e0225..287d468 100644</span>
<span class="p_header">--- a/drivers/dma/ste_dma40.c</span>
<span class="p_header">+++ b/drivers/dma/ste_dma40.c</span>
<span class="p_chunk">@@ -3425,7 +3425,7 @@</span> <span class="p_context"> static int __init d40_lcla_allocate(struct d40_base *base)</span>
 	base-&gt;lcla_pool.pages = SZ_1K * base-&gt;num_phy_chans / PAGE_SIZE;
 
 	for (i = 0; i &lt; MAX_LCLA_ALLOC_ATTEMPTS; i++) {
<span class="p_del">-		page_list[i] = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		page_list[i] = get_free_pages(GFP_KERNEL,</span>
 						base-&gt;lcla_pool.pages);
 		if (!page_list[i]) {
 
<span class="p_header">diff --git a/drivers/firmware/dell_rbu.c b/drivers/firmware/dell_rbu.c</span>
<span class="p_header">index 7d1afaa..ba66b09 100644</span>
<span class="p_header">--- a/drivers/firmware/dell_rbu.c</span>
<span class="p_header">+++ b/drivers/firmware/dell_rbu.c</span>
<span class="p_chunk">@@ -160,8 +160,7 @@</span> <span class="p_context"> static int create_packet(void *data, size_t length)</span>
 	}
 
 	while (!packet_data_temp_buf) {
<span class="p_del">-		packet_data_temp_buf = (unsigned char *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL, ordernum);</span>
<span class="p_add">+		packet_data_temp_buf = get_free_pages(GFP_KERNEL, ordernum);</span>
 		if (!packet_data_temp_buf) {
 			printk(KERN_WARNING
 				&quot;dell_rbu:%s: failed to allocate new &quot;
<span class="p_chunk">@@ -434,8 +433,7 @@</span> <span class="p_context"> static int img_update_realloc(unsigned long size)</span>
 	spin_unlock(&amp;rbu_data.lock);
 
 	ordernum = get_order(size);
<span class="p_del">-	image_update_buffer =</span>
<span class="p_del">-		(unsigned char *) __get_free_pages(GFP_KERNEL, ordernum);</span>
<span class="p_add">+	image_update_buffer = get_free_pages(GFP_KERNEL, ordernum);</span>
 
 	img_buf_phys_addr =
 		(unsigned long) virt_to_phys(image_update_buffer);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_events.c b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">index 8bb3671..82d206f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> static bool allocate_signal_page(struct file *devkfd, struct kfd_process *p)</span>
 
 	page-&gt;free_slots = SLOTS_PER_PAGE;
 
<span class="p_del">-	backing_store = (void *) __get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	backing_store = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					get_order(KFD_SIGNAL_EVENT_LIMIT * 8));
 	if (!backing_store)
 		goto fail_alloc_signal_store;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 0b65dc5..c06147c 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -94,11 +94,11 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 				recv_ringbuffer_size));
 
 	if (!page)
<span class="p_del">-		out = (void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="p_del">-					       get_order(send_ringbuffer_size +</span>
<span class="p_add">+		out = get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="p_add">+				       get_order(send_ringbuffer_size +</span>
 					       recv_ringbuffer_size));
 	else
<span class="p_del">-		out = (void *)page_address(page);</span>
<span class="p_add">+		out = page_address(page);</span>
 
 	if (!out) {
 		err = -ENOMEM;
<span class="p_header">diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c</span>
<span class="p_header">index 99cf9e9..1ec553d 100644</span>
<span class="p_header">--- a/drivers/hv/connection.c</span>
<span class="p_header">+++ b/drivers/hv/connection.c</span>
<span class="p_chunk">@@ -152,8 +152,7 @@</span> <span class="p_context"> int vmbus_connect(void)</span>
 	 * Setup the vmbus event connection for channel interrupt
 	 * abstraction stuff
 	 */
<span class="p_del">-	vmbus_connection.int_page =</span>
<span class="p_del">-	(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO, 0);</span>
<span class="p_add">+	vmbus_connection.int_page = get_free_pages(GFP_KERNEL|__GFP_ZERO, 0);</span>
 	if (vmbus_connection.int_page == NULL) {
 		ret = -ENOMEM;
 		goto cleanup;
<span class="p_chunk">@@ -168,8 +167,8 @@</span> <span class="p_context"> int vmbus_connect(void)</span>
 	 * Setup the monitor notification facility. The 1st page for
 	 * parent-&gt;child and the 2nd page for child-&gt;parent
 	 */
<span class="p_del">-	vmbus_connection.monitor_pages[0] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);</span>
<span class="p_del">-	vmbus_connection.monitor_pages[1] = (void *)__get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);</span>
<span class="p_add">+	vmbus_connection.monitor_pages[0] = get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);</span>
<span class="p_add">+	vmbus_connection.monitor_pages[1] = get_free_pages((GFP_KERNEL|__GFP_ZERO), 0);</span>
 	if ((vmbus_connection.monitor_pages[0] == NULL) ||
 	    (vmbus_connection.monitor_pages[1] == NULL)) {
 		ret = -ENOMEM;
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">index ace59ca..a89b9d5 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> static int __init find_last_devid_acpi(struct acpi_table_header *table)</span>
  */
 static int __init alloc_command_buffer(struct amd_iommu *iommu)
 {
<span class="p_del">-	iommu-&gt;cmd_buf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	iommu-&gt;cmd_buf = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 						  get_order(CMD_BUFFER_SIZE));
 
 	return iommu-&gt;cmd_buf ? 0 : -ENOMEM;
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static void __init free_command_buffer(struct amd_iommu *iommu)</span>
 /* allocates the memory where the IOMMU will log its events to */
 static int __init alloc_event_buffer(struct amd_iommu *iommu)
 {
<span class="p_del">-	iommu-&gt;evt_buf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	iommu-&gt;evt_buf = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 						  get_order(EVT_BUFFER_SIZE));
 
 	return iommu-&gt;evt_buf ? 0 : -ENOMEM;
<span class="p_chunk">@@ -579,7 +579,7 @@</span> <span class="p_context"> static void __init free_event_buffer(struct amd_iommu *iommu)</span>
 /* allocates the memory where the IOMMU will log its events to */
 static int __init alloc_ppr_log(struct amd_iommu *iommu)
 {
<span class="p_del">-	iommu-&gt;ppr_log = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	iommu-&gt;ppr_log = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 						  get_order(PPR_LOG_SIZE));
 
 	return iommu-&gt;ppr_log ? 0 : -ENOMEM;
<span class="p_chunk">@@ -1833,7 +1833,7 @@</span> <span class="p_context"> static int __init early_amd_iommu_init(void)</span>
 
 	/* Device table - directly used by all IOMMUs */
 	ret = -ENOMEM;
<span class="p_del">-	amd_iommu_dev_table = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	amd_iommu_dev_table = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 				      get_order(dev_table_size));
 	if (amd_iommu_dev_table == NULL)
 		goto out;
<span class="p_chunk">@@ -1842,19 +1842,19 @@</span> <span class="p_context"> static int __init early_amd_iommu_init(void)</span>
 	 * Alias table - map PCI Bus/Dev/Func to Bus/Dev/Func the
 	 * IOMMU see for that device
 	 */
<span class="p_del">-	amd_iommu_alias_table = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+	amd_iommu_alias_table = get_free_pages(GFP_KERNEL,</span>
 			get_order(alias_table_size));
 	if (amd_iommu_alias_table == NULL)
 		goto out;
 
 	/* IOMMU rlookup table - find the IOMMU for a specific device */
<span class="p_del">-	amd_iommu_rlookup_table = (void *)__get_free_pages(</span>
<span class="p_add">+	amd_iommu_rlookup_table = get_free_pages(</span>
 			GFP_KERNEL | __GFP_ZERO,
 			get_order(rlookup_table_size));
 	if (amd_iommu_rlookup_table == NULL)
 		goto out;
 
<span class="p_del">-	amd_iommu_pd_alloc_bitmap = (void *)__get_free_pages(</span>
<span class="p_add">+	amd_iommu_pd_alloc_bitmap = get_free_pages(</span>
 					    GFP_KERNEL | __GFP_ZERO,
 					    get_order(MAX_DOMAIN_ID/8));
 	if (amd_iommu_pd_alloc_bitmap == NULL)
<span class="p_chunk">@@ -1898,7 +1898,7 @@</span> <span class="p_context"> static int __init early_amd_iommu_init(void)</span>
 		if (!amd_iommu_irq_cache)
 			goto out;
 
<span class="p_del">-		irq_lookup_table = (void *)__get_free_pages(</span>
<span class="p_add">+		irq_lookup_table = get_free_pages(</span>
 				GFP_KERNEL | __GFP_ZERO,
 				get_order(rlookup_table_size));
 		if (!irq_lookup_table)
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 828a316..6d376c8 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -669,11 +669,11 @@</span> <span class="p_context"> static struct iommu_domain *exynos_iommu_domain_alloc(unsigned type)</span>
 	if (!domain)
 		return NULL;
 
<span class="p_del">-	domain-&gt;pgtable = (sysmmu_pte_t *)__get_free_pages(GFP_KERNEL, 2);</span>
<span class="p_add">+	domain-&gt;pgtable = get_free_pages(GFP_KERNEL, 2);</span>
 	if (!domain-&gt;pgtable)
 		goto err_pgtable;
 
<span class="p_del">-	domain-&gt;lv2entcnt = (short *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
<span class="p_add">+	domain-&gt;lv2entcnt = get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
 	if (!domain-&gt;lv2entcnt)
 		goto err_counter;
 
<span class="p_header">diff --git a/drivers/iommu/msm_iommu.c b/drivers/iommu/msm_iommu.c</span>
<span class="p_header">index 01afc79..2d9f859 100644</span>
<span class="p_header">--- a/drivers/iommu/msm_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/msm_iommu.c</span>
<span class="p_chunk">@@ -227,8 +227,7 @@</span> <span class="p_context"> static struct iommu_domain *msm_iommu_domain_alloc(unsigned type)</span>
 		goto fail_nomem;
 
 	INIT_LIST_HEAD(&amp;priv-&gt;list_attached);
<span class="p_del">-	priv-&gt;pgtable = (unsigned long *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-							  get_order(SZ_16K));</span>
<span class="p_add">+	priv-&gt;pgtable = get_free_pages(GFP_KERNEL, get_order(SZ_16K));</span>
 
 	if (!priv-&gt;pgtable)
 		goto fail_nomem;
<span class="p_chunk">@@ -433,9 +432,8 @@</span> <span class="p_context"> static int msm_iommu_map(struct iommu_domain *domain, unsigned long va,</span>
 
 	/* Need a 2nd level table */
 	if ((len == SZ_4K || len == SZ_64K) &amp;&amp; (*fl_pte) == 0) {
<span class="p_del">-		unsigned long *sl;</span>
<span class="p_del">-		sl = (unsigned long *) __get_free_pages(GFP_ATOMIC,</span>
<span class="p_del">-							get_order(SZ_4K));</span>
<span class="p_add">+		unsigned long *sl = get_free_pages(GFP_ATOMIC,</span>
<span class="p_add">+						   get_order(SZ_4K));</span>
 
 		if (!sl) {
 			pr_debug(&quot;Could not allocate second level table\n&quot;);
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">index 2513a68..217765a 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_chunk">@@ -883,7 +883,7 @@</span> <span class="p_context"> static int its_alloc_tables(const char *node_name, struct its_node *its)</span>
 				node_name, order, alloc_pages);
 		}
 
<span class="p_del">-		base = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
<span class="p_add">+		base = get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
 		if (!base) {
 			err = -ENOMEM;
 			goto out_free;
<span class="p_header">diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.c</span>
<span class="p_header">index 3059674..22b8aaa 100644</span>
<span class="p_header">--- a/drivers/md/bcache/bset.c</span>
<span class="p_header">+++ b/drivers/md/bcache/bset.c</span>
<span class="p_chunk">@@ -315,19 +315,19 @@</span> <span class="p_context"> int bch_btree_keys_alloc(struct btree_keys *b, unsigned page_order, gfp_t gfp)</span>
 
 	b-&gt;page_order = page_order;
 
<span class="p_del">-	t-&gt;data = (void *) __get_free_pages(gfp, b-&gt;page_order);</span>
<span class="p_add">+	t-&gt;data = get_free_pages(gfp, b-&gt;page_order);</span>
 	if (!t-&gt;data)
 		goto err;
 
 	t-&gt;tree = bset_tree_bytes(b) &lt; PAGE_SIZE
 		? kmalloc(bset_tree_bytes(b), gfp)
<span class="p_del">-		: (void *) __get_free_pages(gfp, get_order(bset_tree_bytes(b)));</span>
<span class="p_add">+		: get_free_pages(gfp, get_order(bset_tree_bytes(b)));</span>
 	if (!t-&gt;tree)
 		goto err;
 
 	t-&gt;prev = bset_prev_bytes(b) &lt; PAGE_SIZE
 		? kmalloc(bset_prev_bytes(b), gfp)
<span class="p_del">-		: (void *) __get_free_pages(gfp, get_order(bset_prev_bytes(b)));</span>
<span class="p_add">+		: get_free_pages(gfp, get_order(bset_prev_bytes(b)));</span>
 	if (!t-&gt;prev)
 		goto err;
 
<span class="p_chunk">@@ -1180,7 +1180,7 @@</span> <span class="p_context"> static void __btree_sort(struct btree_keys *b, struct btree_iter *iter,</span>
 {
 	uint64_t start_time;
 	bool used_mempool = false;
<span class="p_del">-	struct bset *out = (void *) __get_free_pages(__GFP_NOWARN|GFP_NOWAIT,</span>
<span class="p_add">+	struct bset *out = get_free_pages(__GFP_NOWARN|GFP_NOWAIT,</span>
 						     order);
 	if (!out) {
 		struct page *outp;
<span class="p_header">diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.c</span>
<span class="p_header">index 1540114..9499bfb 100644</span>
<span class="p_header">--- a/drivers/md/bcache/btree.c</span>
<span class="p_header">+++ b/drivers/md/bcache/btree.c</span>
<span class="p_chunk">@@ -792,8 +792,7 @@</span> <span class="p_context"> int bch_btree_cache_alloc(struct cache_set *c)</span>
 #ifdef CONFIG_BCACHE_DEBUG
 	mutex_init(&amp;c-&gt;verify_lock);
 
<span class="p_del">-	c-&gt;verify_ondisk = (void *)</span>
<span class="p_del">-		__get_free_pages(GFP_KERNEL, ilog2(bucket_pages(c)));</span>
<span class="p_add">+	c-&gt;verify_ondisk = get_free_pages(GFP_KERNEL, ilog2(bucket_pages(c)));</span>
 
 	c-&gt;verify_data = mca_bucket_alloc(c, &amp;ZERO_KEY, GFP_KERNEL);
 
<span class="p_header">diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c</span>
<span class="p_header">index 6ed9533..813def6 100644</span>
<span class="p_header">--- a/drivers/md/bcache/journal.c</span>
<span class="p_header">+++ b/drivers/md/bcache/journal.c</span>
<span class="p_chunk">@@ -815,8 +815,8 @@</span> <span class="p_context"> int bch_journal_alloc(struct cache_set *c)</span>
 	j-&gt;w[1].c = c;
 
 	if (!(init_fifo(&amp;j-&gt;pin, JOURNAL_PIN, GFP_KERNEL)) ||
<span class="p_del">-	    !(j-&gt;w[0].data = (void *) __get_free_pages(GFP_KERNEL, JSET_BITS)) ||</span>
<span class="p_del">-	    !(j-&gt;w[1].data = (void *) __get_free_pages(GFP_KERNEL, JSET_BITS)))</span>
<span class="p_add">+	    !(j-&gt;w[0].data = get_free_pages(GFP_KERNEL, JSET_BITS)) ||</span>
<span class="p_add">+	    !(j-&gt;w[1].data = get_free_pages(GFP_KERNEL, JSET_BITS)))</span>
 		return -ENOMEM;
 
 	return 0;
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index cd04e2d..2fb3624 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1431,7 +1431,7 @@</span> <span class="p_context"> void bch_cache_set_unregister(struct cache_set *c)</span>
 }
 
 #define alloc_bucket_pages(gfp, c)			\
<span class="p_del">-	((void *) __get_free_pages(__GFP_ZERO|gfp, ilog2(bucket_pages(c))))</span>
<span class="p_add">+	(get_free_pages(__GFP_ZERO|gfp, ilog2(bucket_pages(c))))</span>
 
 struct cache_set *bch_cache_set_alloc(struct cache_sb *sb)
 {
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index 10f8a45..f2aae7e 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -380,8 +380,7 @@</span> <span class="p_context"> static void *alloc_buffer_data(struct dm_bufio_client *c, gfp_t gfp_mask,</span>
 	if (c-&gt;block_size &lt;= DM_BUFIO_BLOCK_SIZE_GFP_LIMIT &amp;&amp;
 	    gfp_mask &amp; __GFP_NORETRY) {
 		*data_mode = DATA_MODE_GET_FREE_PAGES;
<span class="p_del">-		return (void *)__get_free_pages(gfp_mask,</span>
<span class="p_del">-						c-&gt;pages_per_block_bits);</span>
<span class="p_add">+		return get_free_pages(gfp_mask, c-&gt;pages_per_block_bits);</span>
 	}
 
 	*data_mode = DATA_MODE_VMALLOC;
<span class="p_header">diff --git a/drivers/media/pci/solo6x10/solo6x10-p2m.c b/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_header">index ef91be9..85bdeac 100644</span>
<span class="p_header">--- a/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_header">+++ b/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_chunk">@@ -221,11 +221,11 @@</span> <span class="p_context"> static int solo_p2m_test(struct solo_dev *solo_dev, int base, int size)</span>
 	int ret = -EIO;
 	int order = get_order(size);
 
<span class="p_del">-	wr_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	wr_buf = get_free_pages(GFP_KERNEL, order);</span>
 	if (wr_buf == NULL)
 		return -1;
 
<span class="p_del">-	rd_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	rd_buf = get_free_pages(GFP_KERNEL, order);</span>
 	if (rd_buf == NULL) {
 		free_pages(wr_buf, order);
 		return -1;
<span class="p_header">diff --git a/drivers/media/platform/davinci/dm644x_ccdc.c b/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_header">index 42df06f..f816042 100644</span>
<span class="p_header">--- a/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_header">+++ b/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_chunk">@@ -268,8 +268,7 @@</span> <span class="p_context"> static int ccdc_update_raw_params(struct ccdc_config_params_raw *raw_params)</span>
 		}
 
 		/* Allocate memory for FPC table */
<span class="p_del">-		fpc_virtaddr =</span>
<span class="p_del">-			(unsigned int *)__get_free_pages(GFP_KERNEL | GFP_DMA,</span>
<span class="p_add">+		fpc_virtaddr = get_free_pages(GFP_KERNEL | GFP_DMA,</span>
 							 get_order(raw_params-&gt;
 							 fault_pxl.fp_num *
 							 FP_NUM_BYTES));
<span class="p_header">diff --git a/drivers/misc/cxl/native.c b/drivers/misc/cxl/native.c</span>
<span class="p_header">index 4620627..6ff5696 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/native.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/native.c</span>
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> int cxl_alloc_spa(struct cxl_afu *afu)</span>
 
 	WARN_ON(afu-&gt;spa_size &gt; 0x100000); /* Max size supported by the hardware */
 
<span class="p_del">-	if (!(afu-&gt;spa = (struct cxl_process_element *)</span>
<span class="p_del">-	      __get_free_pages(GFP_KERNEL | __GFP_ZERO, afu-&gt;spa_order))) {</span>
<span class="p_add">+	if (!(afu-&gt;spa = </span>
<span class="p_add">+	      get_free_pages(GFP_KERNEL | __GFP_ZERO, afu-&gt;spa_order))) {</span>
 		pr_err(&quot;cxl_alloc_spa: Unable to allocate scheduled process area\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/drivers/misc/mic/card/mic_virtio.c b/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_header">index bb364ee..19e5731 100644</span>
<span class="p_header">--- a/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_header">+++ b/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static struct virtqueue *mic_find_vq(struct virtio_device *vdev,</span>
 	mvdev-&gt;used_size[index] = PAGE_ALIGN(sizeof(__u16) * 3 +
 					     sizeof(struct vring_used_elem) *
 					     le16_to_cpu(config.num));
<span class="p_del">-	used = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	used = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					get_order(mvdev-&gt;used_size[index]));
 	if (!used) {
 		err = -ENOMEM;
<span class="p_header">diff --git a/drivers/misc/mic/host/mic_virtio.c b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">index 3474aa2..253c525 100644</span>
<span class="p_header">--- a/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">+++ b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_chunk">@@ -649,8 +649,7 @@</span> <span class="p_context"> int mic_virtio_add_device(struct mic_vdev *mvdev,</span>
 		mutex_init(&amp;mvr-&gt;vr_mutex);
 		vr_size = PAGE_ALIGN(vring_size(num, MIC_VIRTIO_RING_ALIGN) +
 			sizeof(struct _mic_vring_info));
<span class="p_del">-		vr-&gt;va = (void *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+		vr-&gt;va = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					 get_order(vr_size));
 		if (!vr-&gt;va) {
 			ret = -ENOMEM;
<span class="p_chunk">@@ -688,7 +687,7 @@</span> <span class="p_context"> int mic_virtio_add_device(struct mic_vdev *mvdev,</span>
 		dev_dbg(&amp;mdev-&gt;pdev-&gt;dev,
 			&quot;%s %d index %d va %p info %p vr_size 0x%x\n&quot;,
 			__func__, __LINE__, i, vr-&gt;va, vr-&gt;info, vr_size);
<span class="p_del">-		mvr-&gt;buf = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		mvr-&gt;buf = get_free_pages(GFP_KERNEL,</span>
 					get_order(MIC_INT_DMA_BUF_SIZE));
 		mvr-&gt;buf_da = mic_map_single(mvdev-&gt;mdev, mvr-&gt;buf,
 					  MIC_INT_DMA_BUF_SIZE);
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rma.h b/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_header">index e13ab83..020073e 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_chunk">@@ -402,7 +402,7 @@</span> <span class="p_context"> static inline void *scif_zalloc(size_t size)</span>
 	size_t align = ALIGN(size, PAGE_SIZE);
 
 	if (align &amp;&amp; get_order(align) &lt; MAX_ORDER)
<span class="p_del">-		ret = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+		ret = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					       get_order(align));
 	return ret ? ret : vzalloc(align);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/cavium/liquidio/octeon_main.h b/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_header">index b6a90a9..e053e4a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_chunk">@@ -136,9 +136,7 @@</span> <span class="p_context"> cnnic_alloc_aligned_dma(struct pci_dev *pci_dev,</span>
 
 #define OCTEON_MAX_ALLOC_RETRIES     1
 	do {
<span class="p_del">-		ptr =</span>
<span class="p_del">-		    (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-					     get_order(size));</span>
<span class="p_add">+		ptr = get_free_pages(GFP_KERNEL, get_order(size));</span>
 		retries++;
 	} while ((retries &lt;= OCTEON_MAX_ALLOC_RETRIES) &amp;&amp; !ptr);
 
<span class="p_header">diff --git a/drivers/net/ethernet/sgi/ioc3-eth.c b/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_header">index e314d3f..6a256b1 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_chunk">@@ -932,7 +932,7 @@</span> <span class="p_context"> static void ioc3_alloc_rings(struct net_device *dev)</span>
 
 	if (ip-&gt;txr == NULL) {
 		/* Allocate and initialize tx rings.  16kb = 128 bufs.  */
<span class="p_del">-		ip-&gt;txr = (struct ioc3_etxd *)__get_free_pages(GFP_KERNEL, 2);</span>
<span class="p_add">+		ip-&gt;txr = get_free_pages(GFP_KERNEL, 2);</span>
 		if (!ip-&gt;txr)
 			printk(&quot;ioc3_alloc_rings(): __get_free_pages() failed!\n&quot;);
 		ip-&gt;tx_pi = 0;
<span class="p_header">diff --git a/drivers/net/irda/au1k_ir.c b/drivers/net/irda/au1k_ir.c</span>
<span class="p_header">index 6095cf4..ec4b640 100644</span>
<span class="p_header">--- a/drivers/net/irda/au1k_ir.c</span>
<span class="p_header">+++ b/drivers/net/irda/au1k_ir.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static void *dma_alloc(size_t size, dma_addr_t *dma_handle)</span>
 	void *ret;
 	int gfp = GFP_ATOMIC | GFP_DMA;
 
<span class="p_del">-	ret = (void *)__get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(gfp, get_order(size));</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c</span>
<span class="p_header">index d0c1b13..2d060ff 100644</span>
<span class="p_header">--- a/drivers/net/rionet.c</span>
<span class="p_header">+++ b/drivers/net/rionet.c</span>
<span class="p_chunk">@@ -467,7 +467,7 @@</span> <span class="p_context"> static int rionet_setup_netdev(struct rio_mport *mport, struct net_device *ndev)</span>
 	const size_t rionet_active_bytes = sizeof(void *) *
 				RIO_MAX_ROUTE_ENTRIES(mport-&gt;sys_size);
 
<span class="p_del">-	nets[mport-&gt;id].active = (struct rio_dev **)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+	nets[mport-&gt;id].active = get_free_pages(GFP_KERNEL,</span>
 						get_order(rionet_active_bytes));
 	if (!nets[mport-&gt;id].active) {
 		rc = -ENOMEM;
<span class="p_header">diff --git a/drivers/net/wireless/b43/debugfs.c b/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_header">index 50a2316..844e290 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_chunk">@@ -532,7 +532,7 @@</span> <span class="p_context"> static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,</span>
 	dfile = fops_to_dfs_file(dev, dfops);
 
 	if (!dfile-&gt;buffer) {
<span class="p_del">-		buf = (char *)__get_free_pages(GFP_KERNEL, buforder);</span>
<span class="p_add">+		buf = get_free_pages(GFP_KERNEL, buforder);</span>
 		if (!buf) {
 			err = -ENOMEM;
 			goto out_unlock;
<span class="p_header">diff --git a/drivers/net/wireless/b43legacy/debugfs.c b/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_header">index e243955..371ece0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,</span>
 	dfile = fops_to_dfs_file(dev, dfops);
 
 	if (!dfile-&gt;buffer) {
<span class="p_del">-		buf = (char *)__get_free_pages(GFP_KERNEL, buforder);</span>
<span class="p_add">+		buf = get_free_pages(GFP_KERNEL, buforder);</span>
 		if (!buf) {
 			err = -ENOMEM;
 			goto out_unlock;
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_header">index 374adb1..ec979ba 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_chunk">@@ -6309,7 +6309,7 @@</span> <span class="p_context"> struct ieee80211_hw *wlcore_alloc_hw(size_t priv_size, u32 aggr_buf_size,</span>
 	init_completion(&amp;wl-&gt;nvs_loading_complete);
 
 	order = get_order(aggr_buf_size);
<span class="p_del">-	wl-&gt;aggr_buf = (u8 *)__get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	wl-&gt;aggr_buf = get_free_pages(GFP_KERNEL, order);</span>
 	if (!wl-&gt;aggr_buf) {
 		ret = -ENOMEM;
 		goto err_wq;
<span class="p_header">diff --git a/drivers/parisc/ccio-dma.c b/drivers/parisc/ccio-dma.c</span>
<span class="p_header">index b172617..633c6d4 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-dma.c</span>
<span class="p_chunk">@@ -847,7 +847,7 @@</span> <span class="p_context"> ccio_alloc_consistent(struct device *dev, size_t size, dma_addr_t *dma_handle, g</span>
 		return 0;
 	}
 #endif
<span class="p_del">-        ret = (void *) __get_free_pages(flag, get_order(size));</span>
<span class="p_add">+        ret = get_free_pages(flag, get_order(size));</span>
 
 	if (ret) {
 		memset(ret, 0, size);
<span class="p_chunk">@@ -1299,8 +1299,7 @@</span> <span class="p_context"> ccio_ioc_init(struct ioc *ioc)</span>
 			iova_space_size&gt;&gt;20,
 			iov_order + PAGE_SHIFT);
 
<span class="p_del">-	ioc-&gt;pdir_base = (u64 *)__get_free_pages(GFP_KERNEL, </span>
<span class="p_del">-						 get_order(ioc-&gt;pdir_size));</span>
<span class="p_add">+	ioc-&gt;pdir_base = get_free_pages(GFP_KERNEL, get_order(ioc-&gt;pdir_size));</span>
 	if(NULL == ioc-&gt;pdir_base) {
 		panic(&quot;%s() could not allocate I/O Page Table\n&quot;, __func__);
 	}
<span class="p_chunk">@@ -1313,8 +1312,7 @@</span> <span class="p_context"> ccio_ioc_init(struct ioc *ioc)</span>
  	ioc-&gt;res_size = (ioc-&gt;pdir_size / sizeof(u64)) &gt;&gt; 3;
 	DBG_INIT(&quot;%s() res_size 0x%x\n&quot;, __func__, ioc-&gt;res_size);
 	
<span class="p_del">-	ioc-&gt;res_map = (u8 *)__get_free_pages(GFP_KERNEL, </span>
<span class="p_del">-					      get_order(ioc-&gt;res_size));</span>
<span class="p_add">+	ioc-&gt;res_map = get_free_pages(GFP_KERNEL, get_order(ioc-&gt;res_size));</span>
 	if(NULL == ioc-&gt;res_map) {
 		panic(&quot;%s() could not allocate resource map\n&quot;, __func__);
 	}
<span class="p_header">diff --git a/drivers/parisc/ccio-rm-dma.c b/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_header">index b9649c2..e4239f8 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static void *ccio_alloc_consistent(struct pci_dev *dev, size_t size,</span>
 {
 	void *ret;
 	
<span class="p_del">-	ret = (void *)__get_free_pages(GFP_ATOMIC, get_order(size));</span>
<span class="p_add">+	ret = get_free_pages(GFP_ATOMIC, get_order(size));</span>
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
<span class="p_header">diff --git a/drivers/parisc/sba_iommu.c b/drivers/parisc/sba_iommu.c</span>
<span class="p_header">index 6066d4e..10ca71d 100644</span>
<span class="p_header">--- a/drivers/parisc/sba_iommu.c</span>
<span class="p_header">+++ b/drivers/parisc/sba_iommu.c</span>
<span class="p_chunk">@@ -876,7 +876,7 @@</span> <span class="p_context"> static void *sba_alloc_consistent(struct device *hwdev, size_t size,</span>
 		return NULL;
 	}
 
<span class="p_del">-        ret = (void *) __get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+        ret = get_free_pages(gfp, get_order(size));</span>
 
 	if (ret) {
 		memset(ret, 0, size);
<span class="p_chunk">@@ -1283,8 +1283,7 @@</span> <span class="p_context"> sba_ioc_init_pluto(struct parisc_device *sba, struct ioc *ioc, int ioc_num)</span>
 		__func__, ioc-&gt;ioc_hpa, iova_space_size &gt;&gt; 20,
 		iov_order + PAGE_SHIFT);
 
<span class="p_del">-	ioc-&gt;pdir_base = (void *) __get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-						   get_order(ioc-&gt;pdir_size));</span>
<span class="p_add">+	ioc-&gt;pdir_base = get_free_pages(GFP_KERNEL, get_order(ioc-&gt;pdir_size));</span>
 	if (!ioc-&gt;pdir_base)
 		panic(&quot;Couldn&#39;t allocate I/O Page Table\n&quot;);
 
<span class="p_chunk">@@ -1697,7 +1696,7 @@</span> <span class="p_context"> sba_common_init(struct sba_device *sba_dev)</span>
 			__func__, res_size);
 
 		sba_dev-&gt;ioc[i].res_size = res_size;
<span class="p_del">-		sba_dev-&gt;ioc[i].res_map = (char *) __get_free_pages(GFP_KERNEL, get_order(res_size));</span>
<span class="p_add">+		sba_dev-&gt;ioc[i].res_map = get_free_pages(GFP_KERNEL, get_order(res_size));</span>
 
 #ifdef DEBUG_DMB_TRAP
 		iterate_pages( sba_dev-&gt;ioc[i].res_map, res_size,
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index ba7fc9e..9d12ce1 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -1296,7 +1296,7 @@</span> <span class="p_context"> static int tegra_pcie_enable_msi(struct tegra_pcie *pcie)</span>
 	}
 
 	/* setup AFI/FPCI range */
<span class="p_del">-	msi-&gt;pages = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	msi-&gt;pages = get_free_pages(GFP_KERNEL, 0);</span>
 	base = virt_to_phys(msi-&gt;pages);
 
 	afi_writel(pcie, base &gt;&gt; soc-&gt;msi_base_shift, AFI_MSI_FPCI_BAR_ST);
<span class="p_header">diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">index 769fc9d..a46c493 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-designware.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> void dw_pcie_msi_init(struct pcie_port *pp)</span>
 {
 	u64 msi_target;
 
<span class="p_del">-	pp-&gt;msi_data = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	pp-&gt;msi_data = get_free_pages(GFP_KERNEL, 0);</span>
 	msi_target = virt_to_phys(pp-&gt;msi_data);
 
 	/* program the msi_data */
<span class="p_header">diff --git a/drivers/pci/host/pcie-rcar.c b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">index fdeb72f..1cf7746 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_chunk">@@ -734,7 +734,7 @@</span> <span class="p_context"> static int rcar_pcie_enable_msi(struct rcar_pcie *pcie)</span>
 	}
 
 	/* setup MSI data target */
<span class="p_del">-	msi-&gt;pages = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	msi-&gt;pages = get_free_pages(GFP_KERNEL, 0);</span>
 	base = virt_to_phys(msi-&gt;pages);
 
 	rcar_pci_write_reg(pcie, base | MSIFE, PCIEMSIALR);
<span class="p_header">diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">index 3cc679d..a31938b 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static void xilinx_pcie_enable_msi(struct xilinx_pcie_port *port)</span>
 {
 	phys_addr_t msg_addr;
 
<span class="p_del">-	port-&gt;msi_pages = (void *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	port-&gt;msi_pages = get_free_pages(GFP_KERNEL, 0);</span>
 	msg_addr = virt_to_phys(port-&gt;msi_pages);
 	pcie_write(port, 0x0, XILINX_PCIE_REG_MSIBASE1);
 	pcie_write(port, msg_addr, XILINX_PCIE_REG_MSIBASE2);
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 7b24131..ddab935 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> struct dasd_device *dasd_alloc_device(void)</span>
 		return ERR_PTR(-ENOMEM);
 
 	/* Get two pages for normal block device operations. */
<span class="p_del">-	device-&gt;ccw_mem = (void *) __get_free_pages(GFP_ATOMIC | GFP_DMA, 1);</span>
<span class="p_add">+	device-&gt;ccw_mem = get_free_pages(GFP_ATOMIC | GFP_DMA, 1);</span>
 	if (!device-&gt;ccw_mem) {
 		kfree(device);
 		return ERR_PTR(-ENOMEM);
<span class="p_header">diff --git a/drivers/s390/char/hmcdrv_cache.c b/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_header">index 60a4233..98f049b 100644</span>
<span class="p_header">--- a/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_header">+++ b/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> int hmcdrv_cache_startup(size_t cachesize)</span>
 	if (cachesize &gt; 0) { /* perform caching ? */
 		hmcdrv_cache_order = get_order(cachesize);
 		hmcdrv_cache_file.content =
<span class="p_del">-			(void *) __get_free_pages(GFP_KERNEL | GFP_DMA,</span>
<span class="p_add">+			get_free_pages(GFP_KERNEL | GFP_DMA,</span>
 						  hmcdrv_cache_order);
 
 		if (!hmcdrv_cache_file.content) {
<span class="p_header">diff --git a/drivers/s390/char/hmcdrv_ftp.c b/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_header">index c08e633..0ee0827 100644</span>
<span class="p_header">--- a/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_header">+++ b/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> ssize_t hmcdrv_ftp_cmd(char __kernel *cmd, loff_t offset,</span>
 		return retlen;
 
 	order = get_order(ftp.len);
<span class="p_del">-	ftp.buf = (void *) __get_free_pages(GFP_KERNEL | GFP_DMA, order);</span>
<span class="p_add">+	ftp.buf = get_free_pages(GFP_KERNEL | GFP_DMA, order);</span>
 
 	if (!ftp.buf)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/s390/char/tty3270.c b/drivers/s390/char/tty3270.c</span>
<span class="p_header">index bb61f97..f5c9599 100644</span>
<span class="p_header">--- a/drivers/s390/char/tty3270.c</span>
<span class="p_header">+++ b/drivers/s390/char/tty3270.c</span>
<span class="p_chunk">@@ -690,8 +690,8 @@</span> <span class="p_context"> tty3270_alloc_view(void)</span>
 	tp-&gt;rcl_max = 20;
 
 	for (pages = 0; pages &lt; TTY3270_STRING_PAGES; pages++) {
<span class="p_del">-		tp-&gt;freemem_pages[pages] = (void *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL|GFP_DMA, 0);</span>
<span class="p_add">+		tp-&gt;freemem_pages[pages] = </span>
<span class="p_add">+			get_free_pages(GFP_KERNEL|GFP_DMA, 0);</span>
 		if (!tp-&gt;freemem_pages[pages])
 			goto out_pages;
 		add_string_memory(&amp;tp-&gt;freemem,
<span class="p_header">diff --git a/drivers/s390/char/vmcp.c b/drivers/s390/char/vmcp.c</span>
<span class="p_header">index f73bf6b..fea0a72 100644</span>
<span class="p_header">--- a/drivers/s390/char/vmcp.c</span>
<span class="p_header">+++ b/drivers/s390/char/vmcp.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> vmcp_write(struct file *file, const char __user *buff, size_t count,</span>
 		return -ERESTARTSYS;
 	}
 	if (!session-&gt;response)
<span class="p_del">-		session-&gt;response = (char *)__get_free_pages(GFP_KERNEL</span>
<span class="p_add">+		session-&gt;response = get_free_pages(GFP_KERNEL</span>
 						| __GFP_REPEAT | GFP_DMA,
 						get_order(session-&gt;bufsize));
 	if (!session-&gt;response) {
<span class="p_header">diff --git a/drivers/s390/cio/cmf.c b/drivers/s390/cio/cmf.c</span>
<span class="p_header">index 70356a3..6ee6ad6 100644</span>
<span class="p_header">--- a/drivers/s390/cio/cmf.c</span>
<span class="p_header">+++ b/drivers/s390/cio/cmf.c</span>
<span class="p_chunk">@@ -572,7 +572,7 @@</span> <span class="p_context"> static int alloc_cmb(struct ccw_device *cdev)</span>
 		WARN_ON(!list_empty(&amp;cmb_area.list));
 
 		spin_unlock(&amp;cmb_area.lock);
<span class="p_del">-		mem = (void*)__get_free_pages(GFP_KERNEL | GFP_DMA,</span>
<span class="p_add">+		mem = get_free_pages(GFP_KERNEL | GFP_DMA,</span>
 				 get_order(size));
 		spin_lock(&amp;cmb_area.lock);
 
<span class="p_header">diff --git a/drivers/scsi/cxlflash/main.c b/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">index d4d6e38..ff85994 100644</span>
<span class="p_header">--- a/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">+++ b/drivers/scsi/cxlflash/main.c</span>
<span class="p_chunk">@@ -763,7 +763,7 @@</span> <span class="p_context"> static int alloc_mem(struct cxlflash_cfg *cfg)</span>
 	struct device *dev = &amp;cfg-&gt;dev-&gt;dev;
 
 	/* AFU is ~12k, i.e. only one 64k page or up to four 4k pages */
<span class="p_del">-	cfg-&gt;afu = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	cfg-&gt;afu = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					    get_order(sizeof(struct afu)));
 	if (unlikely(!cfg-&gt;afu)) {
 		dev_err(dev, &quot;%s: cannot get %d free pages\n&quot;,
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index d03ab52..4513104 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -2912,8 +2912,7 @@</span> <span class="p_context"> iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,</span>
 	}
 	spin_unlock_bh(&amp;session-&gt;frwd_lock);
 
<span class="p_del">-	data = (char *) __get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-					 get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));</span>
<span class="p_add">+	data = get_free_pages(GFP_KERNEL, get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));</span>
 	if (!data)
 		goto login_task_data_alloc_fail;
 	conn-&gt;login_task-&gt;data = conn-&gt;data = data;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index 4d9457b..5447150 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -6233,8 +6233,7 @@</span> <span class="p_context"> lpfc_setup_bg(struct lpfc_hba *phba, struct Scsi_Host *shost)</span>
 	if (!_dump_buf_data) {
 		while (pagecnt) {
 			spin_lock_init(&amp;_dump_buf_lock);
<span class="p_del">-			_dump_buf_data =</span>
<span class="p_del">-				(char *) __get_free_pages(GFP_KERNEL, pagecnt);</span>
<span class="p_add">+			_dump_buf_data = get_free_pages(GFP_KERNEL, pagecnt);</span>
 			if (_dump_buf_data) {
 				lpfc_printf_log(phba, KERN_ERR, LOG_BG,
 					&quot;9043 BLKGRD: allocated %d pages for &quot;
<span class="p_chunk">@@ -6257,8 +6256,7 @@</span> <span class="p_context"> lpfc_setup_bg(struct lpfc_hba *phba, struct Scsi_Host *shost)</span>
 		       &quot;\n&quot;, _dump_buf_data);
 	if (!_dump_buf_dif) {
 		while (pagecnt) {
<span class="p_del">-			_dump_buf_dif =</span>
<span class="p_del">-				(char *) __get_free_pages(GFP_KERNEL, pagecnt);</span>
<span class="p_add">+			_dump_buf_dif = get_free_pages(GFP_KERNEL, pagecnt);</span>
 			if (_dump_buf_dif) {
 				lpfc_printf_log(phba, KERN_ERR, LOG_BG,
 					&quot;9046 BLKGRD: allocated %d pages for &quot;
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 2c81ab3..56710df 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -5382,7 +5382,7 @@</span> <span class="p_context"> static int megasas_probe_one(struct pci_dev *pdev,</span>
 	{
 		instance-&gt;ctrl_context_pages =
 			get_order(sizeof(struct fusion_context));
<span class="p_del">-		instance-&gt;ctrl_context = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		instance-&gt;ctrl_context = get_free_pages(GFP_KERNEL,</span>
 				instance-&gt;ctrl_context_pages);
 		if (!instance-&gt;ctrl_context) {
 			dev_printk(KERN_DEBUG, &amp;pdev-&gt;dev, &quot;Failed to allocate &quot;
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 6429914..f11c3b7 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -1186,7 +1186,7 @@</span> <span class="p_context"> megasas_init_adapter_fusion(struct megasas_instance *instance)</span>
 	fusion-&gt;drv_map_pages = get_order(fusion-&gt;drv_map_sz);
 	for (i = 0; i &lt; 2; i++) {
 		fusion-&gt;ld_map[i] = NULL;
<span class="p_del">-		fusion-&gt;ld_drv_map[i] = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		fusion-&gt;ld_drv_map[i] = get_free_pages(GFP_KERNEL,</span>
 			fusion-&gt;drv_map_pages);
 		if (!fusion-&gt;ld_drv_map[i]) {
 			dev_err(&amp;instance-&gt;pdev-&gt;dev, &quot;Could not allocate &quot;
<span class="p_chunk">@@ -2462,7 +2462,7 @@</span> <span class="p_context"> megasas_alloc_host_crash_buffer(struct megasas_instance *instance)</span>
 
 	instance-&gt;crash_buf_pages = get_order(CRASH_DMA_BUF_SIZE);
 	for (i = 0; i &lt; MAX_CRASH_DUMP_SIZE; i++) {
<span class="p_del">-		instance-&gt;crash_buf[i] = (void	*)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+		instance-&gt;crash_buf[i] = get_free_pages(GFP_KERNEL,</span>
 				instance-&gt;crash_buf_pages);
 		if (!instance-&gt;crash_buf[i]) {
 			dev_info(&amp;instance-&gt;pdev-&gt;dev, &quot;Firmware crash dump &quot;
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">index 0d73ea3..13e893a 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_chunk">@@ -3386,7 +3386,7 @@</span> <span class="p_context"> _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)</span>
 
 	sz = ioc-&gt;scsiio_depth * sizeof(struct scsiio_tracker);
 	ioc-&gt;scsi_lookup_pages = get_order(sz);
<span class="p_del">-	ioc-&gt;scsi_lookup = (struct scsiio_tracker *)__get_free_pages(</span>
<span class="p_add">+	ioc-&gt;scsi_lookup = get_free_pages(</span>
 	    GFP_KERNEL, ioc-&gt;scsi_lookup_pages);
 	if (!ioc-&gt;scsi_lookup) {
 		pr_err(MPT3SAS_FMT &quot;scsi_lookup: get_free_pages failed, sz(%d)\n&quot;,
<span class="p_chunk">@@ -3400,8 +3400,7 @@</span> <span class="p_context"> _base_allocate_memory_pools(struct MPT3SAS_ADAPTER *ioc,  int sleep_flag)</span>
 	ioc-&gt;chain_depth = min_t(u32, ioc-&gt;chain_depth, MAX_CHAIN_DEPTH);
 	sz = ioc-&gt;chain_depth * sizeof(struct chain_tracker);
 	ioc-&gt;chain_pages = get_order(sz);
<span class="p_del">-	ioc-&gt;chain_lookup = (struct chain_tracker *)__get_free_pages(</span>
<span class="p_del">-	    GFP_KERNEL, ioc-&gt;chain_pages);</span>
<span class="p_add">+	ioc-&gt;chain_lookup = get_free_pages(GFP_KERNEL, ioc-&gt;chain_pages);</span>
 	if (!ioc-&gt;chain_lookup) {
 		pr_err(MPT3SAS_FMT &quot;chain_lookup: __get_free_pages failed\n&quot;,
 			ioc-&gt;name);
<span class="p_header">diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_header">index 45f9ac2..6c0161e 100644</span>
<span class="p_header">--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_header">+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_chunk">@@ -1123,7 +1123,7 @@</span> <span class="p_context"> bad:</span>
  */
 
 #define sym_get_mem_cluster()	\
<span class="p_del">-	(void *) __get_free_pages(GFP_ATOMIC, SYM_MEM_PAGE_ORDER)</span>
<span class="p_add">+	get_free_pages(GFP_ATOMIC, SYM_MEM_PAGE_ORDER)</span>
 #define sym_free_mem_cluster(p)	\
 	free_pages(p, SYM_MEM_PAGE_ORDER)
 
<span class="p_header">diff --git a/drivers/scsi/vmw_pvscsi.c b/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_header">index 7921fc8..16467b53 100644</span>
<span class="p_header">--- a/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_chunk">@@ -1251,8 +1251,7 @@</span> <span class="p_context"> static int pvscsi_allocate_sg(struct pvscsi_adapter *adapter)</span>
 	BUILD_BUG_ON(sizeof(struct pvscsi_sg_list) &gt; SGL_SIZE);
 
 	for (i = 0; i &lt; adapter-&gt;req_depth; ++i, ++ctx) {
<span class="p_del">-		ctx-&gt;sgl = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-						    get_order(SGL_SIZE));</span>
<span class="p_add">+		ctx-&gt;sgl = get_free_pages(GFP_KERNEL, get_order(SGL_SIZE));</span>
 		ctx-&gt;sglPA = 0;
 		BUG_ON(!IS_ALIGNED(((unsigned long)ctx-&gt;sgl), PAGE_SIZE));
 		if (!ctx-&gt;sgl) {
<span class="p_header">diff --git a/drivers/sh/maple/maple.c b/drivers/sh/maple/maple.c</span>
<span class="p_header">index 84fa4f7..4495a56 100644</span>
<span class="p_header">--- a/drivers/sh/maple/maple.c</span>
<span class="p_header">+++ b/drivers/sh/maple/maple.c</span>
<span class="p_chunk">@@ -738,8 +738,7 @@</span> <span class="p_context"> static int maple_set_vblank_interrupt_handler(void)</span>
 
 static int maple_get_dma_buffer(void)
 {
<span class="p_del">-	maple_sendbuf =</span>
<span class="p_del">-	    (void *) __get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	maple_sendbuf = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 				      MAPLE_DMA_PAGES);
 	if (!maple_sendbuf)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c</span>
<span class="p_header">index b741639..3163ae4 100644</span>
<span class="p_header">--- a/drivers/usb/core/devices.c</span>
<span class="p_header">+++ b/drivers/usb/core/devices.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 		return 0;
 	/* allocate 2^1 pages = 8K (on i386);
 	 * should be more than enough for one device */
<span class="p_del">-	pages_start = (char *)__get_free_pages(GFP_NOIO, 1);</span>
<span class="p_add">+	pages_start = get_free_pages(GFP_NOIO, 1);</span>
 	if (!pages_start)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/video/fbdev/fb-puv3.c b/drivers/video/fbdev/fb-puv3.c</span>
<span class="p_header">index 88fa2e7..e6dfba5 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/fb-puv3.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/fb-puv3.c</span>
<span class="p_chunk">@@ -671,7 +671,7 @@</span> <span class="p_context"> static int unifb_probe(struct platform_device *dev)</span>
 	struct resource *iomem;
 	void *videomemory;
 
<span class="p_del">-	videomemory = (void *)__get_free_pages(GFP_KERNEL | __GFP_COMP,</span>
<span class="p_add">+	videomemory = get_free_pages(GFP_KERNEL | __GFP_COMP,</span>
 				get_order(UNIFB_MEMSIZE));
 	if (!videomemory)
 		goto err;
<span class="p_header">diff --git a/drivers/video/fbdev/ssd1307fb.c b/drivers/video/fbdev/ssd1307fb.c</span>
<span class="p_header">index fa34808..ba475e1 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/ssd1307fb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/ssd1307fb.c</span>
<span class="p_chunk">@@ -592,7 +592,7 @@</span> <span class="p_context"> static int ssd1307fb_probe(struct i2c_client *client,</span>
 
 	vmem_size = par-&gt;width * par-&gt;height / 8;
 
<span class="p_del">-	vmem = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	vmem = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					get_order(vmem_size));
 	if (!vmem) {
 		dev_err(&amp;client-&gt;dev, &quot;Couldn&#39;t allocate graphical memory.\n&quot;);
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index 40c9ef6..459cb01731 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -1677,8 +1677,7 @@</span> <span class="p_context"> int ceph_alloc_readdir_reply_buffer(struct ceph_mds_request *req,</span>
 
 	order = get_order(size * num_entries);
 	while (order &gt;= 0) {
<span class="p_del">-		rinfo-&gt;dir_in = (void*)__get_free_pages(GFP_KERNEL |</span>
<span class="p_del">-							__GFP_NOWARN,</span>
<span class="p_add">+		rinfo-&gt;dir_in = get_free_pages(GFP_KERNEL | __GFP_NOWARN,</span>
 							order);
 		if (rinfo-&gt;dir_in)
 			break;
<span class="p_header">diff --git a/fs/configfs/file.c b/fs/configfs/file.c</span>
<span class="p_header">index c4a3c5c..0fd6d8e 100644</span>
<span class="p_header">--- a/fs/configfs/file.c</span>
<span class="p_header">+++ b/fs/configfs/file.c</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> fill_write_buffer(struct configfs_buffer * buffer, const char __user * buf, size</span>
 	int error;
 
 	if (!buffer-&gt;page)
<span class="p_del">-		buffer-&gt;page = (char *)__get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+		buffer-&gt;page = get_free_pages(GFP_KERNEL, 0);</span>
 	if (!buffer-&gt;page)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/fs/hfs/mdb.c b/fs/hfs/mdb.c</span>
<span class="p_header">index 92f1730..914a40e 100644</span>
<span class="p_header">--- a/fs/hfs/mdb.c</span>
<span class="p_header">+++ b/fs/hfs/mdb.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> int hfs_mdb_get(struct super_block *sb)</span>
 		pr_warn(&quot;continuing without an alternate MDB\n&quot;);
 	}
 
<span class="p_del">-	HFS_SB(sb)-&gt;bitmap = (__be32 *)__get_free_pages(GFP_KERNEL, PAGE_SIZE &lt; 8192 ? 1 : 0);</span>
<span class="p_add">+	HFS_SB(sb)-&gt;bitmap = get_free_pages(GFP_KERNEL, PAGE_SIZE &lt; 8192 ? 1 : 0);</span>
 	if (!HFS_SB(sb)-&gt;bitmap)
 		goto out;
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 450a30b..337faf2 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -2301,12 +2301,12 @@</span> <span class="p_context"> void *jbd2_alloc(size_t size, gfp_t flags)</span>
 
 	flags |= __GFP_REPEAT;
 	if (size == PAGE_SIZE)
<span class="p_del">-		ptr = (void *)__get_free_pages(flags, 0);</span>
<span class="p_add">+		ptr = get_free_pages(flags, 0);</span>
 	else if (size &gt; PAGE_SIZE) {
 		int order = get_order(size);
 
 		if (order &lt; 3)
<span class="p_del">-			ptr = (void *)__get_free_pages(flags, order);</span>
<span class="p_add">+			ptr = get_free_pages(flags, order);</span>
 		else
 			ptr = vmalloc(size);
 	} else
<span class="p_header">diff --git a/fs/nilfs2/ioctl.c b/fs/nilfs2/ioctl.c</span>
<span class="p_header">index 09d2ede..da2c0ee 100644</span>
<span class="p_header">--- a/fs/nilfs2/ioctl.c</span>
<span class="p_header">+++ b/fs/nilfs2/ioctl.c</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> static int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,</span>
 	if (argv-&gt;v_index &gt; ~(__u64)0 - argv-&gt;v_nmembs)
 		return -EINVAL;
 
<span class="p_del">-	buf = (void *)__get_free_pages(GFP_NOFS, 0);</span>
<span class="p_add">+	buf = get_free_pages(GFP_NOFS, 0);</span>
 	if (unlikely(!buf))
 		return -ENOMEM;
 	maxmembs = PAGE_SIZE / argv-&gt;v_size;
<span class="p_header">diff --git a/fs/proc/vmcore.c b/fs/proc/vmcore.c</span>
<span class="p_header">index dd6566c..b4cf217 100644</span>
<span class="p_header">--- a/fs/proc/vmcore.c</span>
<span class="p_header">+++ b/fs/proc/vmcore.c</span>
<span class="p_chunk">@@ -1027,7 +1027,7 @@</span> <span class="p_context"> static int __init parse_crash_elf64_headers(void)</span>
 	elfcorebuf_sz_orig = sizeof(Elf64_Ehdr) +
 				ehdr.e_phnum * sizeof(Elf64_Phdr);
 	elfcorebuf_sz = elfcorebuf_sz_orig;
<span class="p_del">-	elfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	elfcorebuf = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					      get_order(elfcorebuf_sz_orig));
 	if (!elfcorebuf)
 		return -ENOMEM;
<span class="p_chunk">@@ -1082,7 +1082,7 @@</span> <span class="p_context"> static int __init parse_crash_elf32_headers(void)</span>
 	/* Read in all elf headers. */
 	elfcorebuf_sz_orig = sizeof(Elf32_Ehdr) + ehdr.e_phnum * sizeof(Elf32_Phdr);
 	elfcorebuf_sz = elfcorebuf_sz_orig;
<span class="p_del">-	elfcorebuf = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+	elfcorebuf = get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					      get_order(elfcorebuf_sz_orig));
 	if (!elfcorebuf)
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/quota/dquot.c b/fs/quota/dquot.c</span>
<span class="p_header">index ef0d64b..b814eeb 100644</span>
<span class="p_header">--- a/fs/quota/dquot.c</span>
<span class="p_header">+++ b/fs/quota/dquot.c</span>
<span class="p_chunk">@@ -2894,7 +2894,7 @@</span> <span class="p_context"> static int __init dquot_init(void)</span>
 			NULL);
 
 	order = 0;
<span class="p_del">-	dquot_hash = (struct hlist_head *)__get_free_pages(GFP_ATOMIC, order);</span>
<span class="p_add">+	dquot_hash = get_free_pages(GFP_ATOMIC, order);</span>
 	if (!dquot_hash)
 		panic(&quot;Cannot create dquot hash table&quot;);
 
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 927cdd4..1d42951 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -2924,7 +2924,7 @@</span> <span class="p_context"> static int ftrace_allocate_records(struct ftrace_page *pg, int count)</span>
 		order--;
 
  again:
<span class="p_del">-	pg-&gt;records = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
<span class="p_add">+	pg-&gt;records = get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
 
 	if (!pg-&gt;records) {
 		/* if we can&#39;t allocate this size, try something smaller */
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index 5d06111..0a0a08e 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -1640,8 +1640,7 @@</span> <span class="p_context"> ftrace_event_pid_write(struct file *filp, const char __user *ubuf,</span>
 			else
 				pid_list-&gt;order = 0;
 
<span class="p_del">-			pid_list-&gt;pids = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-								  pid_list-&gt;order);</span>
<span class="p_add">+			pid_list-&gt;pids = get_free_pages(GFP_KERNEL, pid_list-&gt;order);</span>
 			if (!pid_list-&gt;pids)
 				break;
 
<span class="p_chunk">@@ -1656,8 +1655,7 @@</span> <span class="p_context"> ftrace_event_pid_write(struct file *filp, const char __user *ubuf,</span>
 		if (pid_list-&gt;nr_pids &gt;= max_pids(pid_list)) {
 			pid_t *pid_page;
 
<span class="p_del">-			pid_page = (void *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_del">-							    pid_list-&gt;order + 1);</span>
<span class="p_add">+			pid_page = get_free_pages(GFP_KERNEL, pid_list-&gt;order + 1);</span>
 			if (!pid_page)
 				break;
 			memcpy(pid_page, pid_list-&gt;pids,
<span class="p_header">diff --git a/lib/percpu_ida.c b/lib/percpu_ida.c</span>
<span class="p_header">index d58f5a9..ef95209 100644</span>
<span class="p_header">--- a/lib/percpu_ida.c</span>
<span class="p_header">+++ b/lib/percpu_ida.c</span>
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> int __percpu_ida_init(struct percpu_ida *pool, unsigned long nr_tags,</span>
 	}
 
 	order = get_order(nr_tags * sizeof(unsigned));
<span class="p_del">-	pool-&gt;freelist = (void *) __get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	pool-&gt;freelist = get_free_pages(GFP_KERNEL, order);</span>
 	if (!pool-&gt;freelist)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/lib/raid6/algos.c b/lib/raid6/algos.c</span>
<span class="p_header">index 3d8cf31..c98026d 100644</span>
<span class="p_header">--- a/lib/raid6/algos.c</span>
<span class="p_header">+++ b/lib/raid6/algos.c</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> int __init raid6_select_algo(void)</span>
 		dptrs[i] = ((char *)raid6_gfmul) + PAGE_SIZE*i;
 
 	/* Normal code - use a 2-page allocation to avoid D$ conflict */
<span class="p_del">-	syndromes = (void *) __get_free_pages(GFP_KERNEL, 1);</span>
<span class="p_add">+	syndromes = get_free_pages(GFP_KERNEL, 1);</span>
 
 	if (!syndromes) {
 		pr_err(&quot;raid6: Yikes!  No memory available.\n&quot;);
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index 87e33e7..456e38d 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> swiotlb_late_init_with_default_size(size_t default_size)</span>
 	bytes = io_tlb_nslabs &lt;&lt; IO_TLB_SHIFT;
 
 	while ((SLABS_PER_PAGE &lt;&lt; order) &gt; IO_TLB_MIN_SLABS) {
<span class="p_del">-		vstart = (void *)__get_free_pages(GFP_DMA | __GFP_NOWARN,</span>
<span class="p_add">+		vstart = get_free_pages(GFP_DMA | __GFP_NOWARN,</span>
 						  order);
 		if (vstart)
 			break;
<span class="p_chunk">@@ -299,8 +299,7 @@</span> <span class="p_context"> swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)</span>
 	/*
 	 * Get the overflow emergency buffer
 	 */
<span class="p_del">-	v_overflow_buffer = (void *)__get_free_pages(GFP_DMA,</span>
<span class="p_del">-						     get_order(io_tlb_overflow));</span>
<span class="p_add">+	v_overflow_buffer = get_free_pages(GFP_DMA, get_order(io_tlb_overflow));</span>
 	if (!v_overflow_buffer)
 		goto cleanup2;
 
<span class="p_chunk">@@ -311,13 +310,12 @@</span> <span class="p_context"> swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)</span>
 	 * to find contiguous free memory regions of size up to IO_TLB_SEGSIZE
 	 * between io_tlb_start and io_tlb_end.
 	 */
<span class="p_del">-	io_tlb_list = (unsigned int *)__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+	io_tlb_list = get_free_pages(GFP_KERNEL,</span>
 	                              get_order(io_tlb_nslabs * sizeof(int)));
 	if (!io_tlb_list)
 		goto cleanup3;
 
<span class="p_del">-	io_tlb_orig_addr = (phys_addr_t *)</span>
<span class="p_del">-		__get_free_pages(GFP_KERNEL,</span>
<span class="p_add">+	io_tlb_orig_addr = get_free_pages(GFP_KERNEL,</span>
 				 get_order(io_tlb_nslabs *
 					   sizeof(phys_addr_t)));
 	if (!io_tlb_orig_addr)
<span class="p_chunk">@@ -634,7 +632,7 @@</span> <span class="p_context"> swiotlb_alloc_coherent(struct device *hwdev, size_t size,</span>
 	if (hwdev &amp;&amp; hwdev-&gt;coherent_dma_mask)
 		dma_mask = hwdev-&gt;coherent_dma_mask;
 
<span class="p_del">-	ret = (void *)__get_free_pages(flags, order);</span>
<span class="p_add">+	ret = get_free_pages(flags, order);</span>
 	if (ret) {
 		dev_addr = swiotlb_virt_to_bus(hwdev, ret);
 		if (dev_addr + size - 1 &gt; dma_mask) {
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 8364c20..a3c4440 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static bool tlb_next_batch(struct mmu_gather *tlb)</span>
 	if (tlb-&gt;batch_count == MAX_GATHER_BATCH_COUNT)
 		return false;
 
<span class="p_del">-	batch = (void *)__get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
<span class="p_add">+	batch = get_free_pages(GFP_NOWAIT | __GFP_NOWARN, 0);</span>
 	if (!batch)
 		return false;
 
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 9ab053f..a4d01ea 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -3276,7 +3276,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(get_free_pages);</span>
 
 void *get_zeroed_page(gfp_t gfp_mask)
 {
<span class="p_del">-	return (void *)__get_free_pages(gfp_mask | __GFP_ZERO, 0);</span>
<span class="p_add">+	return get_free_pages(gfp_mask | __GFP_ZERO, 0);</span>
 }
 EXPORT_SYMBOL(get_zeroed_page);
 
<span class="p_chunk">@@ -3481,7 +3481,7 @@</span> <span class="p_context"> static void *make_alloc_exact(void *addr, unsigned int order,</span>
 void *alloc_pages_exact(size_t size, gfp_t gfp_mask)
 {
 	unsigned int order = get_order(size);
<span class="p_del">-	void *addr = (void *)__get_free_pages(gfp_mask, order);</span>
<span class="p_add">+	void *addr = get_free_pages(gfp_mask, order);</span>
 	return make_alloc_exact(addr, order, size);
 }
 EXPORT_SYMBOL(alloc_pages_exact);
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 5da985fe..c04a507 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -4206,7 +4206,7 @@</span> <span class="p_context"> static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)</span>
 
 	order = get_order(sizeof(struct location) * max);
 
<span class="p_del">-	l = (void *)__get_free_pages(flags, order);</span>
<span class="p_add">+	l = get_free_pages(flags, order);</span>
 	if (!l)
 		return 0;
 
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 6eb5170..621eaac 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -327,8 +327,7 @@</span> <span class="p_context"> static struct neigh_hash_table *neigh_hash_alloc(unsigned int shift)</span>
 	if (size &lt;= PAGE_SIZE)
 		buckets = kzalloc(size, GFP_ATOMIC);
 	else
<span class="p_del">-		buckets = (struct neighbour __rcu **)</span>
<span class="p_del">-			  __get_free_pages(GFP_ATOMIC | __GFP_ZERO,</span>
<span class="p_add">+		buckets = get_free_pages(GFP_ATOMIC | __GFP_ZERO,</span>
 					   get_order(size));
 	if (!buckets) {
 		kfree(ret);
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index b689ca8..77c2afe 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -1147,8 +1147,8 @@</span> <span class="p_context"> static int __init dccp_init(void)</span>
 		while (hash_size &amp; (hash_size - 1))
 			hash_size--;
 		dccp_hashinfo.ehash_mask = hash_size - 1;
<span class="p_del">-		dccp_hashinfo.ehash = (struct inet_ehash_bucket *)</span>
<span class="p_del">-			__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, ehash_order);</span>
<span class="p_add">+		dccp_hashinfo.ehash = </span>
<span class="p_add">+			get_free_pages(GFP_ATOMIC|__GFP_NOWARN, ehash_order);</span>
 	} while (!dccp_hashinfo.ehash &amp;&amp; --ehash_order &gt; 0);
 
 	if (!dccp_hashinfo.ehash) {
<span class="p_chunk">@@ -1170,8 +1170,8 @@</span> <span class="p_context"> static int __init dccp_init(void)</span>
 		if ((dccp_hashinfo.bhash_size &gt; (64 * 1024)) &amp;&amp;
 		    bhash_order &gt; 0)
 			continue;
<span class="p_del">-		dccp_hashinfo.bhash = (struct inet_bind_hashbucket *)</span>
<span class="p_del">-			__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, bhash_order);</span>
<span class="p_add">+		dccp_hashinfo.bhash =</span>
<span class="p_add">+			get_free_pages(GFP_ATOMIC|__GFP_NOWARN, bhash_order);</span>
 	} while (!dccp_hashinfo.bhash &amp;&amp; --bhash_order &gt;= 0);
 
 	if (!dccp_hashinfo.bhash) {
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index 607a14f..9aae75d 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -1894,8 +1894,7 @@</span> <span class="p_context"> void __init dn_route_init(void)</span>
 			sizeof(struct dn_rt_hash_bucket);
 		while(dn_rt_hash_mask &amp; (dn_rt_hash_mask - 1))
 			dn_rt_hash_mask--;
<span class="p_del">-		dn_rt_hash_table = (struct dn_rt_hash_bucket *)</span>
<span class="p_del">-			__get_free_pages(GFP_ATOMIC, order);</span>
<span class="p_add">+		dn_rt_hash_table = get_free_pages(GFP_ATOMIC, order);</span>
 	} while (dn_rt_hash_table == NULL &amp;&amp; --order &gt; 0);
 
 	if (!dn_rt_hash_table)
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index f69b6d9..fddffc1 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -840,8 +840,7 @@</span> <span class="p_context"> static struct hlist_head *fib_info_hash_alloc(int bytes)</span>
 	if (bytes &lt;= PAGE_SIZE)
 		return kzalloc(bytes, GFP_KERNEL);
 	else
<span class="p_del">-		return (struct hlist_head *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
<span class="p_add">+		return get_free_pages(GFP_KERNEL | __GFP_ZERO,</span>
 					 get_order(bytes));
 }
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 5a80da65..9124509 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -1544,7 +1544,7 @@</span> <span class="p_context"> void *nf_ct_alloc_hashtable(unsigned int *sizep, int nulls)</span>
 	BUILD_BUG_ON(sizeof(struct hlist_nulls_head) != sizeof(struct hlist_head));
 	nr_slots = *sizep = roundup(*sizep, PAGE_SIZE / sizeof(struct hlist_nulls_head));
 	sz = nr_slots * sizeof(struct hlist_nulls_head);
<span class="p_del">-	hash = (void *)__get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,</span>
<span class="p_add">+	hash = get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,</span>
 					get_order(sz));
 	if (!hash)
 		hash = vzalloc(sz);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index da6fba6..587eb78 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"> static void *alloc_one_pg_vec_page(unsigned long order)</span>
 	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP | __GFP_ZERO |
 			  __GFP_NOWARN | __GFP_NORETRY;
 
<span class="p_del">-	buffer = (void *)__get_free_pages(gfp_flags, order);</span>
<span class="p_add">+	buffer = get_free_pages(gfp_flags, order);</span>
 	if (buffer != NULL)
 		return buffer;
 
<span class="p_chunk">@@ -349,7 +349,7 @@</span> <span class="p_context"> static void *alloc_one_pg_vec_page(unsigned long order)</span>
 		return buffer;
 
 	gfp_flags &amp;= ~__GFP_NORETRY;
<span class="p_del">-	return (void *)__get_free_pages(gfp_flags, order);</span>
<span class="p_add">+	return get_free_pages(gfp_flags, order);</span>
 }
 
 static void **alloc_pg_vec(struct netlink_sock *nlk,
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index fae2812..c1d1284 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -4013,7 +4013,7 @@</span> <span class="p_context"> static char *alloc_one_pg_vec_page(unsigned long order)</span>
 	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |
 			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;
 
<span class="p_del">-	buffer = (char *) __get_free_pages(gfp_flags, order);</span>
<span class="p_add">+	buffer = get_free_pages(gfp_flags, order);</span>
 	if (buffer)
 		return buffer;
 
<span class="p_chunk">@@ -4024,7 +4024,7 @@</span> <span class="p_context"> static char *alloc_one_pg_vec_page(unsigned long order)</span>
 
 	/* vmalloc failed, lets dig into swap here */
 	gfp_flags &amp;= ~__GFP_NORETRY;
<span class="p_del">-	buffer = (char *) __get_free_pages(gfp_flags, order);</span>
<span class="p_add">+	buffer = get_free_pages(gfp_flags, order);</span>
 	if (buffer)
 		return buffer;
 
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 1c9ff0b..4c854f0 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -628,8 +628,7 @@</span> <span class="p_context"> static struct hlist_head *qdisc_class_hash_alloc(unsigned int n)</span>
 	if (size &lt;= PAGE_SIZE)
 		h = kmalloc(size, GFP_KERNEL);
 	else
<span class="p_del">-		h = (struct hlist_head *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL, get_order(size));</span>
<span class="p_add">+		h = get_free_pages(GFP_KERNEL, get_order(size));</span>
 
 	if (h != NULL) {
 		for (i = 0; i &lt; n; i++)
<span class="p_header">diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c</span>
<span class="p_header">index 8dfdd0e..4e44dfd 100644</span>
<span class="p_header">--- a/net/sctp/protocol.c</span>
<span class="p_header">+++ b/net/sctp/protocol.c</span>
<span class="p_chunk">@@ -1418,8 +1418,8 @@</span> <span class="p_context"> static __init int sctp_init(void)</span>
 					sizeof(struct sctp_hashbucket);
 		if ((sctp_assoc_hashsize &gt; (64 * 1024)) &amp;&amp; order &gt; 0)
 			continue;
<span class="p_del">-		sctp_assoc_hashtable = (struct sctp_hashbucket *)</span>
<span class="p_del">-			__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);</span>
<span class="p_add">+		sctp_assoc_hashtable = </span>
<span class="p_add">+			get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);</span>
 	} while (!sctp_assoc_hashtable &amp;&amp; --order &gt; 0);
 	if (!sctp_assoc_hashtable) {
 		pr_err(&quot;Failed association hash alloc\n&quot;);
<span class="p_chunk">@@ -1451,8 +1451,8 @@</span> <span class="p_context"> static __init int sctp_init(void)</span>
 					sizeof(struct sctp_bind_hashbucket);
 		if ((sctp_port_hashsize &gt; (64 * 1024)) &amp;&amp; order &gt; 0)
 			continue;
<span class="p_del">-		sctp_port_hashtable = (struct sctp_bind_hashbucket *)</span>
<span class="p_del">-			__get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);</span>
<span class="p_add">+		sctp_port_hashtable =</span>
<span class="p_add">+			get_free_pages(GFP_ATOMIC|__GFP_NOWARN, order);</span>
 	} while (!sctp_port_hashtable &amp;&amp; --order &gt; 0);
 	if (!sctp_port_hashtable) {
 		pr_err(&quot;Failed bind hash alloc\n&quot;);
<span class="p_header">diff --git a/net/sctp/ssnmap.c b/net/sctp/ssnmap.c</span>
<span class="p_header">index 97b1939..e3e290c 100644</span>
<span class="p_header">--- a/net/sctp/ssnmap.c</span>
<span class="p_header">+++ b/net/sctp/ssnmap.c</span>
<span class="p_chunk">@@ -59,8 +59,7 @@</span> <span class="p_context"> struct sctp_ssnmap *sctp_ssnmap_new(__u16 in, __u16 out,</span>
 	if (size &lt;= KMALLOC_MAX_SIZE)
 		retval = kmalloc(size, gfp);
 	else
<span class="p_del">-		retval = (struct sctp_ssnmap *)</span>
<span class="p_del">-			  __get_free_pages(gfp, get_order(size));</span>
<span class="p_add">+		retval = get_free_pages(gfp, get_order(size));</span>
 	if (!retval)
 		goto fail;
 
<span class="p_header">diff --git a/net/xfrm/xfrm_hash.c b/net/xfrm/xfrm_hash.c</span>
<span class="p_header">index f19872e..47c40d3 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_hash.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_hash.c</span>
<span class="p_chunk">@@ -21,8 +21,7 @@</span> <span class="p_context"> struct hlist_head *xfrm_hash_alloc(unsigned int sz)</span>
 	else if (hashdist)
 		n = vzalloc(sz);
 	else
<span class="p_del">-		n = (struct hlist_head *)</span>
<span class="p_del">-			__get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,</span>
<span class="p_add">+		n = get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,</span>
 					 get_order(sz));
 
 	return n;
<span class="p_header">diff --git a/security/integrity/ima/ima_crypto.c b/security/integrity/ima/ima_crypto.c</span>
<span class="p_header">index 96f416c..f52bf51 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_crypto.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_crypto.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> static void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,</span>
 		order = min(get_order(max_size), order);
 
 	for (; order; order--) {
<span class="p_del">-		ptr = (void *)__get_free_pages(gfp_mask, order);</span>
<span class="p_add">+		ptr = get_free_pages(gfp_mask, order);</span>
 		if (ptr) {
 			*allocated_size = PAGE_SIZE &lt;&lt; order;
 			return ptr;
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> static void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,</span>
 	if (!last_warn)
 		gfp_mask |= __GFP_NOWARN;
 
<span class="p_del">-	ptr = (void *)__get_free_pages(gfp_mask, 0);</span>
<span class="p_add">+	ptr = get_free_pages(gfp_mask, 0);</span>
 	if (ptr) {
 		*allocated_size = PAGE_SIZE;
 		return ptr;
<span class="p_header">diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c</span>
<span class="p_header">index 43ac8b5..3a0b54c 100644</span>
<span class="p_header">--- a/sound/core/memalloc.c</span>
<span class="p_header">+++ b/sound/core/memalloc.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> void *snd_malloc_pages(size_t size, gfp_t gfp_flags)</span>
 		return NULL;
 	gfp_flags |= __GFP_COMP;	/* compound page lets parts be mapped */
 	pg = get_order(size);
<span class="p_del">-	return (void *) __get_free_pages(gfp_flags, pg);</span>
<span class="p_add">+	return get_free_pages(gfp_flags, pg);</span>
 }
 
 /**
<span class="p_header">diff --git a/sound/oss/dmabuf.c b/sound/oss/dmabuf.c</span>
<span class="p_header">index 457755a..e7c45ab 100644</span>
<span class="p_header">--- a/sound/oss/dmabuf.c</span>
<span class="p_header">+++ b/sound/oss/dmabuf.c</span>
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> static int sound_alloc_dmap(struct dma_buffparms *dmap)</span>
 	while (start_addr == NULL &amp;&amp; dmap-&gt;buffsize &gt; PAGE_SIZE) {
 		for (sz = 0, size = PAGE_SIZE; size &lt; dmap-&gt;buffsize; sz++, size &lt;&lt;= 1);
 		dmap-&gt;buffsize = PAGE_SIZE * (1 &lt;&lt; sz);
<span class="p_del">-		start_addr = (char *) __get_free_pages(GFP_ATOMIC|GFP_DMA|__GFP_NOWARN, sz);</span>
<span class="p_add">+		start_addr = get_free_pages(GFP_ATOMIC|GFP_DMA|__GFP_NOWARN, sz);</span>
 		if (start_addr == NULL)
 			dmap-&gt;buffsize /= 2;
 	}
<span class="p_header">diff --git a/sound/usb/usx2y/usb_stream.c b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">index c423951..8ca8200 100644</span>
<span class="p_header">--- a/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">+++ b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	}
 
 	pg = get_order(read_size);
<span class="p_del">-	sk-&gt;s = (void *) __get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+	sk-&gt;s = get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
 	if (!sk-&gt;s) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		goto out;
<span class="p_chunk">@@ -210,8 +210,7 @@</span> <span class="p_context"> struct usb_stream *usb_stream_new(struct usb_stream_kernel *sk,</span>
 	sk-&gt;s-&gt;write_size = write_size;
 	pg = get_order(write_size);
 
<span class="p_del">-	sk-&gt;write_page =</span>
<span class="p_del">-		(void *)__get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
<span class="p_add">+	sk-&gt;write_page = get_free_pages(GFP_KERNEL|__GFP_COMP|__GFP_ZERO, pg);</span>
 	if (!sk-&gt;write_page) {
 		snd_printk(KERN_WARNING &quot;couldn&#39;t __get_free_pages()\n&quot;);
 		usb_stream_free(sk);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



