
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/2] arm: apply more __ro_after_init - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/2] arm: apply more __ro_after_init</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=38541">Kees Cook</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 3, 2016, 6:40 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1464979224-2085-3-git-send-email-keescook@chromium.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9153857/mbox/"
   >mbox</a>
|
   <a href="/patch/9153857/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9153857/">/patch/9153857/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	26BD46082E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  3 Jun 2016 18:40:57 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1D3D628333
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  3 Jun 2016 18:40:57 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 11A8E28336; Fri,  3 Jun 2016 18:40:57 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2DCAA28333
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  3 Jun 2016 18:40:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1161030AbcFCSku (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 3 Jun 2016 14:40:50 -0400
Received: from mail-pf0-f169.google.com ([209.85.192.169]:35627 &quot;EHLO
	mail-pf0-f169.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932319AbcFCSkq (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 3 Jun 2016 14:40:46 -0400
Received: by mail-pf0-f169.google.com with SMTP id g64so46212142pfb.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Fri, 03 Jun 2016 11:40:46 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=chromium.org; s=google;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=hu3RSy6vlNZrzAjgTizErXsaVS2X5XsTmcbIn6f0hLQ=;
	b=h7URcemJAu6FqhdDRGmdCB2eIXrOVqV/v+l7TE0oInZSUYAKTWoxeu882gY0D6LesX
	z6IWyZl5VhfQccoDmEWin/nWRvp/k5UIf3qNrWMCNEsH3quvYt5ihG8Tc1eBpzDUhGTK
	DinuRdMy/BOH7irc/dfFNwAZVmeKqiKH6d0/Q=
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=hu3RSy6vlNZrzAjgTizErXsaVS2X5XsTmcbIn6f0hLQ=;
	b=Goghsc50lIBDi8q8oiG+VATOg0IHsP46i9wP8tcoL9N8QtlEFa17mth5ka+Uej0FTT
	Xztay8GS77HpSzCsMvlcTvYULl8F1cww3DppMvTwlaK3WDnTzrAPjYCOjEcyepRBXfr9
	vPaGuEQiesjzHvZLPYWT3aszsKxLNUAhDjJ/hL4ipz+O2hb2L7PSr458CCL72RRAr0Hi
	3gvTErjuqGfOfbT1x3stp3ZbFJqaViWEW6OGHnTCJKa5nw8A/cgDPE5gf/dLgbd96w/9
	FogZtvhuwI3hL33ZeYs0hD8IbBHmmDZD7fqmzv/SBDAg6VHe+pATVh54BYqkfox5lH/O
	kvUA==
X-Gm-Message-State: ALyK8tIN7RINnczqiuYrI19IqfEt3LXSA302kRCa+A/VPjOofnJp+G4iQ4qZSgkQ2wUQiRjO
X-Received: by 10.98.27.216 with SMTP id b207mr7631796pfb.111.1464979245688; 
	Fri, 03 Jun 2016 11:40:45 -0700 (PDT)
Received: from www.outflux.net
	(173-164-112-133-Oregon.hfc.comcastbusiness.net. [173.164.112.133])
	by smtp.gmail.com with ESMTPSA id
	lg17sm7592764pab.36.2016.06.03.11.40.44
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Fri, 03 Jun 2016 11:40:44 -0700 (PDT)
From: Kees Cook &lt;keescook@chromium.org&gt;
To: kernel-hardening@lists.openwall.com
Cc: Kees Cook &lt;keescook@chromium.org&gt;, linux-arch@vger.kernel.org,
	linux-kernel@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
	x86@kernel.org, Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Mathias Krause &lt;minipli@googlemail.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [PATCH 2/2] arm: apply more __ro_after_init
Date: Fri,  3 Jun 2016 11:40:24 -0700
Message-Id: &lt;1464979224-2085-3-git-send-email-keescook@chromium.org&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1464979224-2085-1-git-send-email-keescook@chromium.org&gt;
References: &lt;1464979224-2085-1-git-send-email-keescook@chromium.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - June 3, 2016, 6:40 p.m.</div>
<pre class="content">
Guided by grsecurity&#39;s analogous __read_only markings in arch/arm,
this applies several uses of __ro_after_init to structures that are
only updated during __init.
<span class="signed-off-by">
Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
---
 arch/arm/kernel/cpuidle.c |  2 +-
 arch/arm/kernel/setup.c   | 10 +++++-----
 arch/arm/kernel/smp.c     |  2 +-
 arch/arm/lib/delay.c      |  2 +-
 arch/arm/mm/mmu.c         |  9 ++-------
 arch/x86/mm/ioremap.c     |  3 +--
 6 files changed, 11 insertions(+), 17 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 3, 2016, 6:51 p.m.</div>
<pre class="content">
On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:
<span class="quote">&gt; Guided by grsecurity&#39;s analogous __read_only markings in arch/arm,</span>
<span class="quote">&gt; this applies several uses of __ro_after_init to structures that are</span>
<span class="quote">&gt; only updated during __init.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/kernel/cpuidle.c |  2 +-</span>
<span class="quote">&gt;  arch/arm/kernel/setup.c   | 10 +++++-----</span>
<span class="quote">&gt;  arch/arm/kernel/smp.c     |  2 +-</span>
<span class="quote">&gt;  arch/arm/lib/delay.c      |  2 +-</span>
<span class="quote">&gt;  arch/arm/mm/mmu.c         |  9 ++-------</span>
<span class="quote">&gt;  arch/x86/mm/ioremap.c     |  3 +--</span>

I don&#39;t think this x86 file is an arm-specific one :)

That minor nit aside, these patches are a great step forward, are you
going to take them and work to push them upstream, or do you want/need
others to do this?

thanks,

greg k-h
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - June 3, 2016, 9:26 p.m.</div>
<pre class="content">
On Fri, Jun 3, 2016 at 11:51 AM, Greg KH &lt;gregkh@linuxfoundation.org&gt; wrote:
<span class="quote">&gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt;&gt; Guided by grsecurity&#39;s analogous __read_only markings in arch/arm,</span>
<span class="quote">&gt;&gt; this applies several uses of __ro_after_init to structures that are</span>
<span class="quote">&gt;&gt; only updated during __init.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/arm/kernel/cpuidle.c |  2 +-</span>
<span class="quote">&gt;&gt;  arch/arm/kernel/setup.c   | 10 +++++-----</span>
<span class="quote">&gt;&gt;  arch/arm/kernel/smp.c     |  2 +-</span>
<span class="quote">&gt;&gt;  arch/arm/lib/delay.c      |  2 +-</span>
<span class="quote">&gt;&gt;  arch/arm/mm/mmu.c         |  9 ++-------</span>
<span class="quote">&gt;&gt;  arch/x86/mm/ioremap.c     |  3 +--</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I don&#39;t think this x86 file is an arm-specific one :)</span>

Hah, whooops. :)
<span class="quote">
&gt; That minor nit aside, these patches are a great step forward, are you</span>
<span class="quote">&gt; going to take them and work to push them upstream, or do you want/need</span>
<span class="quote">&gt; others to do this?</span>

I&#39;ll collect more like these and carry a tree for -next and push them for v4.8.

-Kees
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 3, 2016, 9:54 p.m.</div>
<pre class="content">
On Fri, Jun 03, 2016 at 02:26:54PM -0700, Kees Cook wrote:
<span class="quote">&gt; On Fri, Jun 3, 2016 at 11:51 AM, Greg KH &lt;gregkh@linuxfoundation.org&gt; wrote:</span>
<span class="quote">&gt; &gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt; &gt;&gt; Guided by grsecurity&#39;s analogous __read_only markings in arch/arm,</span>
<span class="quote">&gt; &gt;&gt; this applies several uses of __ro_after_init to structures that are</span>
<span class="quote">&gt; &gt;&gt; only updated during __init.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt; ---</span>
<span class="quote">&gt; &gt;&gt;  arch/arm/kernel/cpuidle.c |  2 +-</span>
<span class="quote">&gt; &gt;&gt;  arch/arm/kernel/setup.c   | 10 +++++-----</span>
<span class="quote">&gt; &gt;&gt;  arch/arm/kernel/smp.c     |  2 +-</span>
<span class="quote">&gt; &gt;&gt;  arch/arm/lib/delay.c      |  2 +-</span>
<span class="quote">&gt; &gt;&gt;  arch/arm/mm/mmu.c         |  9 ++-------</span>
<span class="quote">&gt; &gt;&gt;  arch/x86/mm/ioremap.c     |  3 +--</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I don&#39;t think this x86 file is an arm-specific one :)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hah, whooops. :)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; That minor nit aside, these patches are a great step forward, are you</span>
<span class="quote">&gt; &gt; going to take them and work to push them upstream, or do you want/need</span>
<span class="quote">&gt; &gt; others to do this?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ll collect more like these and carry a tree for -next and push them for v4.8.</span>

Sounds good!

Is there any &quot;problem&quot; with applying these markings to code that could
be built as a module?  I&#39;m thinking of lots of buses and drivers that
have structures like this, but can be a module or not, depending on the
configuration selected.  It would be nice to get the &quot;benefit&quot; of
protection if the code is built into the kernel image.

thanks,

greg k-h
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - June 3, 2016, 10:01 p.m.</div>
<pre class="content">
On Fri, Jun 3, 2016 at 2:54 PM, Greg KH &lt;gregkh@linuxfoundation.org&gt; wrote:
<span class="quote">&gt; On Fri, Jun 03, 2016 at 02:26:54PM -0700, Kees Cook wrote:</span>
<span class="quote">&gt;&gt; On Fri, Jun 3, 2016 at 11:51 AM, Greg KH &lt;gregkh@linuxfoundation.org&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt; Guided by grsecurity&#39;s analogous __read_only markings in arch/arm,</span>
<span class="quote">&gt;&gt; &gt;&gt; this applies several uses of __ro_after_init to structures that are</span>
<span class="quote">&gt;&gt; &gt;&gt; only updated during __init.</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; ---</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/arm/kernel/cpuidle.c |  2 +-</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/arm/kernel/setup.c   | 10 +++++-----</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/arm/kernel/smp.c     |  2 +-</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/arm/lib/delay.c      |  2 +-</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/arm/mm/mmu.c         |  9 ++-------</span>
<span class="quote">&gt;&gt; &gt;&gt;  arch/x86/mm/ioremap.c     |  3 +--</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; I don&#39;t think this x86 file is an arm-specific one :)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hah, whooops. :)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt; That minor nit aside, these patches are a great step forward, are you</span>
<span class="quote">&gt;&gt; &gt; going to take them and work to push them upstream, or do you want/need</span>
<span class="quote">&gt;&gt; &gt; others to do this?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;ll collect more like these and carry a tree for -next and push them for v4.8.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sounds good!</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is there any &quot;problem&quot; with applying these markings to code that could</span>
<span class="quote">&gt; be built as a module?  I&#39;m thinking of lots of buses and drivers that</span>
<span class="quote">&gt; have structures like this, but can be a module or not, depending on the</span>
<span class="quote">&gt; configuration selected.  It would be nice to get the &quot;benefit&quot; of</span>
<span class="quote">&gt; protection if the code is built into the kernel image.</span>

There&#39;s no operational problem, it will just currently offer no
protections, and once the module side of things HAS been fixed, if any
got marked incorrectly, it&#39;ll be discovered then instead of when they
were added.

-Kees
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166571">Russell King - ARM Linux</a> - Aug. 10, 2016, 9:43 a.m.</div>
<pre class="content">
On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:
<span class="quote">&gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt;   * crash the kernel.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct map_desc map;</span>
<span class="quote">&gt;  	unsigned long addr;</span>
<span class="quote">&gt; -	void *vectors;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	/*</span>
<span class="quote">&gt; -	 * Allocate the vector page early.</span>
<span class="quote">&gt; -	 */</span>
<span class="quote">&gt; -	vectors = early_alloc(PAGE_SIZE * 2);</span>

This one is not appropriate.  We _do_ write to these pages after init
for FIQ handler updates.  See set_fiq_handler().
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Aug. 10, 2016, 10 a.m.</div>
<pre class="content">
On Wednesday, August 10, 2016 10:43:39 AM CEST Russell King - ARM Linux wrote:
<span class="quote">&gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt; &gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt; &gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt; &gt;   * crash the kernel.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt; &gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;       struct map_desc map;</span>
<span class="quote">&gt; &gt;       unsigned long addr;</span>
<span class="quote">&gt; &gt; -     void *vectors;</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; -     /*</span>
<span class="quote">&gt; &gt; -      * Allocate the vector page early.</span>
<span class="quote">&gt; &gt; -      */</span>
<span class="quote">&gt; &gt; -     vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt; for FIQ handler updates.  See set_fiq_handler().</span>

Is that the only thing that modifies the page? If we think this is a
valuable change, we could make it depend on the absence of FIQ
support, as very few platforms (rpc, omap1, s3c24xx and possibly
imx) seem to even use it.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166571">Russell King - ARM Linux</a> - Aug. 10, 2016, 10:12 a.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 12:00:53PM +0200, Arnd Bergmann wrote:
<span class="quote">&gt; On Wednesday, August 10, 2016 10:43:39 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt; &gt; &gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt; &gt; &gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt; &gt; &gt;   * crash the kernel.</span>
<span class="quote">&gt; &gt; &gt;   */</span>
<span class="quote">&gt; &gt; &gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt; &gt; &gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt; &gt; &gt;  {</span>
<span class="quote">&gt; &gt; &gt;       struct map_desc map;</span>
<span class="quote">&gt; &gt; &gt;       unsigned long addr;</span>
<span class="quote">&gt; &gt; &gt; -     void *vectors;</span>
<span class="quote">&gt; &gt; &gt; -</span>
<span class="quote">&gt; &gt; &gt; -     /*</span>
<span class="quote">&gt; &gt; &gt; -      * Allocate the vector page early.</span>
<span class="quote">&gt; &gt; &gt; -      */</span>
<span class="quote">&gt; &gt; &gt; -     vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt; &gt; for FIQ handler updates.  See set_fiq_handler().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is that the only thing that modifies the page? If we think this is a</span>
<span class="quote">&gt; valuable change, we could make it depend on the absence of FIQ</span>
<span class="quote">&gt; support, as very few platforms (rpc, omap1, s3c24xx and possibly</span>
<span class="quote">&gt; imx) seem to even use it.</span>

There&#39;s the TLS emulation too, but that writes via the vectors mapping
at 0xffff0ff0.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=110221">Daniel Micay</a> - Aug. 10, 2016, 5:06 p.m.</div>
<pre class="content">
On Wed, 2016-08-10 at 10:43 +0100, Russell King - ARM Linux wrote:
<span class="quote">&gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt; &gt;   * Any other function or debugging method which may touch any</span>
<span class="quote">&gt; &gt; device _will_</span>
<span class="quote">&gt; &gt;   * crash the kernel.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init</span>
<span class="quote">&gt; &gt; __aligned(PAGE_SIZE);</span>
<span class="quote">&gt; &gt;  static void __init devicemaps_init(const struct machine_desc</span>
<span class="quote">&gt; &gt; *mdesc)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	struct map_desc map;</span>
<span class="quote">&gt; &gt;  	unsigned long addr;</span>
<span class="quote">&gt; &gt; -	void *vectors;</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; -	/*</span>
<span class="quote">&gt; &gt; -	 * Allocate the vector page early.</span>
<span class="quote">&gt; &gt; -	 */</span>
<span class="quote">&gt; &gt; -	vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt; for FIQ handler updates.  See set_fiq_handler().</span>

This is one of the many cases where pax_open_kernel/pax_close_kernel are
needed to temporarily toggle it read-only. From grsecurity:

@@ -95,7 +95,10 @@ void set_fiq_handler(void *start, unsigned int
length)
 	void *base = vectors_page;
 	unsigned offset = FIQ_OFFSET;
 
+	pax_open_kernel();
 	memcpy(base + offset, start, length);
+	pax_close_kernel();
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - Aug. 10, 2016, 6:32 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 2:43 AM, Russell King - ARM Linux
&lt;linux@armlinux.org.uk&gt; wrote:
<span class="quote">&gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt;&gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt;&gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt;&gt;   * crash the kernel.</span>
<span class="quote">&gt;&gt;   */</span>
<span class="quote">&gt;&gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt;&gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;       struct map_desc map;</span>
<span class="quote">&gt;&gt;       unsigned long addr;</span>
<span class="quote">&gt;&gt; -     void *vectors;</span>
<span class="quote">&gt;&gt; -</span>
<span class="quote">&gt;&gt; -     /*</span>
<span class="quote">&gt;&gt; -      * Allocate the vector page early.</span>
<span class="quote">&gt;&gt; -      */</span>
<span class="quote">&gt;&gt; -     vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt; for FIQ handler updates.  See set_fiq_handler().</span>

Ah, interesting. I guess none of that hardware is being tested on
linux-next. I&#39;ll drop that chunk and resubmit.

Thanks!

-Kees
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Aug. 10, 2016, 7:41 p.m.</div>
<pre class="content">
On Wednesday, August 10, 2016 11:32:07 AM CEST Kees Cook wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 2:43 AM, Russell King - ARM Linux</span>
<span class="quote">&gt; &lt;linux@armlinux.org.uk&gt; wrote:</span>
<span class="quote">&gt; &gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt; &gt;&gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt; &gt;&gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt; &gt;&gt;   * crash the kernel.</span>
<span class="quote">&gt; &gt;&gt;   */</span>
<span class="quote">&gt; &gt;&gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt; &gt;&gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt; &gt;&gt;  {</span>
<span class="quote">&gt; &gt;&gt;       struct map_desc map;</span>
<span class="quote">&gt; &gt;&gt;       unsigned long addr;</span>
<span class="quote">&gt; &gt;&gt; -     void *vectors;</span>
<span class="quote">&gt; &gt;&gt; -</span>
<span class="quote">&gt; &gt;&gt; -     /*</span>
<span class="quote">&gt; &gt;&gt; -      * Allocate the vector page early.</span>
<span class="quote">&gt; &gt;&gt; -      */</span>
<span class="quote">&gt; &gt;&gt; -     vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt; &gt; for FIQ handler updates.  See set_fiq_handler().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ah, interesting. I guess none of that hardware is being tested on</span>
<span class="quote">&gt; linux-next.</span>

Right. The OMAP1 Amstrad Delta is a somewhat obscure machine, and that
would be the most likely candidate to run into this.

RiscPC also has FIQ support, but I have not heard of anyone other
than Russell still using one with a modern kernel, and I doubt he
tests linux-next on it.

The s3c24xx and imx machines that could use FIQ probably don&#39;t
use it in practice, last time I checked, I didn&#39;t see any DTS file
or platform data definition in the kernel that activated that
code path.
<span class="quote">
&gt; I&#39;ll drop that chunk and resubmit.</span>

Good enough for now, but it may be worth revisiting this, as the
vector page might be a good target for an attack if you have a
way to overwrite a few bytes in the kernel.

Note that there are two mappings for the pages, and as Russell
mentioned, the TLS emulation writes to the other one that is
at a fixed virtual address.

It might be better to start by making the fixed mapping readonly,
as KASLR doesn&#39;t protect that one at all, and change the TLS
code accordingly.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - Aug. 10, 2016, 9:40 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 12:41 PM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:
<span class="quote">&gt; On Wednesday, August 10, 2016 11:32:07 AM CEST Kees Cook wrote:</span>
<span class="quote">&gt;&gt; On Wed, Aug 10, 2016 at 2:43 AM, Russell King - ARM Linux</span>
<span class="quote">&gt;&gt; &lt;linux@armlinux.org.uk&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; On Fri, Jun 03, 2016 at 11:40:24AM -0700, Kees Cook wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt; @@ -1309,16 +1309,11 @@ void __init arm_mm_memblock_reserve(void)</span>
<span class="quote">&gt;&gt; &gt;&gt;   * Any other function or debugging method which may touch any device _will_</span>
<span class="quote">&gt;&gt; &gt;&gt;   * crash the kernel.</span>
<span class="quote">&gt;&gt; &gt;&gt;   */</span>
<span class="quote">&gt;&gt; &gt;&gt; +static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
<span class="quote">&gt;&gt; &gt;&gt;  static void __init devicemaps_init(const struct machine_desc *mdesc)</span>
<span class="quote">&gt;&gt; &gt;&gt;  {</span>
<span class="quote">&gt;&gt; &gt;&gt;       struct map_desc map;</span>
<span class="quote">&gt;&gt; &gt;&gt;       unsigned long addr;</span>
<span class="quote">&gt;&gt; &gt;&gt; -     void *vectors;</span>
<span class="quote">&gt;&gt; &gt;&gt; -</span>
<span class="quote">&gt;&gt; &gt;&gt; -     /*</span>
<span class="quote">&gt;&gt; &gt;&gt; -      * Allocate the vector page early.</span>
<span class="quote">&gt;&gt; &gt;&gt; -      */</span>
<span class="quote">&gt;&gt; &gt;&gt; -     vectors = early_alloc(PAGE_SIZE * 2);</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; This one is not appropriate.  We _do_ write to these pages after init</span>
<span class="quote">&gt;&gt; &gt; for FIQ handler updates.  See set_fiq_handler().</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Ah, interesting. I guess none of that hardware is being tested on</span>
<span class="quote">&gt;&gt; linux-next.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Right. The OMAP1 Amstrad Delta is a somewhat obscure machine, and that</span>
<span class="quote">&gt; would be the most likely candidate to run into this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; RiscPC also has FIQ support, but I have not heard of anyone other</span>
<span class="quote">&gt; than Russell still using one with a modern kernel, and I doubt he</span>
<span class="quote">&gt; tests linux-next on it.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The s3c24xx and imx machines that could use FIQ probably don&#39;t</span>
<span class="quote">&gt; use it in practice, last time I checked, I didn&#39;t see any DTS file</span>
<span class="quote">&gt; or platform data definition in the kernel that activated that</span>
<span class="quote">&gt; code path.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; I&#39;ll drop that chunk and resubmit.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Good enough for now, but it may be worth revisiting this, as the</span>
<span class="quote">&gt; vector page might be a good target for an attack if you have a</span>
<span class="quote">&gt; way to overwrite a few bytes in the kernel.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Note that there are two mappings for the pages, and as Russell</span>
<span class="quote">&gt; mentioned, the TLS emulation writes to the other one that is</span>
<span class="quote">&gt; at a fixed virtual address.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; It might be better to start by making the fixed mapping readonly,</span>
<span class="quote">&gt; as KASLR doesn&#39;t protect that one at all, and change the TLS</span>
<span class="quote">&gt; code accordingly.</span>

That sounds good (anyone want to work on this?). Does arm64 need a
similar vector page protection?

-Kees
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166571">Russell King - ARM Linux</a> - Aug. 10, 2016, 11:02 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 09:31:05PM +0200, Arnd Bergmann wrote:
<span class="quote">&gt; On Wednesday, August 10, 2016 11:12:53 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; There&#39;s the TLS emulation too, but that writes via the vectors mapping</span>
<span class="quote">&gt; &gt; at 0xffff0ff0.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ok, so that should be safe. Can we change the fiq code to also use the</span>
<span class="quote">&gt; high mapping and then take the __ro_after_init patch on top?</span>

We can&#39;t - if the kernel is configured without the kuser helpers in
the vectors page, it&#39;s mapped read-only.  I&#39;m not sure what the
intersection is between platforms that can have FIQs and platforms
that can disable the kuser helpers.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166571">Russell King - ARM Linux</a> - Aug. 10, 2016, 11:06 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 09:41:23PM +0200, Arnd Bergmann wrote:
<span class="quote">&gt; It might be better to start by making the fixed mapping readonly,</span>
<span class="quote">&gt; as KASLR doesn&#39;t protect that one at all, and change the TLS</span>
<span class="quote">&gt; code accordingly.</span>

I think that&#39;s impossible, because we gave userspace permission to
read 0xffff0ff0 directly without using __kuser_get_tls.  You&#39;re
talking about potentially breaking userspace.

If you disable kuser helpers, then the page becomes read-only and
invisible to userspace anyway.  So, everything is being done there
which can be done - if you have kuser helpers enabled, then you
lose some opportunities for these security improvements.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Aug. 11, 2016, 3:54 p.m.</div>
<pre class="content">
On Thursday, August 11, 2016 12:06:45 AM CEST Russell King - ARM Linux wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 09:41:23PM +0200, Arnd Bergmann wrote:</span>
<span class="quote">&gt; &gt; It might be better to start by making the fixed mapping readonly,</span>
<span class="quote">&gt; &gt; as KASLR doesn&#39;t protect that one at all, and change the TLS</span>
<span class="quote">&gt; &gt; code accordingly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think that&#39;s impossible, because we gave userspace permission to</span>
<span class="quote">&gt; read 0xffff0ff0 directly without using __kuser_get_tls.  You&#39;re</span>
<span class="quote">&gt; talking about potentially breaking userspace.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you disable kuser helpers, then the page becomes read-only and</span>
<span class="quote">&gt; invisible to userspace anyway.  So, everything is being done there</span>
<span class="quote">&gt; which can be done - if you have kuser helpers enabled, then you</span>
<span class="quote">&gt; lose some opportunities for these security improvements.</span>

What I meant was writing to the page through the linear mapping
rather than the virtual mapping at 0xffff0000 so we can leave that
one read-only (I did not consider whether that might cause cache
aliasing problems when reading from the other address).

Your other point is more important though: if one really cares
about optimizing security here, they probably should disable
kuser helpers completely anyway.

Kees, is that something you have on your radar already?

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Aug. 11, 2016, 4:02 p.m.</div>
<pre class="content">
On Thursday, August 11, 2016 12:02:42 AM CEST Russell King - ARM Linux wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 09:31:05PM +0200, Arnd Bergmann wrote:</span>
<span class="quote">&gt; &gt; On Wednesday, August 10, 2016 11:12:53 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; &gt; There&#39;s the TLS emulation too, but that writes via the vectors mapping</span>
<span class="quote">&gt; &gt; &gt; at 0xffff0ff0.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Ok, so that should be safe. Can we change the fiq code to also use the</span>
<span class="quote">&gt; &gt; high mapping and then take the __ro_after_init patch on top?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We can&#39;t - if the kernel is configured without the kuser helpers in</span>
<span class="quote">&gt; the vectors page, it&#39;s mapped read-only. I&#39;m not sure what the</span>
<span class="quote">&gt; intersection is between platforms that can have FIQs and platforms</span>
<span class="quote">&gt; that can disable the kuser helpers.</span>

From Kconfig logic and callers of set_fiq_handler(), theoretically
there is just i.MX3, but I think they never use fiq in their
audio drivers in practice already, and Mark Brown mentioned
that we could remove fiq support in the imx audio driver (don&#39;t
remember the details at the moment).

If we can prove that i.MX3 PCM FIQ support is never used, then the
intersection is empty, and all machines that use FIQ require kuser
helpers.

This may change with Daniel Thompson&#39;s patches that use the FIQ
for NMI backtrace.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=38541">Kees Cook</a> - Aug. 11, 2016, 10:16 p.m.</div>
<pre class="content">
On Thu, Aug 11, 2016 at 8:54 AM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:
<span class="quote">&gt; On Thursday, August 11, 2016 12:06:45 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt;&gt; On Wed, Aug 10, 2016 at 09:41:23PM +0200, Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt; &gt; It might be better to start by making the fixed mapping readonly,</span>
<span class="quote">&gt;&gt; &gt; as KASLR doesn&#39;t protect that one at all, and change the TLS</span>
<span class="quote">&gt;&gt; &gt; code accordingly.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I think that&#39;s impossible, because we gave userspace permission to</span>
<span class="quote">&gt;&gt; read 0xffff0ff0 directly without using __kuser_get_tls.  You&#39;re</span>
<span class="quote">&gt;&gt; talking about potentially breaking userspace.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If you disable kuser helpers, then the page becomes read-only and</span>
<span class="quote">&gt;&gt; invisible to userspace anyway.  So, everything is being done there</span>
<span class="quote">&gt;&gt; which can be done - if you have kuser helpers enabled, then you</span>
<span class="quote">&gt;&gt; lose some opportunities for these security improvements.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What I meant was writing to the page through the linear mapping</span>
<span class="quote">&gt; rather than the virtual mapping at 0xffff0000 so we can leave that</span>
<span class="quote">&gt; one read-only (I did not consider whether that might cause cache</span>
<span class="quote">&gt; aliasing problems when reading from the other address).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Your other point is more important though: if one really cares</span>
<span class="quote">&gt; about optimizing security here, they probably should disable</span>
<span class="quote">&gt; kuser helpers completely anyway.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Kees, is that something you have on your radar already?</span>

It wasn&#39;t no. I will add it. :)

-Kees
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=92431">Daniel Thompson</a> - Aug. 12, 2016, 11:34 a.m.</div>
<pre class="content">
On 11/08/16 17:02, Arnd Bergmann wrote:
<span class="quote">&gt; On Thursday, August 11, 2016 12:02:42 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt;&gt; On Wed, Aug 10, 2016 at 09:31:05PM +0200, Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt;&gt; On Wednesday, August 10, 2016 11:12:53 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; There&#39;s the TLS emulation too, but that writes via the vectors mapping</span>
<span class="quote">&gt;&gt;&gt;&gt; at 0xffff0ff0.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Ok, so that should be safe. Can we change the fiq code to also use the</span>
<span class="quote">&gt;&gt;&gt; high mapping and then take the __ro_after_init patch on top?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; We can&#39;t - if the kernel is configured without the kuser helpers in</span>
<span class="quote">&gt;&gt; the vectors page, it&#39;s mapped read-only. I&#39;m not sure what the</span>
<span class="quote">&gt;&gt; intersection is between platforms that can have FIQs and platforms</span>
<span class="quote">&gt;&gt; that can disable the kuser helpers.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; From Kconfig logic and callers of set_fiq_handler(), theoretically</span>
<span class="quote">&gt; there is just i.MX3, but I think they never use fiq in their</span>
<span class="quote">&gt; audio drivers in practice already, and Mark Brown mentioned</span>
<span class="quote">&gt; that we could remove fiq support in the imx audio driver (don&#39;t</span>
<span class="quote">&gt; remember the details at the moment).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If we can prove that i.MX3 PCM FIQ support is never used, then the</span>
<span class="quote">&gt; intersection is empty, and all machines that use FIQ require kuser</span>
<span class="quote">&gt; helpers.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This may change with Daniel Thompson&#39;s patches that use the FIQ</span>
<span class="quote">&gt; for NMI backtrace.</span>

It shouldn&#39;t do!

All the work I did (and am, very slowly, still doing) worked by using 
the default FIQ handler provided at boot time to jump into the perf code.

Nothing I have done or plan to do needs set_fiq_handler() to remain 
functional.

Likewise, nothing I have done should cause set_fiq_handler() to stop 
working for people who do still use it. FWIW I got the impression over 
the last few years that the most significant uses of FIQ on modern 
systems are out-of-tree uses who have designed custom FPGA hardware (and 
presumably designed them with very short FIFOs).


Daniel.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=166571">Russell King - ARM Linux</a> - Aug. 12, 2016, 4:24 p.m.</div>
<pre class="content">
On Thu, Aug 11, 2016 at 05:54:08PM +0200, Arnd Bergmann wrote:
<span class="quote">&gt; On Thursday, August 11, 2016 12:06:45 AM CEST Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; On Wed, Aug 10, 2016 at 09:41:23PM +0200, Arnd Bergmann wrote:</span>
<span class="quote">&gt; &gt; &gt; It might be better to start by making the fixed mapping readonly,</span>
<span class="quote">&gt; &gt; &gt; as KASLR doesn&#39;t protect that one at all, and change the TLS</span>
<span class="quote">&gt; &gt; &gt; code accordingly.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I think that&#39;s impossible, because we gave userspace permission to</span>
<span class="quote">&gt; &gt; read 0xffff0ff0 directly without using __kuser_get_tls.  You&#39;re</span>
<span class="quote">&gt; &gt; talking about potentially breaking userspace.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; If you disable kuser helpers, then the page becomes read-only and</span>
<span class="quote">&gt; &gt; invisible to userspace anyway.  So, everything is being done there</span>
<span class="quote">&gt; &gt; which can be done - if you have kuser helpers enabled, then you</span>
<span class="quote">&gt; &gt; lose some opportunities for these security improvements.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What I meant was writing to the page through the linear mapping</span>
<span class="quote">&gt; rather than the virtual mapping at 0xffff0000 so we can leave that</span>
<span class="quote">&gt; one read-only (I did not consider whether that might cause cache</span>
<span class="quote">&gt; aliasing problems when reading from the other address).</span>

Kees original patch was about moving the vector pages into the
read-only area after init, so the linear mapping of them becomes
read-only as well.  So that won&#39;t work.  We need at least one
read-write mapping for FIQ, and for context switching for kuser
helpers.
<span class="quote">
&gt; Your other point is more important though: if one really cares</span>
<span class="quote">&gt; about optimizing security here, they probably should disable</span>
<span class="quote">&gt; kuser helpers completely anyway.</span>

We could probably predicate moving the vectors page into the RO
section when kuser helpers are enabled.
<span class="quote">
&gt; Kees, is that something you have on your radar already?</span>

I believe Android already disable kuser helpers as of a few years ago.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/kernel/cpuidle.c b/arch/arm/kernel/cpuidle.c</span>
<span class="p_header">index a44b268e12e1..d574708ea20c 100644</span>
<span class="p_header">--- a/arch/arm/kernel/cpuidle.c</span>
<span class="p_header">+++ b/arch/arm/kernel/cpuidle.c</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"> extern struct of_cpuidle_method __cpuidle_method_of_table[];</span>
 static const struct of_cpuidle_method __cpuidle_method_of_table_sentinel
 	__used __section(__cpuidle_method_of_table_end);
 
<span class="p_del">-static struct cpuidle_ops cpuidle_ops[NR_CPUS];</span>
<span class="p_add">+static struct cpuidle_ops cpuidle_ops[NR_CPUS] __ro_after_init;</span>
 
 /**
  * arm_cpuidle_simple_enter() - a wrapper to cpu_do_idle()
<span class="p_header">diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c</span>
<span class="p_header">index 7b5350060612..38196e581d0a 100644</span>
<span class="p_header">--- a/arch/arm/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm/kernel/setup.c</span>
<span class="p_chunk">@@ -115,19 +115,19 @@</span> <span class="p_context"> EXPORT_SYMBOL(elf_hwcap2);</span>
 
 
 #ifdef MULTI_CPU
<span class="p_del">-struct processor processor __read_mostly;</span>
<span class="p_add">+struct processor processor __ro_after_init;</span>
 #endif
 #ifdef MULTI_TLB
<span class="p_del">-struct cpu_tlb_fns cpu_tlb __read_mostly;</span>
<span class="p_add">+struct cpu_tlb_fns cpu_tlb __ro_after_init;</span>
 #endif
 #ifdef MULTI_USER
<span class="p_del">-struct cpu_user_fns cpu_user __read_mostly;</span>
<span class="p_add">+struct cpu_user_fns cpu_user __ro_after_init;</span>
 #endif
 #ifdef MULTI_CACHE
<span class="p_del">-struct cpu_cache_fns cpu_cache __read_mostly;</span>
<span class="p_add">+struct cpu_cache_fns cpu_cache __ro_after_init;</span>
 #endif
 #ifdef CONFIG_OUTER_CACHE
<span class="p_del">-struct outer_cache_fns outer_cache __read_mostly;</span>
<span class="p_add">+struct outer_cache_fns outer_cache __ro_after_init;</span>
 EXPORT_SYMBOL(outer_cache);
 #endif
 
<span class="p_header">diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c</span>
<span class="p_header">index df90bc59bfce..9902e76fce0d 100644</span>
<span class="p_header">--- a/arch/arm/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm/kernel/smp.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> enum ipi_msg_type {</span>
 
 static DECLARE_COMPLETION(cpu_running);
 
<span class="p_del">-static struct smp_operations smp_ops;</span>
<span class="p_add">+static struct smp_operations smp_ops __ro_after_init;</span>
 
 void __init smp_set_ops(const struct smp_operations *ops)
 {
<span class="p_header">diff --git a/arch/arm/lib/delay.c b/arch/arm/lib/delay.c</span>
<span class="p_header">index 8044591dca72..2cef11884857 100644</span>
<span class="p_header">--- a/arch/arm/lib/delay.c</span>
<span class="p_header">+++ b/arch/arm/lib/delay.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 /*
  * Default to the loop-based delay implementation.
  */
<span class="p_del">-struct arm_delay_ops arm_delay_ops = {</span>
<span class="p_add">+struct arm_delay_ops arm_delay_ops __ro_after_init = {</span>
 	.delay		= __loop_delay,
 	.const_udelay	= __loop_const_udelay,
 	.udelay		= __loop_udelay,
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 62f4d01941f7..5e2acc78175e 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> __setup(&quot;noalign&quot;, noalign_setup);</span>
 #define PROT_PTE_S2_DEVICE	PROT_PTE_DEVICE
 #define PROT_SECT_DEVICE	PMD_TYPE_SECT|PMD_SECT_AP_WRITE
 
<span class="p_del">-static struct mem_type mem_types[] = {</span>
<span class="p_add">+static struct mem_type mem_types[] __ro_after_init = {</span>
 	[MT_DEVICE] = {		  /* Strongly ordered / ARMv6 shared device */
 		.prot_pte	= PROT_PTE_DEVICE | L_PTE_MT_DEV_SHARED |
 				  L_PTE_SHARED,
<span class="p_chunk">@@ -1309,16 +1309,11 @@</span> <span class="p_context"> void __init arm_mm_memblock_reserve(void)</span>
  * Any other function or debugging method which may touch any device _will_
  * crash the kernel.
  */
<span class="p_add">+static char vectors[PAGE_SIZE * 2] __ro_after_init __aligned(PAGE_SIZE);</span>
 static void __init devicemaps_init(const struct machine_desc *mdesc)
 {
 	struct map_desc map;
 	unsigned long addr;
<span class="p_del">-	void *vectors;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Allocate the vector page early.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vectors = early_alloc(PAGE_SIZE * 2);</span>
 
 	early_trap_init(vectors);
 
<span class="p_header">diff --git a/arch/x86/mm/ioremap.c b/arch/x86/mm/ioremap.c</span>
<span class="p_header">index 4e5821896eec..f0894910bdd7 100644</span>
<span class="p_header">--- a/arch/x86/mm/ioremap.c</span>
<span class="p_header">+++ b/arch/x86/mm/ioremap.c</span>
<span class="p_chunk">@@ -419,8 +419,7 @@</span> <span class="p_context"> void unxlate_dev_mem_ptr(phys_addr_t phys, void *addr)</span>
 	iounmap((void __iomem *)((unsigned long)addr &amp; PAGE_MASK));
 }
 
<span class="p_del">-static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __ro_after_init</span>
<span class="p_del">-					     __aligned(PAGE_SIZE);</span>
<span class="p_add">+static pte_t bm_pte[PAGE_SIZE/sizeof(pte_t)] __page_aligned_bss;</span>
 
 static inline pmd_t * __init early_ioremap_pmd(unsigned long addr)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



