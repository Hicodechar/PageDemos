
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.0.5 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.0.5</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 6, 2015, 4:26 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150606162634.GB12094@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6559841/mbox/"
   >mbox</a>
|
   <a href="/patch/6559841/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6559841/">/patch/6559841/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 2BF68C0020
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 16:27:47 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 4226B20668
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 16:27:38 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id EE5E02064B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  6 Jun 2015 16:27:28 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1422645AbbFFQ1S (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 6 Jun 2015 12:27:18 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:58413 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932442AbbFFQ0f (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 6 Jun 2015 12:26:35 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id C6608BAF;
	Sat,  6 Jun 2015 16:26:34 +0000 (UTC)
Date: Sat, 6 Jun 2015 09:26:34 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.0.5
Message-ID: &lt;20150606162634.GB12094@kroah.com&gt;
References: &lt;20150606162628.GA12094@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150606162628.GA12094@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-5.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD, UNPARSEABLE_RELAY,
	URIBL_SBL autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 6, 2015, 4:26 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/hwmon/tmp401 b/Documentation/hwmon/tmp401</span>
<span class="p_header">index 8eb88e974055..711f75e189eb 100644</span>
<span class="p_header">--- a/Documentation/hwmon/tmp401</span>
<span class="p_header">+++ b/Documentation/hwmon/tmp401</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"> Supported chips:</span>
     Datasheet: http://focus.ti.com/docs/prod/folders/print/tmp432.html
   * Texas Instruments TMP435
     Prefix: &#39;tmp435&#39;
<span class="p_del">-    Addresses scanned: I2C 0x37, 0x48 - 0x4f</span>
<span class="p_add">+    Addresses scanned: I2C 0x48 - 0x4f</span>
     Datasheet: http://focus.ti.com/docs/prod/folders/print/tmp435.html
 
 Authors:
<span class="p_header">diff --git a/Documentation/serial/tty.txt b/Documentation/serial/tty.txt</span>
<span class="p_header">index 1e52d67d0abf..dbe6623fed1c 100644</span>
<span class="p_header">--- a/Documentation/serial/tty.txt</span>
<span class="p_header">+++ b/Documentation/serial/tty.txt</span>
<span class="p_chunk">@@ -198,6 +198,9 @@</span> <span class="p_context"> TTY_IO_ERROR		If set, causes all subsequent userspace read/write</span>
 
 TTY_OTHER_CLOSED	Device is a pty and the other side has closed.
 
<span class="p_add">+TTY_OTHER_DONE		Device is a pty and the other side has closed and</span>
<span class="p_add">+			all pending input processing has been completed.</span>
<span class="p_add">+</span>
 TTY_NO_WRITE_SPLIT	Prevent driver from splitting up writes into
 			smaller chunks.
 
<span class="p_header">diff --git a/Documentation/virtual/kvm/mmu.txt b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">index 53838d9c6295..c59bd9bc41ef 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_chunk">@@ -169,6 +169,10 @@</span> <span class="p_context"> Shadow pages contain the following information:</span>
     Contains the value of cr4.smep &amp;&amp; !cr0.wp for which the page is valid
     (pages for which this is true are different from other pages; see the
     treatment of cr0.wp=0 below).
<span class="p_add">+  role.smap_andnot_wp:</span>
<span class="p_add">+    Contains the value of cr4.smap &amp;&amp; !cr0.wp for which the page is valid</span>
<span class="p_add">+    (pages for which this is true are different from other pages; see the</span>
<span class="p_add">+    treatment of cr0.wp=0 below).</span>
   gfn:
     Either the guest page table containing the translations shadowed by this
     page, or the base page frame for linear translations.  See role.direct.
<span class="p_chunk">@@ -344,10 +348,16 @@</span> <span class="p_context"> on fault type:</span>
 
 (user write faults generate a #PF)
 
<span class="p_del">-In the first case there is an additional complication if CR4.SMEP is</span>
<span class="p_del">-enabled: since we&#39;ve turned the page into a kernel page, the kernel may now</span>
<span class="p_del">-execute it.  We handle this by also setting spte.nx.  If we get a user</span>
<span class="p_del">-fetch or read fault, we&#39;ll change spte.u=1 and spte.nx=gpte.nx back.</span>
<span class="p_add">+In the first case there are two additional complications:</span>
<span class="p_add">+- if CR4.SMEP is enabled: since we&#39;ve turned the page into a kernel page,</span>
<span class="p_add">+  the kernel may now execute it.  We handle this by also setting spte.nx.</span>
<span class="p_add">+  If we get a user fetch or read fault, we&#39;ll change spte.u=1 and</span>
<span class="p_add">+  spte.nx=gpte.nx back.</span>
<span class="p_add">+- if CR4.SMAP is disabled: since the page has been changed to a kernel</span>
<span class="p_add">+  page, it can not be reused when CR4.SMAP is enabled. We set</span>
<span class="p_add">+  CR4.SMAP &amp;&amp; !CR0.WP into shadow page&#39;s role to avoid this case. Note,</span>
<span class="p_add">+  here we do not care the case that CR4.SMAP is enabled since KVM will</span>
<span class="p_add">+  directly inject #PF to guest due to failed permission check.</span>
 
 To prevent an spte that was converted into a kernel page with cr0.wp=0
 from being written by the kernel after cr0.wp has changed to 1, we make
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 3d16bcc87585..1880cf77059b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 0
<span class="p_del">-SUBLEVEL = 4</span>
<span class="p_add">+SUBLEVEL = 5</span>
 EXTRAVERSION =
 NAME = Hurr durr I&#39;ma sheep
 
<span class="p_header">diff --git a/arch/arc/include/asm/atomic.h b/arch/arc/include/asm/atomic.h</span>
<span class="p_header">index 067551b6920a..9917a45fc430 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static inline void atomic_##op(int i, atomic_t *v)			\</span>
 	atomic_ops_unlock(flags);					\
 }
 
<span class="p_del">-#define ATOMIC_OP_RETURN(op, c_op)					\</span>
<span class="p_add">+#define ATOMIC_OP_RETURN(op, c_op, asm_op)				\</span>
 static inline int atomic_##op##_return(int i, atomic_t *v)		\
 {									\
 	unsigned long flags;						\
<span class="p_header">diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile</span>
<span class="p_header">index a1c776b8dcec..992ea0b063d5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/Makefile</span>
<span class="p_header">+++ b/arch/arm/boot/dts/Makefile</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> dtb-$(CONFIG_SOC_IMX25) += \</span>
 	imx25-eukrea-mbimxsd25-baseboard-dvi-vga.dtb \
 	imx25-karo-tx25.dtb \
 	imx25-pdk.dtb
<span class="p_del">-dtb-$(CONFIG_SOC_IMX31) += \</span>
<span class="p_add">+dtb-$(CONFIG_SOC_IMX27) += \</span>
 	imx27-apf27.dtb \
 	imx27-apf27dev.dtb \
 	imx27-eukrea-mbimxsd27-baseboard.dtb \
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4412-trats2.dts b/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_header">index 173ffa479ad3..792394dd0f2a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4412-trats2.dts</span>
<span class="p_chunk">@@ -736,7 +736,7 @@</span> <span class="p_context"></span>
 
 			display-timings {
 				timing-0 {
<span class="p_del">-					clock-frequency = &lt;0&gt;;</span>
<span class="p_add">+					clock-frequency = &lt;57153600&gt;;</span>
 					hactive = &lt;720&gt;;
 					vactive = &lt;1280&gt;;
 					hfront-porch = &lt;5&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx27.dtsi b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">index 4b063b68db44..9ce1d2128749 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx27.dtsi</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"></span>
 
 			fec: ethernet@1002b000 {
 				compatible = &quot;fsl,imx27-fec&quot;;
<span class="p_del">-				reg = &lt;0x1002b000 0x4000&gt;;</span>
<span class="p_add">+				reg = &lt;0x1002b000 0x1000&gt;;</span>
 				interrupts = &lt;50&gt;;
 				clocks = &lt;&amp;clks IMX27_CLK_FEC_IPG_GATE&gt;,
 					 &lt;&amp;clks IMX27_CLK_FEC_AHB_GATE&gt;;
<span class="p_header">diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S</span>
<span class="p_header">index f8ccc21fa032..4e7f40c577e6 100644</span>
<span class="p_header">--- a/arch/arm/kernel/entry-common.S</span>
<span class="p_header">+++ b/arch/arm/kernel/entry-common.S</span>
<span class="p_chunk">@@ -33,7 +33,9 @@</span> <span class="p_context"> ret_fast_syscall:</span>
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	disable_irq				@ disable interrupts
<span class="p_del">-	ldr	r1, [tsk, #TI_FLAGS]</span>
<span class="p_add">+	ldr	r1, [tsk, #TI_FLAGS]		@ re-check for syscall tracing</span>
<span class="p_add">+	tst	r1, #_TIF_SYSCALL_WORK</span>
<span class="p_add">+	bne	__sys_trace_return</span>
 	tst	r1, #_TIF_WORK_MASK
 	bne	fast_work_pending
 	asm_trace_hardirqs_on
<span class="p_header">diff --git a/arch/arm/mach-exynos/pm_domains.c b/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_header">index 37266a826437..1f02bcb350e5 100644</span>
<span class="p_header">--- a/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_header">+++ b/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> no_clk:</span>
 		args.np = np;
 		args.args_count = 0;
 		child_domain = of_genpd_get_from_provider(&amp;args);
<span class="p_del">-		if (!child_domain)</span>
<span class="p_add">+		if (IS_ERR(child_domain))</span>
 			continue;
 
 		if (of_parse_phandle_with_args(np, &quot;power-domains&quot;,
<span class="p_chunk">@@ -177,7 +177,7 @@</span> <span class="p_context"> no_clk:</span>
 			continue;
 
 		parent_domain = of_genpd_get_from_provider(&amp;args);
<span class="p_del">-		if (!parent_domain)</span>
<span class="p_add">+		if (IS_ERR(parent_domain))</span>
 			continue;
 
 		if (pm_genpd_add_subdomain(parent_domain, child_domain))
<span class="p_header">diff --git a/arch/arm/mach-exynos/sleep.S b/arch/arm/mach-exynos/sleep.S</span>
<span class="p_header">index 31d25834b9c4..cf950790fbdc 100644</span>
<span class="p_header">--- a/arch/arm/mach-exynos/sleep.S</span>
<span class="p_header">+++ b/arch/arm/mach-exynos/sleep.S</span>
<span class="p_chunk">@@ -23,14 +23,7 @@</span> <span class="p_context"></span>
 #define CPU_MASK	0xff0ffff0
 #define CPU_CORTEX_A9	0x410fc090
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The following code is located into the .data section. This is to</span>
<span class="p_del">-	 * allow l2x0_regs_phys to be accessed with a relative load while we</span>
<span class="p_del">-	 * can&#39;t rely on any MMU translation. We could have put l2x0_regs_phys</span>
<span class="p_del">-	 * in the .text section as well, but some setups might insist on it to</span>
<span class="p_del">-	 * be truly read-only. (Reference from: arch/arm/kernel/sleep.S)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	.data</span>
<span class="p_add">+	.text</span>
 	.align
 
 	/*
<span class="p_chunk">@@ -69,10 +62,12 @@</span> <span class="p_context"> ENTRY(exynos_cpu_resume_ns)</span>
 	cmp	r0, r1
 	bne	skip_cp15
 
<span class="p_del">-	adr	r0, cp15_save_power</span>
<span class="p_add">+	adr	r0, _cp15_save_power</span>
 	ldr	r1, [r0]
<span class="p_del">-	adr	r0, cp15_save_diag</span>
<span class="p_add">+	ldr	r1, [r0, r1]</span>
<span class="p_add">+	adr	r0, _cp15_save_diag</span>
 	ldr	r2, [r0]
<span class="p_add">+	ldr	r2, [r0, r2]</span>
 	mov	r0, #SMC_CMD_C15RESUME
 	dsb
 	smc	#0
<span class="p_chunk">@@ -118,14 +113,20 @@</span> <span class="p_context"> skip_l2x0:</span>
 skip_cp15:
 	b	cpu_resume
 ENDPROC(exynos_cpu_resume_ns)
<span class="p_add">+</span>
<span class="p_add">+	.align</span>
<span class="p_add">+_cp15_save_power:</span>
<span class="p_add">+	.long	cp15_save_power - .</span>
<span class="p_add">+_cp15_save_diag:</span>
<span class="p_add">+	.long	cp15_save_diag - .</span>
<span class="p_add">+#ifdef CONFIG_CACHE_L2X0</span>
<span class="p_add">+1:	.long	l2x0_saved_regs - .</span>
<span class="p_add">+#endif /* CONFIG_CACHE_L2X0 */</span>
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
 	.globl cp15_save_diag
 cp15_save_diag:
 	.long	0	@ cp15 diagnostic
 	.globl cp15_save_power
 cp15_save_power:
 	.long	0	@ cp15 power control
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_CACHE_L2X0</span>
<span class="p_del">-	.align</span>
<span class="p_del">-1:	.long	l2x0_saved_regs - .</span>
<span class="p_del">-#endif /* CONFIG_CACHE_L2X0 */</span>
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 4e6ef896c619..7186382672b5 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -1112,22 +1112,22 @@</span> <span class="p_context"> void __init sanity_check_meminfo(void)</span>
 			}
 
 			/*
<span class="p_del">-			 * Find the first non-section-aligned page, and point</span>
<span class="p_add">+			 * Find the first non-pmd-aligned page, and point</span>
 			 * memblock_limit at it. This relies on rounding the
<span class="p_del">-			 * limit down to be section-aligned, which happens at</span>
<span class="p_del">-			 * the end of this function.</span>
<span class="p_add">+			 * limit down to be pmd-aligned, which happens at the</span>
<span class="p_add">+			 * end of this function.</span>
 			 *
 			 * With this algorithm, the start or end of almost any
<span class="p_del">-			 * bank can be non-section-aligned. The only exception</span>
<span class="p_del">-			 * is that the start of the bank 0 must be section-</span>
<span class="p_add">+			 * bank can be non-pmd-aligned. The only exception is</span>
<span class="p_add">+			 * that the start of the bank 0 must be section-</span>
 			 * aligned, since otherwise memory would need to be
 			 * allocated when mapping the start of bank 0, which
 			 * occurs before any free memory is mapped.
 			 */
 			if (!memblock_limit) {
<span class="p_del">-				if (!IS_ALIGNED(block_start, SECTION_SIZE))</span>
<span class="p_add">+				if (!IS_ALIGNED(block_start, PMD_SIZE))</span>
 					memblock_limit = block_start;
<span class="p_del">-				else if (!IS_ALIGNED(block_end, SECTION_SIZE))</span>
<span class="p_add">+				else if (!IS_ALIGNED(block_end, PMD_SIZE))</span>
 					memblock_limit = arm_lowmem_limit;
 			}
 
<span class="p_chunk">@@ -1137,12 +1137,12 @@</span> <span class="p_context"> void __init sanity_check_meminfo(void)</span>
 	high_memory = __va(arm_lowmem_limit - 1) + 1;
 
 	/*
<span class="p_del">-	 * Round the memblock limit down to a section size.  This</span>
<span class="p_add">+	 * Round the memblock limit down to a pmd size.  This</span>
 	 * helps to ensure that we will allocate memory from the
<span class="p_del">-	 * last full section, which should be mapped.</span>
<span class="p_add">+	 * last full pmd, which should be mapped.</span>
 	 */
 	if (memblock_limit)
<span class="p_del">-		memblock_limit = round_down(memblock_limit, SECTION_SIZE);</span>
<span class="p_add">+		memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
 	if (!memblock_limit)
 		memblock_limit = arm_lowmem_limit;
 
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index edba042b2325..dc6a4842683a 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> emit_cond_jmp:</span>
 			return -EINVAL;
 		}
 
<span class="p_del">-		imm64 = (u64)insn1.imm &lt;&lt; 32 | imm;</span>
<span class="p_add">+		imm64 = (u64)insn1.imm &lt;&lt; 32 | (u32)imm;</span>
 		emit_a64_mov_i64(dst, imm64, ctx);
 
 		return 1;
<span class="p_header">diff --git a/arch/mips/kernel/elf.c b/arch/mips/kernel/elf.c</span>
<span class="p_header">index d2c09f6475c5..f20cedcb50f1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/elf.c</span>
<span class="p_header">+++ b/arch/mips/kernel/elf.c</span>
<span class="p_chunk">@@ -76,14 +76,6 @@</span> <span class="p_context"> int arch_elf_pt_proc(void *_ehdr, void *_phdr, struct file *elf,</span>
 
 	/* Lets see if this is an O32 ELF */
 	if (ehdr32-&gt;e_ident[EI_CLASS] == ELFCLASS32) {
<span class="p_del">-		/* FR = 1 for N32 */</span>
<span class="p_del">-		if (ehdr32-&gt;e_flags &amp; EF_MIPS_ABI2)</span>
<span class="p_del">-			state-&gt;overall_fp_mode = FP_FR1;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			/* Set a good default FPU mode for O32 */</span>
<span class="p_del">-			state-&gt;overall_fp_mode = cpu_has_mips_r6 ?</span>
<span class="p_del">-				FP_FRE : FP_FR0;</span>
<span class="p_del">-</span>
 		if (ehdr32-&gt;e_flags &amp; EF_MIPS_FP64) {
 			/*
 			 * Set MIPS_ABI_FP_OLD_64 for EF_MIPS_FP64. We will override it
<span class="p_chunk">@@ -104,9 +96,6 @@</span> <span class="p_context"> int arch_elf_pt_proc(void *_ehdr, void *_phdr, struct file *elf,</span>
 				  (char *)&amp;abiflags,
 				  sizeof(abiflags));
 	} else {
<span class="p_del">-		/* FR=1 is really the only option for 64-bit */</span>
<span class="p_del">-		state-&gt;overall_fp_mode = FP_FR1;</span>
<span class="p_del">-</span>
 		if (phdr64-&gt;p_type != PT_MIPS_ABIFLAGS)
 			return 0;
 		if (phdr64-&gt;p_filesz &lt; sizeof(abiflags))
<span class="p_chunk">@@ -147,6 +136,7 @@</span> <span class="p_context"> int arch_check_elf(void *_ehdr, bool has_interpreter,</span>
 	struct elf32_hdr *ehdr = _ehdr;
 	struct mode_req prog_req, interp_req;
 	int fp_abi, interp_fp_abi, abi0, abi1, max_abi;
<span class="p_add">+	bool is_mips64;</span>
 
 	if (!config_enabled(CONFIG_MIPS_O32_FP64_SUPPORT))
 		return 0;
<span class="p_chunk">@@ -162,10 +152,22 @@</span> <span class="p_context"> int arch_check_elf(void *_ehdr, bool has_interpreter,</span>
 		abi0 = abi1 = fp_abi;
 	}
 
<span class="p_del">-	/* ABI limits. O32 = FP_64A, N32/N64 = FP_SOFT */</span>
<span class="p_del">-	max_abi = ((ehdr-&gt;e_ident[EI_CLASS] == ELFCLASS32) &amp;&amp;</span>
<span class="p_del">-		   (!(ehdr-&gt;e_flags &amp; EF_MIPS_ABI2))) ?</span>
<span class="p_del">-		MIPS_ABI_FP_64A : MIPS_ABI_FP_SOFT;</span>
<span class="p_add">+	is_mips64 = (ehdr-&gt;e_ident[EI_CLASS] == ELFCLASS64) ||</span>
<span class="p_add">+		    (ehdr-&gt;e_flags &amp; EF_MIPS_ABI2);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_mips64) {</span>
<span class="p_add">+		/* MIPS64 code always uses FR=1, thus the default is easy */</span>
<span class="p_add">+		state-&gt;overall_fp_mode = FP_FR1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Disallow access to the various FPXX &amp; FP64 ABIs */</span>
<span class="p_add">+		max_abi = MIPS_ABI_FP_SOFT;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Default to a mode capable of running code expecting FR=0 */</span>
<span class="p_add">+		state-&gt;overall_fp_mode = cpu_has_mips_r6 ? FP_FRE : FP_FR0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Allow all ABIs we know about */</span>
<span class="p_add">+		max_abi = MIPS_ABI_FP_64A;</span>
<span class="p_add">+	}</span>
 
 	if ((abi0 &gt; max_abi &amp;&amp; abi0 != MIPS_ABI_FP_UNKNOWN) ||
 	    (abi1 &gt; max_abi &amp;&amp; abi1 != MIPS_ABI_FP_UNKNOWN))
<span class="p_header">diff --git a/arch/parisc/include/asm/elf.h b/arch/parisc/include/asm/elf.h</span>
<span class="p_header">index 3391d061eccc..78c9fd32c554 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/elf.h</span>
<span class="p_chunk">@@ -348,6 +348,10 @@</span> <span class="p_context"> struct pt_regs;	/* forward declaration... */</span>
 
 #define ELF_HWCAP	0
 
<span class="p_add">+#define STACK_RND_MASK	(is_32bit_task() ? \</span>
<span class="p_add">+				0x7ff &gt;&gt; (PAGE_SHIFT - 12) : \</span>
<span class="p_add">+				0x3ffff &gt;&gt; (PAGE_SHIFT - 12))</span>
<span class="p_add">+</span>
 struct mm_struct;
 extern unsigned long arch_randomize_brk(struct mm_struct *);
 #define arch_randomize_brk arch_randomize_brk
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index e1ffea2f9a0b..5aba01ac457f 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -77,6 +77,9 @@</span> <span class="p_context"> static unsigned long mmap_upper_limit(void)</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	return PAGE_ALIGN(STACK_TOP - stack_base);
 }
 
<span class="p_header">diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c</span>
<span class="p_header">index 15c99b649b04..b2eb4686bd8f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/mce.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/mce.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> void save_mce_event(struct pt_regs *regs, long handled,</span>
 		    uint64_t nip, uint64_t addr)
 {
 	uint64_t srr1;
<span class="p_del">-	int index = __this_cpu_inc_return(mce_nest_count);</span>
<span class="p_add">+	int index = __this_cpu_inc_return(mce_nest_count) - 1;</span>
 	struct machine_check_event *mce = this_cpu_ptr(&amp;mce_event[index]);
 
 	/*
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> void machine_check_queue_event(void)</span>
 	if (!get_mce_event(&amp;evt, MCE_EVENT_RELEASE))
 		return;
 
<span class="p_del">-	index = __this_cpu_inc_return(mce_queue_count);</span>
<span class="p_add">+	index = __this_cpu_inc_return(mce_queue_count) - 1;</span>
 	/* If queue is full, just return for now. */
 	if (index &gt;= MAX_MC_EVT) {
 		__this_cpu_dec(mce_queue_count);
<span class="p_header">diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">index f096e72262f4..1db685104ffc 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.opd)
 	}
 
<span class="p_add">+	. = ALIGN(256);</span>
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 #ifndef CONFIG_RELOCATABLE
<span class="p_header">diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">index 7940dc90e80b..b258110da952 100644</span>
<span class="p_header">--- a/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">+++ b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_chunk">@@ -16,11 +16,12 @@</span> <span class="p_context"></span>
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
<span class="p_del">-	u8 icv[16];</span>
<span class="p_del">-	u8 key[16];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 };
 
 struct ghash_desc_ctx {
<span class="p_add">+	u8 icv[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
<span class="p_chunk">@@ -28,8 +29,10 @@</span> <span class="p_context"> struct ghash_desc_ctx {</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_add">+	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
 	memset(dctx, 0, sizeof(*dctx));
<span class="p_add">+	memcpy(dctx-&gt;key, ctx-&gt;key, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -45,7 +48,6 @@</span> <span class="p_context"> static int ghash_setkey(struct crypto_shash *tfm,</span>
 	}
 
 	memcpy(ctx-&gt;key, key, GHASH_BLOCK_SIZE);
<span class="p_del">-	memset(ctx-&gt;icv, 0, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -54,7 +56,6 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	unsigned int n;
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 		src += n;
 
 		if (!dctx-&gt;bytes) {
<span class="p_del">-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,</span>
<span class="p_add">+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,</span>
 					      GHASH_BLOCK_SIZE);
 			if (ret != GHASH_BLOCK_SIZE)
 				return -EIO;
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 
 	n = srclen &amp; ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);</span>
 		if (ret != n)
 			return -EIO;
 		src += n;
<span class="p_chunk">@@ -94,7 +95,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 	return 0;
 }
 
<span class="p_del">-static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
<span class="p_add">+static int ghash_flush(struct ghash_desc_ctx *dctx)</span>
 {
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -104,24 +105,24 @@</span> <span class="p_context"> static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
 
 		memset(pos, 0, dctx-&gt;bytes);
 
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);</span>
 		if (ret != GHASH_BLOCK_SIZE)
 			return -EIO;
<span class="p_add">+</span>
<span class="p_add">+		dctx-&gt;bytes = 0;</span>
 	}
 
<span class="p_del">-	dctx-&gt;bytes = 0;</span>
 	return 0;
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	int ret;
 
<span class="p_del">-	ret = ghash_flush(ctx, dctx);</span>
<span class="p_add">+	ret = ghash_flush(dctx);</span>
 	if (!ret)
<span class="p_del">-		memcpy(dst, ctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		memcpy(dst, dctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/s390/include/asm/pgtable.h b/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">index e08ec38f8c6e..e10112da008d 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static inline int pmd_large(pmd_t pmd)</span>
 	return (pmd_val(pmd) &amp; _SEGMENT_ENTRY_LARGE) != 0;
 }
 
<span class="p_del">-static inline int pmd_pfn(pmd_t pmd)</span>
<span class="p_add">+static inline unsigned long pmd_pfn(pmd_t pmd)</span>
 {
 	unsigned long origin_mask;
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index a236e39cc385..1c0fb570b5c2 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> union kvm_mmu_page_role {</span>
 		unsigned nxe:1;
 		unsigned cr0_wp:1;
 		unsigned smep_andnot_wp:1;
<span class="p_add">+		unsigned smap_andnot_wp:1;</span>
 	};
 };
 
<span class="p_chunk">@@ -404,6 +405,7 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	struct kvm_mmu_memory_cache mmu_page_header_cache;
 
 	struct fpu guest_fpu;
<span class="p_add">+	bool eager_fpu;</span>
 	u64 xcr0;
 	u64 guest_supported_xcr0;
 	u32 guest_xstate_size;
<span class="p_chunk">@@ -735,6 +737,7 @@</span> <span class="p_context"> struct kvm_x86_ops {</span>
 	void (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);
 	unsigned long (*get_rflags)(struct kvm_vcpu *vcpu);
 	void (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);
<span class="p_add">+	void (*fpu_activate)(struct kvm_vcpu *vcpu);</span>
 	void (*fpu_deactivate)(struct kvm_vcpu *vcpu);
 
 	void (*tlb_flush)(struct kvm_vcpu *vcpu);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index 3c036cb4a370..11dd8f23fcea 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -705,6 +705,7 @@</span> <span class="p_context"> static int mce_no_way_out(struct mce *m, char **msg, unsigned long *validp,</span>
 			  struct pt_regs *regs)
 {
 	int i, ret = 0;
<span class="p_add">+	char *tmp;</span>
 
 	for (i = 0; i &lt; mca_cfg.banks; i++) {
 		m-&gt;status = mce_rdmsrl(MSR_IA32_MCx_STATUS(i));
<span class="p_chunk">@@ -713,9 +714,11 @@</span> <span class="p_context"> static int mce_no_way_out(struct mce *m, char **msg, unsigned long *validp,</span>
 			if (quirk_no_way_out)
 				quirk_no_way_out(i, m, regs);
 		}
<span class="p_del">-		if (mce_severity(m, mca_cfg.tolerant, msg, true) &gt;=</span>
<span class="p_del">-		    MCE_PANIC_SEVERITY)</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mce_severity(m, mca_cfg.tolerant, &amp;tmp, true) &gt;= MCE_PANIC_SEVERITY) {</span>
<span class="p_add">+			*msg = tmp;</span>
 			ret = 1;
<span class="p_add">+		}</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_rapl.c b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">index c4bb8b8e5017..76d8cbe5a10f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_chunk">@@ -680,6 +680,7 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 		break;
 	case 60: /* Haswell */
 	case 69: /* Haswell-Celeron */
<span class="p_add">+	case 61: /* Broadwell */</span>
 		rapl_cntr_mask = RAPL_IDX_HSW;
 		rapl_pmu_events_group.attrs = rapl_events_hsw_attr;
 		break;
<span class="p_header">diff --git a/arch/x86/kernel/i387.c b/arch/x86/kernel/i387.c</span>
<span class="p_header">index d5651fce0b71..f341d56b7883 100644</span>
<span class="p_header">--- a/arch/x86/kernel/i387.c</span>
<span class="p_header">+++ b/arch/x86/kernel/i387.c</span>
<span class="p_chunk">@@ -169,6 +169,21 @@</span> <span class="p_context"> static void init_thread_xstate(void)</span>
 		xstate_size = sizeof(struct i387_fxsave_struct);
 	else
 		xstate_size = sizeof(struct i387_fsave_struct);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quirk: we don&#39;t yet handle the XSAVES* instructions</span>
<span class="p_add">+	 * correctly, as we don&#39;t correctly convert between</span>
<span class="p_add">+	 * standard and compacted format when interfacing</span>
<span class="p_add">+	 * with user-space - so disable it for now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The difference is small: with recent CPUs the</span>
<span class="p_add">+	 * compacted format is only marginally smaller than</span>
<span class="p_add">+	 * the standard FPU state format.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * ( This is easy to backport while we are fixing</span>
<span class="p_add">+	 *   XSAVES* support. )</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_XSAVES);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c</span>
<span class="p_header">index 8a80737ee6e6..307f9ec28e08 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.c</span>
<span class="p_chunk">@@ -16,6 +16,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_add">+#include &lt;asm/i387.h&gt; /* For use_eager_fpu.  Ugh! */</span>
<span class="p_add">+#include &lt;asm/fpu-internal.h&gt; /* For use_eager_fpu.  Ugh! */</span>
 #include &lt;asm/user.h&gt;
 #include &lt;asm/xsave.h&gt;
 #include &quot;cpuid.h&quot;
<span class="p_chunk">@@ -95,6 +97,8 @@</span> <span class="p_context"> int kvm_update_cpuid(struct kvm_vcpu *vcpu)</span>
 	if (best &amp;&amp; (best-&gt;eax &amp; (F(XSAVES) | F(XSAVEC))))
 		best-&gt;ebx = xstate_required_size(vcpu-&gt;arch.xcr0, true);
 
<span class="p_add">+	vcpu-&gt;arch.eager_fpu = guest_cpuid_has_mpx(vcpu);</span>
<span class="p_add">+</span>
 	/*
 	 * The existing code assumes virtual address is 48-bit in the canonical
 	 * address checks; exit if it is ever changed.
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h</span>
<span class="p_header">index 4452eedfaedd..9bec2b8cdced 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.h</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.h</span>
<span class="p_chunk">@@ -111,4 +111,12 @@</span> <span class="p_context"> static inline bool guest_cpuid_has_rtm(struct kvm_vcpu *vcpu)</span>
 	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 	return best &amp;&amp; (best-&gt;ebx &amp; bit(X86_FEATURE_RTM));
 }
<span class="p_add">+</span>
<span class="p_add">+static inline bool guest_cpuid_has_mpx(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_cpuid_entry2 *best;</span>
<span class="p_add">+</span>
<span class="p_add">+	best = kvm_find_cpuid_entry(vcpu, 7, 0);</span>
<span class="p_add">+	return best &amp;&amp; (best-&gt;ebx &amp; bit(X86_FEATURE_MPX));</span>
<span class="p_add">+}</span>
 #endif
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index cee759299a35..88ee9282a57e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3736,8 +3736,8 @@</span> <span class="p_context"> static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,</span>
 	}
 }
 
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_del">-		struct kvm_mmu *mmu, bool ept)</span>
<span class="p_add">+static void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+				      struct kvm_mmu *mmu, bool ept)</span>
 {
 	unsigned bit, byte, pfec;
 	u8 map;
<span class="p_chunk">@@ -3918,6 +3918,7 @@</span> <span class="p_context"> static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)</span>
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)
 {
 	bool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);
<span class="p_add">+	bool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);</span>
 	struct kvm_mmu *context = &amp;vcpu-&gt;arch.mmu;
 
 	MMU_WARN_ON(VALID_PAGE(context-&gt;root_hpa));
<span class="p_chunk">@@ -3936,6 +3937,8 @@</span> <span class="p_context"> void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)</span>
 	context-&gt;base_role.cr0_wp  = is_write_protection(vcpu);
 	context-&gt;base_role.smep_andnot_wp
 		= smep &amp;&amp; !is_write_protection(vcpu);
<span class="p_add">+	context-&gt;base_role.smap_andnot_wp</span>
<span class="p_add">+		= smap &amp;&amp; !is_write_protection(vcpu);</span>
 }
 EXPORT_SYMBOL_GPL(kvm_init_shadow_mmu);
 
<span class="p_chunk">@@ -4207,12 +4210,18 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 		       const u8 *new, int bytes)
 {
 	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
<span class="p_del">-	union kvm_mmu_page_role mask = { .word = 0 };</span>
 	struct kvm_mmu_page *sp;
 	LIST_HEAD(invalid_list);
 	u64 entry, gentry, *spte;
 	int npte;
 	bool remote_flush, local_flush, zap_page;
<span class="p_add">+	union kvm_mmu_page_role mask = (union kvm_mmu_page_role) {</span>
<span class="p_add">+		.cr0_wp = 1,</span>
<span class="p_add">+		.cr4_pae = 1,</span>
<span class="p_add">+		.nxe = 1,</span>
<span class="p_add">+		.smep_andnot_wp = 1,</span>
<span class="p_add">+		.smap_andnot_wp = 1,</span>
<span class="p_add">+	};</span>
 
 	/*
 	 * If we don&#39;t have indirect shadow pages, it means no page is
<span class="p_chunk">@@ -4238,7 +4247,6 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 	++vcpu-&gt;kvm-&gt;stat.mmu_pte_write;
 	kvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);
 
<span class="p_del">-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;</span>
 	for_each_gfn_indirect_valid_sp(vcpu-&gt;kvm, sp, gfn) {
 		if (detect_write_misaligned(sp, gpa, bytes) ||
 		      detect_write_flooding(sp)) {
<span class="p_header">diff --git a/arch/x86/kvm/mmu.h b/arch/x86/kvm/mmu.h</span>
<span class="p_header">index c7d65637c851..0ada65ecddcf 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.h</span>
<span class="p_chunk">@@ -71,8 +71,6 @@</span> <span class="p_context"> enum {</span>
 int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct);
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu);
 void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly);
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
<span class="p_del">-		bool ept);</span>
 
 static inline unsigned int kvm_mmu_available_pages(struct kvm *kvm)
 {
<span class="p_chunk">@@ -166,6 +164,8 @@</span> <span class="p_context"> static inline bool permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
 	int index = (pfec &gt;&gt; 1) +
 		    (smap &gt;&gt; (X86_EFLAGS_AC_BIT - PFERR_RSVD_BIT + 1));
 
<span class="p_add">+	WARN_ON(pfec &amp; PFERR_RSVD_MASK);</span>
<span class="p_add">+</span>
 	return (mmu-&gt;permissions[index] &gt;&gt; pte_access) &amp; 1;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">index fd49c867b25a..6e6d115fe9b5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">+++ b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_chunk">@@ -718,6 +718,13 @@</span> <span class="p_context"> static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code,</span>
 					      mmu_is_nested(vcpu));
 		if (likely(r != RET_MMIO_PF_INVALID))
 			return r;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * page fault with PFEC.RSVD  = 1 is caused by shadow</span>
<span class="p_add">+		 * page fault, should not be used to walk guest page</span>
<span class="p_add">+		 * table.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		error_code &amp;= ~PFERR_RSVD_MASK;</span>
 	};
 
 	r = mmu_topup_memory_caches(vcpu);
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index cc618c882f90..a4e62fcfabcb 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -4374,6 +4374,7 @@</span> <span class="p_context"> static struct kvm_x86_ops svm_x86_ops = {</span>
 	.cache_reg = svm_cache_reg,
 	.get_rflags = svm_get_rflags,
 	.set_rflags = svm_set_rflags,
<span class="p_add">+	.fpu_activate = svm_fpu_activate,</span>
 	.fpu_deactivate = svm_fpu_deactivate,
 
 	.tlb_flush = svm_flush_tlb,
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index a60bd3aa0965..5318d64674b0 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -10179,6 +10179,7 @@</span> <span class="p_context"> static struct kvm_x86_ops vmx_x86_ops = {</span>
 	.cache_reg = vmx_cache_reg,
 	.get_rflags = vmx_get_rflags,
 	.set_rflags = vmx_set_rflags,
<span class="p_add">+	.fpu_activate = vmx_fpu_activate,</span>
 	.fpu_deactivate = vmx_fpu_deactivate,
 
 	.tlb_flush = vmx_flush_tlb,
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index e222ba5d2beb..8838057da9c3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -702,8 +702,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_set_xcr);</span>
 int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 {
 	unsigned long old_cr4 = kvm_read_cr4(vcpu);
<span class="p_del">-	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |</span>
<span class="p_del">-				   X86_CR4_PAE | X86_CR4_SMEP;</span>
<span class="p_add">+	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |</span>
<span class="p_add">+				   X86_CR4_SMEP | X86_CR4_SMAP;</span>
<span class="p_add">+</span>
 	if (cr4 &amp; CR4_RESERVED_BITS)
 		return 1;
 
<span class="p_chunk">@@ -744,9 +745,6 @@</span> <span class="p_context"> int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)</span>
 	    (!(cr4 &amp; X86_CR4_PCIDE) &amp;&amp; (old_cr4 &amp; X86_CR4_PCIDE)))
 		kvm_mmu_reset_context(vcpu);
 
<span class="p_del">-	if ((cr4 ^ old_cr4) &amp; X86_CR4_SMAP)</span>
<span class="p_del">-		update_permission_bitmask(vcpu, vcpu-&gt;arch.walk_mmu, false);</span>
<span class="p_del">-</span>
 	if ((cr4 ^ old_cr4) &amp; X86_CR4_OSXSAVE)
 		kvm_update_cpuid(vcpu);
 
<span class="p_chunk">@@ -6141,6 +6139,8 @@</span> <span class="p_context"> void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)</span>
 		return;
 
 	page = gfn_to_page(vcpu-&gt;kvm, APIC_DEFAULT_PHYS_BASE &gt;&gt; PAGE_SHIFT);
<span class="p_add">+	if (is_error_page(page))</span>
<span class="p_add">+		return;</span>
 	kvm_x86_ops-&gt;set_apic_access_page_addr(vcpu, page_to_phys(page));
 
 	/*
<span class="p_chunk">@@ -6996,7 +6996,9 @@</span> <span class="p_context"> void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	fpu_save_init(&amp;vcpu-&gt;arch.guest_fpu);
 	__kernel_fpu_end();
 	++vcpu-&gt;stat.fpu_reload;
<span class="p_del">-	kvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);</span>
<span class="p_add">+	if (!vcpu-&gt;arch.eager_fpu)</span>
<span class="p_add">+		kvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);</span>
<span class="p_add">+</span>
 	trace_kvm_fpu(0);
 }
 
<span class="p_chunk">@@ -7012,11 +7014,21 @@</span> <span class="p_context"> void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)</span>
 struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
 						unsigned int id)
 {
<span class="p_add">+	struct kvm_vcpu *vcpu;</span>
<span class="p_add">+</span>
 	if (check_tsc_unstable() &amp;&amp; atomic_read(&amp;kvm-&gt;online_vcpus) != 0)
 		printk_once(KERN_WARNING
 		&quot;kvm: SMP vm created on host with unstable TSC; &quot;
 		&quot;guest TSC will not be reliable\n&quot;);
<span class="p_del">-	return kvm_x86_ops-&gt;vcpu_create(kvm, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	vcpu = kvm_x86_ops-&gt;vcpu_create(kvm, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Activate fpu unconditionally in case the guest needs eager FPU.  It will be</span>
<span class="p_add">+	 * deactivated soon if it doesn&#39;t.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_x86_ops-&gt;fpu_activate(vcpu);</span>
<span class="p_add">+	return vcpu;</span>
 }
 
 int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index f9eeae871593..5aa1f6e281d2 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 		request_mem_region(addr, length, desc);
 }
 
<span class="p_del">-static int __init acpi_reserve_resources(void)</span>
<span class="p_add">+static void __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -211,10 +211,7 @@</span> <span class="p_context"> static int __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
<span class="p_del">-device_initcall(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1845,6 +1842,7 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_add">+	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue(&quot;kacpi_hotplug&quot;, 0);
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 33bb06e006c9..adce56fa9cef 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> enum board_ids {</span>
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
<span class="p_add">+	board_ahci_avn,</span>
 	board_ahci_mcp65,
 	board_ahci_mcp77,
 	board_ahci_mcp89,
<span class="p_chunk">@@ -84,6 +85,8 @@</span> <span class="p_context"> enum board_ids {</span>
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline);</span>
 static void ahci_mcp89_apple_enable(struct pci_dev *pdev);
 static bool is_mcp89_apple(struct pci_dev *pdev);
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
<span class="p_chunk">@@ -107,6 +110,11 @@</span> <span class="p_context"> static struct ata_port_operations ahci_p5wdh_ops = {</span>
 	.hardreset		= ahci_p5wdh_hardreset,
 };
 
<span class="p_add">+static struct ata_port_operations ahci_avn_ops = {</span>
<span class="p_add">+	.inherits		= &amp;ahci_ops,</span>
<span class="p_add">+	.hardreset		= ahci_avn_hardreset,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] = {
<span class="p_chunk">@@ -151,6 +159,12 @@</span> <span class="p_context"> static const struct ata_port_info ahci_port_info[] = {</span>
 		.port_ops	= &amp;ahci_ops,
 	},
 	/* by chipsets */
<span class="p_add">+	[board_ahci_avn] = {</span>
<span class="p_add">+		.flags		= AHCI_FLAG_COMMON,</span>
<span class="p_add">+		.pio_mask	= ATA_PIO4,</span>
<span class="p_add">+		.udma_mask	= ATA_UDMA6,</span>
<span class="p_add">+		.port_ops	= &amp;ahci_avn_ops,</span>
<span class="p_add">+	},</span>
 	[board_ahci_mcp65] = {
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
 				 AHCI_HFLAG_YES_NCQ),
<span class="p_chunk">@@ -290,14 +304,14 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci }, /* Avoton RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn }, /* Avoton RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x2823), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x2827), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci }, /* Wellsburg AHCI */
<span class="p_chunk">@@ -670,6 +684,79 @@</span> <span class="p_context"> static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,</span>
 	return rc;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * ahci_avn_hardreset - attempt more aggressive recovery of Avoton ports.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It has been observed with some SSDs that the timing of events in the</span>
<span class="p_add">+ * link synchronization phase can leave the port in a state that can not</span>
<span class="p_add">+ * be recovered by a SATA-hard-reset alone.  The failing signature is</span>
<span class="p_add">+ * SStatus.DET stuck at 1 (&quot;Device presence detected but Phy</span>
<span class="p_add">+ * communication not established&quot;).  It was found that unloading and</span>
<span class="p_add">+ * reloading the driver when this problem occurs allows the drive</span>
<span class="p_add">+ * connection to be recovered (DET advanced to 0x3).  The critical</span>
<span class="p_add">+ * component of reloading the driver is that the port state machines are</span>
<span class="p_add">+ * reset by bouncing &quot;port enable&quot; in the AHCI PCS configuration</span>
<span class="p_add">+ * register.  So, reproduce that effect by bouncing a port whenever we</span>
<span class="p_add">+ * see DET==1 after a reset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned long *timing = sata_ehc_deb_timing(&amp;link-&gt;eh_context);</span>
<span class="p_add">+	struct ata_port *ap = link-&gt;ap;</span>
<span class="p_add">+	struct ahci_port_priv *pp = ap-&gt;private_data;</span>
<span class="p_add">+	struct ahci_host_priv *hpriv = ap-&gt;host-&gt;private_data;</span>
<span class="p_add">+	u8 *d2h_fis = pp-&gt;rx_fis + RX_FIS_D2H_REG;</span>
<span class="p_add">+	unsigned long tmo = deadline - jiffies;</span>
<span class="p_add">+	struct ata_taskfile tf;</span>
<span class="p_add">+	bool online;</span>
<span class="p_add">+	int rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;ENTER\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_stop_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		u16 val;</span>
<span class="p_add">+		u32 sstatus;</span>
<span class="p_add">+		int port = ap-&gt;port_no;</span>
<span class="p_add">+		struct ata_host *host = ap-&gt;host;</span>
<span class="p_add">+		struct pci_dev *pdev = to_pci_dev(host-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* clear D2H reception area to properly wait for D2H FIS */</span>
<span class="p_add">+		ata_tf_init(link-&gt;device, &amp;tf);</span>
<span class="p_add">+		tf.command = ATA_BUSY;</span>
<span class="p_add">+		ata_tf_to_fis(&amp;tf, 0, 0, d2h_fis);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = sata_link_hardreset(link, timing, deadline, &amp;online,</span>
<span class="p_add">+				ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sata_scr_read(link, SCR_STATUS, &amp;sstatus) != 0 ||</span>
<span class="p_add">+				(sstatus &amp; 0xf) != 1)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ata_link_printk(link, KERN_INFO, &quot;avn bounce port%d\n&quot;,</span>
<span class="p_add">+				port);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, 0x92, &amp;val);</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; port);</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		ata_msleep(ap, 1000);</span>
<span class="p_add">+		val |= 1 &lt;&lt; port;</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		deadline += tmo;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hpriv-&gt;start_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (online)</span>
<span class="p_add">+		*class = ahci_dev_classify(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;EXIT, rc=%d, class=%u\n&quot;, rc, *class);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 61a9c07e0dff..287c4ba0219f 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1707,8 +1707,7 @@</span> <span class="p_context"> static void ahci_handle_port_interrupt(struct ata_port *ap,</span>
 	if (unlikely(resetting))
 		status &amp;= ~PORT_IRQ_BAD_PMP;
 
<span class="p_del">-	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_del">-	if (ap-&gt;link.lpm_policy &gt; ATA_LPM_MAX_POWER) {</span>
<span class="p_add">+	if (sata_lpm_ignore_phy_events(&amp;ap-&gt;link)) {</span>
 		status &amp;= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&amp;ap-&gt;link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 23dac3babfe3..87b4b7f9fdc6 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4214,7 +4214,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*MX100*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_del">-	{ &quot;Samsung SSD 850 PRO*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 
 	/*
<span class="p_chunk">@@ -6728,6 +6728,38 @@</span> <span class="p_context"> u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,</span>
 	return tmp;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored</span>
<span class="p_add">+ *	@link: Link receiving the event</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Test whether the received PHY event has to be ignored or not.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	LOCKING:</span>
<span class="p_add">+ *	None:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	RETURNS:</span>
<span class="p_add">+ *	True if the event has to be ignored.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sata_lpm_ignore_phy_events(struct ata_link *link)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long lpm_timeout = link-&gt;last_lpm_change +</span>
<span class="p_add">+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_add">+	if (link-&gt;lpm_policy &gt; ATA_LPM_MAX_POWER)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ignore the first PHY event after the LPM policy changed</span>
<span class="p_add">+	 * as it is might be spurious</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((link-&gt;flags &amp; ATA_LFLAG_CHANGED) &amp;&amp;</span>
<span class="p_add">+	    time_before(jiffies, lpm_timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);</span>
<span class="p_add">+</span>
 /*
  * Dummy port_ops
  */
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index d2029a462e2c..89c3d83e1ca7 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -3489,6 +3489,9 @@</span> <span class="p_context"> static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,</span>
 		}
 	}
 
<span class="p_add">+	link-&gt;last_lpm_change = jiffies;</span>
<span class="p_add">+	link-&gt;flags |= ATA_LFLAG_CHANGED;</span>
<span class="p_add">+</span>
 	return 0;
 
 fail:
<span class="p_header">diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c</span>
<span class="p_header">index 237f23f68bfc..1daa0ea2f1ac 100644</span>
<span class="p_header">--- a/drivers/clk/clk.c</span>
<span class="p_header">+++ b/drivers/clk/clk.c</span>
<span class="p_chunk">@@ -1443,8 +1443,10 @@</span> <span class="p_context"> static struct clk_core *__clk_set_parent_before(struct clk_core *clk,</span>
 	 */
 	if (clk-&gt;prepare_count) {
 		clk_core_prepare(parent);
<span class="p_add">+		flags = clk_enable_lock();</span>
 		clk_core_enable(parent);
 		clk_core_enable(clk);
<span class="p_add">+		clk_enable_unlock(flags);</span>
 	}
 
 	/* update the clk tree topology */
<span class="p_chunk">@@ -1459,13 +1461,17 @@</span> <span class="p_context"> static void __clk_set_parent_after(struct clk_core *core,</span>
 				   struct clk_core *parent,
 				   struct clk_core *old_parent)
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
 	/*
 	 * Finish the migration of prepare state and undo the changes done
 	 * for preventing a race with clk_enable().
 	 */
 	if (core-&gt;prepare_count) {
<span class="p_add">+		flags = clk_enable_lock();</span>
 		clk_core_disable(core);
 		clk_core_disable(old_parent);
<span class="p_add">+		clk_enable_unlock(flags);</span>
 		clk_core_unprepare(old_parent);
 	}
 }
<span class="p_chunk">@@ -1489,8 +1495,10 @@</span> <span class="p_context"> static int __clk_set_parent(struct clk_core *clk, struct clk_core *parent,</span>
 		clk_enable_unlock(flags);
 
 		if (clk-&gt;prepare_count) {
<span class="p_add">+			flags = clk_enable_lock();</span>
 			clk_core_disable(clk);
 			clk_core_disable(parent);
<span class="p_add">+			clk_enable_unlock(flags);</span>
 			clk_core_unprepare(parent);
 		}
 		return ret;
<span class="p_header">diff --git a/drivers/clk/samsung/clk-exynos5420.c b/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_header">index 07d666cc6a29..bea4a173eef5 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> static const struct samsung_clk_reg_dump exynos5420_set_clksrc[] = {</span>
 	{ .offset = SRC_MASK_PERIC0,		.value = 0x11111110, },
 	{ .offset = SRC_MASK_PERIC1,		.value = 0x11111100, },
 	{ .offset = SRC_MASK_ISP,		.value = 0x11111000, },
<span class="p_add">+	{ .offset = GATE_BUS_TOP,		.value = 0xffffffff, },</span>
 	{ .offset = GATE_BUS_DISP1,		.value = 0xffffffff, },
 	{ .offset = GATE_IP_PERIC,		.value = 0xffffffff, },
 };
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 2eebd28b4c40..ccc20188f00c 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -499,18 +499,19 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 	buf += 16;
 
 	if (memcmp(buf, &quot;_DMI_&quot;, 5) == 0 &amp;&amp; dmi_checksum(buf, 15)) {
<span class="p_add">+		if (smbios_ver)</span>
<span class="p_add">+			dmi_ver = smbios_ver;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);</span>
 		dmi_num = get_unaligned_le16(buf + 12);
 		dmi_len = get_unaligned_le16(buf + 6);
 		dmi_base = get_unaligned_le32(buf + 8);
 
 		if (dmi_walk_early(dmi_decode) == 0) {
 			if (smbios_ver) {
<span class="p_del">-				dmi_ver = smbios_ver;</span>
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			} else {
<span class="p_del">-				dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 |</span>
<span class="p_del">-					   (buf[14] &amp; 0x0F);</span>
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			}
<span class="p_header">diff --git a/drivers/gpio/gpio-kempld.c b/drivers/gpio/gpio-kempld.c</span>
<span class="p_header">index 443518f63f15..a6b0def4bd7b 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-kempld.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-kempld.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int kempld_gpio_get_direction(struct gpio_chip *chip, unsigned offset)</span>
 		= container_of(chip, struct kempld_gpio_data, chip);
 	struct kempld_device_data *pld = gpio-&gt;pld;
 
<span class="p_del">-	return kempld_gpio_get_bit(pld, KEMPLD_GPIO_DIR_NUM(offset), offset);</span>
<span class="p_add">+	return !kempld_gpio_get_bit(pld, KEMPLD_GPIO_DIR_NUM(offset), offset);</span>
 }
 
 static int kempld_gpio_pincount(struct kempld_device_data *pld)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_header">index 498399323a8c..406624a0b201 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c</span>
<span class="p_chunk">@@ -729,7 +729,7 @@</span> <span class="p_context"> static ssize_t node_show(struct kobject *kobj, struct attribute *attr,</span>
 				kfd2kgd-&gt;get_max_engine_clock_in_mhz(
 					dev-&gt;gpu-&gt;kgd));
 		sysfs_show_64bit_prop(buffer, &quot;local_mem_size&quot;,
<span class="p_del">-				kfd2kgd-&gt;get_vmem_size(dev-&gt;gpu-&gt;kgd));</span>
<span class="p_add">+				(unsigned long long int) 0);</span>
 
 		sysfs_show_32bit_prop(buffer, &quot;fw_version&quot;,
 				kfd2kgd-&gt;get_fw_version(
<span class="p_header">diff --git a/drivers/gpu/drm/drm_plane_helper.c b/drivers/gpu/drm/drm_plane_helper.c</span>
<span class="p_header">index 5ba5792bfdba..98b125763ecd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_plane_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_plane_helper.c</span>
<span class="p_chunk">@@ -476,6 +476,9 @@</span> <span class="p_context"> int drm_plane_helper_commit(struct drm_plane *plane,</span>
 		if (!crtc[i])
 			continue;
 
<span class="p_add">+		if (crtc[i]-&gt;cursor == plane)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		/* There&#39;s no other way to figure out whether the crtc is running. */
 		ret = drm_crtc_vblank_get(crtc[i]);
 		if (ret == 0) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 1afc0b419da2..965a45619f6b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -1789,7 +1789,9 @@</span> <span class="p_context"> static int radeon_get_shared_nondp_ppll(struct drm_crtc *crtc)</span>
 			if ((crtc-&gt;mode.clock == test_crtc-&gt;mode.clock) &amp;&amp;
 			    (adjusted_clock == test_adjusted_clock) &amp;&amp;
 			    (radeon_crtc-&gt;ss_enabled == test_radeon_crtc-&gt;ss_enabled) &amp;&amp;
<span class="p_del">-			    (test_radeon_crtc-&gt;pll_id != ATOM_PPLL_INVALID))</span>
<span class="p_add">+			    (test_radeon_crtc-&gt;pll_id != ATOM_PPLL_INVALID) &amp;&amp;</span>
<span class="p_add">+			    (drm_detect_monitor_audio(radeon_connector_edid(test_radeon_crtc-&gt;connector)) ==</span>
<span class="p_add">+			     drm_detect_monitor_audio(radeon_connector_edid(radeon_crtc-&gt;connector))))</span>
 				return test_radeon_crtc-&gt;pll_id;
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 8d74de82456e..8b2c4c890507 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -412,19 +412,21 @@</span> <span class="p_context"> bool radeon_dp_getdpcd(struct radeon_connector *radeon_connector)</span>
 {
 	struct radeon_connector_atom_dig *dig_connector = radeon_connector-&gt;con_priv;
 	u8 msg[DP_DPCD_SIZE];
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, i;</span>
 
<span class="p_del">-	ret = drm_dp_dpcd_read(&amp;radeon_connector-&gt;ddc_bus-&gt;aux, DP_DPCD_REV, msg,</span>
<span class="p_del">-			       DP_DPCD_SIZE);</span>
<span class="p_del">-	if (ret &gt; 0) {</span>
<span class="p_del">-		memcpy(dig_connector-&gt;dpcd, msg, DP_DPCD_SIZE);</span>
<span class="p_add">+	for (i = 0; i &lt; 7; i++) {</span>
<span class="p_add">+		ret = drm_dp_dpcd_read(&amp;radeon_connector-&gt;ddc_bus-&gt;aux, DP_DPCD_REV, msg,</span>
<span class="p_add">+				       DP_DPCD_SIZE);</span>
<span class="p_add">+		if (ret == DP_DPCD_SIZE) {</span>
<span class="p_add">+			memcpy(dig_connector-&gt;dpcd, msg, DP_DPCD_SIZE);</span>
 
<span class="p_del">-		DRM_DEBUG_KMS(&quot;DPCD: %*ph\n&quot;, (int)sizeof(dig_connector-&gt;dpcd),</span>
<span class="p_del">-			      dig_connector-&gt;dpcd);</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;DPCD: %*ph\n&quot;, (int)sizeof(dig_connector-&gt;dpcd),</span>
<span class="p_add">+				      dig_connector-&gt;dpcd);</span>
 
<span class="p_del">-		radeon_dp_probe_oui(radeon_connector);</span>
<span class="p_add">+			radeon_dp_probe_oui(radeon_connector);</span>
 
<span class="p_del">-		return true;</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
 	}
 	dig_connector-&gt;dpcd[0] = 0;
 	return false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 3e670d344a20..19aafb71fd8e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -5804,7 +5804,7 @@</span> <span class="p_context"> static int cik_pcie_gart_enable(struct radeon_device *rdev)</span>
 	/* restore context1-15 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	for (i = 1; i &lt; 16; i++) {
 		if (i &lt; 8)
 			WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen_hdmi.c b/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_header">index 0926739c9fa7..9953356fe263 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_chunk">@@ -400,7 +400,7 @@</span> <span class="p_context"> void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable)</span>
 	if (enable) {
 		struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 
<span class="p_del">-		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+		if (connector &amp;&amp; drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
 			WREG32(HDMI_INFOFRAME_CONTROL0 + dig-&gt;afmt-&gt;offset,
 			       HDMI_AVI_INFO_SEND | /* enable AVI info frames */
 			       HDMI_AVI_INFO_CONT | /* required for audio info values to be updated */
<span class="p_chunk">@@ -438,7 +438,8 @@</span> <span class="p_context"> void evergreen_dp_enable(struct drm_encoder *encoder, bool enable)</span>
 	if (!dig || !dig-&gt;afmt)
 		return;
 
<span class="p_del">-	if (enable &amp;&amp; drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+	if (enable &amp;&amp; connector &amp;&amp;</span>
<span class="p_add">+	    drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
 		struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 		struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 		struct radeon_connector_atom_dig *dig_connector;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index dab00812abaa..02d585455f49 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1272,7 +1272,8 @@</span> <span class="p_context"> static int cayman_pcie_gart_enable(struct radeon_device *rdev)</span>
 	 */
 	for (i = 1; i &lt; 8; i++) {
 		WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i &lt;&lt; 2), 0);
<span class="p_del">-		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2), rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2),</span>
<span class="p_add">+			rdev-&gt;vm_manager.max_pfn - 1);</span>
 		WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
 		       rdev-&gt;vm_manager.saved_table_addr[i]);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">index b7c6bb69f3c7..88c04bc0a7f6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_chunk">@@ -460,9 +460,6 @@</span> <span class="p_context"> void radeon_audio_detect(struct drm_connector *connector,</span>
 	if (!connector || !connector-&gt;encoder)
 		return;
 
<span class="p_del">-	if (!radeon_encoder_is_digital(connector-&gt;encoder))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	rdev = connector-&gt;encoder-&gt;dev-&gt;dev_private;
 
 	if (!radeon_audio_chipset_supported(rdev))
<span class="p_chunk">@@ -471,26 +468,26 @@</span> <span class="p_context"> void radeon_audio_detect(struct drm_connector *connector,</span>
 	radeon_encoder = to_radeon_encoder(connector-&gt;encoder);
 	dig = radeon_encoder-&gt;enc_priv;
 
<span class="p_del">-	if (!dig-&gt;afmt)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (status == connector_status_connected) {
<span class="p_del">-		struct radeon_connector *radeon_connector = to_radeon_connector(connector);</span>
<span class="p_add">+		struct radeon_connector *radeon_connector;</span>
<span class="p_add">+		int sink_type;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+			radeon_encoder-&gt;audio = NULL;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		radeon_connector = to_radeon_connector(connector);</span>
<span class="p_add">+		sink_type = radeon_dp_getsinktype(radeon_connector);</span>
 
 		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort &amp;&amp;
<span class="p_del">-		    radeon_dp_getsinktype(radeon_connector) ==</span>
<span class="p_del">-		    CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
<span class="p_add">+			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
 			radeon_encoder-&gt;audio = rdev-&gt;audio.dp_funcs;
 		else
 			radeon_encoder-&gt;audio = rdev-&gt;audio.hdmi_funcs;
 
 		dig-&gt;afmt-&gt;pin = radeon_audio_get_pin(connector-&gt;encoder);
<span class="p_del">-		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_del">-			radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0);</span>
<span class="p_del">-			dig-&gt;afmt-&gt;pin = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);</span>
 	} else {
 		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0);
 		dig-&gt;afmt-&gt;pin = NULL;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 27973e3faf0e..27def67cb6be 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1333,10 +1333,8 @@</span> <span class="p_context"> out:</span>
 	/* updated in get modes as well since we need to know if it&#39;s analog or digital */
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0) {</span>
<span class="p_del">-		radeon_connector_get_edid(connector);</span>
<span class="p_add">+	if (radeon_audio != 0)</span>
 		radeon_audio_detect(connector, ret);
<span class="p_del">-	}</span>
 
 exit:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_chunk">@@ -1661,10 +1659,8 @@</span> <span class="p_context"> radeon_dp_detect(struct drm_connector *connector, bool force)</span>
 
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0) {</span>
<span class="p_del">-		radeon_connector_get_edid(connector);</span>
<span class="p_add">+	if (radeon_audio != 0)</span>
 		radeon_audio_detect(connector, ret);
<span class="p_del">-	}</span>
 
 out:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index a7fb2735d4a9..f433491fab6f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -4288,7 +4288,7 @@</span> <span class="p_context"> static int si_pcie_gart_enable(struct radeon_device *rdev)</span>
 	/* empty context1-15 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	/* Assign the pt base to something valid for now; the pts used for
 	 * the VMs are determined by the application and setup and assigned
 	 * on the fly in the vm part of radeon_gart.c
<span class="p_header">diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">index e77658cd037c..2caf5b2f3446 100644</span>
<span class="p_header">--- a/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">+++ b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_chunk">@@ -39,7 +39,6 @@</span> <span class="p_context"> MODULE_AUTHOR(&quot;Nestor Lopez Casado &lt;nlopezcasad@logitech.com&gt;&quot;);</span>
 /* bits 1..20 are reserved for classes */
 #define HIDPP_QUIRK_DELAYED_INIT		BIT(21)
 #define HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS	BIT(22)
<span class="p_del">-#define HIDPP_QUIRK_MULTI_INPUT			BIT(23)</span>
 
 /*
  * There are two hidpp protocols in use, the first version hidpp10 is known
<span class="p_chunk">@@ -701,12 +700,6 @@</span> <span class="p_context"> static int wtp_input_mapping(struct hid_device *hdev, struct hid_input *hi,</span>
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
<span class="p_del">-	struct hidpp_device *hidpp = hid_get_drvdata(hdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT) &amp;&amp;</span>
<span class="p_del">-	    (field-&gt;application == HID_GD_KEYBOARD))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	return -1;
 }
 
<span class="p_chunk">@@ -715,10 +708,6 @@</span> <span class="p_context"> static void wtp_populate_input(struct hidpp_device *hidpp,</span>
 {
 	struct wtp_data *wd = hidpp-&gt;private_data;
 
<span class="p_del">-	if ((hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT) &amp;&amp; origin_is_hid_core)</span>
<span class="p_del">-		/* this is the generic hid-input call */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	__set_bit(EV_ABS, input_dev-&gt;evbit);
 	__set_bit(EV_KEY, input_dev-&gt;evbit);
 	__clear_bit(EV_REL, input_dev-&gt;evbit);
<span class="p_chunk">@@ -1234,10 +1223,6 @@</span> <span class="p_context"> static int hidpp_probe(struct hid_device *hdev, const struct hid_device_id *id)</span>
 	if (hidpp-&gt;quirks &amp; HIDPP_QUIRK_DELAYED_INIT)
 		connect_mask &amp;= ~HID_CONNECT_HIDINPUT;
 
<span class="p_del">-	/* Re-enable hidinput for multi-input devices */</span>
<span class="p_del">-	if (hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT)</span>
<span class="p_del">-		connect_mask |= HID_CONNECT_HIDINPUT;</span>
<span class="p_del">-</span>
 	ret = hid_hw_start(hdev, connect_mask);
 	if (ret) {
 		hid_err(hdev, &quot;%s:hid_hw_start returned error\n&quot;, __func__);
<span class="p_chunk">@@ -1285,11 +1270,6 @@</span> <span class="p_context"> static const struct hid_device_id hidpp_devices[] = {</span>
 	  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH,
 		USB_DEVICE_ID_LOGITECH_T651),
 	  .driver_data = HIDPP_QUIRK_CLASS_WTP },
<span class="p_del">-	{ /* Keyboard TK820 */</span>
<span class="p_del">-	  HID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_DJ_DEVICE,</span>
<span class="p_del">-		USB_VENDOR_ID_LOGITECH, 0x4102),</span>
<span class="p_del">-	  .driver_data = HIDPP_QUIRK_DELAYED_INIT | HIDPP_QUIRK_MULTI_INPUT |</span>
<span class="p_del">-			 HIDPP_QUIRK_CLASS_WTP },</span>
 
 	{ HID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_DJ_DEVICE,
 		USB_VENDOR_ID_LOGITECH, HID_ANY_ID)},
<span class="p_header">diff --git a/drivers/hwmon/nct6683.c b/drivers/hwmon/nct6683.c</span>
<span class="p_header">index f3830db02d46..37f01702d081 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct6683.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct6683.c</span>
<span class="p_chunk">@@ -439,6 +439,7 @@</span> <span class="p_context"> nct6683_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				 (*t)-&gt;dev_attr.attr.name, tg-&gt;base + i);
 			if ((*t)-&gt;s2) {
 				a2 = &amp;su-&gt;u.a2;
<span class="p_add">+				sysfs_attr_init(&amp;a2-&gt;dev_attr.attr);</span>
 				a2-&gt;dev_attr.attr.name = su-&gt;name;
 				a2-&gt;nr = (*t)-&gt;u.s.nr + i;
 				a2-&gt;index = (*t)-&gt;u.s.index;
<span class="p_chunk">@@ -449,6 +450,7 @@</span> <span class="p_context"> nct6683_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				*attrs = &amp;a2-&gt;dev_attr.attr;
 			} else {
 				a = &amp;su-&gt;u.a1;
<span class="p_add">+				sysfs_attr_init(&amp;a-&gt;dev_attr.attr);</span>
 				a-&gt;dev_attr.attr.name = su-&gt;name;
 				a-&gt;index = (*t)-&gt;u.index + i;
 				a-&gt;dev_attr.attr.mode =
<span class="p_header">diff --git a/drivers/hwmon/nct6775.c b/drivers/hwmon/nct6775.c</span>
<span class="p_header">index 1be41177b620..0773930c110e 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct6775.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct6775.c</span>
<span class="p_chunk">@@ -994,6 +994,7 @@</span> <span class="p_context"> nct6775_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				 (*t)-&gt;dev_attr.attr.name, tg-&gt;base + i);
 			if ((*t)-&gt;s2) {
 				a2 = &amp;su-&gt;u.a2;
<span class="p_add">+				sysfs_attr_init(&amp;a2-&gt;dev_attr.attr);</span>
 				a2-&gt;dev_attr.attr.name = su-&gt;name;
 				a2-&gt;nr = (*t)-&gt;u.s.nr + i;
 				a2-&gt;index = (*t)-&gt;u.s.index;
<span class="p_chunk">@@ -1004,6 +1005,7 @@</span> <span class="p_context"> nct6775_create_attr_group(struct device *dev, struct sensor_template_group *tg,</span>
 				*attrs = &amp;a2-&gt;dev_attr.attr;
 			} else {
 				a = &amp;su-&gt;u.a1;
<span class="p_add">+				sysfs_attr_init(&amp;a-&gt;dev_attr.attr);</span>
 				a-&gt;dev_attr.attr.name = su-&gt;name;
 				a-&gt;index = (*t)-&gt;u.index + i;
 				a-&gt;dev_attr.attr.mode =
<span class="p_header">diff --git a/drivers/hwmon/ntc_thermistor.c b/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_header">index 112e4d45e4a0..68800115876b 100644</span>
<span class="p_header">--- a/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_header">+++ b/drivers/hwmon/ntc_thermistor.c</span>
<span class="p_chunk">@@ -239,8 +239,10 @@</span> <span class="p_context"> static struct ntc_thermistor_platform_data *</span>
 ntc_thermistor_parse_dt(struct platform_device *pdev)
 {
 	struct iio_channel *chan;
<span class="p_add">+	enum iio_chan_type type;</span>
 	struct device_node *np = pdev-&gt;dev.of_node;
 	struct ntc_thermistor_platform_data *pdata;
<span class="p_add">+	int ret;</span>
 
 	if (!np)
 		return NULL;
<span class="p_chunk">@@ -253,6 +255,13 @@</span> <span class="p_context"> ntc_thermistor_parse_dt(struct platform_device *pdev)</span>
 	if (IS_ERR(chan))
 		return ERR_CAST(chan);
 
<span class="p_add">+	ret = iio_get_channel_type(chan, &amp;type);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ERR_PTR(ret);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IIO_VOLTAGE)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (of_property_read_u32(np, &quot;pullup-uv&quot;, &amp;pdata-&gt;pullup_uv))
 		return ERR_PTR(-ENODEV);
 	if (of_property_read_u32(np, &quot;pullup-ohm&quot;, &amp;pdata-&gt;pullup_ohm))
<span class="p_header">diff --git a/drivers/hwmon/tmp401.c b/drivers/hwmon/tmp401.c</span>
<span class="p_header">index 99664ebc738d..ccf4cffe0ee1 100644</span>
<span class="p_header">--- a/drivers/hwmon/tmp401.c</span>
<span class="p_header">+++ b/drivers/hwmon/tmp401.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sysfs.h&gt;
 
 /* Addresses to scan */
<span class="p_del">-static const unsigned short normal_i2c[] = { 0x37, 0x48, 0x49, 0x4a, 0x4c, 0x4d,</span>
<span class="p_add">+static const unsigned short normal_i2c[] = { 0x48, 0x49, 0x4a, 0x4c, 0x4d,</span>
 	0x4e, 0x4f, I2C_CLIENT_END };
 
 enum chips { tmp401, tmp411, tmp431, tmp432, tmp435 };
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index 53f32629283a..6805db0e4f07 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -465,6 +465,7 @@</span> <span class="p_context"> int st_accel_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;accel_info;
<span class="p_add">+	mutex_init(&amp;adata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/adc/axp288_adc.c b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">index 08bcfb061ca5..56008a86b78f 100644</span>
<span class="p_header">--- a/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_chunk">@@ -53,39 +53,42 @@</span> <span class="p_context"> static const struct iio_chan_spec const axp288_adc_channels[] = {</span>
 		.channel = 0,
 		.address = AXP288_TS_ADC_H,
 		.datasheet_name = &quot;TS_PIN&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_TEMP,
 		.channel = 1,
 		.address = AXP288_PMIC_ADC_H,
 		.datasheet_name = &quot;PMIC_TEMP&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_TEMP,
 		.channel = 2,
 		.address = AXP288_GP_ADC_H,
 		.datasheet_name = &quot;GPADC&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_CURRENT,
 		.channel = 3,
 		.address = AXP20X_BATT_CHRG_I_H,
 		.datasheet_name = &quot;BATT_CHG_I&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_CURRENT,
 		.channel = 4,
 		.address = AXP20X_BATT_DISCHRG_I_H,
 		.datasheet_name = &quot;BATT_DISCHRG_I&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_VOLTAGE,
 		.channel = 5,
 		.address = AXP20X_BATT_V_H,
 		.datasheet_name = &quot;BATT_V&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	},
 };
 
<span class="p_chunk">@@ -151,9 +154,6 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 						chan-&gt;address))
 			dev_err(&amp;indio_dev-&gt;dev, &quot;TS pin restore\n&quot;);
 		break;
<span class="p_del">-	case IIO_CHAN_INFO_PROCESSED:</span>
<span class="p_del">-		ret = axp288_adc_read_channel(val, chan-&gt;address, info-&gt;regmap);</span>
<span class="p_del">-		break;</span>
 	default:
 		ret = -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/iio/adc/cc10001_adc.c b/drivers/iio/adc/cc10001_adc.c</span>
<span class="p_header">index 51e2a83c9404..115f6e99a7fa 100644</span>
<span class="p_header">--- a/drivers/iio/adc/cc10001_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/cc10001_adc.c</span>
<span class="p_chunk">@@ -35,8 +35,9 @@</span> <span class="p_context"></span>
 #define CC10001_ADC_EOC_SET		BIT(0)
 
 #define CC10001_ADC_CHSEL_SAMPLED	0x0c
<span class="p_del">-#define CC10001_ADC_POWER_UP		0x10</span>
<span class="p_del">-#define CC10001_ADC_POWER_UP_SET	BIT(0)</span>
<span class="p_add">+#define CC10001_ADC_POWER_DOWN		0x10</span>
<span class="p_add">+#define CC10001_ADC_POWER_DOWN_SET	BIT(0)</span>
<span class="p_add">+</span>
 #define CC10001_ADC_DEBUG		0x14
 #define CC10001_ADC_DATA_COUNT		0x20
 
<span class="p_chunk">@@ -62,7 +63,6 @@</span> <span class="p_context"> struct cc10001_adc_device {</span>
 	u16 *buf;
 
 	struct mutex lock;
<span class="p_del">-	unsigned long channel_map;</span>
 	unsigned int start_delay_ns;
 	unsigned int eoc_delay_ns;
 };
<span class="p_chunk">@@ -79,6 +79,18 @@</span> <span class="p_context"> static inline u32 cc10001_adc_read_reg(struct cc10001_adc_device *adc_dev,</span>
 	return readl(adc_dev-&gt;reg_base + reg);
 }
 
<span class="p_add">+static void cc10001_adc_power_up(struct cc10001_adc_device *adc_dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN, 0);</span>
<span class="p_add">+	ndelay(adc_dev-&gt;start_delay_ns);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void cc10001_adc_power_down(struct cc10001_adc_device *adc_dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_DOWN,</span>
<span class="p_add">+			      CC10001_ADC_POWER_DOWN_SET);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cc10001_adc_start(struct cc10001_adc_device *adc_dev,
 			      unsigned int channel)
 {
<span class="p_chunk">@@ -88,6 +100,7 @@</span> <span class="p_context"> static void cc10001_adc_start(struct cc10001_adc_device *adc_dev,</span>
 	val = (channel &amp; CC10001_ADC_CH_MASK) | CC10001_ADC_MODE_SINGLE_CONV;
 	cc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);
 
<span class="p_add">+	udelay(1);</span>
 	val = cc10001_adc_read_reg(adc_dev, CC10001_ADC_CONFIG);
 	val = val | CC10001_ADC_START_CONV;
 	cc10001_adc_write_reg(adc_dev, CC10001_ADC_CONFIG, val);
<span class="p_chunk">@@ -129,6 +142,7 @@</span> <span class="p_context"> static irqreturn_t cc10001_adc_trigger_h(int irq, void *p)</span>
 	struct iio_dev *indio_dev;
 	unsigned int delay_ns;
 	unsigned int channel;
<span class="p_add">+	unsigned int scan_idx;</span>
 	bool sample_invalid;
 	u16 *data;
 	int i;
<span class="p_chunk">@@ -139,20 +153,17 @@</span> <span class="p_context"> static irqreturn_t cc10001_adc_trigger_h(int irq, void *p)</span>
 
 	mutex_lock(&amp;adc_dev-&gt;lock);
 
<span class="p_del">-	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_UP,</span>
<span class="p_del">-			      CC10001_ADC_POWER_UP_SET);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wait for 8 (6+2) clock cycles before activating START */</span>
<span class="p_del">-	ndelay(adc_dev-&gt;start_delay_ns);</span>
<span class="p_add">+	cc10001_adc_power_up(adc_dev);</span>
 
 	/* Calculate delay step for eoc and sampled data */
 	delay_ns = adc_dev-&gt;eoc_delay_ns / CC10001_MAX_POLL_COUNT;
 
 	i = 0;
 	sample_invalid = false;
<span class="p_del">-	for_each_set_bit(channel, indio_dev-&gt;active_scan_mask,</span>
<span class="p_add">+	for_each_set_bit(scan_idx, indio_dev-&gt;active_scan_mask,</span>
 				  indio_dev-&gt;masklength) {
 
<span class="p_add">+		channel = indio_dev-&gt;channels[scan_idx].channel;</span>
 		cc10001_adc_start(adc_dev, channel);
 
 		data[i] = cc10001_adc_poll_done(indio_dev, channel, delay_ns);
<span class="p_chunk">@@ -166,7 +177,7 @@</span> <span class="p_context"> static irqreturn_t cc10001_adc_trigger_h(int irq, void *p)</span>
 	}
 
 done:
<span class="p_del">-	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_UP, 0);</span>
<span class="p_add">+	cc10001_adc_power_down(adc_dev);</span>
 
 	mutex_unlock(&amp;adc_dev-&gt;lock);
 
<span class="p_chunk">@@ -185,11 +196,7 @@</span> <span class="p_context"> static u16 cc10001_adc_read_raw_voltage(struct iio_dev *indio_dev,</span>
 	unsigned int delay_ns;
 	u16 val;
 
<span class="p_del">-	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_UP,</span>
<span class="p_del">-			      CC10001_ADC_POWER_UP_SET);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wait for 8 (6+2) clock cycles before activating START */</span>
<span class="p_del">-	ndelay(adc_dev-&gt;start_delay_ns);</span>
<span class="p_add">+	cc10001_adc_power_up(adc_dev);</span>
 
 	/* Calculate delay step for eoc and sampled data */
 	delay_ns = adc_dev-&gt;eoc_delay_ns / CC10001_MAX_POLL_COUNT;
<span class="p_chunk">@@ -198,7 +205,7 @@</span> <span class="p_context"> static u16 cc10001_adc_read_raw_voltage(struct iio_dev *indio_dev,</span>
 
 	val = cc10001_adc_poll_done(indio_dev, chan-&gt;channel, delay_ns);
 
<span class="p_del">-	cc10001_adc_write_reg(adc_dev, CC10001_ADC_POWER_UP, 0);</span>
<span class="p_add">+	cc10001_adc_power_down(adc_dev);</span>
 
 	return val;
 }
<span class="p_chunk">@@ -224,7 +231,7 @@</span> <span class="p_context"> static int cc10001_adc_read_raw(struct iio_dev *indio_dev,</span>
 
 	case IIO_CHAN_INFO_SCALE:
 		ret = regulator_get_voltage(adc_dev-&gt;reg);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			return ret;
 
 		*val = ret / 1000;
<span class="p_chunk">@@ -255,22 +262,22 @@</span> <span class="p_context"> static const struct iio_info cc10001_adc_info = {</span>
 	.update_scan_mode = &amp;cc10001_update_scan_mode,
 };
 
<span class="p_del">-static int cc10001_adc_channel_init(struct iio_dev *indio_dev)</span>
<span class="p_add">+static int cc10001_adc_channel_init(struct iio_dev *indio_dev,</span>
<span class="p_add">+				    unsigned long channel_map)</span>
 {
<span class="p_del">-	struct cc10001_adc_device *adc_dev = iio_priv(indio_dev);</span>
 	struct iio_chan_spec *chan_array, *timestamp;
 	unsigned int bit, idx = 0;
 
<span class="p_del">-	indio_dev-&gt;num_channels = bitmap_weight(&amp;adc_dev-&gt;channel_map,</span>
<span class="p_del">-						CC10001_ADC_NUM_CHANNELS);</span>
<span class="p_add">+	indio_dev-&gt;num_channels = bitmap_weight(&amp;channel_map,</span>
<span class="p_add">+						CC10001_ADC_NUM_CHANNELS) + 1;</span>
 
<span class="p_del">-	chan_array = devm_kcalloc(&amp;indio_dev-&gt;dev, indio_dev-&gt;num_channels + 1,</span>
<span class="p_add">+	chan_array = devm_kcalloc(&amp;indio_dev-&gt;dev, indio_dev-&gt;num_channels,</span>
 				  sizeof(struct iio_chan_spec),
 				  GFP_KERNEL);
 	if (!chan_array)
 		return -ENOMEM;
 
<span class="p_del">-	for_each_set_bit(bit, &amp;adc_dev-&gt;channel_map, CC10001_ADC_NUM_CHANNELS) {</span>
<span class="p_add">+	for_each_set_bit(bit, &amp;channel_map, CC10001_ADC_NUM_CHANNELS) {</span>
 		struct iio_chan_spec *chan = &amp;chan_array[idx];
 
 		chan-&gt;type = IIO_VOLTAGE;
<span class="p_chunk">@@ -305,6 +312,7 @@</span> <span class="p_context"> static int cc10001_adc_probe(struct platform_device *pdev)</span>
 	unsigned long adc_clk_rate;
 	struct resource *res;
 	struct iio_dev *indio_dev;
<span class="p_add">+	unsigned long channel_map;</span>
 	int ret;
 
 	indio_dev = devm_iio_device_alloc(&amp;pdev-&gt;dev, sizeof(*adc_dev));
<span class="p_chunk">@@ -313,9 +321,9 @@</span> <span class="p_context"> static int cc10001_adc_probe(struct platform_device *pdev)</span>
 
 	adc_dev = iio_priv(indio_dev);
 
<span class="p_del">-	adc_dev-&gt;channel_map = GENMASK(CC10001_ADC_NUM_CHANNELS - 1, 0);</span>
<span class="p_add">+	channel_map = GENMASK(CC10001_ADC_NUM_CHANNELS - 1, 0);</span>
 	if (!of_property_read_u32(node, &quot;adc-reserved-channels&quot;, &amp;ret))
<span class="p_del">-		adc_dev-&gt;channel_map &amp;= ~ret;</span>
<span class="p_add">+		channel_map &amp;= ~ret;</span>
 
 	adc_dev-&gt;reg = devm_regulator_get(&amp;pdev-&gt;dev, &quot;vref&quot;);
 	if (IS_ERR(adc_dev-&gt;reg))
<span class="p_chunk">@@ -361,7 +369,7 @@</span> <span class="p_context"> static int cc10001_adc_probe(struct platform_device *pdev)</span>
 	adc_dev-&gt;start_delay_ns = adc_dev-&gt;eoc_delay_ns * CC10001_WAIT_CYCLES;
 
 	/* Setup the ADC channels available on the device */
<span class="p_del">-	ret = cc10001_adc_channel_init(indio_dev);</span>
<span class="p_add">+	ret = cc10001_adc_channel_init(indio_dev, channel_map);</span>
 	if (ret &lt; 0)
 		goto err_disable_clk;
 
<span class="p_header">diff --git a/drivers/iio/adc/qcom-spmi-vadc.c b/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_header">index 3211729bcb0b..0c4618b4d515 100644</span>
<span class="p_header">--- a/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/qcom-spmi-vadc.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/iio.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/kernel.h&gt;
<span class="p_add">+#include &lt;linux/math64.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
 #include &lt;linux/platform_device.h&gt;
<span class="p_chunk">@@ -471,11 +472,11 @@</span> <span class="p_context"> static s32 vadc_calibrate(struct vadc_priv *vadc,</span>
 			  const struct vadc_channel_prop *prop, u16 adc_code)
 {
 	const struct vadc_prescale_ratio *prescale;
<span class="p_del">-	s32 voltage;</span>
<span class="p_add">+	s64 voltage;</span>
 
 	voltage = adc_code - vadc-&gt;graph[prop-&gt;calibration].gnd;
 	voltage *= vadc-&gt;graph[prop-&gt;calibration].dx;
<span class="p_del">-	voltage = voltage / vadc-&gt;graph[prop-&gt;calibration].dy;</span>
<span class="p_add">+	voltage = div64_s64(voltage, vadc-&gt;graph[prop-&gt;calibration].dy);</span>
 
 	if (prop-&gt;calibration == VADC_CALIB_ABSOLUTE)
 		voltage += vadc-&gt;graph[prop-&gt;calibration].dx;
<span class="p_chunk">@@ -487,7 +488,7 @@</span> <span class="p_context"> static s32 vadc_calibrate(struct vadc_priv *vadc,</span>
 
 	voltage = voltage * prescale-&gt;den;
 
<span class="p_del">-	return voltage / prescale-&gt;num;</span>
<span class="p_add">+	return div64_s64(voltage, prescale-&gt;num);</span>
 }
 
 static int vadc_decimation_from_dt(u32 value)
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">index a221f7329b79..ce93bd8e3f68 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_chunk">@@ -856,6 +856,7 @@</span> <span class="p_context"> static int xadc_read_raw(struct iio_dev *indio_dev,</span>
 			switch (chan-&gt;address) {
 			case XADC_REG_VCCINT:
 			case XADC_REG_VCCAUX:
<span class="p_add">+			case XADC_REG_VREFP:</span>
 			case XADC_REG_VCCBRAM:
 			case XADC_REG_VCCPINT:
 			case XADC_REG_VCCPAUX:
<span class="p_chunk">@@ -996,7 +997,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 	.num_event_specs = (_alarm) ? ARRAY_SIZE(xadc_voltage_events) : 0, \
 	.scan_index = (_scan_index), \
 	.scan_type = { \
<span class="p_del">-		.sign = &#39;u&#39;, \</span>
<span class="p_add">+		.sign = ((_addr) == XADC_REG_VREFN) ? &#39;s&#39; : &#39;u&#39;, \</span>
 		.realbits = 12, \
 		.storagebits = 16, \
 		.shift = 4, \
<span class="p_chunk">@@ -1008,7 +1009,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 static const struct iio_chan_spec xadc_channels[] = {
 	XADC_CHAN_TEMP(0, 8, XADC_REG_TEMP),
 	XADC_CHAN_VOLTAGE(0, 9, XADC_REG_VCCINT, &quot;vccint&quot;, true),
<span class="p_del">-	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCINT, &quot;vccaux&quot;, true),</span>
<span class="p_add">+	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCAUX, &quot;vccaux&quot;, true),</span>
 	XADC_CHAN_VOLTAGE(2, 14, XADC_REG_VCCBRAM, &quot;vccbram&quot;, true),
 	XADC_CHAN_VOLTAGE(3, 5, XADC_REG_VCCPINT, &quot;vccpint&quot;, true),
 	XADC_CHAN_VOLTAGE(4, 6, XADC_REG_VCCPAUX, &quot;vccpaux&quot;, true),
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc.h b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">index c7487e8d7f80..54adc5087210 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_chunk">@@ -145,9 +145,9 @@</span> <span class="p_context"> static inline int xadc_write_adc_reg(struct xadc *xadc, unsigned int reg,</span>
 #define XADC_REG_MAX_VCCPINT	0x28
 #define XADC_REG_MAX_VCCPAUX	0x29
 #define XADC_REG_MAX_VCCO_DDR	0x2a
<span class="p_del">-#define XADC_REG_MIN_VCCPINT	0x2b</span>
<span class="p_del">-#define XADC_REG_MIN_VCCPAUX	0x2c</span>
<span class="p_del">-#define XADC_REG_MIN_VCCO_DDR	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPINT	0x2c</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPAUX	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCO_DDR	0x2e</span>
 
 #define XADC_REG_CONF0		0x40
 #define XADC_REG_CONF1		0x41
<span class="p_header">diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">index edd13d2b4121..8dd0477e201c 100644</span>
<span class="p_header">--- a/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">+++ b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_chunk">@@ -304,8 +304,6 @@</span> <span class="p_context"> int st_sensors_init_sensor(struct iio_dev *indio_dev,</span>
 	struct st_sensors_platform_data *of_pdata;
 	int err = 0;
 
<span class="p_del">-	mutex_init(&amp;sdata-&gt;tb.buf_lock);</span>
<span class="p_del">-</span>
 	/* If OF/DT pdata exists, it will take precedence of anything else */
 	of_pdata = st_sensors_of_probe(indio_dev-&gt;dev.parent, pdata);
 	if (of_pdata)
<span class="p_header">diff --git a/drivers/iio/gyro/st_gyro_core.c b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">index f07a2336f7dc..566f7d2df031 100644</span>
<span class="p_header">--- a/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">+++ b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_chunk">@@ -317,6 +317,7 @@</span> <span class="p_context"> int st_gyro_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;gyro_info;
<span class="p_add">+	mutex_init(&amp;gdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/light/hid-sensor-prox.c b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">index 3ecf79ed08ac..88f21bbe947c 100644</span>
<span class="p_header">--- a/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">+++ b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_chunk">@@ -43,8 +43,6 @@</span> <span class="p_context"> struct prox_state {</span>
 static const struct iio_chan_spec prox_channels[] = {
 	{
 		.type = IIO_PROXIMITY,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">index 8ade473f99fe..2e56f812a644 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> int st_magn_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;magn_info;
<span class="p_add">+	mutex_init(&amp;mdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/pressure/hid-sensor-press.c b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">index 1af314926ebd..476a7d03d2ce 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_chunk">@@ -47,8 +47,6 @@</span> <span class="p_context"> struct press_state {</span>
 static const struct iio_chan_spec press_channels[] = {
 	{
 		.type = IIO_PRESSURE,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index 97baf40d424b..e881fa6291e9 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> int st_press_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;press_info;
<span class="p_add">+	mutex_init(&amp;press_data-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_msg.c b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">index b85ddbc979e0..e5558b2660f2 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 
 #include &quot;iwpm_util.h&quot;
 
<span class="p_del">-static const char iwpm_ulib_name[] = &quot;iWarpPortMapperUser&quot;;</span>
<span class="p_add">+static const char iwpm_ulib_name[IWPM_ULIBNAME_SIZE] = &quot;iWarpPortMapperUser&quot;;</span>
 static int iwpm_ulib_version = 3;
 static int iwpm_user_pid = IWPM_PID_UNDEFINED;
 static atomic_t echo_nlmsg_seq;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 991dc6b20a58..79363b687195 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -315,7 +315,7 @@</span> <span class="p_context"> static void elantech_report_semi_mt_data(struct input_dev *dev,</span>
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
<span class="p_del">-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);</span>
<span class="p_add">+	elantech_set_slot(dev, 1, num_fingers &gt;= 2, x2, y2);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index 6d5a5c44453b..173e70dbf61b 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -266,6 +266,7 @@</span> <span class="p_context"> static void put_pasid_state(struct pasid_state *pasid_state)</span>
 
 static void put_pasid_state_wait(struct pasid_state *pasid_state)
 {
<span class="p_add">+	atomic_dec(&amp;pasid_state-&gt;count);</span>
 	wait_event(pasid_state-&gt;wq, !atomic_read(&amp;pasid_state-&gt;count));
 	free_pasid_state(pasid_state);
 }
<span class="p_header">diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="p_header">index a3adde6519f0..bd6252b01510 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu.c</span>
<span class="p_chunk">@@ -224,14 +224,7 @@</span> <span class="p_context"></span>
 #define RESUME_TERMINATE		(1 &lt;&lt; 0)
 
 #define TTBCR2_SEP_SHIFT		15
<span class="p_del">-#define TTBCR2_SEP_MASK			0x7</span>
<span class="p_del">-</span>
<span class="p_del">-#define TTBCR2_ADDR_32			0</span>
<span class="p_del">-#define TTBCR2_ADDR_36			1</span>
<span class="p_del">-#define TTBCR2_ADDR_40			2</span>
<span class="p_del">-#define TTBCR2_ADDR_42			3</span>
<span class="p_del">-#define TTBCR2_ADDR_44			4</span>
<span class="p_del">-#define TTBCR2_ADDR_48			5</span>
<span class="p_add">+#define TTBCR2_SEP_UPSTREAM		(0x7 &lt;&lt; TTBCR2_SEP_SHIFT)</span>
 
 #define TTBRn_HI_ASID_SHIFT            16
 
<span class="p_chunk">@@ -783,26 +776,7 @@</span> <span class="p_context"> static void arm_smmu_init_context_bank(struct arm_smmu_domain *smmu_domain,</span>
 		writel_relaxed(reg, cb_base + ARM_SMMU_CB_TTBCR);
 		if (smmu-&gt;version &gt; ARM_SMMU_V1) {
 			reg = pgtbl_cfg-&gt;arm_lpae_s1_cfg.tcr &gt;&gt; 32;
<span class="p_del">-			switch (smmu-&gt;va_size) {</span>
<span class="p_del">-			case 32:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_32 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 36:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_36 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 40:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_40 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 42:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_42 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 44:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_44 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 48:</span>
<span class="p_del">-				reg |= (TTBCR2_ADDR_48 &lt;&lt; TTBCR2_SEP_SHIFT);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			reg |= TTBCR2_SEP_UPSTREAM;</span>
 			writel_relaxed(reg, cb_base + ARM_SMMU_CB_TTBCR2);
 		}
 	} else {
<span class="p_header">diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c</span>
<span class="p_header">index 7dc93aa004c8..312ffd3d0017 100644</span>
<span class="p_header">--- a/drivers/lguest/core.c</span>
<span class="p_header">+++ b/drivers/lguest/core.c</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> static void unmap_switcher(void)</span>
 bool lguest_address_ok(const struct lguest *lg,
 		       unsigned long addr, unsigned long len)
 {
<span class="p_del">-	return (addr+len) / PAGE_SIZE &lt; lg-&gt;pfn_limit &amp;&amp; (addr+len &gt;= addr);</span>
<span class="p_add">+	return addr+len &lt;= lg-&gt;pfn_limit * PAGE_SIZE &amp;&amp; (addr+len &gt;= addr);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c</span>
<span class="p_header">index 6554d9148927..757f1ba34c4d 100644</span>
<span class="p_header">--- a/drivers/md/dm-table.c</span>
<span class="p_header">+++ b/drivers/md/dm-table.c</span>
<span class="p_chunk">@@ -823,6 +823,12 @@</span> <span class="p_context"> void dm_consume_args(struct dm_arg_set *as, unsigned num_args)</span>
 }
 EXPORT_SYMBOL(dm_consume_args);
 
<span class="p_add">+static bool __table_type_request_based(unsigned table_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (table_type == DM_TYPE_REQUEST_BASED ||</span>
<span class="p_add">+		table_type == DM_TYPE_MQ_REQUEST_BASED);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int dm_table_set_type(struct dm_table *t)
 {
 	unsigned i;
<span class="p_chunk">@@ -855,8 +861,7 @@</span> <span class="p_context"> static int dm_table_set_type(struct dm_table *t)</span>
 		 * Determine the type from the live device.
 		 * Default to bio-based if device is new.
 		 */
<span class="p_del">-		if (live_md_type == DM_TYPE_REQUEST_BASED ||</span>
<span class="p_del">-		    live_md_type == DM_TYPE_MQ_REQUEST_BASED)</span>
<span class="p_add">+		if (__table_type_request_based(live_md_type))</span>
 			request_based = 1;
 		else
 			bio_based = 1;
<span class="p_chunk">@@ -906,7 +911,7 @@</span> <span class="p_context"> static int dm_table_set_type(struct dm_table *t)</span>
 			}
 		t-&gt;type = DM_TYPE_MQ_REQUEST_BASED;
 
<span class="p_del">-	} else if (hybrid &amp;&amp; list_empty(devices) &amp;&amp; live_md_type != DM_TYPE_NONE) {</span>
<span class="p_add">+	} else if (list_empty(devices) &amp;&amp; __table_type_request_based(live_md_type)) {</span>
 		/* inherit live MD type */
 		t-&gt;type = live_md_type;
 
<span class="p_chunk">@@ -928,10 +933,7 @@</span> <span class="p_context"> struct target_type *dm_table_get_immutable_target_type(struct dm_table *t)</span>
 
 bool dm_table_request_based(struct dm_table *t)
 {
<span class="p_del">-	unsigned table_type = dm_table_get_type(t);</span>
<span class="p_del">-</span>
<span class="p_del">-	return (table_type == DM_TYPE_REQUEST_BASED ||</span>
<span class="p_del">-		table_type == DM_TYPE_MQ_REQUEST_BASED);</span>
<span class="p_add">+	return __table_type_request_based(dm_table_get_type(t));</span>
 }
 
 bool dm_table_mq_request_based(struct dm_table *t)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 8001fe9e3434..9b4e30a82e4a 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1642,8 +1642,7 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	struct mapped_device *md = q-&gt;queuedata;
 	struct dm_table *map = dm_get_live_table_fast(md);
 	struct dm_target *ti;
<span class="p_del">-	sector_t max_sectors;</span>
<span class="p_del">-	int max_size = 0;</span>
<span class="p_add">+	sector_t max_sectors, max_size = 0;</span>
 
 	if (unlikely(!map))
 		goto out;
<span class="p_chunk">@@ -1658,8 +1657,16 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	max_sectors = min(max_io_len(bvm-&gt;bi_sector, ti),
 			  (sector_t) queue_max_sectors(q));
 	max_size = (max_sectors &lt;&lt; SECTOR_SHIFT) - bvm-&gt;bi_size;
<span class="p_del">-	if (unlikely(max_size &lt; 0)) /* this shouldn&#39;t _ever_ happen */</span>
<span class="p_del">-		max_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * FIXME: this stop-gap fix _must_ be cleaned up (by passing a sector_t</span>
<span class="p_add">+	 * to the targets&#39; merge function since it holds sectors not bytes).</span>
<span class="p_add">+	 * Just doing this as an interim fix for stable@ because the more</span>
<span class="p_add">+	 * comprehensive cleanup of switching to sector_t will impact every</span>
<span class="p_add">+	 * DM target that implements a -&gt;merge hook.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (max_size &gt; INT_MAX)</span>
<span class="p_add">+		max_size = INT_MAX;</span>
 
 	/*
 	 * merge_bvec_fn() returns number of bytes
<span class="p_chunk">@@ -1667,7 +1674,7 @@</span> <span class="p_context"> static int dm_merge_bvec(struct request_queue *q,</span>
 	 * max is precomputed maximal io size
 	 */
 	if (max_size &amp;&amp; ti-&gt;type-&gt;merge)
<span class="p_del">-		max_size = ti-&gt;type-&gt;merge(ti, bvm, biovec, max_size);</span>
<span class="p_add">+		max_size = ti-&gt;type-&gt;merge(ti, bvm, biovec, (int) max_size);</span>
 	/*
 	 * If the target doesn&#39;t support merge method and some of the devices
 	 * provided their merge_bvec method (we know this by looking for the
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index e47d1dd046da..907534b7f40d 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -4138,12 +4138,12 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 	if (!mddev-&gt;pers || !mddev-&gt;pers-&gt;sync_request)
 		return -EINVAL;
 
<span class="p_del">-	if (cmd_match(page, &quot;frozen&quot;))</span>
<span class="p_del">-		set_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 
 	if (cmd_match(page, &quot;idle&quot;) || cmd_match(page, &quot;frozen&quot;)) {
<span class="p_add">+		if (cmd_match(page, &quot;frozen&quot;))</span>
<span class="p_add">+			set_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 		flush_workqueue(md_misc_wq);
 		if (mddev-&gt;sync_thread) {
 			set_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery);
<span class="p_chunk">@@ -4156,16 +4156,17 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 		   test_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery))
 		return -EBUSY;
 	else if (cmd_match(page, &quot;resync&quot;))
<span class="p_del">-		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);</span>
<span class="p_add">+		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 	else if (cmd_match(page, &quot;recover&quot;)) {
<span class="p_add">+		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 		set_bit(MD_RECOVERY_RECOVER, &amp;mddev-&gt;recovery);
<span class="p_del">-		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);</span>
 	} else if (cmd_match(page, &quot;reshape&quot;)) {
 		int err;
 		if (mddev-&gt;pers-&gt;start_reshape == NULL)
 			return -EINVAL;
 		err = mddev_lock(mddev);
 		if (!err) {
<span class="p_add">+			clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 			err = mddev-&gt;pers-&gt;start_reshape(mddev);
 			mddev_unlock(mddev);
 		}
<span class="p_chunk">@@ -4177,6 +4178,7 @@</span> <span class="p_context"> action_store(struct mddev *mddev, const char *page, size_t len)</span>
 			set_bit(MD_RECOVERY_CHECK, &amp;mddev-&gt;recovery);
 		else if (!cmd_match(page, &quot;repair&quot;))
 			return -EINVAL;
<span class="p_add">+		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 		set_bit(MD_RECOVERY_REQUESTED, &amp;mddev-&gt;recovery);
 		set_bit(MD_RECOVERY_SYNC, &amp;mddev-&gt;recovery);
 	}
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index 3b5d7f704aa3..903391ce9353 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -517,6 +517,9 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			 ? (sector &amp; (chunk_sects-1))
 			 : sector_div(sector, chunk_sects));
 
<span class="p_add">+		/* Restore due to sector_div */</span>
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
<span class="p_add">+</span>
 		if (sectors &lt; bio_sectors(bio)) {
 			split = bio_split(bio, sectors, GFP_NOIO, fs_bio_set);
 			bio_chain(split, bio);
<span class="p_chunk">@@ -524,7 +527,6 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_del">-		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index cd2f96b2c572..007ab861eca0 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -1933,7 +1933,8 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 
 	conf-&gt;slab_cache = sc;
 	conf-&gt;active_name = 1-conf-&gt;active_name;
<span class="p_del">-	conf-&gt;pool_size = newsize;</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		conf-&gt;pool_size = newsize;</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/mfd/da9052-core.c b/drivers/mfd/da9052-core.c</span>
<span class="p_header">index ae498b53ee40..46e3840c7a37 100644</span>
<span class="p_header">--- a/drivers/mfd/da9052-core.c</span>
<span class="p_header">+++ b/drivers/mfd/da9052-core.c</span>
<span class="p_chunk">@@ -433,6 +433,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(da9052_adc_read_temp);</span>
 static const struct mfd_cell da9052_subdev_info[] = {
 	{
 		.name = &quot;da9052-regulator&quot;,
<span class="p_add">+		.id = 0,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.name = &quot;da9052-regulator&quot;,</span>
 		.id = 1,
 	},
 	{
<span class="p_chunk">@@ -484,10 +488,6 @@</span> <span class="p_context"> static const struct mfd_cell da9052_subdev_info[] = {</span>
 		.id = 13,
 	},
 	{
<span class="p_del">-		.name = &quot;da9052-regulator&quot;,</span>
<span class="p_del">-		.id = 14,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
 		.name = &quot;da9052-onkey&quot;,
 	},
 	{
<span class="p_header">diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">index 03d7c7521d97..9a39e0b7e583 100644</span>
<span class="p_header">--- a/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_chunk">@@ -1304,7 +1304,7 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 
 	if (ios-&gt;clock) {
 		unsigned int clock_min = ~0U;
<span class="p_del">-		u32 clkdiv;</span>
<span class="p_add">+		int clkdiv;</span>
 
 		spin_lock_bh(&amp;host-&gt;lock);
 		if (!host-&gt;mode_reg) {
<span class="p_chunk">@@ -1328,7 +1328,12 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 		/* Calculate clock divider */
 		if (host-&gt;caps.has_odd_clk_div) {
 			clkdiv = DIV_ROUND_UP(host-&gt;bus_hz, clock_min) - 2;
<span class="p_del">-			if (clkdiv &gt; 511) {</span>
<span class="p_add">+			if (clkdiv &lt; 0) {</span>
<span class="p_add">+				dev_warn(&amp;mmc-&gt;class_dev,</span>
<span class="p_add">+					 &quot;clock %u too fast; using %lu\n&quot;,</span>
<span class="p_add">+					 clock_min, host-&gt;bus_hz / 2);</span>
<span class="p_add">+				clkdiv = 0;</span>
<span class="p_add">+			} else if (clkdiv &gt; 511) {</span>
 				dev_warn(&amp;mmc-&gt;class_dev,
 				         &quot;clock %u too slow; using %lu\n&quot;,
 				         clock_min, host-&gt;bus_hz / (511 + 2));
<span class="p_header">diff --git a/drivers/mtd/ubi/block.c b/drivers/mtd/ubi/block.c</span>
<span class="p_header">index db2c05b6fe7f..c9eb78f10a0d 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/block.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/block.c</span>
<span class="p_chunk">@@ -310,6 +310,8 @@</span> <span class="p_context"> static void ubiblock_do_work(struct work_struct *work)</span>
 	blk_rq_map_sg(req-&gt;q, req, pdu-&gt;usgl.sg);
 
 	ret = ubiblock_read(pdu);
<span class="p_add">+	rq_flush_dcache_pages(req);</span>
<span class="p_add">+</span>
 	blk_mq_end_request(req, ret);
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/msgbuf.c b/drivers/net/wireless/brcm80211/brcmfmac/msgbuf.c</span>
<span class="p_header">index 6262612dec45..7a3231d8b933 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/msgbuf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/msgbuf.c</span>
<span class="p_chunk">@@ -512,11 +512,9 @@</span> <span class="p_context"> static int brcmf_msgbuf_query_dcmd(struct brcmf_pub *drvr, int ifidx,</span>
 				     msgbuf-&gt;rx_pktids,
 				     msgbuf-&gt;ioctl_resp_pktid);
 	if (msgbuf-&gt;ioctl_resp_ret_len != 0) {
<span class="p_del">-		if (!skb) {</span>
<span class="p_del">-			brcmf_err(&quot;Invalid packet id idx recv&#39;d %d\n&quot;,</span>
<span class="p_del">-				  msgbuf-&gt;ioctl_resp_pktid);</span>
<span class="p_add">+		if (!skb)</span>
 			return -EBADF;
<span class="p_del">-		}</span>
<span class="p_add">+</span>
 		memcpy(buf, skb-&gt;data, (len &lt; msgbuf-&gt;ioctl_resp_ret_len) ?
 				       len : msgbuf-&gt;ioctl_resp_ret_len);
 	}
<span class="p_chunk">@@ -875,10 +873,8 @@</span> <span class="p_context"> brcmf_msgbuf_process_txstatus(struct brcmf_msgbuf *msgbuf, void *buf)</span>
 	flowid -= BRCMF_NROF_H2D_COMMON_MSGRINGS;
 	skb = brcmf_msgbuf_get_pktid(msgbuf-&gt;drvr-&gt;bus_if-&gt;dev,
 				     msgbuf-&gt;tx_pktids, idx);
<span class="p_del">-	if (!skb) {</span>
<span class="p_del">-		brcmf_err(&quot;Invalid packet id idx recv&#39;d %d\n&quot;, idx);</span>
<span class="p_add">+	if (!skb)</span>
 		return;
<span class="p_del">-	}</span>
 
 	set_bit(flowid, msgbuf-&gt;txstatus_done_map);
 	commonring = msgbuf-&gt;flowrings[flowid];
<span class="p_chunk">@@ -1157,6 +1153,8 @@</span> <span class="p_context"> brcmf_msgbuf_process_rx_complete(struct brcmf_msgbuf *msgbuf, void *buf)</span>
 
 	skb = brcmf_msgbuf_get_pktid(msgbuf-&gt;drvr-&gt;bus_if-&gt;dev,
 				     msgbuf-&gt;rx_pktids, idx);
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		return;</span>
 
 	if (data_offset)
 		skb_pull(skb, data_offset);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">index 14e8fd661889..fd5a0bb1493f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_chunk">@@ -1742,8 +1742,10 @@</span> <span class="p_context"> static void iwl_mvm_query_netdetect_reasons(struct iwl_mvm *mvm,</span>
 	int i, j, n_matches, ret;
 
 	fw_status = iwl_mvm_get_wakeup_status(mvm, vif);
<span class="p_del">-	if (!IS_ERR_OR_NULL(fw_status))</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(fw_status)) {</span>
 		reasons = le32_to_cpu(fw_status-&gt;wakeup_reasons);
<span class="p_add">+		kfree(fw_status);</span>
<span class="p_add">+	}</span>
 
 	if (reasons &amp; IWL_WOWLAN_WAKEUP_BY_RFKILL_DEASSERTED)
 		wakeup.rfkill_release = true;
<span class="p_chunk">@@ -1860,15 +1862,15 @@</span> <span class="p_context"> static int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)</span>
 	/* get the BSS vif pointer again */
 	vif = iwl_mvm_get_bss_vif(mvm);
 	if (IS_ERR_OR_NULL(vif))
<span class="p_del">-		goto out_unlock;</span>
<span class="p_add">+		goto err;</span>
 
 	ret = iwl_trans_d3_resume(mvm-&gt;trans, &amp;d3_status, test);
 	if (ret)
<span class="p_del">-		goto out_unlock;</span>
<span class="p_add">+		goto err;</span>
 
 	if (d3_status != IWL_D3_STATUS_ALIVE) {
 		IWL_INFO(mvm, &quot;Device was reset during suspend\n&quot;);
<span class="p_del">-		goto out_unlock;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	/* query SRAM first in case we want event logging */
<span class="p_chunk">@@ -1886,7 +1888,8 @@</span> <span class="p_context"> static int __iwl_mvm_resume(struct iwl_mvm *mvm, bool test)</span>
 	/* has unlocked the mutex, so skip that */
 	goto out;
 
<span class="p_del">- out_unlock:</span>
<span class="p_add">+err:</span>
<span class="p_add">+	iwl_mvm_free_nd(mvm);</span>
 	mutex_unlock(&amp;mvm-&gt;mutex);
 
  out:
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">index 69935aa5a1b3..cb72edb3d16a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -5,8 +5,8 @@</span> <span class="p_context"></span>
  *
  * GPL LICENSE SUMMARY
  *
<span class="p_del">- * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.</span>
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2007 - 2015 Intel Corporation. All rights reserved.</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -31,8 +31,8 @@</span> <span class="p_context"></span>
  *
  * BSD LICENSE
  *
<span class="p_del">- * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.</span>
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2005 - 2015 Intel Corporation. All rights reserved.</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static void iwl_pcie_free_fw_monitor(struct iwl_trans *trans)</span>
 static void iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans)
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
<span class="p_del">-	struct page *page;</span>
<span class="p_add">+	struct page *page = NULL;</span>
 	dma_addr_t phys;
 	u32 size;
 	u8 power;
<span class="p_chunk">@@ -131,6 +131,7 @@</span> <span class="p_context"> static void iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans)</span>
 				    DMA_FROM_DEVICE);
 		if (dma_mapping_error(trans-&gt;dev, phys)) {
 			__free_pages(page, order);
<span class="p_add">+			page = NULL;</span>
 			continue;
 		}
 		IWL_INFO(trans,
<span class="p_header">diff --git a/drivers/net/wireless/rt2x00/rt2800usb.c b/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_header">index 8444313eabe2..8694dddcce9a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rt2x00/rt2800usb.c</span>
<span class="p_chunk">@@ -1040,6 +1040,7 @@</span> <span class="p_context"> static struct usb_device_id rt2800usb_device_table[] = {</span>
 	{ USB_DEVICE(0x07d1, 0x3c17) },
 	{ USB_DEVICE(0x2001, 0x3317) },
 	{ USB_DEVICE(0x2001, 0x3c1b) },
<span class="p_add">+	{ USB_DEVICE(0x2001, 0x3c25) },</span>
 	/* Draytek */
 	{ USB_DEVICE(0x07fa, 0x7712) },
 	/* DVICO */
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 46ee956d0235..27cd6cabf6c5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,</span>
 
 	do {
 		status = usb_control_msg(udev, pipe, request, reqtype, value,
<span class="p_del">-					 index, pdata, len, 0); /*max. timeout*/</span>
<span class="p_add">+					 index, pdata, len, 1000);</span>
 		if (status &lt; 0) {
 			/* firmware download is checksumed, don&#39;t retry */
 			if ((value &gt;= FW_8192C_START_ADDRESS &amp;&amp;
<span class="p_header">diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c</span>
<span class="p_header">index 13584e24736a..4d7d60e593b8 100644</span>
<span class="p_header">--- a/drivers/power/reset/at91-reset.c</span>
<span class="p_header">+++ b/drivers/power/reset/at91-reset.c</span>
<span class="p_chunk">@@ -212,9 +212,9 @@</span> <span class="p_context"> static int at91_reset_platform_probe(struct platform_device *pdev)</span>
 		res = platform_get_resource(pdev, IORESOURCE_MEM, idx + 1 );
 		at91_ramc_base[idx] = devm_ioremap(&amp;pdev-&gt;dev, res-&gt;start,
 						   resource_size(res));
<span class="p_del">-		if (IS_ERR(at91_ramc_base[idx])) {</span>
<span class="p_add">+		if (!at91_ramc_base[idx]) {</span>
 			dev_err(&amp;pdev-&gt;dev, &quot;Could not map ram controller address\n&quot;);
<span class="p_del">-			return PTR_ERR(at91_ramc_base[idx]);</span>
<span class="p_add">+			return -ENOMEM;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/pwm/pwm-img.c b/drivers/pwm/pwm-img.c</span>
<span class="p_header">index 476171a768d6..8a029f9bc18c 100644</span>
<span class="p_header">--- a/drivers/pwm/pwm-img.c</span>
<span class="p_header">+++ b/drivers/pwm/pwm-img.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mfd/syscon.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pwm.h&gt;
 #include &lt;linux/regmap.h&gt;
<span class="p_chunk">@@ -38,7 +39,22 @@</span> <span class="p_context"></span>
 #define PERIP_PWM_PDM_CONTROL_CH_MASK		0x1
 #define PERIP_PWM_PDM_CONTROL_CH_SHIFT(ch)	((ch) * 4)
 
<span class="p_del">-#define MAX_TMBASE_STEPS			65536</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * PWM period is specified with a timebase register,</span>
<span class="p_add">+ * in number of step periods. The PWM duty cycle is also</span>
<span class="p_add">+ * specified in step periods, in the [0, $timebase] range.</span>
<span class="p_add">+ * In other words, the timebase imposes the duty cycle</span>
<span class="p_add">+ * resolution. Therefore, let&#39;s constraint the timebase to</span>
<span class="p_add">+ * a minimum value to allow a sane range of duty cycle values.</span>
<span class="p_add">+ * Imposing a minimum timebase, will impose a maximum PWM frequency.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The value chosen is completely arbitrary.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MIN_TMBASE_STEPS			16</span>
<span class="p_add">+</span>
<span class="p_add">+struct img_pwm_soc_data {</span>
<span class="p_add">+	u32 max_timebase;</span>
<span class="p_add">+};</span>
 
 struct img_pwm_chip {
 	struct device	*dev;
<span class="p_chunk">@@ -47,6 +63,9 @@</span> <span class="p_context"> struct img_pwm_chip {</span>
 	struct clk	*sys_clk;
 	void __iomem	*base;
 	struct regmap	*periph_regs;
<span class="p_add">+	int		max_period_ns;</span>
<span class="p_add">+	int		min_period_ns;</span>
<span class="p_add">+	const struct img_pwm_soc_data   *data;</span>
 };
 
 static inline struct img_pwm_chip *to_img_pwm_chip(struct pwm_chip *chip)
<span class="p_chunk">@@ -72,24 +91,31 @@</span> <span class="p_context"> static int img_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,</span>
 	u32 val, div, duty, timebase;
 	unsigned long mul, output_clk_hz, input_clk_hz;
 	struct img_pwm_chip *pwm_chip = to_img_pwm_chip(chip);
<span class="p_add">+	unsigned int max_timebase = pwm_chip-&gt;data-&gt;max_timebase;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (period_ns &lt; pwm_chip-&gt;min_period_ns ||</span>
<span class="p_add">+	    period_ns &gt; pwm_chip-&gt;max_period_ns) {</span>
<span class="p_add">+		dev_err(chip-&gt;dev, &quot;configured period not in range\n&quot;);</span>
<span class="p_add">+		return -ERANGE;</span>
<span class="p_add">+	}</span>
 
 	input_clk_hz = clk_get_rate(pwm_chip-&gt;pwm_clk);
 	output_clk_hz = DIV_ROUND_UP(NSEC_PER_SEC, period_ns);
 
 	mul = DIV_ROUND_UP(input_clk_hz, output_clk_hz);
<span class="p_del">-	if (mul &lt;= MAX_TMBASE_STEPS) {</span>
<span class="p_add">+	if (mul &lt;= max_timebase) {</span>
 		div = PWM_CTRL_CFG_NO_SUB_DIV;
 		timebase = DIV_ROUND_UP(mul, 1);
<span class="p_del">-	} else if (mul &lt;= MAX_TMBASE_STEPS * 8) {</span>
<span class="p_add">+	} else if (mul &lt;= max_timebase * 8) {</span>
 		div = PWM_CTRL_CFG_SUB_DIV0;
 		timebase = DIV_ROUND_UP(mul, 8);
<span class="p_del">-	} else if (mul &lt;= MAX_TMBASE_STEPS * 64) {</span>
<span class="p_add">+	} else if (mul &lt;= max_timebase * 64) {</span>
 		div = PWM_CTRL_CFG_SUB_DIV1;
 		timebase = DIV_ROUND_UP(mul, 64);
<span class="p_del">-	} else if (mul &lt;= MAX_TMBASE_STEPS * 512) {</span>
<span class="p_add">+	} else if (mul &lt;= max_timebase * 512) {</span>
 		div = PWM_CTRL_CFG_SUB_DIV0_DIV1;
 		timebase = DIV_ROUND_UP(mul, 512);
<span class="p_del">-	} else if (mul &gt; MAX_TMBASE_STEPS * 512) {</span>
<span class="p_add">+	} else if (mul &gt; max_timebase * 512) {</span>
 		dev_err(chip-&gt;dev,
 			&quot;failed to configure timebase steps/divider value\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -143,11 +169,27 @@</span> <span class="p_context"> static const struct pwm_ops img_pwm_ops = {</span>
 	.owner = THIS_MODULE,
 };
 
<span class="p_add">+static const struct img_pwm_soc_data pistachio_pwm = {</span>
<span class="p_add">+	.max_timebase = 255,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id img_pwm_of_match[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;img,pistachio-pwm&quot;,</span>
<span class="p_add">+		.data = &amp;pistachio_pwm,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+MODULE_DEVICE_TABLE(of, img_pwm_of_match);</span>
<span class="p_add">+</span>
 static int img_pwm_probe(struct platform_device *pdev)
 {
 	int ret;
<span class="p_add">+	u64 val;</span>
<span class="p_add">+	unsigned long clk_rate;</span>
 	struct resource *res;
 	struct img_pwm_chip *pwm;
<span class="p_add">+	const struct of_device_id *of_dev_id;</span>
 
 	pwm = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*pwm), GFP_KERNEL);
 	if (!pwm)
<span class="p_chunk">@@ -160,6 +202,11 @@</span> <span class="p_context"> static int img_pwm_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(pwm-&gt;base))
 		return PTR_ERR(pwm-&gt;base);
 
<span class="p_add">+	of_dev_id = of_match_device(img_pwm_of_match, &amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (!of_dev_id)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	pwm-&gt;data = of_dev_id-&gt;data;</span>
<span class="p_add">+</span>
 	pwm-&gt;periph_regs = syscon_regmap_lookup_by_phandle(pdev-&gt;dev.of_node,
 							   &quot;img,cr-periph&quot;);
 	if (IS_ERR(pwm-&gt;periph_regs))
<span class="p_chunk">@@ -189,6 +236,17 @@</span> <span class="p_context"> static int img_pwm_probe(struct platform_device *pdev)</span>
 		goto disable_sysclk;
 	}
 
<span class="p_add">+	clk_rate = clk_get_rate(pwm-&gt;pwm_clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The maximum input clock divider is 512 */</span>
<span class="p_add">+	val = (u64)NSEC_PER_SEC * 512 * pwm-&gt;data-&gt;max_timebase;</span>
<span class="p_add">+	do_div(val, clk_rate);</span>
<span class="p_add">+	pwm-&gt;max_period_ns = val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64)NSEC_PER_SEC * MIN_TMBASE_STEPS;</span>
<span class="p_add">+	do_div(val, clk_rate);</span>
<span class="p_add">+	pwm-&gt;min_period_ns = val;</span>
<span class="p_add">+</span>
 	pwm-&gt;chip.dev = &amp;pdev-&gt;dev;
 	pwm-&gt;chip.ops = &amp;img_pwm_ops;
 	pwm-&gt;chip.base = -1;
<span class="p_chunk">@@ -228,12 +286,6 @@</span> <span class="p_context"> static int img_pwm_remove(struct platform_device *pdev)</span>
 	return pwmchip_remove(&amp;pwm_chip-&gt;chip);
 }
 
<span class="p_del">-static const struct of_device_id img_pwm_of_match[] = {</span>
<span class="p_del">-	{ .compatible = &quot;img,pistachio-pwm&quot;, },</span>
<span class="p_del">-	{ }</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(of, img_pwm_of_match);</span>
<span class="p_del">-</span>
 static struct platform_driver img_pwm_driver = {
 	.driver = {
 		.name = &quot;img-pwm&quot;,
<span class="p_header">diff --git a/drivers/regulator/da9052-regulator.c b/drivers/regulator/da9052-regulator.c</span>
<span class="p_header">index 8a4df7a1f2ee..e628d4c2f2ae 100644</span>
<span class="p_header">--- a/drivers/regulator/da9052-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/da9052-regulator.c</span>
<span class="p_chunk">@@ -394,6 +394,7 @@</span> <span class="p_context"> static inline struct da9052_regulator_info *find_regulator_info(u8 chip_id,</span>
 
 static int da9052_regulator_probe(struct platform_device *pdev)
 {
<span class="p_add">+	const struct mfd_cell *cell = mfd_get_cell(pdev);</span>
 	struct regulator_config config = { };
 	struct da9052_regulator *regulator;
 	struct da9052 *da9052;
<span class="p_chunk">@@ -409,7 +410,7 @@</span> <span class="p_context"> static int da9052_regulator_probe(struct platform_device *pdev)</span>
 	regulator-&gt;da9052 = da9052;
 
 	regulator-&gt;info = find_regulator_info(regulator-&gt;da9052-&gt;chip_id,
<span class="p_del">-					      pdev-&gt;id);</span>
<span class="p_add">+					      cell-&gt;id);</span>
 	if (regulator-&gt;info == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;invalid regulator ID specified\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -419,7 +420,7 @@</span> <span class="p_context"> static int da9052_regulator_probe(struct platform_device *pdev)</span>
 	config.driver_data = regulator;
 	config.regmap = da9052-&gt;regmap;
 	if (pdata &amp;&amp; pdata-&gt;regulators) {
<span class="p_del">-		config.init_data = pdata-&gt;regulators[pdev-&gt;id];</span>
<span class="p_add">+		config.init_data = pdata-&gt;regulators[cell-&gt;id];</span>
 	} else {
 #ifdef CONFIG_OF
 		struct device_node *nproot = da9052-&gt;dev-&gt;of_node;
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 3290a3ed5b31..a661d339adf7 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1624,6 +1624,7 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 {
 	u64 start_lba = blk_rq_pos(scmd-&gt;request);
 	u64 end_lba = blk_rq_pos(scmd-&gt;request) + (scsi_bufflen(scmd) / 512);
<span class="p_add">+	u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
 	u64 bad_lba;
 	int info_valid;
 	/*
<span class="p_chunk">@@ -1645,16 +1646,9 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 	if (scsi_bufflen(scmd) &lt;= scmd-&gt;device-&gt;sector_size)
 		return 0;
 
<span class="p_del">-	if (scmd-&gt;device-&gt;sector_size &lt; 512) {</span>
<span class="p_del">-		/* only legitimate sector_size here is 256 */</span>
<span class="p_del">-		start_lba &lt;&lt;= 1;</span>
<span class="p_del">-		end_lba &lt;&lt;= 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* be careful ... don&#39;t want any overflows */</span>
<span class="p_del">-		unsigned int factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_del">-		do_div(start_lba, factor);</span>
<span class="p_del">-		do_div(end_lba, factor);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* be careful ... don&#39;t want any overflows */</span>
<span class="p_add">+	do_div(start_lba, factor);</span>
<span class="p_add">+	do_div(end_lba, factor);</span>
 
 	/* The bad lba was reported incorrectly, we have no idea where
 	 * the error is.
<span class="p_chunk">@@ -2212,8 +2206,7 @@</span> <span class="p_context"> got_data:</span>
 	if (sector_size != 512 &amp;&amp;
 	    sector_size != 1024 &amp;&amp;
 	    sector_size != 2048 &amp;&amp;
<span class="p_del">-	    sector_size != 4096 &amp;&amp;</span>
<span class="p_del">-	    sector_size != 256) {</span>
<span class="p_add">+	    sector_size != 4096) {</span>
 		sd_printk(KERN_NOTICE, sdkp, &quot;Unsupported sector size %d.\n&quot;,
 			  sector_size);
 		/*
<span class="p_chunk">@@ -2268,8 +2261,6 @@</span> <span class="p_context"> got_data:</span>
 		sdkp-&gt;capacity &lt;&lt;= 2;
 	else if (sector_size == 1024)
 		sdkp-&gt;capacity &lt;&lt;= 1;
<span class="p_del">-	else if (sector_size == 256)</span>
<span class="p_del">-		sdkp-&gt;capacity &gt;&gt;= 1;</span>
 
 	blk_queue_physical_block_size(sdp-&gt;request_queue,
 				      sdkp-&gt;physical_block_size);
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index bf8c5c1e254e..75efaaeb0eca 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1565,8 +1565,7 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 		break;
 	default:
 		vm_srb-&gt;data_in = UNKNOWN_TYPE;
<span class="p_del">-		vm_srb-&gt;win8_extension.srb_flags |= (SRB_FLAGS_DATA_IN |</span>
<span class="p_del">-						     SRB_FLAGS_DATA_OUT);</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.srb_flags |= SRB_FLAGS_NO_DATA_TRANSFER;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">index d1ab996b3305..a21a51efaad0 100644</span>
<span class="p_header">--- a/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">+++ b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 	unsigned int start_flag;
 	unsigned int payload_size;
 	unsigned short packet_type;
<span class="p_del">-	int dummy_cnt;</span>
<span class="p_add">+	int total_len;</span>
 	u32 packet_size_sum = r-&gt;offset;
 	int index;
 	int ret = TO_HOST_INVALID_PACKET;
<span class="p_chunk">@@ -176,10 +176,10 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		dummy_cnt = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
<span class="p_add">+		total_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
 
 		if (len - packet_size_sum &lt;
<span class="p_del">-			MUX_HEADER_SIZE + payload_size + dummy_cnt) {</span>
<span class="p_add">+			total_len) {</span>
 			pr_err(&quot;invalid payload : %d %d %04x\n&quot;,
 			       payload_size, len, packet_type);
 			break;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		packet_size_sum += MUX_HEADER_SIZE + payload_size + dummy_cnt;</span>
<span class="p_add">+		packet_size_sum += total_len;</span>
 		if (len - packet_size_sum &lt;= MUX_HEADER_SIZE + 2) {
 			ret = r-&gt;callback(NULL,
 					0,
<span class="p_chunk">@@ -361,7 +361,6 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	struct mux_pkt_header *mux_header;
 	struct mux_tx *t = NULL;
 	static u32 seq_num = 1;
<span class="p_del">-	int dummy_cnt;</span>
 	int total_len;
 	int ret;
 	unsigned long flags;
<span class="p_chunk">@@ -374,9 +373,7 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 
 	spin_lock_irqsave(&amp;mux_dev-&gt;write_lock, flags);
 
<span class="p_del">-	dummy_cnt = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
<span class="p_del">-</span>
<span class="p_del">-	total_len = len + MUX_HEADER_SIZE + dummy_cnt;</span>
<span class="p_add">+	total_len = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
 
 	t = alloc_mux_tx(total_len);
 	if (!t) {
<span class="p_chunk">@@ -392,7 +389,8 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	mux_header-&gt;packet_type = __cpu_to_le16(packet_type[tty_index]);
 
 	memcpy(t-&gt;buf+MUX_HEADER_SIZE, data, len);
<span class="p_del">-	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, dummy_cnt);</span>
<span class="p_add">+	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, total_len - MUX_HEADER_SIZE -</span>
<span class="p_add">+	       len);</span>
 
 	t-&gt;len = total_len;
 	t-&gt;callback = cb;
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index 03b2a90b9ac0..992236f605d8 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -911,7 +911,11 @@</span> <span class="p_context"> static int vnt_int_report_rate(struct vnt_private *priv,</span>
 
 	if (!(tsr1 &amp; TSR1_TERR)) {
 		info-&gt;status.rates[0].idx = idx;
<span class="p_del">-		info-&gt;flags |= IEEE80211_TX_STAT_ACK;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (info-&gt;flags &amp; IEEE80211_TX_CTL_NO_ACK)</span>
<span class="p_add">+			info-&gt;flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			info-&gt;flags |= IEEE80211_TX_STAT_ACK;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -936,9 +940,6 @@</span> <span class="p_context"> static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 		//Only the status of first TD in the chain is correct
 		if (pTD-&gt;m_td1TD1.byTCR &amp; TCR_STP) {
 			if ((pTD-&gt;pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB) != 0) {
<span class="p_del">-</span>
<span class="p_del">-				vnt_int_report_rate(pDevice, pTD-&gt;pTDInfo, byTsr0, byTsr1);</span>
<span class="p_del">-</span>
 				if (!(byTsr1 &amp; TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(&quot; Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n&quot;,
<span class="p_chunk">@@ -957,6 +958,9 @@</span> <span class="p_context"> static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 						 (int)uIdx, byTsr1, byTsr0);
 				}
 			}
<span class="p_add">+</span>
<span class="p_add">+			vnt_int_report_rate(pDevice, pTD-&gt;pTDInfo, byTsr0, byTsr1);</span>
<span class="p_add">+</span>
 			device_free_tx_buf(pDevice, pTD);
 			pDevice-&gt;iTDUsed[uIdx]--;
 		}
<span class="p_chunk">@@ -988,10 +992,8 @@</span> <span class="p_context"> static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)</span>
 				 PCI_DMA_TODEVICE);
 	}
 
<span class="p_del">-	if (pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB)</span>
<span class="p_add">+	if (skb)</span>
 		ieee80211_tx_status_irqsafe(pDevice-&gt;hw, skb);
<span class="p_del">-	else</span>
<span class="p_del">-		dev_kfree_skb_irq(skb);</span>
 
 	pTDInfo-&gt;skb_dma = 0;
 	pTDInfo-&gt;skb = NULL;
<span class="p_chunk">@@ -1201,14 +1203,6 @@</span> <span class="p_context"> static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 	if (dma_idx == TYPE_AC0DMA)
 		head_td-&gt;pTDInfo-&gt;byFlags = TD_FLAGS_NETIF_SKB;
 
<span class="p_del">-	priv-&gt;iTDUsed[dma_idx]++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Take ownership */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	head_td-&gt;m_td0TD0.f1Owner = OWNED_BY_NIC;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get Next */</span>
<span class="p_del">-	wmb();</span>
 	priv-&gt;apCurrTD[dma_idx] = head_td-&gt;next;
 
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1229,11 +1223,18 @@</span> <span class="p_context"> static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 
 	head_td-&gt;buff_addr = cpu_to_le32(head_td-&gt;pTDInfo-&gt;skb_dma);
 
<span class="p_add">+	/* Poll Transmit the adapter */</span>
<span class="p_add">+	wmb();</span>
<span class="p_add">+	head_td-&gt;m_td0TD0.f1Owner = OWNED_BY_NIC;</span>
<span class="p_add">+	wmb(); /* second memory barrier */</span>
<span class="p_add">+</span>
 	if (head_td-&gt;pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB)
 		MACvTransmitAC0(priv-&gt;PortOffset);
 	else
 		MACvTransmit0(priv-&gt;PortOffset);
 
<span class="p_add">+	priv-&gt;iTDUsed[dma_idx]++;</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
 
 	return 0;
<span class="p_chunk">@@ -1413,9 +1414,16 @@</span> <span class="p_context"> static void vnt_bss_info_changed(struct ieee80211_hw *hw,</span>
 
 	priv-&gt;current_aid = conf-&gt;aid;
 
<span class="p_del">-	if (changed &amp; BSS_CHANGED_BSSID)</span>
<span class="p_add">+	if (changed &amp; BSS_CHANGED_BSSID) {</span>
<span class="p_add">+		unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
 		MACvWriteBSSIDAddress(priv-&gt;PortOffset, (u8 *)conf-&gt;bssid);
 
<span class="p_add">+		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (changed &amp; BSS_CHANGED_BASIC_RATES) {
 		priv-&gt;basic_rates = conf-&gt;basic_rates;
 
<span class="p_header">diff --git a/drivers/staging/vt6656/rxtx.c b/drivers/staging/vt6656/rxtx.c</span>
<span class="p_header">index 33baf26de4b5..ee9ce165dcde 100644</span>
<span class="p_header">--- a/drivers/staging/vt6656/rxtx.c</span>
<span class="p_header">+++ b/drivers/staging/vt6656/rxtx.c</span>
<span class="p_chunk">@@ -805,10 +805,18 @@</span> <span class="p_context"> int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 		vnt_schedule_command(priv, WLAN_CMD_SETPOWER);
 	}
 
<span class="p_del">-	if (current_rate &gt; RATE_11M)</span>
<span class="p_del">-		pkt_type = priv-&gt;packet_type;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (current_rate &gt; RATE_11M) {</span>
<span class="p_add">+		if (info-&gt;band == IEEE80211_BAND_5GHZ) {</span>
<span class="p_add">+			pkt_type = PK_TYPE_11A;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (tx_rate-&gt;flags &amp; IEEE80211_TX_RC_USE_CTS_PROTECT)</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GB;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GA;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
 		pkt_type = PK_TYPE_11B;
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index f6c954c4635f..4073869d2090 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -521,6 +521,7 @@</span> <span class="p_context"> static int pscsi_configure_device(struct se_device *dev)</span>
 					&quot; pdv_host_id: %d\n&quot;, pdv-&gt;pdv_host_id);
 				return -EINVAL;
 			}
<span class="p_add">+			pdv-&gt;pdv_lld_host = sh;</span>
 		}
 	} else {
 		if (phv-&gt;phv_mode == PHV_VIRTUAL_HOST_ID) {
<span class="p_chunk">@@ -603,6 +604,8 @@</span> <span class="p_context"> static void pscsi_free_device(struct se_device *dev)</span>
 		if ((phv-&gt;phv_mode == PHV_LLD_SCSI_HOST_NO) &amp;&amp;
 		    (phv-&gt;phv_lld_host != NULL))
 			scsi_host_put(phv-&gt;phv_lld_host);
<span class="p_add">+		else if (pdv-&gt;pdv_lld_host)</span>
<span class="p_add">+			scsi_host_put(pdv-&gt;pdv_lld_host);</span>
 
 		if ((sd-&gt;type == TYPE_DISK) || (sd-&gt;type == TYPE_ROM))
 			scsi_device_put(sd);
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.h b/drivers/target/target_core_pscsi.h</span>
<span class="p_header">index 1bd757dff8ee..820d3052b775 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.h</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> struct pscsi_dev_virt {</span>
 	int	pdv_lun_id;
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
<span class="p_add">+	struct Scsi_Host *pdv_lld_host;</span>
 } ____cacheline_aligned;
 
 typedef enum phv_modes {
<span class="p_header">diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c</span>
<span class="p_header">index c2556cf5186b..01255fd65135 100644</span>
<span class="p_header">--- a/drivers/thermal/armada_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/armada_thermal.c</span>
<span class="p_chunk">@@ -224,9 +224,9 @@</span> <span class="p_context"> static const struct armada_thermal_data armada380_data = {</span>
 	.is_valid_shift = 10,
 	.temp_shift = 0,
 	.temp_mask = 0x3ff,
<span class="p_del">-	.coef_b = 1169498786UL,</span>
<span class="p_del">-	.coef_m = 2000000UL,</span>
<span class="p_del">-	.coef_div = 4289,</span>
<span class="p_add">+	.coef_b = 2931108200UL,</span>
<span class="p_add">+	.coef_m = 5000000UL,</span>
<span class="p_add">+	.coef_div = 10502,</span>
 	.inverted = true,
 };
 
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 5bab1c684bb1..7a3d146a5f0e 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 			return -ENOMEM;
 	}
 
<span class="p_del">-	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0);</span>
<span class="p_add">+	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);</span>
 	info-&gt;vtermno = HVC_COOKIE;
 
 	spin_lock(&amp;xencons_lock);
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index c4343764cc5b..bce16e405d59 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -3170,7 +3170,7 @@</span> <span class="p_context"> static int gsmtty_break_ctl(struct tty_struct *tty, int state)</span>
 	return gsmtty_modem_update(dlci, encode);
 }
 
<span class="p_del">-static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
<span class="p_add">+static void gsmtty_cleanup(struct tty_struct *tty)</span>
 {
 	struct gsm_dlci *dlci = tty-&gt;driver_data;
 	struct gsm_mux *gsm = dlci-&gt;gsm;
<span class="p_chunk">@@ -3178,7 +3178,6 @@</span> <span class="p_context"> static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
 	dlci_put(dlci);
 	dlci_put(gsm-&gt;dlci[0]);
 	mux_put(gsm);
<span class="p_del">-	driver-&gt;ttys[tty-&gt;index] = NULL;</span>
 }
 
 /* Virtual ttys for the demux */
<span class="p_chunk">@@ -3199,7 +3198,7 @@</span> <span class="p_context"> static const struct tty_operations gsmtty_ops = {</span>
 	.tiocmget		= gsmtty_tiocmget,
 	.tiocmset		= gsmtty_tiocmset,
 	.break_ctl		= gsmtty_break_ctl,
<span class="p_del">-	.remove			= gsmtty_remove,</span>
<span class="p_add">+	.cleanup		= gsmtty_cleanup,</span>
 };
 
 
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index 644ddb841d9f..bbc4ce66c2c1 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,</span>
 	add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);
 
 	for (;;) {
<span class="p_del">-		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags)) {</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		/* set bits for operations that won&#39;t block */
 		if (n_hdlc-&gt;rx_buf_list.head)
 			mask |= POLLIN | POLLRDNORM;	/* readable */
<span class="p_del">-		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags))</span>
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index cf6e0f2e1331..cc57a3a6b02b 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1949,6 +1949,18 @@</span> <span class="p_context"> static inline int input_available_p(struct tty_struct *tty, int poll)</span>
 		return ldata-&gt;commit_head - ldata-&gt;read_tail &gt;= amt;
 }
 
<span class="p_add">+static inline int check_other_done(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int done = test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags);</span>
<span class="p_add">+	if (done) {</span>
<span class="p_add">+		/* paired with cmpxchg() in check_other_closed(); ensures</span>
<span class="p_add">+		 * read buffer head index is not stale</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb__after_atomic();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return done;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	copy_from_read_buf	-	copy read data directly
  *	@tty: terminal device
<span class="p_chunk">@@ -2167,7 +2179,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 	unsigned char __user *b = buf;
 	DEFINE_WAIT_FUNC(wait, woken_wake_function);
<span class="p_del">-	int c;</span>
<span class="p_add">+	int c, done;</span>
 	int minimum, time;
 	ssize_t retval = 0;
 	long timeout;
<span class="p_chunk">@@ -2235,8 +2247,10 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 		    ((minimum - (b - buf)) &gt;= 1))
 			ldata-&gt;minimum_to_wake = (minimum - (b - buf));
 
<span class="p_add">+		done = check_other_done(tty);</span>
<span class="p_add">+</span>
 		if (!input_available_p(tty, 0)) {
<span class="p_del">-			if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+			if (done) {</span>
 				retval = -EIO;
 				break;
 			}
<span class="p_chunk">@@ -2443,12 +2457,12 @@</span> <span class="p_context"> static unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,</span>
 
 	poll_wait(file, &amp;tty-&gt;read_wait, wait);
 	poll_wait(file, &amp;tty-&gt;write_wait, wait);
<span class="p_add">+	if (check_other_done(tty))</span>
<span class="p_add">+		mask |= POLLHUP;</span>
 	if (input_available_p(tty, 1))
 		mask |= POLLIN | POLLRDNORM;
 	if (tty-&gt;packet &amp;&amp; tty-&gt;link-&gt;ctrl_status)
 		mask |= POLLPRI | POLLIN | POLLRDNORM;
<span class="p_del">-	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_del">-		mask |= POLLHUP;</span>
 	if (tty_hung_up_p(file))
 		mask |= POLLHUP;
 	if (!(mask &amp; (POLLHUP | POLLIN | POLLRDNORM))) {
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index e72ee629cead..4d5e8409769c 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -53,9 +53,8 @@</span> <span class="p_context"> static void pty_close(struct tty_struct *tty, struct file *filp)</span>
 	/* Review - krefs on tty_link ?? */
 	if (!tty-&gt;link)
 		return;
<span class="p_del">-	tty_flush_to_ldisc(tty-&gt;link);</span>
 	set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait);</span>
<span class="p_add">+	tty_flip_buffer_push(tty-&gt;link-&gt;port);</span>
 	wake_up_interruptible(&amp;tty-&gt;link-&gt;write_wait);
 	if (tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags);
<span class="p_chunk">@@ -243,7 +242,9 @@</span> <span class="p_context"> static int pty_open(struct tty_struct *tty, struct file *filp)</span>
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);
<span class="p_add">+	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */</span>
 	clear_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_add">+	clear_bit(TTY_OTHER_DONE, &amp;tty-&gt;link-&gt;flags);</span>
 	set_bit(TTY_THROTTLED, &amp;tty-&gt;flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 75661641f5fe..2f78b77f0f81 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -37,6 +37,28 @@</span> <span class="p_context"></span>
 
 #define TTY_BUFFER_PAGE	(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) &amp; ~0xFF)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * If all tty flip buffers have been processed by flush_to_ldisc() or</span>
<span class="p_add">+ * dropped by tty_buffer_flush(), check if the linked pty has been closed.</span>
<span class="p_add">+ * If so, wake the reader/poll to process</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void check_other_closed(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags, old;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* transition from TTY_OTHER_CLOSED =&gt; TTY_OTHER_DONE must be atomic */</span>
<span class="p_add">+	for (flags = ACCESS_ONCE(tty-&gt;flags);</span>
<span class="p_add">+	     test_bit(TTY_OTHER_CLOSED, &amp;flags);</span>
<span class="p_add">+	     ) {</span>
<span class="p_add">+		old = flags;</span>
<span class="p_add">+		__set_bit(TTY_OTHER_DONE, &amp;flags);</span>
<span class="p_add">+		flags = cmpxchg(&amp;tty-&gt;flags, old, flags);</span>
<span class="p_add">+		if (old == flags) {</span>
<span class="p_add">+			wake_up_interruptible(&amp;tty-&gt;read_wait);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 /**
  *	tty_buffer_lock_exclusive	-	gain exclusive access to buffer
<span class="p_chunk">@@ -229,6 +251,8 @@</span> <span class="p_context"> void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)</span>
 	if (ld &amp;&amp; ld-&gt;ops-&gt;flush_buffer)
 		ld-&gt;ops-&gt;flush_buffer(tty);
 
<span class="p_add">+	check_other_closed(tty);</span>
<span class="p_add">+</span>
 	atomic_dec(&amp;buf-&gt;priority);
 	mutex_unlock(&amp;buf-&gt;lock);
 }
<span class="p_chunk">@@ -471,8 +495,10 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 		smp_rmb();
 		count = head-&gt;commit - head-&gt;read;
 		if (!count) {
<span class="p_del">-			if (next == NULL)</span>
<span class="p_add">+			if (next == NULL) {</span>
<span class="p_add">+				check_other_closed(tty);</span>
 				break;
<span class="p_add">+			}</span>
 			buf-&gt;head = next;
 			tty_buffer_free(port, head);
 			continue;
<span class="p_chunk">@@ -489,19 +515,6 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 }
 
 /**
<span class="p_del">- *	tty_flush_to_ldisc</span>
<span class="p_del">- *	@tty: tty to push</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Push the terminal flip buffers to the line discipline.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Must not be called from IRQ context.</span>
<span class="p_del">- */</span>
<span class="p_del">-void tty_flush_to_ldisc(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	flush_work(&amp;tty-&gt;port-&gt;buf.work);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  *	tty_flip_buffer_push	-	terminal
  *	@port: tty port to push
  *
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index c42765b3a060..0495c94a23d7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -1295,6 +1295,7 @@</span> <span class="p_context"> static void purge_configs_funcs(struct gadget_info *gi)</span>
 			}
 		}
 		c-&gt;next_interface_id = 0;
<span class="p_add">+		memset(c-&gt;interface, 0, sizeof(c-&gt;interface));</span>
 		c-&gt;superspeed = 0;
 		c-&gt;highspeed = 0;
 		c-&gt;fullspeed = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index eeedde8c435a..6994c99e58a6 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2026,8 +2026,13 @@</span> <span class="p_context"> static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
<span class="p_add">+		frame-&gt;status = -EPROTO;</span>
<span class="p_add">+		skip_td = true;</span>
<span class="p_add">+		break;</span>
 	case COMP_TX_ERR:
 		frame-&gt;status = -EPROTO;
<span class="p_add">+		if (event_trb != td-&gt;last_trb)</span>
<span class="p_add">+			return 0;</span>
 		skip_td = true;
 		break;
 	case COMP_STOP:
<span class="p_chunk">@@ -2640,7 +2645,7 @@</span> <span class="p_context"> irqreturn_t xhci_irq(struct usb_hcd *hcd)</span>
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&amp;xhci-&gt;lock);
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		return IRQ_HANDLED;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 8e421b89632d..ea75e8ccd3c1 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1267,7 +1267,7 @@</span> <span class="p_context"> union xhci_trb {</span>
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
<span class="p_del">-#define TRBS_PER_SEGMENT	64</span>
<span class="p_add">+#define TRBS_PER_SEGMENT	256</span>
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 84ce2d74894c..9031750e7404 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -127,6 +127,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index 829604d11f3f..f5257af33ecf 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -61,7 +61,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },</span>
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index 71fd9da1d6e7..e3b7af8adfb7 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"></span>
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
<span class="p_del">-/* Samsung I330 phone cradle */</span>
<span class="p_del">-#define SAMSUNG_VENDOR_ID	0x04e8</span>
<span class="p_del">-#define SAMSUNG_PRODUCT_ID	0x8001</span>
<span class="p_del">-</span>
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index bf2bd40e5f2a..60afb39eb73c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID),</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index d684b4b8108f..caf188800c67 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -766,6 +766,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
<span class="p_add">+/* Reported by Christian Schaller &lt;cschalle@redhat.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,</span>
<span class="p_add">+		&quot;LaCie&quot;,</span>
<span class="p_add">+		&quot;External HDD&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don&#39;t.
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 2b8553bd8715..38387950490e 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -957,7 +957,7 @@</span> <span class="p_context"> unsigned xen_evtchn_nr_channels(void)</span>
 }
 EXPORT_SYMBOL_GPL(xen_evtchn_nr_channels);
 
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)</span>
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq, ret;
<span class="p_chunk">@@ -971,8 +971,12 @@</span> <span class="p_context"> int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
 		if (irq &lt; 0)
 			goto out;
 
<span class="p_del">-		irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_del">-					      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		if (percpu)</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_add">+						      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip,</span>
<span class="p_add">+						      handle_edge_irq, &quot;virq&quot;);</span>
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
<span class="p_chunk">@@ -1062,7 +1066,7 @@</span> <span class="p_context"> int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,</span>
 {
 	int irq, retval;
 
<span class="p_del">-	irq = bind_virq_to_irq(virq, cpu);</span>
<span class="p_add">+	irq = bind_virq_to_irq(virq, cpu, irqflags &amp; IRQF_PERCPU);</span>
 	if (irq &lt; 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index d925f55e4857..8081aba116a7 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -928,7 +928,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 			total_size = total_mapping_size(elf_phdata,
 							loc-&gt;elf_ex.e_phnum);
 			if (!total_size) {
<span class="p_del">-				error = -EINVAL;</span>
<span class="p_add">+				retval = -EINVAL;</span>
 				goto out_free_dentry;
 			}
 		}
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 0a795c969c78..8b33da6ec3dd 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -8548,7 +8548,9 @@</span> <span class="p_context"> int btrfs_set_block_group_ro(struct btrfs_root *root,</span>
 out:
 	if (cache-&gt;flags &amp; BTRFS_BLOCK_GROUP_SYSTEM) {
 		alloc_flags = update_block_group_flags(root, cache-&gt;flags);
<span class="p_add">+		lock_chunks(root-&gt;fs_info-&gt;chunk_root);</span>
 		check_system_chunk(trans, root, alloc_flags);
<span class="p_add">+		unlock_chunks(root-&gt;fs_info-&gt;chunk_root);</span>
 	}
 
 	btrfs_end_transaction(trans, root);
<span class="p_header">diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c</span>
<span class="p_header">index 8222f6f74147..44a7e0398d97 100644</span>
<span class="p_header">--- a/fs/btrfs/volumes.c</span>
<span class="p_header">+++ b/fs/btrfs/volumes.c</span>
<span class="p_chunk">@@ -4626,6 +4626,7 @@</span> <span class="p_context"> int btrfs_alloc_chunk(struct btrfs_trans_handle *trans,</span>
 {
 	u64 chunk_offset;
 
<span class="p_add">+	ASSERT(mutex_is_locked(&amp;extent_root-&gt;fs_info-&gt;chunk_mutex));</span>
 	chunk_offset = find_next_chunk(extent_root-&gt;fs_info);
 	return __btrfs_alloc_chunk(trans, extent_root, chunk_offset, type);
 }
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index c71e3732e53b..922f23ef6041 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1205,13 +1205,13 @@</span> <span class="p_context"> ascend:</span>
 		/* might go back up the wrong parent if we have had a rename. */
 		if (need_seqretry(&amp;rename_lock, seq))
 			goto rename_retry;
<span class="p_del">-		next = child-&gt;d_child.next;</span>
<span class="p_del">-		while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+		/* go into the first sibling still alive */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			next = child-&gt;d_child.next;</span>
 			if (next == &amp;this_parent-&gt;d_subdirs)
 				goto ascend;
 			child = list_entry(next, struct dentry, d_child);
<span class="p_del">-			next = next-&gt;next;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		} while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span>
 		rcu_read_unlock();
 		goto resume;
 	}
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 00400cf522dc..120244523647 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -659,6 +659,9 @@</span> <span class="p_context"> int setup_arg_pages(struct linux_binprm *bprm,</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	/* Make sure we didn&#39;t let the argument array grow too large. */
 	if (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">index 3445035c7e01..d41843181818 100644</span>
<span class="p_header">--- a/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">+++ b/fs/ext4/ext4_jbd2.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)</span>
 		ext4_put_nojournal(handle);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!handle-&gt;h_transaction) {</span>
<span class="p_add">+		err = jbd2_journal_stop(handle);</span>
<span class="p_add">+		return handle-&gt;h_err ? handle-&gt;h_err : err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sb = handle-&gt;h_transaction-&gt;t_journal-&gt;j_private;
 	err = handle-&gt;h_err;
 	rc = jbd2_journal_stop(handle);
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 16f6365f65e7..ea4ee1732143 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
 	ext4_lblk_t last = lblock + len - 1;
 
<span class="p_del">-	if (lblock &gt; last)</span>
<span class="p_add">+	if (len == 0 || lblock &gt; last)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 852cc521f327..1f252b4e0f51 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -4233,7 +4233,7 @@</span> <span class="p_context"> static void ext4_update_other_inodes_time(struct super_block *sb,</span>
 	int inode_size = EXT4_INODE_SIZE(sb);
 
 	oi.orig_ino = orig_ino;
<span class="p_del">-	ino = orig_ino &amp; ~(inodes_per_block - 1);</span>
<span class="p_add">+	ino = (orig_ino &amp; ~(inodes_per_block - 1)) + 1;</span>
 	for (i = 0; i &lt; inodes_per_block; i++, ino++, buf += inode_size) {
 		if (ino == orig_ino)
 			continue;
<span class="p_header">diff --git a/fs/fhandle.c b/fs/fhandle.c</span>
<span class="p_header">index 999ff5c3cab0..d59712dfa3e7 100644</span>
<span class="p_header">--- a/fs/fhandle.c</span>
<span class="p_header">+++ b/fs/fhandle.c</span>
<span class="p_chunk">@@ -195,8 +195,9 @@</span> <span class="p_context"> static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,</span>
 		goto out_err;
 	}
 	/* copy the full handle */
<span class="p_del">-	if (copy_from_user(handle, ufh,</span>
<span class="p_del">-			   sizeof(struct file_handle) +</span>
<span class="p_add">+	*handle = f_handle;</span>
<span class="p_add">+	if (copy_from_user(&amp;handle-&gt;f_handle,</span>
<span class="p_add">+			   &amp;ufh-&gt;f_handle,</span>
 			   f_handle.handle_bytes)) {
 		retval = -EFAULT;
 		goto out_handle;
<span class="p_header">diff --git a/fs/fs_pin.c b/fs/fs_pin.c</span>
<span class="p_header">index b06c98796afb..611b5408f6ec 100644</span>
<span class="p_header">--- a/fs/fs_pin.c</span>
<span class="p_header">+++ b/fs/fs_pin.c</span>
<span class="p_chunk">@@ -9,8 +9,8 @@</span> <span class="p_context"> static DEFINE_SPINLOCK(pin_lock);</span>
 void pin_remove(struct fs_pin *pin)
 {
 	spin_lock(&amp;pin_lock);
<span class="p_del">-	hlist_del(&amp;pin-&gt;m_list);</span>
<span class="p_del">-	hlist_del(&amp;pin-&gt;s_list);</span>
<span class="p_add">+	hlist_del_init(&amp;pin-&gt;m_list);</span>
<span class="p_add">+	hlist_del_init(&amp;pin-&gt;s_list);</span>
 	spin_unlock(&amp;pin_lock);
 	spin_lock_irq(&amp;pin-&gt;wait.lock);
 	pin-&gt;done = 1;
<span class="p_header">diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c</span>
<span class="p_header">index b5128c6e63ad..a9079d035ae5 100644</span>
<span class="p_header">--- a/fs/jbd2/recovery.c</span>
<span class="p_header">+++ b/fs/jbd2/recovery.c</span>
<span class="p_chunk">@@ -842,15 +842,23 @@</span> <span class="p_context"> static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,</span>
 {
 	jbd2_journal_revoke_header_t *header;
 	int offset, max;
<span class="p_add">+	int csum_size = 0;</span>
<span class="p_add">+	__u32 rcount;</span>
 	int record_len = 4;
 
 	header = (jbd2_journal_revoke_header_t *) bh-&gt;b_data;
 	offset = sizeof(jbd2_journal_revoke_header_t);
<span class="p_del">-	max = be32_to_cpu(header-&gt;r_count);</span>
<span class="p_add">+	rcount = be32_to_cpu(header-&gt;r_count);</span>
 
 	if (!jbd2_revoke_block_csum_verify(journal, header))
 		return -EINVAL;
 
<span class="p_add">+	if (jbd2_journal_has_csum_v2or3(journal))</span>
<span class="p_add">+		csum_size = sizeof(struct jbd2_journal_revoke_tail);</span>
<span class="p_add">+	if (rcount &gt; journal-&gt;j_blocksize - csum_size)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	max = rcount;</span>
<span class="p_add">+</span>
 	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))
 		record_len = 8;
 
<span class="p_header">diff --git a/fs/jbd2/revoke.c b/fs/jbd2/revoke.c</span>
<span class="p_header">index c6cbaef2bda1..14214da80eb8 100644</span>
<span class="p_header">--- a/fs/jbd2/revoke.c</span>
<span class="p_header">+++ b/fs/jbd2/revoke.c</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 {
 	int csum_size = 0;
 	struct buffer_head *descriptor;
<span class="p_del">-	int offset;</span>
<span class="p_add">+	int sz, offset;</span>
 	journal_header_t *header;
 
 	/* If we are already aborting, this all becomes a noop.  We
<span class="p_chunk">@@ -594,9 +594,14 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 	if (jbd2_journal_has_csum_v2or3(journal))
 		csum_size = sizeof(struct jbd2_journal_revoke_tail);
 
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
<span class="p_add">+		sz = 8;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sz = 4;</span>
<span class="p_add">+</span>
 	/* Make sure we have a descriptor with space left for the record */
 	if (descriptor) {
<span class="p_del">-		if (offset &gt;= journal-&gt;j_blocksize - csum_size) {</span>
<span class="p_add">+		if (offset + sz &gt; journal-&gt;j_blocksize - csum_size) {</span>
 			flush_descriptor(journal, descriptor, offset, write_op);
 			descriptor = NULL;
 		}
<span class="p_chunk">@@ -619,16 +624,13 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 		*descriptorp = descriptor;
 	}
 
<span class="p_del">-	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {</span>
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
 		* ((__be64 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be64(record-&gt;blocknr);
<span class="p_del">-		offset += 8;</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else</span>
 		* ((__be32 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be32(record-&gt;blocknr);
<span class="p_del">-		offset += 4;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	offset += sz;</span>
 
 	*offsetp = offset;
 }
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 5f09370c90a8..ff2f2e6ad311 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -551,7 +551,6 @@</span> <span class="p_context"> int jbd2_journal_extend(handle_t *handle, int nblocks)</span>
 	int result;
 	int wanted;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -627,7 +626,6 @@</span> <span class="p_context"> int jbd2__journal_restart(handle_t *handle, int nblocks, gfp_t gfp_mask)</span>
 	tid_t		tid;
 	int		need_to_start, ret;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	/* If we&#39;ve had an abort of any type, don&#39;t even think about
 	 * actually doing the restart! */
 	if (is_handle_aborted(handle))
<span class="p_chunk">@@ -785,7 +783,6 @@</span> <span class="p_context"> do_get_write_access(handle_t *handle, struct journal_head *jh,</span>
 	int need_copy = 0;
 	unsigned long start_lock, time_lock;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1051,7 +1048,6 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 	int err;
 
 	jbd_debug(5, &quot;journal_head %p\n&quot;, jh);
<span class="p_del">-	WARN_ON(!transaction);</span>
 	err = -EROFS;
 	if (is_handle_aborted(handle))
 		goto out;
<span class="p_chunk">@@ -1266,7 +1262,6 @@</span> <span class="p_context"> int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)</span>
 	struct journal_head *jh;
 	int ret = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1397,7 +1392,6 @@</span> <span class="p_context"> int jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)</span>
 	int err = 0;
 	int was_modified = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1530,8 +1524,22 @@</span> <span class="p_context"> int jbd2_journal_stop(handle_t *handle)</span>
 	tid_t tid;
 	pid_t pid;
 
<span class="p_del">-	if (!transaction)</span>
<span class="p_del">-		goto free_and_exit;</span>
<span class="p_add">+	if (!transaction) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Handle is already detached from the transaction so</span>
<span class="p_add">+		 * there is nothing to do other than decrease a refcount,</span>
<span class="p_add">+		 * or free the handle if refcount drops to zero</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (--handle-&gt;h_ref &gt; 0) {</span>
<span class="p_add">+			jbd_debug(4, &quot;h_ref %d -&gt; %d\n&quot;, handle-&gt;h_ref + 1,</span>
<span class="p_add">+							 handle-&gt;h_ref);</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (handle-&gt;h_rsv_handle)</span>
<span class="p_add">+				jbd2_free_handle(handle-&gt;h_rsv_handle);</span>
<span class="p_add">+			goto free_and_exit;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	journal = transaction-&gt;t_journal;
 
 	J_ASSERT(journal_current_handle() == handle);
<span class="p_chunk">@@ -2373,7 +2381,6 @@</span> <span class="p_context"> int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode)</span>
 	transaction_t *transaction = handle-&gt;h_transaction;
 	journal_t *journal;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_header">diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c</span>
<span class="p_header">index 6acc9648f986..345b35fd329d 100644</span>
<span class="p_header">--- a/fs/kernfs/dir.c</span>
<span class="p_header">+++ b/fs/kernfs/dir.c</span>
<span class="p_chunk">@@ -518,7 +518,14 @@</span> <span class="p_context"> static struct kernfs_node *__kernfs_new_node(struct kernfs_root *root,</span>
 	if (!kn)
 		goto err_out1;
 
<span class="p_del">-	ret = ida_simple_get(&amp;root-&gt;ino_ida, 1, 0, GFP_KERNEL);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the ino of the sysfs entry created for a kmem cache gets</span>
<span class="p_add">+	 * allocated from an ida layer, which is accounted to the memcg that</span>
<span class="p_add">+	 * owns the cache, the memcg will get pinned forever. So do not account</span>
<span class="p_add">+	 * ino ida allocations.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = ida_simple_get(&amp;root-&gt;ino_ida, 1, 0,</span>
<span class="p_add">+			     GFP_KERNEL | __GFP_NOACCOUNT);</span>
 	if (ret &lt; 0)
 		goto err_out2;
 	kn-&gt;ino = ret;
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 38ed1e1bed41..13b0f7bfc096 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -1709,8 +1709,11 @@</span> <span class="p_context"> struct vfsmount *collect_mounts(struct path *path)</span>
 {
 	struct mount *tree;
 	namespace_lock();
<span class="p_del">-	tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry,</span>
<span class="p_del">-			 CL_COPY_ALL | CL_PRIVATE);</span>
<span class="p_add">+	if (!check_mnt(real_mount(path-&gt;mnt)))</span>
<span class="p_add">+		tree = ERR_PTR(-EINVAL);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry,</span>
<span class="p_add">+				 CL_COPY_ALL | CL_PRIVATE);</span>
 	namespace_unlock();
 	if (IS_ERR(tree))
 		return ERR_CAST(tree);
<span class="p_header">diff --git a/fs/nfsd/blocklayout.c b/fs/nfsd/blocklayout.c</span>
<span class="p_header">index 03d647bf195d..cdefaa331a07 100644</span>
<span class="p_header">--- a/fs/nfsd/blocklayout.c</span>
<span class="p_header">+++ b/fs/nfsd/blocklayout.c</span>
<span class="p_chunk">@@ -181,6 +181,17 @@</span> <span class="p_context"> nfsd4_block_proc_layoutcommit(struct inode *inode,</span>
 }
 
 const struct nfsd4_layout_ops bl_layout_ops = {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pretend that we send notification to the client.  This is a blatant</span>
<span class="p_add">+	 * lie to force recent Linux clients to cache our device IDs.</span>
<span class="p_add">+	 * We rarely ever change the device ID, so the harm of leaking deviceids</span>
<span class="p_add">+	 * for a while isn&#39;t too bad.  Unfortunately RFC5661 is a complete mess</span>
<span class="p_add">+	 * in this regard, but I filed errata 4119 for this a while ago, and</span>
<span class="p_add">+	 * hopefully the Linux client will eventually start caching deviceids</span>
<span class="p_add">+	 * without this again.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.notify_types		=</span>
<span class="p_add">+			NOTIFY_DEVICEID4_DELETE | NOTIFY_DEVICEID4_CHANGE,</span>
 	.proc_getdeviceinfo	= nfsd4_block_proc_getdeviceinfo,
 	.encode_getdeviceinfo	= nfsd4_block_encode_getdeviceinfo,
 	.proc_layoutget		= nfsd4_block_proc_layoutget,
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index ee1cccdb083a..b4541ede7cb8 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -4386,10 +4386,17 @@</span> <span class="p_context"> static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_s</span>
 	return nfserr_old_stateid;
 }
 
<span class="p_add">+static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ols-&gt;st_stateowner-&gt;so_is_open_owner &amp;&amp;</span>
<span class="p_add">+	    !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	return nfs_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 {
 	struct nfs4_stid *s;
<span class="p_del">-	struct nfs4_ol_stateid *ols;</span>
 	__be32 status = nfserr_bad_stateid;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
<span class="p_chunk">@@ -4419,13 +4426,7 @@</span> <span class="p_context"> static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)</span>
 		break;
 	case NFS4_OPEN_STID:
 	case NFS4_LOCK_STID:
<span class="p_del">-		ols = openlockstateid(s);</span>
<span class="p_del">-		if (ols-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-	    			&amp;&amp; !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags</span>
<span class="p_del">-						&amp; NFS4_OO_CONFIRMED))</span>
<span class="p_del">-			status = nfserr_bad_stateid;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			status = nfs_ok;</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(openlockstateid(s));</span>
 		break;
 	default:
 		printk(&quot;unknown stateid type %x\n&quot;, s-&gt;sc_type);
<span class="p_chunk">@@ -4517,8 +4518,8 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,</span>
 		status = nfs4_check_fh(current_fh, stp);
 		if (status)
 			goto out;
<span class="p_del">-		if (stp-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-		    &amp;&amp; !(openowner(stp-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_add">+		if (status)</span>
 			goto out;
 		status = nfs4_check_openmode(stp, flags);
 		if (status)
<span class="p_header">diff --git a/fs/omfs/inode.c b/fs/omfs/inode.c</span>
<span class="p_header">index 138321b0c6c2..454111a3308e 100644</span>
<span class="p_header">--- a/fs/omfs/inode.c</span>
<span class="p_header">+++ b/fs/omfs/inode.c</span>
<span class="p_chunk">@@ -306,7 +306,8 @@</span> <span class="p_context"> static const struct super_operations omfs_sops = {</span>
  */
 static int omfs_get_imap(struct super_block *sb)
 {
<span class="p_del">-	unsigned int bitmap_size, count, array_size;</span>
<span class="p_add">+	unsigned int bitmap_size, array_size;</span>
<span class="p_add">+	int count;</span>
 	struct omfs_sb_info *sbi = OMFS_SB(sb);
 	struct buffer_head *bh;
 	unsigned long **ptr;
<span class="p_chunk">@@ -359,7 +360,7 @@</span> <span class="p_context"> nomem:</span>
 }
 
 enum {
<span class="p_del">-	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask</span>
<span class="p_add">+	Opt_uid, Opt_gid, Opt_umask, Opt_dmask, Opt_fmask, Opt_err</span>
 };
 
 static const match_table_t tokens = {
<span class="p_chunk">@@ -368,6 +369,7 @@</span> <span class="p_context"> static const match_table_t tokens = {</span>
 	{Opt_umask, &quot;umask=%o&quot;},
 	{Opt_dmask, &quot;dmask=%o&quot;},
 	{Opt_fmask, &quot;fmask=%o&quot;},
<span class="p_add">+	{Opt_err, NULL},</span>
 };
 
 static int parse_options(char *options, struct omfs_sb_info *sbi)
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 24f640441bd9..84d693d37428 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -299,6 +299,9 @@</span> <span class="p_context"> int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry,</span>
 	struct cred *override_cred;
 	char *link = NULL;
 
<span class="p_add">+	if (WARN_ON(!workdir))</span>
<span class="p_add">+		return -EROFS;</span>
<span class="p_add">+</span>
 	ovl_path_upper(parent, &amp;parentpath);
 	upperdir = parentpath.dentry;
 
<span class="p_header">diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c</span>
<span class="p_header">index d139405d2bfa..692ceda3bc21 100644</span>
<span class="p_header">--- a/fs/overlayfs/dir.c</span>
<span class="p_header">+++ b/fs/overlayfs/dir.c</span>
<span class="p_chunk">@@ -222,6 +222,9 @@</span> <span class="p_context"> static struct dentry *ovl_clear_empty(struct dentry *dentry,</span>
 	struct kstat stat;
 	int err;
 
<span class="p_add">+	if (WARN_ON(!workdir))</span>
<span class="p_add">+		return ERR_PTR(-EROFS);</span>
<span class="p_add">+</span>
 	err = ovl_lock_rename_workdir(workdir, upperdir);
 	if (err)
 		goto out;
<span class="p_chunk">@@ -322,6 +325,9 @@</span> <span class="p_context"> static int ovl_create_over_whiteout(struct dentry *dentry, struct inode *inode,</span>
 	struct dentry *newdentry;
 	int err;
 
<span class="p_add">+	if (WARN_ON(!workdir))</span>
<span class="p_add">+		return -EROFS;</span>
<span class="p_add">+</span>
 	err = ovl_lock_rename_workdir(workdir, upperdir);
 	if (err)
 		goto out;
<span class="p_chunk">@@ -506,11 +512,28 @@</span> <span class="p_context"> static int ovl_remove_and_whiteout(struct dentry *dentry, bool is_dir)</span>
 	struct dentry *opaquedir = NULL;
 	int err;
 
<span class="p_del">-	if (is_dir &amp;&amp; OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {</span>
<span class="p_del">-		opaquedir = ovl_check_empty_and_clear(dentry);</span>
<span class="p_del">-		err = PTR_ERR(opaquedir);</span>
<span class="p_del">-		if (IS_ERR(opaquedir))</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+	if (WARN_ON(!workdir))</span>
<span class="p_add">+		return -EROFS;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_dir) {</span>
<span class="p_add">+		if (OVL_TYPE_MERGE_OR_LOWER(ovl_path_type(dentry))) {</span>
<span class="p_add">+			opaquedir = ovl_check_empty_and_clear(dentry);</span>
<span class="p_add">+			err = PTR_ERR(opaquedir);</span>
<span class="p_add">+			if (IS_ERR(opaquedir))</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			LIST_HEAD(list);</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * When removing an empty opaque directory, then it</span>
<span class="p_add">+			 * makes no sense to replace it with an exact replica of</span>
<span class="p_add">+			 * itself.  But emptiness still needs to be checked.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			err = ovl_check_empty_dir(dentry, &amp;list);</span>
<span class="p_add">+			ovl_cache_free(&amp;list);</span>
<span class="p_add">+			if (err)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = ovl_lock_rename_workdir(workdir, upperdir);
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index 5f0d1993e6e3..bf8537c7f455 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -529,7 +529,7 @@</span> <span class="p_context"> static int ovl_remount(struct super_block *sb, int *flags, char *data)</span>
 {
 	struct ovl_fs *ufs = sb-&gt;s_fs_info;
 
<span class="p_del">-	if (!(*flags &amp; MS_RDONLY) &amp;&amp; !ufs-&gt;upper_mnt)</span>
<span class="p_add">+	if (!(*flags &amp; MS_RDONLY) &amp;&amp; (!ufs-&gt;upper_mnt || !ufs-&gt;workdir))</span>
 		return -EROFS;
 
 	return 0;
<span class="p_chunk">@@ -925,9 +925,10 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 		ufs-&gt;workdir = ovl_workdir_create(ufs-&gt;upper_mnt, workpath.dentry);
 		err = PTR_ERR(ufs-&gt;workdir);
 		if (IS_ERR(ufs-&gt;workdir)) {
<span class="p_del">-			pr_err(&quot;overlayfs: failed to create directory %s/%s\n&quot;,</span>
<span class="p_del">-			       ufs-&gt;config.workdir, OVL_WORKDIR_NAME);</span>
<span class="p_del">-			goto out_put_upper_mnt;</span>
<span class="p_add">+			pr_warn(&quot;overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n&quot;,</span>
<span class="p_add">+				ufs-&gt;config.workdir, OVL_WORKDIR_NAME, -err);</span>
<span class="p_add">+			sb-&gt;s_flags |= MS_RDONLY;</span>
<span class="p_add">+			ufs-&gt;workdir = NULL;</span>
 		}
 	}
 
<span class="p_chunk">@@ -997,7 +998,6 @@</span> <span class="p_context"> out_put_lower_mnt:</span>
 	kfree(ufs-&gt;lower_mnt);
 out_put_workdir:
 	dput(ufs-&gt;workdir);
<span class="p_del">-out_put_upper_mnt:</span>
 	mntput(ufs-&gt;upper_mnt);
 out_put_lowerpath:
 	for (i = 0; i &lt; numlower; i++)
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_attr_leaf.c b/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_header">index 15105dbc9e28..0166e7e829a7 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_attr_leaf.c</span>
<span class="p_chunk">@@ -498,8 +498,8 @@</span> <span class="p_context"> xfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)</span>
  * After the last attribute is removed revert to original inode format,
  * making all literal area available to the data fork once more.
  */
<span class="p_del">-STATIC void</span>
<span class="p_del">-xfs_attr_fork_reset(</span>
<span class="p_add">+void</span>
<span class="p_add">+xfs_attr_fork_remove(</span>
 	struct xfs_inode	*ip,
 	struct xfs_trans	*tp)
 {
<span class="p_chunk">@@ -565,7 +565,7 @@</span> <span class="p_context"> xfs_attr_shortform_remove(xfs_da_args_t *args)</span>
 	    (mp-&gt;m_flags &amp; XFS_MOUNT_ATTR2) &amp;&amp;
 	    (dp-&gt;i_d.di_format != XFS_DINODE_FMT_BTREE) &amp;&amp;
 	    !(args-&gt;op_flags &amp; XFS_DA_OP_ADDNAME)) {
<span class="p_del">-		xfs_attr_fork_reset(dp, args-&gt;trans);</span>
<span class="p_add">+		xfs_attr_fork_remove(dp, args-&gt;trans);</span>
 	} else {
 		xfs_idata_realloc(dp, -size, XFS_ATTR_FORK);
 		dp-&gt;i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> xfs_attr3_leaf_to_shortform(</span>
 	if (forkoff == -1) {
 		ASSERT(dp-&gt;i_mount-&gt;m_flags &amp; XFS_MOUNT_ATTR2);
 		ASSERT(dp-&gt;i_d.di_format != XFS_DINODE_FMT_BTREE);
<span class="p_del">-		xfs_attr_fork_reset(dp, args-&gt;trans);</span>
<span class="p_add">+		xfs_attr_fork_remove(dp, args-&gt;trans);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_attr_leaf.h b/fs/xfs/libxfs/xfs_attr_leaf.h</span>
<span class="p_header">index e2929da7c3ba..4f3a60aa93d4 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_attr_leaf.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_attr_leaf.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> int	xfs_attr_shortform_remove(struct xfs_da_args *args);</span>
 int	xfs_attr_shortform_list(struct xfs_attr_list_context *context);
 int	xfs_attr_shortform_allfit(struct xfs_buf *bp, struct xfs_inode *dp);
 int	xfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes);
<span class="p_del">-</span>
<span class="p_add">+void	xfs_attr_fork_remove(struct xfs_inode *ip, struct xfs_trans *tp);</span>
 
 /*
  * Internal routines when attribute fork size == XFS_LBSIZE(mp).
<span class="p_header">diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">index 83af4c149635..487c8374a1e0 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_chunk">@@ -379,23 +379,31 @@</span> <span class="p_context"> xfs_attr3_root_inactive(</span>
 	return error;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * xfs_attr_inactive kills all traces of an attribute fork on an inode. It</span>
<span class="p_add">+ * removes both the on-disk and in-memory inode fork. Note that this also has to</span>
<span class="p_add">+ * handle the condition of inodes without attributes but with an attribute fork</span>
<span class="p_add">+ * configured, so we can&#39;t use xfs_inode_hasattr() here.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The in-memory attribute fork is removed even on error.</span>
<span class="p_add">+ */</span>
 int
<span class="p_del">-xfs_attr_inactive(xfs_inode_t *dp)</span>
<span class="p_add">+xfs_attr_inactive(</span>
<span class="p_add">+	struct xfs_inode	*dp)</span>
 {
<span class="p_del">-	xfs_trans_t *trans;</span>
<span class="p_del">-	xfs_mount_t *mp;</span>
<span class="p_del">-	int error;</span>
<span class="p_add">+	struct xfs_trans	*trans;</span>
<span class="p_add">+	struct xfs_mount	*mp;</span>
<span class="p_add">+	int			cancel_flags = 0;</span>
<span class="p_add">+	int			lock_mode = XFS_ILOCK_SHARED;</span>
<span class="p_add">+	int			error = 0;</span>
 
 	mp = dp-&gt;i_mount;
 	ASSERT(! XFS_NOT_DQATTACHED(mp, dp));
 
<span class="p_del">-	xfs_ilock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_del">-	if (!xfs_inode_hasattr(dp) ||</span>
<span class="p_del">-	    dp-&gt;i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_del">-		xfs_iunlock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_SHARED);</span>
<span class="p_add">+	xfs_ilock(dp, lock_mode);</span>
<span class="p_add">+	if (!XFS_IFORK_Q(dp))</span>
<span class="p_add">+		goto out_destroy_fork;</span>
<span class="p_add">+	xfs_iunlock(dp, lock_mode);</span>
 
 	/*
 	 * Start our first transaction of the day.
<span class="p_chunk">@@ -407,13 +415,18 @@</span> <span class="p_context"> xfs_attr_inactive(xfs_inode_t *dp)</span>
 	 * the inode in every transaction to let it float upward through
 	 * the log.
 	 */
<span class="p_add">+	lock_mode = 0;</span>
 	trans = xfs_trans_alloc(mp, XFS_TRANS_ATTRINVAL);
 	error = xfs_trans_reserve(trans, &amp;M_RES(mp)-&gt;tr_attrinval, 0, 0);
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		xfs_trans_cancel(trans, 0);</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	xfs_ilock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		goto out_cancel;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_mode = XFS_ILOCK_EXCL;</span>
<span class="p_add">+	cancel_flags = XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT;</span>
<span class="p_add">+	xfs_ilock(dp, lock_mode);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!XFS_IFORK_Q(dp))</span>
<span class="p_add">+		goto out_cancel;</span>
 
 	/*
 	 * No need to make quota reservations here. We expect to release some
<span class="p_chunk">@@ -421,29 +434,31 @@</span> <span class="p_context"> xfs_attr_inactive(xfs_inode_t *dp)</span>
 	 */
 	xfs_trans_ijoin(trans, dp, 0);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Decide on what work routines to call based on the inode size.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!xfs_inode_hasattr(dp) ||</span>
<span class="p_del">-	    dp-&gt;i_d.di_aformat == XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_del">-		error = 0;</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	/* invalidate and truncate the attribute fork extents */</span>
<span class="p_add">+	if (dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_add">+		error = xfs_attr3_root_inactive(&amp;trans, dp);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out_cancel;</span>
<span class="p_add">+</span>
<span class="p_add">+		error = xfs_itruncate_extents(&amp;trans, dp, XFS_ATTR_FORK, 0);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			goto out_cancel;</span>
 	}
<span class="p_del">-	error = xfs_attr3_root_inactive(&amp;trans, dp);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
 
<span class="p_del">-	error = xfs_itruncate_extents(&amp;trans, dp, XFS_ATTR_FORK, 0);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	/* Reset the attribute fork - this also destroys the in-core fork */</span>
<span class="p_add">+	xfs_attr_fork_remove(dp, trans);</span>
 
 	error = xfs_trans_commit(trans, XFS_TRANS_RELEASE_LOG_RES);
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_del">-</span>
<span class="p_add">+	xfs_iunlock(dp, lock_mode);</span>
 	return error;
 
<span class="p_del">-out:</span>
<span class="p_del">-	xfs_trans_cancel(trans, XFS_TRANS_RELEASE_LOG_RES|XFS_TRANS_ABORT);</span>
<span class="p_del">-	xfs_iunlock(dp, XFS_ILOCK_EXCL);</span>
<span class="p_add">+out_cancel:</span>
<span class="p_add">+	xfs_trans_cancel(trans, cancel_flags);</span>
<span class="p_add">+out_destroy_fork:</span>
<span class="p_add">+	/* kill the in-core attr fork before we drop the inode lock */</span>
<span class="p_add">+	if (dp-&gt;i_afp)</span>
<span class="p_add">+		xfs_idestroy_fork(dp, XFS_ATTR_FORK);</span>
<span class="p_add">+	if (lock_mode)</span>
<span class="p_add">+		xfs_iunlock(dp, lock_mode);</span>
 	return error;
 }
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index a2e1cb8a568b..f3ba637a8ece 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> xfs_iozero(</span>
 		status = 0;
 	} while (count);
 
<span class="p_del">-	return (-status);</span>
<span class="p_add">+	return status;</span>
 }
 
 int
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 6163767aa856..b1edda7890f4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -1889,21 +1889,17 @@</span> <span class="p_context"> xfs_inactive(</span>
 	/*
 	 * If there are attributes associated with the file then blow them away
 	 * now.  The code calls a routine that recursively deconstructs the
<span class="p_del">-	 * attribute fork.  We need to just commit the current transaction</span>
<span class="p_del">-	 * because we can&#39;t use it for xfs_attr_inactive().</span>
<span class="p_add">+	 * attribute fork. If also blows away the in-core attribute fork.</span>
 	 */
<span class="p_del">-	if (ip-&gt;i_d.di_anextents &gt; 0) {</span>
<span class="p_del">-		ASSERT(ip-&gt;i_d.di_forkoff != 0);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (XFS_IFORK_Q(ip)) {</span>
 		error = xfs_attr_inactive(ip);
 		if (error)
 			return;
 	}
 
<span class="p_del">-	if (ip-&gt;i_afp)</span>
<span class="p_del">-		xfs_idestroy_fork(ip, XFS_ATTR_FORK);</span>
<span class="p_del">-</span>
<span class="p_add">+	ASSERT(!ip-&gt;i_afp);</span>
 	ASSERT(ip-&gt;i_d.di_anextents == 0);
<span class="p_add">+	ASSERT(ip-&gt;i_d.di_forkoff == 0);</span>
 
 	/*
 	 * Free the inode.
<span class="p_header">diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h</span>
<span class="p_header">index 2dd405c9be78..45c39a37f924 100644</span>
<span class="p_header">--- a/include/drm/drm_pciids.h</span>
<span class="p_header">+++ b/include/drm/drm_pciids.h</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"></span>
 	{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
<span class="p_add">+	{0x1002, 0x665f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \</span>
 	{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
<span class="p_header">diff --git a/include/linux/fs_pin.h b/include/linux/fs_pin.h</span>
<span class="p_header">index 9dc4e0384bfb..3886b3bffd7f 100644</span>
<span class="p_header">--- a/include/linux/fs_pin.h</span>
<span class="p_header">+++ b/include/linux/fs_pin.h</span>
<span class="p_chunk">@@ -13,6 +13,8 @@</span> <span class="p_context"> struct vfsmount;</span>
 static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))
 {
 	init_waitqueue_head(&amp;p-&gt;wait);
<span class="p_add">+	INIT_HLIST_NODE(&amp;p-&gt;s_list);</span>
<span class="p_add">+	INIT_HLIST_NODE(&amp;p-&gt;m_list);</span>
 	p-&gt;kill = kill;
 }
 
<span class="p_header">diff --git a/include/linux/gfp.h b/include/linux/gfp.h</span>
<span class="p_header">index 51bd1e72a917..eb6fafe66bec 100644</span>
<span class="p_header">--- a/include/linux/gfp.h</span>
<span class="p_header">+++ b/include/linux/gfp.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> struct vm_area_struct;</span>
 #define ___GFP_HARDWALL		0x20000u
 #define ___GFP_THISNODE		0x40000u
 #define ___GFP_RECLAIMABLE	0x80000u
<span class="p_add">+#define ___GFP_NOACCOUNT	0x100000u</span>
 #define ___GFP_NOTRACK		0x200000u
 #define ___GFP_NO_KSWAPD	0x400000u
 #define ___GFP_OTHER_NODE	0x800000u
<span class="p_chunk">@@ -85,6 +86,7 @@</span> <span class="p_context"> struct vm_area_struct;</span>
 #define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL) /* Enforce hardwall cpuset memory allocs */
 #define __GFP_THISNODE	((__force gfp_t)___GFP_THISNODE)/* No fallback, no policies */
 #define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE) /* Page is reclaimable */
<span class="p_add">+#define __GFP_NOACCOUNT	((__force gfp_t)___GFP_NOACCOUNT) /* Don&#39;t account to kmemcg */</span>
 #define __GFP_NOTRACK	((__force gfp_t)___GFP_NOTRACK)  /* Don&#39;t track with kmemcheck */
 
 #define __GFP_NO_KSWAPD	((__force gfp_t)___GFP_NO_KSWAPD)
<span class="p_header">diff --git a/include/linux/ktime.h b/include/linux/ktime.h</span>
<span class="p_header">index 5fc3d1083071..2b6a204bd8d4 100644</span>
<span class="p_header">--- a/include/linux/ktime.h</span>
<span class="p_header">+++ b/include/linux/ktime.h</span>
<span class="p_chunk">@@ -166,19 +166,34 @@</span> <span class="p_context"> static inline bool ktime_before(const ktime_t cmp1, const ktime_t cmp2)</span>
 }
 
 #if BITS_PER_LONG &lt; 64
<span class="p_del">-extern u64 __ktime_divns(const ktime_t kt, s64 div);</span>
<span class="p_del">-static inline u64 ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+extern s64 __ktime_divns(const ktime_t kt, s64 div);</span>
<span class="p_add">+static inline s64 ktime_divns(const ktime_t kt, s64 div)</span>
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Negative divisors could cause an inf loop,</span>
<span class="p_add">+	 * so bug out here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUG_ON(div &lt; 0);</span>
 	if (__builtin_constant_p(div) &amp;&amp; !(div &gt;&gt; 32)) {
<span class="p_del">-		u64 ns = kt.tv64;</span>
<span class="p_del">-		do_div(ns, div);</span>
<span class="p_del">-		return ns;</span>
<span class="p_add">+		s64 ns = kt.tv64;</span>
<span class="p_add">+		u64 tmp = ns &lt; 0 ? -ns : ns;</span>
<span class="p_add">+</span>
<span class="p_add">+		do_div(tmp, div);</span>
<span class="p_add">+		return ns &lt; 0 ? -tmp : tmp;</span>
 	} else {
 		return __ktime_divns(kt, div);
 	}
 }
 #else /* BITS_PER_LONG &lt; 64 */
<span class="p_del">-# define ktime_divns(kt, div)		(u64)((kt).tv64 / (div))</span>
<span class="p_add">+static inline s64 ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 32-bit implementation cannot handle negative divisors,</span>
<span class="p_add">+	 * so catch them on 64bit as well.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WARN_ON(div &lt; 0);</span>
<span class="p_add">+	return kt.tv64 / div;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline s64 ktime_to_us(const ktime_t kt)
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 6b08cc106c21..f8994b4b122c 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -205,6 +205,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_LFLAG_SW_ACTIVITY	= (1 &lt;&lt; 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 &lt;&lt; 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 &lt;&lt; 9), /* limit recovery to one reset */
<span class="p_add">+	ATA_LFLAG_CHANGED	= (1 &lt;&lt; 10), /* LPM state changed on this link */</span>
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 &lt;&lt; 0), /* host supports slave dev */
<span class="p_chunk">@@ -310,6 +311,12 @@</span> <span class="p_context"> enum {</span>
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
<span class="p_add">+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might</span>
<span class="p_add">+	 * be a spurious PHY event, so ignore the first PHY event that</span>
<span class="p_add">+	 * occurs within 10s after the policy change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ATA_TMOUT_SPURIOUS_PHY	= 10000,</span>
<span class="p_add">+</span>
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
<span class="p_chunk">@@ -789,6 +796,8 @@</span> <span class="p_context"> struct ata_link {</span>
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		last_lpm_change; /* when last LPM change happened */</span>
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
<span class="p_chunk">@@ -1202,6 +1211,7 @@</span> <span class="p_context"> extern struct ata_device *ata_dev_pair(struct ata_device *adev);</span>
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
<span class="p_add">+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);</span>
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
<span class="p_header">diff --git a/include/linux/memcontrol.h b/include/linux/memcontrol.h</span>
<span class="p_header">index 72dff5fb0d0c..6c8918114804 100644</span>
<span class="p_header">--- a/include/linux/memcontrol.h</span>
<span class="p_header">+++ b/include/linux/memcontrol.h</span>
<span class="p_chunk">@@ -463,6 +463,8 @@</span> <span class="p_context"> memcg_kmem_newpage_charge(gfp_t gfp, struct mem_cgroup **memcg, int order)</span>
 	if (!memcg_kmem_enabled())
 		return true;
 
<span class="p_add">+	if (gfp &amp; __GFP_NOACCOUNT)</span>
<span class="p_add">+		return true;</span>
 	/*
 	 * __GFP_NOFAIL allocations will move on even if charging is not
 	 * possible. Therefore we don&#39;t even try, and have this allocation
<span class="p_chunk">@@ -522,6 +524,8 @@</span> <span class="p_context"> memcg_kmem_get_cache(struct kmem_cache *cachep, gfp_t gfp)</span>
 {
 	if (!memcg_kmem_enabled())
 		return cachep;
<span class="p_add">+	if (gfp &amp; __GFP_NOACCOUNT)</span>
<span class="p_add">+		return cachep;</span>
 	if (gfp &amp; __GFP_NOFAIL)
 		return cachep;
 	if (in_interrupt() || (!current-&gt;mm) || (current-&gt;flags &amp; PF_KTHREAD))
<span class="p_header">diff --git a/include/linux/sched/rt.h b/include/linux/sched/rt.h</span>
<span class="p_header">index 6341f5be6e24..a30b172df6e1 100644</span>
<span class="p_header">--- a/include/linux/sched/rt.h</span>
<span class="p_header">+++ b/include/linux/sched/rt.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"> static inline int rt_task(struct task_struct *p)</span>
 #ifdef CONFIG_RT_MUTEXES
 extern int rt_mutex_getprio(struct task_struct *p);
 extern void rt_mutex_setprio(struct task_struct *p, int prio);
<span class="p_del">-extern int rt_mutex_check_prio(struct task_struct *task, int newprio);</span>
<span class="p_add">+extern int rt_mutex_get_effective_prio(struct task_struct *task, int newprio);</span>
 extern struct task_struct *rt_mutex_get_top_task(struct task_struct *task);
 extern void rt_mutex_adjust_pi(struct task_struct *p);
 static inline bool tsk_is_pi_blocked(struct task_struct *tsk)
<span class="p_chunk">@@ -31,9 +31,10 @@</span> <span class="p_context"> static inline int rt_mutex_getprio(struct task_struct *p)</span>
 	return p-&gt;normal_prio;
 }
 
<span class="p_del">-static inline int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+static inline int rt_mutex_get_effective_prio(struct task_struct *task,</span>
<span class="p_add">+					      int newprio)</span>
 {
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 static inline struct task_struct *rt_mutex_get_top_task(struct task_struct *task)
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 358a337af598..790752ac074a 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -339,6 +339,7 @@</span> <span class="p_context"> struct tty_file_private {</span>
 #define TTY_EXCLUSIVE 		3	/* Exclusive open mode */
 #define TTY_DEBUG 		4	/* Debugging */
 #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
<span class="p_add">+#define TTY_OTHER_DONE		6	/* Closed pty has completed input processing */</span>
 #define TTY_LDISC_OPEN	 	11	/* Line discipline is open */
 #define TTY_PTY_LOCK 		16	/* pty private */
 #define TTY_NO_WRITE_SPLIT 	17	/* Preserve write boundaries to driver */
<span class="p_chunk">@@ -462,7 +463,6 @@</span> <span class="p_context"> extern int tty_hung_up_p(struct file *filp);</span>
 extern void do_SAK(struct tty_struct *tty);
 extern void __do_SAK(struct tty_struct *tty);
 extern void no_tty(void);
<span class="p_del">-extern void tty_flush_to_ldisc(struct tty_struct *tty);</span>
 extern void tty_buffer_free_all(struct tty_port *port);
 extern void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld);
 extern void tty_buffer_init(struct tty_port *port);
<span class="p_header">diff --git a/include/xen/events.h b/include/xen/events.h</span>
<span class="p_header">index 5321cd9636e6..7d95fdf9cf3e 100644</span>
<span class="p_header">--- a/include/xen/events.h</span>
<span class="p_header">+++ b/include/xen/events.h</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"> int bind_evtchn_to_irqhandler(unsigned int evtchn,</span>
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);</span>
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index 6357265a31ad..ce9108c059fb 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -265,15 +265,17 @@</span> <span class="p_context"> struct task_struct *rt_mutex_get_top_task(struct task_struct *task)</span>
 }
 
 /*
<span class="p_del">- * Called by sched_setscheduler() to check whether the priority change</span>
<span class="p_del">- * is overruled by a possible priority boosting.</span>
<span class="p_add">+ * Called by sched_setscheduler() to get the priority which will be</span>
<span class="p_add">+ * effective after the change.</span>
  */
<span class="p_del">-int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+int rt_mutex_get_effective_prio(struct task_struct *task, int newprio)</span>
 {
 	if (!task_has_pi_waiters(task))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return newprio;</span>
 
<span class="p_del">-	return task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio;</span>
<span class="p_add">+	if (task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio)</span>
<span class="p_add">+		return task_top_pi_waiter(task)-&gt;task-&gt;prio;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index ec53f594e9c9..538794ce3cc7 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -3366,6 +3366,9 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	module_bug_cleanup(mod);
 	mutex_unlock(&amp;module_mutex);
 
<span class="p_add">+	blocking_notifier_call_chain(&amp;module_notify_list,</span>
<span class="p_add">+				     MODULE_STATE_GOING, mod);</span>
<span class="p_add">+</span>
 	/* we can&#39;t deallocate the module until we clear memory protection */
 	unset_module_init_ro_nx(mod);
 	unset_module_core_ro_nx(mod);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 3d5f6f6d14c2..f4da2cbbfd7f 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -3295,15 +3295,18 @@</span> <span class="p_context"> static void __setscheduler_params(struct task_struct *p,</span>
 
 /* Actually do priority change: must hold pi &amp; rq lock. */
 static void __setscheduler(struct rq *rq, struct task_struct *p,
<span class="p_del">-			   const struct sched_attr *attr)</span>
<span class="p_add">+			   const struct sched_attr *attr, bool keep_boost)</span>
 {
 	__setscheduler_params(p, attr);
 
 	/*
<span class="p_del">-	 * If we get here, there was no pi waiters boosting the</span>
<span class="p_del">-	 * task. It is safe to use the normal prio.</span>
<span class="p_add">+	 * Keep a potential priority boosting if called from</span>
<span class="p_add">+	 * sched_setscheduler().</span>
 	 */
<span class="p_del">-	p-&gt;prio = normal_prio(p);</span>
<span class="p_add">+	if (keep_boost)</span>
<span class="p_add">+		p-&gt;prio = rt_mutex_get_effective_prio(p, normal_prio(p));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		p-&gt;prio = normal_prio(p);</span>
 
 	if (dl_prio(p-&gt;prio))
 		p-&gt;sched_class = &amp;dl_sched_class;
<span class="p_chunk">@@ -3403,7 +3406,7 @@</span> <span class="p_context"> static int __sched_setscheduler(struct task_struct *p,</span>
 	int newprio = dl_policy(attr-&gt;sched_policy) ? MAX_DL_PRIO - 1 :
 		      MAX_RT_PRIO - 1 - attr-&gt;sched_priority;
 	int retval, oldprio, oldpolicy = -1, queued, running;
<span class="p_del">-	int policy = attr-&gt;sched_policy;</span>
<span class="p_add">+	int new_effective_prio, policy = attr-&gt;sched_policy;</span>
 	unsigned long flags;
 	const struct sched_class *prev_class;
 	struct rq *rq;
<span class="p_chunk">@@ -3585,15 +3588,14 @@</span> <span class="p_context"> change:</span>
 	oldprio = p-&gt;prio;
 
 	/*
<span class="p_del">-	 * Special case for priority boosted tasks.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * If the new priority is lower or equal (user space view)</span>
<span class="p_del">-	 * than the current (boosted) priority, we just store the new</span>
<span class="p_add">+	 * Take priority boosted tasks into account. If the new</span>
<span class="p_add">+	 * effective priority is unchanged, we just store the new</span>
 	 * normal parameters and do not touch the scheduler class and
 	 * the runqueue. This will be done when the task deboost
 	 * itself.
 	 */
<span class="p_del">-	if (rt_mutex_check_prio(p, newprio)) {</span>
<span class="p_add">+	new_effective_prio = rt_mutex_get_effective_prio(p, newprio);</span>
<span class="p_add">+	if (new_effective_prio == oldprio) {</span>
 		__setscheduler_params(p, attr);
 		task_rq_unlock(rq, p, &amp;flags);
 		return 0;
<span class="p_chunk">@@ -3607,7 +3609,7 @@</span> <span class="p_context"> change:</span>
 		put_prev_task(rq, p);
 
 	prev_class = p-&gt;sched_class;
<span class="p_del">-	__setscheduler(rq, p, attr);</span>
<span class="p_add">+	__setscheduler(rq, p, attr, true);</span>
 
 	if (running)
 		p-&gt;sched_class-&gt;set_curr_task(rq);
<span class="p_chunk">@@ -4382,10 +4384,7 @@</span> <span class="p_context"> long __sched io_schedule_timeout(long timeout)</span>
 	long ret;
 
 	current-&gt;in_iowait = 1;
<span class="p_del">-	if (old_iowait)</span>
<span class="p_del">-		blk_schedule_flush_plug(current);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		blk_flush_plug(current);</span>
<span class="p_add">+	blk_schedule_flush_plug(current);</span>
 
 	delayacct_blkio_start();
 	rq = raw_rq();
<span class="p_chunk">@@ -7357,7 +7356,7 @@</span> <span class="p_context"> static void normalize_task(struct rq *rq, struct task_struct *p)</span>
 	queued = task_on_rq_queued(p);
 	if (queued)
 		dequeue_task(rq, p, 0);
<span class="p_del">-	__setscheduler(rq, p, &amp;attr);</span>
<span class="p_add">+	__setscheduler(rq, p, &amp;attr, false);</span>
 	if (queued) {
 		enqueue_task(rq, p, 0);
 		resched_curr(rq);
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index bee0c1f78091..38f586c076fe 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -266,21 +266,23 @@</span> <span class="p_context"> lock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)</span>
 /*
  * Divide a ktime value by a nanosecond value
  */
<span class="p_del">-u64 __ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+s64 __ktime_divns(const ktime_t kt, s64 div)</span>
 {
<span class="p_del">-	u64 dclc;</span>
 	int sft = 0;
<span class="p_add">+	s64 dclc;</span>
<span class="p_add">+	u64 tmp;</span>
 
 	dclc = ktime_to_ns(kt);
<span class="p_add">+	tmp = dclc &lt; 0 ? -dclc : dclc;</span>
<span class="p_add">+</span>
 	/* Make sure the divisor is less than 2^32: */
 	while (div &gt;&gt; 32) {
 		sft++;
 		div &gt;&gt;= 1;
 	}
<span class="p_del">-	dclc &gt;&gt;= sft;</span>
<span class="p_del">-	do_div(dclc, (unsigned long) div);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dclc;</span>
<span class="p_add">+	tmp &gt;&gt;= sft;</span>
<span class="p_add">+	do_div(tmp, (unsigned long) div);</span>
<span class="p_add">+	return dclc &lt; 0 ? -tmp : tmp;</span>
 }
 EXPORT_SYMBOL_GPL(__ktime_divns);
 #endif /* BITS_PER_LONG &gt;= 64 */
<span class="p_header">diff --git a/lib/strnlen_user.c b/lib/strnlen_user.c</span>
<span class="p_header">index a28df5206d95..11649615c505 100644</span>
<span class="p_header">--- a/lib/strnlen_user.c</span>
<span class="p_header">+++ b/lib/strnlen_user.c</span>
<span class="p_chunk">@@ -57,7 +57,8 @@</span> <span class="p_context"> static inline long do_strnlen_user(const char __user *src, unsigned long count,</span>
 			return res + find_zero(data) + 1 - align;
 		}
 		res += sizeof(unsigned long);
<span class="p_del">-		if (unlikely(max &lt; sizeof(unsigned long)))</span>
<span class="p_add">+		/* We already handled &#39;unsigned long&#39; bytes. Did we do it all ? */</span>
<span class="p_add">+		if (unlikely(max &lt;= sizeof(unsigned long)))</span>
 			break;
 		max -= sizeof(unsigned long);
 		if (unlikely(__get_user(c,(unsigned long __user *)(src+res))))
<span class="p_header">diff --git a/mm/kmemleak.c b/mm/kmemleak.c</span>
<span class="p_header">index 5405aff5a590..f0fe4f2c1fa7 100644</span>
<span class="p_header">--- a/mm/kmemleak.c</span>
<span class="p_header">+++ b/mm/kmemleak.c</span>
<span class="p_chunk">@@ -115,7 +115,8 @@</span> <span class="p_context"></span>
 #define BYTES_PER_POINTER	sizeof(void *)
 
 /* GFP bitmask for kmemleak internal allocations */
<span class="p_del">-#define gfp_kmemleak_mask(gfp)	(((gfp) &amp; (GFP_KERNEL | GFP_ATOMIC)) | \</span>
<span class="p_add">+#define gfp_kmemleak_mask(gfp)	(((gfp) &amp; (GFP_KERNEL | GFP_ATOMIC | \</span>
<span class="p_add">+					   __GFP_NOACCOUNT)) | \</span>
 				 __GFP_NORETRY | __GFP_NOMEMALLOC | \
 				 __GFP_NOWARN)
 
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index de5dc5e12691..0f7d73b3e4b1 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -2517,7 +2517,7 @@</span> <span class="p_context"> static void __init check_numabalancing_enable(void)</span>
 	if (numabalancing_override)
 		set_numabalancing_state(numabalancing_override == 1);
 
<span class="p_del">-	if (nr_node_ids &gt; 1 &amp;&amp; !numabalancing_override) {</span>
<span class="p_add">+	if (num_online_nodes() &gt; 1 &amp;&amp; !numabalancing_override) {</span>
 		pr_info(&quot;%s automatic NUMA balancing. &quot;
 			&quot;Configure with numa_balancing= or the &quot;
 			&quot;kernel.numa_balancing sysctl&quot;,
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index 41a4abc7e98e..c4ec9239249a 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -1306,8 +1306,6 @@</span> <span class="p_context"> static void __unregister_linger_request(struct ceph_osd_client *osdc,</span>
 		if (list_empty(&amp;req-&gt;r_osd_item))
 			req-&gt;r_osd = NULL;
 	}
<span class="p_del">-</span>
<span class="p_del">-	list_del_init(&amp;req-&gt;r_req_lru_item); /* can be on notarget */</span>
 	ceph_osdc_put_request(req);
 }
 
<span class="p_chunk">@@ -2017,20 +2015,29 @@</span> <span class="p_context"> static void kick_requests(struct ceph_osd_client *osdc, bool force_resend,</span>
 		err = __map_request(osdc, req,
 				    force_resend || force_resend_writes);
 		dout(&quot;__map_request returned %d\n&quot;, err);
<span class="p_del">-		if (err == 0)</span>
<span class="p_del">-			continue;  /* no change and no osd was specified */</span>
 		if (err &lt; 0)
 			continue;  /* hrm! */
<span class="p_del">-		if (req-&gt;r_osd == NULL) {</span>
<span class="p_del">-			dout(&quot;tid %llu maps to no valid osd\n&quot;, req-&gt;r_tid);</span>
<span class="p_del">-			needmap++;  /* request a newer map */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (req-&gt;r_osd == NULL || err &gt; 0) {</span>
<span class="p_add">+			if (req-&gt;r_osd == NULL) {</span>
<span class="p_add">+				dout(&quot;lingering %p tid %llu maps to no osd\n&quot;,</span>
<span class="p_add">+				     req, req-&gt;r_tid);</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * A homeless lingering request makes</span>
<span class="p_add">+				 * no sense, as it&#39;s job is to keep</span>
<span class="p_add">+				 * a particular OSD connection open.</span>
<span class="p_add">+				 * Request a newer map and kick the</span>
<span class="p_add">+				 * request, knowing that it won&#39;t be</span>
<span class="p_add">+				 * resent until we actually get a map</span>
<span class="p_add">+				 * that can tell us where to send it.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				needmap++;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req, req-&gt;r_tid,</span>
<span class="p_del">-		     req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_del">-		__register_request(osdc, req);</span>
<span class="p_del">-		__unregister_linger_request(osdc, req);</span>
<span class="p_add">+			dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req,</span>
<span class="p_add">+			     req-&gt;r_tid, req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_add">+			__register_request(osdc, req);</span>
<span class="p_add">+			__unregister_linger_request(osdc, req);</span>
<span class="p_add">+		}</span>
 	}
 	reset_changed_osds(osdc);
 	mutex_unlock(&amp;osdc-&gt;request_mutex);
<span class="p_header">diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h</span>
<span class="p_header">index 8d53d65bd2ab..81e8dc5cb7f9 100644</span>
<span class="p_header">--- a/net/mac80211/ieee80211_i.h</span>
<span class="p_header">+++ b/net/mac80211/ieee80211_i.h</span>
<span class="p_chunk">@@ -204,6 +204,8 @@</span> <span class="p_context"> enum ieee80211_packet_rx_flags {</span>
  * @IEEE80211_RX_CMNTR: received on cooked monitor already
  * @IEEE80211_RX_BEACON_REPORTED: This frame was already reported
  *	to cfg80211_report_obss_beacon().
<span class="p_add">+ * @IEEE80211_RX_REORDER_TIMER: this frame is released by the</span>
<span class="p_add">+ *	reorder buffer timeout timer, not the normal RX path</span>
  *
  * These flags are used across handling multiple interfaces
  * for a single frame.
<span class="p_chunk">@@ -211,6 +213,7 @@</span> <span class="p_context"> enum ieee80211_packet_rx_flags {</span>
 enum ieee80211_rx_flags {
 	IEEE80211_RX_CMNTR		= BIT(0),
 	IEEE80211_RX_BEACON_REPORTED	= BIT(1),
<span class="p_add">+	IEEE80211_RX_REORDER_TIMER	= BIT(2),</span>
 };
 
 struct ieee80211_rx_data {
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 1eb730bf8752..4c887d053333 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -2106,7 +2106,8 @@</span> <span class="p_context"> ieee80211_deliver_skb(struct ieee80211_rx_data *rx)</span>
 		/* deliver to local stack */
 		skb-&gt;protocol = eth_type_trans(skb, dev);
 		memset(skb-&gt;cb, 0, sizeof(skb-&gt;cb));
<span class="p_del">-		if (rx-&gt;local-&gt;napi)</span>
<span class="p_add">+		if (!(rx-&gt;flags &amp; IEEE80211_RX_REORDER_TIMER) &amp;&amp;</span>
<span class="p_add">+		    rx-&gt;local-&gt;napi)</span>
 			napi_gro_receive(rx-&gt;local-&gt;napi, skb);
 		else
 			netif_receive_skb(skb);
<span class="p_chunk">@@ -3215,7 +3216,7 @@</span> <span class="p_context"> void ieee80211_release_reorder_timeout(struct sta_info *sta, int tid)</span>
 		/* This is OK -- must be QoS data frame */
 		.security_idx = tid,
 		.seqno_idx = tid,
<span class="p_del">-		.flags = 0,</span>
<span class="p_add">+		.flags = IEEE80211_RX_REORDER_TIMER,</span>
 	};
 	struct tid_ampdu_rx *tid_agg_rx;
 
<span class="p_header">diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c</span>
<span class="p_header">index a4220e92f0cc..efa3f48f1ec5 100644</span>
<span class="p_header">--- a/net/mac80211/wep.c</span>
<span class="p_header">+++ b/net/mac80211/wep.c</span>
<span class="p_chunk">@@ -98,8 +98,7 @@</span> <span class="p_context"> static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,</span>
 
 	hdr-&gt;frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
<span class="p_del">-	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN ||</span>
<span class="p_del">-		    skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
<span class="p_add">+	if (WARN_ON(skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
 		return NULL;
 
 	hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
<span class="p_chunk">@@ -167,6 +166,9 @@</span> <span class="p_context"> int ieee80211_wep_encrypt(struct ieee80211_local *local,</span>
 	size_t len;
 	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
 
<span class="p_add">+	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
 	if (!iv)
 		return -1;
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index 1ec19f6f0c2b..eeeba5adee6d 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -793,20 +793,26 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 {
 	u32 value_follows;
 	int err;
<span class="p_add">+	struct page *scratch;</span>
<span class="p_add">+</span>
<span class="p_add">+	scratch = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+	if (!scratch)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	xdr_set_scratch_buffer(xdr, page_address(scratch), PAGE_SIZE);</span>
 
 	/* res-&gt;status */
 	err = gssx_dec_status(xdr, &amp;res-&gt;status);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 
 	/* res-&gt;context_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_ctx(xdr, res-&gt;context_handle);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;context_handle = NULL;
 	}
<span class="p_chunk">@@ -814,11 +820,11 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;output_token */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_buffer(xdr, res-&gt;output_token);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;output_token = NULL;
 	}
<span class="p_chunk">@@ -826,14 +832,17 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;delegated_cred_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		/* we do not support upcall servers sending this data. */
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* res-&gt;options */
 	err = gssx_dec_option_array(xdr, &amp;res-&gt;options);
 
<span class="p_add">+out_free:</span>
<span class="p_add">+	__free_page(scratch);</span>
 	return err;
 }
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index a8a1e14272a1..a002a6d1e6da 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2108,6 +2108,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
 	{ PCI_DEVICE(0x1002, 0xaab0),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0xaac8),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	/* VIA VT8251/VT8237A */
 	{ PCI_DEVICE(0x1106, 0x3288),
 	  .driver_data = AZX_DRIVER_VIA | AZX_DCAPS_POSFIX_VIA },
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index da67ea8645a6..e27298bdcd6d 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -973,6 +973,14 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_conexant[] = {</span>
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = &quot;CX20665&quot;,
 	  .patch = patch_conexant_auto },
<span class="p_add">+	{ .id = 0x14f150f1, .name = &quot;CX20721&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f2, .name = &quot;CX20722&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f3, .name = &quot;CX20723&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f4, .name = &quot;CX20724&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
 	{ .id = 0x14f1510f, .name = &quot;CX20751/2&quot;,
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = &quot;CX20751/2&quot;,
<span class="p_chunk">@@ -1007,6 +1015,10 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ab&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ac&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b8&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b9&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f1&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f3&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f4&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f1510f&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15110&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15111&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 2fd490b1764b..93c78c3c4b95 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5027,6 +5027,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9099, &quot;Sony VAIO S13&quot;, ALC275_FIXUP_SONY_DISABLE_AAMIX),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),</span>
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
 	SND_PCI_QUIRK(0x144d, 0xc109, &quot;Samsung Ativ book 9 (NP900X3G)&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1458, 0xfa53, &quot;Gigabyte BXBT-2807&quot;, ALC283_FIXUP_BXBT2807_MIC),
<span class="p_chunk">@@ -5056,6 +5057,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5026, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
 	SND_PCI_QUIRK(0x17aa, 0x9e54, &quot;LENOVO NB&quot;, ALC269_FIXUP_LENOVO_EAPD),
<span class="p_chunk">@@ -5246,6 +5248,13 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x17, 0x40000000},
 		{0x1d, 0x40700001},
 		{0x21, 0x02211050}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell Inspiron 5548&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC255_STANDARD_PINS,</span>
<span class="p_add">+		{0x12, 0x90a60180},</span>
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x17, 0x40000000},</span>
<span class="p_add">+		{0x1d, 0x40700001},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC256_STANDARD_PINS,
 		{0x13, 0x40000000}),
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 2341fc334163..6ba0b5517c40 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 		if (led_set_func(TPACPI_LED_MUTE, false) &gt;= 0) {
 			old_vmaster_hook = spec-&gt;vmaster_mute.hook;
 			spec-&gt;vmaster_mute.hook = update_tpacpi_mute_led;
<span class="p_del">-			spec-&gt;vmaster_mute_enum = 1;</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_header">diff --git a/sound/soc/codecs/mc13783.c b/sound/soc/codecs/mc13783.c</span>
<span class="p_header">index 2ffb9a0570dc..3d44fc50e4d0 100644</span>
<span class="p_header">--- a/sound/soc/codecs/mc13783.c</span>
<span class="p_header">+++ b/sound/soc/codecs/mc13783.c</span>
<span class="p_chunk">@@ -623,14 +623,14 @@</span> <span class="p_context"> static int mc13783_probe(struct snd_soc_codec *codec)</span>
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_CODEC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	if (priv-&gt;dac_ssi_port == MC13783_SSI1_PORT)
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c</span>
<span class="p_header">index dc7778b6dd7f..c3c33bd0df1c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/uda1380.c</span>
<span class="p_header">+++ b/sound/soc/codecs/uda1380.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> static int uda1380_set_dai_fmt_both(struct snd_soc_dai *codec_dai,</span>
 	if ((fmt &amp; SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)
 		return -EINVAL;
 
<span class="p_del">-	uda1380_write(codec, UDA1380_IFACE, iface);</span>
<span class="p_add">+	uda1380_write_reg_cache(codec, UDA1380_IFACE, iface);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 3035d9856415..e97a7615df85 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -395,7 +395,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route audio_paths[] = {</span>
 	{ &quot;Right Input Mixer&quot;, &quot;Boost Switch&quot;, &quot;Right Boost Mixer&quot;, },
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT1&quot;, },  /* Really Boost Switch */
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT2&quot; },
<span class="p_del">-	{ &quot;Right Input Mixer&quot;, NULL, &quot;LINPUT3&quot; },</span>
<span class="p_add">+	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT3&quot; },</span>
 
 	{ &quot;Left ADC&quot;, NULL, &quot;Left Input Mixer&quot; },
 	{ &quot;Right ADC&quot;, NULL, &quot;Right Input Mixer&quot; },
<span class="p_header">diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c</span>
<span class="p_header">index 4fbc7689339a..a1c04dab6684 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8994.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8994.c</span>
<span class="p_chunk">@@ -2754,7 +2754,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static int fs_ratios[] = {
<span class="p_del">-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536</span>
<span class="p_add">+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536</span>
 };
 
 static int bclk_divs[] = {
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index b6f88202b8c9..e19a6765bd8a 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -3074,11 +3074,16 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 	}
 
 	prefix = soc_dapm_prefix(dapm);
<span class="p_del">-	if (prefix)</span>
<span class="p_add">+	if (prefix) {</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix, widget-&gt;name);
<span class="p_del">-	else</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix,</span>
<span class="p_add">+					     widget-&gt;sname);</span>
<span class="p_add">+	} else {</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;name);
<span class="p_del">-</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;sname);</span>
<span class="p_add">+	}</span>
 	if (w-&gt;name == NULL) {
 		kfree(w);
 		return NULL;
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 32631a86078b..e21ec5abcc3a 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1117,6 +1117,8 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	switch (chip-&gt;usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
<span class="p_add">+	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */</span>
<span class="p_add">+	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */</span>
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 		return true;
 	}
<span class="p_header">diff --git a/tools/vm/Makefile b/tools/vm/Makefile</span>
<span class="p_header">index ac884b65a072..93aadaf7ff63 100644</span>
<span class="p_header">--- a/tools/vm/Makefile</span>
<span class="p_header">+++ b/tools/vm/Makefile</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
 TARGETS=page-types slabinfo page_owner_sort
 
 LIB_DIR = ../lib/api
<span class="p_del">-LIBS = $(LIB_DIR)/libapikfs.a</span>
<span class="p_add">+LIBS = $(LIB_DIR)/libapi.a</span>
 
 CC = $(CROSS_COMPILE)gcc
 CFLAGS = -Wall -Wextra -I../lib/

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



