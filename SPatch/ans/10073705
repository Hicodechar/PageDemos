
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.13.16 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.13.16</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 24, 2017, 8:18 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171124081829.GB30810@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10073705/mbox/"
   >mbox</a>
|
   <a href="/patch/10073705/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10073705/">/patch/10073705/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B7A576037F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Nov 2017 08:18:32 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A3DF92A359
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Nov 2017 08:18:32 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 986292A35E; Fri, 24 Nov 2017 08:18:32 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C25662A359
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Nov 2017 08:18:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752711AbdKXIS1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 24 Nov 2017 03:18:27 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:43002 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752357AbdKXISZ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 24 Nov 2017 03:18:25 -0500
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 04256ABB;
	Fri, 24 Nov 2017 08:18:23 +0000 (UTC)
Date: Fri, 24 Nov 2017 09:18:29 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.13.16
Message-ID: &lt;20171124081829.GB30810@kroah.com&gt;
References: &lt;20171124081820.GA30810@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171124081820.GA30810@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 24, 2017, 8:18 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 3bd5d9d148d3..bc9a897e0431 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 13
<span class="p_del">-SUBLEVEL = 15</span>
<span class="p_add">+SUBLEVEL = 16</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/intel_cacheinfo.c b/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_header">index c55fb2cb2acc..24f749324c0f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/intel_cacheinfo.c</span>
<span class="p_chunk">@@ -811,7 +811,24 @@</span> <span class="p_context"> static int __cache_amd_cpumap_setup(unsigned int cpu, int index,</span>
 	struct cacheinfo *this_leaf;
 	int i, sibling;
 
<span class="p_del">-	if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For L3, always use the pre-calculated cpu_llc_shared_mask</span>
<span class="p_add">+	 * to derive shared_cpu_map.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (index == 3) {</span>
<span class="p_add">+		for_each_cpu(i, cpu_llc_shared_mask(cpu)) {</span>
<span class="p_add">+			this_cpu_ci = get_cpu_cacheinfo(i);</span>
<span class="p_add">+			if (!this_cpu_ci-&gt;info_list)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			this_leaf = this_cpu_ci-&gt;info_list + index;</span>
<span class="p_add">+			for_each_cpu(sibling, cpu_llc_shared_mask(cpu)) {</span>
<span class="p_add">+				if (!cpu_online(sibling))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+				cpumask_set_cpu(sibling,</span>
<span class="p_add">+						&amp;this_leaf-&gt;shared_cpu_map);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {</span>
 		unsigned int apicid, nshared, first, last;
 
 		this_leaf = this_cpu_ci-&gt;info_list + index;
<span class="p_chunk">@@ -839,19 +856,6 @@</span> <span class="p_context"> static int __cache_amd_cpumap_setup(unsigned int cpu, int index,</span>
 						&amp;this_leaf-&gt;shared_cpu_map);
 			}
 		}
<span class="p_del">-	} else if (index == 3) {</span>
<span class="p_del">-		for_each_cpu(i, cpu_llc_shared_mask(cpu)) {</span>
<span class="p_del">-			this_cpu_ci = get_cpu_cacheinfo(i);</span>
<span class="p_del">-			if (!this_cpu_ci-&gt;info_list)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			this_leaf = this_cpu_ci-&gt;info_list + index;</span>
<span class="p_del">-			for_each_cpu(sibling, cpu_llc_shared_mask(cpu)) {</span>
<span class="p_del">-				if (!cpu_online(sibling))</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				cpumask_set_cpu(sibling,</span>
<span class="p_del">-						&amp;this_leaf-&gt;shared_cpu_map);</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
 	} else
 		return 0;
 
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_msghandler.c b/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_header">index 810b138f5897..c82d9fd2f05a 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_msghandler.c</span>
<span class="p_chunk">@@ -4030,7 +4030,8 @@</span> <span class="p_context"> smi_from_recv_msg(ipmi_smi_t intf, struct ipmi_recv_msg *recv_msg,</span>
 }
 
 static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,
<span class="p_del">-			      struct list_head *timeouts, long timeout_period,</span>
<span class="p_add">+			      struct list_head *timeouts,</span>
<span class="p_add">+			      unsigned long timeout_period,</span>
 			      int slot, unsigned long *flags,
 			      unsigned int *waiting_msgs)
 {
<span class="p_chunk">@@ -4043,8 +4044,8 @@</span> <span class="p_context"> static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,</span>
 	if (!ent-&gt;inuse)
 		return;
 
<span class="p_del">-	ent-&gt;timeout -= timeout_period;</span>
<span class="p_del">-	if (ent-&gt;timeout &gt; 0) {</span>
<span class="p_add">+	if (timeout_period &lt; ent-&gt;timeout) {</span>
<span class="p_add">+		ent-&gt;timeout -= timeout_period;</span>
 		(*waiting_msgs)++;
 		return;
 	}
<span class="p_chunk">@@ -4110,7 +4111,8 @@</span> <span class="p_context"> static void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,</span>
 	}
 }
 
<span class="p_del">-static unsigned int ipmi_timeout_handler(ipmi_smi_t intf, long timeout_period)</span>
<span class="p_add">+static unsigned int ipmi_timeout_handler(ipmi_smi_t intf,</span>
<span class="p_add">+					 unsigned long timeout_period)</span>
 {
 	struct list_head     timeouts;
 	struct ipmi_recv_msg *msg, *msg2;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev-common.c b/drivers/char/tpm/tpm-dev-common.c</span>
<span class="p_header">index 610638a80383..461bf0b8a094 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev-common.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev-common.c</span>
<span class="p_chunk">@@ -110,6 +110,12 @@</span> <span class="p_context"> ssize_t tpm_common_write(struct file *file, const char __user *buf,</span>
 		return -EFAULT;
 	}
 
<span class="p_add">+	if (in_size &lt; 6 ||</span>
<span class="p_add">+	    in_size &lt; be32_to_cpu(*((__be32 *) (priv-&gt;data_buffer + 2)))) {</span>
<span class="p_add">+		mutex_unlock(&amp;priv-&gt;buffer_mutex);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* atomic tpm command send and result receive. We only hold the ops
 	 * lock during this period so that the tpm can be unregistered even if
 	 * the char dev is held open.
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index c99dc59d729b..76e8054bfc4e 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -3253,7 +3253,7 @@</span> <span class="p_context"> u32 bond_xmit_hash(struct bonding *bond, struct sk_buff *skb)</span>
 	hash ^= (hash &gt;&gt; 16);
 	hash ^= (hash &gt;&gt; 8);
 
<span class="p_del">-	return hash;</span>
<span class="p_add">+	return hash &gt;&gt; 1;</span>
 }
 
 /*-------------------------- Device entry points ----------------------------*/
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index c28fa5a8734c..ba15eeadfe21 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -1743,15 +1743,17 @@</span> <span class="p_context"> static inline void bcm_sysport_mask_all_intrs(struct bcm_sysport_priv *priv)</span>
 
 static inline void gib_set_pad_extension(struct bcm_sysport_priv *priv)
 {
<span class="p_del">-	u32 __maybe_unused reg;</span>
<span class="p_add">+	u32 reg;</span>
 
<span class="p_del">-	/* Include Broadcom tag in pad extension */</span>
<span class="p_add">+	reg = gib_readl(priv, GIB_CONTROL);</span>
<span class="p_add">+	/* Include Broadcom tag in pad extension and fix up IPG_LENGTH */</span>
 	if (netdev_uses_dsa(priv-&gt;netdev)) {
<span class="p_del">-		reg = gib_readl(priv, GIB_CONTROL);</span>
 		reg &amp;= ~(GIB_PAD_EXTENSION_MASK &lt;&lt; GIB_PAD_EXTENSION_SHIFT);
 		reg |= ENET_BRCM_TAG_LEN &lt;&lt; GIB_PAD_EXTENSION_SHIFT;
<span class="p_del">-		gib_writel(priv, reg, GIB_CONTROL);</span>
 	}
<span class="p_add">+	reg &amp;= ~(GIB_IPG_LEN_MASK &lt;&lt; GIB_IPG_LEN_SHIFT);</span>
<span class="p_add">+	reg |= 12 &lt;&lt; GIB_IPG_LEN_SHIFT;</span>
<span class="p_add">+	gib_writel(priv, reg, GIB_CONTROL);</span>
 }
 
 static int bcm_sysport_open(struct net_device *dev)
<span class="p_header">diff --git a/drivers/net/ethernet/fealnx.c b/drivers/net/ethernet/fealnx.c</span>
<span class="p_header">index e92859dab7ae..e191c4ebeaf4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/fealnx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/fealnx.c</span>
<span class="p_chunk">@@ -257,8 +257,8 @@</span> <span class="p_context"> enum rx_desc_status_bits {</span>
 	RXFSD = 0x00000800,	/* first descriptor */
 	RXLSD = 0x00000400,	/* last descriptor */
 	ErrorSummary = 0x80,	/* error summary */
<span class="p_del">-	RUNT = 0x40,		/* runt packet received */</span>
<span class="p_del">-	LONG = 0x20,		/* long packet received */</span>
<span class="p_add">+	RUNTPKT = 0x40,		/* runt packet received */</span>
<span class="p_add">+	LONGPKT = 0x20,		/* long packet received */</span>
 	FAE = 0x10,		/* frame align error */
 	CRC = 0x08,		/* crc error */
 	RXER = 0x04,		/* receive error */
<span class="p_chunk">@@ -1632,7 +1632,7 @@</span> <span class="p_context"> static int netdev_rx(struct net_device *dev)</span>
 					       dev-&gt;name, rx_status);
 
 				dev-&gt;stats.rx_errors++;	/* end of a packet. */
<span class="p_del">-				if (rx_status &amp; (LONG | RUNT))</span>
<span class="p_add">+				if (rx_status &amp; (LONGPKT | RUNTPKT))</span>
 					dev-&gt;stats.rx_length_errors++;
 				if (rx_status &amp; RXER)
 					dev-&gt;stats.rx_frame_errors++;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">index 7344433259fc..1c513dc0105e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_chunk">@@ -213,22 +213,20 @@</span> <span class="p_context"> static inline bool mlx5e_rx_cache_get(struct mlx5e_rq *rq,</span>
 static inline int mlx5e_page_alloc_mapped(struct mlx5e_rq *rq,
 					  struct mlx5e_dma_info *dma_info)
 {
<span class="p_del">-	struct page *page;</span>
<span class="p_del">-</span>
 	if (mlx5e_rx_cache_get(rq, dma_info))
 		return 0;
 
<span class="p_del">-	page = dev_alloc_pages(rq-&gt;buff.page_order);</span>
<span class="p_del">-	if (unlikely(!page))</span>
<span class="p_add">+	dma_info-&gt;page = dev_alloc_pages(rq-&gt;buff.page_order);</span>
<span class="p_add">+	if (unlikely(!dma_info-&gt;page))</span>
 		return -ENOMEM;
 
<span class="p_del">-	dma_info-&gt;addr = dma_map_page(rq-&gt;pdev, page, 0,</span>
<span class="p_add">+	dma_info-&gt;addr = dma_map_page(rq-&gt;pdev, dma_info-&gt;page, 0,</span>
 				      RQ_PAGE_SIZE(rq), rq-&gt;buff.map_dir);
 	if (unlikely(dma_mapping_error(rq-&gt;pdev, dma_info-&gt;addr))) {
<span class="p_del">-		put_page(page);</span>
<span class="p_add">+		put_page(dma_info-&gt;page);</span>
<span class="p_add">+		dma_info-&gt;page = NULL;</span>
 		return -ENOMEM;
 	}
<span class="p_del">-	dma_info-&gt;page = page;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 16885827367b..553bc230d70d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -1545,9 +1545,16 @@</span> <span class="p_context"> static int mlx5_try_fast_unload(struct mlx5_core_dev *dev)</span>
 		return -EAGAIN;
 	}
 
<span class="p_add">+	/* Panic tear down fw command will stop the PCI bus communication</span>
<span class="p_add">+	 * with the HCA, so the health polll is no longer needed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mlx5_drain_health_wq(dev);</span>
<span class="p_add">+	mlx5_stop_health_poll(dev);</span>
<span class="p_add">+</span>
 	ret = mlx5_cmd_force_teardown_hca(dev);
 	if (ret) {
 		mlx5_core_dbg(dev, &quot;Firmware couldn&#39;t do fast unload error: %d\n&quot;, ret);
<span class="p_add">+		mlx5_start_health_poll(dev);</span>
 		return ret;
 	}
 
<span class="p_header">diff --git a/drivers/net/usb/asix_devices.c b/drivers/net/usb/asix_devices.c</span>
<span class="p_header">index b2ff88e69a81..3d4f7959dabb 100644</span>
<span class="p_header">--- a/drivers/net/usb/asix_devices.c</span>
<span class="p_header">+++ b/drivers/net/usb/asix_devices.c</span>
<span class="p_chunk">@@ -626,7 +626,7 @@</span> <span class="p_context"> static int asix_suspend(struct usb_interface *intf, pm_message_t message)</span>
 	struct usbnet *dev = usb_get_intfdata(intf);
 	struct asix_common_private *priv = dev-&gt;driver_priv;
 
<span class="p_del">-	if (priv-&gt;suspend)</span>
<span class="p_add">+	if (priv &amp;&amp; priv-&gt;suspend)</span>
 		priv-&gt;suspend(dev);
 
 	return usbnet_suspend(intf, message);
<span class="p_chunk">@@ -678,7 +678,7 @@</span> <span class="p_context"> static int asix_resume(struct usb_interface *intf)</span>
 	struct usbnet *dev = usb_get_intfdata(intf);
 	struct asix_common_private *priv = dev-&gt;driver_priv;
 
<span class="p_del">-	if (priv-&gt;resume)</span>
<span class="p_add">+	if (priv &amp;&amp; priv-&gt;resume)</span>
 		priv-&gt;resume(dev);
 
 	return usbnet_resume(intf);
<span class="p_header">diff --git a/drivers/net/usb/cdc_ether.c b/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">index 8ab281b478f2..4f88f64cccb4 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ether.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> int usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)</span>
 			goto bad_desc;
 	}
 
<span class="p_del">-	if (header.usb_cdc_ether_desc) {</span>
<span class="p_add">+	if (header.usb_cdc_ether_desc &amp;&amp; info-&gt;ether-&gt;wMaxSegmentSize) {</span>
 		dev-&gt;hard_mtu = le16_to_cpu(info-&gt;ether-&gt;wMaxSegmentSize);
 		/* because of Zaurus, we may be ignoring the host
 		 * side link address we were given.
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index 9c80e80c5493..8d5e97251efe 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -771,7 +771,7 @@</span> <span class="p_context"> int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_</span>
 	int err;
 	u8 iface_no;
 	struct usb_cdc_parsed_header hdr;
<span class="p_del">-	u16 curr_ntb_format;</span>
<span class="p_add">+	__le16 curr_ntb_format;</span>
 
 	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -889,7 +889,7 @@</span> <span class="p_context"> int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_</span>
 			goto error2;
 		}
 
<span class="p_del">-		if (curr_ntb_format == USB_CDC_NCM_NTB32_FORMAT) {</span>
<span class="p_add">+		if (curr_ntb_format == cpu_to_le16(USB_CDC_NCM_NTB32_FORMAT)) {</span>
 			dev_info(&amp;intf-&gt;dev, &quot;resetting NTB format to 16-bit&quot;);
 			err = usbnet_write_cmd(dev, USB_CDC_SET_NTB_FORMAT,
 					       USB_TYPE_CLASS | USB_DIR_OUT
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 8c3733608271..8d4a6f7cba61 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> static int qmi_wwan_rx_fixup(struct usbnet *dev, struct sk_buff *skb)</span>
 		return 1;
 	}
 	if (rawip) {
<span class="p_add">+		skb_reset_mac_header(skb);</span>
 		skb-&gt;dev = dev-&gt;net; /* normally set by eth_type_trans */
 		skb-&gt;protocol = proto;
 		return 1;
<span class="p_chunk">@@ -681,7 +682,7 @@</span> <span class="p_context"> static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)</span>
 	}
 
 	/* errors aren&#39;t fatal - we can live with the dynamic address */
<span class="p_del">-	if (cdc_ether) {</span>
<span class="p_add">+	if (cdc_ether &amp;&amp; cdc_ether-&gt;wMaxSegmentSize) {</span>
 		dev-&gt;hard_mtu = le16_to_cpu(cdc_ether-&gt;wMaxSegmentSize);
 		usbnet_get_ethernet_addr(dev, cdc_ether-&gt;iMACAddress);
 	}
<span class="p_header">diff --git a/drivers/net/vrf.c b/drivers/net/vrf.c</span>
<span class="p_header">index 8a1eaf3c302a..e91ef5e236cc 100644</span>
<span class="p_header">--- a/drivers/net/vrf.c</span>
<span class="p_header">+++ b/drivers/net/vrf.c</span>
<span class="p_chunk">@@ -1271,7 +1271,7 @@</span> <span class="p_context"> static int vrf_fib_rule(const struct net_device *dev, __u8 family, bool add_it)</span>
 	frh-&gt;family = family;
 	frh-&gt;action = FR_ACT_TO_TBL;
 
<span class="p_del">-	if (nla_put_u32(skb, FRA_L3MDEV, 1))</span>
<span class="p_add">+	if (nla_put_u8(skb, FRA_L3MDEV, 1))</span>
 		goto nla_put_failure;
 
 	if (nla_put_u32(skb, FRA_PRIORITY, FIB_RULE_PREF))
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index e17baac70f43..436154720bf8 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -1632,26 +1632,19 @@</span> <span class="p_context"> static struct sk_buff *vxlan_na_create(struct sk_buff *request,</span>
 static int neigh_reduce(struct net_device *dev, struct sk_buff *skb, __be32 vni)
 {
 	struct vxlan_dev *vxlan = netdev_priv(dev);
<span class="p_del">-	struct nd_msg *msg;</span>
<span class="p_del">-	const struct ipv6hdr *iphdr;</span>
 	const struct in6_addr *daddr;
<span class="p_del">-	struct neighbour *n;</span>
<span class="p_add">+	const struct ipv6hdr *iphdr;</span>
 	struct inet6_dev *in6_dev;
<span class="p_add">+	struct neighbour *n;</span>
<span class="p_add">+	struct nd_msg *msg;</span>
 
 	in6_dev = __in6_dev_get(dev);
 	if (!in6_dev)
 		goto out;
 
<span class="p_del">-	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr) + sizeof(struct nd_msg)))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	iphdr = ipv6_hdr(skb);
 	daddr = &amp;iphdr-&gt;daddr;
<span class="p_del">-</span>
 	msg = (struct nd_msg *)(iphdr + 1);
<span class="p_del">-	if (msg-&gt;icmph.icmp6_code != 0 ||</span>
<span class="p_del">-	    msg-&gt;icmph.icmp6_type != NDISC_NEIGHBOUR_SOLICITATION)</span>
<span class="p_del">-		goto out;</span>
 
 	if (ipv6_addr_loopback(daddr) ||
 	    ipv6_addr_is_multicast(&amp;msg-&gt;target))
<span class="p_chunk">@@ -2258,11 +2251,11 @@</span> <span class="p_context"> static void vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,</span>
 static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct vxlan_dev *vxlan = netdev_priv(dev);
<span class="p_add">+	struct vxlan_rdst *rdst, *fdst = NULL;</span>
 	const struct ip_tunnel_info *info;
<span class="p_del">-	struct ethhdr *eth;</span>
 	bool did_rsc = false;
<span class="p_del">-	struct vxlan_rdst *rdst, *fdst = NULL;</span>
 	struct vxlan_fdb *f;
<span class="p_add">+	struct ethhdr *eth;</span>
 	__be32 vni = 0;
 
 	info = skb_tunnel_info(skb);
<span class="p_chunk">@@ -2287,12 +2280,14 @@</span> <span class="p_context"> static netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		if (ntohs(eth-&gt;h_proto) == ETH_P_ARP)
 			return arp_reduce(dev, skb, vni);
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-		else if (ntohs(eth-&gt;h_proto) == ETH_P_IPV6) {</span>
<span class="p_del">-			struct ipv6hdr *hdr, _hdr;</span>
<span class="p_del">-			if ((hdr = skb_header_pointer(skb,</span>
<span class="p_del">-						      skb_network_offset(skb),</span>
<span class="p_del">-						      sizeof(_hdr), &amp;_hdr)) &amp;&amp;</span>
<span class="p_del">-			    hdr-&gt;nexthdr == IPPROTO_ICMPV6)</span>
<span class="p_add">+		else if (ntohs(eth-&gt;h_proto) == ETH_P_IPV6 &amp;&amp;</span>
<span class="p_add">+			 pskb_may_pull(skb, sizeof(struct ipv6hdr) +</span>
<span class="p_add">+					    sizeof(struct nd_msg)) &amp;&amp;</span>
<span class="p_add">+			 ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) {</span>
<span class="p_add">+			struct nd_msg *m = (struct nd_msg *)(ipv6_hdr(skb) + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (m-&gt;icmph.icmp6_code == 0 &amp;&amp;</span>
<span class="p_add">+			    m-&gt;icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)</span>
 				return neigh_reduce(dev, skb, vni);
 		}
 #endif
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_fintek.c b/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_header">index e500f7dd2470..4bd376c08b59 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_fintek.c</span>
<span class="p_chunk">@@ -118,6 +118,9 @@</span> <span class="p_context"> static int fintek_8250_enter_key(u16 base_port, u8 key)</span>
 	if (!request_muxed_region(base_port, 2, &quot;8250_fintek&quot;))
 		return -EBUSY;
 
<span class="p_add">+	/* Force to deactive all SuperIO in this base_port */</span>
<span class="p_add">+	outb(EXIT_KEY, base_port + ADDR_PORT);</span>
<span class="p_add">+</span>
 	outb(key, base_port + ADDR_PORT);
 	outb(key, base_port + ADDR_PORT);
 	return 0;
<span class="p_header">diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">index 1ea05ac57aa7..670f7e334f93 100644</span>
<span class="p_header">--- a/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/omap-serial.c</span>
<span class="p_chunk">@@ -693,7 +693,7 @@</span> <span class="p_context"> static void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)</span>
 	if ((mctrl &amp; TIOCM_RTS) &amp;&amp; (port-&gt;status &amp; UPSTAT_AUTORTS))
 		up-&gt;efr |= UART_EFR_RTS;
 	else
<span class="p_del">-		up-&gt;efr &amp;= UART_EFR_RTS;</span>
<span class="p_add">+		up-&gt;efr &amp;= ~UART_EFR_RTS;</span>
 	serial_out(up, UART_EFR, up-&gt;efr);
 	serial_out(up, UART_LCR, lcr);
 
<span class="p_header">diff --git a/fs/coda/upcall.c b/fs/coda/upcall.c</span>
<span class="p_header">index e82357c89979..8cf16d8c5261 100644</span>
<span class="p_header">--- a/fs/coda/upcall.c</span>
<span class="p_header">+++ b/fs/coda/upcall.c</span>
<span class="p_chunk">@@ -446,8 +446,7 @@</span> <span class="p_context"> int venus_fsync(struct super_block *sb, struct CodaFid *fid)</span>
 	UPARG(CODA_FSYNC);
 
 	inp-&gt;coda_fsync.VFid = *fid;
<span class="p_del">-	error = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),</span>
<span class="p_del">-			    &amp;outsize, inp);</span>
<span class="p_add">+	error = coda_upcall(coda_vcp(sb), insize, &amp;outsize, inp);</span>
 
 	CODA_FREE(inp, insize);
 	return error;
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">index 74407c6dd592..ec8f75813beb 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_chunk">@@ -2419,6 +2419,7 @@</span> <span class="p_context"> static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)</span>
 					dlm_lockres_put(res);
 					continue;
 				}
<span class="p_add">+				dlm_move_lockres_to_recovery_list(dlm, res);</span>
 			} else if (res-&gt;owner == dlm-&gt;node_num) {
 				dlm_free_dead_locks(dlm, res, dead_node);
 				__dlm_lockres_calc_usage(dlm, res);
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index bfeb647459d9..2fc8e65c07c5 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1168,6 +1168,13 @@</span> <span class="p_context"> int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	}
 	size_change = S_ISREG(inode-&gt;i_mode) &amp;&amp; attr-&gt;ia_valid &amp; ATTR_SIZE;
 	if (size_change) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Here we should wait dio to finish before inode lock</span>
<span class="p_add">+		 * to avoid a deadlock between ocfs2_setattr() and</span>
<span class="p_add">+		 * ocfs2_dio_end_io_write()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		inode_dio_wait(inode);</span>
<span class="p_add">+</span>
 		status = ocfs2_rw_lock(inode, 1);
 		if (status &lt; 0) {
 			mlog_errno(status);
<span class="p_chunk">@@ -1207,8 +1214,6 @@</span> <span class="p_context"> int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)</span>
 		if (status)
 			goto bail_unlock;
 
<span class="p_del">-		inode_dio_wait(inode);</span>
<span class="p_del">-</span>
 		if (i_size_read(inode) &gt;= attr-&gt;ia_size) {
 			if (ocfs2_should_order_data(inode)) {
 				status = ocfs2_begin_ordered_truncate(inode,
<span class="p_header">diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h</span>
<span class="p_header">index fc14b8b3f6ce..1d86e09f17c1 100644</span>
<span class="p_header">--- a/include/linux/mmzone.h</span>
<span class="p_header">+++ b/include/linux/mmzone.h</span>
<span class="p_chunk">@@ -691,7 +691,8 @@</span> <span class="p_context"> typedef struct pglist_data {</span>
 	 * is the first PFN that needs to be initialised.
 	 */
 	unsigned long first_deferred_pfn;
<span class="p_del">-	unsigned long static_init_size;</span>
<span class="p_add">+	/* Number of non-deferred pages */</span>
<span class="p_add">+	unsigned long static_init_pgcnt;</span>
 #endif /* CONFIG_DEFERRED_STRUCT_PAGE_INIT */
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 63df75ae70ee..baf2dd102686 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -3655,6 +3655,13 @@</span> <span class="p_context"> static inline void nf_reset_trace(struct sk_buff *skb)</span>
 #endif
 }
 
<span class="p_add">+static inline void ipvs_reset(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_IP_VS)</span>
<span class="p_add">+	skb-&gt;ipvs_property = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Note: This doesn&#39;t put any conntrack and bridge info in dst. */
 static inline void __nf_copy(struct sk_buff *dst, const struct sk_buff *src,
 			     bool copy)
<span class="p_header">diff --git a/kernel/rcu/tree_plugin.h b/kernel/rcu/tree_plugin.h</span>
<span class="p_header">index 908b309d60d7..b8f51dffeae9 100644</span>
<span class="p_header">--- a/kernel/rcu/tree_plugin.h</span>
<span class="p_header">+++ b/kernel/rcu/tree_plugin.h</span>
<span class="p_chunk">@@ -1493,7 +1493,7 @@</span> <span class="p_context"> static void rcu_prepare_for_idle(void)</span>
 	rdtp-&gt;last_accelerate = jiffies;
 	for_each_rcu_flavor(rsp) {
 		rdp = this_cpu_ptr(rsp-&gt;rda);
<span class="p_del">-		if (rcu_segcblist_pend_cbs(&amp;rdp-&gt;cblist))</span>
<span class="p_add">+		if (!rcu_segcblist_pend_cbs(&amp;rdp-&gt;cblist))</span>
 			continue;
 		rnp = rdp-&gt;mynode;
 		raw_spin_lock_rcu_node(rnp); /* irqs already disabled. */
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 1423da8dd16f..3bd0999c266f 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -289,28 +289,37 @@</span> <span class="p_context"> EXPORT_SYMBOL(nr_online_nodes);</span>
 int page_group_by_mobility_disabled __read_mostly;
 
 #ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Determine how many pages need to be initialized durig early boot</span>
<span class="p_add">+ * (non-deferred initialization).</span>
<span class="p_add">+ * The value of first_deferred_pfn will be set later, once non-deferred pages</span>
<span class="p_add">+ * are initialized, but for now set it ULONG_MAX.</span>
<span class="p_add">+ */</span>
 static inline void reset_deferred_meminit(pg_data_t *pgdat)
 {
<span class="p_del">-	unsigned long max_initialise;</span>
<span class="p_del">-	unsigned long reserved_lowmem;</span>
<span class="p_add">+	phys_addr_t start_addr, end_addr;</span>
<span class="p_add">+	unsigned long max_pgcnt;</span>
<span class="p_add">+	unsigned long reserved;</span>
 
 	/*
 	 * Initialise at least 2G of a node but also take into account that
 	 * two large system hashes that can take up 1GB for 0.25TB/node.
 	 */
<span class="p_del">-	max_initialise = max(2UL &lt;&lt; (30 - PAGE_SHIFT),</span>
<span class="p_del">-		(pgdat-&gt;node_spanned_pages &gt;&gt; 8));</span>
<span class="p_add">+	max_pgcnt = max(2UL &lt;&lt; (30 - PAGE_SHIFT),</span>
<span class="p_add">+			(pgdat-&gt;node_spanned_pages &gt;&gt; 8));</span>
 
 	/*
 	 * Compensate the all the memblock reservations (e.g. crash kernel)
 	 * from the initial estimation to make sure we will initialize enough
 	 * memory to boot.
 	 */
<span class="p_del">-	reserved_lowmem = memblock_reserved_memory_within(pgdat-&gt;node_start_pfn,</span>
<span class="p_del">-			pgdat-&gt;node_start_pfn + max_initialise);</span>
<span class="p_del">-	max_initialise += reserved_lowmem;</span>
<span class="p_add">+	start_addr = PFN_PHYS(pgdat-&gt;node_start_pfn);</span>
<span class="p_add">+	end_addr = PFN_PHYS(pgdat-&gt;node_start_pfn + max_pgcnt);</span>
<span class="p_add">+	reserved = memblock_reserved_memory_within(start_addr, end_addr);</span>
<span class="p_add">+	max_pgcnt += PHYS_PFN(reserved);</span>
 
<span class="p_del">-	pgdat-&gt;static_init_size = min(max_initialise, pgdat-&gt;node_spanned_pages);</span>
<span class="p_add">+	pgdat-&gt;static_init_pgcnt = min(max_pgcnt, pgdat-&gt;node_spanned_pages);</span>
 	pgdat-&gt;first_deferred_pfn = ULONG_MAX;
 }
 
<span class="p_chunk">@@ -337,7 +346,7 @@</span> <span class="p_context"> static inline bool update_defer_init(pg_data_t *pgdat,</span>
 	if (zone_end &lt; pgdat_end_pfn(pgdat))
 		return true;
 	(*nr_initialised)++;
<span class="p_del">-	if ((*nr_initialised &gt; pgdat-&gt;static_init_size) &amp;&amp;</span>
<span class="p_add">+	if ((*nr_initialised &gt; pgdat-&gt;static_init_pgcnt) &amp;&amp;</span>
 	    (pfn &amp; (PAGES_PER_SECTION - 1)) == 0) {
 		pgdat-&gt;first_deferred_pfn = pfn;
 		return false;
<span class="p_header">diff --git a/mm/page_ext.c b/mm/page_ext.c</span>
<span class="p_header">index 88ccc044b09a..9dbabbfc4557 100644</span>
<span class="p_header">--- a/mm/page_ext.c</span>
<span class="p_header">+++ b/mm/page_ext.c</span>
<span class="p_chunk">@@ -124,7 +124,6 @@</span> <span class="p_context"> struct page_ext *lookup_page_ext(struct page *page)</span>
 	struct page_ext *base;
 
 	base = NODE_DATA(page_to_nid(page))-&gt;node_page_ext;
<span class="p_del">-#if defined(CONFIG_DEBUG_VM)</span>
 	/*
 	 * The sanity checks the page allocator does upon freeing a
 	 * page can reach here before the page_ext arrays are
<span class="p_chunk">@@ -133,7 +132,6 @@</span> <span class="p_context"> struct page_ext *lookup_page_ext(struct page *page)</span>
 	 */
 	if (unlikely(!base))
 		return NULL;
<span class="p_del">-#endif</span>
 	index = pfn - round_down(node_start_pfn(page_to_nid(page)),
 					MAX_ORDER_NR_PAGES);
 	return get_entry(base, index);
<span class="p_chunk">@@ -198,7 +196,6 @@</span> <span class="p_context"> struct page_ext *lookup_page_ext(struct page *page)</span>
 {
 	unsigned long pfn = page_to_pfn(page);
 	struct mem_section *section = __pfn_to_section(pfn);
<span class="p_del">-#if defined(CONFIG_DEBUG_VM)</span>
 	/*
 	 * The sanity checks the page allocator does upon freeing a
 	 * page can reach here before the page_ext arrays are
<span class="p_chunk">@@ -207,7 +204,6 @@</span> <span class="p_context"> struct page_ext *lookup_page_ext(struct page *page)</span>
 	 */
 	if (!section-&gt;page_ext)
 		return NULL;
<span class="p_del">-#endif</span>
 	return get_entry(section-&gt;page_ext, pfn);
 }
 
<span class="p_header">diff --git a/mm/pagewalk.c b/mm/pagewalk.c</span>
<span class="p_header">index 1a4197965415..7d973f63088c 100644</span>
<span class="p_header">--- a/mm/pagewalk.c</span>
<span class="p_header">+++ b/mm/pagewalk.c</span>
<span class="p_chunk">@@ -187,8 +187,12 @@</span> <span class="p_context"> static int walk_hugetlb_range(unsigned long addr, unsigned long end,</span>
 	do {
 		next = hugetlb_entry_end(h, addr, end);
 		pte = huge_pte_offset(walk-&gt;mm, addr &amp; hmask, sz);
<span class="p_del">-		if (pte &amp;&amp; walk-&gt;hugetlb_entry)</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pte)</span>
 			err = walk-&gt;hugetlb_entry(pte, hmask, addr, next, walk);
<span class="p_add">+		else if (walk-&gt;pte_hole)</span>
<span class="p_add">+			err = walk-&gt;pte_hole(addr, next, walk);</span>
<span class="p_add">+</span>
 		if (err)
 			break;
 	} while (addr = next, addr != end);
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index 9649579b5b9f..4a72ee4e2ae9 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -376,6 +376,9 @@</span> <span class="p_context"> static int vlan_device_event(struct notifier_block *unused, unsigned long event,</span>
 			dev-&gt;name);
 		vlan_vid_add(dev, htons(ETH_P_8021Q), 0);
 	}
<span class="p_add">+	if (event == NETDEV_DOWN &amp;&amp;</span>
<span class="p_add">+	    (dev-&gt;features &amp; NETIF_F_HW_VLAN_CTAG_FILTER))</span>
<span class="p_add">+		vlan_vid_del(dev, htons(ETH_P_8021Q), 0);</span>
 
 	vlan_info = rtnl_dereference(dev-&gt;vlan_info);
 	if (!vlan_info)
<span class="p_chunk">@@ -423,9 +426,6 @@</span> <span class="p_context"> static int vlan_device_event(struct notifier_block *unused, unsigned long event,</span>
 		struct net_device *tmp;
 		LIST_HEAD(close_list);
 
<span class="p_del">-		if (dev-&gt;features &amp; NETIF_F_HW_VLAN_CTAG_FILTER)</span>
<span class="p_del">-			vlan_vid_del(dev, htons(ETH_P_8021Q), 0);</span>
<span class="p_del">-</span>
 		/* Put all VLANs for this dev in the down state too.  */
 		vlan_group_for_each_dev(grp, i, vlandev) {
 			flgs = vlandev-&gt;flags;
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 72eb23d2426f..a0155578e951 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -4476,6 +4476,7 @@</span> <span class="p_context"> void skb_scrub_packet(struct sk_buff *skb, bool xnet)</span>
 	if (!xnet)
 		return;
 
<span class="p_add">+	ipvs_reset(skb);</span>
 	skb_orphan(skb);
 	skb-&gt;mark = 0;
 }
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index e92e5dbcb3d6..ffe96de8a079 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -2613,7 +2613,6 @@</span> <span class="p_context"> void tcp_simple_retransmit(struct sock *sk)</span>
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct sk_buff *skb;
 	unsigned int mss = tcp_current_mss(sk);
<span class="p_del">-	u32 prior_lost = tp-&gt;lost_out;</span>
 
 	tcp_for_write_queue(skb, sk) {
 		if (skb == tcp_send_head(sk))
<span class="p_chunk">@@ -2630,7 +2629,7 @@</span> <span class="p_context"> void tcp_simple_retransmit(struct sock *sk)</span>
 
 	tcp_clear_retrans_hints_partial(tp);
 
<span class="p_del">-	if (prior_lost == tp-&gt;lost_out)</span>
<span class="p_add">+	if (!tp-&gt;lost_out)</span>
 		return;
 
 	if (tcp_is_reno(tp))
<span class="p_header">diff --git a/net/ipv4/tcp_nv.c b/net/ipv4/tcp_nv.c</span>
<span class="p_header">index 6d650ed3cb59..5c871666c561 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_nv.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_nv.c</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> static void tcpnv_acked(struct sock *sk, const struct ack_sample *sample)</span>
 
 	/* rate in 100&#39;s bits per second */
 	rate64 = ((u64)sample-&gt;in_flight) * 8000000;
<span class="p_del">-	rate = (u32)div64_u64(rate64, (u64)(avg_rtt * 100));</span>
<span class="p_add">+	rate = (u32)div64_u64(rate64, (u64)(avg_rtt ?: 1) * 100);</span>
 
 	/* Remember the maximum rate seen during this RTT
 	 * Note: It may be more than one RTT. This function should be
<span class="p_header">diff --git a/net/ipv4/tcp_offload.c b/net/ipv4/tcp_offload.c</span>
<span class="p_header">index 11f69bbf9307..b6a2aa1dcf56 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_offload.c</span>
<span class="p_chunk">@@ -149,11 +149,19 @@</span> <span class="p_context"> struct sk_buff *tcp_gso_segment(struct sk_buff *skb,</span>
 	 * is freed by GSO engine
 	 */
 	if (copy_destructor) {
<span class="p_add">+		int delta;</span>
<span class="p_add">+</span>
 		swap(gso_skb-&gt;sk, skb-&gt;sk);
 		swap(gso_skb-&gt;destructor, skb-&gt;destructor);
 		sum_truesize += skb-&gt;truesize;
<span class="p_del">-		refcount_add(sum_truesize - gso_skb-&gt;truesize,</span>
<span class="p_del">-			   &amp;skb-&gt;sk-&gt;sk_wmem_alloc);</span>
<span class="p_add">+		delta = sum_truesize - gso_skb-&gt;truesize;</span>
<span class="p_add">+		/* In some pathological cases, delta can be negative.</span>
<span class="p_add">+		 * We need to either use refcount_add() or refcount_sub_and_test()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (likely(delta &gt;= 0))</span>
<span class="p_add">+			refcount_add(delta, &amp;skb-&gt;sk-&gt;sk_wmem_alloc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			WARN_ON_ONCE(refcount_sub_and_test(-delta, &amp;skb-&gt;sk-&gt;sk_wmem_alloc));</span>
 	}
 
 	delta = htonl(oldlen + (skb_tail_pointer(skb) -
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 58587b0e2b5d..e359840f46c0 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -3207,13 +3207,8 @@</span> <span class="p_context"> struct sk_buff *tcp_make_synack(const struct sock *sk, struct dst_entry *dst,</span>
 	th-&gt;source = htons(ireq-&gt;ir_num);
 	th-&gt;dest = ireq-&gt;ir_rmt_port;
 	skb-&gt;mark = ireq-&gt;ir_mark;
<span class="p_del">-	/* Setting of flags are superfluous here for callers (and ECE is</span>
<span class="p_del">-	 * not even correctly set)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	tcp_init_nondata_skb(skb, tcp_rsk(req)-&gt;snt_isn,</span>
<span class="p_del">-			     TCPHDR_SYN | TCPHDR_ACK);</span>
<span class="p_del">-</span>
<span class="p_del">-	th-&gt;seq = htonl(TCP_SKB_CB(skb)-&gt;seq);</span>
<span class="p_add">+	skb-&gt;ip_summed = CHECKSUM_PARTIAL;</span>
<span class="p_add">+	th-&gt;seq = htonl(tcp_rsk(req)-&gt;snt_isn);</span>
 	/* XXX data is queued and acked as is. No buffer/window check */
 	th-&gt;ack_seq = htonl(tcp_rsk(req)-&gt;rcv_nxt);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 4d322c1b7233..e4280b6568b4 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 	unsigned char *ptr, *optr;
 	struct l2tp_session *session;
 	struct l2tp_tunnel *tunnel = NULL;
<span class="p_add">+	struct iphdr *iph;</span>
 	int length;
 
 	if (!pskb_may_pull(skb, 4))
<span class="p_chunk">@@ -178,24 +179,17 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 		goto discard;
 
 	tunnel_id = ntohl(*(__be32 *) &amp;skb-&gt;data[4]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		struct iphdr *iph = (struct iphdr *) skb_network_header(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-		sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_del">-					   inet_iif(skb), tunnel_id);</span>
<span class="p_del">-		if (!sk) {</span>
<span class="p_del">-			read_unlock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_del">-			goto discard;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	iph = (struct iphdr *)skb_network_header(skb);</span>
 
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_add">+	read_lock_bh(&amp;l2tp_ip_lock);</span>
<span class="p_add">+	sk = __l2tp_ip_bind_lookup(net, iph-&gt;daddr, iph-&gt;saddr, inet_iif(skb),</span>
<span class="p_add">+				   tunnel_id);</span>
<span class="p_add">+	if (!sk) {</span>
 		read_unlock_bh(&amp;l2tp_ip_lock);
<span class="p_add">+		goto discard;</span>
 	}
<span class="p_add">+	sock_hold(sk);</span>
<span class="p_add">+	read_unlock_bh(&amp;l2tp_ip_lock);</span>
 
 	if (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_put;
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index 88b397c30d86..8bcaa975b432 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 	unsigned char *ptr, *optr;
 	struct l2tp_session *session;
 	struct l2tp_tunnel *tunnel = NULL;
<span class="p_add">+	struct ipv6hdr *iph;</span>
 	int length;
 
 	if (!pskb_may_pull(skb, 4))
<span class="p_chunk">@@ -192,24 +193,17 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 		goto discard;
 
 	tunnel_id = ntohl(*(__be32 *) &amp;skb-&gt;data[4]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		struct ipv6hdr *iph = ipv6_hdr(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_del">-		sk = __l2tp_ip6_bind_lookup(net, &amp;iph-&gt;daddr, &amp;iph-&gt;saddr,</span>
<span class="p_del">-					    inet6_iif(skb), tunnel_id);</span>
<span class="p_del">-		if (!sk) {</span>
<span class="p_del">-			read_unlock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_del">-			goto discard;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	iph = ipv6_hdr(skb);</span>
 
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_add">+	read_lock_bh(&amp;l2tp_ip6_lock);</span>
<span class="p_add">+	sk = __l2tp_ip6_bind_lookup(net, &amp;iph-&gt;daddr, &amp;iph-&gt;saddr,</span>
<span class="p_add">+				    inet6_iif(skb), tunnel_id);</span>
<span class="p_add">+	if (!sk) {</span>
 		read_unlock_bh(&amp;l2tp_ip6_lock);
<span class="p_add">+		goto discard;</span>
 	}
<span class="p_add">+	sock_hold(sk);</span>
<span class="p_add">+	read_unlock_bh(&amp;l2tp_ip6_lock);</span>
 
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_put;
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 09c8dbbd2d70..2939a6b87c27 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2128,7 +2128,7 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
 	struct module *module;
<span class="p_del">-	int len, err = -ENOBUFS;</span>
<span class="p_add">+	int err = -ENOBUFS;</span>
 	int alloc_min_size;
 	int alloc_size;
 
<span class="p_chunk">@@ -2175,9 +2175,11 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	skb_reserve(skb, skb_tailroom(skb) - alloc_size);
 	netlink_skb_set_owner_r(skb, sk);
 
<span class="p_del">-	len = cb-&gt;dump(skb, cb);</span>
<span class="p_add">+	if (nlk-&gt;dump_done_errno &gt; 0)</span>
<span class="p_add">+		nlk-&gt;dump_done_errno = cb-&gt;dump(skb, cb);</span>
 
<span class="p_del">-	if (len &gt; 0) {</span>
<span class="p_add">+	if (nlk-&gt;dump_done_errno &gt; 0 ||</span>
<span class="p_add">+	    skb_tailroom(skb) &lt; nlmsg_total_size(sizeof(nlk-&gt;dump_done_errno))) {</span>
 		mutex_unlock(nlk-&gt;cb_mutex);
 
 		if (sk_filter(sk, skb))
<span class="p_chunk">@@ -2187,13 +2189,15 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 		return 0;
 	}
 
<span class="p_del">-	nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);</span>
<span class="p_del">-	if (!nlh)</span>
<span class="p_add">+	nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE,</span>
<span class="p_add">+			       sizeof(nlk-&gt;dump_done_errno), NLM_F_MULTI);</span>
<span class="p_add">+	if (WARN_ON(!nlh))</span>
 		goto errout_skb;
 
 	nl_dump_check_consistent(cb, nlh);
 
<span class="p_del">-	memcpy(nlmsg_data(nlh), &amp;len, sizeof(len));</span>
<span class="p_add">+	memcpy(nlmsg_data(nlh), &amp;nlk-&gt;dump_done_errno,</span>
<span class="p_add">+	       sizeof(nlk-&gt;dump_done_errno));</span>
 
 	if (sk_filter(sk, skb))
 		kfree_skb(skb);
<span class="p_chunk">@@ -2265,6 +2269,7 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 	}
 
 	nlk-&gt;cb_running = true;
<span class="p_add">+	nlk-&gt;dump_done_errno = INT_MAX;</span>
 
 	mutex_unlock(nlk-&gt;cb_mutex);
 
<span class="p_header">diff --git a/net/netlink/af_netlink.h b/net/netlink/af_netlink.h</span>
<span class="p_header">index 3490f2430532..8908fc2d3de0 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.h</span>
<span class="p_header">+++ b/net/netlink/af_netlink.h</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"> struct netlink_sock {</span>
 	wait_queue_head_t	wait;
 	bool			bound;
 	bool			cb_running;
<span class="p_add">+	int			dump_done_errno;</span>
 	struct netlink_callback	cb;
 	struct mutex		*cb_mutex;
 	struct mutex		cb_def_mutex;
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 1344e3a411ae..edb462b0b73b 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -807,9 +807,10 @@</span> <span class="p_context"> static void sctp_inet6_skb_msgname(struct sk_buff *skb, char *msgname,</span>
 		addr-&gt;v6.sin6_flowinfo = 0;
 		addr-&gt;v6.sin6_port = sh-&gt;source;
 		addr-&gt;v6.sin6_addr = ipv6_hdr(skb)-&gt;saddr;
<span class="p_del">-		if (ipv6_addr_type(&amp;addr-&gt;v6.sin6_addr) &amp; IPV6_ADDR_LINKLOCAL) {</span>
<span class="p_add">+		if (ipv6_addr_type(&amp;addr-&gt;v6.sin6_addr) &amp; IPV6_ADDR_LINKLOCAL)</span>
 			addr-&gt;v6.sin6_scope_id = sctp_v6_skb_iif(skb);
<span class="p_del">-		}</span>
<span class="p_add">+		else</span>
<span class="p_add">+			addr-&gt;v6.sin6_scope_id = 0;</span>
 	}
 
 	*addr_len = sctp_v6_addr_to_user(sctp_sk(skb-&gt;sk), addr);
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 3d79085eb4e0..083da13e1af4 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4924,6 +4924,10 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	struct socket *sock;
 	int err = 0;
 
<span class="p_add">+	/* Do not peel off from one netns to another one. */</span>
<span class="p_add">+	if (!net_eq(current-&gt;nsproxy-&gt;net_ns, sock_net(sk)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_header">diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">index 809ba70fbbbf..7d769b948de8 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_appraise.c</span>
<span class="p_chunk">@@ -320,6 +320,9 @@</span> <span class="p_context"> void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)</span>
 	if (iint-&gt;flags &amp; IMA_DIGSIG)
 		return;
 
<span class="p_add">+	if (iint-&gt;ima_file_status != INTEGRITY_PASS)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	rc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo);
 	if (rc &lt; 0)
 		return;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



