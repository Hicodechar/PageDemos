
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v6,4/4] sparc64: Add support for ADI (Application Data Integrity) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v6,4/4] sparc64: Add support for ADI (Application Data Integrity)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 28, 2017, 6:35 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;85d8a35b577915945703ff84cec6f7f4d85ec214.1488232598.git.khalid.aziz@oracle.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9596535/mbox/"
   >mbox</a>
|
   <a href="/patch/9596535/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9596535/">/patch/9596535/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D2845601D7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Feb 2017 18:42:42 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BE14628530
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Feb 2017 18:42:42 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B027F2855C; Tue, 28 Feb 2017 18:42:42 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 435F928530
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Feb 2017 18:42:40 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751882AbdB1Smi (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 28 Feb 2017 13:42:38 -0500
Received: from aserp1050.oracle.com ([141.146.126.70]:43650 &quot;EHLO
	aserp1050.oracle.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751497AbdB1SmZ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 28 Feb 2017 13:42:25 -0500
Received: from aserp1040.oracle.com (aserp1040.oracle.com [141.146.126.69])
	by aserp1050.oracle.com (Sentrion-MTA-4.3.2/Sentrion-MTA-4.3.2)
	with ESMTP id v1SIfVSD019467
	(version=TLSv1.2 cipher=ECDHE-RSA-AES256-GCM-SHA384 bits=256
	verify=OK)
	for &lt;linux-kernel@vger.kernel.org&gt;; Tue, 28 Feb 2017 18:41:32 GMT
Received: from aserv0021.oracle.com (aserv0021.oracle.com [141.146.126.233])
	by aserp1040.oracle.com (Sentrion-MTA-4.3.2/Sentrion-MTA-4.3.2)
	with ESMTP id v1SIadK7022825
	(version=TLSv1 cipher=DHE-RSA-AES256-SHA bits=256 verify=OK);
	Tue, 28 Feb 2017 18:36:40 GMT
Received: from aserv0121.oracle.com (aserv0121.oracle.com [141.146.126.235])
	by aserv0021.oracle.com (8.13.8/8.14.4) with ESMTP id
	v1SIadEU010667
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=OK);
	Tue, 28 Feb 2017 18:36:39 GMT
Received: from abhmp0014.oracle.com (abhmp0014.oracle.com [141.146.116.20])
	by aserv0121.oracle.com (8.13.8/8.13.8) with ESMTP id
	v1SIabDP027498; Tue, 28 Feb 2017 18:36:38 GMT
Received: from concerto.us.oracle.com (/10.159.75.43)
	by default (Oracle Beehive Gateway v4.0)
	with ESMTP ; Tue, 28 Feb 2017 10:36:36 -0800
From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;
To: davem@davemloft.net, corbet@lwn.net
Cc: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;, viro@zeniv.linux.org.uk,
	nitin.m.gupta@oracle.com, mike.kravetz@oracle.com,
	akpm@linux-foundation.org, mingo@kernel.org,
	kirill.shutemov@linux.intel.com, adam.buchbinder@gmail.com,
	hughd@google.com, minchan@kernel.org, chris.hyser@oracle.com,
	atish.patra@oracle.com, cmetcalf@mellanox.com, atomlin@redhat.com,
	jslaby@suse.cz, joe@perches.com, paul.gortmaker@windriver.com,
	mhocko@suse.com, lstoakes@gmail.com, jack@suse.cz,
	dave.hansen@linux.intel.com, vbabka@suse.cz,
	dan.j.williams@intel.com, iamjoonsoo.kim@lge.com,
	linux-doc@vger.kernel.org, linux-kernel@vger.kernel.org,
	sparclinux@vger.kernel.org, linux-mm@kvack.org,
	Khalid Aziz &lt;khalid@gonehiking.org&gt;
Subject: [PATCH v6 4/4] sparc64: Add support for ADI (Application Data
	Integrity)
Date: Tue, 28 Feb 2017 11:35:23 -0700
Message-Id: &lt;85d8a35b577915945703ff84cec6f7f4d85ec214.1488232598.git.khalid.aziz@oracle.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;cover.1488232591.git.khalid.aziz@oracle.com&gt;
References: &lt;cover.1488232591.git.khalid.aziz@oracle.com&gt;
In-Reply-To: &lt;cover.1488232591.git.khalid.aziz@oracle.com&gt;
References: &lt;cover.1488232591.git.khalid.aziz@oracle.com&gt;
X-Source-IP: aserp1040.oracle.com [141.146.126.69]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - Feb. 28, 2017, 6:35 p.m.</div>
<pre class="content">
ADI is a new feature supported on SPARC M7 and newer processors to allow
hardware to catch rogue accesses to memory. ADI is supported for data
fetches only and not instruction fetches. An app can enable ADI on its
data pages, set version tags on them and use versioned addresses to
access the data pages. Upper bits of the address contain the version
tag. On M7 processors, upper four bits (bits 63-60) contain the version
tag. If a rogue app attempts to access ADI enabled data pages, its
access is blocked and processor generates an exception. Please see
Documentation/sparc/adi.txt for further details.

This patch extends mprotect to enable ADI (TSTATE.mcde), enable/disable
MCD (Memory Corruption Detection) on selected memory ranges, enable
TTE.mcd in PTEs, return ADI parameters to userspace and save/restore ADI
version tags on page swap out/in or migration. It also adds handlers for
traps related to MCD. ADI is not enabled by default for any task. A task
must explicitly enable ADI on a memory range and set version tag for ADI
to be effective for the task.

This initial implementation supports saving and restoring one tag per
page. A page must use same version tag across the entire page for the
tag to survive swap and migration. Swap swupport infrastructure in this
patch allows for this capability to be expanded to store/restore more
than one tag per page in future.
<span class="signed-off-by">
Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
Cc: Khalid Aziz &lt;khalid@gonehiking.org&gt;
---
v6:
	- Eliminated instructions to read and write PSTATE as well as
	  MCDPER and PMCDPER on every access to userspace addresses
	  by setting PSTATE and PMCDPER correctly upon entry into
	  kernel. PSTATE.mcde and PMCDPER are set upon entry into
	  kernel when running on an M7 processor. PSTATE.mcde being
	  set only affects memory accesses that have TTE.mcd set.
	  PMCDPER being set only affects writes to memory addresses
	  that have TTE.mcd set. This ensures any faults caused by
	  ADI tag mismatch on a write are exposed before kernel returns
	  to userspace.

v5:
	- Fixed indentation issues and instrcuctions in assembly code
	- Removed CONFIG_SPARC64 from mdesc.c
	- Changed to maintain state of MCDPER register in thread info
	  flags as opposed to in mm context. MCDPER is a per-thread
	  state and belongs in thread info flag as opposed to mm context
	  which is shared across threads. Added comments to clarify this
	  is a lazily maintained state and must be updated on context
	  switch and copy_process()
	- Updated code to use the new arch_do_swap_page() and
	  arch_unmap_one() functions

v4:
	- Broke patch up into smaller patches

v3:
	- Removed CONFIG_SPARC_ADI
	- Replaced prctl commands with mprotect
	- Added auxiliary vectors for ADI parameters
	- Enabled ADI for swappable pages

v2:
	- Fixed a build error

 Documentation/sparc/adi.txt             | 292 ++++++++++++++++++++++++++++++++
 arch/sparc/include/asm/adi.h            |   6 +
 arch/sparc/include/asm/adi_64.h         |  46 +++++
 arch/sparc/include/asm/elf_64.h         |   8 +
 arch/sparc/include/asm/hugetlb.h        |  13 ++
 arch/sparc/include/asm/mman.h           |  40 ++++-
 arch/sparc/include/asm/mmu_64.h         |   1 +
 arch/sparc/include/asm/mmu_context_64.h |  42 +++++
 arch/sparc/include/asm/pgtable_64.h     |  85 +++++++++-
 arch/sparc/include/asm/thread_info_64.h |   2 +-
 arch/sparc/include/asm/trap_block.h     |   2 +
 arch/sparc/include/uapi/asm/auxvec.h    |   8 +
 arch/sparc/include/uapi/asm/mman.h      |   2 +
 arch/sparc/kernel/Makefile              |   1 +
 arch/sparc/kernel/adi_64.c              |  93 ++++++++++
 arch/sparc/kernel/etrap_64.S            |  28 ++-
 arch/sparc/kernel/mdesc.c               |   2 +
 arch/sparc/kernel/process_64.c          |  25 +++
 arch/sparc/kernel/setup_64.c            |  11 +-
 arch/sparc/kernel/traps_64.c            |  83 ++++++++-
 arch/sparc/kernel/vmlinux.lds.S         |   5 +
 arch/sparc/mm/gup.c                     |  37 ++++
 include/linux/mm.h                      |   2 +
 23 files changed, 825 insertions(+), 9 deletions(-)
 create mode 100644 Documentation/sparc/adi.txt
 create mode 100644 arch/sparc/include/asm/adi.h
 create mode 100644 arch/sparc/include/asm/adi_64.h
 create mode 100644 arch/sparc/kernel/adi_64.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173107">Anthony Yznaga</a> - March 7, 2017, 12:13 a.m.</div>
<pre class="content">
<span class="quote">&gt; On Feb 28, 2017, at 10:35 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/sparc/kernel/etrap_64.S b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt; index 1276ca2..7be33bf 100644</span>
<span class="quote">&gt; --- a/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt; +++ b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt; @@ -132,7 +132,33 @@ etrap_save:	save	%g2, -STACK_BIAS, %sp</span>
<span class="quote">&gt; 		stx	%g6, [%sp + PTREGS_OFF + PT_V9_G6]</span>
<span class="quote">&gt; 		stx	%g7, [%sp + PTREGS_OFF + PT_V9_G7]</span>
<span class="quote">&gt; 		or	%l7, %l0, %l7</span>
<span class="quote">&gt; -		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt; +661:		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * If userspace is using ADI, it could potentially pass</span>
<span class="quote">&gt; +		 * a pointer with version tag embedded in it. To maintain</span>
<span class="quote">&gt; +		 * the ADI security, we must enable PSTATE.mcde. Userspace</span>
<span class="quote">&gt; +		 * would have already set TTE.mcd in an earlier call to</span>
<span class="quote">&gt; +		 * kernel and set the version tag for the address being</span>
<span class="quote">&gt; +		 * dereferenced. Setting PSTATE.mcde would ensure any</span>
<span class="quote">&gt; +		 * access to userspace data through a system call honors</span>
<span class="quote">&gt; +		 * ADI and does not allow a rogue app to bypass ADI by</span>
<span class="quote">&gt; +		 * using system calls. Setting PSTATE.mcde only affects</span>
<span class="quote">&gt; +		 * accesses to virtual addresses that have TTE.mcd set.</span>
<span class="quote">&gt; +		 * Set PMCDPER to ensure any exceptions caused by ADI</span>
<span class="quote">&gt; +		 * version tag mismatch are exposed before system call</span>
<span class="quote">&gt; +		 * returns to userspace. Setting PMCDPER affects only</span>
<span class="quote">&gt; +		 * writes to virtual addresses that have TTE.mcd set and</span>
<span class="quote">&gt; +		 * have a version tag set as well.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt; +		.word	661b</span>
<span class="quote">&gt; +		sethi	%hi(TSTATE_TSO | TSTATE_PEF | TSTATE_MCDE), %l0</span>
<span class="quote">&gt; +		.previous</span>
<span class="quote">&gt; +661:		nop</span>
<span class="quote">&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt; +		.word	661b</span>
<span class="quote">&gt; +		.word 0xaf902001	/* wrpr %g0, 1, %pmcdper */</span>

Since PMCDPER is never cleared, setting it here is quickly going to set it on all CPUs and then become an expensive &quot;nop&quot; that burns ~50 cycles each time through etrap.  Consider setting it at boot time and when a CPU is DR&#39;d into the system.

Anthony
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 7, 2017, 12:31 a.m.</div>
<pre class="content">
On 03/06/2017 05:13 PM, Anthony Yznaga wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; On Feb 28, 2017, at 10:35 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/kernel/etrap_64.S b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt; index 1276ca2..7be33bf 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt; @@ -132,7 +132,33 @@ etrap_save:	save	%g2, -STACK_BIAS, %sp</span>
<span class="quote">&gt;&gt; 		stx	%g6, [%sp + PTREGS_OFF + PT_V9_G6]</span>
<span class="quote">&gt;&gt; 		stx	%g7, [%sp + PTREGS_OFF + PT_V9_G7]</span>
<span class="quote">&gt;&gt; 		or	%l7, %l0, %l7</span>
<span class="quote">&gt;&gt; -		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt;&gt; +661:		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt;&gt; +		/*</span>
<span class="quote">&gt;&gt; +		 * If userspace is using ADI, it could potentially pass</span>
<span class="quote">&gt;&gt; +		 * a pointer with version tag embedded in it. To maintain</span>
<span class="quote">&gt;&gt; +		 * the ADI security, we must enable PSTATE.mcde. Userspace</span>
<span class="quote">&gt;&gt; +		 * would have already set TTE.mcd in an earlier call to</span>
<span class="quote">&gt;&gt; +		 * kernel and set the version tag for the address being</span>
<span class="quote">&gt;&gt; +		 * dereferenced. Setting PSTATE.mcde would ensure any</span>
<span class="quote">&gt;&gt; +		 * access to userspace data through a system call honors</span>
<span class="quote">&gt;&gt; +		 * ADI and does not allow a rogue app to bypass ADI by</span>
<span class="quote">&gt;&gt; +		 * using system calls. Setting PSTATE.mcde only affects</span>
<span class="quote">&gt;&gt; +		 * accesses to virtual addresses that have TTE.mcd set.</span>
<span class="quote">&gt;&gt; +		 * Set PMCDPER to ensure any exceptions caused by ADI</span>
<span class="quote">&gt;&gt; +		 * version tag mismatch are exposed before system call</span>
<span class="quote">&gt;&gt; +		 * returns to userspace. Setting PMCDPER affects only</span>
<span class="quote">&gt;&gt; +		 * writes to virtual addresses that have TTE.mcd set and</span>
<span class="quote">&gt;&gt; +		 * have a version tag set as well.</span>
<span class="quote">&gt;&gt; +		 */</span>
<span class="quote">&gt;&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt;&gt; +		.word	661b</span>
<span class="quote">&gt;&gt; +		sethi	%hi(TSTATE_TSO | TSTATE_PEF | TSTATE_MCDE), %l0</span>
<span class="quote">&gt;&gt; +		.previous</span>
<span class="quote">&gt;&gt; +661:		nop</span>
<span class="quote">&gt;&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt;&gt; +		.word	661b</span>
<span class="quote">&gt;&gt; +		.word 0xaf902001	/* wrpr %g0, 1, %pmcdper */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Since PMCDPER is never cleared, setting it here is quickly going to set it on all CPUs and then become an expensive &quot;nop&quot; that burns ~50 cycles each time through etrap.  Consider setting it at boot time and when a CPU is DR&#39;d into the system.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Anthony</span>
<span class="quote">&gt;</span>

I considered that possibility. What made me uncomfortable with that is 
there is no way to prevent a driver/module or future code elsewhere in 
kernel from clearing PMCDPER with possibly good reason. If that were to 
happen, setting PMCDPER here ensures kernel will always see consistent 
behavior with system calls. It does come at a cost. Is that cost 
unacceptable to ensure consistent behavior?

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173107">Anthony Yznaga</a> - March 7, 2017, 1:25 a.m.</div>
<pre class="content">
<span class="quote">&gt; On Mar 6, 2017, at 4:31 PM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 03/06/2017 05:13 PM, Anthony Yznaga wrote:</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; On Feb 28, 2017, at 10:35 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/kernel/etrap_64.S b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt;&gt; index 1276ca2..7be33bf 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/kernel/etrap_64.S</span>
<span class="quote">&gt;&gt;&gt; @@ -132,7 +132,33 @@ etrap_save:	save	%g2, -STACK_BIAS, %sp</span>
<span class="quote">&gt;&gt;&gt; 		stx	%g6, [%sp + PTREGS_OFF + PT_V9_G6]</span>
<span class="quote">&gt;&gt;&gt; 		stx	%g7, [%sp + PTREGS_OFF + PT_V9_G7]</span>
<span class="quote">&gt;&gt;&gt; 		or	%l7, %l0, %l7</span>
<span class="quote">&gt;&gt;&gt; -		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt;&gt;&gt; +661:		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="quote">&gt;&gt;&gt; +		/*</span>
<span class="quote">&gt;&gt;&gt; +		 * If userspace is using ADI, it could potentially pass</span>
<span class="quote">&gt;&gt;&gt; +		 * a pointer with version tag embedded in it. To maintain</span>
<span class="quote">&gt;&gt;&gt; +		 * the ADI security, we must enable PSTATE.mcde. Userspace</span>
<span class="quote">&gt;&gt;&gt; +		 * would have already set TTE.mcd in an earlier call to</span>
<span class="quote">&gt;&gt;&gt; +		 * kernel and set the version tag for the address being</span>
<span class="quote">&gt;&gt;&gt; +		 * dereferenced. Setting PSTATE.mcde would ensure any</span>
<span class="quote">&gt;&gt;&gt; +		 * access to userspace data through a system call honors</span>
<span class="quote">&gt;&gt;&gt; +		 * ADI and does not allow a rogue app to bypass ADI by</span>
<span class="quote">&gt;&gt;&gt; +		 * using system calls. Setting PSTATE.mcde only affects</span>
<span class="quote">&gt;&gt;&gt; +		 * accesses to virtual addresses that have TTE.mcd set.</span>
<span class="quote">&gt;&gt;&gt; +		 * Set PMCDPER to ensure any exceptions caused by ADI</span>
<span class="quote">&gt;&gt;&gt; +		 * version tag mismatch are exposed before system call</span>
<span class="quote">&gt;&gt;&gt; +		 * returns to userspace. Setting PMCDPER affects only</span>
<span class="quote">&gt;&gt;&gt; +		 * writes to virtual addresses that have TTE.mcd set and</span>
<span class="quote">&gt;&gt;&gt; +		 * have a version tag set as well.</span>
<span class="quote">&gt;&gt;&gt; +		 */</span>
<span class="quote">&gt;&gt;&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt;&gt;&gt; +		.word	661b</span>
<span class="quote">&gt;&gt;&gt; +		sethi	%hi(TSTATE_TSO | TSTATE_PEF | TSTATE_MCDE), %l0</span>
<span class="quote">&gt;&gt;&gt; +		.previous</span>
<span class="quote">&gt;&gt;&gt; +661:		nop</span>
<span class="quote">&gt;&gt;&gt; +		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="quote">&gt;&gt;&gt; +		.word	661b</span>
<span class="quote">&gt;&gt;&gt; +		.word 0xaf902001	/* wrpr %g0, 1, %pmcdper */</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; Since PMCDPER is never cleared, setting it here is quickly going to set it on all CPUs and then become an expensive &quot;nop&quot; that burns ~50 cycles each time through etrap.  Consider setting it at boot time and when a CPU is DR&#39;d into the system.</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; Anthony</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I considered that possibility. What made me uncomfortable with that is there is no way to prevent a driver/module or future code elsewhere in kernel from clearing PMCDPER with possibly good reason. If that were to happen, setting PMCDPER here ensures kernel will always see consistent behavior with system calls. It does come at a cost. Is that cost unacceptable to ensure consistent behavior?</span>

Aren&#39;t you still at risk if the thread relinquishes the CPU while in the kernel and is then rescheduled on a CPU where PMCDPER has erroneously been left cleared?  You may need to save and restore PMCDPER as well as MCDPER on context switch, but I don&#39;t know if that will cover you completely.

Alternatively you can avoid problems from buggy code and avoid the performance hit when storing to ADI enabled memory with precise mode enabled (e.g. when reading from a file into an ADI-enabled buffer) by handling disrupting mismatches that happen in copy_to_user() or put_user().  That does require adding error barriers and appropriate exception table entries, though, to deal with the nature of disrupting exceptions.

Anthony
<span class="quote">
&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Khalid</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/sparc/adi.txt b/Documentation/sparc/adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..93fb97e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/sparc/adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,292 @@</span> <span class="p_context"></span>
<span class="p_add">+Application Data Integrity (ADI)</span>
<span class="p_add">+================================</span>
<span class="p_add">+</span>
<span class="p_add">+SPARC M7 processor adds the Application Data Integrity (ADI) feature.</span>
<span class="p_add">+ADI allows a task to set version tags on any subset of its address</span>
<span class="p_add">+space. Once ADI is enabled and version tags are set for ranges of</span>
<span class="p_add">+address space of a task, the processor will compare the tag in pointers</span>
<span class="p_add">+to memory in these ranges to the version set by the application</span>
<span class="p_add">+previously. Access to memory is granted only if the tag in given</span>
<span class="p_add">+pointer matches the tag set by the application. In case of mismatch,</span>
<span class="p_add">+processor raises an exception.</span>
<span class="p_add">+</span>
<span class="p_add">+Following steps must be taken by a task to enable ADI fully:</span>
<span class="p_add">+</span>
<span class="p_add">+1. Set the user mode PSTATE.mcde bit. This acts as master switch for</span>
<span class="p_add">+   the task&#39;s entire address space to enable/disable ADI for the task.</span>
<span class="p_add">+</span>
<span class="p_add">+2. Set TTE.mcd bit on any TLB entries that correspond to the range of</span>
<span class="p_add">+   addresses ADI is being enabled on. MMU checks the version tag only</span>
<span class="p_add">+   on the pages that have TTE.mcd bit set.</span>
<span class="p_add">+</span>
<span class="p_add">+3. Set the version tag for virtual addresses using stxa instruction</span>
<span class="p_add">+   and one of the MCD specific ASIs. Each stxa instruction sets the</span>
<span class="p_add">+   given tag for one ADI block size number of bytes. This step must</span>
<span class="p_add">+   be repeated for entire page to set tags for entire page.</span>
<span class="p_add">+</span>
<span class="p_add">+ADI block size for the platform is provided by the hypervisor to the</span>
<span class="p_add">+kernel in machine description tables. Hypervisor also provides the</span>
<span class="p_add">+number of top bits in the virtual address that specify the version tag.</span>
<span class="p_add">+Once version tag has been set for a memory location, the tag is stored</span>
<span class="p_add">+in the physical memory and the same tag must be present in the ADI</span>
<span class="p_add">+version tag bits of the virtual address being presented to the MMU. For</span>
<span class="p_add">+example on SPARC M7 processor, MMU uses bits 63-60 for version tags and</span>
<span class="p_add">+ADI block size is same as cacheline size which is 64 bytes. A task that</span>
<span class="p_add">+sets ADI version to say 10 on a range of memory, must access that memory</span>
<span class="p_add">+using virtual addresses that contain 0xa in bits 63-60.</span>
<span class="p_add">+</span>
<span class="p_add">+ADI is enabled on a set of pages using mprotect() with PROT_ADI flag.</span>
<span class="p_add">+When ADI is enabled on a set of pages by a task for the first time,</span>
<span class="p_add">+kernel sets the PSTATE.mcde bit fot the task. Version tags for memory</span>
<span class="p_add">+addresses are set with an stxa instruction on the addresses using</span>
<span class="p_add">+ASI_MCD_PRIMARY or ASI_MCD_ST_BLKINIT_PRIMARY. ADI block size is</span>
<span class="p_add">+provided by the hypervisor to the kernel.  Kernel returns the value of</span>
<span class="p_add">+ADI block size to userspace using auxiliary vector along with other ADI</span>
<span class="p_add">+info. Following auxiliary vectors are provided by the kernel:</span>
<span class="p_add">+</span>
<span class="p_add">+	AT_ADI_BLKSZ	ADI block size. This is the granularity and</span>
<span class="p_add">+			alignment, in bytes, of ADI versioning.</span>
<span class="p_add">+	AT_ADI_NBITS	Number of ADI version bits in the VA</span>
<span class="p_add">+	AT_ADI_UEONADI	If there is an uncorrectable error in array</span>
<span class="p_add">+			of versions maintained for cachelines, ADI</span>
<span class="p_add">+			version of memory affected by this error</span>
<span class="p_add">+			will be forced to this value when cachelines</span>
<span class="p_add">+			are flushed. This may not be supported on</span>
<span class="p_add">+			all platforms.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+IMPORTANT NOTES:</span>
<span class="p_add">+</span>
<span class="p_add">+- Version tag values of 0x0 and 0xf are reserved.</span>
<span class="p_add">+</span>
<span class="p_add">+- Version tags are set on virtual addresses from userspace even though</span>
<span class="p_add">+  tags are stored in physical memory. Tags are set on a physical page</span>
<span class="p_add">+  after it has been allocated to a task and a pte has been created for</span>
<span class="p_add">+  it.</span>
<span class="p_add">+</span>
<span class="p_add">+- When a task frees a memory page it had set version tags on, the page</span>
<span class="p_add">+  goes back to free page pool. When this page is re-allocated to a task,</span>
<span class="p_add">+  kernel clears the page using block initialization ASI which clears the</span>
<span class="p_add">+  version tags as well for the page. If a page allocated to a task is</span>
<span class="p_add">+  freed and allocated back to the same task, old version tags set by the</span>
<span class="p_add">+  task on that page will no longer be present.</span>
<span class="p_add">+</span>
<span class="p_add">+- Kernel does not set any tags for user pages and it is entirely a</span>
<span class="p_add">+  task&#39;s responsibility to set any version tags. Kernel does ensure the</span>
<span class="p_add">+  version tags are preserved if a page is swapped out to the disk and</span>
<span class="p_add">+  swapped back in. It also preserves that version tags if a page is</span>
<span class="p_add">+  migrated.</span>
<span class="p_add">+</span>
<span class="p_add">+- Initial implementation assumes a single page uses exact same version</span>
<span class="p_add">+  tag for the entire page. Kernel saves the version tag for only the</span>
<span class="p_add">+  first byte when swapping or migrating a page and restores that tag to</span>
<span class="p_add">+  the entire page after swapping in or migrating the page. Future</span>
<span class="p_add">+  implementations may expand kernel&#39;s capability to store/restore more</span>
<span class="p_add">+  than one tag per page.</span>
<span class="p_add">+</span>
<span class="p_add">+- ADI works for any size pages. A userspace task need not be aware of</span>
<span class="p_add">+  page size when using ADI. It can simply select a virtual address</span>
<span class="p_add">+  range, enable ADI on the range using mprotect() and set version tags</span>
<span class="p_add">+  for the entire range. mprotect() ensures range is aligned to page size</span>
<span class="p_add">+  and is a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ADI related traps</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+With ADI enabled, following new traps may occur:</span>
<span class="p_add">+</span>
<span class="p_add">+Disrupting memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory localtion that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. By</span>
<span class="p_add">+	default, it is a disrupting trap and is sent to the hypervisor</span>
<span class="p_add">+	first. Hypervisor creates a sun4v error report and sends a</span>
<span class="p_add">+	resumable error (TT=0x7e) trap to the kernel. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+		siginfo.si_addr = addr; /* PC where first mismatch occurred */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Precise memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory location that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. If</span>
<span class="p_add">+	MCD precise exception is enabled (MCDPERR=1), a precise</span>
<span class="p_add">+	exception is sent to the kernel with TT=0x1a. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	NOTE: ADI tag mismatch on a load always results in precise trap.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+MCD disabled</span>
<span class="p_add">+</span>
<span class="p_add">+	When a task has not enabled ADI and attempts to set ADI version</span>
<span class="p_add">+	on a memory address, processor sends an MCD disabled trap. This</span>
<span class="p_add">+	trap is handled by hypervisor first and the hypervisor vectors this</span>
<span class="p_add">+	trap through to the kernel as Data Access Exception trap with</span>
<span class="p_add">+	fault type set to 0xa (invalid ASI). When this occurs, the kernel</span>
<span class="p_add">+	sends the task SIGSEGV signal with following info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Sample program to use ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following sample program is meant to illustrate how to use the ADI</span>
<span class="p_add">+functionality.</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;unistd.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;elf.h&gt;</span>
<span class="p_add">+#include &lt;sys/ipc.h&gt;</span>
<span class="p_add">+#include &lt;sys/shm.h&gt;</span>
<span class="p_add">+#include &lt;sys/mman.h&gt;</span>
<span class="p_add">+#include &lt;asm/asi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef AT_ADI_BLKSZ</span>
<span class="p_add">+#define AT_ADI_BLKSZ	34</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef AT_ADI_NBITS</span>
<span class="p_add">+#define AT_ADI_NBITS	35</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef AT_ADI_UEONADI</span>
<span class="p_add">+#define AT_ADI_UEONADI	36</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef PROT_ADI</span>
<span class="p_add">+#define PROT_ADI	0x10</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE     32*1024*1024UL</span>
<span class="p_add">+</span>
<span class="p_add">+main(int argc, char* argv[], char* envp[])</span>
<span class="p_add">+{</span>
<span class="p_add">+        unsigned long i, mcde, adi_blksz, adi_nbits, adi_ueonadi;</span>
<span class="p_add">+        char *shmaddr, *tmp_addr, *end, *veraddr, *clraddr;</span>
<span class="p_add">+        int shmid, version;</span>
<span class="p_add">+	Elf64_auxv_t *auxv;</span>
<span class="p_add">+</span>
<span class="p_add">+	adi_blksz = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while(*envp++ != NULL);</span>
<span class="p_add">+	for (auxv = (Elf64_auxv_t *)envp; auxv-&gt;a_type != AT_NULL; auxv++) {</span>
<span class="p_add">+		switch (auxv-&gt;a_type) {</span>
<span class="p_add">+		case AT_ADI_BLKSZ:</span>
<span class="p_add">+			adi_blksz = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case AT_ADI_NBITS:</span>
<span class="p_add">+			adi_nbits = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case AT_ADI_UEONADI:</span>
<span class="p_add">+			adi_ueonadi = auxv-&gt;a_un.a_val;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (adi_blksz == 0) {</span>
<span class="p_add">+		fprintf(stderr, &quot;Oops! ADI is not supported\n&quot;);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;ADI capabilities:\n&quot;);</span>
<span class="p_add">+	printf(&quot;\tBlock size = %ld\n&quot;, adi_blksz);</span>
<span class="p_add">+	printf(&quot;\tNumber of bits = %ld\n&quot;, adi_nbits);</span>
<span class="p_add">+	printf(&quot;\tUE on ADI error = %ld\n&quot;, adi_ueonadi);</span>
<span class="p_add">+</span>
<span class="p_add">+        if ((shmid = shmget(2, BUFFER_SIZE,</span>
<span class="p_add">+                                IPC_CREAT | SHM_R | SHM_W)) &lt; 0) {</span>
<span class="p_add">+                perror(&quot;shmget failed&quot;);</span>
<span class="p_add">+                exit(1);</span>
<span class="p_add">+        }</span>
<span class="p_add">+</span>
<span class="p_add">+        shmaddr = shmat(shmid, NULL, 0);</span>
<span class="p_add">+        if (shmaddr == (char *)-1) {</span>
<span class="p_add">+                perror(&quot;shm attach failed&quot;);</span>
<span class="p_add">+                shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+                exit(1);</span>
<span class="p_add">+        }</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mprotect(shmaddr, BUFFER_SIZE, PROT_READ|PROT_WRITE|PROT_ADI)) {</span>
<span class="p_add">+		perror(&quot;mprotect failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Set the ADI version tag on the shm segment</span>
<span class="p_add">+         */</span>
<span class="p_add">+        version = 10;</span>
<span class="p_add">+        tmp_addr = shmaddr;</span>
<span class="p_add">+        end = shmaddr + BUFFER_SIZE;</span>
<span class="p_add">+        while (tmp_addr &lt; end) {</span>
<span class="p_add">+                asm volatile(</span>
<span class="p_add">+                        &quot;stxa %1, [%0]0x90\n\t&quot;</span>
<span class="p_add">+                        :</span>
<span class="p_add">+                        : &quot;r&quot; (tmp_addr), &quot;r&quot; (version));</span>
<span class="p_add">+                tmp_addr += adi_blksz;</span>
<span class="p_add">+        }</span>
<span class="p_add">+	asm volatile(&quot;membar #Sync\n\t&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Create a versioned address from the normal address by placing</span>
<span class="p_add">+	 * version tag in the upper adi_nbits bits</span>
<span class="p_add">+         */</span>
<span class="p_add">+        tmp_addr = (void *) ((unsigned long)shmaddr &lt;&lt; adi_nbits);</span>
<span class="p_add">+        tmp_addr = (void *) ((unsigned long)tmp_addr &gt;&gt; adi_nbits);</span>
<span class="p_add">+        veraddr = (void *) (((unsigned long)version &lt;&lt; (64-adi_nbits))</span>
<span class="p_add">+                        | (unsigned long)tmp_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+        printf(&quot;Starting the writes:\n&quot;);</span>
<span class="p_add">+        for (i = 0; i &lt; BUFFER_SIZE; i++) {</span>
<span class="p_add">+                veraddr[i] = (char)(i);</span>
<span class="p_add">+                if (!(i % (1024 * 1024)))</span>
<span class="p_add">+                        printf(&quot;.&quot;);</span>
<span class="p_add">+        }</span>
<span class="p_add">+        printf(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        printf(&quot;Verifying data...&quot;);</span>
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+        for (i = 0; i &lt; BUFFER_SIZE; i++)</span>
<span class="p_add">+                if (veraddr[i] != (char)i)</span>
<span class="p_add">+                        printf(&quot;\nIndex %lu mismatched\n&quot;, i);</span>
<span class="p_add">+        printf(&quot;Done.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Disable ADI and clean up</span>
<span class="p_add">+         */</span>
<span class="p_add">+	if (mprotect(shmaddr, BUFFER_SIZE, PROT_READ|PROT_WRITE)) {</span>
<span class="p_add">+		perror(&quot;mprotect failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+        if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+                perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+        shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+        exit(0);</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+        if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+                perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+        shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+        exit(1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/adi.h b/arch/sparc/include/asm/adi.h</span>
new file mode 100644
<span class="p_header">index 0000000..acad0d0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/include/asm/adi.h</span>
<span class="p_chunk">@@ -0,0 +1,6 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef ___ASM_SPARC_ADI_H</span>
<span class="p_add">+#define ___ASM_SPARC_ADI_H</span>
<span class="p_add">+#if defined(__sparc__) &amp;&amp; defined(__arch64__)</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/adi_64.h b/arch/sparc/include/asm/adi_64.h</span>
new file mode 100644
<span class="p_header">index 0000000..24fe52f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/include/asm/adi_64.h</span>
<span class="p_chunk">@@ -0,0 +1,46 @@</span> <span class="p_context"></span>
<span class="p_add">+/* adi_64.h: ADI related data structures</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Khalid Aziz (khalid.aziz@oracle.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This work is licensed under the terms of the GNU GPL, version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __ASM_SPARC64_ADI_H</span>
<span class="p_add">+#define __ASM_SPARC64_ADI_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps {</span>
<span class="p_add">+	__u64 blksz;</span>
<span class="p_add">+	__u64 nbits;</span>
<span class="p_add">+	__u64 ue_on_adi;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_config {</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	struct adi_caps caps;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct adi_config adi_state;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void mdesc_adi_init(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool adi_capable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long adi_blksize(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.caps.blksz;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long adi_nbits(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.caps.nbits;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif	/* !(__ASM_SPARC64_ADI_H) */</span>
<span class="p_header">diff --git a/arch/sparc/include/asm/elf_64.h b/arch/sparc/include/asm/elf_64.h</span>
<span class="p_header">index 3f2d403..cf00fbc 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/elf_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/elf_64.h</span>
<span class="p_chunk">@@ -210,4 +210,12 @@</span> <span class="p_context"> do {	if ((ex).e_ident[EI_CLASS] == ELFCLASS32)	\</span>
 			(current-&gt;personality &amp; (~PER_MASK)));	\
 } while (0)
 
<span class="p_add">+#define ARCH_DLINFO						\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	extern struct adi_config adi_state;			\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_BLKSZ, adi_state.caps.blksz);	\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_NBITS, adi_state.caps.nbits);	\</span>
<span class="p_add">+	NEW_AUX_ENT(AT_ADI_UEONADI, adi_state.caps.ue_on_adi);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 #endif /* !(__ASM_SPARC64_ELF_H) */
<span class="p_header">diff --git a/arch/sparc/include/asm/hugetlb.h b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">index dcbf985..ac2fe18 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -77,5 +77,18 @@</span> <span class="p_context"> static inline void arch_clear_hugepage_flags(struct page *page)</span>
 void hugetlb_free_pgd_range(struct mmu_gather *tlb, unsigned long addr,
 			    unsigned long end, unsigned long floor,
 			    unsigned long ceiling);
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+static inline pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+			 struct page *page, int writeable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If this vma has ADI enabled on it, turn on TTE.mcd</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return pte_mkmcd(entry);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return pte_mknotmcd(entry);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="p_add">+#endif</span>
 
 #endif /* _ASM_SPARC64_HUGETLB_H */
<span class="p_header">diff --git a/arch/sparc/include/asm/mman.h b/arch/sparc/include/asm/mman.h</span>
<span class="p_header">index 59bb593..95d3abc 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mman.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mman.h</span>
<span class="p_chunk">@@ -6,5 +6,43 @@</span> <span class="p_context"></span>
 #ifndef __ASSEMBLY__
 #define arch_mmap_check(addr,len,flags)	sparc_mmap_check(addr,len)
 int sparc_mmap_check(unsigned long addr, unsigned long len);
<span class="p_del">-#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_calc_vm_prot_bits(prot, pkey) sparc_calc_vm_prot_bits(prot)</span>
<span class="p_add">+static inline unsigned long sparc_calc_vm_prot_bits(unsigned long prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (prot &amp; PROT_ADI) {</span>
<span class="p_add">+		struct pt_regs *regs;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!current-&gt;mm-&gt;context.adi) {</span>
<span class="p_add">+			regs = task_pt_regs(current);</span>
<span class="p_add">+			regs-&gt;tstate |= TSTATE_MCDE;</span>
<span class="p_add">+			current-&gt;mm-&gt;context.adi = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return VM_SPARC_ADI;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_vm_get_page_prot(vm_flags) sparc_vm_get_page_prot(vm_flags)</span>
<span class="p_add">+static inline pgprot_t sparc_vm_get_page_prot(unsigned long vm_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (vm_flags &amp; VM_SPARC_ADI) ? __pgprot(_PAGE_MCD_4V) : __pgprot(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_validate_prot(prot) sparc_validate_prot(prot)</span>
<span class="p_add">+static inline int sparc_validate_prot(unsigned long prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (prot &amp; ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM | PROT_ADI))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if ((prot &amp; PROT_ADI) &amp;&amp; !adi_capable())</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_SPARC64 */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
 #endif /* __SPARC_MMAN_H__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_64.h b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">index f7de0db..e1d30ac 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_chunk">@@ -96,6 +96,7 @@</span> <span class="p_context"> typedef struct {</span>
 	unsigned long		thp_pte_count;
 	struct tsb_config	tsb_block[MM_NUM_TSBS];
 	struct hv_tsb_descr	tsb_descr[MM_NUM_TSBS];
<span class="p_add">+	bool			adi;</span>
 } mm_context_t;
 
 #endif /* !__ASSEMBLY__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_context_64.h b/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_header">index d031799..358a3ae 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_context_64.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/spinlock.h&gt;
 #include &lt;asm/spitfire.h&gt;
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
 #include &lt;asm-generic/mm_hooks.h&gt;
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
<span class="p_chunk">@@ -151,6 +152,47 @@</span> <span class="p_context"> static inline void activate_mm(struct mm_struct *active_mm, struct mm_struct *mm</span>
 	spin_unlock_irqrestore(&amp;mm-&gt;context.lock, flags);
 }
 
<span class="p_add">+#define  __HAVE_ARCH_START_CONTEXT_SWITCH</span>
<span class="p_add">+static inline void arch_start_context_switch(struct task_struct *prev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Save the current state of MCDPER register for the process we are</span>
<span class="p_add">+	 * switching from</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;.word 0x83438000\n\t&quot;	/* rd  %mcdper, %g1 */</span>
<span class="p_add">+			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;g1&quot;);</span>
<span class="p_add">+		if (tmp_mcdper)</span>
<span class="p_add">+			set_tsk_thread_flag(prev, TIF_MCDPER);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			clear_tsk_thread_flag(prev, TIF_MCDPER);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define finish_arch_post_lock_switch	finish_arch_post_lock_switch</span>
<span class="p_add">+static inline void finish_arch_post_lock_switch(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Restore the state of MCDPER register for the new process</span>
<span class="p_add">+	 * just switched to.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp_mcdper = test_thread_flag(TIF_MCDPER);</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;mov %0, %%g1\n\t&quot;</span>
<span class="p_add">+			&quot;.word 0x9d800001\n\t&quot;	/* wr %g0, %g1, %mcdper&quot; */</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;ir&quot; (tmp_mcdper)</span>
<span class="p_add">+			: &quot;g1&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* !(__ASSEMBLY__) */
 
 #endif /* !(__SPARC64_MMU_CONTEXT_H) */
<span class="p_header">diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">index 569768d..b0b9824 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/types.h&gt;
 #include &lt;asm/spitfire.h&gt;
 #include &lt;asm/asi.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/processor.h&gt;
 
<span class="p_chunk">@@ -564,6 +565,18 @@</span> <span class="p_context"> static inline pte_t pte_mkspecial(pte_t pte)</span>
 	return pte;
 }
 
<span class="p_add">+static inline pte_t pte_mkmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) |= _PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pte_t pte_mknotmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) &amp;= ~_PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long pte_young(pte_t pte)
 {
 	unsigned long mask;
<span class="p_chunk">@@ -964,9 +977,14 @@</span> <span class="p_context"> void pgtable_trans_huge_deposit(struct mm_struct *mm, pmd_t *pmdp,</span>
 pgtable_t pgtable_trans_huge_withdraw(struct mm_struct *mm, pmd_t *pmdp);
 #endif
 
<span class="p_del">-/* Encode and de-code a swap entry */</span>
<span class="p_add">+/* Encode and de-code a swap entry. Upper bits of offset are used to</span>
<span class="p_add">+ * store the ADI version tag for pages that have ADI enabled and tags set</span>
<span class="p_add">+ */</span>
 #define __swp_type(entry)	(((entry).val &gt;&gt; PAGE_SHIFT) &amp; 0xffUL)
<span class="p_del">-#define __swp_offset(entry)	((entry).val &gt;&gt; (PAGE_SHIFT + 8UL))</span>
<span class="p_add">+#define __swp_offset(entry)		\</span>
<span class="p_add">+	((((entry).val &lt;&lt; adi_nbits()) &gt;&gt; adi_nbits()) &gt;&gt; (PAGE_SHIFT + 8UL))</span>
<span class="p_add">+#define __swp_aditag(entry)		\</span>
<span class="p_add">+	((entry).val &gt;&gt; (sizeof(unsigned long)-adi_nbits()))</span>
 #define __swp_entry(type, offset)	\
 	( (swp_entry_t) \
 	  { \
<span class="p_chunk">@@ -989,6 +1007,69 @@</span> <span class="p_context"> int page_in_phys_avail(unsigned long paddr);</span>
 int remap_pfn_range(struct vm_area_struct *, unsigned long, unsigned long,
 		    unsigned long, pgprot_t);
 
<span class="p_add">+#define __HAVE_ARCH_DO_SWAP_PAGE</span>
<span class="p_add">+static inline void arch_do_swap_page(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+				     pte_t pte, pte_t oldpte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pte_val(pte) &amp; _PAGE_MCD_4V) {</span>
<span class="p_add">+		swp_entry_t tmp;</span>
<span class="p_add">+		pgoff_t swap_off;</span>
<span class="p_add">+		unsigned long swap_type, version;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Check if the swapped out page has an ADI version</span>
<span class="p_add">+		 * saved in the swap offset. If yes, restore</span>
<span class="p_add">+		 * version tag to the newly allocated page</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmp = __pte_to_swp_entry(oldpte);</span>
<span class="p_add">+		swap_off = __swp_offset(tmp);</span>
<span class="p_add">+		swap_type = __swp_type(tmp);</span>
<span class="p_add">+		version = __swp_aditag(tmp);</span>
<span class="p_add">+		if (version) {</span>
<span class="p_add">+			unsigned long i, paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+			paddr = pte_val(pte) &amp; _PAGE_PADDR_4V;</span>
<span class="p_add">+			for (i = paddr; i &lt; (paddr+PAGE_SIZE);</span>
<span class="p_add">+					i += adi_blksize())</span>
<span class="p_add">+				asm volatile(&quot;stxa %0, [%1] %2\n\t&quot;</span>
<span class="p_add">+					:</span>
<span class="p_add">+					: &quot;r&quot; (version), &quot;r&quot; (i),</span>
<span class="p_add">+					  &quot;i&quot; (ASI_MCD_REAL));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define __HAVE_ARCH_UNMAP_ONE</span>
<span class="p_add">+static inline void arch_unmap_one(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+				  pte_t pte, pte_t oldpte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pte_val(oldpte) &amp; _PAGE_MCD_4V) {</span>
<span class="p_add">+		unsigned long version, paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr = pte_val(oldpte) &amp; _PAGE_PADDR_4V;</span>
<span class="p_add">+		asm volatile(&quot;ldxa [%1] %2, %0\n\t&quot;</span>
<span class="p_add">+			     : &quot;=r&quot; (version)</span>
<span class="p_add">+			     : &quot;r&quot; (paddr), &quot;i&quot; (ASI_MCD_REAL));</span>
<span class="p_add">+		if (version) {</span>
<span class="p_add">+			swp_entry_t tmp;</span>
<span class="p_add">+			pgoff_t swap_off;</span>
<span class="p_add">+			unsigned long swap_type, shift_size;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Save ADI version tag in the top bits</span>
<span class="p_add">+			 * of swap offset</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = __pte_to_swp_entry(pte);</span>
<span class="p_add">+			swap_off = __swp_offset(tmp);</span>
<span class="p_add">+			swap_type = __swp_type(tmp);</span>
<span class="p_add">+			shift_size = PAGE_SHIFT + 8UL + adi_nbits();</span>
<span class="p_add">+			swap_off = (swap_off &lt;&lt; shift_size)&gt;&gt;shift_size;</span>
<span class="p_add">+			swap_off = (version &lt;&lt; (sizeof(unsigned long) -</span>
<span class="p_add">+					        shift_size)) | swap_off;</span>
<span class="p_add">+			tmp = __swp_entry(swap_type, swap_off);</span>
<span class="p_add">+			pte = __swp_entry_to_pte(tmp);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int io_remap_pfn_range(struct vm_area_struct *vma,
 				     unsigned long from, unsigned long pfn,
 				     unsigned long size, pgprot_t prot)
<span class="p_header">diff --git a/arch/sparc/include/asm/thread_info_64.h b/arch/sparc/include/asm/thread_info_64.h</span>
<span class="p_header">index 38a24f2..9c04acb 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/thread_info_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/thread_info_64.h</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> register struct thread_info *current_thread_info_reg asm(&quot;g6&quot;);</span>
  *       in using in assembly, else we can&#39;t use the mask as
  *       an immediate value in instructions such as andcc.
  */
<span class="p_del">-/* flag bit 12 is available */</span>
<span class="p_add">+#define TIF_MCDPER		12	/* Precise MCD exception */</span>
 #define TIF_MEMDIE		13	/* is terminating due to OOM killer */
 #define TIF_POLLING_NRFLAG	14
 
<span class="p_header">diff --git a/arch/sparc/include/asm/trap_block.h b/arch/sparc/include/asm/trap_block.h</span>
<span class="p_header">index ec9c04d..b283e94 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/trap_block.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/trap_block.h</span>
<span class="p_chunk">@@ -72,6 +72,8 @@</span> <span class="p_context"> struct sun4v_1insn_patch_entry {</span>
 };
 extern struct sun4v_1insn_patch_entry __sun4v_1insn_patch,
 	__sun4v_1insn_patch_end;
<span class="p_add">+extern struct sun4v_1insn_patch_entry __sun_m7_1insn_patch,</span>
<span class="p_add">+	__sun_m7_1insn_patch_end;</span>
 
 struct sun4v_2insn_patch_entry {
 	unsigned int	addr;
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/auxvec.h b/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_header">index ad6f360..6fe1249 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -1,4 +1,12 @@</span> <span class="p_context"></span>
 #ifndef __ASMSPARC_AUXVEC_H
 #define __ASMSPARC_AUXVEC_H
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+#define AT_ADI_BLKSZ	34</span>
<span class="p_add">+#define AT_ADI_NBITS	35</span>
<span class="p_add">+#define AT_ADI_UEONADI	36</span>
<span class="p_add">+</span>
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH	3</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* !(__ASMSPARC_AUXVEC_H) */
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/mman.h b/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_header">index 9765896..a72c033 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/mman.h</span>
<span class="p_chunk">@@ -5,6 +5,8 @@</span> <span class="p_context"></span>
 
 /* SunOS&#39;ified... */
 
<span class="p_add">+#define PROT_ADI	0x10		/* ADI enabled */</span>
<span class="p_add">+</span>
 #define MAP_RENAME      MAP_ANONYMOUS   /* In SunOS terminology */
 #define MAP_NORESERVE   0x40            /* don&#39;t reserve swap pages */
 #define MAP_INHERIT     0x80            /* SunOS doesn&#39;t do this, but... */
<span class="p_header">diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile</span>
<span class="p_header">index aac6098..8149e17 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/Makefile</span>
<span class="p_header">+++ b/arch/sparc/kernel/Makefile</span>
<span class="p_chunk">@@ -67,6 +67,7 @@</span> <span class="p_context"> obj-$(CONFIG_SPARC64)   += visemul.o</span>
 obj-$(CONFIG_SPARC64)   += hvapi.o
 obj-$(CONFIG_SPARC64)   += sstate.o
 obj-$(CONFIG_SPARC64)   += mdesc.o
<span class="p_add">+obj-$(CONFIG_SPARC64)   += adi_64.o</span>
 obj-$(CONFIG_SPARC64)	+= pcr.o
 obj-$(CONFIG_SPARC64)	+= nmi.o
 obj-$(CONFIG_SPARC64_SMP) += cpumap.o
<span class="p_header">diff --git a/arch/sparc/kernel/adi_64.c b/arch/sparc/kernel/adi_64.c</span>
new file mode 100644
<span class="p_header">index 0000000..aba1960</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/adi_64.c</span>
<span class="p_chunk">@@ -0,0 +1,93 @@</span> <span class="p_context"></span>
<span class="p_add">+/* adi_64.c: support for ADI (Application Data Integrity) feature on</span>
<span class="p_add">+ * sparc m7 and newer processors. This feature is also known as</span>
<span class="p_add">+ * SSM (Silicon Secured Memory).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Khalid Aziz (khalid.aziz@oracle.com)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This work is licensed under the terms of the GNU GPL, version 2.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;asm/mdesc.h&gt;</span>
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_config adi_state;</span>
<span class="p_add">+</span>
<span class="p_add">+/* mdesc_adi_init() : Parse machine description provided by the</span>
<span class="p_add">+ *	hypervisor to detect ADI capabilities</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Hypervisor reports ADI capabilities of platform in &quot;hwcap-list&quot; property</span>
<span class="p_add">+ * for &quot;cpu&quot; node. If the platform supports ADI, &quot;hwcap-list&quot; property</span>
<span class="p_add">+ * contains the keyword &quot;adp&quot;. If the platform supports ADI, &quot;platform&quot;</span>
<span class="p_add">+ * node will contain &quot;adp-blksz&quot;, &quot;adp-nbits&quot; and &quot;ue-on-adp&quot; properties</span>
<span class="p_add">+ * to describe the ADI capabilities.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init mdesc_adi_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mdesc_handle *hp = mdesc_grab();</span>
<span class="p_add">+	const char *prop;</span>
<span class="p_add">+	u64 pn, *val;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hp)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="p_add">+	if (!prop)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="p_add">+	 * ADI support</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+	while (len) {</span>
<span class="p_add">+		int plen;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="p_add">+			adi_state.enabled = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		plen = strlen(prop) + 1;</span>
<span class="p_add">+		prop += plen;</span>
<span class="p_add">+		len -= plen;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!adi_state.enabled)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the ADI properties in &quot;platform&quot; node. If all ADI</span>
<span class="p_add">+	 * properties are not found, ADI support is incomplete and</span>
<span class="p_add">+	 * do not enable ADI in the kernel.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.blksz = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.nbits = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto adi_not_found;</span>
<span class="p_add">+	adi_state.caps.ue_on_adi = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	mdesc_release(hp);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+adi_not_found:</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+	if (hp)</span>
<span class="p_add">+		mdesc_release(hp);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/kernel/etrap_64.S b/arch/sparc/kernel/etrap_64.S</span>
<span class="p_header">index 1276ca2..7be33bf 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/etrap_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/etrap_64.S</span>
<span class="p_chunk">@@ -132,7 +132,33 @@</span> <span class="p_context"> etrap_save:	save	%g2, -STACK_BIAS, %sp</span>
 		stx	%g6, [%sp + PTREGS_OFF + PT_V9_G6]
 		stx	%g7, [%sp + PTREGS_OFF + PT_V9_G7]
 		or	%l7, %l0, %l7
<span class="p_del">-		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="p_add">+661:		sethi	%hi(TSTATE_TSO | TSTATE_PEF), %l0</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If userspace is using ADI, it could potentially pass</span>
<span class="p_add">+		 * a pointer with version tag embedded in it. To maintain</span>
<span class="p_add">+		 * the ADI security, we must enable PSTATE.mcde. Userspace</span>
<span class="p_add">+		 * would have already set TTE.mcd in an earlier call to</span>
<span class="p_add">+		 * kernel and set the version tag for the address being</span>
<span class="p_add">+		 * dereferenced. Setting PSTATE.mcde would ensure any</span>
<span class="p_add">+		 * access to userspace data through a system call honors</span>
<span class="p_add">+		 * ADI and does not allow a rogue app to bypass ADI by</span>
<span class="p_add">+		 * using system calls. Setting PSTATE.mcde only affects</span>
<span class="p_add">+		 * accesses to virtual addresses that have TTE.mcd set.</span>
<span class="p_add">+		 * Set PMCDPER to ensure any exceptions caused by ADI</span>
<span class="p_add">+		 * version tag mismatch are exposed before system call</span>
<span class="p_add">+		 * returns to userspace. Setting PMCDPER affects only</span>
<span class="p_add">+		 * writes to virtual addresses that have TTE.mcd set and</span>
<span class="p_add">+		 * have a version tag set as well.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word	661b</span>
<span class="p_add">+		sethi	%hi(TSTATE_TSO | TSTATE_PEF | TSTATE_MCDE), %l0</span>
<span class="p_add">+		.previous</span>
<span class="p_add">+661:		nop</span>
<span class="p_add">+		.section .sun_m7_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word	661b</span>
<span class="p_add">+		.word 0xaf902001	/* wrpr %g0, 1, %pmcdper */</span>
<span class="p_add">+		.previous</span>
 		or	%l7, %l0, %l7
 		wrpr	%l2, %tnpc
 		wrpr	%l7, (TSTATE_PRIV | TSTATE_IE), %tstate
<span class="p_header">diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">index c0765bb..50b8bfb 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/mdesc.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;asm/oplib.h&gt;
 #include &lt;asm/smp.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 
 /* Unlike the OBP device tree, the machine description is a full-on
  * DAG.  An arbitrary number of ARCs are possible from one
<span class="p_chunk">@@ -1104,5 +1105,6 @@</span> <span class="p_context"> void __init sun4v_mdesc_init(void)</span>
 
 	cur_mdesc = hp;
 
<span class="p_add">+	mdesc_adi_init();</span>
 	report_platform_properties();
 }
<span class="p_header">diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c</span>
<span class="p_header">index d249ca1..c04ef3e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/process_64.c</span>
<span class="p_chunk">@@ -680,6 +680,31 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long sp,</span>
 	return 0;
 }
 
<span class="p_add">+/* TIF_MCDPER in thread info flags for current task is updated lazily upon</span>
<span class="p_add">+ * a context switch. Update the this flag in current task&#39;s thread flags</span>
<span class="p_add">+ * before dup so the dup&#39;d task will inherit the current TIF_MCDPER flag.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		register unsigned long tmp_mcdper;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__(</span>
<span class="p_add">+			&quot;.word 0x83438000\n\t&quot;	/* rd  %mcdper, %g1 */</span>
<span class="p_add">+			&quot;mov %%g1, %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot; (tmp_mcdper)</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;g1&quot;);</span>
<span class="p_add">+		if (tmp_mcdper)</span>
<span class="p_add">+			set_thread_flag(TIF_MCDPER);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			clear_thread_flag(TIF_MCDPER);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*dst = *src;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 typedef struct {
 	union {
 		unsigned int	pr_regs[32];
<span class="p_header">diff --git a/arch/sparc/kernel/setup_64.c b/arch/sparc/kernel/setup_64.c</span>
<span class="p_header">index 6b7331d..fafdd35 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/setup_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/setup_64.c</span>
<span class="p_chunk">@@ -240,6 +240,12 @@</span> <span class="p_context"> void sun4v_patch_1insn_range(struct sun4v_1insn_patch_entry *start,</span>
 	}
 }
 
<span class="p_add">+void sun_m7_patch_1insn_range(struct sun4v_1insn_patch_entry *start,</span>
<span class="p_add">+			     struct sun4v_1insn_patch_entry *end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sun4v_patch_1insn_range(start, end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void sun4v_patch_2insn_range(struct sun4v_2insn_patch_entry *start,
 			     struct sun4v_2insn_patch_entry *end)
 {
<span class="p_chunk">@@ -289,9 +295,12 @@</span> <span class="p_context"> static void __init sun4v_patch(void)</span>
 	sun4v_patch_2insn_range(&amp;__sun4v_2insn_patch,
 				&amp;__sun4v_2insn_patch_end);
 	if (sun4v_chip_type == SUN4V_CHIP_SPARC_M7 ||
<span class="p_del">-	    sun4v_chip_type == SUN4V_CHIP_SPARC_SN)</span>
<span class="p_add">+	    sun4v_chip_type == SUN4V_CHIP_SPARC_SN) {</span>
<span class="p_add">+		sun_m7_patch_1insn_range(&amp;__sun_m7_1insn_patch,</span>
<span class="p_add">+					 &amp;__sun_m7_1insn_patch_end);</span>
 		sun_m7_patch_2insn_range(&amp;__sun_m7_2insn_patch,
 					 &amp;__sun_m7_2insn_patch_end);
<span class="p_add">+		}</span>
 
 	sun4v_hvapi_init();
 }
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index a9a71d5..64fd221 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/memctrl.h&gt;
 #include &lt;asm/cacheflush.h&gt;
 #include &lt;asm/setup.h&gt;
<span class="p_add">+#include &lt;asm/adi_64.h&gt;</span>
 
 #include &quot;entry.h&quot;
 #include &quot;kernel.h&quot;
<span class="p_chunk">@@ -351,12 +352,31 @@</span> <span class="p_context"> void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig</span>
 		regs-&gt;tpc &amp;= 0xffffffff;
 		regs-&gt;tnpc &amp;= 0xffffffff;
 	}
<span class="p_del">-	info.si_signo = SIGSEGV;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MCD (Memory Corruption Detection) disabled trap (TT=0x19) in HV</span>
<span class="p_add">+	 * is vectored thorugh data access exception trap with fault type</span>
<span class="p_add">+	 * set to HV_FAULT_TYPE_MCD_DIS. Check for MCD disabled trap</span>
<span class="p_add">+	 */</span>
 	info.si_errno = 0;
<span class="p_del">-	info.si_code = SEGV_MAPERR;</span>
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
<span class="p_del">-	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case HV_FAULT_TYPE_INV_ASI:</span>
<span class="p_add">+		info.si_signo = SIGILL;</span>
<span class="p_add">+		info.si_code = ILL_ILLADR;</span>
<span class="p_add">+		force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HV_FAULT_TYPE_MCD_DIS:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_MAPERR;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
<span class="p_chunk">@@ -1801,6 +1821,7 @@</span> <span class="p_context"> struct sun4v_error_entry {</span>
 #define SUN4V_ERR_ATTRS_ASI		0x00000080
 #define SUN4V_ERR_ATTRS_PRIV_REG	0x00000100
 #define SUN4V_ERR_ATTRS_SPSTATE_MSK	0x00000600
<span class="p_add">+#define SUN4V_ERR_ATTRS_MCD		0x00000800</span>
 #define SUN4V_ERR_ATTRS_SPSTATE_SHFT	9
 #define SUN4V_ERR_ATTRS_MODE_MSK	0x03000000
 #define SUN4V_ERR_ATTRS_MODE_SHFT	24
<span class="p_chunk">@@ -1998,6 +2019,54 @@</span> <span class="p_context"> static void sun4v_log_error(struct pt_regs *regs, struct sun4v_error_entry *ent,</span>
 	}
 }
 
<span class="p_add">+/* Handle memory corruption detected error which is vectored in</span>
<span class="p_add">+ * through resumable error trap.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void do_mcd_err(struct pt_regs *regs, struct sun4v_error_entry ent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;MCD error&quot;, regs,</span>
<span class="p_add">+		       0, 0x34, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		/* MCD exception could happen because the task was running</span>
<span class="p_add">+		 * a system call with MCD enabled and passed a non-versioned</span>
<span class="p_add">+		 * pointer or pointer with bad version tag to  the system</span>
<span class="p_add">+		 * call. In such cases, hypervisor places the address of</span>
<span class="p_add">+		 * offending instruction in the resumable error report. This</span>
<span class="p_add">+		 * is a deferred error, so the read/write that caused the trap</span>
<span class="p_add">+		 * was potentially retired long time back and we may have</span>
<span class="p_add">+		 * no choice but to send SIGSEGV to the process.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		const struct exception_table_entry *entry;</span>
<span class="p_add">+</span>
<span class="p_add">+		entry = search_exception_tables(regs-&gt;tpc);</span>
<span class="p_add">+		if (entry) {</span>
<span class="p_add">+			/* Looks like a bad syscall parameter */</span>
<span class="p_add">+#ifdef DEBUG_EXCEPTIONS</span>
<span class="p_add">+			pr_emerg(&quot;Exception: PC&lt;%016lx&gt; faddr&lt;UNKNOWN&gt;\n&quot;,</span>
<span class="p_add">+				 regs-&gt;tpc);</span>
<span class="p_add">+			pr_emerg(&quot;EX_TABLE: insn&lt;%016lx&gt; fixup&lt;%016lx&gt;\n&quot;,</span>
<span class="p_add">+				 ent.err_raddr, entry-&gt;fixup);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			regs-&gt;tpc = entry-&gt;fixup;</span>
<span class="p_add">+			regs-&gt;tnpc = regs-&gt;tpc + 4;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send SIGSEGV to the userspace process with the right code</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+	info.si_addr = (void __user *)ent.err_raddr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We run with %pil set to PIL_NORMAL_MAX and PSTATE_IE enabled in %pstate.
  * Log the event and clear the first word of the entry.
  */
<span class="p_chunk">@@ -2035,6 +2104,14 @@</span> <span class="p_context"> void sun4v_resum_error(struct pt_regs *regs, unsigned long offset)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this is a memory corruption detected error, call the</span>
<span class="p_add">+	 * handler</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (local_copy.err_attrs &amp; SUN4V_ERR_ATTRS_MCD) {</span>
<span class="p_add">+		do_mcd_err(regs, local_copy);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sun4v_log_error(regs, &amp;local_copy, cpu,
 			KERN_ERR &quot;RESUMABLE ERROR&quot;,
 			&amp;sun4v_resum_oflow_cnt);
<span class="p_header">diff --git a/arch/sparc/kernel/vmlinux.lds.S b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">index 572db68..20a7068 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.pause_3insn_patch)
 		__pause_3insn_patch_end = .;
 	}
<span class="p_add">+	.sun_m7_1insn_patch : {</span>
<span class="p_add">+		__sun_m7_1insn_patch = .;</span>
<span class="p_add">+		*(.sun_m7_1insn_patch)</span>
<span class="p_add">+		__sun_m7_1insn_patch_end = .;</span>
<span class="p_add">+	}</span>
 	.sun_m7_2insn_patch : {
 		__sun_m7_2insn_patch = .;
 		*(.sun_m7_2insn_patch)
<span class="p_header">diff --git a/arch/sparc/mm/gup.c b/arch/sparc/mm/gup.c</span>
<span class="p_header">index cd0e32b..579f7ae 100644</span>
<span class="p_header">--- a/arch/sparc/mm/gup.c</span>
<span class="p_header">+++ b/arch/sparc/mm/gup.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/rwsem.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/adi.h&gt;</span>
 
 /*
  * The performance critical leaf functions are made noinline otherwise gcc
<span class="p_chunk">@@ -157,6 +158,24 @@</span> <span class="p_context"> int __get_user_pages_fast(unsigned long start, int nr_pages, int write,</span>
 	pgd_t *pgdp;
 	int nr = 0;
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		long addr = start;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If userspace has passed a versioned address, kernel</span>
<span class="p_add">+		 * will not find it in the VMAs since it does not store</span>
<span class="p_add">+		 * the version tags in the list of VMAs. Storing version</span>
<span class="p_add">+		 * tags in list of VMAs is impractical since they can be</span>
<span class="p_add">+		 * changed any time from userspace without dropping into</span>
<span class="p_add">+		 * kernel. Any address search in VMAs will be done with</span>
<span class="p_add">+		 * non-versioned addresses. Ensure the ADI version bits</span>
<span class="p_add">+		 * are dropped here by sign extending the last bit before</span>
<span class="p_add">+		 * ADI bits. IOMMU does not implement version tags.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		addr = (addr &lt;&lt; (long)adi_nbits()) &gt;&gt; (long)adi_nbits();</span>
<span class="p_add">+		start = addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	start &amp;= PAGE_MASK;
 	addr = start;
 	len = (unsigned long) nr_pages &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -187,6 +206,24 @@</span> <span class="p_context"> int get_user_pages_fast(unsigned long start, int nr_pages, int write,</span>
 	pgd_t *pgdp;
 	int nr = 0;
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+	if (adi_capable()) {</span>
<span class="p_add">+		long addr = start;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If userspace has passed a versioned address, kernel</span>
<span class="p_add">+		 * will not find it in the VMAs since it does not store</span>
<span class="p_add">+		 * the version tags in the list of VMAs. Storing version</span>
<span class="p_add">+		 * tags in list of VMAs is impractical since they can be</span>
<span class="p_add">+		 * changed any time from userspace without dropping into</span>
<span class="p_add">+		 * kernel. Any address search in VMAs will be done with</span>
<span class="p_add">+		 * non-versioned addresses. Ensure the ADI version bits</span>
<span class="p_add">+		 * are dropped here by sign extending the last bit before</span>
<span class="p_add">+		 * ADI bits. IOMMU does not implements version tags,</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		addr = (addr &lt;&lt; (long)adi_nbits()) &gt;&gt; (long)adi_nbits();</span>
<span class="p_add">+		start = addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 	start &amp;= PAGE_MASK;
 	addr = start;
 	len = (unsigned long) nr_pages &lt;&lt; PAGE_SHIFT;
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index b84615b..4eaf202 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -225,6 +225,8 @@</span> <span class="p_context"> extern unsigned int kobjsize(const void *objp);</span>
 # define VM_GROWSUP	VM_ARCH_1
 #elif defined(CONFIG_IA64)
 # define VM_GROWSUP	VM_ARCH_1
<span class="p_add">+#elif defined(CONFIG_SPARC64)</span>
<span class="p_add">+# define VM_SPARC_ADI	VM_ARCH_1	/* Uses ADI tag for access control */</span>
 #elif !defined(CONFIG_MMU)
 # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
 #endif

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



