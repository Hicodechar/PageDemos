
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2] x86/efi: Correct ident mapping of efi old_map when kalsr enabled - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2] x86/efi: Correct ident mapping of efi old_map when kalsr enabled</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=73061">Baoquan He</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 27, 2017, 12:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1493294823-9315-1-git-send-email-bhe@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9702811/mbox/"
   >mbox</a>
|
   <a href="/patch/9702811/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9702811/">/patch/9702811/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4D608602CC for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 27 Apr 2017 12:07:43 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2DB1F28399
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 27 Apr 2017 12:07:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1FB8928449; Thu, 27 Apr 2017 12:07:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5E91428399
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 27 Apr 2017 12:07:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S939190AbdD0MHa (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 27 Apr 2017 08:07:30 -0400
Received: from mx1.redhat.com ([209.132.183.28]:59132 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S936605AbdD0MHR (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 27 Apr 2017 08:07:17 -0400
Received: from smtp.corp.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id C06AF80503;
	Thu, 27 Apr 2017 12:07:11 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mx1.redhat.com C06AF80503
Authentication-Results: ext-mx03.extmail.prod.ext.phx2.redhat.com;
	dmarc=none (p=none dis=none) header.from=redhat.com
Authentication-Results: ext-mx03.extmail.prod.ext.phx2.redhat.com;
	spf=pass smtp.mailfrom=bhe@redhat.com
DKIM-Filter: OpenDKIM Filter v2.11.0 mx1.redhat.com C06AF80503
Received: from x1.redhat.com (ovpn-8-19.pek2.redhat.com [10.72.8.19])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 3548F88D9D;
	Thu, 27 Apr 2017 12:07:06 +0000 (UTC)
From: Baoquan He &lt;bhe@redhat.com&gt;
To: linux-kernel@vger.kernel.org
Cc: Baoquan He &lt;bhe@redhat.com&gt;, Dave Young &lt;dyoung@redhat.com&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Thomas Garnier &lt;thgarnie@google.com&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, x86@kernel.org,
	linux-efi@vger.kernel.org
Subject: [PATCH v2] x86/efi: Correct ident mapping of efi old_map when kalsr
	enabled
Date: Thu, 27 Apr 2017 20:07:03 +0800
Message-Id: &lt;1493294823-9315-1-git-send-email-bhe@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.11
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.27]);
	Thu, 27 Apr 2017 12:07:12 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - April 27, 2017, 12:07 p.m.</div>
<pre class="content">
For EFI with old_map enabled, Kernel will panic when kaslr is enabled.

The root cause is the ident mapping is not built correctly in this case.

For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE
aligned. We can borrow the pud table from direct mapping safely. Given a
physical address X, we have pud_index(X) == pud_index(__va(X)). However,
for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical
address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry
from direct mapping to build ident mapping, instead need copy pud entry
one by one from direct mapping.

So fix it in this patch.

The panic message is like below, an emty PUD or a wrong PUD.

[    0.233007] BUG: unable to handle kernel paging request at 000000007febd57e
[    0.233899] IP: 0x7febd57e
[    0.234000] PGD 1025a067
[    0.234000] PUD 0
[    0.234000]
[    0.234000] Oops: 0010 [#1] SMP
[    0.234000] Modules linked in:
[    0.234000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc8+ #125
[    0.234000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015
[    0.234000] task: ffffffffafe104c0 task.stack: ffffffffafe00000
[    0.234000] RIP: 0010:0x7febd57e
[    0.234000] RSP: 0000:ffffffffafe03d98 EFLAGS: 00010086
[    0.234000] RAX: ffff8c9e3fff9540 RBX: 000000007c4b6000 RCX: 0000000000000480
[    0.234000] RDX: 0000000000000030 RSI: 0000000000000480 RDI: 000000007febd57e
[    0.234000] RBP: ffffffffafe03e40 R08: 0000000000000001 R09: 000000007c4b6000
[    0.234000] R10: ffffffffafa71a40 R11: 20786c6c2478303d R12: 0000000000000030
[    0.234000] R13: 0000000000000246 R14: ffff8c9e3c4198d8 R15: 0000000000000480
[    0.234000] FS:  0000000000000000(0000) GS:ffff8c9e3fa00000(0000) knlGS:0000000000000000
[    0.234000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    0.234000] CR2: 000000007febd57e CR3: 000000000fe09000 CR4: 00000000000406b0
[    0.234000] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[    0.234000] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[    0.234000] Call Trace:
[    0.234000]  ? efi_call+0x58/0x90
[    0.234000]  ? printk+0x58/0x6f
[    0.234000]  efi_enter_virtual_mode+0x3c5/0x50d
[    0.234000]  start_kernel+0x40f/0x4b8
[    0.234000]  ? set_init_arg+0x55/0x55
[    0.234000]  ? early_idt_handler_array+0x120/0x120
[    0.234000]  x86_64_start_reservations+0x24/0x26
[    0.234000]  x86_64_start_kernel+0x14c/0x16f
[    0.234000]  start_cpu+0x14/0x14
[    0.234000] Code:  Bad RIP value.
[    0.234000] RIP: 0x7febd57e RSP: ffffffffafe03d98
[    0.234000] CR2: 000000007febd57e
[    0.234000] ---[ end trace d4ded46ab8ab8ba9 ]---
[    0.234000] Kernel panic - not syncing: Attempted to kill the idle task!
[    0.234000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task!
<span class="signed-off-by">
Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;
Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;
Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
Cc: Ingo Molnar &lt;mingo@redhat.com&gt;
Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
Cc: Thomas Garnier &lt;thgarnie@google.com&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;
Cc: x86@kernel.org
Cc: linux-efi@vger.kernel.org
---
v1-&gt;v2:
    Change code and add description according to Thomas&#39;s suggestion as below:

    1. Add checking if pud table is allocated successfully. If not just break
    the for loop.

    2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog

    3. Other minor change

 arch/x86/platform/efi/efi_64.c | 72 +++++++++++++++++++++++++++++++++++++-----
 1 file changed, 64 insertions(+), 8 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=160651">Thomas Garnier</a> - May 1, 2017, 2:21 p.m.</div>
<pre class="content">
On Thu, Apr 27, 2017 at 5:07 AM, Baoquan He &lt;bhe@redhat.com&gt; wrote:
<span class="quote">&gt; For EFI with old_map enabled, Kernel will panic when kaslr is enabled.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The root cause is the ident mapping is not built correctly in this case.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE</span>
<span class="quote">&gt; aligned. We can borrow the pud table from direct mapping safely. Given a</span>
<span class="quote">&gt; physical address X, we have pud_index(X) == pud_index(__va(X)). However,</span>
<span class="quote">&gt; for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical</span>
<span class="quote">&gt; address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry</span>
<span class="quote">&gt; from direct mapping to build ident mapping, instead need copy pud entry</span>
<span class="quote">&gt; one by one from direct mapping.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So fix it in this patch.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The panic message is like below, an emty PUD or a wrong PUD.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [    0.233007] BUG: unable to handle kernel paging request at 000000007febd57e</span>
<span class="quote">&gt; [    0.233899] IP: 0x7febd57e</span>
<span class="quote">&gt; [    0.234000] PGD 1025a067</span>
<span class="quote">&gt; [    0.234000] PUD 0</span>
<span class="quote">&gt; [    0.234000]</span>
<span class="quote">&gt; [    0.234000] Oops: 0010 [#1] SMP</span>
<span class="quote">&gt; [    0.234000] Modules linked in:</span>
<span class="quote">&gt; [    0.234000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc8+ #125</span>
<span class="quote">&gt; [    0.234000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015</span>
<span class="quote">&gt; [    0.234000] task: ffffffffafe104c0 task.stack: ffffffffafe00000</span>
<span class="quote">&gt; [    0.234000] RIP: 0010:0x7febd57e</span>
<span class="quote">&gt; [    0.234000] RSP: 0000:ffffffffafe03d98 EFLAGS: 00010086</span>
<span class="quote">&gt; [    0.234000] RAX: ffff8c9e3fff9540 RBX: 000000007c4b6000 RCX: 0000000000000480</span>
<span class="quote">&gt; [    0.234000] RDX: 0000000000000030 RSI: 0000000000000480 RDI: 000000007febd57e</span>
<span class="quote">&gt; [    0.234000] RBP: ffffffffafe03e40 R08: 0000000000000001 R09: 000000007c4b6000</span>
<span class="quote">&gt; [    0.234000] R10: ffffffffafa71a40 R11: 20786c6c2478303d R12: 0000000000000030</span>
<span class="quote">&gt; [    0.234000] R13: 0000000000000246 R14: ffff8c9e3c4198d8 R15: 0000000000000480</span>
<span class="quote">&gt; [    0.234000] FS:  0000000000000000(0000) GS:ffff8c9e3fa00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt; [    0.234000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt; [    0.234000] CR2: 000000007febd57e CR3: 000000000fe09000 CR4: 00000000000406b0</span>
<span class="quote">&gt; [    0.234000] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span>
<span class="quote">&gt; [    0.234000] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400</span>
<span class="quote">&gt; [    0.234000] Call Trace:</span>
<span class="quote">&gt; [    0.234000]  ? efi_call+0x58/0x90</span>
<span class="quote">&gt; [    0.234000]  ? printk+0x58/0x6f</span>
<span class="quote">&gt; [    0.234000]  efi_enter_virtual_mode+0x3c5/0x50d</span>
<span class="quote">&gt; [    0.234000]  start_kernel+0x40f/0x4b8</span>
<span class="quote">&gt; [    0.234000]  ? set_init_arg+0x55/0x55</span>
<span class="quote">&gt; [    0.234000]  ? early_idt_handler_array+0x120/0x120</span>
<span class="quote">&gt; [    0.234000]  x86_64_start_reservations+0x24/0x26</span>
<span class="quote">&gt; [    0.234000]  x86_64_start_kernel+0x14c/0x16f</span>
<span class="quote">&gt; [    0.234000]  start_cpu+0x14/0x14</span>
<span class="quote">&gt; [    0.234000] Code:  Bad RIP value.</span>
<span class="quote">&gt; [    0.234000] RIP: 0x7febd57e RSP: ffffffffafe03d98</span>
<span class="quote">&gt; [    0.234000] CR2: 000000007febd57e</span>
<span class="quote">&gt; [    0.234000] ---[ end trace d4ded46ab8ab8ba9 ]---</span>
<span class="quote">&gt; [    0.234000] Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt; [    0.234000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; Cc: linux-efi@vger.kernel.org</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; v1-&gt;v2:</span>
<span class="quote">&gt;     Change code and add description according to Thomas&#39;s suggestion as below:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     1. Add checking if pud table is allocated successfully. If not just break</span>
<span class="quote">&gt;     the for loop.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     3. Other minor change</span>
<span class="quote">&gt;</span>

Thanks for the changes.
<span class="acked-by">
Acked-by: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">
&gt;  arch/x86/platform/efi/efi_64.c | 72 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt;  1 file changed, 64 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; index 2ee7694..48de7fd 100644</span>
<span class="quote">&gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -       unsigned long vaddress;</span>
<span class="quote">&gt; +       unsigned long vaddr, left_vaddr;</span>
<span class="quote">&gt; +       unsigned int num_entries;</span>
<span class="quote">&gt;         pgd_t *save_pgd;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -       int pgd;</span>
<span class="quote">&gt; +       pud_t *pud, *pud_k;</span>
<span class="quote">&gt; +       int pud_idx;</span>
<span class="quote">&gt;         int n_pgds;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;                 save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; @@ -88,10 +90,51 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;         n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt;         save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -       for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; -               save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -               vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -               set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * We try to build 1:1 ident mapping for efi old_map usage. However,</span>
<span class="quote">&gt; +        * whether kaslr is enabled or not, PAGE_OFFSET must be PUD_SIZE</span>
<span class="quote">&gt; +        * aligned. Given a physical address X, we can copy its pud entry</span>
<span class="quote">&gt; +        * of __va(X) to fill in its pud entry of 1:1 mapping since both</span>
<span class="quote">&gt; +        * of them relate to the same physical memory position.</span>
<span class="quote">&gt; +        *</span>
<span class="quote">&gt; +        * And copying those pud entries one by one is inefficient. We copy</span>
<span class="quote">&gt; +        * memory. Assume PAGE_OFFSET is not PGDIR_SIZE aligned, say it&#39;s</span>
<span class="quote">&gt; +        * 0xffff880080000000, and we have memory bigger than 512G. Then the</span>
<span class="quote">&gt; +        * first 512G will cross two pgd entries. We need copy memory twice.</span>
<span class="quote">&gt; +        * The 1st pud entry will be in the 3rd slot of pud table, so we copy</span>
<span class="quote">&gt; +        * pud[2] to pud[511] of the 1st pud table pointed by the 1st pgd entry</span>
<span class="quote">&gt; +        * firstly, then copy pud[0] to pud[1] of the 2nd pud table pointed by</span>
<span class="quote">&gt; +        * 2nd pgd entry at the second time.</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       for (i = 0; i &lt; n_pgds; i++) {</span>
<span class="quote">&gt; +               save_pgd[i] = *pgd_offset_k(i * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               vaddr = (unsigned long)__va(i * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /*</span>
<span class="quote">&gt; +                * Though it may fail to allocate page in the middle, just</span>
<span class="quote">&gt; +                * leave those allocated pages there since 1:1 mapping has</span>
<span class="quote">&gt; +                * been built. And efi region could be located there, efi_call</span>
<span class="quote">&gt; +                * still can work.</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               pud = pud_alloc_one(NULL, 0);</span>
<span class="quote">&gt; +               if (!pud) {</span>
<span class="quote">&gt; +                       pr_err(&quot;Failed to allocate page for %d-th pud table &quot;</span>
<span class="quote">&gt; +                               &quot;to build 1:1 mapping!\n&quot;, i);</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               pud_idx = pud_index(vaddr);</span>
<span class="quote">&gt; +               num_entries = PTRS_PER_PUD - pud_idx;</span>
<span class="quote">&gt; +               pud_k = pud_offset(pgd_offset_k(vaddr), vaddr);</span>
<span class="quote">&gt; +               memcpy(pud, pud_k, num_entries);</span>
<span class="quote">&gt; +               if (pud_idx &gt; 0) {</span>
<span class="quote">&gt; +                       left_vaddr = vaddr + (num_entries * PUD_SIZE);</span>
<span class="quote">&gt; +                       pud_k = pud_offset(pgd_offset_k(left_vaddr),</span>
<span class="quote">&gt; +                                          left_vaddr);</span>
<span class="quote">&gt; +                       memcpy(pud + num_entries, pud_k, pud_idx);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               pgd_populate(NULL, pgd_offset_k(i * PGDIR_SIZE), pud);</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt;  out:</span>
<span class="quote">&gt;         __flush_tlb_all();</span>
<span class="quote">&gt; @@ -106,6 +149,8 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;          */</span>
<span class="quote">&gt;         int pgd_idx;</span>
<span class="quote">&gt;         int nr_pgds;</span>
<span class="quote">&gt; +       pud_t *pud;</span>
<span class="quote">&gt; +       pgd_t *pgd;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;                 write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; @@ -115,8 +160,19 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -       for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; +       for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; +               pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /*</span>
<span class="quote">&gt; +                * We need check if the pud table was really allocated</span>
<span class="quote">&gt; +                * successfully. Otherwise no need to free.</span>
<span class="quote">&gt; +                * */</span>
<span class="quote">&gt; +               if (pgd_val(*pgd) != pgd_val(save_pgd[pgd_idx])) {</span>
<span class="quote">&gt; +                       pud = (pud_t *)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; +                       pud_free(NULL, pud);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt;                 set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         kfree(save_pgd);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 2.5.5</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=119821">Matt Fleming</a> - May 5, 2017, 8:42 p.m.</div>
<pre class="content">
(Including the folks from SGI since this was hit on a UV system)

On Thu, 27 Apr, at 08:07:03PM, Baoquan He wrote:
<span class="quote">&gt; For EFI with old_map enabled, Kernel will panic when kaslr is enabled.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The root cause is the ident mapping is not built correctly in this case.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE</span>
<span class="quote">&gt; aligned. We can borrow the pud table from direct mapping safely. Given a</span>
<span class="quote">&gt; physical address X, we have pud_index(X) == pud_index(__va(X)). However,</span>
<span class="quote">&gt; for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical</span>
<span class="quote">&gt; address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry</span>
<span class="quote">&gt; from direct mapping to build ident mapping, instead need copy pud entry</span>
<span class="quote">&gt; one by one from direct mapping.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So fix it in this patch.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The panic message is like below, an emty PUD or a wrong PUD.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [    0.233007] BUG: unable to handle kernel paging request at 000000007febd57e</span>
<span class="quote">&gt; [    0.233899] IP: 0x7febd57e</span>
<span class="quote">&gt; [    0.234000] PGD 1025a067</span>
<span class="quote">&gt; [    0.234000] PUD 0</span>
<span class="quote">&gt; [    0.234000]</span>
<span class="quote">&gt; [    0.234000] Oops: 0010 [#1] SMP</span>
<span class="quote">&gt; [    0.234000] Modules linked in:</span>
<span class="quote">&gt; [    0.234000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc8+ #125</span>
<span class="quote">&gt; [    0.234000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015</span>
<span class="quote">&gt; [    0.234000] task: ffffffffafe104c0 task.stack: ffffffffafe00000</span>
<span class="quote">&gt; [    0.234000] RIP: 0010:0x7febd57e</span>
<span class="quote">&gt; [    0.234000] RSP: 0000:ffffffffafe03d98 EFLAGS: 00010086</span>
<span class="quote">&gt; [    0.234000] RAX: ffff8c9e3fff9540 RBX: 000000007c4b6000 RCX: 0000000000000480</span>
<span class="quote">&gt; [    0.234000] RDX: 0000000000000030 RSI: 0000000000000480 RDI: 000000007febd57e</span>
<span class="quote">&gt; [    0.234000] RBP: ffffffffafe03e40 R08: 0000000000000001 R09: 000000007c4b6000</span>
<span class="quote">&gt; [    0.234000] R10: ffffffffafa71a40 R11: 20786c6c2478303d R12: 0000000000000030</span>
<span class="quote">&gt; [    0.234000] R13: 0000000000000246 R14: ffff8c9e3c4198d8 R15: 0000000000000480</span>
<span class="quote">&gt; [    0.234000] FS:  0000000000000000(0000) GS:ffff8c9e3fa00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt; [    0.234000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt; [    0.234000] CR2: 000000007febd57e CR3: 000000000fe09000 CR4: 00000000000406b0</span>
<span class="quote">&gt; [    0.234000] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span>
<span class="quote">&gt; [    0.234000] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400</span>
<span class="quote">&gt; [    0.234000] Call Trace:</span>
<span class="quote">&gt; [    0.234000]  ? efi_call+0x58/0x90</span>
<span class="quote">&gt; [    0.234000]  ? printk+0x58/0x6f</span>
<span class="quote">&gt; [    0.234000]  efi_enter_virtual_mode+0x3c5/0x50d</span>
<span class="quote">&gt; [    0.234000]  start_kernel+0x40f/0x4b8</span>
<span class="quote">&gt; [    0.234000]  ? set_init_arg+0x55/0x55</span>
<span class="quote">&gt; [    0.234000]  ? early_idt_handler_array+0x120/0x120</span>
<span class="quote">&gt; [    0.234000]  x86_64_start_reservations+0x24/0x26</span>
<span class="quote">&gt; [    0.234000]  x86_64_start_kernel+0x14c/0x16f</span>
<span class="quote">&gt; [    0.234000]  start_cpu+0x14/0x14</span>
<span class="quote">&gt; [    0.234000] Code:  Bad RIP value.</span>
<span class="quote">&gt; [    0.234000] RIP: 0x7febd57e RSP: ffffffffafe03d98</span>
<span class="quote">&gt; [    0.234000] CR2: 000000007febd57e</span>
<span class="quote">&gt; [    0.234000] ---[ end trace d4ded46ab8ab8ba9 ]---</span>
<span class="quote">&gt; [    0.234000] Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt; [    0.234000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; Cc: linux-efi@vger.kernel.org</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; v1-&gt;v2:</span>
<span class="quote">&gt;     Change code and add description according to Thomas&#39;s suggestion as below:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     1. Add checking if pud table is allocated successfully. If not just break</span>
<span class="quote">&gt;     the for loop.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     3. Other minor change</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  arch/x86/platform/efi/efi_64.c | 72 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt;  1 file changed, 64 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; index 2ee7694..48de7fd 100644</span>
<span class="quote">&gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	unsigned long vaddress;</span>
<span class="quote">&gt; +	unsigned long vaddr, left_vaddr;</span>
<span class="quote">&gt; +	unsigned int num_entries;</span>
<span class="quote">&gt;  	pgd_t *save_pgd;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	int pgd;</span>
<span class="quote">&gt; +	pud_t *pud, *pud_k;</span>
<span class="quote">&gt; +	int pud_idx;</span>
<span class="quote">&gt;  	int n_pgds;</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;  		save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; @@ -88,10 +90,51 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;  	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt;  	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * We try to build 1:1 ident mapping for efi old_map usage. However,</span>
<span class="quote">&gt; +	 * whether kaslr is enabled or not, PAGE_OFFSET must be PUD_SIZE</span>
<span class="quote">&gt; +	 * aligned. Given a physical address X, we can copy its pud entry</span>
<span class="quote">&gt; +	 * of __va(X) to fill in its pud entry of 1:1 mapping since both</span>
<span class="quote">&gt; +	 * of them relate to the same physical memory position.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * And copying those pud entries one by one is inefficient. We copy</span>
<span class="quote">&gt; +	 * memory. Assume PAGE_OFFSET is not PGDIR_SIZE aligned, say it&#39;s</span>
<span class="quote">&gt; +	 * 0xffff880080000000, and we have memory bigger than 512G. Then the</span>
<span class="quote">&gt; +	 * first 512G will cross two pgd entries. We need copy memory twice.</span>
<span class="quote">&gt; +	 * The 1st pud entry will be in the 3rd slot of pud table, so we copy</span>
<span class="quote">&gt; +	 * pud[2] to pud[511] of the 1st pud table pointed by the 1st pgd entry</span>
<span class="quote">&gt; +	 * firstly, then copy pud[0] to pud[1] of the 2nd pud table pointed by</span>
<span class="quote">&gt; +	 * 2nd pgd entry at the second time.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	for (i = 0; i &lt; n_pgds; i++) {</span>
<span class="quote">&gt; +		save_pgd[i] = *pgd_offset_k(i * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		vaddr = (unsigned long)__va(i * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Though it may fail to allocate page in the middle, just</span>
<span class="quote">&gt; +		 * leave those allocated pages there since 1:1 mapping has</span>
<span class="quote">&gt; +		 * been built. And efi region could be located there, efi_call</span>
<span class="quote">&gt; +		 * still can work.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		pud = pud_alloc_one(NULL, 0);</span>
<span class="quote">&gt; +		if (!pud) {</span>
<span class="quote">&gt; +			pr_err(&quot;Failed to allocate page for %d-th pud table &quot;</span>
<span class="quote">&gt; +				&quot;to build 1:1 mapping!\n&quot;, i);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pud_idx = pud_index(vaddr);</span>
<span class="quote">&gt; +		num_entries = PTRS_PER_PUD - pud_idx;</span>
<span class="quote">&gt; +		pud_k = pud_offset(pgd_offset_k(vaddr), vaddr);</span>
<span class="quote">&gt; +		memcpy(pud, pud_k, num_entries);</span>
<span class="quote">&gt; +		if (pud_idx &gt; 0) {</span>
<span class="quote">&gt; +			left_vaddr = vaddr + (num_entries * PUD_SIZE);</span>
<span class="quote">&gt; +			pud_k = pud_offset(pgd_offset_k(left_vaddr),</span>
<span class="quote">&gt; +					   left_vaddr);</span>
<span class="quote">&gt; +			memcpy(pud + num_entries, pud_k, pud_idx);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		pgd_populate(NULL, pgd_offset_k(i * PGDIR_SIZE), pud);</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  out:</span>
<span class="quote">&gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; @@ -106,6 +149,8 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	int pgd_idx;</span>
<span class="quote">&gt;  	int nr_pgds;</span>
<span class="quote">&gt; +	pud_t *pud;</span>
<span class="quote">&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;  		write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; @@ -115,8 +160,19 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; +	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * We need check if the pud table was really allocated</span>
<span class="quote">&gt; +		 * successfully. Otherwise no need to free.</span>
<span class="quote">&gt; +		 * */</span>
<span class="quote">&gt; +		if (pgd_val(*pgd) != pgd_val(save_pgd[pgd_idx])) {</span>
<span class="quote">&gt; +			pud = (pud_t *)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; +			pud_free(NULL, pud);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt;  		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	kfree(save_pgd);</span>

This seems like a lot of code for a really simple problem. Do other
1:1 users require this change? I&#39;m thinking of the realmode trampoline
code.

If the SGI folks think this looks OK then I&#39;ll apply it with Thomas&#39;
ACK.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 5, 2017, 11:36 p.m.</div>
<pre class="content">
On Fri, May 05, 2017 at 09:42:14PM +0100, Matt Fleming wrote:
<span class="quote">&gt; (Including the folks from SGI since this was hit on a UV system)</span>

Wasn&#39;t there a BIOS fix supplied at some point which obviated the need
to boot with efi=old_map on SGI boxes?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=172137">Bhupesh Sharma</a> - May 7, 2017, 6:37 p.m.</div>
<pre class="content">
On Sat, May 6, 2017 at 5:06 AM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:
<span class="quote">&gt; On Fri, May 05, 2017 at 09:42:14PM +0100, Matt Fleming wrote:</span>
<span class="quote">&gt;&gt; (Including the folks from SGI since this was hit on a UV system)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Wasn&#39;t there a BIOS fix supplied at some point which obviated the need</span>
<span class="quote">&gt; to boot with efi=old_map on SGI boxes?</span>
<span class="quote">&gt;</span>

AFAICR, the bios fixes were provided only for SGI boxes with BIOS
version greater than or equal to UV2 (so upstream with recent bios
works on UV2, UV3, and UV4 hardware platforms, both with old and new
mapping, with new mapping being the default), however the UV1
platforms still use efi=old_map

Also as mentioned above since commit
caef78b6cdeddf4ad364f95910bba6b43b8eb9bf fixed the efi=old_map support
on UV systems even with new bios, they should ideally all boot up
properly in upstream both with &#39;nokaslr&#39; and without &#39;nokaslr&#39; in the
bootargs when efi=old_map is used.

Regards,
Bhupesh
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 8, 2017, 1:36 a.m.</div>
<pre class="content">
Thanks for explaining, Bhupesh. 

BIOS issue of SGI uv1 is still not fixed. There&#39;s a quirk for uv1 to
use efi old map:

void __init efi_apply_memmap_quirks(void)
{
	...
	...
        /* UV2+ BIOS has a fix for this issue.  UV1 still needs the quirk. */
        if (dmi_check_system(sgi_uv1_dmi))
                set_bit(EFI_OLD_MEMMAP, &amp;efi.flags);
}

And because of some reasons, redhat also need efi old_map now.

Hi Matt,

This v2 patch works on my kvm guest, however there&#39;s still problem on
SGI system. I will post v3 later after it&#39;s handled. So nack this v2
patch.

Thanks
Baoquan

On 05/08/17 at 12:07am, Bhupesh Sharma wrote:
<span class="quote">&gt; On Sat, May 6, 2017 at 5:06 AM, Borislav Petkov &lt;bp@alien8.de&gt; wrote:</span>
<span class="quote">&gt; &gt; On Fri, May 05, 2017 at 09:42:14PM +0100, Matt Fleming wrote:</span>
<span class="quote">&gt; &gt;&gt; (Including the folks from SGI since this was hit on a UV system)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Wasn&#39;t there a BIOS fix supplied at some point which obviated the need</span>
<span class="quote">&gt; &gt; to boot with efi=old_map on SGI boxes?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; AFAICR, the bios fixes were provided only for SGI boxes with BIOS</span>
<span class="quote">&gt; version greater than or equal to UV2 (so upstream with recent bios</span>
<span class="quote">&gt; works on UV2, UV3, and UV4 hardware platforms, both with old and new</span>
<span class="quote">&gt; mapping, with new mapping being the default), however the UV1</span>
<span class="quote">&gt; platforms still use efi=old_map</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also as mentioned above since commit</span>
<span class="quote">&gt; caef78b6cdeddf4ad364f95910bba6b43b8eb9bf fixed the efi=old_map support</span>
<span class="quote">&gt; on UV systems even with new bios, they should ideally all boot up</span>
<span class="quote">&gt; properly in upstream both with &#39;nokaslr&#39; and without &#39;nokaslr&#39; in the</span>
<span class="quote">&gt; bootargs when efi=old_map is used.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Regards,</span>
<span class="quote">&gt; Bhupesh</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=174187">Russ Anderson</a> - May 8, 2017, 3:18 a.m.</div>
<pre class="content">
On Sat, May 06, 2017 at 01:36:20AM +0200, Borislav Petkov wrote:
<span class="quote">&gt; On Fri, May 05, 2017 at 09:42:14PM +0100, Matt Fleming wrote:</span>
<span class="quote">&gt; &gt; (Including the folks from SGI since this was hit on a UV system)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Wasn&#39;t there a BIOS fix supplied at some point which obviated the need</span>
<span class="quote">&gt; to boot with efi=old_map on SGI boxes?</span>

Yes, and other fixes to get new and old mapping working (except
for UV1 hardware).  The kaslr patchset broke booting with old
mapping.  That is the issue Baoquan, Bhupesh, and legacy SGI
engineers are trying to fix.


For those that want a more detailed summary:

In early 2014 upstream EFI changed the mapping, which lead to setting EFI_OLD_MEMMAP on all UV systems.

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=a5d90c923bcfb9632d998ed06e9569216ad695f3

Later upstream fixes, plus a bios fix, got new mapping working.
Here are a couple of the fixes.

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=08914f436bdd2ed60923f49cbc402307aba20fe4
  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/arch/x86/platform/uv/bios_uv.c?id=f72075c9eda8a43aeea2f9dbb8d187afd4a76f0b

This patch enabled new EFI mapping on UV2+ platforms (all but UV1).
Note this is not bios version checking, it is hardware platform checking.

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/arch/x86/platform/efi/quirks.c?id=d394f2d9d8e1e7b4959819344baf67b5995da9b0

One of the fixes to get new map to work broke old map.  This patch fixed it.

  https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/arch/x86/platform/uv/bios_uv.c?id=caef78b6cdeddf4ad364f95910bba6b43b8eb9bf

So upstream with recent bios works on UV2, UV3, and UV4 hardware platforms,
both old and new mapping, with new mapping being the default.

Thanks.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 11, 2017, 9:32 a.m.</div>
<pre class="content">
Hi all,

On 05/05/17 at 09:42pm, Matt Fleming wrote:
<span class="quote">&gt; (Including the folks from SGI since this was hit on a UV system)</span>

After debugging, I got the reason why kernel still crash casually when
the ident mapping issue of old_map efi has been fixed. It&#39;s because
SGI UV3 needs map MMIOH regions.  On a SGI uv3 system, I found that
there are two MMIOH regions:

[    1.519001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000
                                      16TB-16G -  16T
[    1.523001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000
                                           16TB - 32TB
On this system, 512G ram are spread out to 1TB regions. Then above two
SGI MMIOH region also will be mapped into direct mapping section by
adding PAGE_OFFSET. The thing is SGI UV3 maps its MMIOH region to direct
mapping in uv_system_init() which is called during
kernel_init_freeable(), it&#39;s much later than kernel_randomize_memory(),
mm KASLR has no chance to take it into consideration.

When kaslr disabled, we can see that there are 64T
memory for ram. If system ram is not big enough, the left space of the
whole 64T memory is still enough to contain MMIOH regions to make it not
reach vmalloc and vmemmap area. 

ffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys.
memory                                                                  
136T - 200T
ffffc80000000000 - ffffc8ffffffffff (=40 bits) hole
200T - 201T
ffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap space
201T - 233T 

While with kaslr enabled, there&#39;s no this 64T memory reserved thing for
system ram any more. KASLR only reserve the actual size of system ram plus
10TB for direct mapping. So on SGI uv3 system, with kaslr enabled, MMIOH
region mapping could touch vmalloc or vmemmap area and trigger the BUG_ON()
in __init_extra_mapping().

Below is the back trace of crash after the ident mapping of old_map is
fixed. I believe this will happen on new map efi too, will reboot
several times to test new map efi.

So I will repost v3 for the ident mapping of old_map efi issue because
that is a code bug and independent with this one. And any idea about
this SGI uv3 MMIOH mapping issue?
 

[    1.375001] UV: Found UV300 hub
[    1.376007] UV: UVsystab: Revision:1
[    1.377001] UV: No UVsystab socket table, ignoring
[    1.378003] UV: N:7 M:38 m_shift:26 n_lshift:43
[    1.379001] UV: gpa_mask/shift:0x1fffffffffff/0 pnode_mask:0x7f apic_pns:5
[    1.380001] UV: mmr_base/shift:0xffa00000000/26 gru_base/shift:0x0/0
[    1.381001] UV: gnode_upper:0x0 gnode_extra:0x0
[    1.382001] UV: NODE_PRESENT_DEPTH = 16
[    1.383001] UV: NODE_PRESENT(0) = 0x000000000000000f
[    1.384005] UV: Found 4 hubs, 4 nodes, 128 CPUs
[    1.385076] UV: UVHUB node: 0 pn:00 nrcpus:32
[    1.386001] UV: UVHUB node: 1 pn:01 nrcpus:32
[    1.387001] UV: UVHUB node: 2 pn:02 nrcpus:32
[    1.388001] UV: UVHUB node: 3 pn:03 nrcpus:32
[    1.389001] UV: min_pnode:00 max_pnode:03
[    1.390002] UV: Map GRU_HI 0xff000000000 - 0xff040000000
[    1.391013] UV: Map MMR_HI 0xffa00000000 - 0xffa10000000
[    1.392004] UV: MMIOH0 overlay 0x8006cffc00000000 base:0x3ff00 m_io:27
[    1.393029] UV: MMIOH0[000..127] NASID 0x0000 ADDR 0x00000ffc00000000 - 0x0000100000000000
[    1.394001] UV: MMIOH0 base:0x3ff00 shift:26 M_IO:27 MAX_IO:127
[    1.395001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000
[    1.396116] UV: MMIOH1 overlay 0x8009500000000000 base:0x40000 m_io:37
[    1.397029] UV: MMIOH1[000..127] NASID 0x0000 ADDR 0x0000100000000000 - 0x0000200000000000
[    1.398001] UV: MMIOH1 base:0x40000 shift:26 M_IO:37 MAX_IO:127
[    1.399001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000
[    1.487916] ------------[ cut here ]------------
[    1.488002] kernel BUG at arch/x86/mm/init_64.c:311!
[    1.489003] invalid opcode: 0000 [#1] SMP
[    1.490000] Modules linked in:
[    1.490000] CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.11.0+ #17
[    1.490000] Hardware name: SGI UV300/UV300, BIOS SGI UV 300 series BIOS 05/25/2016
[    1.490000] task: ffff88d6f3910000 task.stack: ffffa488c0018000
[    1.490000] RIP: 0010:__init_extra_mapping+0x188/0x196
[    1.490000] RSP: 0000:ffffa488c001bc50 EFLAGS: 00010202
[    1.490000] RAX: ffff88d6ffc02000 RBX: ffff8897ffd16118 RCX: 00003ffffffff000
[    1.490000] RDX: ffff88d6ffc02000 RSI: 80001bf23fe001fb RDI: 0000000000000000
[    1.490000] RBP: ffffa488c001bc80 R08: 0000000000000000 R09: 000000000001f458
[    1.490000] R10: ffff88b6fffd5d00 R11: 0000000000000001 R12: 00001bf240000000
[    1.490000] R13: 0000040dc0000000 R14: 80000000000001fb R15: 0000000000000118
[    1.490000] FS:  0000000000000000(0000) GS:ffff88b683600000(0000) knlGS:0000000000000000
[    1.490000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    1.490000] CR2: ffff89757efff000 CR3: 0000000430a09000 CR4: 00000000003406f0
[    1.490000] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[    1.490000] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
[    1.490000] Call Trace:
[    1.490000]  init_extra_mapping_uc+0x13/0x15
[    1.490000]  map_high+0x67/0x75
[    1.490000]  map_mmioh_high_uv3+0x20a/0x219
[    1.490000]  uv_system_init_hub+0x12d9/0x1496
[    1.490000]  uv_system_init+0x27/0x29
[    1.490000]  native_smp_prepare_cpus+0x28d/0x2d8
[    1.490000]  kernel_init_freeable+0xdd/0x253
[    1.490000]  ? rest_init+0x80/0x80
[    1.490000]  kernel_init+0xe/0x110
[    1.490000]  ret_from_fork+0x2c/0x40
[    1.490000] Code: 0a ee 29 ff 66 90 48 8b 3b e8 30 2e 2a ff 4c 89 e2
48 c1 ea 12 81 e2 f8 0f 00 00 48 01 c2 48 f7 02 9f ff ff ff 0f 84 da fe
ff ff &lt;0f&gt; 0b 58 5b 41 5c 41 5d 41 5e 41 5f 5d c3 0f 1f 44 00 00 55 48 
[    1.490000] RIP: __init_extra_mapping+0x188/0x196 RSP: ffffa488c001bc50
[    1.490002] ---[ end trace f1736a9e6e4b7656 ]---
[    1.491001] Kernel panic - not syncing: Fatal exception
[    1.492000] ---[ end Kernel panic - not syncing: Fatal exception
******** [20170511.020636] BMC r001i11b: Power OFF via BMC 
******** [20170511.020701] BMC r001i11b: Power ON via BMC
<span class="quote">
&gt; </span>
<span class="quote">&gt; On Thu, 27 Apr, at 08:07:03PM, Baoquan He wrote:</span>
<span class="quote">&gt; &gt; For EFI with old_map enabled, Kernel will panic when kaslr is enabled.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The root cause is the ident mapping is not built correctly in this case.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE</span>
<span class="quote">&gt; &gt; aligned. We can borrow the pud table from direct mapping safely. Given a</span>
<span class="quote">&gt; &gt; physical address X, we have pud_index(X) == pud_index(__va(X)). However,</span>
<span class="quote">&gt; &gt; for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical</span>
<span class="quote">&gt; &gt; address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry</span>
<span class="quote">&gt; &gt; from direct mapping to build ident mapping, instead need copy pud entry</span>
<span class="quote">&gt; &gt; one by one from direct mapping.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So fix it in this patch.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The panic message is like below, an emty PUD or a wrong PUD.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; [    0.233007] BUG: unable to handle kernel paging request at 000000007febd57e</span>
<span class="quote">&gt; &gt; [    0.233899] IP: 0x7febd57e</span>
<span class="quote">&gt; &gt; [    0.234000] PGD 1025a067</span>
<span class="quote">&gt; &gt; [    0.234000] PUD 0</span>
<span class="quote">&gt; &gt; [    0.234000]</span>
<span class="quote">&gt; &gt; [    0.234000] Oops: 0010 [#1] SMP</span>
<span class="quote">&gt; &gt; [    0.234000] Modules linked in:</span>
<span class="quote">&gt; &gt; [    0.234000] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.11.0-rc8+ #125</span>
<span class="quote">&gt; &gt; [    0.234000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 0.0.0 02/06/2015</span>
<span class="quote">&gt; &gt; [    0.234000] task: ffffffffafe104c0 task.stack: ffffffffafe00000</span>
<span class="quote">&gt; &gt; [    0.234000] RIP: 0010:0x7febd57e</span>
<span class="quote">&gt; &gt; [    0.234000] RSP: 0000:ffffffffafe03d98 EFLAGS: 00010086</span>
<span class="quote">&gt; &gt; [    0.234000] RAX: ffff8c9e3fff9540 RBX: 000000007c4b6000 RCX: 0000000000000480</span>
<span class="quote">&gt; &gt; [    0.234000] RDX: 0000000000000030 RSI: 0000000000000480 RDI: 000000007febd57e</span>
<span class="quote">&gt; &gt; [    0.234000] RBP: ffffffffafe03e40 R08: 0000000000000001 R09: 000000007c4b6000</span>
<span class="quote">&gt; &gt; [    0.234000] R10: ffffffffafa71a40 R11: 20786c6c2478303d R12: 0000000000000030</span>
<span class="quote">&gt; &gt; [    0.234000] R13: 0000000000000246 R14: ffff8c9e3c4198d8 R15: 0000000000000480</span>
<span class="quote">&gt; &gt; [    0.234000] FS:  0000000000000000(0000) GS:ffff8c9e3fa00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt; &gt; [    0.234000] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt; &gt; [    0.234000] CR2: 000000007febd57e CR3: 000000000fe09000 CR4: 00000000000406b0</span>
<span class="quote">&gt; &gt; [    0.234000] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000</span>
<span class="quote">&gt; &gt; [    0.234000] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400</span>
<span class="quote">&gt; &gt; [    0.234000] Call Trace:</span>
<span class="quote">&gt; &gt; [    0.234000]  ? efi_call+0x58/0x90</span>
<span class="quote">&gt; &gt; [    0.234000]  ? printk+0x58/0x6f</span>
<span class="quote">&gt; &gt; [    0.234000]  efi_enter_virtual_mode+0x3c5/0x50d</span>
<span class="quote">&gt; &gt; [    0.234000]  start_kernel+0x40f/0x4b8</span>
<span class="quote">&gt; &gt; [    0.234000]  ? set_init_arg+0x55/0x55</span>
<span class="quote">&gt; &gt; [    0.234000]  ? early_idt_handler_array+0x120/0x120</span>
<span class="quote">&gt; &gt; [    0.234000]  x86_64_start_reservations+0x24/0x26</span>
<span class="quote">&gt; &gt; [    0.234000]  x86_64_start_kernel+0x14c/0x16f</span>
<span class="quote">&gt; &gt; [    0.234000]  start_cpu+0x14/0x14</span>
<span class="quote">&gt; &gt; [    0.234000] Code:  Bad RIP value.</span>
<span class="quote">&gt; &gt; [    0.234000] RIP: 0x7febd57e RSP: ffffffffafe03d98</span>
<span class="quote">&gt; &gt; [    0.234000] CR2: 000000007febd57e</span>
<span class="quote">&gt; &gt; [    0.234000] ---[ end trace d4ded46ab8ab8ba9 ]---</span>
<span class="quote">&gt; &gt; [    0.234000] Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt; &gt; [    0.234000] ---[ end Kernel panic - not syncing: Attempted to kill the idle task!</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; &gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; &gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; &gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; &gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; &gt; Cc: linux-efi@vger.kernel.org</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt; v1-&gt;v2:</span>
<span class="quote">&gt; &gt;     Change code and add description according to Thomas&#39;s suggestion as below:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;     1. Add checking if pud table is allocated successfully. If not just break</span>
<span class="quote">&gt; &gt;     the for loop.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;     2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;     3. Other minor change</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;  arch/x86/platform/efi/efi_64.c | 72 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt; &gt;  1 file changed, 64 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; index 2ee7694..48de7fd 100644</span>
<span class="quote">&gt; &gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	unsigned long vaddress;</span>
<span class="quote">&gt; &gt; +	unsigned long vaddr, left_vaddr;</span>
<span class="quote">&gt; &gt; +	unsigned int num_entries;</span>
<span class="quote">&gt; &gt;  	pgd_t *save_pgd;</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; -	int pgd;</span>
<span class="quote">&gt; &gt; +	pud_t *pud, *pud_k;</span>
<span class="quote">&gt; &gt; +	int pud_idx;</span>
<span class="quote">&gt; &gt;  	int n_pgds;</span>
<span class="quote">&gt; &gt; +	int i;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt;  		save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; &gt; @@ -88,10 +90,51 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt;  	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt; &gt;  	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; &gt; -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * We try to build 1:1 ident mapping for efi old_map usage. However,</span>
<span class="quote">&gt; &gt; +	 * whether kaslr is enabled or not, PAGE_OFFSET must be PUD_SIZE</span>
<span class="quote">&gt; &gt; +	 * aligned. Given a physical address X, we can copy its pud entry</span>
<span class="quote">&gt; &gt; +	 * of __va(X) to fill in its pud entry of 1:1 mapping since both</span>
<span class="quote">&gt; &gt; +	 * of them relate to the same physical memory position.</span>
<span class="quote">&gt; &gt; +	 *</span>
<span class="quote">&gt; &gt; +	 * And copying those pud entries one by one is inefficient. We copy</span>
<span class="quote">&gt; &gt; +	 * memory. Assume PAGE_OFFSET is not PGDIR_SIZE aligned, say it&#39;s</span>
<span class="quote">&gt; &gt; +	 * 0xffff880080000000, and we have memory bigger than 512G. Then the</span>
<span class="quote">&gt; &gt; +	 * first 512G will cross two pgd entries. We need copy memory twice.</span>
<span class="quote">&gt; &gt; +	 * The 1st pud entry will be in the 3rd slot of pud table, so we copy</span>
<span class="quote">&gt; &gt; +	 * pud[2] to pud[511] of the 1st pud table pointed by the 1st pgd entry</span>
<span class="quote">&gt; &gt; +	 * firstly, then copy pud[0] to pud[1] of the 2nd pud table pointed by</span>
<span class="quote">&gt; &gt; +	 * 2nd pgd entry at the second time.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; n_pgds; i++) {</span>
<span class="quote">&gt; &gt; +		save_pgd[i] = *pgd_offset_k(i * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		vaddr = (unsigned long)__va(i * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * Though it may fail to allocate page in the middle, just</span>
<span class="quote">&gt; &gt; +		 * leave those allocated pages there since 1:1 mapping has</span>
<span class="quote">&gt; &gt; +		 * been built. And efi region could be located there, efi_call</span>
<span class="quote">&gt; &gt; +		 * still can work.</span>
<span class="quote">&gt; &gt; +		 */</span>
<span class="quote">&gt; &gt; +		pud = pud_alloc_one(NULL, 0);</span>
<span class="quote">&gt; &gt; +		if (!pud) {</span>
<span class="quote">&gt; &gt; +			pr_err(&quot;Failed to allocate page for %d-th pud table &quot;</span>
<span class="quote">&gt; &gt; +				&quot;to build 1:1 mapping!\n&quot;, i);</span>
<span class="quote">&gt; &gt; +			break;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		pud_idx = pud_index(vaddr);</span>
<span class="quote">&gt; &gt; +		num_entries = PTRS_PER_PUD - pud_idx;</span>
<span class="quote">&gt; &gt; +		pud_k = pud_offset(pgd_offset_k(vaddr), vaddr);</span>
<span class="quote">&gt; &gt; +		memcpy(pud, pud_k, num_entries);</span>
<span class="quote">&gt; &gt; +		if (pud_idx &gt; 0) {</span>
<span class="quote">&gt; &gt; +			left_vaddr = vaddr + (num_entries * PUD_SIZE);</span>
<span class="quote">&gt; &gt; +			pud_k = pud_offset(pgd_offset_k(left_vaddr),</span>
<span class="quote">&gt; &gt; +					   left_vaddr);</span>
<span class="quote">&gt; &gt; +			memcpy(pud + num_entries, pud_k, pud_idx);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +		pgd_populate(NULL, pgd_offset_k(i * PGDIR_SIZE), pud);</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  out:</span>
<span class="quote">&gt; &gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; &gt; @@ -106,6 +149,8 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt;  	 */</span>
<span class="quote">&gt; &gt;  	int pgd_idx;</span>
<span class="quote">&gt; &gt;  	int nr_pgds;</span>
<span class="quote">&gt; &gt; +	pud_t *pud;</span>
<span class="quote">&gt; &gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt;  		write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; &gt; @@ -115,8 +160,19 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; &gt; +	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; &gt; +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * We need check if the pud table was really allocated</span>
<span class="quote">&gt; &gt; +		 * successfully. Otherwise no need to free.</span>
<span class="quote">&gt; &gt; +		 * */</span>
<span class="quote">&gt; &gt; +		if (pgd_val(*pgd) != pgd_val(save_pgd[pgd_idx])) {</span>
<span class="quote">&gt; &gt; +			pud = (pud_t *)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; &gt; +			pud_free(NULL, pud);</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt;  		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	kfree(save_pgd);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This seems like a lot of code for a really simple problem. Do other</span>
<span class="quote">&gt; 1:1 users require this change? I&#39;m thinking of the realmode trampoline</span>
<span class="quote">&gt; code.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If the SGI folks think this looks OK then I&#39;ll apply it with Thomas&#39;</span>
<span class="quote">&gt; ACK.</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 2ee7694..48de7fd 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -71,11 +71,13 @@</span> <span class="p_context"> static void __init early_code_mapping_set_exec(int executable)</span>
 
 pgd_t * __init efi_call_phys_prolog(void)
 {
<span class="p_del">-	unsigned long vaddress;</span>
<span class="p_add">+	unsigned long vaddr, left_vaddr;</span>
<span class="p_add">+	unsigned int num_entries;</span>
 	pgd_t *save_pgd;
<span class="p_del">-</span>
<span class="p_del">-	int pgd;</span>
<span class="p_add">+	pud_t *pud, *pud_k;</span>
<span class="p_add">+	int pud_idx;</span>
 	int n_pgds;
<span class="p_add">+	int i;</span>
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		save_pgd = (pgd_t *)read_cr3();
<span class="p_chunk">@@ -88,10 +90,51 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);
 
<span class="p_del">-	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="p_del">-		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="p_del">-		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="p_del">-		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We try to build 1:1 ident mapping for efi old_map usage. However,</span>
<span class="p_add">+	 * whether kaslr is enabled or not, PAGE_OFFSET must be PUD_SIZE</span>
<span class="p_add">+	 * aligned. Given a physical address X, we can copy its pud entry</span>
<span class="p_add">+	 * of __va(X) to fill in its pud entry of 1:1 mapping since both</span>
<span class="p_add">+	 * of them relate to the same physical memory position.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * And copying those pud entries one by one is inefficient. We copy</span>
<span class="p_add">+	 * memory. Assume PAGE_OFFSET is not PGDIR_SIZE aligned, say it&#39;s</span>
<span class="p_add">+	 * 0xffff880080000000, and we have memory bigger than 512G. Then the</span>
<span class="p_add">+	 * first 512G will cross two pgd entries. We need copy memory twice.</span>
<span class="p_add">+	 * The 1st pud entry will be in the 3rd slot of pud table, so we copy</span>
<span class="p_add">+	 * pud[2] to pud[511] of the 1st pud table pointed by the 1st pgd entry</span>
<span class="p_add">+	 * firstly, then copy pud[0] to pud[1] of the 2nd pud table pointed by</span>
<span class="p_add">+	 * 2nd pgd entry at the second time.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; n_pgds; i++) {</span>
<span class="p_add">+		save_pgd[i] = *pgd_offset_k(i * PGDIR_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		vaddr = (unsigned long)__va(i * PGDIR_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Though it may fail to allocate page in the middle, just</span>
<span class="p_add">+		 * leave those allocated pages there since 1:1 mapping has</span>
<span class="p_add">+		 * been built. And efi region could be located there, efi_call</span>
<span class="p_add">+		 * still can work.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pud = pud_alloc_one(NULL, 0);</span>
<span class="p_add">+		if (!pud) {</span>
<span class="p_add">+			pr_err(&quot;Failed to allocate page for %d-th pud table &quot;</span>
<span class="p_add">+				&quot;to build 1:1 mapping!\n&quot;, i);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		pud_idx = pud_index(vaddr);</span>
<span class="p_add">+		num_entries = PTRS_PER_PUD - pud_idx;</span>
<span class="p_add">+		pud_k = pud_offset(pgd_offset_k(vaddr), vaddr);</span>
<span class="p_add">+		memcpy(pud, pud_k, num_entries);</span>
<span class="p_add">+		if (pud_idx &gt; 0) {</span>
<span class="p_add">+			left_vaddr = vaddr + (num_entries * PUD_SIZE);</span>
<span class="p_add">+			pud_k = pud_offset(pgd_offset_k(left_vaddr),</span>
<span class="p_add">+					   left_vaddr);</span>
<span class="p_add">+			memcpy(pud + num_entries, pud_k, pud_idx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pgd_populate(NULL, pgd_offset_k(i * PGDIR_SIZE), pud);</span>
 	}
 out:
 	__flush_tlb_all();
<span class="p_chunk">@@ -106,6 +149,8 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	 */
 	int pgd_idx;
 	int nr_pgds;
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pgd_t *pgd;</span>
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		write_cr3((unsigned long)save_pgd);
<span class="p_chunk">@@ -115,8 +160,19 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 
 	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);
 
<span class="p_del">-	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="p_add">+	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="p_add">+		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need check if the pud table was really allocated</span>
<span class="p_add">+		 * successfully. Otherwise no need to free.</span>
<span class="p_add">+		 * */</span>
<span class="p_add">+		if (pgd_val(*pgd) != pgd_val(save_pgd[pgd_idx])) {</span>
<span class="p_add">+			pud = (pud_t *)pgd_page_vaddr(*pgd);</span>
<span class="p_add">+			pud_free(NULL, pud);</span>
<span class="p_add">+		}</span>
 		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);
<span class="p_add">+	}</span>
 
 	kfree(save_pgd);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



