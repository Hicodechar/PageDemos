
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,03/35] nds32: Exception handling - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,03/35] nds32: Exception handling</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=171217">Greentime Hu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 27, 2017, 12:27 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;ab955abb08aa8693201430f61ba2eaeff05a0753.1511785528.git.green.hu@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10076789/mbox/"
   >mbox</a>
|
   <a href="/patch/10076789/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10076789/">/patch/10076789/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DDFD96028E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Nov 2017 12:53:47 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C845428DA6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Nov 2017 12:53:47 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BB4E928DB8; Mon, 27 Nov 2017 12:53:47 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6964528DA6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 27 Nov 2017 12:53:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752322AbdK0Mxn (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 27 Nov 2017 07:53:43 -0500
Received: from mail-pl0-f66.google.com ([209.85.160.66]:37084 &quot;EHLO
	mail-pl0-f66.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752181AbdK0Mxd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 27 Nov 2017 07:53:33 -0500
Received: by mail-pl0-f66.google.com with SMTP id 61so8438098plf.4;
	Mon, 27 Nov 2017 04:53:32 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=from:to:cc:subject:date:message-id:in-reply-to:references
	:in-reply-to:references;
	bh=FrEXLhK1qYvh7dCSdZ/KFbwXH5vKtHkFjuDXEw4oPAk=;
	b=Mv+gPK/3JAgKoDlW9N8p+xOgUb2aOkMIx+2sCXYiZQe1pstE50L09zxD0mhebJKPLD
	95sXgvRfnDMuoWMYHD4w+slUhzHZJdsN/XoLpwJbwNw/YayowJdzqgVzZemvwdJDvyiy
	E2q6ZVrgilC0VW8rNHme9qAcAl4T6ky/L6WdAWwzajneo9a7/6xcDT63D/6etDUKN286
	tWiPpRBnV2mPafY8CgQW5uPONjuFrc+FRvY/QnXqnDC35bApyZUd6qr2tNm7l1M6VVN2
	XcXe7a4WuqUr29MY6cBCzwUmttKTWjMu9PDu7pmkENoRLS/L7ZdDsI8BDwzpyz74BRoo
	P0dg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references:in-reply-to:references;
	bh=FrEXLhK1qYvh7dCSdZ/KFbwXH5vKtHkFjuDXEw4oPAk=;
	b=h8TQrt4rBZ5XAkQmf6Z/AHiBxmQCsLHZJ0mUKm2J3HqCO8jw1o+QQRaC65V3dfT3lL
	P/ilppz/Pta2d3BrJOAAl7tgM0UHKMsT1OKUXT03WswMZjiIY9ef5ibhbcVSG44+tCLe
	vKu7Sg8E3w5MHMHzOmneDLD0rHfGpj71P6so8ikS/kstTBPQDqRpA89iuU9B57Or4Ff7
	+XAaRXT3GeJLZYT5NF1rez9aKlNs0ZY5z7IjzdsrdYiUuN/CHQbSA/mP1FA2NVP73cJ9
	cQm2DVK3PfxPRaCtrVqYGPlUcopO89MXs2P2AHUlrHfHY/gjn1nTCSTqiiJNRU8XFYSh
	+NbQ==
X-Gm-Message-State: AJaThX7areA+BcCBIzlxn4jaPSEIMJieraSS6EK6DbPUeo6ILmRlSul/
	iuOd0k0Oy9I6S0v/5B0O5ms=
X-Google-Smtp-Source: AGs4zMZILSwxznZbgvav2k5ecP4ci4Nple+S1wuZcG4RQ1ab/uEcWO9MicU1slng+zGwmsE6goD3Fw==
X-Received: by 10.84.140.131 with SMTP id 3mr26760649plt.394.1511787211737; 
	Mon, 27 Nov 2017 04:53:31 -0800 (PST)
Received: from app09.andestech.com ([118.163.51.199])
	by smtp.gmail.com with ESMTPSA id
	w64sm55225459pfj.62.2017.11.27.04.53.28
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 27 Nov 2017 04:53:31 -0800 (PST)
From: Greentime Hu &lt;green.hu@gmail.com&gt;
To: greentime@andestech.com, linux-kernel@vger.kernel.org,
	arnd@arndb.de, linux-arch@vger.kernel.org, tglx@linutronix.de,
	jason@lakedaemon.net, marc.zyngier@arm.com, robh+dt@kernel.org,
	netdev@vger.kernel.org, deanbo422@gmail.com,
	devicetree@vger.kernel.org, viro@zeniv.linux.org.uk,
	dhowells@redhat.com, will.deacon@arm.com,
	daniel.lezcano@linaro.org, linux-serial@vger.kernel.org
Cc: green.hu@gmail.com, Vincent Chen &lt;vincentc@andestech.com&gt;
Subject: [PATCH v2 03/35] nds32: Exception handling
Date: Mon, 27 Nov 2017 20:27:50 +0800
Message-Id: &lt;ab955abb08aa8693201430f61ba2eaeff05a0753.1511785528.git.green.hu@gmail.com&gt;
X-Mailer: git-send-email 1.7.9.5
In-Reply-To: &lt;cover.1511785528.git.green.hu@gmail.com&gt;
References: &lt;cover.1511785528.git.green.hu@gmail.com&gt;
In-Reply-To: &lt;cover.1511785528.git.green.hu@gmail.com&gt;
References: &lt;cover.1511785528.git.green.hu@gmail.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=171217">Greentime Hu</a> - Nov. 27, 2017, 12:27 p.m.</div>
<pre class="content">
<span class="from">From: Greentime Hu &lt;greentime@andestech.com&gt;</span>

This patch includes the exception/interrupt entries, pt_reg structure and
related accessors.
<span class="signed-off-by">
Signed-off-by: Vincent Chen &lt;vincentc@andestech.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Greentime Hu &lt;greentime@andestech.com&gt;</span>
---
 arch/nds32/include/asm/ptrace.h |   79 +++++
 arch/nds32/kernel/ex-entry.S    |  170 +++++++++++
 arch/nds32/kernel/ex-exit.S     |  206 +++++++++++++
 arch/nds32/kernel/stacktrace.c  |   60 ++++
 arch/nds32/kernel/traps.c       |  441 +++++++++++++++++++++++++++
 arch/nds32/mm/alignment.c       |  622 +++++++++++++++++++++++++++++++++++++++
 6 files changed, 1578 insertions(+)
 create mode 100644 arch/nds32/include/asm/ptrace.h
 create mode 100644 arch/nds32/kernel/ex-entry.S
 create mode 100644 arch/nds32/kernel/ex-exit.S
 create mode 100644 arch/nds32/kernel/stacktrace.c
 create mode 100644 arch/nds32/kernel/traps.c
 create mode 100644 arch/nds32/mm/alignment.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/nds32/include/asm/ptrace.h b/arch/nds32/include/asm/ptrace.h</span>
new file mode 100644
<span class="p_header">index 0000000..2c9c03d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -0,0 +1,79 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASM_NDS32_PTRACE_H</span>
<span class="p_add">+#define __ASM_NDS32_PTRACE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTRACE_GETREGS		12</span>
<span class="p_add">+#define PTRACE_SETREGS		13</span>
<span class="p_add">+#define PTRACE_GETFPREGS	14</span>
<span class="p_add">+#define PTRACE_SETFPREGS	15</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;uapi/asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+struct pt_regs {</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct user_pt_regs user_regs;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			long uregs[26];</span>
<span class="p_add">+			long fp;</span>
<span class="p_add">+			long gp;</span>
<span class="p_add">+			long lp;</span>
<span class="p_add">+			long sp;</span>
<span class="p_add">+			long ipc;</span>
<span class="p_add">+#if defined(CONFIG_HWZOL)</span>
<span class="p_add">+			long lb;</span>
<span class="p_add">+			long le;</span>
<span class="p_add">+			long lc;</span>
<span class="p_add">+#else</span>
<span class="p_add">+			long dummy[3];</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			long syscallno;</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
<span class="p_add">+	long orig_r0;</span>
<span class="p_add">+	long ir0;</span>
<span class="p_add">+	long ipsw;</span>
<span class="p_add">+	long pipsw;</span>
<span class="p_add">+	long pipc;</span>
<span class="p_add">+	long pp0;</span>
<span class="p_add">+	long pp1;</span>
<span class="p_add">+	long fucop_ctl;</span>
<span class="p_add">+	long osp;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/bitfield.h&gt;</span>
<span class="p_add">+extern void show_regs(struct pt_regs *);</span>
<span class="p_add">+/* Avoid circular header include via sched.h */</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs,</span>
<span class="p_add">+			 int error_code, int si_code);</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_has_single_step()		(1)</span>
<span class="p_add">+#define user_mode(regs)			(((regs)-&gt;ipsw &amp; PSW_mskPOM) == 0)</span>
<span class="p_add">+#define interrupts_enabled(regs)	(!!((regs)-&gt;ipsw &amp; PSW_mskGIE))</span>
<span class="p_add">+#define valid_user_regs(regs)		(user_mode(regs) &amp;&amp; interrupts_enabled(regs))</span>
<span class="p_add">+#define regs_return_value(regs)		((regs)-&gt;uregs[0])</span>
<span class="p_add">+#define instruction_pointer(regs)	((regs)-&gt;ipc)</span>
<span class="p_add">+#define user_stack_pointer(regs)        ((regs)-&gt;sp)</span>
<span class="p_add">+#define profile_pc(regs) 		instruction_pointer(regs)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARCH_HAS_USER_SINGLE_STEP_INFO</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/nds32/kernel/ex-entry.S b/arch/nds32/kernel/ex-entry.S</span>
new file mode 100644
<span class="p_header">index 0000000..09dc6a0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/ex-entry.S</span>
<span class="p_chunk">@@ -0,0 +1,170 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/memory.h&gt;</span>
<span class="p_add">+#include &lt;asm/nds32.h&gt;</span>
<span class="p_add">+#include &lt;asm/errno.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	.macro push_zol</span>
<span class="p_add">+	mfusr	$r14, $LB</span>
<span class="p_add">+	mfusr	$r15, $LE</span>
<span class="p_add">+	mfusr	$r16, $LC</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	save_user_regs</span>
<span class="p_add">+</span>
<span class="p_add">+	smw.adm $sp, [$sp], $sp, #0x1</span>
<span class="p_add">+	/* move $SP to the bottom of pt_regs */</span>
<span class="p_add">+	addi    $sp, $sp, -OSP_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	/* push $r0 ~ $r25 */</span>
<span class="p_add">+	smw.bim $r0, [$sp], $r25</span>
<span class="p_add">+	/* push $fp, $gp, $lp */</span>
<span class="p_add">+	smw.bim $sp, [$sp], $sp, #0xe</span>
<span class="p_add">+</span>
<span class="p_add">+	mfsr	$r12, $SP_USR</span>
<span class="p_add">+	mfsr	$r13, $IPC</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	push_zol</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	movi	$r17, -1</span>
<span class="p_add">+	move	$r18, $r0</span>
<span class="p_add">+	mfsr	$r19, $PSW</span>
<span class="p_add">+	mfsr	$r20, $IPSW</span>
<span class="p_add">+	mfsr	$r21, $P_IPSW</span>
<span class="p_add">+	mfsr	$r22, $P_IPC</span>
<span class="p_add">+	mfsr	$r23, $P_P0</span>
<span class="p_add">+	mfsr	$r24, $P_P1</span>
<span class="p_add">+	smw.bim $r12, [$sp], $r24, #0</span>
<span class="p_add">+	addi	$sp, $sp, -FUCOP_CTL_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize kernel space $fp */</span>
<span class="p_add">+	andi    $p0, $r20, #PSW_mskPOM</span>
<span class="p_add">+	movi    $p1, #0x0</span>
<span class="p_add">+	cmovz   $fp, $p1, $p0</span>
<span class="p_add">+</span>
<span class="p_add">+	andi	$r16, $r19, #PSW_mskINTL</span>
<span class="p_add">+	slti	$r17, $r16, #4</span>
<span class="p_add">+	bnez	$r17, 1f</span>
<span class="p_add">+	addi	$r17, $r19, #-2</span>
<span class="p_add">+	mtsr	$r17, $PSW</span>
<span class="p_add">+	isb</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* If it was superuser mode, we don&#39;t need to update $r25 */</span>
<span class="p_add">+	bnez	$p0, 2f</span>
<span class="p_add">+	la	$p0, __entry_task</span>
<span class="p_add">+	lw	$r25, [$p0]</span>
<span class="p_add">+2:</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Exception Vector</span>
<span class="p_add">+ */</span>
<span class="p_add">+exception_handlers:</span>
<span class="p_add">+	.long	unhandled_exceptions	!Reset/NMI</span>
<span class="p_add">+	.long	unhandled_exceptions	!TLB fill</span>
<span class="p_add">+	.long	do_page_fault		!PTE not present</span>
<span class="p_add">+	.long	do_dispatch_tlb_misc	!TLB misc</span>
<span class="p_add">+	.long	unhandled_exceptions	!TLB VLPT</span>
<span class="p_add">+	.long	unhandled_exceptions	!Machine Error</span>
<span class="p_add">+	.long	do_debug_trap		!Debug related</span>
<span class="p_add">+	.long	do_dispatch_general	!General exception</span>
<span class="p_add">+	.long	eh_syscall		!Syscall</span>
<span class="p_add">+	.long	asm_do_IRQ		!IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+common_exception_handler:</span>
<span class="p_add">+	save_user_regs</span>
<span class="p_add">+	mfsr	$p0, $ITYPE</span>
<span class="p_add">+	andi	$p0, $p0, #ITYPE_mskVECTOR</span>
<span class="p_add">+	srli	$p0, $p0, #ITYPE_offVECTOR</span>
<span class="p_add">+	andi	$p1, $p0, #NDS32_VECTOR_mskNONEXCEPTION</span>
<span class="p_add">+	bnez	$p1, 1f</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_exception)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_exception)</span>
<span class="p_add">+	sethi	$p1, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p1, $p1, lo12(exception_handlers)</span>
<span class="p_add">+	lw	$p1, [$p1+$p0&lt;&lt;2]</span>
<span class="p_add">+	move	$r0, $p0</span>
<span class="p_add">+	mfsr	$r1, $EVA</span>
<span class="p_add">+	mfsr	$r2, $ITYPE</span>
<span class="p_add">+	move	$r3, $sp</span>
<span class="p_add">+	mfsr    $r4, $OIPC</span>
<span class="p_add">+	/* enable gie if it is enabled in IPSW. */</span>
<span class="p_add">+	mfsr	$r21, $PSW</span>
<span class="p_add">+	andi	$r20, $r20, #PSW_mskGIE	/* r20 is $IPSW*/</span>
<span class="p_add">+	or	$r21, $r21, $r20</span>
<span class="p_add">+	mtsr	$r21, $PSW</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	jr	$p1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* syscall */</span>
<span class="p_add">+1:</span>
<span class="p_add">+	addi	$p1, $p0, #-NDS32_VECTOR_offEXCEPTION</span>
<span class="p_add">+	bnez	$p1, 2f</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_exception)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_exception)</span>
<span class="p_add">+	sethi	$p1, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p1, $p1, lo12(exception_handlers)</span>
<span class="p_add">+	lwi	$p1, [$p1+#NDS32_VECTOR_offEXCEPTION&lt;&lt;2]</span>
<span class="p_add">+	jr	$p1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* interrupt */</span>
<span class="p_add">+2:</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	jal     arch_trace_hardirqs_off</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	move	$r0, $sp</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_intr)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_intr)</span>
<span class="p_add">+	sethi	$p0, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p0, $p0, lo12(exception_handlers)</span>
<span class="p_add">+	lwi	$p0, [$p0+#NDS32_VECTOR_offINTERRUPT&lt;&lt;2]</span>
<span class="p_add">+	jr	$p0</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	EXCEPTION_VECTOR_DEBUG</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	mfsr     $p0, $EDM_CTL</span>
<span class="p_add">+	andi     $p0, $p0, EDM_CTL_mskV3_EDM_MODE</span>
<span class="p_add">+	tnez     $p0, SWID_RAISE_INTERRUPT_LEVEL</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	EXCEPTION_VECTOR</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	sethi	 $p0, hi20(common_exception_handler)</span>
<span class="p_add">+	ori	 $p0, $p0, lo12(common_exception_handler)</span>
<span class="p_add">+	jral.ton $p0, $p0</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.section	&quot;.text.init&quot;, #alloc, #execinstr</span>
<span class="p_add">+	.global	exception_vector</span>
<span class="p_add">+exception_vector:</span>
<span class="p_add">+.rept 5</span>
<span class="p_add">+	EXCEPTION_VECTOR</span>
<span class="p_add">+.endr</span>
<span class="p_add">+	EXCEPTION_VECTOR_DEBUG</span>
<span class="p_add">+.rept 122</span>
<span class="p_add">+	EXCEPTION_VECTOR</span>
<span class="p_add">+.endr</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	.global	exception_vector_end</span>
<span class="p_add">+exception_vector_end:</span>
<span class="p_header">diff --git a/arch/nds32/kernel/ex-exit.S b/arch/nds32/kernel/ex-exit.S</span>
new file mode 100644
<span class="p_header">index 0000000..fc60e60</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/ex-exit.S</span>
<span class="p_chunk">@@ -0,0 +1,206 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
<span class="p_add">+#include &lt;asm/nds32.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/current.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	.macro pop_zol</span>
<span class="p_add">+	mtusr	$r14, $LB</span>
<span class="p_add">+	mtusr	$r15, $LE</span>
<span class="p_add">+	mtusr	$r16, $LC</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs_first</span>
<span class="p_add">+	setgie.d</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	addi	$sp, $sp, FUCOP_CTL_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	lmw.adm $r12, [$sp], $r24, #0x0</span>
<span class="p_add">+	mtsr	$r12, $SP_USR</span>
<span class="p_add">+	mtsr	$r13, $IPC</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	pop_zol</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	mtsr	$r19, $PSW</span>
<span class="p_add">+	mtsr	$r20, $IPSW</span>
<span class="p_add">+	mtsr    $r21, $P_IPSW</span>
<span class="p_add">+	mtsr	$r22, $P_IPC</span>
<span class="p_add">+	mtsr	$r23, $P_P0</span>
<span class="p_add">+	mtsr	$r24, $P_P1</span>
<span class="p_add">+	lmw.adm $sp, [$sp], $sp, #0xe</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs_last</span>
<span class="p_add">+	pop	$p0</span>
<span class="p_add">+	cmovn	$sp, $p0, $p0</span>
<span class="p_add">+</span>
<span class="p_add">+	iret</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs</span>
<span class="p_add">+	restore_user_regs_first</span>
<span class="p_add">+	lmw.adm $r0, [$sp], $r25, #0x0</span>
<span class="p_add">+	addi	$sp, $sp, OSP_OFFSET</span>
<span class="p_add">+	restore_user_regs_last</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	fast_restore_user_regs</span>
<span class="p_add">+	restore_user_regs_first</span>
<span class="p_add">+	lmw.adm $r1, [$sp], $r25, #0x0</span>
<span class="p_add">+	addi	$sp, $sp, OSP_OFFSET-4</span>
<span class="p_add">+	restore_user_regs_last</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PREEMPT</span>
<span class="p_add">+	.macro	preempt_stop</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#else</span>
<span class="p_add">+	.macro	preempt_stop</span>
<span class="p_add">+	setgie.d</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#define	resume_kernel	no_work_pending</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_exception)</span>
<span class="p_add">+	preempt_stop</span>
<span class="p_add">+ENTRY(ret_from_intr)</span>
<span class="p_add">+	move	why, #0				! not system call</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * judge Kernel or user mode</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]	! Check if in nested interrupt</span>
<span class="p_add">+	andi	$p0, $p0, #PSW_mskINTL</span>
<span class="p_add">+	bnez	$p0, resume_kernel		! done with iret</span>
<span class="p_add">+	j	resume_userspace</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is the fast syscall return path.  We do as little as</span>
<span class="p_add">+ * possible here, and this includes saving $r0 back into the SVC</span>
<span class="p_add">+ * stack.</span>
<span class="p_add">+ * fixed: tsk - $r25, why - $r8, $r7 - syscall #, $r8 - syscall table pointer</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(ret_fast_syscall)</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_MASK</span>
<span class="p_add">+	bnez	$p1, fast_work_pending</span>
<span class="p_add">+	fast_restore_user_regs			! iret</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ok, we need to do extra processing,</span>
<span class="p_add">+ * enter the slow path returning from syscall, while pending work.</span>
<span class="p_add">+ */</span>
<span class="p_add">+fast_work_pending:</span>
<span class="p_add">+	swi	$r0, [$sp+(#R0_OFFSET)]		! what is different from ret_from_exception</span>
<span class="p_add">+work_pending:</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_NEED_RESCHED</span>
<span class="p_add">+	bnez	$p1, work_resched</span>
<span class="p_add">+</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_SIGPENDING|#_TIF_NOTIFY_RESUME</span>
<span class="p_add">+	beqz	$p1, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	move	$r0, $sp			! &#39;regs&#39;</span>
<span class="p_add">+	move	$r2, why</span>
<span class="p_add">+	gie_enable</span>
<span class="p_add">+	bal	do_notify_resume</span>
<span class="p_add">+	beqz	$r0, ret_slow_syscall</span>
<span class="p_add">+	bgtz	$r0, 1f</span>
<span class="p_add">+	lmw.bi  $r0, [sp], $r5</span>
<span class="p_add">+	movi	$r7, #__NR_restart_syscall</span>
<span class="p_add">+1:</span>
<span class="p_add">+	b	eh_syscall_phase_2</span>
<span class="p_add">+work_resched:</span>
<span class="p_add">+	bal	schedule			! path, return to user mode</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * &quot;slow&quot; syscall return path.</span>
<span class="p_add">+ * &quot;why&quot; tells us if this was a real syscall.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(resume_userspace)</span>
<span class="p_add">+ENTRY(ret_slow_syscall)</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]	! Check if in nested interrupt</span>
<span class="p_add">+	andi	$p0, $p0, #PSW_mskINTL</span>
<span class="p_add">+	bnez	$p0, no_work_pending		! done with iret</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_MASK</span>
<span class="p_add">+	bnez	$p1, work_pending		! handle work_resched, sig_pend</span>
<span class="p_add">+</span>
<span class="p_add">+no_work_pending:</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]</span>
<span class="p_add">+	andi	$p0, $p0, #0x1</span>
<span class="p_add">+	la	$r10, trace_hardirqs_off</span>
<span class="p_add">+	la	$r9, trace_hardirqs_on</span>
<span class="p_add">+	cmovz	$r9, $p0, $r10</span>
<span class="p_add">+	jral	$r9</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	restore_user_regs			! return from iret</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * preemptive kernel</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifdef CONFIG_PREEMPT</span>
<span class="p_add">+resume_kernel:</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$t0, [tsk+#TSK_TI_PREEMPT]</span>
<span class="p_add">+	bnez	$t0, no_work_pending</span>
<span class="p_add">+need_resched:</span>
<span class="p_add">+	lwi	$t0, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $t0, #_TIF_NEED_RESCHED</span>
<span class="p_add">+	beqz	$p1, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	lwi	$t0, [$sp+(#IPSW_OFFSET)]	! Interrupts off?</span>
<span class="p_add">+	andi	$t0, $t0, #1</span>
<span class="p_add">+	beqz	$t0, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	jal	preempt_schedule_irq</span>
<span class="p_add">+	b	need_resched</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is how we return from a fork.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(ret_from_fork)</span>
<span class="p_add">+	bal	schedule_tail</span>
<span class="p_add">+	beqz	$r6, 1f				! r6 stores fn for kernel thread</span>
<span class="p_add">+	move	$r0, $r7			! prepare kernel thread arg</span>
<span class="p_add">+	jral	$r6</span>
<span class="p_add">+1:</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]		! check for syscall tracing</span>
<span class="p_add">+	move	why, #1</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_SYSCALL_LEAVE	! are we tracing syscalls?</span>
<span class="p_add">+	beqz	$p1, ret_slow_syscall</span>
<span class="p_add">+	move    $r0, $sp</span>
<span class="p_add">+	bal	syscall_trace_leave</span>
<span class="p_add">+	b	ret_slow_syscall</span>
<span class="p_header">diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c</span>
new file mode 100644
<span class="p_header">index 0000000..78e816d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -0,0 +1,60 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/stacktrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace(struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	save_stack_trace_tsk(current, trace);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *fpn;</span>
<span class="p_add">+	int skip = trace-&gt;skip;</span>
<span class="p_add">+	int savesched;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tsk == current) {</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(fpn));</span>
<span class="p_add">+		savesched = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		fpn = (unsigned long *)thread_saved_fp(tsk);</span>
<span class="p_add">+		savesched = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!kstack_end(fpn) &amp;&amp; !((unsigned long)fpn &amp; 0x3)</span>
<span class="p_add">+	       &amp;&amp; (fpn &gt;= (unsigned long *)TASK_SIZE)) {</span>
<span class="p_add">+		unsigned long lpp, fpp;</span>
<span class="p_add">+</span>
<span class="p_add">+		lpp = fpn[-1];</span>
<span class="p_add">+		fpp = fpn[FP_OFFSET];</span>
<span class="p_add">+		if (!__kernel_text_address(lpp))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (savesched || !in_sched_functions(lpp)) {</span>
<span class="p_add">+			if (skip) {</span>
<span class="p_add">+				skip--;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				trace-&gt;entries[trace-&gt;nr_entries++] = lpp;</span>
<span class="p_add">+				if (trace-&gt;nr_entries &gt;= trace-&gt;max_entries)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fpn = (unsigned long *)fpp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/nds32/kernel/traps.c b/arch/nds32/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 0000000..1680d29</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,441 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/personality.h&gt;</span>
<span class="p_add">+#include &lt;linux/kallsyms.h&gt;</span>
<span class="p_add">+#include &lt;linux/hardirq.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;nds32_intrinsic.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void show_pte(struct mm_struct *mm, unsigned long addr);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Dump out the contents of some memory nicely...</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dump_mem(const char *lvl, unsigned long bottom, unsigned long top)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long first;</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_add">+	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_add">+	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s(0x%08lx to 0x%08lx)\n&quot;, lvl, bottom, top);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (first = bottom &amp; ~31; first &lt; top; first += 32) {</span>
<span class="p_add">+		unsigned long p;</span>
<span class="p_add">+		char str[sizeof(&quot; 12345678&quot;) * 8 + 1];</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(str, &#39; &#39;, sizeof(str));</span>
<span class="p_add">+		str[sizeof(str) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (p = first, i = 0; i &lt; 8 &amp;&amp; p &lt; top; i++, p += 4) {</span>
<span class="p_add">+			if (p &gt;= bottom &amp;&amp; p &lt; top) {</span>
<span class="p_add">+				unsigned long val;</span>
<span class="p_add">+				if (__get_user(val, (unsigned long *)p) == 0)</span>
<span class="p_add">+					sprintf(str + i * 9, &quot; %08lx&quot;, val);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					sprintf(str + i * 9, &quot; ????????&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pr_emerg(&quot;%s%04lx:%s\n&quot;, lvl, first &amp; 0xffff, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(dump_mem);</span>
<span class="p_add">+</span>
<span class="p_add">+static void dump_instr(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr = instruction_pointer(regs);</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	char str[sizeof(&quot;00000000 &quot;) * 5 + 2 + 1], *p = str;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	return;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_add">+	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_add">+	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;Code: &quot;);</span>
<span class="p_add">+	for (i = -4; i &lt; 1; i++) {</span>
<span class="p_add">+		unsigned int val, bad;</span>
<span class="p_add">+</span>
<span class="p_add">+		bad = __get_user(val, &amp;((u32 *) addr)[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!bad) {</span>
<span class="p_add">+			p += sprintf(p, i == 0 ? &quot;(%08x) &quot; : &quot;%08x &quot;, val);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			p += sprintf(p, &quot;bad PC value&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_emerg(&quot;Code: %s\n&quot;, str);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
<span class="p_add">+static void</span>
<span class="p_add">+get_real_ret_addr(unsigned long *addr, struct task_struct *tsk, int *graph)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (*addr == (unsigned long)return_to_handler) {</span>
<span class="p_add">+		int index = tsk-&gt;curr_ret_stack;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (tsk-&gt;ret_stack &amp;&amp; index &gt;= *graph) {</span>
<span class="p_add">+			index -= *graph;</span>
<span class="p_add">+			*addr = tsk-&gt;ret_stack[index].ret;</span>
<span class="p_add">+			(*graph)++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+get_real_ret_addr(unsigned long *addr, struct task_struct *tsk, int *graph)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define LOOP_TIMES (100)</span>
<span class="p_add">+static void __dump(struct task_struct *tsk, unsigned long *base_reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ret_addr;</span>
<span class="p_add">+	int cnt = LOOP_TIMES, graph = 0;</span>
<span class="p_add">+	pr_emerg(&quot;Call Trace:\n&quot;);</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER)) {</span>
<span class="p_add">+		while (!kstack_end(base_reg)) {</span>
<span class="p_add">+			ret_addr = *base_reg++;</span>
<span class="p_add">+			if (__kernel_text_address(ret_addr)) {</span>
<span class="p_add">+				get_real_ret_addr(&amp;ret_addr, tsk, &amp;graph);</span>
<span class="p_add">+				print_ip_sym(ret_addr);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (--cnt &lt; 0)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		while (!kstack_end((void *)base_reg) &amp;&amp;</span>
<span class="p_add">+		       !((unsigned long)base_reg &amp; 0x3) &amp;&amp;</span>
<span class="p_add">+		       ((unsigned long)base_reg &gt;= TASK_SIZE)) {</span>
<span class="p_add">+			unsigned long next_fp;</span>
<span class="p_add">+#if !defined(NDS32_ABI_2)</span>
<span class="p_add">+			ret_addr = base_reg[0];</span>
<span class="p_add">+			next_fp = base_reg[1];</span>
<span class="p_add">+#else</span>
<span class="p_add">+			ret_addr = base_reg[-1];</span>
<span class="p_add">+			next_fp = base_reg[FP_OFFSET];</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			if (__kernel_text_address(ret_addr)) {</span>
<span class="p_add">+				get_real_ret_addr(&amp;ret_addr, tsk, &amp;graph);</span>
<span class="p_add">+				print_ip_sym(ret_addr);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (--cnt &lt; 0)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		base_reg = (unsigned long *)next_fp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_emerg(&quot;\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void dump_stack(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *base_reg;</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER))</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $sp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	__dump(NULL, base_reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(dump_stack);</span>
<span class="p_add">+</span>
<span class="p_add">+void show_stack(struct task_struct *tsk, unsigned long *sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *base_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER)) {</span>
<span class="p_add">+		if (tsk != current)</span>
<span class="p_add">+			base_reg = (unsigned long *)(tsk-&gt;thread.cpu_context.sp);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__asm__ __volatile__(&quot;\tori\t%0, $sp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (tsk != current)</span>
<span class="p_add">+			base_reg = (unsigned long *)(tsk-&gt;thread.cpu_context.fp);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	__dump(tsk, base_reg);</span>
<span class="p_add">+	barrier();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function is protected against re-entrancy.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void die(const char *str, struct pt_regs *regs, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *tsk = current;</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;Internal error: %s: %x [#%d]\n&quot;, str, err, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	pr_emerg(&quot;CPU: %i\n&quot;, smp_processor_id());</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	pr_emerg(&quot;Process %s (pid: %d, stack limit = 0x%p)\n&quot;,</span>
<span class="p_add">+		 tsk-&gt;comm, tsk-&gt;pid, task_thread_info(tsk) + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!user_mode(regs) || in_interrupt()) {</span>
<span class="p_add">+		dump_mem(&quot;Stack: &quot;, regs-&gt;sp,</span>
<span class="p_add">+			 THREAD_SIZE + (unsigned long)task_thread_info(tsk));</span>
<span class="p_add">+		dump_instr(regs);</span>
<span class="p_add">+		dump_stack();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(die);</span>
<span class="p_add">+</span>
<span class="p_add">+void die_if_kernel(const char *str, struct pt_regs *regs, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	die(str, regs, err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int bad_syscall(int n, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;personality != PER_LINUX) {</span>
<span class="p_add">+		send_sig(SIGSEGV, current, 1);</span>
<span class="p_add">+		return regs-&gt;uregs[0];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = SIGILL;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = ILL_ILLTRP;</span>
<span class="p_add">+	info.si_addr = (void __user *)instruction_pointer(regs) - 4;</span>
<span class="p_add">+</span>
<span class="p_add">+	force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+	die_if_kernel(&quot;Oops - bad syscall&quot;, regs, n);</span>
<span class="p_add">+	return regs-&gt;uregs[0];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pte_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pte %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pmd_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pmd %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pgd_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pgd %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern char *exception_vector, *exception_vector_end;</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init early_trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ivb = 0;</span>
<span class="p_add">+	unsigned long base = PAGE_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy((unsigned long *)base, (unsigned long *)&amp;exception_vector,</span>
<span class="p_add">+	       ((unsigned long)&amp;exception_vector_end -</span>
<span class="p_add">+		(unsigned long)&amp;exception_vector));</span>
<span class="p_add">+	ivb = __nds32__mfsr(NDS32_SR_IVB);</span>
<span class="p_add">+	/* Check platform support. */</span>
<span class="p_add">+	if (((ivb &amp; IVB_mskNIVIC) &gt;&gt; IVB_offNIVIC) &lt; 2)</span>
<span class="p_add">+		panic</span>
<span class="p_add">+		    (&quot;IVIC mode is not allowed on the platform with interrupt controller\n&quot;);</span>
<span class="p_add">+	__nds32__mtsr((ivb &amp; ~IVB_mskESZ) | (IVB_valESZ16 &lt;&lt; IVB_offESZ) |</span>
<span class="p_add">+		      IVB_BASE, NDS32_SR_IVB);</span>
<span class="p_add">+	__nds32__mtsr(INT_MASK_INITAIAL_VAL, NDS32_SR_INT_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 0x800 = 128 vectors * 16byte.</span>
<span class="p_add">+	 * It should be enough to flush a page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	flush_icache_range(base, base + PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_debug_trap(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+		   unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (notify_die(DIE_OOPS, &quot;Oops&quot;, regs, addr, type, SIGTRAP)</span>
<span class="p_add">+	    == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		/* trap_signal */</span>
<span class="p_add">+		send_sigtrap(current, regs, 0, TRAP_BRKPT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* kernel_trap */</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(&quot;unexpected kernel_trap&quot;, regs, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void unhandled_interruption(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;unhandled_interruption\n&quot;);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGKILL);</span>
<span class="p_add">+	si.si_signo = SIGKILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	force_sig_info(SIGKILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void unhandled_exceptions(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			  unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;Unhandled Exception: entry: %lx addr:%lx itype:%lx\n&quot;, entry,</span>
<span class="p_add">+		 addr, type);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGKILL);</span>
<span class="p_add">+	si.si_signo = SIGKILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	si.si_addr = (void *)addr;</span>
<span class="p_add">+	force_sig_info(SIGKILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern int do_page_fault(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			 unsigned int error_code, struct pt_regs *regs);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * 2:DEF dispatch for TLB MISC exception handler</span>
<span class="p_add">+*/</span>
<span class="p_add">+</span>
<span class="p_add">+void do_dispatch_tlb_misc(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			  unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	type = type &amp; (ITYPE_mskINST | ITYPE_mskETYPE);</span>
<span class="p_add">+	if ((type &amp; ITYPE_mskETYPE) &lt; 5) {</span>
<span class="p_add">+		/* Permission exceptions */</span>
<span class="p_add">+		do_page_fault(entry, addr, type, regs);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		unhandled_exceptions(entry, addr, type, regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_revinsn(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;Reserved Instruction\n&quot;);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGILL);</span>
<span class="p_add">+	si.si_signo = SIGILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	force_sig_info(SIGILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ALIGNMENT_TRAP</span>
<span class="p_add">+extern int unalign_access_mode;</span>
<span class="p_add">+extern int do_unaligned_access(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			unsigned long type, struct pt_regs *regs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+void do_dispatch_general(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			 unsigned long itype, struct pt_regs *regs,</span>
<span class="p_add">+			 unsigned long oipc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int swid = itype &gt;&gt; ITYPE_offSWID;</span>
<span class="p_add">+	unsigned long type = itype &amp; (ITYPE_mskINST | ITYPE_mskETYPE);</span>
<span class="p_add">+	if (type == ETYPE_ALIGNMENT_CHECK) {</span>
<span class="p_add">+#ifdef CONFIG_ALIGNMENT_TRAP</span>
<span class="p_add">+		/* Alignment check */</span>
<span class="p_add">+		if (unalign_access_mode &amp; 0x3) {</span>
<span class="p_add">+			int ret;</span>
<span class="p_add">+			ret = do_unaligned_access(entry, addr, type, regs);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret == 0)</span>
<span class="p_add">+				return;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret == -EFAULT)</span>
<span class="p_add">+				pr_emerg</span>
<span class="p_add">+				    (&quot;Unhandled unaligned access exception\n&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		do_page_fault(entry, addr, type, regs);</span>
<span class="p_add">+	} else if (type == ETYPE_RESERVED_INSTRUCTION) {</span>
<span class="p_add">+		/* Reserved instruction */</span>
<span class="p_add">+		do_revinsn(regs);</span>
<span class="p_add">+	} else if (type == ETYPE_TRAP &amp;&amp; swid == SWID_RAISE_INTERRUPT_LEVEL) {</span>
<span class="p_add">+		/* trap, used on v3 EDM target debugging workaround */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * DIPC(OIPC) is passed as parameter before</span>
<span class="p_add">+		 * interrupt is enabled, so the DIPC will not be corrupted</span>
<span class="p_add">+		 * even though interrupts are coming in</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * 1. update ipc</span>
<span class="p_add">+		 * 2. update pt_regs ipc with oipc</span>
<span class="p_add">+		 * 3. update pt_regs ipsw (clear DEX)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__asm__ volatile (&quot;mtsr %0, $IPC\n\t&quot;::&quot;r&quot; (oipc));</span>
<span class="p_add">+		regs-&gt;ipc = oipc;</span>
<span class="p_add">+		if (regs-&gt;pipsw &amp; PSW_mskDEX) {</span>
<span class="p_add">+			pr_emerg</span>
<span class="p_add">+			    (&quot;Nested Debug exception is possibly happened\n&quot;);</span>
<span class="p_add">+			pr_emerg(&quot;ipc:%08x pipc:%08x\n&quot;,</span>
<span class="p_add">+				 (unsigned int)regs-&gt;ipc,</span>
<span class="p_add">+				 (unsigned int)regs-&gt;pipc);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		do_debug_trap(entry, addr, itype, regs);</span>
<span class="p_add">+		regs-&gt;ipsw &amp;= ~PSW_mskDEX;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		unhandled_exceptions(entry, addr, type, regs);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/nds32/mm/alignment.c b/arch/nds32/mm/alignment.c</span>
new file mode 100644
<span class="p_header">index 0000000..19aba59</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/mm/alignment.c</span>
<span class="p_chunk">@@ -0,0 +1,622 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/proc_fs.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/sysctl.h&gt;</span>
<span class="p_add">+#include &lt;asm/unaligned.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DEBUG(enable, tagged, ...)				\</span>
<span class="p_add">+	do{							\</span>
<span class="p_add">+		if (enable) {					\</span>
<span class="p_add">+			if (tagged)				\</span>
<span class="p_add">+			pr_warn(&quot;[ %30s() ] &quot;, __func__);	\</span>
<span class="p_add">+			pr_warn(__VA_ARGS__);			\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RT(inst)	(((inst) &gt;&gt; 20) &amp; 0x1FUL)</span>
<span class="p_add">+#define RA(inst)	(((inst) &gt;&gt; 15) &amp; 0x1FUL)</span>
<span class="p_add">+#define RB(inst)	(((inst) &gt;&gt; 10) &amp; 0x1FUL)</span>
<span class="p_add">+#define SV(inst)	(((inst) &gt;&gt; 8) &amp; 0x3UL)</span>
<span class="p_add">+#define IMM(inst)	(((inst) &gt;&gt; 0) &amp; 0x3FFFUL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RA3(inst)	(((inst) &gt;&gt; 3) &amp; 0x7UL)</span>
<span class="p_add">+#define RT3(inst)	(((inst) &gt;&gt; 6) &amp; 0x7UL)</span>
<span class="p_add">+#define IMM3U(inst)	(((inst) &gt;&gt; 0) &amp; 0x7UL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RA5(inst)	(((inst) &gt;&gt; 0) &amp; 0x1FUL)</span>
<span class="p_add">+#define RT4(inst)	(((inst) &gt;&gt; 5) &amp; 0xFUL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __get8_data(val,addr,err)	\</span>
<span class="p_add">+	__asm__(					\</span>
<span class="p_add">+	&quot;1:	lbi.bi	%1, [%2], #1\n&quot;			\</span>
<span class="p_add">+	&quot;2:\n&quot;						\</span>
<span class="p_add">+	&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+	&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+	&quot;3:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+	&quot;	j	2b\n&quot;				\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+	&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+	&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+	&quot;	.long	1b, 3b\n&quot;			\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+	: &quot;=r&quot; (err), &quot;=&amp;r&quot; (val), &quot;=r&quot; (addr)		\</span>
<span class="p_add">+	: &quot;0&quot; (err), &quot;2&quot; (addr))</span>
<span class="p_add">+</span>
<span class="p_add">+#define get16_data(addr, val_ptr)				\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, v, a = addr;		\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr =  v &lt;&lt; 0;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 8;				\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+		*val_ptr = le16_to_cpu(*val_ptr);		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define get32_data(addr, val_ptr)				\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, v, a = addr;		\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr =  v &lt;&lt; 0;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 8;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 16;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 24;				\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+		*val_ptr = le32_to_cpu(*val_ptr);		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define get_data(addr, val_ptr, len)				\</span>
<span class="p_add">+	if (len == 2)						\</span>
<span class="p_add">+		get16_data(addr, val_ptr);			\</span>
<span class="p_add">+	else							\</span>
<span class="p_add">+		get32_data(addr, val_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define set16_data(addr, val)					\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, *ptr = addr ;		\</span>
<span class="p_add">+		val = le32_to_cpu(val);				\</span>
<span class="p_add">+		__asm__(					\</span>
<span class="p_add">+                &quot;1:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;2:	sbi	%2, [%1]\n&quot;			\</span>
<span class="p_add">+		&quot;3:\n&quot;						\</span>
<span class="p_add">+		&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+		&quot;4:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+		&quot;	j	3b\n&quot;				\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+		&quot;	.long	1b, 4b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	2b, 4b\n&quot;			\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		: &quot;=r&quot; (err), &quot;+r&quot; (ptr), &quot;+r&quot; (val)		\</span>
<span class="p_add">+		: &quot;0&quot; (err)					\</span>
<span class="p_add">+		);						\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define set32_data(addr, val)					\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, *ptr = addr ;		\</span>
<span class="p_add">+		val = le32_to_cpu(val);				\</span>
<span class="p_add">+		__asm__(					\</span>
<span class="p_add">+                &quot;1:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;2:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;3:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;4:	sbi 	%2, [%1]\n&quot;			\</span>
<span class="p_add">+		&quot;5:\n&quot;						\</span>
<span class="p_add">+		&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+		&quot;6:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+		&quot;	j	5b\n&quot;				\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+		&quot;	.long	1b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	2b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	3b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	4b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		: &quot;=r&quot; (err), &quot;+r&quot; (ptr), &quot;+r&quot; (val)		\</span>
<span class="p_add">+		: &quot;0&quot; (err)					\</span>
<span class="p_add">+		);						\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+#define set_data(addr, val, len)				\</span>
<span class="p_add">+	if (len == 2)						\</span>
<span class="p_add">+		set16_data(addr, val);				\</span>
<span class="p_add">+	else							\</span>
<span class="p_add">+		set32_data(addr, val);</span>
<span class="p_add">+extern pte_t va_present(struct mm_struct *mm, unsigned long addr);</span>
<span class="p_add">+extern pte_t va_kernel_present(unsigned long addr);</span>
<span class="p_add">+extern int va_readable(struct pt_regs *regs, unsigned long addr);</span>
<span class="p_add">+extern int va_writable(struct pt_regs *regs, unsigned long addr);</span>
<span class="p_add">+</span>
<span class="p_add">+int unalign_access_mode = 0, unalign_access_debug = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long *idx_to_addr(struct pt_regs *regs, int idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* this should be consistent with ptrace.h */</span>
<span class="p_add">+	if (idx &gt;= 0 &amp;&amp; idx &lt;= 25)	/* R0-R25 */</span>
<span class="p_add">+		return &amp;regs-&gt;uregs[0] + idx;</span>
<span class="p_add">+	else if (idx &gt;= 28 &amp;&amp; idx &lt;= 30)	/* FP, GP, LP */</span>
<span class="p_add">+		return &amp;regs-&gt;fp + (idx - 28);</span>
<span class="p_add">+	else if (idx == 31)	/* SP */</span>
<span class="p_add">+		return &amp;regs-&gt;sp;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return NULL;	/* cause a segfault */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_inst(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(get_unaligned((u32 *) addr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long sign_extend(unsigned long val, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ret = 0;</span>
<span class="p_add">+	unsigned char *s, *t;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = cpu_to_le32(val);</span>
<span class="p_add">+</span>
<span class="p_add">+	s = (void *)&amp;val;</span>
<span class="p_add">+	t = (void *)&amp;ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (i++ &lt; len)</span>
<span class="p_add">+		*t++ = *s++;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((*(t - 1)) &amp; 0x80) &amp;&amp; (i &lt; 4)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		while (i++ &lt;= 4)</span>
<span class="p_add">+			*t++ = 0xff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return le32_to_cpu(ret);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int do_16(unsigned long inst, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int imm, regular, load, len, addr_mode, idx_mode;</span>
<span class="p_add">+	unsigned long unaligned_addr, target_val, source_idx, target_idx,</span>
<span class="p_add">+	    shift = 0;</span>
<span class="p_add">+	switch ((inst &gt;&gt; 9) &amp; 0x3F) {</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x12:		/* LHI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x10:		/* LWI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x11:		/* LWI333.bi */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1A:		/* LWI450    */</span>
<span class="p_add">+		imm = 0;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 5;</span>
<span class="p_add">+		idx_mode = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x16:		/* SHI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x14:		/* SWI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x15:		/* SWI333.bi */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1B:		/* SWI450    */</span>
<span class="p_add">+		imm = 0;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 5;</span>
<span class="p_add">+		idx_mode = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (addr_mode == 3) {</span>
<span class="p_add">+		unaligned_addr = *idx_to_addr(regs, RA3(inst));</span>
<span class="p_add">+		source_idx = RA3(inst);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		unaligned_addr = *idx_to_addr(regs, RA5(inst));</span>
<span class="p_add">+		source_idx = RA5(inst);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (idx_mode == 3)</span>
<span class="p_add">+		target_idx = RT3(inst);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		target_idx = RT4(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (imm)</span>
<span class="p_add">+		shift = IMM3U(inst) * len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regular)</span>
<span class="p_add">+		unaligned_addr += shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (load) {</span>
<span class="p_add">+		if (!access_ok(VERIFY_READ, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		get_data(unaligned_addr,&amp;target_val,len);</span>
<span class="p_add">+		*idx_to_addr(regs, target_idx) = target_val;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+		target_val = *idx_to_addr(regs, target_idx);</span>
<span class="p_add">+		set_data((void *)unaligned_addr, target_val, len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if(!regular)</span>
<span class="p_add">+		*idx_to_addr(regs, source_idx) = unaligned_addr + shift;</span>
<span class="p_add">+	regs-&gt;ipc += 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+fault:</span>
<span class="p_add">+	return -EACCES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int do_32(unsigned long inst, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int imm, regular, load, len, sign_ext;</span>
<span class="p_add">+	unsigned long unaligned_addr, target_val, shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	unaligned_addr = *idx_to_addr(regs, RA(inst));</span>
<span class="p_add">+</span>
<span class="p_add">+	switch ((inst &gt;&gt; 25) &lt;&lt; 1) {</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x02:		/* LHI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x0A:		/* LHI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x22:		/* LHSI      */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x2A:		/* LHSI.bi   */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x04:		/* LWI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x0C:		/* LWI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x12:		/* SHI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1A:		/* SHI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x14:		/* SWI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1C:		/* SWI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		switch (inst &amp; 0xff) {</span>
<span class="p_add">+</span>
<span class="p_add">+		case 0x01:	/* LH        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x05:	/* LH.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x11:	/* LHS       */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x15:	/* LHS.bi    */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x02:	/* LW        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x06:	/* LW.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x09:	/* SH        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0D:	/* SH.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0A:	/* SW        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0E:	/* SW.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (imm)</span>
<span class="p_add">+		shift = IMM(inst) * len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		shift = *idx_to_addr(regs, RB(inst)) &lt;&lt; SV(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regular)</span>
<span class="p_add">+		unaligned_addr += shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (load) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!access_ok(VERIFY_READ, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		get_data(unaligned_addr,&amp;target_val,len);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sign_ext)</span>
<span class="p_add">+			*idx_to_addr(regs, RT(inst)) =</span>
<span class="p_add">+			    sign_extend(target_val, len);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			*idx_to_addr(regs, RT(inst)) = target_val;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		target_val = *idx_to_addr(regs, RT(inst));</span>
<span class="p_add">+		set_data((void *)unaligned_addr, target_val, len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if(!regular)</span>
<span class="p_add">+		*idx_to_addr(regs, RA(inst)) = unaligned_addr + shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	regs-&gt;ipc += 4;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+fault:</span>
<span class="p_add">+	return -EACCES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int do_unaligned_access(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long inst;</span>
<span class="p_add">+	int ret = -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	inst = get_inst(regs-&gt;ipc);</span>
<span class="p_add">+</span>
<span class="p_add">+	DEBUG((unalign_access_debug &gt; 0), 1,</span>
<span class="p_add">+	      &quot;Faulting addr: 0x%08lx, pc: 0x%08lx [inst: 0x%08lx ]\n&quot;</span>
<span class="p_add">+	      &quot;unalign_access_mode: %x\n&quot;</span>
<span class="p_add">+		, addr,regs-&gt;ipc, inst, unalign_access_mode);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((user_mode(regs) &amp;&amp; (unalign_access_mode &amp; 0x01))</span>
<span class="p_add">+	    || (!user_mode(regs) &amp;&amp; (unalign_access_mode &amp; 0x02))) {</span>
<span class="p_add">+</span>
<span class="p_add">+		mm_segment_t seg = get_fs();</span>
<span class="p_add">+</span>
<span class="p_add">+		user_mode(regs)?set_fs(USER_DS):set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (inst &amp; 0x80000000)</span>
<span class="p_add">+		{</span>
<span class="p_add">+			ret = do_16((inst &gt;&gt; 16) &amp; 0xffff, regs);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		else</span>
<span class="p_add">+		{</span>
<span class="p_add">+			ret = do_32(inst, regs);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		set_fs(seg);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static</span>
<span class="p_add">+int unalign_access_policy(struct ctl_table *ctl, int write,</span>
<span class="p_add">+			     void __user * buffer, size_t * lenp, loff_t * ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int val = *(int *)(ctl-&gt;data);</span>
<span class="p_add">+	loff_t pos = *ppos;</span>
<span class="p_add">+	struct ctl_table lctl;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lctl = *ctl;</span>
<span class="p_add">+	lctl.data = &amp;val;</span>
<span class="p_add">+	ret = proc_dointvec(&amp;lctl, write, buffer, lenp, ppos);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		*ppos = pos;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		*(int *)ctl-&gt;data = val;</span>
<span class="p_add">+		if (val &gt; 3)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ctl_table alignment_tbl[3] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.procname = &quot;enable_mode&quot;,</span>
<span class="p_add">+		.data = &amp;unalign_access_mode,</span>
<span class="p_add">+		.maxlen = sizeof(unalign_access_mode),</span>
<span class="p_add">+		.mode = 0666,</span>
<span class="p_add">+		.proc_handler = unalign_access_policy,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.procname	= &quot;debug&quot;,</span>
<span class="p_add">+		.data		= &amp;unalign_access_debug,</span>
<span class="p_add">+		.maxlen		= sizeof(unalign_access_mode),</span>
<span class="p_add">+		.mode		= 0644,</span>
<span class="p_add">+		.proc_handler	= &amp;proc_dointvec</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ctl_table nds32_sysctl_table[2] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .procname = &quot;unaligned_acess&quot;,</span>
<span class="p_add">+	 .mode = 0555,</span>
<span class="p_add">+	 .child = alignment_tbl},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+static struct ctl_path nds32_path[2] = {</span>
<span class="p_add">+	{.procname = &quot;nds32&quot; },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Initialize nds32 alignment-correction interface</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init nds32_sysctl_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	register_sysctl_paths(nds32_path, nds32_sysctl_table);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+__initcall(nds32_sysctl_init);</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



