
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.29 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.29</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 31, 2016, 12:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161031124653.GB31717@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9405445/mbox/"
   >mbox</a>
|
   <a href="/patch/9405445/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9405445/">/patch/9405445/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D387760234 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:30 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C21772918C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:30 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B5F3F29193; Mon, 31 Oct 2016 12:48:30 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F18592918C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S941944AbcJaMsM (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 31 Oct 2016 08:48:12 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:36788 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S941898AbcJaMsF (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 31 Oct 2016 08:48:05 -0400
Received: from localhost (unknown [207.224.144.10])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D589B414;
	Mon, 31 Oct 2016 12:48:03 +0000 (UTC)
Date: Mon, 31 Oct 2016 06:46:53 -0600
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.29
Message-ID: &lt;20161031124653.GB31717@kroah.com&gt;
References: &lt;20161031124645.GA31717@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161031124645.GA31717@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 31, 2016, 12:46 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/x86/exception-tables.txt b/Documentation/x86/exception-tables.txt</span>
<span class="p_header">index 32901aa36f0a..e396bcd8d830 100644</span>
<span class="p_header">--- a/Documentation/x86/exception-tables.txt</span>
<span class="p_header">+++ b/Documentation/x86/exception-tables.txt</span>
<span class="p_chunk">@@ -290,3 +290,38 @@</span> <span class="p_context"> Due to the way that the exception table is built and needs to be ordered,</span>
 only use exceptions for code in the .text section.  Any other section
 will cause the exception table to not be sorted correctly, and the
 exceptions will fail.
<span class="p_add">+</span>
<span class="p_add">+Things changed when 64-bit support was added to x86 Linux. Rather than</span>
<span class="p_add">+double the size of the exception table by expanding the two entries</span>
<span class="p_add">+from 32-bits to 64 bits, a clever trick was used to store addresses</span>
<span class="p_add">+as relative offsets from the table itself. The assembly code changed</span>
<span class="p_add">+from:</span>
<span class="p_add">+	.long 1b,3b</span>
<span class="p_add">+to:</span>
<span class="p_add">+        .long (from) - .</span>
<span class="p_add">+        .long (to) - .</span>
<span class="p_add">+</span>
<span class="p_add">+and the C-code that uses these values converts back to absolute addresses</span>
<span class="p_add">+like this:</span>
<span class="p_add">+</span>
<span class="p_add">+	ex_insn_addr(const struct exception_table_entry *x)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		return (unsigned long)&amp;x-&gt;insn + x-&gt;insn;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+In v4.6 the exception table entry was expanded with a new field &quot;handler&quot;.</span>
<span class="p_add">+This is also 32-bits wide and contains a third relative function</span>
<span class="p_add">+pointer which points to one of:</span>
<span class="p_add">+</span>
<span class="p_add">+1) int ex_handler_default(const struct exception_table_entry *fixup)</span>
<span class="p_add">+   This is legacy case that just jumps to the fixup code</span>
<span class="p_add">+2) int ex_handler_fault(const struct exception_table_entry *fixup)</span>
<span class="p_add">+   This case provides the fault number of the trap that occurred at</span>
<span class="p_add">+   entry-&gt;insn. It is used to distinguish page faults from machine</span>
<span class="p_add">+   check.</span>
<span class="p_add">+3) int ex_handler_ext(const struct exception_table_entry *fixup)</span>
<span class="p_add">+   This case is used for uaccess_err ... we need to set a flag</span>
<span class="p_add">+   in the task structure. Before the handler functions existed this</span>
<span class="p_add">+   case was handled by adding a large offset to the fixup to tag</span>
<span class="p_add">+   it as special.</span>
<span class="p_add">+More functions can easily be added.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 391294301aaf..19d7d9f68e35 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 28</span>
<span class="p_add">+SUBLEVEL = 29</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/crypto/ghash-ce-glue.c b/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_header">index 03a39fe29246..9d9ba9acdddc 100644</span>
<span class="p_header">--- a/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_chunk">@@ -226,6 +226,27 @@</span> <span class="p_context"> static int ghash_async_digest(struct ahash_request *req)</span>
 	}
 }
 
<span class="p_add">+static int ghash_async_import(struct ahash_request *req, const void *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ahash_request *cryptd_req = ahash_request_ctx(req);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+	struct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(cryptd_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	desc-&gt;tfm = cryptd_ahash_child(ctx-&gt;cryptd_tfm);</span>
<span class="p_add">+	desc-&gt;flags = req-&gt;base.flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_import(desc, in);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ghash_async_export(struct ahash_request *req, void *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ahash_request *cryptd_req = ahash_request_ctx(req);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(cryptd_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_export(desc, out);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ghash_async_setkey(struct crypto_ahash *tfm, const u8 *key,
 			      unsigned int keylen)
 {
<span class="p_chunk">@@ -274,7 +295,10 @@</span> <span class="p_context"> static struct ahash_alg ghash_async_alg = {</span>
 	.final			= ghash_async_final,
 	.setkey			= ghash_async_setkey,
 	.digest			= ghash_async_digest,
<span class="p_add">+	.import			= ghash_async_import,</span>
<span class="p_add">+	.export			= ghash_async_export,</span>
 	.halg.digestsize	= GHASH_DIGEST_SIZE,
<span class="p_add">+	.halg.statesize		= sizeof(struct ghash_desc_ctx),</span>
 	.halg.base		= {
 		.cra_name	= &quot;ghash&quot;,
 		.cra_driver_name = &quot;ghash-ce&quot;,
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa_cplds_irqs.c b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_header">index 2385052b0ce1..e362f865fcd2 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_chunk">@@ -41,30 +41,35 @@</span> <span class="p_context"> static irqreturn_t cplds_irq_handler(int in_irq, void *d)</span>
 	unsigned long pending;
 	unsigned int bit;
 
<span class="p_del">-	pending = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR) &amp; fpga-&gt;irq_mask;</span>
<span class="p_del">-	for_each_set_bit(bit, &amp;pending, CPLDS_NB_IRQ)</span>
<span class="p_del">-		generic_handle_irq(irq_find_mapping(fpga-&gt;irqdomain, bit));</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		pending = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR) &amp; fpga-&gt;irq_mask;</span>
<span class="p_add">+		for_each_set_bit(bit, &amp;pending, CPLDS_NB_IRQ) {</span>
<span class="p_add">+			generic_handle_irq(irq_find_mapping(fpga-&gt;irqdomain,</span>
<span class="p_add">+							    bit));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pending);</span>
 
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static void cplds_irq_mask_ack(struct irq_data *d)</span>
<span class="p_add">+static void cplds_irq_mask(struct irq_data *d)</span>
 {
 	struct cplds *fpga = irq_data_get_irq_chip_data(d);
 	unsigned int cplds_irq = irqd_to_hwirq(d);
<span class="p_del">-	unsigned int set, bit = BIT(cplds_irq);</span>
<span class="p_add">+	unsigned int bit = BIT(cplds_irq);</span>
 
 	fpga-&gt;irq_mask &amp;= ~bit;
 	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);
<span class="p_del">-	set = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_del">-	writel(set &amp; ~bit, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
 }
 
 static void cplds_irq_unmask(struct irq_data *d)
 {
 	struct cplds *fpga = irq_data_get_irq_chip_data(d);
 	unsigned int cplds_irq = irqd_to_hwirq(d);
<span class="p_del">-	unsigned int bit = BIT(cplds_irq);</span>
<span class="p_add">+	unsigned int set, bit = BIT(cplds_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	set = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_add">+	writel(set &amp; ~bit, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
 
 	fpga-&gt;irq_mask |= bit;
 	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);
<span class="p_chunk">@@ -72,7 +77,8 @@</span> <span class="p_context"> static void cplds_irq_unmask(struct irq_data *d)</span>
 
 static struct irq_chip cplds_irq_chip = {
 	.name		= &quot;pxa_cplds&quot;,
<span class="p_del">-	.irq_mask_ack	= cplds_irq_mask_ack,</span>
<span class="p_add">+	.irq_ack	= cplds_irq_mask,</span>
<span class="p_add">+	.irq_mask	= cplds_irq_mask,</span>
 	.irq_unmask	= cplds_irq_unmask,
 	.flags		= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE,
 };
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index 247a0dc012f1..c07bfb52275e 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -909,6 +909,14 @@</span> <span class="p_context"> static void eeh_handle_special_event(void)</span>
 				/* Notify all devices to be down */
 				eeh_pe_state_clear(pe, EEH_PE_PRI_BUS);
 				bus = eeh_pe_bus_get(phb_pe);
<span class="p_add">+				if (!bus) {</span>
<span class="p_add">+					pr_err(&quot;%s: Cannot find PCI bus for &quot;</span>
<span class="p_add">+					       &quot;PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+					       __func__,</span>
<span class="p_add">+					       pe-&gt;phb-&gt;global_number,</span>
<span class="p_add">+					       pe-&gt;addr);</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 				eeh_pe_dev_traverse(pe,
 					eeh_report_failure, NULL);
 				pcibios_remove_pci_devices(bus);
<span class="p_header">diff --git a/arch/powerpc/kernel/nvram_64.c b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">index 32e26526f7e4..1eb698f653b4 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_chunk">@@ -969,7 +969,7 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 
 		/* Make partition a free partition */
 		part-&gt;header.signature = NVRAM_SIG_FREE;
<span class="p_del">-		strncpy(part-&gt;header.name, &quot;wwwwwwwwwwww&quot;, 12);</span>
<span class="p_add">+		memset(part-&gt;header.name, &#39;w&#39;, 12);</span>
 		part-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);
 		rc = nvram_write_header(part);
 		if (rc &lt;= 0) {
<span class="p_chunk">@@ -987,8 +987,8 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 		}
 		if (prev) {
 			prev-&gt;header.length += part-&gt;header.length;
<span class="p_del">-			prev-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);</span>
<span class="p_del">-			rc = nvram_write_header(part);</span>
<span class="p_add">+			prev-&gt;header.checksum = nvram_checksum(&amp;prev-&gt;header);</span>
<span class="p_add">+			rc = nvram_write_header(prev);</span>
 			if (rc &lt;= 0) {
 				printk(KERN_ERR &quot;nvram_remove_partition: nvram_write failed (%d)\n&quot;, rc);
 				return rc;
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">index ba0cae69a396..92736851c795 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_chunk">@@ -956,6 +956,11 @@</span> <span class="p_context"> static int pnv_eeh_reset(struct eeh_pe *pe, int option)</span>
 		}
 
 		bus = eeh_pe_bus_get(pe);
<span class="p_add">+		if (!bus) {</span>
<span class="p_add">+			pr_err(&quot;%s: Cannot find PCI bus for PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+			       __func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr);</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+		}</span>
 		if (pci_is_root_bus(bus) ||
 			pci_is_root_bus(bus-&gt;parent))
 			ret = pnv_eeh_root_reset(hose, option);
<span class="p_header">diff --git a/arch/x86/include/asm/asm.h b/arch/x86/include/asm/asm.h</span>
<span class="p_header">index 189679aba703..f5063b6659eb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/asm.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/asm.h</span>
<span class="p_chunk">@@ -44,19 +44,22 @@</span> <span class="p_context"></span>
 
 /* Exception table entry */
 #ifdef __ASSEMBLY__
<span class="p_del">-# define _ASM_EXTABLE(from,to)					\</span>
<span class="p_add">+# define _ASM_EXTABLE_HANDLE(from, to, handler)			\</span>
 	.pushsection &quot;__ex_table&quot;,&quot;a&quot; ;				\
<span class="p_del">-	.balign 8 ;						\</span>
<span class="p_add">+	.balign 4 ;						\</span>
 	.long (from) - . ;					\
 	.long (to) - . ;					\
<span class="p_add">+	.long (handler) - . ;					\</span>
 	.popsection
 
<span class="p_del">-# define _ASM_EXTABLE_EX(from,to)				\</span>
<span class="p_del">-	.pushsection &quot;__ex_table&quot;,&quot;a&quot; ;				\</span>
<span class="p_del">-	.balign 8 ;						\</span>
<span class="p_del">-	.long (from) - . ;					\</span>
<span class="p_del">-	.long (to) - . + 0x7ffffff0 ;				\</span>
<span class="p_del">-	.popsection</span>
<span class="p_add">+# define _ASM_EXTABLE(from, to)					\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_default)</span>
<span class="p_add">+</span>
<span class="p_add">+# define _ASM_EXTABLE_FAULT(from, to)				\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_fault)</span>
<span class="p_add">+</span>
<span class="p_add">+# define _ASM_EXTABLE_EX(from, to)				\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_ext)</span>
 
 # define _ASM_NOKPROBE(entry)					\
 	.pushsection &quot;_kprobe_blacklist&quot;,&quot;aw&quot; ;			\
<span class="p_chunk">@@ -89,19 +92,24 @@</span> <span class="p_context"></span>
 	.endm
 
 #else
<span class="p_del">-# define _ASM_EXTABLE(from,to)					\</span>
<span class="p_add">+# define _EXPAND_EXTABLE_HANDLE(x) #x</span>
<span class="p_add">+# define _ASM_EXTABLE_HANDLE(from, to, handler)			\</span>
 	&quot; .pushsection \&quot;__ex_table\&quot;,\&quot;a\&quot;\n&quot;			\
<span class="p_del">-	&quot; .balign 8\n&quot;						\</span>
<span class="p_add">+	&quot; .balign 4\n&quot;						\</span>
 	&quot; .long (&quot; #from &quot;) - .\n&quot;				\
 	&quot; .long (&quot; #to &quot;) - .\n&quot;				\
<span class="p_add">+	&quot; .long (&quot; _EXPAND_EXTABLE_HANDLE(handler) &quot;) - .\n&quot;	\</span>
 	&quot; .popsection\n&quot;
 
<span class="p_del">-# define _ASM_EXTABLE_EX(from,to)				\</span>
<span class="p_del">-	&quot; .pushsection \&quot;__ex_table\&quot;,\&quot;a\&quot;\n&quot;			\</span>
<span class="p_del">-	&quot; .balign 8\n&quot;						\</span>
<span class="p_del">-	&quot; .long (&quot; #from &quot;) - .\n&quot;				\</span>
<span class="p_del">-	&quot; .long (&quot; #to &quot;) - . + 0x7ffffff0\n&quot;			\</span>
<span class="p_del">-	&quot; .popsection\n&quot;</span>
<span class="p_add">+# define _ASM_EXTABLE(from, to)					\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_default)</span>
<span class="p_add">+</span>
<span class="p_add">+# define _ASM_EXTABLE_FAULT(from, to)				\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_fault)</span>
<span class="p_add">+</span>
<span class="p_add">+# define _ASM_EXTABLE_EX(from, to)				\</span>
<span class="p_add">+	_ASM_EXTABLE_HANDLE(from, to, ex_handler_ext)</span>
<span class="p_add">+</span>
 /* For C file, we already have NOKPROBE_SYMBOL macro */
 #endif
 
<span class="p_header">diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">index d42252ce9b4d..3794c7331cfc 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -90,12 +90,11 @@</span> <span class="p_context"> static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, un</span>
 	likely(!__range_not_ok(addr, size, user_addr_max()))
 
 /*
<span class="p_del">- * The exception table consists of pairs of addresses relative to the</span>
<span class="p_del">- * exception table enty itself: the first is the address of an</span>
<span class="p_del">- * instruction that is allowed to fault, and the second is the address</span>
<span class="p_del">- * at which the program should continue.  No registers are modified,</span>
<span class="p_del">- * so it is entirely up to the continuation code to figure out what to</span>
<span class="p_del">- * do.</span>
<span class="p_add">+ * The exception table consists of triples of addresses relative to the</span>
<span class="p_add">+ * exception table entry itself. The first address is of an instruction</span>
<span class="p_add">+ * that is allowed to fault, the second is the target at which the program</span>
<span class="p_add">+ * should continue. The third is a handler function to deal with the fault</span>
<span class="p_add">+ * caused by the instruction in the first field.</span>
  *
  * All the routines below use bits of fixup code that are out of line
  * with the main instruction path.  This means when everything is well,
<span class="p_chunk">@@ -104,13 +103,14 @@</span> <span class="p_context"> static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, un</span>
  */
 
 struct exception_table_entry {
<span class="p_del">-	int insn, fixup;</span>
<span class="p_add">+	int insn, fixup, handler;</span>
 };
 /* This is not the generic standard exception_table_entry format */
 #define ARCH_HAS_SORT_EXTABLE
 #define ARCH_HAS_SEARCH_EXTABLE
 
<span class="p_del">-extern int fixup_exception(struct pt_regs *regs);</span>
<span class="p_add">+extern int fixup_exception(struct pt_regs *regs, int trapnr);</span>
<span class="p_add">+extern bool ex_has_fault_handler(unsigned long ip);</span>
 extern int early_fixup_exception(unsigned long *ip);
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index 9fdf1d330727..a257d6077d1b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -331,12 +331,11 @@</span> <span class="p_context"> static u32 __init i85x_stolen_base(int num, int slot, int func, size_t stolen_si</span>
 
 static u32 __init i865_stolen_base(int num, int slot, int func, size_t stolen_size)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * FIXME is the graphics stolen memory region</span>
<span class="p_del">-	 * always at TOUD? Ie. is it always the last</span>
<span class="p_del">-	 * one to be allocated by the BIOS?</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return read_pci_config_16(0, 0, 0, I865_TOUD) &lt;&lt; 16;</span>
<span class="p_add">+	u16 toud = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	toud = read_pci_config_16(0, 0, 0, I865_TOUD);</span>
<span class="p_add">+</span>
<span class="p_add">+	return (phys_addr_t)(toud &lt;&lt; 16) + i845_tseg_size();</span>
 }
 
 static size_t __init i830_stolen_size(int num, int slot, int func)
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index 023c442c33bb..e1d1f6cbaf11 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -1000,7 +1000,7 @@</span> <span class="p_context"> int kprobe_fault_handler(struct pt_regs *regs, int trapnr)</span>
 		 * In case the user-specified fault handler returned
 		 * zero, try to fix up.
 		 */
<span class="p_del">-		if (fixup_exception(regs))</span>
<span class="p_add">+		if (fixup_exception(regs, trapnr))</span>
 			return 1;
 
 		/*
<span class="p_header">diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c</span>
<span class="p_header">index 679302c312f8..5621f882645e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/traps.c</span>
<span class="p_header">+++ b/arch/x86/kernel/traps.c</span>
<span class="p_chunk">@@ -199,7 +199,7 @@</span> <span class="p_context"> do_trap_no_signal(struct task_struct *tsk, int trapnr, char *str,</span>
 	}
 
 	if (!user_mode(regs)) {
<span class="p_del">-		if (!fixup_exception(regs)) {</span>
<span class="p_add">+		if (!fixup_exception(regs, trapnr)) {</span>
 			tsk-&gt;thread.error_code = error_code;
 			tsk-&gt;thread.trap_nr = trapnr;
 			die(str, regs, error_code);
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> do_general_protection(struct pt_regs *regs, long error_code)</span>
 
 	tsk = current;
 	if (!user_mode(regs)) {
<span class="p_del">-		if (fixup_exception(regs))</span>
<span class="p_add">+		if (fixup_exception(regs, X86_TRAP_GP))</span>
 			return;
 
 		tsk-&gt;thread.error_code = error_code;
<span class="p_chunk">@@ -699,7 +699,7 @@</span> <span class="p_context"> static void math_error(struct pt_regs *regs, int error_code, int trapnr)</span>
 	conditional_sti(regs);
 
 	if (!user_mode(regs)) {
<span class="p_del">-		if (!fixup_exception(regs)) {</span>
<span class="p_add">+		if (!fixup_exception(regs, trapnr)) {</span>
 			task-&gt;thread.error_code = error_code;
 			task-&gt;thread.trap_nr = trapnr;
 			die(str, regs, error_code);
<span class="p_header">diff --git a/arch/x86/mm/extable.c b/arch/x86/mm/extable.c</span>
<span class="p_header">index 903ec1e9c326..9dd7e4b7fcde 100644</span>
<span class="p_header">--- a/arch/x86/mm/extable.c</span>
<span class="p_header">+++ b/arch/x86/mm/extable.c</span>
<span class="p_chunk">@@ -3,6 +3,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/sort.h&gt;
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+typedef bool (*ex_handler_t)(const struct exception_table_entry *,</span>
<span class="p_add">+			    struct pt_regs *, int);</span>
<span class="p_add">+</span>
 static inline unsigned long
 ex_insn_addr(const struct exception_table_entry *x)
 {
<span class="p_chunk">@@ -13,11 +16,56 @@</span> <span class="p_context"> ex_fixup_addr(const struct exception_table_entry *x)</span>
 {
 	return (unsigned long)&amp;x-&gt;fixup + x-&gt;fixup;
 }
<span class="p_add">+static inline ex_handler_t</span>
<span class="p_add">+ex_fixup_handler(const struct exception_table_entry *x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (ex_handler_t)((unsigned long)&amp;x-&gt;handler + x-&gt;handler);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-int fixup_exception(struct pt_regs *regs)</span>
<span class="p_add">+bool ex_handler_default(const struct exception_table_entry *fixup,</span>
<span class="p_add">+		       struct pt_regs *regs, int trapnr)</span>
 {
<span class="p_del">-	const struct exception_table_entry *fixup;</span>
<span class="p_del">-	unsigned long new_ip;</span>
<span class="p_add">+	regs-&gt;ip = ex_fixup_addr(fixup);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(ex_handler_default);</span>
<span class="p_add">+</span>
<span class="p_add">+bool ex_handler_fault(const struct exception_table_entry *fixup,</span>
<span class="p_add">+		     struct pt_regs *regs, int trapnr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;ip = ex_fixup_addr(fixup);</span>
<span class="p_add">+	regs-&gt;ax = trapnr;</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(ex_handler_fault);</span>
<span class="p_add">+</span>
<span class="p_add">+bool ex_handler_ext(const struct exception_table_entry *fixup,</span>
<span class="p_add">+		   struct pt_regs *regs, int trapnr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Special hack for uaccess_err */</span>
<span class="p_add">+	current_thread_info()-&gt;uaccess_err = 1;</span>
<span class="p_add">+	regs-&gt;ip = ex_fixup_addr(fixup);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(ex_handler_ext);</span>
<span class="p_add">+</span>
<span class="p_add">+bool ex_has_fault_handler(unsigned long ip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct exception_table_entry *e;</span>
<span class="p_add">+	ex_handler_t handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	e = search_exception_tables(ip);</span>
<span class="p_add">+	if (!e)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	handler = ex_fixup_handler(e);</span>
<span class="p_add">+</span>
<span class="p_add">+	return handler == ex_handler_fault;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int fixup_exception(struct pt_regs *regs, int trapnr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct exception_table_entry *e;</span>
<span class="p_add">+	ex_handler_t handler;</span>
 
 #ifdef CONFIG_PNPBIOS
 	if (unlikely(SEGMENT_IS_PNP_CODE(regs-&gt;cs))) {
<span class="p_chunk">@@ -33,42 +81,34 @@</span> <span class="p_context"> int fixup_exception(struct pt_regs *regs)</span>
 	}
 #endif
 
<span class="p_del">-	fixup = search_exception_tables(regs-&gt;ip);</span>
<span class="p_del">-	if (fixup) {</span>
<span class="p_del">-		new_ip = ex_fixup_addr(fixup);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (fixup-&gt;fixup - fixup-&gt;insn &gt;= 0x7ffffff0 - 4) {</span>
<span class="p_del">-			/* Special hack for uaccess_err */</span>
<span class="p_del">-			current_thread_info()-&gt;uaccess_err = 1;</span>
<span class="p_del">-			new_ip -= 0x7ffffff0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		regs-&gt;ip = new_ip;</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	e = search_exception_tables(regs-&gt;ip);</span>
<span class="p_add">+	if (!e)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	handler = ex_fixup_handler(e);</span>
<span class="p_add">+	return handler(e, regs, trapnr);</span>
 }
 
 /* Restricted version used during very early boot */
 int __init early_fixup_exception(unsigned long *ip)
 {
<span class="p_del">-	const struct exception_table_entry *fixup;</span>
<span class="p_add">+	const struct exception_table_entry *e;</span>
 	unsigned long new_ip;
<span class="p_add">+	ex_handler_t handler;</span>
 
<span class="p_del">-	fixup = search_exception_tables(*ip);</span>
<span class="p_del">-	if (fixup) {</span>
<span class="p_del">-		new_ip = ex_fixup_addr(fixup);</span>
<span class="p_add">+	e = search_exception_tables(*ip);</span>
<span class="p_add">+	if (!e)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-		if (fixup-&gt;fixup - fixup-&gt;insn &gt;= 0x7ffffff0 - 4) {</span>
<span class="p_del">-			/* uaccess handling not supported during early boot */</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	new_ip  = ex_fixup_addr(e);</span>
<span class="p_add">+	handler = ex_fixup_handler(e);</span>
 
<span class="p_del">-		*ip = new_ip;</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* special handling not supported during early boot */</span>
<span class="p_add">+	if (handler != ex_handler_default)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	*ip = new_ip;</span>
<span class="p_add">+	return 1;</span>
 }
 
 /*
<span class="p_chunk">@@ -133,6 +173,8 @@</span> <span class="p_context"> void sort_extable(struct exception_table_entry *start,</span>
 		i += 4;
 		p-&gt;fixup += i;
 		i += 4;
<span class="p_add">+		p-&gt;handler += i;</span>
<span class="p_add">+		i += 4;</span>
 	}
 
 	sort(start, finish - start, sizeof(struct exception_table_entry),
<span class="p_chunk">@@ -145,6 +187,8 @@</span> <span class="p_context"> void sort_extable(struct exception_table_entry *start,</span>
 		i += 4;
 		p-&gt;fixup -= i;
 		i += 4;
<span class="p_add">+		p-&gt;handler -= i;</span>
<span class="p_add">+		i += 4;</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c</span>
<span class="p_header">index e830c71a1323..03898aea6e0f 100644</span>
<span class="p_header">--- a/arch/x86/mm/fault.c</span>
<span class="p_header">+++ b/arch/x86/mm/fault.c</span>
<span class="p_chunk">@@ -663,7 +663,7 @@</span> <span class="p_context"> no_context(struct pt_regs *regs, unsigned long error_code,</span>
 	int sig;
 
 	/* Are we prepared to handle this kernel fault? */
<span class="p_del">-	if (fixup_exception(regs)) {</span>
<span class="p_add">+	if (fixup_exception(regs, X86_TRAP_PF)) {</span>
 		/*
 		 * Any interrupt that takes a fault gets the fixup. This makes
 		 * the below recursive fault logic only apply to a faults from
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index d9ea5f9c0574..1238b3c5a321 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,</span>
 	struct crypto_ablkcipher *ctr = ctx-&gt;ctr;
 	struct {
 		be128 hash;
<span class="p_del">-		u8 iv[8];</span>
<span class="p_add">+		u8 iv[16];</span>
 
 		struct crypto_gcm_setkey_result result;
 
<span class="p_header">diff --git a/drivers/char/hw_random/omap-rng.c b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">index 01d4be2c354b..f5c26a5f6875 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_chunk">@@ -385,7 +385,7 @@</span> <span class="p_context"> static int omap_rng_probe(struct platform_device *pdev)</span>
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
 	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);
 		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 		goto err_ioremap;
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> static int __maybe_unused omap_rng_resume(struct device *dev)</span>
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		dev_err(dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);
 		pm_runtime_put_noidle(dev);
 		return ret;
<span class="p_header">diff --git a/drivers/clk/clk-divider.c b/drivers/clk/clk-divider.c</span>
<span class="p_header">index bbf206e3da0d..ac9582de64a5 100644</span>
<span class="p_header">--- a/drivers/clk/clk-divider.c</span>
<span class="p_header">+++ b/drivers/clk/clk-divider.c</span>
<span class="p_chunk">@@ -354,7 +354,7 @@</span> <span class="p_context"> static long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,</span>
 
 	/* if read only, just return current value */
 	if (divider-&gt;flags &amp; CLK_DIVIDER_READ_ONLY) {
<span class="p_del">-		bestdiv = readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
<span class="p_add">+		bestdiv = clk_readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
 		bestdiv &amp;= div_mask(divider-&gt;width);
 		bestdiv = _get_div(divider-&gt;table, bestdiv, divider-&gt;flags,
 			divider-&gt;width);
<span class="p_header">diff --git a/drivers/clk/clk-qoriq.c b/drivers/clk/clk-qoriq.c</span>
<span class="p_header">index 7bc1c4527ae4..8b77abb6bc22 100644</span>
<span class="p_header">--- a/drivers/clk/clk-qoriq.c</span>
<span class="p_header">+++ b/drivers/clk/clk-qoriq.c</span>
<span class="p_chunk">@@ -766,7 +766,11 @@</span> <span class="p_context"> static struct clk * __init create_one_cmux(struct clockgen *cg, int idx)</span>
 	if (!hwc)
 		return NULL;
 
<span class="p_del">-	hwc-&gt;reg = cg-&gt;regs + 0x20 * idx;</span>
<span class="p_add">+	if (cg-&gt;info.flags &amp; CG_VER3)</span>
<span class="p_add">+		hwc-&gt;reg = cg-&gt;regs + 0x70000 + 0x20 * idx;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		hwc-&gt;reg = cg-&gt;regs + 0x20 * idx;</span>
<span class="p_add">+</span>
 	hwc-&gt;info = cg-&gt;info.cmux_groups[cg-&gt;info.cmux_to_group[idx]];
 
 	/*
<span class="p_header">diff --git a/drivers/clk/imx/clk-imx35.c b/drivers/clk/imx/clk-imx35.c</span>
<span class="p_header">index b0978d3b83e2..d302ed3b8225 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-imx35.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-imx35.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static void __init _mx35_clocks_init(void)</span>
 	}
 
 	clk[ckih] = imx_clk_fixed(&quot;ckih&quot;, 24000000);
<span class="p_del">-	clk[ckil] = imx_clk_fixed(&quot;ckih&quot;, 32768);</span>
<span class="p_add">+	clk[ckil] = imx_clk_fixed(&quot;ckil&quot;, 32768);</span>
 	clk[mpll] = imx_clk_pllv1(IMX_PLLV1_IMX35, &quot;mpll&quot;, &quot;ckih&quot;, base + MX35_CCM_MPCTL);
 	clk[ppll] = imx_clk_pllv1(IMX_PLLV1_IMX35, &quot;ppll&quot;, &quot;ckih&quot;, base + MX35_CCM_PPCTL);
 
<span class="p_header">diff --git a/drivers/dma/ipu/ipu_irq.c b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">index 2bf37e68ad0f..dd184b50e5b4 100644</span>
<span class="p_header">--- a/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">+++ b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_chunk">@@ -286,22 +286,21 @@</span> <span class="p_context"> static void ipu_irq_handler(struct irq_desc *desc)</span>
 		raw_spin_unlock(&amp;bank_lock);
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
<span class="p_del">-			unsigned int irq = NO_IRQ;</span>
<span class="p_add">+			unsigned int irq;</span>
 
 			line--;
 			status &amp;= ~(1UL &lt;&lt; line);
 
 			raw_spin_lock(&amp;bank_lock);
 			map = src2map(32 * i + line);
<span class="p_del">-			if (map)</span>
<span class="p_del">-				irq = map-&gt;irq;</span>
<span class="p_del">-			raw_spin_unlock(&amp;bank_lock);</span>
<span class="p_del">-</span>
 			if (!map) {
<span class="p_add">+				raw_spin_unlock(&amp;bank_lock);</span>
 				pr_err(&quot;IPU: Interrupt on unmapped source %u bank %d\n&quot;,
 				       line, i);
 				continue;
 			}
<span class="p_add">+			irq = map-&gt;irq;</span>
<span class="p_add">+			raw_spin_unlock(&amp;bank_lock);</span>
 			generic_handle_irq(irq);
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">index fe36caf1b7d7..14f57d9915e3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_chunk">@@ -113,24 +113,26 @@</span> <span class="p_context"> void amdgpu_dpm_print_ps_status(struct amdgpu_device *adev,</span>
 	printk(&quot;\n&quot;);
 }
 
<span class="p_add">+</span>
 u32 amdgpu_dpm_get_vblank_time(struct amdgpu_device *adev)
 {
 	struct drm_device *dev = adev-&gt;ddev;
 	struct drm_crtc *crtc;
 	struct amdgpu_crtc *amdgpu_crtc;
<span class="p_del">-	u32 line_time_us, vblank_lines;</span>
<span class="p_add">+	u32 vblank_in_pixels;</span>
 	u32 vblank_time_us = 0xffffffff; /* if the displays are off, vblank time is max */
 
 	if (adev-&gt;mode_info.num_crtc &amp;&amp; adev-&gt;mode_info.mode_config_initialized) {
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			amdgpu_crtc = to_amdgpu_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				line_time_us = (amdgpu_crtc-&gt;hw_mode.crtc_htotal * 1000) /</span>
<span class="p_del">-					amdgpu_crtc-&gt;hw_mode.clock;</span>
<span class="p_del">-				vblank_lines = amdgpu_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_add">+				vblank_in_pixels =</span>
<span class="p_add">+					amdgpu_crtc-&gt;hw_mode.crtc_htotal *</span>
<span class="p_add">+					(amdgpu_crtc-&gt;hw_mode.crtc_vblank_end -</span>
 					amdgpu_crtc-&gt;hw_mode.crtc_vdisplay +
<span class="p_del">-					(amdgpu_crtc-&gt;v_border * 2);</span>
<span class="p_del">-				vblank_time_us = vblank_lines * line_time_us;</span>
<span class="p_add">+					(amdgpu_crtc-&gt;v_border * 2));</span>
<span class="p_add">+</span>
<span class="p_add">+				vblank_time_us = vblank_in_pixels * 1000 / amdgpu_crtc-&gt;hw_mode.clock;</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">index 4488e82f87b0..a5c824078472 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"> static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file</span>
 			type = AMD_IP_BLOCK_TYPE_UVD;
 			ring_mask = adev-&gt;uvd.ring.ready ? 1 : 0;
 			ib_start_alignment = AMDGPU_GPU_PAGE_SIZE;
<span class="p_del">-			ib_size_alignment = 8;</span>
<span class="p_add">+			ib_size_alignment = 16;</span>
 			break;
 		case AMDGPU_HW_IP_VCE:
 			type = AMD_IP_BLOCK_TYPE_VCE;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">index 4dcc8fba5792..5b261adb4b69 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_chunk">@@ -419,16 +419,6 @@</span> <span class="p_context"> static void dce_v10_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			idx = 0;
<span class="p_chunk">@@ -452,6 +442,19 @@</span> <span class="p_context"> static void dce_v10_0_hpd_init(struct amdgpu_device *adev)</span>
 			continue;
 		}
 
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = RREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx]);</span>
<span class="p_add">+			tmp = REG_SET_FIELD(tmp, DC_HPD_INT_CONTROL, DC_HPD_INT_EN, 0);</span>
<span class="p_add">+			WREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx], tmp);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		tmp = RREG32(mmDC_HPD_CONTROL + hpd_offsets[idx]);
 		tmp = REG_SET_FIELD(tmp, DC_HPD_CONTROL, DC_HPD_EN, 1);
 		WREG32(mmDC_HPD_CONTROL + hpd_offsets[idx], tmp);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">index 8f1e51128b33..c161eeda417b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_chunk">@@ -409,16 +409,6 @@</span> <span class="p_context"> static void dce_v11_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			idx = 0;
<span class="p_chunk">@@ -442,6 +432,19 @@</span> <span class="p_context"> static void dce_v11_0_hpd_init(struct amdgpu_device *adev)</span>
 			continue;
 		}
 
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = RREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx]);</span>
<span class="p_add">+			tmp = REG_SET_FIELD(tmp, DC_HPD_INT_CONTROL, DC_HPD_INT_EN, 0);</span>
<span class="p_add">+			WREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx], tmp);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		tmp = RREG32(mmDC_HPD_CONTROL + hpd_offsets[idx]);
 		tmp = REG_SET_FIELD(tmp, DC_HPD_CONTROL, DC_HPD_EN, 1);
 		WREG32(mmDC_HPD_CONTROL + hpd_offsets[idx], tmp);
<span class="p_chunk">@@ -3030,6 +3033,7 @@</span> <span class="p_context"> static int dce_v11_0_sw_fini(void *handle)</span>
 
 	dce_v11_0_afmt_fini(adev);
 
<span class="p_add">+	drm_mode_config_cleanup(adev-&gt;ddev);</span>
 	adev-&gt;mode_info.mode_config_initialized = false;
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">index 42d954dc436d..9b4dcf76ce6c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_chunk">@@ -392,15 +392,6 @@</span> <span class="p_context"> static void dce_v8_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			WREG32(mmDC_HPD1_CONTROL, tmp);
<span class="p_chunk">@@ -423,6 +414,45 @@</span> <span class="p_context"> static void dce_v8_0_hpd_init(struct amdgpu_device *adev)</span>
 		default:
 			break;
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			u32 dc_hpd_int_cntl_reg, dc_hpd_int_cntl;</span>
<span class="p_add">+</span>
<span class="p_add">+			switch (amdgpu_connector-&gt;hpd.hpd) {</span>
<span class="p_add">+			case AMDGPU_HPD_1:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD1_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_2:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD2_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_3:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD3_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_4:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD4_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_5:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD5_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_6:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD6_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			default:</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			dc_hpd_int_cntl = RREG32(dc_hpd_int_cntl_reg);</span>
<span class="p_add">+			dc_hpd_int_cntl &amp;= ~DC_HPD1_INT_CONTROL__DC_HPD1_INT_EN_MASK;</span>
<span class="p_add">+			WREG32(dc_hpd_int_cntl_reg, dc_hpd_int_cntl);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		dce_v8_0_hpd_set_polarity(adev, amdgpu_connector-&gt;hpd.hpd);
 		amdgpu_irq_get(adev, &amp;adev-&gt;hpd_irq, amdgpu_connector-&gt;hpd.hpd);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_prime.c b/drivers/gpu/drm/drm_prime.c</span>
<span class="p_header">index 9f935f55d74c..968b31f39884 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_prime.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_prime.c</span>
<span class="p_chunk">@@ -339,14 +339,17 @@</span> <span class="p_context"> static const struct dma_buf_ops drm_gem_prime_dmabuf_ops =  {</span>
  * using the PRIME helpers.
  */
 struct dma_buf *drm_gem_prime_export(struct drm_device *dev,
<span class="p_del">-				     struct drm_gem_object *obj, int flags)</span>
<span class="p_add">+				     struct drm_gem_object *obj,</span>
<span class="p_add">+				     int flags)</span>
 {
<span class="p_del">-	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);</span>
<span class="p_del">-</span>
<span class="p_del">-	exp_info.ops = &amp;drm_gem_prime_dmabuf_ops;</span>
<span class="p_del">-	exp_info.size = obj-&gt;size;</span>
<span class="p_del">-	exp_info.flags = flags;</span>
<span class="p_del">-	exp_info.priv = obj;</span>
<span class="p_add">+	struct dma_buf_export_info exp_info = {</span>
<span class="p_add">+		.exp_name = KBUILD_MODNAME, /* white lie for debug */</span>
<span class="p_add">+		.owner = dev-&gt;driver-&gt;fops-&gt;owner,</span>
<span class="p_add">+		.ops = &amp;drm_gem_prime_dmabuf_ops,</span>
<span class="p_add">+		.size = obj-&gt;size,</span>
<span class="p_add">+		.flags = flags,</span>
<span class="p_add">+		.priv = obj,</span>
<span class="p_add">+	};</span>
 
 	if (dev-&gt;driver-&gt;gem_prime_res_obj)
 		exp_info.resv = dev-&gt;driver-&gt;gem_prime_res_obj(obj);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index d400d6773bbb..fb9f647bb5cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -2150,21 +2150,19 @@</span> <span class="p_context"> struct drm_i915_gem_object {</span>
 	/** Record of address bit 17 of each page at last unbind. */
 	unsigned long *bit_17;
 
<span class="p_del">-	union {</span>
<span class="p_del">-		/** for phy allocated objects */</span>
<span class="p_del">-		struct drm_dma_handle *phys_handle;</span>
<span class="p_del">-</span>
<span class="p_del">-		struct i915_gem_userptr {</span>
<span class="p_del">-			uintptr_t ptr;</span>
<span class="p_del">-			unsigned read_only :1;</span>
<span class="p_del">-			unsigned workers :4;</span>
<span class="p_add">+	struct i915_gem_userptr {</span>
<span class="p_add">+		uintptr_t ptr;</span>
<span class="p_add">+		unsigned read_only :1;</span>
<span class="p_add">+		unsigned workers :4;</span>
 #define I915_GEM_USERPTR_MAX_WORKERS 15
 
<span class="p_del">-			struct i915_mm_struct *mm;</span>
<span class="p_del">-			struct i915_mmu_object *mmu_object;</span>
<span class="p_del">-			struct work_struct *work;</span>
<span class="p_del">-		} userptr;</span>
<span class="p_del">-	};</span>
<span class="p_add">+		struct i915_mm_struct *mm;</span>
<span class="p_add">+		struct i915_mmu_object *mmu_object;</span>
<span class="p_add">+		struct work_struct *work;</span>
<span class="p_add">+	} userptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/** for phys allocated objects */</span>
<span class="p_add">+	struct drm_dma_handle *phys_handle;</span>
 };
 #define to_intel_bo(x) container_of(x, struct drm_i915_gem_object, base)
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_stolen.c b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">index 87e919a06b27..5d2323a40c25 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_chunk">@@ -108,17 +108,28 @@</span> <span class="p_context"> static unsigned long i915_stolen_to_physical(struct drm_device *dev)</span>
 		pci_read_config_dword(dev-&gt;pdev, 0x5c, &amp;base);
 		base &amp;= ~((1&lt;&lt;20) - 1);
 	} else if (IS_I865G(dev)) {
<span class="p_add">+		u32 tseg_size = 0;</span>
 		u16 toud = 0;
<span class="p_add">+		u8 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_bus_read_config_byte(dev-&gt;pdev-&gt;bus, PCI_DEVFN(0, 0),</span>
<span class="p_add">+					 I845_ESMRAMC, &amp;tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (tmp &amp; TSEG_ENABLE) {</span>
<span class="p_add">+			switch (tmp &amp; I845_TSEG_SIZE_MASK) {</span>
<span class="p_add">+			case I845_TSEG_SIZE_512K:</span>
<span class="p_add">+				tseg_size = KB(512);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case I845_TSEG_SIZE_1M:</span>
<span class="p_add">+				tseg_size = MB(1);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * FIXME is the graphics stolen memory region</span>
<span class="p_del">-		 * always at TOUD? Ie. is it always the last</span>
<span class="p_del">-		 * one to be allocated by the BIOS?</span>
<span class="p_del">-		 */</span>
 		pci_bus_read_config_word(dev-&gt;pdev-&gt;bus, PCI_DEVFN(0, 0),
 					 I865_TOUD, &amp;toud);
 
<span class="p_del">-		base = toud &lt;&lt; 16;</span>
<span class="p_add">+		base = (toud &lt;&lt; 16) + tseg_size;</span>
 	} else if (IS_I85X(dev)) {
 		u32 tseg_size = 0;
 		u32 tom;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index ebbd23407a80..0f8367da0663 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -4648,7 +4648,7 @@</span> <span class="p_context"> static bool bxt_digital_port_connected(struct drm_i915_private *dev_priv,</span>
  *
  * Return %true if @port is connected, %false otherwise.
  */
<span class="p_del">-bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+static bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
 					 struct intel_digital_port *port)
 {
 	if (HAS_PCH_IBX(dev_priv))
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index 41442e619595..722aa159cd28 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -1231,8 +1231,6 @@</span> <span class="p_context"> void intel_edp_drrs_disable(struct intel_dp *intel_dp);</span>
 void intel_edp_drrs_invalidate(struct drm_device *dev,
 		unsigned frontbuffer_bits);
 void intel_edp_drrs_flush(struct drm_device *dev, unsigned frontbuffer_bits);
<span class="p_del">-bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-					 struct intel_digital_port *port);</span>
 void hsw_dp_set_ddi_pll_sel(struct intel_crtc_state *pipe_config);
 
 /* intel_dp_mst.c */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_hdmi.c b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">index dff69fef47e0..3b92cad8bef2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_chunk">@@ -1331,19 +1331,18 @@</span> <span class="p_context"> intel_hdmi_unset_edid(struct drm_connector *connector)</span>
 }
 
 static bool
<span class="p_del">-intel_hdmi_set_edid(struct drm_connector *connector, bool force)</span>
<span class="p_add">+intel_hdmi_set_edid(struct drm_connector *connector)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;dev);
 	struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);
<span class="p_del">-	struct edid *edid = NULL;</span>
<span class="p_add">+	struct edid *edid;</span>
 	bool connected = false;
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);
 
<span class="p_del">-	if (force)</span>
<span class="p_del">-		edid = drm_get_edid(connector,</span>
<span class="p_del">-				    intel_gmbus_get_adapter(dev_priv,</span>
<span class="p_del">-				    intel_hdmi-&gt;ddc_bus));</span>
<span class="p_add">+	edid = drm_get_edid(connector,</span>
<span class="p_add">+			    intel_gmbus_get_adapter(dev_priv,</span>
<span class="p_add">+			    intel_hdmi-&gt;ddc_bus));</span>
 
 	intel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS);
 
<span class="p_chunk">@@ -1371,37 +1370,16 @@</span> <span class="p_context"> static enum drm_connector_status</span>
 intel_hdmi_detect(struct drm_connector *connector, bool force)
 {
 	enum drm_connector_status status;
<span class="p_del">-	struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);</span>
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;dev);
<span class="p_del">-	bool live_status = false;</span>
<span class="p_del">-	unsigned int try;</span>
 
 	DRM_DEBUG_KMS(&quot;[CONNECTOR:%d:%s]\n&quot;,
 		      connector-&gt;base.id, connector-&gt;name);
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);
 
<span class="p_del">-	for (try = 0; !live_status &amp;&amp; try &lt; 9; try++) {</span>
<span class="p_del">-		if (try)</span>
<span class="p_del">-			msleep(10);</span>
<span class="p_del">-		live_status = intel_digital_port_connected(dev_priv,</span>
<span class="p_del">-				hdmi_to_dig_port(intel_hdmi));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!live_status) {</span>
<span class="p_del">-		DRM_DEBUG_KMS(&quot;HDMI live status down\n&quot;);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Live status register is not reliable on all intel platforms.</span>
<span class="p_del">-		 * So consider live_status only for certain platforms, for</span>
<span class="p_del">-		 * others, read EDID to determine presence of sink.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (INTEL_INFO(dev_priv)-&gt;gen &lt; 7 || IS_IVYBRIDGE(dev_priv))</span>
<span class="p_del">-			live_status = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	intel_hdmi_unset_edid(connector);
 
<span class="p_del">-	if (intel_hdmi_set_edid(connector, live_status)) {</span>
<span class="p_add">+	if (intel_hdmi_set_edid(connector)) {</span>
 		struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);
 
 		hdmi_to_dig_port(intel_hdmi)-&gt;base.type = INTEL_OUTPUT_HDMI;
<span class="p_chunk">@@ -1427,7 +1405,7 @@</span> <span class="p_context"> intel_hdmi_force(struct drm_connector *connector)</span>
 	if (connector-&gt;status != connector_status_connected)
 		return;
 
<span class="p_del">-	intel_hdmi_set_edid(connector, true);</span>
<span class="p_add">+	intel_hdmi_set_edid(connector);</span>
 	hdmi_to_dig_port(intel_hdmi)-&gt;base.type = INTEL_OUTPUT_HDMI;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 1e851e037c29..3f802163f7d4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2097,32 +2097,34 @@</span> <span class="p_context"> static void intel_read_wm_latency(struct drm_device *dev, uint16_t wm[8])</span>
 				GEN9_MEM_LATENCY_LEVEL_MASK;
 
 		/*
<span class="p_add">+		 * If a level n (n &gt; 1) has a 0us latency, all levels m (m &gt;= n)</span>
<span class="p_add">+		 * need to be disabled. We make sure to sanitize the values out</span>
<span class="p_add">+		 * of the punit to satisfy this requirement.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (level = 1; level &lt;= max_level; level++) {</span>
<span class="p_add">+			if (wm[level] == 0) {</span>
<span class="p_add">+				for (i = level + 1; i &lt;= max_level; i++)</span>
<span class="p_add">+					wm[i] = 0;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
 		 * WaWmMemoryReadLatency:skl
 		 *
 		 * punit doesn&#39;t take into account the read latency so we need
<span class="p_del">-		 * to add 2us to the various latency levels we retrieve from</span>
<span class="p_del">-		 * the punit.</span>
<span class="p_del">-		 *   - W0 is a bit special in that it&#39;s the only level that</span>
<span class="p_del">-		 *   can&#39;t be disabled if we want to have display working, so</span>
<span class="p_del">-		 *   we always add 2us there.</span>
<span class="p_del">-		 *   - For levels &gt;=1, punit returns 0us latency when they are</span>
<span class="p_del">-		 *   disabled, so we respect that and don&#39;t add 2us then</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Additionally, if a level n (n &gt; 1) has a 0us latency, all</span>
<span class="p_del">-		 * levels m (m &gt;= n) need to be disabled. We make sure to</span>
<span class="p_del">-		 * sanitize the values out of the punit to satisfy this</span>
<span class="p_del">-		 * requirement.</span>
<span class="p_add">+		 * to add 2us to the various latency levels we retrieve from the</span>
<span class="p_add">+		 * punit when level 0 response data us 0us.</span>
 		 */
<span class="p_del">-		wm[0] += 2;</span>
<span class="p_del">-		for (level = 1; level &lt;= max_level; level++)</span>
<span class="p_del">-			if (wm[level] != 0)</span>
<span class="p_add">+		if (wm[0] == 0) {</span>
<span class="p_add">+			wm[0] += 2;</span>
<span class="p_add">+			for (level = 1; level &lt;= max_level; level++) {</span>
<span class="p_add">+				if (wm[level] == 0)</span>
<span class="p_add">+					break;</span>
 				wm[level] += 2;
<span class="p_del">-			else {</span>
<span class="p_del">-				for (i = level + 1; i &lt;= max_level; i++)</span>
<span class="p_del">-					wm[i] = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-				break;</span>
 			}
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		uint64_t sskpd = I915_READ64(MCH_SSKPD);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">index fa2154493cf1..470af4aa4a6a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_chunk">@@ -156,19 +156,20 @@</span> <span class="p_context"> u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)</span>
 	struct drm_device *dev = rdev-&gt;ddev;
 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
<span class="p_del">-	u32 line_time_us, vblank_lines;</span>
<span class="p_add">+	u32 vblank_in_pixels;</span>
 	u32 vblank_time_us = 0xffffffff; /* if the displays are off, vblank time is max */
 
 	if (rdev-&gt;num_crtc &amp;&amp; rdev-&gt;mode_info.mode_config_initialized) {
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			radeon_crtc = to_radeon_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				line_time_us = (radeon_crtc-&gt;hw_mode.crtc_htotal * 1000) /</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.clock;</span>
<span class="p_del">-				vblank_lines = radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_del">-					(radeon_crtc-&gt;v_border * 2);</span>
<span class="p_del">-				vblank_time_us = vblank_lines * line_time_us;</span>
<span class="p_add">+				vblank_in_pixels =</span>
<span class="p_add">+					radeon_crtc-&gt;hw_mode.crtc_htotal *</span>
<span class="p_add">+					(radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_add">+					 radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_add">+					 (radeon_crtc-&gt;v_border * 2));</span>
<span class="p_add">+</span>
<span class="p_add">+				vblank_time_us = vblank_in_pixels * 1000 / radeon_crtc-&gt;hw_mode.clock;</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index e2dd5d19c32c..4aa2cbe4c85f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -660,8 +660,9 @@</span> <span class="p_context"> bool radeon_card_posted(struct radeon_device *rdev)</span>
 {
 	uint32_t reg;
 
<span class="p_del">-	/* for pass through, always force asic_init */</span>
<span class="p_del">-	if (radeon_device_is_virtual())</span>
<span class="p_add">+	/* for pass through, always force asic_init for CI */</span>
<span class="p_add">+	if (rdev-&gt;family &gt;= CHIP_BONAIRE &amp;&amp;</span>
<span class="p_add">+	    radeon_device_is_virtual())</span>
 		return false;
 
 	/* required for EFI mode on macbook2,1 which uses an r5xx asic */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 3aaa07dafc00..472e0771832e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -4112,7 +4112,7 @@</span> <span class="p_context"> static int si_populate_smc_voltage_tables(struct radeon_device *rdev,</span>
 							      &amp;rdev-&gt;pm.dpm.dyn_state.phase_shedding_limits_table)) {
 				si_populate_smc_voltage_table(rdev, &amp;si_pi-&gt;vddc_phase_shed_table, table);
 
<span class="p_del">-				table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC] =</span>
<span class="p_add">+				table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING] =</span>
 					cpu_to_be32(si_pi-&gt;vddc_phase_shed_table.mask_low);
 
 				si_write_smc_soft_register(rdev, SI_SMC_SOFT_REGISTER_phase_shedding_delay,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/sislands_smc.h b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">index 3c779838d9ab..966e3a556011 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_chunk">@@ -194,6 +194,7 @@</span> <span class="p_context"> typedef struct SISLANDS_SMC_SWSTATE SISLANDS_SMC_SWSTATE;</span>
 #define SISLANDS_SMC_VOLTAGEMASK_VDDC  0
 #define SISLANDS_SMC_VOLTAGEMASK_MVDD  1
 #define SISLANDS_SMC_VOLTAGEMASK_VDDCI 2
<span class="p_add">+#define SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING 3</span>
 #define SISLANDS_SMC_VOLTAGEMASK_MAX   4
 
 struct SISLANDS_SMC_VOLTAGEMASKTABLE
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index 4948c1529836..ecf15cf0c3fd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -3830,14 +3830,14 @@</span> <span class="p_context"> static void *vmw_execbuf_cmdbuf(struct vmw_private *dev_priv,</span>
 	int ret;
 
 	*header = NULL;
<span class="p_del">-	if (!dev_priv-&gt;cman || kernel_commands)</span>
<span class="p_del">-		return kernel_commands;</span>
<span class="p_del">-</span>
 	if (command_size &gt; SVGA_CB_MAX_SIZE) {
 		DRM_ERROR(&quot;Command buffer is too large.\n&quot;);
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_add">+	if (!dev_priv-&gt;cman || kernel_commands)</span>
<span class="p_add">+		return kernel_commands;</span>
<span class="p_add">+</span>
 	/* If possible, add a little space for fencing. */
 	cmdbuf_size = command_size + 512;
 	cmdbuf_size = min_t(size_t, cmdbuf_size, SVGA_CB_MAX_SIZE);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index 71493d2af912..70a6985334d5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -4102,7 +4102,7 @@</span> <span class="p_context"> brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,</span>
 				(u8 *)&amp;settings-&gt;beacon.head[ie_offset],
 				settings-&gt;beacon.head_len - ie_offset,
 				WLAN_EID_SSID);
<span class="p_del">-		if (!ssid_ie)</span>
<span class="p_add">+		if (!ssid_ie || ssid_ie-&gt;len &gt; IEEE80211_MAX_SSID_LEN)</span>
 			return -EINVAL;
 
 		memcpy(ssid_le.SSID, ssid_ie-&gt;data, ssid_ie-&gt;len);
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/join.c b/drivers/net/wireless/mwifiex/join.c</span>
<span class="p_header">index 3cda1f956f0b..6378dfd3b4e8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/join.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/join.c</span>
<span class="p_chunk">@@ -661,9 +661,8 @@</span> <span class="p_context"> int mwifiex_ret_802_11_associate(struct mwifiex_private *priv,</span>
 	priv-&gt;assoc_rsp_size = min(le16_to_cpu(resp-&gt;size) - S_DS_GEN,
 				   sizeof(priv-&gt;assoc_rsp_buf));
 
<span class="p_del">-	memcpy(priv-&gt;assoc_rsp_buf, &amp;resp-&gt;params, priv-&gt;assoc_rsp_size);</span>
<span class="p_del">-</span>
 	assoc_rsp-&gt;a_id = cpu_to_le16(aid);
<span class="p_add">+	memcpy(priv-&gt;assoc_rsp_buf, &amp;resp-&gt;params, priv-&gt;assoc_rsp_size);</span>
 
 	if (status_code) {
 		priv-&gt;adapter-&gt;dbg.num_cmd_assoc_failure++;
<span class="p_header">diff --git a/drivers/power/bq24257_charger.c b/drivers/power/bq24257_charger.c</span>
<span class="p_header">index 1fea2c7ef97f..6fc31bdc639b 100644</span>
<span class="p_header">--- a/drivers/power/bq24257_charger.c</span>
<span class="p_header">+++ b/drivers/power/bq24257_charger.c</span>
<span class="p_chunk">@@ -1068,6 +1068,12 @@</span> <span class="p_context"> static int bq24257_probe(struct i2c_client *client,</span>
 		return ret;
 	}
 
<span class="p_add">+	ret = bq24257_power_supply_init(bq);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to register power supply\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = devm_request_threaded_irq(dev, client-&gt;irq, NULL,
 					bq24257_irq_handler_thread,
 					IRQF_TRIGGER_FALLING |
<span class="p_chunk">@@ -1078,12 +1084,6 @@</span> <span class="p_context"> static int bq24257_probe(struct i2c_client *client,</span>
 		return ret;
 	}
 
<span class="p_del">-	ret = bq24257_power_supply_init(bq);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(dev, &quot;Failed to register power supply\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = sysfs_create_group(&amp;bq-&gt;charger-&gt;dev.kobj, &amp;bq24257_attr_group);
 	if (ret &lt; 0) {
 		dev_err(dev, &quot;Can&#39;t create sysfs entries\n&quot;);
<span class="p_header">diff --git a/drivers/s390/char/con3270.c b/drivers/s390/char/con3270.c</span>
<span class="p_header">index 7c511add5aa7..bae98521c808 100644</span>
<span class="p_header">--- a/drivers/s390/char/con3270.c</span>
<span class="p_header">+++ b/drivers/s390/char/con3270.c</span>
<span class="p_chunk">@@ -124,7 +124,12 @@</span> <span class="p_context"> con3270_create_status(struct con3270 *cp)</span>
 static void
 con3270_update_string(struct con3270 *cp, struct string *s, int nr)
 {
<span class="p_del">-	if (s-&gt;len &gt;= cp-&gt;view.cols - 5)</span>
<span class="p_add">+	if (s-&gt;len &lt; 4) {</span>
<span class="p_add">+		/* This indicates a bug, but printing a warning would</span>
<span class="p_add">+		 * cause a deadlock. */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (s-&gt;string[s-&gt;len - 4] != TO_RA)</span>
 		return;
 	raw3270_buffer_address(cp-&gt;view.dev, s-&gt;string + s-&gt;len - 3,
 			       cp-&gt;view.cols * (nr + 1));
<span class="p_chunk">@@ -461,11 +466,11 @@</span> <span class="p_context"> con3270_cline_end(struct con3270 *cp)</span>
 		cp-&gt;cline-&gt;len + 4 : cp-&gt;view.cols;
 	s = con3270_alloc_string(cp, size);
 	memcpy(s-&gt;string, cp-&gt;cline-&gt;string, cp-&gt;cline-&gt;len);
<span class="p_del">-	if (s-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
<span class="p_add">+	if (cp-&gt;cline-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
 		s-&gt;string[s-&gt;len - 4] = TO_RA;
 		s-&gt;string[s-&gt;len - 1] = 0;
 	} else {
<span class="p_del">-		while (--size &gt; cp-&gt;cline-&gt;len)</span>
<span class="p_add">+		while (--size &gt;= cp-&gt;cline-&gt;len)</span>
 			s-&gt;string[size] = cp-&gt;view.ascebc[&#39; &#39;];
 	}
 	/* Replace cline with allocated line s and reset cline. */
<span class="p_header">diff --git a/drivers/s390/cio/chsc.c b/drivers/s390/cio/chsc.c</span>
<span class="p_header">index c424c0c7367e..1e16331891a9 100644</span>
<span class="p_header">--- a/drivers/s390/cio/chsc.c</span>
<span class="p_header">+++ b/drivers/s390/cio/chsc.c</span>
<span class="p_chunk">@@ -95,12 +95,13 @@</span> <span class="p_context"> struct chsc_ssd_area {</span>
 int chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)
 {
 	struct chsc_ssd_area *ssd_area;
<span class="p_add">+	unsigned long flags;</span>
 	int ccode;
 	int ret;
 	int i;
 	int mask;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	ssd_area = chsc_page;
 	ssd_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -144,7 +145,7 @@</span> <span class="p_context"> int chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)</span>
 			ssd-&gt;fla[i] = ssd_area-&gt;fla[i];
 	}
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -832,9 +833,10 @@</span> <span class="p_context"> int __chsc_do_secm(struct channel_subsystem *css, int enable)</span>
 		u32 fmt : 4;
 		u32 : 16;
 	} __attribute__ ((packed)) *secm_area;
<span class="p_add">+	unsigned long flags;</span>
 	int ret, ccode;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	secm_area = chsc_page;
 	secm_area-&gt;request.length = 0x0050;
<span class="p_chunk">@@ -864,7 +866,7 @@</span> <span class="p_context"> int __chsc_do_secm(struct channel_subsystem *css, int enable)</span>
 		CIO_CRW_EVENT(2, &quot;chsc: secm failed (rc=%04x)\n&quot;,
 			      secm_area-&gt;response.code);
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -993,6 +995,7 @@</span> <span class="p_context"> chsc_initialize_cmg_chars(struct channel_path *chp, u8 cmcv,</span>
 
 int chsc_get_channel_measurement_chars(struct channel_path *chp)
 {
<span class="p_add">+	unsigned long flags;</span>
 	int ccode, ret;
 
 	struct {
<span class="p_chunk">@@ -1022,7 +1025,7 @@</span> <span class="p_context"> int chsc_get_channel_measurement_chars(struct channel_path *chp)</span>
 	if (!css_chsc_characteristics.scmc || !css_chsc_characteristics.secm)
 		return 0;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	scmc_area = chsc_page;
 	scmc_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -1054,7 +1057,7 @@</span> <span class="p_context"> int chsc_get_channel_measurement_chars(struct channel_path *chp)</span>
 	chsc_initialize_cmg_chars(chp, scmc_area-&gt;cmcv,
 				  (struct cmg_chars *) &amp;scmc_area-&gt;data);
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1135,6 +1138,7 @@</span> <span class="p_context"> struct css_chsc_char css_chsc_characteristics;</span>
 int __init
 chsc_determine_css_characteristics(void)
 {
<span class="p_add">+	unsigned long flags;</span>
 	int result;
 	struct {
 		struct chsc_header request;
<span class="p_chunk">@@ -1147,7 +1151,7 @@</span> <span class="p_context"> chsc_determine_css_characteristics(void)</span>
 		u32 chsc_char[508];
 	} __attribute__ ((packed)) *scsc_area;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	scsc_area = chsc_page;
 	scsc_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -1169,7 +1173,7 @@</span> <span class="p_context"> chsc_determine_css_characteristics(void)</span>
 		CIO_CRW_EVENT(2, &quot;chsc: scsc failed (rc=%04x)\n&quot;,
 			      scsc_area-&gt;response.code);
 exit:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 6180f7970bbf..0969cea1089a 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -4510,7 +4510,7 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 			    le16_to_cpu(mpi_reply-&gt;DevHandle));
 		mpt3sas_trigger_scsi(ioc, data.skey, data.asc, data.ascq);
 
<span class="p_del">-		if (!(ioc-&gt;logging_level &amp; MPT_DEBUG_REPLY) &amp;&amp;</span>
<span class="p_add">+		if ((ioc-&gt;logging_level &amp; MPT_DEBUG_REPLY) &amp;&amp;</span>
 		     ((scmd-&gt;sense_buffer[2] == UNIT_ATTENTION) ||
 		     (scmd-&gt;sense_buffer[2] == MEDIUM_ERROR) ||
 		     (scmd-&gt;sense_buffer[2] == HARDWARE_ERROR)))
<span class="p_header">diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_header">index 39412c9097c6..a3965cac1b34 100644</span>
<span class="p_header">--- a/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_chunk">@@ -753,7 +753,6 @@</span> <span class="p_context"> static int dspi_remove(struct platform_device *pdev)</span>
 	/* Disconnect from the SPI framework */
 	clk_disable_unprepare(dspi-&gt;clk);
 	spi_unregister_master(dspi-&gt;master);
<span class="p_del">-	spi_master_put(dspi-&gt;master);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_cmd.c b/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_header">index 9b7026e7d55b..45d0a87f55d2 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_chunk">@@ -718,13 +718,13 @@</span> <span class="p_context"> u8 rtw_addbareq_cmd(struct adapter *padapter, u8 tid, u8 *addr)</span>
 	u8	res = _SUCCESS;
 
 
<span class="p_del">-	ph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);</span>
<span class="p_add">+	ph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);</span>
 	if (ph2c == NULL) {
 		res = _FAIL;
 		goto exit;
 	}
 
<span class="p_del">-	paddbareq_parm = kzalloc(sizeof(struct addBaReq_parm), GFP_KERNEL);</span>
<span class="p_add">+	paddbareq_parm = kzalloc(sizeof(struct addBaReq_parm), GFP_ATOMIC);</span>
 	if (paddbareq_parm == NULL) {
 		kfree(ph2c);
 		res = _FAIL;
<span class="p_header">diff --git a/drivers/uio/uio_dmem_genirq.c b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">index 915facbf552e..e1134a4d97f3 100644</span>
<span class="p_header">--- a/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">+++ b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static int uio_dmem_genirq_probe(struct platform_device *pdev)</span>
 		++uiomem;
 	}
 
<span class="p_del">-	priv-&gt;dmem_region_start = i;</span>
<span class="p_add">+	priv-&gt;dmem_region_start = uiomem - &amp;uioinfo-&gt;mem[0];</span>
 	priv-&gt;num_dmem_regions = pdata-&gt;num_dynamic_regions;
 
 	for (i = 0; i &lt; pdata-&gt;num_dynamic_regions; ++i) {
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_dev_frontend.c b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">index 531e76474983..0e0eb10f82a0 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_chunk">@@ -316,7 +316,7 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 			rc = -ENOMEM;
 			goto out;
 		}
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else if (msg_type == XS_TRANSACTION_END) {</span>
 		list_for_each_entry(trans, &amp;u-&gt;transactions, list)
 			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)
 				break;
<span class="p_header">diff --git a/fs/9p/acl.c b/fs/9p/acl.c</span>
<span class="p_header">index a7e28890f5ef..929b618da43b 100644</span>
<span class="p_header">--- a/fs/9p/acl.c</span>
<span class="p_header">+++ b/fs/9p/acl.c</span>
<span class="p_chunk">@@ -282,32 +282,26 @@</span> <span class="p_context"> static int v9fs_xattr_set_acl(const struct xattr_handler *handler,</span>
 	switch (handler-&gt;flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			retval = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (retval &lt; 0)</span>
<span class="p_add">+			struct iattr iattr;</span>
<span class="p_add">+</span>
<span class="p_add">+			retval = posix_acl_update_mode(inode, &amp;iattr.ia_mode, &amp;acl);</span>
<span class="p_add">+			if (retval)</span>
 				goto err_out;
<span class="p_del">-			else {</span>
<span class="p_del">-				struct iattr iattr;</span>
<span class="p_del">-				if (retval == 0) {</span>
<span class="p_del">-					/*</span>
<span class="p_del">-					 * ACL can be represented</span>
<span class="p_del">-					 * by the mode bits. So don&#39;t</span>
<span class="p_del">-					 * update ACL.</span>
<span class="p_del">-					 */</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-					value = NULL;</span>
<span class="p_del">-					size = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				/* Updte the mode bits */</span>
<span class="p_del">-				iattr.ia_mode = ((mode &amp; S_IALLUGO) |</span>
<span class="p_del">-						 (inode-&gt;i_mode &amp; ~S_IALLUGO));</span>
<span class="p_del">-				iattr.ia_valid = ATTR_MODE;</span>
<span class="p_del">-				/* FIXME should we update ctime ?</span>
<span class="p_del">-				 * What is the following setxattr update the</span>
<span class="p_del">-				 * mode ?</span>
<span class="p_add">+			if (!acl) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * ACL can be represented</span>
<span class="p_add">+				 * by the mode bits. So don&#39;t</span>
<span class="p_add">+				 * update ACL.</span>
 				 */
<span class="p_del">-				v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
<span class="p_add">+				value = NULL;</span>
<span class="p_add">+				size = 0;</span>
 			}
<span class="p_add">+			iattr.ia_valid = ATTR_MODE;</span>
<span class="p_add">+			/* FIXME should we update ctime ?</span>
<span class="p_add">+			 * What is the following setxattr update the</span>
<span class="p_add">+			 * mode ?</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index 9a0124a95851..fb3e64d37cb4 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -83,11 +83,9 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		ret = 0;
 		break;
<span class="p_header">diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c</span>
<span class="p_header">index 8f84646f10e9..4d8caeb94a11 100644</span>
<span class="p_header">--- a/fs/ceph/acl.c</span>
<span class="p_header">+++ b/fs/ceph/acl.c</span>
<span class="p_chunk">@@ -94,11 +94,9 @@</span> <span class="p_context"> int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;new_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;new_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				goto out;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c</span>
<span class="p_header">index 27695e6f4e46..d6aeb84e90b6 100644</span>
<span class="p_header">--- a/fs/ext2/acl.c</span>
<span class="p_header">+++ b/fs/ext2/acl.c</span>
<span class="p_chunk">@@ -193,15 +193,11 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					mark_inode_dirty(inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				mark_inode_dirty(inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c</span>
<span class="p_header">index 69b1e73026a5..c3fe1e323951 100644</span>
<span class="p_header">--- a/fs/ext4/acl.c</span>
<span class="p_header">+++ b/fs/ext4/acl.c</span>
<span class="p_chunk">@@ -196,15 +196,11 @@</span> <span class="p_context"> __ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_del">-				ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_add">+			ext4_mark_inode_dirty(handle, inode);</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/f2fs/acl.c b/fs/f2fs/acl.c</span>
<span class="p_header">index c8f25f7241f0..e9a8d676c6bc 100644</span>
<span class="p_header">--- a/fs/f2fs/acl.c</span>
<span class="p_header">+++ b/fs/f2fs/acl.c</span>
<span class="p_chunk">@@ -214,12 +214,10 @@</span> <span class="p_context"> static int __f2fs_set_acl(struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
 			set_acl_inode(fi, inode-&gt;i_mode);
<span class="p_del">-			if (error == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c</span>
<span class="p_header">index 1be3b061c05c..ff0ac96a8e7b 100644</span>
<span class="p_header">--- a/fs/gfs2/acl.c</span>
<span class="p_header">+++ b/fs/gfs2/acl.c</span>
<span class="p_chunk">@@ -79,17 +79,11 @@</span> <span class="p_context"> int gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode-&gt;i_mode;
 
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
 			return error;
<span class="p_del">-</span>
<span class="p_del">-		if (error == 0)</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mode != inode-&gt;i_mode) {</span>
<span class="p_del">-			inode-&gt;i_mode = mode;</span>
<span class="p_add">+		if (mode != inode-&gt;i_mode)</span>
 			mark_inode_dirty(inode);
<span class="p_del">-		}</span>
 	}
 
 	if (acl) {
<span class="p_header">diff --git a/fs/hfsplus/posix_acl.c b/fs/hfsplus/posix_acl.c</span>
<span class="p_header">index df0c9af68d05..71b3087b7e32 100644</span>
<span class="p_header">--- a/fs/hfsplus/posix_acl.c</span>
<span class="p_header">+++ b/fs/hfsplus/posix_acl.c</span>
<span class="p_chunk">@@ -68,8 +68,8 @@</span> <span class="p_context"> int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
 	case ACL_TYPE_ACCESS:
 		xattr_name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			err = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (err &lt; 0)</span>
<span class="p_add">+			err = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (err)</span>
 				return err;
 		}
 		err = 0;
<span class="p_header">diff --git a/fs/jffs2/acl.c b/fs/jffs2/acl.c</span>
<span class="p_header">index 2f7a3c090489..f9f86f87d32b 100644</span>
<span class="p_header">--- a/fs/jffs2/acl.c</span>
<span class="p_header">+++ b/fs/jffs2/acl.c</span>
<span class="p_chunk">@@ -235,9 +235,10 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			if (inode-&gt;i_mode != mode) {
 				struct iattr attr;
<span class="p_chunk">@@ -249,8 +250,6 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 				if (rc &lt; 0)
 					return rc;
 			}
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 0c8ca830b113..9fad9f4fe883 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -84,13 +84,11 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		ea_name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			inode-&gt;i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 2162434728c0..164307b99405 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -241,13 +241,11 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_del">-				return ret;</span>
<span class="p_add">+			umode_t mode;</span>
 
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index 34bd1bd354e6..a60d3cc5b55d 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -592,6 +592,37 @@</span> <span class="p_context"> no_mem:</span>
 }
 EXPORT_SYMBOL_GPL(posix_acl_create);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * posix_acl_update_mode  -  update mode in set_acl</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update the file mode when setting an ACL: compute the new file permission</span>
<span class="p_add">+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new</span>
<span class="p_add">+ * file mode, set *acl to NULL to indicate that no ACL should be set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As with chmod, clear the setgit bit if the caller is not in the owning group</span>
<span class="p_add">+ * or capable of CAP_FSETID (see inode_change_ok).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called from set_acl inode operations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,</span>
<span class="p_add">+			  struct posix_acl **acl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = posix_acl_equiv_mode(*acl, &amp;mode);</span>
<span class="p_add">+	if (error &lt; 0)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (error == 0)</span>
<span class="p_add">+		*acl = NULL;</span>
<span class="p_add">+	if (!in_group_p(inode-&gt;i_gid) &amp;&amp;</span>
<span class="p_add">+	    !capable_wrt_inode_uidgid(inode, CAP_FSETID))</span>
<span class="p_add">+		mode &amp;= ~S_ISGID;</span>
<span class="p_add">+	*mode_p = mode;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(posix_acl_update_mode);</span>
<span class="p_add">+</span>
 /*
  * Fix up the uids and gids in posix acl extended attributes in place.
  */
<span class="p_header">diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">index 4b34b9dc03dd..9b1824f35501 100644</span>
<span class="p_header">--- a/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">+++ b/fs/reiserfs/xattr_acl.c</span>
<span class="p_chunk">@@ -246,13 +246,9 @@</span> <span class="p_context"> __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,</span>
 	case ACL_TYPE_ACCESS:
 		name = POSIX_ACL_XATTR_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index 6bb470fbb8e8..c5101a3295d8 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -288,16 +288,11 @@</span> <span class="p_context"> xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (error &lt;= 0) {</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		umode_t mode;</span>
 
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index 0a271ca1f7c7..a31976c860f6 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -1029,7 +1029,8 @@</span> <span class="p_context"> static inline int drm_debugfs_remove_files(const struct drm_info_list *files,</span>
 #endif
 
 extern struct dma_buf *drm_gem_prime_export(struct drm_device *dev,
<span class="p_del">-		struct drm_gem_object *obj, int flags);</span>
<span class="p_add">+					    struct drm_gem_object *obj,</span>
<span class="p_add">+					    int flags);</span>
 extern int drm_gem_prime_handle_to_fd(struct drm_device *dev,
 		struct drm_file *file_priv, uint32_t handle, uint32_t flags,
 		int *prime_fd);
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 4e9c75226f07..12b4d54a8ffa 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -1986,8 +1986,8 @@</span> <span class="p_context"> struct napi_gro_cb {</span>
 	/* This is non-zero if the packet may be of the same flow. */
 	u8	same_flow:1;
 
<span class="p_del">-	/* Used in udp_gro_receive */</span>
<span class="p_del">-	u8	udp_mark:1;</span>
<span class="p_add">+	/* Used in tunnel GRO receive */</span>
<span class="p_add">+	u8	encap_mark:1;</span>
 
 	/* GRO checksum is valid */
 	u8	csum_valid:1;
<span class="p_header">diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h</span>
<span class="p_header">index 3e96a6a76103..d1a8ad7e5ae4 100644</span>
<span class="p_header">--- a/include/linux/posix_acl.h</span>
<span class="p_header">+++ b/include/linux/posix_acl.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> extern int set_posix_acl(struct inode *, int, struct posix_acl *);</span>
 extern int posix_acl_chmod(struct inode *, umode_t);
 extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
 		struct posix_acl **);
<span class="p_add">+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);</span>
 
 extern int simple_set_acl(struct inode *, struct posix_acl *, int);
 extern int simple_acl_create(struct inode *, struct inode *);
<span class="p_header">diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h</span>
<span class="p_header">index af40bc586a1b..86a7bdd61d1a 100644</span>
<span class="p_header">--- a/include/net/ip_tunnels.h</span>
<span class="p_header">+++ b/include/net/ip_tunnels.h</span>
<span class="p_chunk">@@ -283,6 +283,22 @@</span> <span class="p_context"> struct metadata_dst *iptunnel_metadata_reply(struct metadata_dst *md,</span>
 struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, bool gre_csum,
 					 int gso_type_mask);
 
<span class="p_add">+static inline int iptunnel_pull_offloads(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (skb_is_gso(skb)) {</span>
<span class="p_add">+		int err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = skb_unclone(skb, GFP_ATOMIC);</span>
<span class="p_add">+		if (unlikely(err))</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		skb_shinfo(skb)-&gt;gso_type &amp;= ~(NETIF_F_GSO_ENCAP_ALL &gt;&gt;</span>
<span class="p_add">+					       NETIF_F_GSO_SHIFT);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	skb-&gt;encapsulation = 0;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void iptunnel_xmit_stats(int err,
 				       struct net_device_stats *err_stats,
 				       struct pcpu_sw_netstats __percpu *stats)
<span class="p_header">diff --git a/kernel/irq/generic-chip.c b/kernel/irq/generic-chip.c</span>
<span class="p_header">index abd286afbd27..a4775f3451b9 100644</span>
<span class="p_header">--- a/kernel/irq/generic-chip.c</span>
<span class="p_header">+++ b/kernel/irq/generic-chip.c</span>
<span class="p_chunk">@@ -411,8 +411,29 @@</span> <span class="p_context"> int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,</span>
 }
 EXPORT_SYMBOL_GPL(irq_map_generic_chip);
 
<span class="p_add">+static void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct irq_data *data = irq_domain_get_irq_data(d, virq);</span>
<span class="p_add">+	struct irq_domain_chip_generic *dgc = d-&gt;gc;</span>
<span class="p_add">+	unsigned int hw_irq = data-&gt;hwirq;</span>
<span class="p_add">+	struct irq_chip_generic *gc;</span>
<span class="p_add">+	int irq_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	gc = irq_get_domain_generic_chip(d, hw_irq);</span>
<span class="p_add">+	if (!gc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_idx = hw_irq % dgc-&gt;irqs_per_chip;</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(irq_idx, &amp;gc-&gt;installed);</span>
<span class="p_add">+	irq_domain_set_info(d, virq, hw_irq, &amp;no_irq_chip, NULL, NULL, NULL,</span>
<span class="p_add">+			    NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct irq_domain_ops irq_generic_chip_ops = {
 	.map	= irq_map_generic_chip,
<span class="p_add">+	.unmap  = irq_unmap_generic_chip,</span>
 	.xlate	= irq_domain_xlate_onetwocell,
 };
 EXPORT_SYMBOL_GPL(irq_generic_chip_ops);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 125c7dd55322..4434cdd4cd9a 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1416,12 +1416,13 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
 {
 	spin_lock(&amp;hugetlb_lock);
 	if (PageHuge(page) &amp;&amp; !page_count(page)) {
<span class="p_del">-		struct hstate *h = page_hstate(page);</span>
<span class="p_del">-		int nid = page_to_nid(page);</span>
<span class="p_del">-		list_del(&amp;page-&gt;lru);</span>
<span class="p_add">+		struct page *head = compound_head(page);</span>
<span class="p_add">+		struct hstate *h = page_hstate(head);</span>
<span class="p_add">+		int nid = page_to_nid(head);</span>
<span class="p_add">+		list_del(&amp;head-&gt;lru);</span>
 		h-&gt;free_huge_pages--;
 		h-&gt;free_huge_pages_node[nid]--;
<span class="p_del">-		update_and_free_page(h, page);</span>
<span class="p_add">+		update_and_free_page(h, head);</span>
 	}
 	spin_unlock(&amp;hugetlb_lock);
 }
<span class="p_chunk">@@ -1429,7 +1430,8 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
 /*
  * Dissolve free hugepages in a given pfn range. Used by memory hotplug to
  * make specified memory blocks removable from the system.
<span class="p_del">- * Note that start_pfn should aligned with (minimum) hugepage size.</span>
<span class="p_add">+ * Note that this will dissolve a free gigantic hugepage completely, if any</span>
<span class="p_add">+ * part of it lies within the given range.</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_chunk">@@ -1438,7 +1440,6 @@</span> <span class="p_context"> void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
 	if (!hugepages_supported())
 		return;
 
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
 	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index de4ed2b5a221..0989fea88c44 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -4239,7 +4239,7 @@</span> <span class="p_context"> static enum gro_result dev_gro_receive(struct napi_struct *napi, struct sk_buff</span>
 		NAPI_GRO_CB(skb)-&gt;same_flow = 0;
 		NAPI_GRO_CB(skb)-&gt;flush = 0;
 		NAPI_GRO_CB(skb)-&gt;free = 0;
<span class="p_del">-		NAPI_GRO_CB(skb)-&gt;udp_mark = 0;</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;encap_mark = 0;</span>
 		NAPI_GRO_CB(skb)-&gt;gro_remcsum_start = 0;
 
 		/* Setup for GRO checksum validation */
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index 5c5db6636704..1a5c1ca3ad3c 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -1383,6 +1383,19 @@</span> <span class="p_context"> out:</span>
 	return pp;
 }
 
<span class="p_add">+static struct sk_buff **ipip_gro_receive(struct sk_buff **head,</span>
<span class="p_add">+					 struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (NAPI_GRO_CB(skb)-&gt;encap_mark) {</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;flush = 1;</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;encap_mark = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return inet_gro_receive(head, skb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int inet_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)
 {
 	if (sk-&gt;sk_family == AF_INET)
<span class="p_chunk">@@ -1425,6 +1438,13 @@</span> <span class="p_context"> out_unlock:</span>
 	return err;
 }
 
<span class="p_add">+static int ipip_gro_complete(struct sk_buff *skb, int nhoff)</span>
<span class="p_add">+{</span>
<span class="p_add">+	skb-&gt;encapsulation = 1;</span>
<span class="p_add">+	skb_shinfo(skb)-&gt;gso_type |= SKB_GSO_IPIP;</span>
<span class="p_add">+	return inet_gro_complete(skb, nhoff);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int inet_ctl_sock_create(struct sock **sk, unsigned short family,
 			 unsigned short type, unsigned char protocol,
 			 struct net *net)
<span class="p_chunk">@@ -1652,8 +1672,8 @@</span> <span class="p_context"> static struct packet_offload ip_packet_offload __read_mostly = {</span>
 static const struct net_offload ipip_offload = {
 	.callbacks = {
 		.gso_segment	= inet_gso_segment,
<span class="p_del">-		.gro_receive	= inet_gro_receive,</span>
<span class="p_del">-		.gro_complete	= inet_gro_complete,</span>
<span class="p_add">+		.gro_receive	= ipip_gro_receive,</span>
<span class="p_add">+		.gro_complete	= ipip_gro_complete,</span>
 	},
 };
 
<span class="p_header">diff --git a/net/ipv4/fou.c b/net/ipv4/fou.c</span>
<span class="p_header">index bd903fe0f750..08d7de55e57e 100644</span>
<span class="p_header">--- a/net/ipv4/fou.c</span>
<span class="p_header">+++ b/net/ipv4/fou.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static inline struct fou *fou_from_sock(struct sock *sk)</span>
 	return sk-&gt;sk_user_data;
 }
 
<span class="p_del">-static void fou_recv_pull(struct sk_buff *skb, size_t len)</span>
<span class="p_add">+static int fou_recv_pull(struct sk_buff *skb, size_t len)</span>
 {
 	struct iphdr *iph = ip_hdr(skb);
 
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> static void fou_recv_pull(struct sk_buff *skb, size_t len)</span>
 	__skb_pull(skb, len);
 	skb_postpull_rcsum(skb, udp_hdr(skb), len);
 	skb_reset_transport_header(skb);
<span class="p_add">+	return iptunnel_pull_offloads(skb);</span>
 }
 
 static int fou_udp_recv(struct sock *sk, struct sk_buff *skb)
<span class="p_chunk">@@ -68,9 +69,14 @@</span> <span class="p_context"> static int fou_udp_recv(struct sock *sk, struct sk_buff *skb)</span>
 	if (!fou)
 		return 1;
 
<span class="p_del">-	fou_recv_pull(skb, sizeof(struct udphdr));</span>
<span class="p_add">+	if (fou_recv_pull(skb, sizeof(struct udphdr)))</span>
<span class="p_add">+		goto drop;</span>
 
 	return -fou-&gt;protocol;
<span class="p_add">+</span>
<span class="p_add">+drop:</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 0;</span>
 }
 
 static struct guehdr *gue_remcsum(struct sk_buff *skb, struct guehdr *guehdr,
<span class="p_chunk">@@ -170,6 +176,9 @@</span> <span class="p_context"> static int gue_udp_recv(struct sock *sk, struct sk_buff *skb)</span>
 	__skb_pull(skb, sizeof(struct udphdr) + hdrlen);
 	skb_reset_transport_header(skb);
 
<span class="p_add">+	if (iptunnel_pull_offloads(skb))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	return -guehdr-&gt;proto_ctype;
 
 drop:
<span class="p_header">diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c</span>
<span class="p_header">index 5a8ee3282550..e603004c1af8 100644</span>
<span class="p_header">--- a/net/ipv4/gre_offload.c</span>
<span class="p_header">+++ b/net/ipv4/gre_offload.c</span>
<span class="p_chunk">@@ -128,6 +128,11 @@</span> <span class="p_context"> static struct sk_buff **gre_gro_receive(struct sk_buff **head,</span>
 	struct packet_offload *ptype;
 	__be16 type;
 
<span class="p_add">+	if (NAPI_GRO_CB(skb)-&gt;encap_mark)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;encap_mark = 1;</span>
<span class="p_add">+</span>
 	off = skb_gro_offset(skb);
 	hlen = off + sizeof(*greh);
 	greh = skb_gro_header_fast(skb, off);
<span class="p_header">diff --git a/net/ipv4/ip_tunnel_core.c b/net/ipv4/ip_tunnel_core.c</span>
<span class="p_header">index 6cb9009c3d96..dbda0565781c 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel_core.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel_core.c</span>
<span class="p_chunk">@@ -116,7 +116,8 @@</span> <span class="p_context"> int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto)</span>
 	skb-&gt;vlan_tci = 0;
 	skb_set_queue_mapping(skb, 0);
 	skb-&gt;pkt_type = PACKET_HOST;
<span class="p_del">-	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return iptunnel_pull_offloads(skb);</span>
 }
 EXPORT_SYMBOL_GPL(iptunnel_pull_header);
 
<span class="p_header">diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c</span>
<span class="p_header">index f9386160cbee..0e36e56dfd22 100644</span>
<span class="p_header">--- a/net/ipv4/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/udp_offload.c</span>
<span class="p_chunk">@@ -299,14 +299,14 @@</span> <span class="p_context"> struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,</span>
 	unsigned int off = skb_gro_offset(skb);
 	int flush = 1;
 
<span class="p_del">-	if (NAPI_GRO_CB(skb)-&gt;udp_mark ||</span>
<span class="p_add">+	if (NAPI_GRO_CB(skb)-&gt;encap_mark ||</span>
 	    (skb-&gt;ip_summed != CHECKSUM_PARTIAL &amp;&amp;
 	     NAPI_GRO_CB(skb)-&gt;csum_cnt == 0 &amp;&amp;
 	     !NAPI_GRO_CB(skb)-&gt;csum_valid))
 		goto out;
 
<span class="p_del">-	/* mark that this skb passed once through the udp gro layer */</span>
<span class="p_del">-	NAPI_GRO_CB(skb)-&gt;udp_mark = 1;</span>
<span class="p_add">+	/* mark that this skb passed once through the tunnel gro layer */</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;encap_mark = 1;</span>
 
 	rcu_read_lock();
 	uo_priv = rcu_dereference(udp_offload_base);
<span class="p_header">diff --git a/net/ipv6/ip6_offload.c b/net/ipv6/ip6_offload.c</span>
<span class="p_header">index eeca943f12dc..82e9f3076028 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_offload.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_offload.c</span>
<span class="p_chunk">@@ -258,6 +258,19 @@</span> <span class="p_context"> out:</span>
 	return pp;
 }
 
<span class="p_add">+static struct sk_buff **sit_gro_receive(struct sk_buff **head,</span>
<span class="p_add">+					struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (NAPI_GRO_CB(skb)-&gt;encap_mark) {</span>
<span class="p_add">+		NAPI_GRO_CB(skb)-&gt;flush = 1;</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	NAPI_GRO_CB(skb)-&gt;encap_mark = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ipv6_gro_receive(head, skb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ipv6_gro_complete(struct sk_buff *skb, int nhoff)
 {
 	const struct net_offload *ops;
<span class="p_chunk">@@ -302,7 +315,7 @@</span> <span class="p_context"> static struct packet_offload ipv6_packet_offload __read_mostly = {</span>
 static const struct net_offload sit_offload = {
 	.callbacks = {
 		.gso_segment	= ipv6_gso_segment,
<span class="p_del">-		.gro_receive    = ipv6_gro_receive,</span>
<span class="p_add">+		.gro_receive    = sit_gro_receive,</span>
 		.gro_complete   = sit_gro_complete,
 	},
 };
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index ba3d2f3d66d2..3da2b16356eb 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -681,14 +681,15 @@</span> <span class="p_context"> static int ipip6_rcv(struct sk_buff *skb)</span>
 		skb-&gt;mac_header = skb-&gt;network_header;
 		skb_reset_network_header(skb);
 		IPCB(skb)-&gt;flags = 0;
<span class="p_del">-		skb-&gt;protocol = htons(ETH_P_IPV6);</span>
<span class="p_add">+		skb-&gt;dev = tunnel-&gt;dev;</span>
 
 		if (packet_is_spoofed(skb, iph, tunnel)) {
 			tunnel-&gt;dev-&gt;stats.rx_errors++;
 			goto out;
 		}
 
<span class="p_del">-		__skb_tunnel_rx(skb, tunnel-&gt;dev, tunnel-&gt;net);</span>
<span class="p_add">+		if (iptunnel_pull_header(skb, 0, htons(ETH_P_IPV6)))</span>
<span class="p_add">+			goto out;</span>
 
 		err = IP_ECN_decapsulate(iph, skb);
 		if (unlikely(err)) {
<span class="p_header">diff --git a/scripts/sortextable.c b/scripts/sortextable.c</span>
<span class="p_header">index c2423d913b46..7b29fb14f870 100644</span>
<span class="p_header">--- a/scripts/sortextable.c</span>
<span class="p_header">+++ b/scripts/sortextable.c</span>
<span class="p_chunk">@@ -209,6 +209,35 @@</span> <span class="p_context"> static int compare_relative_table(const void *a, const void *b)</span>
 	return 0;
 }
 
<span class="p_add">+static void x86_sort_relative_table(char *extab_image, int image_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	i = 0;</span>
<span class="p_add">+	while (i &lt; image_size) {</span>
<span class="p_add">+		uint32_t *loc = (uint32_t *)(extab_image + i);</span>
<span class="p_add">+</span>
<span class="p_add">+		w(r(loc) + i, loc);</span>
<span class="p_add">+		w(r(loc + 1) + i + 4, loc + 1);</span>
<span class="p_add">+		w(r(loc + 2) + i + 8, loc + 2);</span>
<span class="p_add">+</span>
<span class="p_add">+		i += sizeof(uint32_t) * 3;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	qsort(extab_image, image_size / 12, 12, compare_relative_table);</span>
<span class="p_add">+</span>
<span class="p_add">+	i = 0;</span>
<span class="p_add">+	while (i &lt; image_size) {</span>
<span class="p_add">+		uint32_t *loc = (uint32_t *)(extab_image + i);</span>
<span class="p_add">+</span>
<span class="p_add">+		w(r(loc) - i, loc);</span>
<span class="p_add">+		w(r(loc + 1) - (i + 4), loc + 1);</span>
<span class="p_add">+		w(r(loc + 2) - (i + 8), loc + 2);</span>
<span class="p_add">+</span>
<span class="p_add">+		i += sizeof(uint32_t) * 3;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void sort_relative_table(char *extab_image, int image_size)
 {
 	int i;
<span class="p_chunk">@@ -281,6 +310,9 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 		break;
 	case EM_386:
 	case EM_X86_64:
<span class="p_add">+		custom_sort = x86_sort_relative_table;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	case EM_S390:
 		custom_sort = sort_relative_table;
 		break;
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index afb70a5d4fd3..b8a256dfed7e 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -823,6 +823,7 @@</span> <span class="p_context"> static int dapm_create_or_share_kcontrol(struct snd_soc_dapm_widget *w,</span>
 			case snd_soc_dapm_switch:
 			case snd_soc_dapm_mixer:
 			case snd_soc_dapm_pga:
<span class="p_add">+			case snd_soc_dapm_out_drv:</span>
 				wname_in_long_name = true;
 				kcname_in_long_name = true;
 				break;
<span class="p_chunk">@@ -3015,6 +3016,9 @@</span> <span class="p_context"> int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,</span>
 	}
 	mutex_unlock(&amp;card-&gt;dapm_mutex);
 
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	if (invert)
 		ucontrol-&gt;value.integer.value[0] = max - val;
 	else
<span class="p_chunk">@@ -3166,7 +3170,7 @@</span> <span class="p_context"> int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,</span>
 	if (e-&gt;shift_l != e-&gt;shift_r) {
 		if (item[1] &gt; e-&gt;items)
 			return -EINVAL;
<span class="p_del">-		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_l;</span>
<span class="p_add">+		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_r;</span>
 		mask |= e-&gt;mask &lt;&lt; e-&gt;shift_r;
 	}
 
<span class="p_header">diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c</span>
<span class="p_header">index 6963ba20991c..70396d3f6472 100644</span>
<span class="p_header">--- a/sound/soc/soc-topology.c</span>
<span class="p_header">+++ b/sound/soc/soc-topology.c</span>
<span class="p_chunk">@@ -1484,6 +1484,7 @@</span> <span class="p_context"> widget:</span>
 	if (widget == NULL) {
 		dev_err(tplg-&gt;dev, &quot;ASoC: failed to create widget %s controls\n&quot;,
 			w-&gt;name);
<span class="p_add">+		ret = -ENOMEM;</span>
 		goto hdr_err;
 	}
 
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 3900386a3629..d802938644b5 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -684,7 +684,6 @@</span> <span class="p_context"> static int __hpp__slsmg_color_printf(struct perf_hpp *hpp, const char *fmt, ...)</span>
 	ret = scnprintf(hpp-&gt;buf, hpp-&gt;size, fmt, len, percent);
 	ui_browser__printf(arg-&gt;b, &quot;%s&quot;, hpp-&gt;buf);
 
<span class="p_del">-	advance_hpp(hpp, ret);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/tools/perf/util/stat.c b/tools/perf/util/stat.c</span>
<span class="p_header">index 4a3a72cb5805..6ce624cb7001 100644</span>
<span class="p_header">--- a/tools/perf/util/stat.c</span>
<span class="p_header">+++ b/tools/perf/util/stat.c</span>
<span class="p_chunk">@@ -311,6 +311,16 @@</span> <span class="p_context"> int perf_stat_process_counter(struct perf_stat_config *config,</span>
 
 	aggr-&gt;val = aggr-&gt;ena = aggr-&gt;run = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We calculate counter&#39;s data every interval,</span>
<span class="p_add">+	 * and the display code shows ps-&gt;res_stats</span>
<span class="p_add">+	 * avg value. We need to zero the stats for</span>
<span class="p_add">+	 * interval mode, otherwise overall avg running</span>
<span class="p_add">+	 * averages will be shown for each interval.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (config-&gt;interval)</span>
<span class="p_add">+		init_stats(ps-&gt;res_stats);</span>
<span class="p_add">+</span>
 	if (counter-&gt;per_pkg)
 		zero_per_pkg(counter);
 
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index 475d88d0a1c9..27ae382feb2d 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -1091,9 +1091,8 @@</span> <span class="p_context"> new_symbol:</span>
 	 * For misannotated, zeroed, ASM function sizes.
 	 */
 	if (nr &gt; 0) {
<span class="p_del">-		if (!symbol_conf.allow_aliases)</span>
<span class="p_del">-			symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+		symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		if (kmap) {
 			/*
 			 * We need to fixup this here too because we create new
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index cd08027a6d2c..520a32a12f8a 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -151,6 +151,9 @@</span> <span class="p_context"> void symbols__fixup_duplicate(struct rb_root *symbols)</span>
 	struct rb_node *nd;
 	struct symbol *curr, *next;
 
<span class="p_add">+	if (symbol_conf.allow_aliases)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	nd = rb_first(symbols);
 
 	while (nd) {
<span class="p_chunk">@@ -1275,8 +1278,8 @@</span> <span class="p_context"> int dso__load_kallsyms(struct dso *dso, const char *filename,</span>
 	if (kallsyms__delta(map, filename, &amp;delta))
 		return -1;
 
<span class="p_del">-	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 	symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 
 	if (dso-&gt;kernel == DSO_TYPE_GUEST_KERNEL)
 		dso-&gt;symtab_type = DSO_BINARY_TYPE__GUEST_KALLSYMS;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



