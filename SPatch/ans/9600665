
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,v2,24/32] kvm: x86: prepare for SEV guest management API support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,v2,24/32] kvm: x86: prepare for SEV guest management API support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=150921">Brijesh Singh</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 2, 2017, 3:17 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;148846784278.2349.17771314083820274411.stgit@brijesh-build-machine&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9600665/mbox/"
   >mbox</a>
|
   <a href="/patch/9600665/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9600665/">/patch/9600665/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	F113C60453 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  2 Mar 2017 15:53:43 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DF12C28485
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  2 Mar 2017 15:53:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D2544285A3; Thu,  2 Mar 2017 15:53:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 21A202858C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  2 Mar 2017 15:53:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753670AbdCBPxb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 2 Mar 2017 10:53:31 -0500
Received: from mail-cys01nam02on0053.outbound.protection.outlook.com
	([104.47.37.53]:19434
	&quot;EHLO NAM02-CY1-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1752105AbdCBPwn (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 2 Mar 2017 10:52:43 -0500
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=BabRD+8SP09AKdgdetzTcMHogaAs/xaiaTq1N87Grxc=;
	b=whh6Jd88o78nR0Drtq4obpwu2F/VkTI+sb0znASq2+o68m93HJ/WJ/iqI+YRcwH0NuFgz5IFojuTKVW4rPonIfYEQl8OTcEG09fbF4hfeJIHVjeHQAKxQqpSc9P4mTeje1Bf9ebbhE1nQZpLRXb2JFtbDWWsCEFKhdQ/xdYKgmQ=
Authentication-Results: vger.kernel.org; dkim=none (message not signed)
	header.d=none; vger.kernel.org;
	dmarc=none action=none header.from=amd.com; 
Received: from [127.0.1.1] (165.204.77.1) by
	DM5PR12MB1610.namprd12.prod.outlook.com (10.172.40.16) with Microsoft
	SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P384) id
	15.1.947.12; Thu, 2 Mar 2017 15:17:26 +0000
Subject: [RFC PATCH v2 24/32] kvm: x86: prepare for SEV guest management API
	support
From: Brijesh Singh &lt;brijesh.singh@amd.com&gt;
To: &lt;simon.guinot@sequanux.org&gt;, &lt;linux-efi@vger.kernel.org&gt;,
	&lt;brijesh.singh@amd.com&gt;, &lt;kvm@vger.kernel.org&gt;,
	&lt;rkrcmar@redhat.com&gt;, &lt;matt@codeblueprint.co.uk&gt;,
	&lt;linux-pci@vger.kernel.org&gt;, &lt;linus.walleij@linaro.org&gt;,
	&lt;gary.hook@amd.com&gt;, &lt;linux-mm@kvack.org&gt;,
	&lt;paul.gortmaker@windriver.com&gt;, &lt;hpa@zytor.com&gt;, &lt;cl@linux.com&gt;,
	&lt;dan.j.williams@intel.com&gt;, &lt;aarcange@redhat.com&gt;,
	&lt;sfr@canb.auug.org.au&gt;, &lt;andriy.shevchenko@linux.intel.com&gt;,
	&lt;herbert@gondor.apana.org.au&gt;, &lt;bhe@redhat.com&gt;,
	&lt;xemul@parallels.com&gt;, &lt;joro@8bytes.org&gt;, &lt;x86@kernel.org&gt;,
	&lt;peterz@infradead.org&gt;, &lt;piotr.luc@intel.com&gt;, &lt;mingo@redhat.com&gt;,
	&lt;msalter@redhat.com&gt;, &lt;ross.zwisler@linux.intel.com&gt;, &lt;bp@suse.de&gt;,
	&lt;dyoung@redhat.com&gt;, &lt;thomas.lendacky@amd.com&gt;, &lt;jroedel@suse.de&gt;,
	&lt;keescook@chromium.org&gt;, &lt;arnd@arndb.de&gt;, &lt;toshi.kani@hpe.com&gt;,
	&lt;mathieu.desnoyers@efficios.com&gt;, &lt;luto@kernel.org&gt;,
	&lt;devel@linuxdriverproject.org&gt;, &lt;bhelgaas@google.com&gt;,
	&lt;tglx@linutronix.de&gt;, &lt;mchehab@kernel.org&gt;,
	&lt;iamjoonsoo.kim@lge.com&gt;, &lt;labbott@fedoraproject.org&gt;,
	&lt;tony.luck@intel.com&gt;, &lt;alexandre.bounine@idt.com&gt;,
	&lt;kuleshovmail@gmail.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	&lt;mcgrof@kernel.org&gt;, &lt;mst@redhat.com&gt;,
	&lt;linux-crypto@vger.kernel.org&gt;, &lt;tj@kernel.org&gt;,
	&lt;pbonzini@redhat.com&gt;, &lt;akpm@linux-foundation.org&gt;, &lt;davem@davemloft.net&gt;
Date: Thu, 2 Mar 2017 10:17:22 -0500
Message-ID: &lt;148846784278.2349.17771314083820274411.stgit@brijesh-build-machine&gt;
In-Reply-To: &lt;148846752022.2349.13667498174822419498.stgit@brijesh-build-machine&gt;
References: &lt;148846752022.2349.13667498174822419498.stgit@brijesh-build-machine&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: BN6PR17CA0002.namprd17.prod.outlook.com (10.173.147.12) To
	DM5PR12MB1610.namprd12.prod.outlook.com (10.172.40.16)
X-MS-Office365-Filtering-Correlation-Id: a603cbfb-dcee-4c1b-f216-08d4617f3e92
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0; RULEID:(22001)(48565401081);
	SRVR:DM5PR12MB1610; 
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1610;
	3:3rwDFMak7XXHt4ud2HmmP1D26747cg6y1uqVUPcIG9xweNjJeGiU96Yj2y/XmRk/nSZKuLesMKvkj70FM6FSboaIrX76NOSGAmID+SfUSWkCdhiIdOnOUzrw5UWWozw0lhYi3zMeqgaLUwWM9idSxjytSZM69ebVGexhqNp58Q5aLG/qQK9IqXbR+D6cqw1QbaaQIgbID6L1OlqRhIlGltVCuKT0h2ZmqrITMiviEf1142OUvTPOFPqU3MlL2aBfelOPONIbGj4MQlDCiVsWB63rRcqgwiXu0i8qS6e69Cg=;
	25:xqpBrr2dPOWiChXgV77mQTS2K48b9sgknEXH510ou1ruk6nulTzko1LYhcXJvnRk3AtS640bNbkVK9nAuC8BEGWScOYlHhWHbGO48Oz6OTjiDKkuC6OpE183ucJrjtR1y4p0Oxo5qQXRbspXxyo5LdWQg2nFwRo9sJWyrshUVUpsriluGY2gTXBSeyfsOnd0TO/lcqhazMYhU+ZQ/uXp5fNcImDolIOyopk9mj7xXkZch29oDas7pbGnPPAV5esiGfrUqtUOM4LhRiSyfjfP3xImMkU8suwSCW2kKvwBnEElASgSTn2sy0qZm30NlaCe1lz9bFabgJBZ25Mxor4/Vzfuax3r98aR7cOQxzHvFtcfJnW7a/FNm55jRuS/MBtw+tUgYFibpWObmMPJ+TCiiwkcn/4Y/BYjNe0IW+c7iMglogBwJcY/aeEtZzKKG35S
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1610;
	31:P6hTFzMg8ISsPy3avF6XG/NpvfKvkWbGUHA+yPSnViTzH0ED5yNsSJls6ABHAP8k2aSogKAuZbuNmoByl367gOW/4eJKfGdGP7wLGevAsCMDioZqLyw5GRefWjMquvWrlJhYBOe8TMrv3uSKL5s1NDuoheRo/u9iGO4uNRzf27zPFp27qm1qsgk14f2uwKcR37097LNyDmjYVf2Gib4qa1uOQDV8MCcI8xes8g0OfMs=;
	20:BhRqSTRDjc5Of6cQggFeAl/tgLwVHYkvu8l7R09O3qTX2c+cktTWLT4rWFgmcR3UexM4QNxvzTV/z3757nupgnwqkjVleD1KmPvBncOFgbUpdI3q0bNZDi5ilUlJgtqnCb3wWiIvaX+BbRbvtKMyd2+JdzUC/kzGsry/gcx0pRZAc9+r5ttUlYZbiRd/VhrsbKYHhvMh4vtGpZX1p5ldZp45PKN7n6kbYYjWLr+tXQH501V1n9SEKyZfybZWdF5OsTQl7LA1iz1gtqtZFBiRGoH1TWi5CoZuVpkU5t1IrIjggvut69EyyoOrDlRcSDg7MjlFg386ztsZNh5wq/j0WJhlsHz7AK/yydHuj8cSmYFbzNe0gdHbOeVbTgYV6oqrNIlMCAAn2a88axoWngldCJK5kK1zg2Bh0/qU8/ipgETLi5R1yoB4u/mM0uOiyyAF2dcfym8SQVQFMcEEh5y4znu0RDAa0lJGgKzu2MwvFk2wqMMG9zqTohSgYs1Hpbjp
X-Microsoft-Antispam-PRVS: &lt;DM5PR12MB161050D5C8BDF38F0B4D56E0E5280@DM5PR12MB1610.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(6040375)(601004)(2401047)(8121501046)(5005006)(10201501046)(3002001)(6055026)(6041248)(20161123555025)(20161123564025)(20161123562025)(20161123558025)(20161123560025)(6072148);
	SRVR:DM5PR12MB1610; BCL:0; PCL:0; RULEID:; SRVR:DM5PR12MB1610;
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1610;
	4:+sCCXQ8KjKTdr8OCbnKVZzinT0gMzKt97zgZ4k14yHtUTVJvUfYmPZPfdKycTtP16Qs+bW3XlC1+ziqdB/3Sj4fRzZpO9KVoQmT2Wa3gabY6eE6WLVx8/ahjPGsHa0ecDWMe/L1Qk+M0egwrr4KinPT6QlwL4TnFgLkZ5qxG24ceC1o6PFznOW+NgWWP26GQKnqg7sddRy29ymgKnMLkV4368l4gRPHgkljuMpHjWzUFTPsg4ckrvMoIkI6rNcADLTUlj2GC5e9Qm/tqpWMRosmE1+GaXuPTmnaIEu3nD2eOSh95dJkFX3qh0xDeT/Vs4CyAaxoXwX1boFGshkkrAiVPfgYpIJ1fJRIPn+DHcvB62vUEjPcDKK0pHdV323kMehyRT+IdRfBEb7GGFipCyqDbxkvE+1+mvkwuu++IBiO7x80d24QWqcTXXASPY/K/C27Lk8+HL7xp9APklo5tUN45x3H7SzhsoQgKma7QWOfjlyv00etv0hNvQFDD5J4gdvStwXKzFbMiL9Yd87RocXAaxLTMZaFRG3TOqcTBqoNssp6B11a94TC0HsJnURkZYTO8o+BMk2rgWJvd0TFA25SnxgiX63P8CdO7oYdOahd1qoUAVSFbF0Lpe+cEsXxlk0xQdfdZx0EhytZObgFce0034HI6qRMSPtthajYFDJs=
X-Forefront-PRVS: 023495660C
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6049001)(6009001)(7916002)(39850400002)(39860400002)(39840400002)(39410400002)(39450400003)(50466002)(2906002)(9686003)(50986999)(76176999)(33646002)(54356999)(7416002)(2201001)(2950100002)(103116003)(7406005)(23676002)(5660300001)(7736002)(4001350100001)(189998001)(83506001)(8676002)(38730400002)(1191002)(305945005)(53936002)(42186005)(6486002)(47776003)(77096006)(230700001)(6116002)(3846002)(33716001)(90366009)(6666003)(66066001)(86362001)(25786008)(81166006)(92566002)(921003)(84006005)(2101003)(217873001)(83996005)(1121003);
	DIR:OUT; SFP:1101; SCL:1; SRVR:DM5PR12MB1610; H:[127.0.1.1];
	FPR:; SPF:None; MLV:sfv; LANG:en; 
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtETTVQUjEyTUIxNjEwOzIzOm9tL0xaRCtxd2QySWhiV3U3RmFJbkx5cE94?=
	=?utf-8?B?SnJJMjYyanIyYll1djJLdlBJUEdtVlNQSnZXZ0FCUVFqRWExNWRaYzJqaEhD?=
	=?utf-8?B?bVBFRk90RUR0Yng4SWpFK1BXZTgvbDh5RElVWExDTmxuYmhHT2ptN05LTkxT?=
	=?utf-8?B?a2tud0ZVcUNqdzR4YityaHpHZEdINy9ET0pSWVZka0prZVpvOStkRHJRRkZv?=
	=?utf-8?B?ckwrRkxUUjRwNEo5UzdrWnNTM285T2hKT0JnSSs1T0xXN1M5NERwMTBpRzU4?=
	=?utf-8?B?YXo1aG5icXRBWldUa3Y1blJJNzdjTU9OUkI4dVRKV0xpeFpWcTNOZmxTaDk0?=
	=?utf-8?B?emJVTDVlekM0YUROTkxkL2Rqa3Uzc3RUbytiNjhrQ01lUUk4cXFGRkxFVTE5?=
	=?utf-8?B?T0FqaVBLR3R5MnFkZEZ5UmpGaHB6VjZ4UGNLTVA1ejNvaTR5Zk4wOGZibnJV?=
	=?utf-8?B?c2RES0tzZGRMRE5qaG94d2MxKzYrSkFYb3BJY0F5d2pqd1dJd2UvQXg0OFIy?=
	=?utf-8?B?R1hROHV5Q2lzSkdnb3cvRWxHMldldDZvMElVaVV0SVR2V0UyU28xRUpzNmVX?=
	=?utf-8?B?Z3RtQy9DS1JGWm00eUVCRmxlcUdXQkUxbTJhQXUrVml2aXNtcFVZMGw4WExX?=
	=?utf-8?B?N0pHUUxjZ0QvamlkOFNtOGU4dDRWR3ZXL3F6Y3V1UDRtWkp1ZWZLUm94Vlpa?=
	=?utf-8?B?U3hYRThDc3FqYzNqNkZoUmxqQWtMaE56aW9rOUZlaTNnS21EbkJ3cFBQeVcx?=
	=?utf-8?B?aVhmdHk3L2xBNmd6U3VWSTh2cVo0NmFDZ0lKaGZaRkk2N0t4bW5HZ25RN1RR?=
	=?utf-8?B?b0g0ZmVWcm9CSkxZSEEwT2EwTWFNVGg3K3VjWlFhVWJrK0pLTklNWFBBa0do?=
	=?utf-8?B?a3VDSWNCUFRMOXRpV3l1QlFTY2xCTkxBYmVmanpJQ1NNdDVDWEZWKzlEUmpO?=
	=?utf-8?B?MEhUaWI4RjJvRWoxMTA0M1BoUTlGZ3EvemtkZy95aXcvYlBYc0ZDOVFKaHZt?=
	=?utf-8?B?MzFDN3ZNYlBiQUhSek5HUml0am5qTWlNR01kWWlqR2hRUGpBLzhRczMxZG55?=
	=?utf-8?B?ZzNFaFdFVnhpRVNHWnNiNUp2LzFFeGQ4SjhnT3AyMURWaG8rYVFjTUM3RWVa?=
	=?utf-8?B?UWIvMElXOS84ZkRDT0dqM1M3b05lSFd5U2xGaFlBL09vL3NUcVZtckRYQm85?=
	=?utf-8?B?MkNERnlWMCsvVnBvWXc4dGtjQXJSUzJTVHBtV1FzeVZ3Y2VuODFSMDB5SDhY?=
	=?utf-8?B?SmZReVh4Tk5VMnZyU2VuMzBSd2M4MVllNDNQbk5wd01QanhUUllLemd3WlZ6?=
	=?utf-8?B?TlFFZnNzYjFMVTloRkF3VlEreGI1eDIwNFdEWUorOUhIRlNybHpybktObDVv?=
	=?utf-8?B?cHRzODNJU1AzYWxBS2gvc2MrY2hvQkxFZFQrTysyais0V3lPME5IU0xxd0l4?=
	=?utf-8?B?dzBFaTdQaVJrWnk5T0Jyc0k0WWx2QTFzY2N0b1d4SGZES0g4S3ZNL2NDRkNw?=
	=?utf-8?B?MUlSWFBFb0trbnJYUUtIeml2UXFraGI0RzFqODJuQzdsU0ltSzFBWTlpOVBU?=
	=?utf-8?B?VGZWQmNoVVp6cDVNOEJjTWEzbG04OCtoanFCREt1RTFPTXpGSFV2dXk5YlBu?=
	=?utf-8?B?MmZ3bGZFS1luTDBRdUdpREpad1lSQnBNTlMwbVBMclhXcG1OMHdkeU1OOCth?=
	=?utf-8?B?K1B3RzIrVGZxUmo4SmhJSDZVTnFHOFQyVlEzekpvVnR2Q3N2amludDZWNWdi?=
	=?utf-8?B?YUtRWEx1TUtLT3pvc2tPUT09?=
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1610;
	6:o68Ua4eb8bllZxslkdWH0DEyjf3Q1Rk5KDrL/8UqTa6N0ruObTpIO3oLr29JcFEmwHYAVVKFUVjdBQE6ORfSspu0lZtbp1bFsiKfPCcyWFMSSmEXtFlRB84K2RIgJPE6TUwUt/YslJ4I8KysELJqcsV/4Ge+AZmAx/mqqIp/Zj2d0h1YDfRFZSdQuuRxZEaSy0xHx37D/YaNzzjixjLccieU86kb19c79HYhOZcibvPtuD1RkJd7xAJ7PA0s5IQ7c18DAiHQwXMqDuZlE5923LXyVKjN+Eios8y5zowEmT07bUFU75bTZbj6bO3VsOHn81d6hcsi/vkwA7j0fsPn6KrCVYvxI4hIduvWF8FCfpCwurSfKMkUpx7MoqxHUXdR5MulvtIOzn0yK6ghX8mrjz80kdJhNVYxD/WdHhtScgk=;
	5:rGMR1UnqLXH6ZuynpdJPXda56NUOsFQUNpRanhvOjnOsW1sf5fxQMSsk8ESwhTESGIBukW1VFqG7OeY+lybXICaHZ6kk0iKTPpidtWaSGX34aPnslqmyByeQT92RhJFPk2+h2zO8/EzZi1ITffJJtw==;
	24:oJrG9LOOBi8qB6u5qv4LvtFfiDh7TMZJvDYggCo0kNKzXvTB5ol/T0kma8j5Xjeva9dSjzeK2uNcabdTpwMJ32K7rqX2cfQ04cMlSG+nY/0=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; DM5PR12MB1610;
	7:Nlr7sHYQ1Mvq/6yhTKnh1Sn6GGZvEuktQcWGcU0f9ylHnH2YnyXaFu+yJFvAwFbX9MEcBphy3E3OPAZhqbWD46Xa/x9NjQcfwd4cXb82bAQHJA9kvDOhDRy+3YDvqR71g4CAt7k5uX/jdNlc+f8xZAzvILuT8zQWfQ3iVftmO6DvxtgzlCDOw20cHrnv/NyCB/ew+FSttLB99LMzrTnA/w8QgJlXPWwktszdPeI4xarx4jI3TxfYk2cyzK8m9HuTh8wvP1F2AfUMVbkNQwOjeCmKc42yQuFdmG2IWRzzkWImysEr/Z6Wpsf9GmNG7kQlGBTrUrEBxitwOQ/yJADOFQ==;
	20:bd09UplDCicDOmJdtbRslW3LvLVgcU2bRlbbsdl8iA0hreEX5UMzlpEaXcKkr1J7azfJ/ArDvEx2fzEAfFIwq6DZ9/JwD+xBKl0BwGsCBzcAChZ/kkAvArDpO4A+FqeyJVGOGUEWesTpqsSeRLOxwMDylz4kZx6TQpjE/tVK0FSVdLjJrielZN34XNlHTptKANgHiB981vHkNtYAbNTndAF5P5ZkFdDzk5zsz+tpa9EoopVNXbQB/QNXOgtYK3xX
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 02 Mar 2017 15:17:26.0654
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DM5PR12MB1610
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=150921">Brijesh Singh</a> - March 2, 2017, 3:17 p.m.</div>
<pre class="content">
The patch adds initial support required to integrate Secure Encrypted
Virtualization (SEV) feature.

ASID management:
 - Reserve asid range for SEV guest, SEV asid range is obtained through
   CPUID Fn8000_001f[ECX]. A non-SEV guest can use any asid outside the SEV
   asid range.
 - SEV guest must have asid value within asid range obtained through CPUID.
 - SEV guest must have the same asid for all vcpu&#39;s. A TLB flush is required
   if different vcpu for the same ASID is to be run on the same host CPU.
<span class="signed-off-by">
Signed-off-by: Brijesh Singh &lt;brijesh.singh@amd.com&gt;</span>
---
 arch/x86/include/asm/kvm_host.h |    8 ++
 arch/x86/kvm/svm.c              |  189 +++++++++++++++++++++++++++++++++++++++
 include/uapi/linux/kvm.h        |   98 ++++++++++++++++++++
 3 files changed, 294 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2536">Paolo Bonzini</a> - March 16, 2017, 10:33 a.m.</div>
<pre class="content">
On 02/03/2017 16:17, Brijesh Singh wrote:
<span class="quote">&gt; ASID management:</span>
<span class="quote">&gt;  - Reserve asid range for SEV guest, SEV asid range is obtained through</span>
<span class="quote">&gt;    CPUID Fn8000_001f[ECX]. A non-SEV guest can use any asid outside the SEV</span>
<span class="quote">&gt;    asid range.</span>

How is backwards compatibility handled?
<span class="quote">
&gt;  - SEV guest must have asid value within asid range obtained through CPUID.</span>
<span class="quote">&gt;  - SEV guest must have the same asid for all vcpu&#39;s. A TLB flush is required</span>
<span class="quote">&gt;    if different vcpu for the same ASID is to be run on the same host CPU.</span>

[...]
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	/* which host cpu was used for running this vcpu */</span>
<span class="quote">&gt; +	bool last_cpuid;</span>

Should be unsigned int.
<span class="quote">
&gt; </span>
<span class="quote">&gt; +	/* Assign the asid allocated for this SEV guest */</span>
<span class="quote">&gt; +	svm-&gt;vmcb-&gt;control.asid = asid;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Flush guest TLB:</span>
<span class="quote">&gt; +	 * - when different VMCB for the same ASID is to be run on the</span>
<span class="quote">&gt; +	 *   same host CPU</span>
<span class="quote">&gt; +	 *   or</span>
<span class="quote">&gt; +	 * - this VMCB was executed on different host cpu in previous VMRUNs.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (sd-&gt;sev_vmcbs[asid] != (void *)svm-&gt;vmcb ||</span>

Why the cast?
<span class="quote">
&gt; +		svm-&gt;last_cpuid != cpu)</span>
<span class="quote">&gt; +		svm-&gt;vmcb-&gt;control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;</span>

If there is a match, you don&#39;t need to do anything else (neither reset
the asid, nor mark it as dirty, nor update the fields), so:

	if (sd-&gt;sev_vmcbs[asid] == svm-&gt;vmcb &amp;&amp;
	    svm-&gt;last_cpuid == cpu)
		return;

	svm-&gt;last_cpuid = cpu;
	sd-&gt;sev_vmcbs[asid] = svm-&gt;vmcb;
	svm-&gt;vmcb-&gt;control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;
	svm-&gt;vmcb-&gt;control.asid = asid;
	mark_dirty(svm-&gt;vmcb, VMCB_ASID);

(plus comments ;)).

Also, why not TLB_CONTROL_FLUSH_ASID if possible?
<span class="quote">
&gt; +	svm-&gt;last_cpuid = cpu;</span>
<span class="quote">&gt; +	sd-&gt;sev_vmcbs[asid] = (void *)svm-&gt;vmcb;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mark_dirty(svm-&gt;vmcb, VMCB_ASID);</span>

[...]
<span class="quote">
&gt; </span>
<span class="quote">&gt; diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h</span>
<span class="quote">&gt; index fef7d83..9df37a2 100644</span>
<span class="quote">&gt; --- a/include/uapi/linux/kvm.h</span>
<span class="quote">&gt; +++ b/include/uapi/linux/kvm.h</span>
<span class="quote">&gt; @@ -1284,6 +1284,104 @@ struct kvm_s390_ucas_mapping {</span>
<span class="quote">&gt;  /* Memory Encryption Commands */</span>
<span class="quote">&gt;  #define KVM_MEMORY_ENCRYPT_OP	  _IOWR(KVMIO, 0xb8, unsigned long)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* Secure Encrypted Virtualization mode */</span>
<span class="quote">&gt; +enum sev_cmd_id {</span>

Please add documentation in Documentation/virtual/kvm/memory_encrypt.txt.

Paolo
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 62651ad..fcc4710 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -719,6 +719,12 @@</span> <span class="p_context"> struct kvm_hv {</span>
 	HV_REFERENCE_TSC_PAGE tsc_ref;
 };
 
<span class="p_add">+struct kvm_sev_info {</span>
<span class="p_add">+	unsigned int handle;	/* firmware handle */</span>
<span class="p_add">+	unsigned int asid;	/* asid for this guest */</span>
<span class="p_add">+	int sev_fd;		/* SEV device fd */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct kvm_arch {
 	unsigned int n_used_mmu_pages;
 	unsigned int n_requested_mmu_pages;
<span class="p_chunk">@@ -805,6 +811,8 @@</span> <span class="p_context"> struct kvm_arch {</span>
 
 	bool x2apic_format;
 	bool x2apic_broadcast_quirk_disabled;
<span class="p_add">+</span>
<span class="p_add">+	struct kvm_sev_info sev_info;</span>
 };
 
 struct kvm_vm_stat {
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 8d8fe62..fb63398 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/amd-iommu.h&gt;
 #include &lt;linux/hashtable.h&gt;
<span class="p_add">+#include &lt;linux/psp-sev.h&gt;</span>
 
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/perf_event.h&gt;
<span class="p_chunk">@@ -211,6 +212,9 @@</span> <span class="p_context"> struct vcpu_svm {</span>
 	 */
 	struct list_head ir_list;
 	spinlock_t ir_list_lock;
<span class="p_add">+</span>
<span class="p_add">+	/* which host cpu was used for running this vcpu */</span>
<span class="p_add">+	bool last_cpuid;</span>
 };
 
 /*
<span class="p_chunk">@@ -490,6 +494,64 @@</span> <span class="p_context"> static inline bool gif_set(struct vcpu_svm *svm)</span>
 	return !!(svm-&gt;vcpu.arch.hflags &amp; HF_GIF_MASK);
 }
 
<span class="p_add">+/* Secure Encrypted Virtualization */</span>
<span class="p_add">+static unsigned int max_sev_asid;</span>
<span class="p_add">+static unsigned long *sev_asid_bitmap;</span>
<span class="p_add">+</span>
<span class="p_add">+static bool kvm_sev_enabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return max_sev_asid ? 1 : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct kvm_sev_info *sev_get_info(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_arch *vm_data = &amp;kvm-&gt;arch;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;vm_data-&gt;sev_info;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int sev_get_handle(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_sev_info *sev_info = sev_get_info(kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	return sev_info-&gt;handle;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int sev_guest(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sev_get_handle(kvm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int sev_get_asid(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_sev_info *sev_info = sev_get_info(kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sev_info)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sev_info-&gt;asid;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int sev_get_fd(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_sev_info *sev_info = sev_get_info(kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sev_info)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sev_info-&gt;sev_fd;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sev_set_asid(struct kvm *kvm, int asid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_sev_info *sev_info = sev_get_info(kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sev_info)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	sev_info-&gt;asid = asid;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static unsigned long iopm_base;
 
 struct kvm_ldttss_desc {
<span class="p_chunk">@@ -511,6 +573,8 @@</span> <span class="p_context"> struct svm_cpu_data {</span>
 	struct kvm_ldttss_desc *tss_desc;
 
 	struct page *save_area;
<span class="p_add">+</span>
<span class="p_add">+	struct vmcb **sev_vmcbs;  /* index = sev_asid, value = vmcb pointer */</span>
 };
 
 static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);
<span class="p_chunk">@@ -764,7 +828,7 @@</span> <span class="p_context"> static int svm_hardware_enable(void)</span>
 	sd-&gt;asid_generation = 1;
 	sd-&gt;max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;
 	sd-&gt;next_asid = sd-&gt;max_asid + 1;
<span class="p_del">-	sd-&gt;min_asid = 1;</span>
<span class="p_add">+	sd-&gt;min_asid = max_sev_asid + 1;</span>
 
 	native_store_gdt(&amp;gdt_descr);
 	gdt = (struct desc_struct *)gdt_descr.address;
<span class="p_chunk">@@ -825,6 +889,7 @@</span> <span class="p_context"> static void svm_cpu_uninit(int cpu)</span>
 
 	per_cpu(svm_data, raw_smp_processor_id()) = NULL;
 	__free_page(sd-&gt;save_area);
<span class="p_add">+	kfree(sd-&gt;sev_vmcbs);</span>
 	kfree(sd);
 }
 
<span class="p_chunk">@@ -842,6 +907,14 @@</span> <span class="p_context"> static int svm_cpu_init(int cpu)</span>
 	if (!sd-&gt;save_area)
 		goto err_1;
 
<span class="p_add">+	if (kvm_sev_enabled()) {</span>
<span class="p_add">+		sd-&gt;sev_vmcbs = kmalloc((max_sev_asid + 1) * sizeof(void *),</span>
<span class="p_add">+					GFP_KERNEL);</span>
<span class="p_add">+		r = -ENOMEM;</span>
<span class="p_add">+		if (!sd-&gt;sev_vmcbs)</span>
<span class="p_add">+			goto err_1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	per_cpu(svm_data, cpu) = sd;
 
 	return 0;
<span class="p_chunk">@@ -1017,6 +1090,61 @@</span> <span class="p_context"> static int avic_ga_log_notifier(u32 ga_tag)</span>
 	return 0;
 }
 
<span class="p_add">+static __init void sev_hardware_setup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret, error, nguests;</span>
<span class="p_add">+	struct sev_data_init *init;</span>
<span class="p_add">+	struct sev_data_status *status;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Get maximum number of encrypted guest supported: Fn8001_001F[ECX]</span>
<span class="p_add">+	 * 	Bit 31:0: Number of supported guest</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	nguests = cpuid_ecx(0x8000001F);</span>
<span class="p_add">+	if (!nguests)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	init = kzalloc(sizeof(*init), GFP_KERNEL);</span>
<span class="p_add">+	if (!init)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	status = kzalloc(sizeof(*status), GFP_KERNEL);</span>
<span class="p_add">+	if (!status)</span>
<span class="p_add">+		goto err_1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize SEV firmware */</span>
<span class="p_add">+	ret = sev_platform_init(init, &amp;error);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;SEV: PLATFORM_INIT ret=%d (%#x)\n&quot;, ret, error);</span>
<span class="p_add">+		goto err_2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize SEV ASID bitmap */</span>
<span class="p_add">+	sev_asid_bitmap = kcalloc(BITS_TO_LONGS(nguests),</span>
<span class="p_add">+				  sizeof(unsigned long), GFP_KERNEL);</span>
<span class="p_add">+	if (IS_ERR(sev_asid_bitmap)) {</span>
<span class="p_add">+		sev_platform_shutdown(&amp;error);</span>
<span class="p_add">+		goto err_2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Query the platform status and print API version */</span>
<span class="p_add">+	ret = sev_platform_status(status, &amp;error);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;SEV: PLATFORM_STATUS ret=%#x\n&quot;, error);</span>
<span class="p_add">+		goto err_2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	max_sev_asid = nguests;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;kvm: SEV enabled\n&quot;);</span>
<span class="p_add">+	printk(KERN_INFO &quot;SEV API: %d.%d\n&quot;,</span>
<span class="p_add">+			status-&gt;api_major, status-&gt;api_minor);</span>
<span class="p_add">+err_2:</span>
<span class="p_add">+	kfree(status);</span>
<span class="p_add">+err_1:</span>
<span class="p_add">+	kfree(init);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __init int svm_hardware_setup(void)
 {
 	int cpu;
<span class="p_chunk">@@ -1052,6 +1180,9 @@</span> <span class="p_context"> static __init int svm_hardware_setup(void)</span>
 		kvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);
 	}
 
<span class="p_add">+	if (boot_cpu_has(X86_FEATURE_SEV))</span>
<span class="p_add">+		sev_hardware_setup();</span>
<span class="p_add">+</span>
 	for_each_possible_cpu(cpu) {
 		r = svm_cpu_init(cpu);
 		if (r)
<span class="p_chunk">@@ -1094,10 +1225,25 @@</span> <span class="p_context"> static __init int svm_hardware_setup(void)</span>
 	return r;
 }
 
<span class="p_add">+static __exit void sev_hardware_unsetup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = sev_platform_shutdown(&amp;err);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		printk(KERN_ERR &quot;failed to shutdown PSP rc=%d (%#0x10x)\n&quot;,</span>
<span class="p_add">+		ret, err);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(sev_asid_bitmap);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __exit void svm_hardware_unsetup(void)
 {
 	int cpu;
 
<span class="p_add">+	if (kvm_sev_enabled())</span>
<span class="p_add">+		sev_hardware_unsetup();</span>
<span class="p_add">+</span>
 	for_each_possible_cpu(cpu)
 		svm_cpu_uninit(cpu);
 
<span class="p_chunk">@@ -1157,6 +1303,11 @@</span> <span class="p_context"> static void avic_init_vmcb(struct vcpu_svm *svm)</span>
 	svm-&gt;vcpu.arch.apicv_active = true;
 }
 
<span class="p_add">+static void sev_init_vmcb(struct vcpu_svm *svm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	svm-&gt;vmcb-&gt;control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void init_vmcb(struct vcpu_svm *svm)
 {
 	struct vmcb_control_area *control = &amp;svm-&gt;vmcb-&gt;control;
<span class="p_chunk">@@ -1271,6 +1422,9 @@</span> <span class="p_context"> static void init_vmcb(struct vcpu_svm *svm)</span>
 	if (avic)
 		avic_init_vmcb(svm);
 
<span class="p_add">+	if (sev_guest(svm-&gt;vcpu.kvm))</span>
<span class="p_add">+		sev_init_vmcb(svm);</span>
<span class="p_add">+</span>
 	mark_all_dirty(svm-&gt;vmcb);
 
 	enable_gif(svm);
<span class="p_chunk">@@ -2084,6 +2238,11 @@</span> <span class="p_context"> static int pf_interception(struct vcpu_svm *svm)</span>
 	default:
 		error_code = svm-&gt;vmcb-&gt;control.exit_info_1;
 
<span class="p_add">+		/* In SEV mode, the guest physical address will have C-bit</span>
<span class="p_add">+		 * set. C-bit must be cleared before handling the fault.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (sev_guest(svm-&gt;vcpu.kvm))</span>
<span class="p_add">+			fault_address &amp;= ~sme_me_mask;</span>
 		trace_kvm_page_fault(fault_address, error_code);
 		if (!npt_enabled &amp;&amp; kvm_event_needs_reinjection(&amp;svm-&gt;vcpu))
 			kvm_mmu_unprotect_page_virt(&amp;svm-&gt;vcpu, fault_address);
<span class="p_chunk">@@ -4258,12 +4417,40 @@</span> <span class="p_context"> static void reload_tss(struct kvm_vcpu *vcpu)</span>
 	load_TR_desc();
 }
 
<span class="p_add">+static void pre_sev_run(struct vcpu_svm *svm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int asid = sev_get_asid(svm-&gt;vcpu.kvm);</span>
<span class="p_add">+	int cpu = raw_smp_processor_id();</span>
<span class="p_add">+	struct svm_cpu_data *sd = per_cpu(svm_data, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Assign the asid allocated for this SEV guest */</span>
<span class="p_add">+	svm-&gt;vmcb-&gt;control.asid = asid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush guest TLB:</span>
<span class="p_add">+	 * - when different VMCB for the same ASID is to be run on the</span>
<span class="p_add">+	 *   same host CPU</span>
<span class="p_add">+	 *   or</span>
<span class="p_add">+	 * - this VMCB was executed on different host cpu in previous VMRUNs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sd-&gt;sev_vmcbs[asid] != (void *)svm-&gt;vmcb ||</span>
<span class="p_add">+		svm-&gt;last_cpuid != cpu)</span>
<span class="p_add">+		svm-&gt;vmcb-&gt;control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;</span>
<span class="p_add">+</span>
<span class="p_add">+	svm-&gt;last_cpuid = cpu;</span>
<span class="p_add">+	sd-&gt;sev_vmcbs[asid] = (void *)svm-&gt;vmcb;</span>
<span class="p_add">+</span>
<span class="p_add">+	mark_dirty(svm-&gt;vmcb, VMCB_ASID);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void pre_svm_run(struct vcpu_svm *svm)
 {
 	int cpu = raw_smp_processor_id();
 
 	struct svm_cpu_data *sd = per_cpu(svm_data, cpu);
 
<span class="p_add">+	if (sev_guest(svm-&gt;vcpu.kvm))</span>
<span class="p_add">+		return pre_sev_run(svm);</span>
<span class="p_add">+</span>
 	/* FIXME: handle wraparound of asid_generation */
 	if (svm-&gt;asid_generation != sd-&gt;asid_generation)
 		new_asid(svm, sd);
<span class="p_header">diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h</span>
<span class="p_header">index fef7d83..9df37a2 100644</span>
<span class="p_header">--- a/include/uapi/linux/kvm.h</span>
<span class="p_header">+++ b/include/uapi/linux/kvm.h</span>
<span class="p_chunk">@@ -1284,6 +1284,104 @@</span> <span class="p_context"> struct kvm_s390_ucas_mapping {</span>
 /* Memory Encryption Commands */
 #define KVM_MEMORY_ENCRYPT_OP	  _IOWR(KVMIO, 0xb8, unsigned long)
 
<span class="p_add">+/* Secure Encrypted Virtualization mode */</span>
<span class="p_add">+enum sev_cmd_id {</span>
<span class="p_add">+	/* Guest launch commands */</span>
<span class="p_add">+	KVM_SEV_LAUNCH_START = 0,</span>
<span class="p_add">+	KVM_SEV_LAUNCH_UPDATE_DATA,</span>
<span class="p_add">+	KVM_SEV_LAUNCH_MEASURE,</span>
<span class="p_add">+	KVM_SEV_LAUNCH_FINISH,</span>
<span class="p_add">+	/* Guest migration commands (outgoing) */</span>
<span class="p_add">+	KVM_SEV_SEND_START,</span>
<span class="p_add">+	KVM_SEV_SEND_UPDATE_DATA,</span>
<span class="p_add">+	KVM_SEV_SEND_FINISH,</span>
<span class="p_add">+	/* Guest migration commands (incoming) */</span>
<span class="p_add">+	KVM_SEV_RECEIVE_START,</span>
<span class="p_add">+	KVM_SEV_RECEIVE_UPDATE_DATA,</span>
<span class="p_add">+	KVM_SEV_RECEIVE_FINISH,</span>
<span class="p_add">+	/* Guest status and debug commands */</span>
<span class="p_add">+	KVM_SEV_GUEST_STATUS,</span>
<span class="p_add">+	KVM_SEV_DBG_DECRYPT,</span>
<span class="p_add">+	KVM_SEV_DBG_ENCRYPT,</span>
<span class="p_add">+</span>
<span class="p_add">+	KVM_SEV_NR_MAX,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_cmd {</span>
<span class="p_add">+	__u32 id;</span>
<span class="p_add">+	__u64 data;</span>
<span class="p_add">+	__u32 error;</span>
<span class="p_add">+	__u32 sev_fd;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_launch_start {</span>
<span class="p_add">+	__u32 handle;</span>
<span class="p_add">+	__u32 policy;</span>
<span class="p_add">+	__u64 dh_cert_data;</span>
<span class="p_add">+	__u32 dh_cert_length;</span>
<span class="p_add">+	__u64 session_data;</span>
<span class="p_add">+	__u32 session_length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_launch_update_data {</span>
<span class="p_add">+	__u64 address;</span>
<span class="p_add">+	__u32 length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_launch_measure {</span>
<span class="p_add">+	__u64 address;</span>
<span class="p_add">+	__u32 length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_send_start {</span>
<span class="p_add">+	__u64 pdh_cert_data;</span>
<span class="p_add">+	__u32 pdh_cert_length;</span>
<span class="p_add">+	__u64 plat_cert_data;</span>
<span class="p_add">+	__u32 plat_cert_length;</span>
<span class="p_add">+	__u64 amd_cert_data;</span>
<span class="p_add">+	__u32 amd_cert_length;</span>
<span class="p_add">+	__u64 session_data;</span>
<span class="p_add">+	__u32 session_length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_send_update_data {</span>
<span class="p_add">+	__u64 hdr_data;</span>
<span class="p_add">+	__u32 hdr_length;</span>
<span class="p_add">+	__u64 guest_address;</span>
<span class="p_add">+	__u32 guest_length;</span>
<span class="p_add">+	__u64 host_address;</span>
<span class="p_add">+	__u32 host_length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_receive_start {</span>
<span class="p_add">+	__u32 handle;</span>
<span class="p_add">+	__u64 pdh_cert_data;</span>
<span class="p_add">+	__u32 pdh_cert_length;</span>
<span class="p_add">+	__u64 session_data;</span>
<span class="p_add">+	__u32 session_length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_receive_update_data {</span>
<span class="p_add">+	__u64 hdr_data;</span>
<span class="p_add">+	__u32 hdr_length;</span>
<span class="p_add">+	__u64 guest_address;</span>
<span class="p_add">+	__u32 guest_length;</span>
<span class="p_add">+	__u64 host_address;</span>
<span class="p_add">+	__u32 host_length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_guest_status {</span>
<span class="p_add">+	__u32 handle;</span>
<span class="p_add">+	__u32 policy;</span>
<span class="p_add">+	__u32 state;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sev_dbg {</span>
<span class="p_add">+	__u64 src_addr;</span>
<span class="p_add">+	__u64 dst_addr;</span>
<span class="p_add">+	__u32 length;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 &lt;&lt; 0)
 #define KVM_DEV_ASSIGN_PCI_2_3		(1 &lt;&lt; 1)
 #define KVM_DEV_ASSIGN_MASK_INTX	(1 &lt;&lt; 2)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



