
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.60 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.60</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 8, 2017, 8:07 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170408080724.GB14171@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9670987/mbox/"
   >mbox</a>
|
   <a href="/patch/9670987/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9670987/">/patch/9670987/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E01FF6020F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Apr 2017 08:08:28 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CD05028462
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Apr 2017 08:08:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BE877285D2; Sat,  8 Apr 2017 08:08:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CDCDF28462
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Apr 2017 08:08:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752240AbdDHIIL (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 8 Apr 2017 04:08:11 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:55126 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751867AbdDHIHf (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 8 Apr 2017 04:07:35 -0400
Received: from localhost (D57E6652.static.ziggozakelijk.nl [213.126.102.82])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 62A9640A;
	Sat,  8 Apr 2017 08:07:34 +0000 (UTC)
Date: Sat, 8 Apr 2017 10:07:24 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.60
Message-ID: &lt;20170408080724.GB14171@kroah.com&gt;
References: &lt;20170408080717.GA14171@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170408080717.GA14171@kroah.com&gt;
User-Agent: Mutt/1.8.0 (2017-02-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - April 8, 2017, 8:07 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 083724c6ca4d..fb7c2b40753d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 59</span>
<span class="p_add">+SUBLEVEL = 60</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c</span>
<span class="p_header">index 2e7f60c9fc5d..51cdc46a87e2 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/irq.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/irq.c</span>
<span class="p_chunk">@@ -269,6 +269,11 @@</span> <span class="p_context"> static void ltq_hw5_irqdispatch(void)</span>
 DEFINE_HWx_IRQDISPATCH(5)
 #endif
 
<span class="p_add">+static void ltq_hw_irq_handler(struct irq_desc *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ltq_hw_irqdispatch(irq_desc_get_irq(desc) - 2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_MIPS_MT_SMP
 void __init arch_init_ipiirq(int irq, struct irqaction *action)
 {
<span class="p_chunk">@@ -313,23 +318,19 @@</span> <span class="p_context"> static struct irqaction irq_call = {</span>
 asmlinkage void plat_irq_dispatch(void)
 {
 	unsigned int pending = read_c0_status() &amp; read_c0_cause() &amp; ST0_IM;
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((MIPS_CPU_TIMER_IRQ == 7) &amp;&amp; (pending &amp; CAUSEF_IP7)) {</span>
<span class="p_del">-		do_IRQ(MIPS_CPU_TIMER_IRQ);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		for (i = 0; i &lt; MAX_IM; i++) {</span>
<span class="p_del">-			if (pending &amp; (CAUSEF_IP2 &lt;&lt; i)) {</span>
<span class="p_del">-				ltq_hw_irqdispatch(i);</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+	int irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pending) {</span>
<span class="p_add">+		spurious_interrupt();</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_del">-	pr_alert(&quot;Spurious IRQ: CAUSE=0x%08x\n&quot;, read_c0_status());</span>
 
<span class="p_del">-out:</span>
<span class="p_del">-	return;</span>
<span class="p_add">+	pending &gt;&gt;= CAUSEB_IP;</span>
<span class="p_add">+	while (pending) {</span>
<span class="p_add">+		irq = fls(pending) - 1;</span>
<span class="p_add">+		do_IRQ(MIPS_CPU_IRQ_BASE + irq);</span>
<span class="p_add">+		pending &amp;= ~BIT(irq);</span>
<span class="p_add">+	}</span>
 }
 
 static int icu_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hw)
<span class="p_chunk">@@ -354,11 +355,6 @@</span> <span class="p_context"> static const struct irq_domain_ops irq_domain_ops = {</span>
 	.map = icu_map,
 };
 
<span class="p_del">-static struct irqaction cascade = {</span>
<span class="p_del">-	.handler = no_action,</span>
<span class="p_del">-	.name = &quot;cascade&quot;,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 int __init icu_of_init(struct device_node *node, struct device_node *parent)
 {
 	struct device_node *eiu_node;
<span class="p_chunk">@@ -390,7 +386,7 @@</span> <span class="p_context"> int __init icu_of_init(struct device_node *node, struct device_node *parent)</span>
 	mips_cpu_irq_init();
 
 	for (i = 0; i &lt; MAX_IM; i++)
<span class="p_del">-		setup_irq(i + 2, &amp;cascade);</span>
<span class="p_add">+		irq_set_chained_handler(i + 2, ltq_hw_irq_handler);</span>
 
 	if (cpu_has_vint) {
 		pr_info(&quot;Setting up vectored interrupts\n&quot;);
<span class="p_header">diff --git a/arch/x86/xen/setup.c b/arch/x86/xen/setup.c</span>
<span class="p_header">index e345891450c3..df8844a1853a 100644</span>
<span class="p_header">--- a/arch/x86/xen/setup.c</span>
<span class="p_header">+++ b/arch/x86/xen/setup.c</span>
<span class="p_chunk">@@ -713,10 +713,9 @@</span> <span class="p_context"> static void __init xen_reserve_xen_mfnlist(void)</span>
 		size = PFN_PHYS(xen_start_info-&gt;nr_p2m_frames);
 	}
 
<span class="p_del">-	if (!xen_is_e820_reserved(start, size)) {</span>
<span class="p_del">-		memblock_reserve(start, size);</span>
<span class="p_add">+	memblock_reserve(start, size);</span>
<span class="p_add">+	if (!xen_is_e820_reserved(start, size))</span>
 		return;
<span class="p_del">-	}</span>
 
 #ifdef CONFIG_X86_32
 	/*
<span class="p_chunk">@@ -727,6 +726,7 @@</span> <span class="p_context"> static void __init xen_reserve_xen_mfnlist(void)</span>
 	BUG();
 #else
 	xen_relocate_p2m();
<span class="p_add">+	memblock_free(start, size);</span>
 #endif
 }
 
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 46e2cc1d4016..14263fab94d3 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -373,10 +373,14 @@</span> <span class="p_context"> static void punt_bios_to_rescuer(struct bio_set *bs)</span>
 	bio_list_init(&amp;punt);
 	bio_list_init(&amp;nopunt);
 
<span class="p_del">-	while ((bio = bio_list_pop(current-&gt;bio_list)))</span>
<span class="p_add">+	while ((bio = bio_list_pop(&amp;current-&gt;bio_list[0])))</span>
 		bio_list_add(bio-&gt;bi_pool == bs ? &amp;punt : &amp;nopunt, bio);
<span class="p_add">+	current-&gt;bio_list[0] = nopunt;</span>
 
<span class="p_del">-	*current-&gt;bio_list = nopunt;</span>
<span class="p_add">+	bio_list_init(&amp;nopunt);</span>
<span class="p_add">+	while ((bio = bio_list_pop(&amp;current-&gt;bio_list[1])))</span>
<span class="p_add">+		bio_list_add(bio-&gt;bi_pool == bs ? &amp;punt : &amp;nopunt, bio);</span>
<span class="p_add">+	current-&gt;bio_list[1] = nopunt;</span>
 
 	spin_lock(&amp;bs-&gt;rescue_lock);
 	bio_list_merge(&amp;bs-&gt;rescue_list, &amp;punt);
<span class="p_chunk">@@ -464,7 +468,9 @@</span> <span class="p_context"> struct bio *bio_alloc_bioset(gfp_t gfp_mask, int nr_iovecs, struct bio_set *bs)</span>
 		 * we retry with the original gfp_flags.
 		 */
 
<span class="p_del">-		if (current-&gt;bio_list &amp;&amp; !bio_list_empty(current-&gt;bio_list))</span>
<span class="p_add">+		if (current-&gt;bio_list &amp;&amp;</span>
<span class="p_add">+		    (!bio_list_empty(&amp;current-&gt;bio_list[0]) ||</span>
<span class="p_add">+		     !bio_list_empty(&amp;current-&gt;bio_list[1])))</span>
 			gfp_mask &amp;= ~__GFP_DIRECT_RECLAIM;
 
 		p = mempool_alloc(bs-&gt;bio_pool, gfp_mask);
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 4fab5d610805..ef083e7a37c5 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -2021,7 +2021,14 @@</span> <span class="p_context"> end_io:</span>
  */
 blk_qc_t generic_make_request(struct bio *bio)
 {
<span class="p_del">-	struct bio_list bio_list_on_stack;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * bio_list_on_stack[0] contains bios submitted by the current</span>
<span class="p_add">+	 * make_request_fn.</span>
<span class="p_add">+	 * bio_list_on_stack[1] contains bios that were submitted before</span>
<span class="p_add">+	 * the current make_request_fn, but that haven&#39;t been processed</span>
<span class="p_add">+	 * yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct bio_list bio_list_on_stack[2];</span>
 	blk_qc_t ret = BLK_QC_T_NONE;
 
 	if (!generic_make_request_checks(bio))
<span class="p_chunk">@@ -2038,7 +2045,7 @@</span> <span class="p_context"> blk_qc_t generic_make_request(struct bio *bio)</span>
 	 * should be added at the tail
 	 */
 	if (current-&gt;bio_list) {
<span class="p_del">-		bio_list_add(current-&gt;bio_list, bio);</span>
<span class="p_add">+		bio_list_add(&amp;current-&gt;bio_list[0], bio);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -2057,24 +2064,39 @@</span> <span class="p_context"> blk_qc_t generic_make_request(struct bio *bio)</span>
 	 * bio_list, and call into -&gt;make_request() again.
 	 */
 	BUG_ON(bio-&gt;bi_next);
<span class="p_del">-	bio_list_init(&amp;bio_list_on_stack);</span>
<span class="p_del">-	current-&gt;bio_list = &amp;bio_list_on_stack;</span>
<span class="p_add">+	bio_list_init(&amp;bio_list_on_stack[0]);</span>
<span class="p_add">+	current-&gt;bio_list = bio_list_on_stack;</span>
 	do {
 		struct request_queue *q = bdev_get_queue(bio-&gt;bi_bdev);
 
 		if (likely(blk_queue_enter(q, __GFP_DIRECT_RECLAIM) == 0)) {
<span class="p_add">+			struct bio_list lower, same;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Create a fresh bio_list for all subordinate requests */</span>
<span class="p_add">+			bio_list_on_stack[1] = bio_list_on_stack[0];</span>
<span class="p_add">+			bio_list_init(&amp;bio_list_on_stack[0]);</span>
 
 			ret = q-&gt;make_request_fn(q, bio);
 
 			blk_queue_exit(q);
<span class="p_del">-</span>
<span class="p_del">-			bio = bio_list_pop(current-&gt;bio_list);</span>
<span class="p_add">+			/* sort new bios into those for a lower level</span>
<span class="p_add">+			 * and those for the same level</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			bio_list_init(&amp;lower);</span>
<span class="p_add">+			bio_list_init(&amp;same);</span>
<span class="p_add">+			while ((bio = bio_list_pop(&amp;bio_list_on_stack[0])) != NULL)</span>
<span class="p_add">+				if (q == bdev_get_queue(bio-&gt;bi_bdev))</span>
<span class="p_add">+					bio_list_add(&amp;same, bio);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					bio_list_add(&amp;lower, bio);</span>
<span class="p_add">+			/* now assemble so we handle the lowest level first */</span>
<span class="p_add">+			bio_list_merge(&amp;bio_list_on_stack[0], &amp;lower);</span>
<span class="p_add">+			bio_list_merge(&amp;bio_list_on_stack[0], &amp;same);</span>
<span class="p_add">+			bio_list_merge(&amp;bio_list_on_stack[0], &amp;bio_list_on_stack[1]);</span>
 		} else {
<span class="p_del">-			struct bio *bio_next = bio_list_pop(current-&gt;bio_list);</span>
<span class="p_del">-</span>
 			bio_io_error(bio);
<span class="p_del">-			bio = bio_next;</span>
 		}
<span class="p_add">+		bio = bio_list_pop(&amp;bio_list_on_stack[0]);</span>
 	} while (bio);
 	current-&gt;bio_list = NULL; /* deactivate */
 
<span class="p_header">diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile</span>
<span class="p_header">index 675eaf337178..b9cebca376f9 100644</span>
<span class="p_header">--- a/drivers/acpi/Makefile</span>
<span class="p_header">+++ b/drivers/acpi/Makefile</span>
<span class="p_chunk">@@ -2,7 +2,6 @@</span> <span class="p_context"></span>
 # Makefile for the Linux ACPI interpreter
 #
 
<span class="p_del">-ccflags-y			:= -Os</span>
 ccflags-$(CONFIG_ACPI_DEBUG)	+= -DACPI_DEBUG_OUTPUT
 
 #
<span class="p_header">diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c</span>
<span class="p_header">index 296b7a14893a..5365ff6e69c1 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_platform.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_platform.c</span>
<span class="p_chunk">@@ -24,9 +24,11 @@</span> <span class="p_context"></span>
 ACPI_MODULE_NAME(&quot;platform&quot;);
 
 static const struct acpi_device_id forbidden_id_list[] = {
<span class="p_del">-	{&quot;PNP0000&quot;, 0},	/* PIC */</span>
<span class="p_del">-	{&quot;PNP0100&quot;, 0},	/* Timer */</span>
<span class="p_del">-	{&quot;PNP0200&quot;, 0},	/* AT DMA Controller */</span>
<span class="p_add">+	{&quot;PNP0000&quot;,  0},	/* PIC */</span>
<span class="p_add">+	{&quot;PNP0100&quot;,  0},	/* Timer */</span>
<span class="p_add">+	{&quot;PNP0200&quot;,  0},	/* AT DMA Controller */</span>
<span class="p_add">+	{&quot;ACPI0009&quot;, 0},	/* IOxAPIC */</span>
<span class="p_add">+	{&quot;ACPI000A&quot;, 0},	/* IOAPIC */</span>
 	{&quot;&quot;, 0},
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index 35310336dd0a..d684e2b79d2b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -213,8 +213,8 @@</span> <span class="p_context"> static void radeon_evict_flags(struct ttm_buffer_object *bo,</span>
 			rbo-&gt;placement.num_busy_placement = 0;
 			for (i = 0; i &lt; rbo-&gt;placement.num_placement; i++) {
 				if (rbo-&gt;placements[i].flags &amp; TTM_PL_FLAG_VRAM) {
<span class="p_del">-					if (rbo-&gt;placements[0].fpfn &lt; fpfn)</span>
<span class="p_del">-						rbo-&gt;placements[0].fpfn = fpfn;</span>
<span class="p_add">+					if (rbo-&gt;placements[i].fpfn &lt; fpfn)</span>
<span class="p_add">+						rbo-&gt;placements[i].fpfn = fpfn;</span>
 				} else {
 					rbo-&gt;placement.busy_placement =
 						&amp;rbo-&gt;placements[i];
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 397f0454100b..320eb3c4bb6b 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1481,26 +1481,29 @@</span> <span class="p_context"> static void flush_current_bio_list(struct blk_plug_cb *cb, bool from_schedule)</span>
 	struct dm_offload *o = container_of(cb, struct dm_offload, cb);
 	struct bio_list list;
 	struct bio *bio;
<span class="p_add">+	int i;</span>
 
 	INIT_LIST_HEAD(&amp;o-&gt;cb.list);
 
 	if (unlikely(!current-&gt;bio_list))
 		return;
 
<span class="p_del">-	list = *current-&gt;bio_list;</span>
<span class="p_del">-	bio_list_init(current-&gt;bio_list);</span>
<span class="p_del">-</span>
<span class="p_del">-	while ((bio = bio_list_pop(&amp;list))) {</span>
<span class="p_del">-		struct bio_set *bs = bio-&gt;bi_pool;</span>
<span class="p_del">-		if (unlikely(!bs) || bs == fs_bio_set) {</span>
<span class="p_del">-			bio_list_add(current-&gt;bio_list, bio);</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		list = current-&gt;bio_list[i];</span>
<span class="p_add">+		bio_list_init(&amp;current-&gt;bio_list[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		while ((bio = bio_list_pop(&amp;list))) {</span>
<span class="p_add">+			struct bio_set *bs = bio-&gt;bi_pool;</span>
<span class="p_add">+			if (unlikely(!bs) || bs == fs_bio_set) {</span>
<span class="p_add">+				bio_list_add(&amp;current-&gt;bio_list[i], bio);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_lock(&amp;bs-&gt;rescue_lock);</span>
<span class="p_add">+			bio_list_add(&amp;bs-&gt;rescue_list, bio);</span>
<span class="p_add">+			queue_work(bs-&gt;rescue_workqueue, &amp;bs-&gt;rescue_work);</span>
<span class="p_add">+			spin_unlock(&amp;bs-&gt;rescue_lock);</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		spin_lock(&amp;bs-&gt;rescue_lock);</span>
<span class="p_del">-		bio_list_add(&amp;bs-&gt;rescue_list, bio);</span>
<span class="p_del">-		queue_work(bs-&gt;rescue_workqueue, &amp;bs-&gt;rescue_work);</span>
<span class="p_del">-		spin_unlock(&amp;bs-&gt;rescue_lock);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 515554c7365b..9be39988bf06 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -877,7 +877,8 @@</span> <span class="p_context"> static sector_t wait_barrier(struct r1conf *conf, struct bio *bio)</span>
 				     ((conf-&gt;start_next_window &lt;
 				       conf-&gt;next_resync + RESYNC_SECTORS) &amp;&amp;
 				      current-&gt;bio_list &amp;&amp;
<span class="p_del">-				      !bio_list_empty(current-&gt;bio_list))),</span>
<span class="p_add">+				     (!bio_list_empty(&amp;current-&gt;bio_list[0]) ||</span>
<span class="p_add">+				      !bio_list_empty(&amp;current-&gt;bio_list[1])))),</span>
 				    conf-&gt;resync_lock);
 		conf-&gt;nr_waiting--;
 	}
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index a92979e704e3..e5ee4e9e0ea5 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -946,7 +946,8 @@</span> <span class="p_context"> static void wait_barrier(struct r10conf *conf)</span>
 				    !conf-&gt;barrier ||
 				    (conf-&gt;nr_pending &amp;&amp;
 				     current-&gt;bio_list &amp;&amp;
<span class="p_del">-				     !bio_list_empty(current-&gt;bio_list)),</span>
<span class="p_add">+				     (!bio_list_empty(&amp;current-&gt;bio_list[0]) ||</span>
<span class="p_add">+				      !bio_list_empty(&amp;current-&gt;bio_list[1]))),</span>
 				    conf-&gt;resync_lock);
 		conf-&gt;nr_waiting--;
 	}
<span class="p_header">diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c</span>
<span class="p_header">index e9e24df35f26..2579f025b90b 100644</span>
<span class="p_header">--- a/drivers/power/reset/at91-poweroff.c</span>
<span class="p_header">+++ b/drivers/power/reset/at91-poweroff.c</span>
<span class="p_chunk">@@ -14,9 +14,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/io.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/printk.h&gt;
 
<span class="p_add">+#include &lt;soc/at91/at91sam9_ddrsdr.h&gt;</span>
<span class="p_add">+</span>
 #define AT91_SHDW_CR	0x00		/* Shut Down Control Register */
 #define AT91_SHDW_SHDW		BIT(0)			/* Shut Down command */
 #define AT91_SHDW_KEY		(0xa5 &lt;&lt; 24)		/* KEY Password */
<span class="p_chunk">@@ -50,6 +53,7 @@</span> <span class="p_context"> static const char *shdwc_wakeup_modes[] = {</span>
 
 static void __iomem *at91_shdwc_base;
 static struct clk *sclk;
<span class="p_add">+static void __iomem *mpddrc_base;</span>
 
 static void __init at91_wakeup_status(void)
 {
<span class="p_chunk">@@ -73,6 +77,29 @@</span> <span class="p_context"> static void at91_poweroff(void)</span>
 	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
 }
 
<span class="p_add">+static void at91_lpddr_poweroff(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+		/* Align to cache lines */</span>
<span class="p_add">+		&quot;.balign 32\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Ensure AT91_SHDW_CR is in the TLB by reading it */</span>
<span class="p_add">+		&quot;	ldr	r6, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Power down SDRAM0 */</span>
<span class="p_add">+		&quot;	str	%1, [%0, #&quot; __stringify(AT91_DDRSDRC_LPR) &quot;]\n\t&quot;</span>
<span class="p_add">+		/* Shutdown CPU */</span>
<span class="p_add">+		&quot;	str	%3, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		&quot;	b	.\n\t&quot;</span>
<span class="p_add">+		:</span>
<span class="p_add">+		: &quot;r&quot; (mpddrc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),</span>
<span class="p_add">+		  &quot;r&quot; (at91_shdwc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)</span>
<span class="p_add">+		: &quot;r0&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int at91_poweroff_get_wakeup_mode(struct device_node *np)
 {
 	const char *pm;
<span class="p_chunk">@@ -124,6 +151,8 @@</span> <span class="p_context"> static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)</span>
 static int __init at91_poweroff_probe(struct platform_device *pdev)
 {
 	struct resource *res;
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	u32 ddr_type;</span>
 	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
<span class="p_chunk">@@ -150,12 +179,30 @@</span> <span class="p_context"> static int __init at91_poweroff_probe(struct platform_device *pdev)</span>
 
 	pm_power_off = at91_poweroff;
 
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;atmel,sama5d3-ddramc&quot;);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mpddrc_base = of_iomap(np, 0);</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mpddrc_base)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) &amp; AT91_DDRSDRC_MD;</span>
<span class="p_add">+	if ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||</span>
<span class="p_add">+	    (ddr_type == AT91_DDRSDRC_MD_LPDDR3))</span>
<span class="p_add">+		pm_power_off = at91_lpddr_poweroff;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		iounmap(mpddrc_base);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static int __exit at91_poweroff_remove(struct platform_device *pdev)
 {
<span class="p_del">-	if (pm_power_off == at91_poweroff)</span>
<span class="p_add">+	if (pm_power_off == at91_poweroff ||</span>
<span class="p_add">+	    pm_power_off == at91_lpddr_poweroff)</span>
 		pm_power_off = NULL;
 
 	clk_disable_unprepare(sclk);
<span class="p_chunk">@@ -163,6 +210,11 @@</span> <span class="p_context"> static int __exit at91_poweroff_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static const struct of_device_id at91_ramc_of_match[] = {</span>
<span class="p_add">+	{ .compatible = &quot;atmel,sama5d3-ddramc&quot;, },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = &quot;atmel,at91sam9260-shdwc&quot;, },
 	{ .compatible = &quot;atmel,at91sam9rl-shdwc&quot;, },
<span class="p_header">diff --git a/drivers/rtc/rtc-s35390a.c b/drivers/rtc/rtc-s35390a.c</span>
<span class="p_header">index f40afdd0e5f5..00662dd28d66 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s35390a.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s35390a.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitrev.h&gt;
 #include &lt;linux/bcd.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #define S35390A_CMD_STATUS1	0
 #define S35390A_CMD_STATUS2	1
<span class="p_chunk">@@ -34,10 +35,14 @@</span> <span class="p_context"></span>
 #define S35390A_ALRM_BYTE_HOURS	1
 #define S35390A_ALRM_BYTE_MINS	2
 
<span class="p_add">+/* flags for STATUS1 */</span>
 #define S35390A_FLAG_POC	0x01
 #define S35390A_FLAG_BLD	0x02
<span class="p_add">+#define S35390A_FLAG_INT2	0x04</span>
 #define S35390A_FLAG_24H	0x40
 #define S35390A_FLAG_RESET	0x80
<span class="p_add">+</span>
<span class="p_add">+/* flag for STATUS2 */</span>
 #define S35390A_FLAG_TEST	0x01
 
 #define S35390A_INT2_MODE_MASK		0xF0
<span class="p_chunk">@@ -94,19 +99,63 @@</span> <span class="p_context"> static int s35390a_get_reg(struct s35390a *s35390a, int reg, char *buf, int len)</span>
 	return 0;
 }
 
<span class="p_del">-static int s35390a_reset(struct s35390a *s35390a)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns &lt;0 on error, 0 if rtc is setup fine and 1 if the chip was reset.</span>
<span class="p_add">+ * To keep the information if an irq is pending, pass the value read from</span>
<span class="p_add">+ * STATUS1 to the caller.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int s35390a_reset(struct s35390a *s35390a, char *status1)</span>
 {
<span class="p_del">-	char buf[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf)) &lt; 0)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(buf[0] &amp; (S35390A_FLAG_POC | S35390A_FLAG_BLD)))</span>
<span class="p_add">+	char buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	unsigned initcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, status1, 1);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (*status1 &amp; S35390A_FLAG_POC)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not communicate for 0.5 seconds since the power-on</span>
<span class="p_add">+		 * detection circuit is in operation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		msleep(500);</span>
<span class="p_add">+	else if (!(*status1 &amp; S35390A_FLAG_BLD))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If both POC and BLD are unset everything is fine.</span>
<span class="p_add">+		 */</span>
 		return 0;
 
<span class="p_del">-	buf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);</span>
<span class="p_del">-	buf[0] &amp;= 0xf0;</span>
<span class="p_del">-	return s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * At least one of POC and BLD are set, so reinitialise chip. Keeping</span>
<span class="p_add">+	 * this information in the hardware to know later that the time isn&#39;t</span>
<span class="p_add">+	 * valid is unfortunately not possible because POC and BLD are cleared</span>
<span class="p_add">+	 * on read. So the reset is best done now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The 24H bit is kept over reset, so set it already here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+initialize:</span>
<span class="p_add">+	*status1 = S35390A_FLAG_24H;</span>
<span class="p_add">+	buf = S35390A_FLAG_RESET | S35390A_FLAG_24H;</span>
<span class="p_add">+	ret = s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, &amp;buf, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, &amp;buf, 1);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf &amp; (S35390A_FLAG_POC | S35390A_FLAG_BLD)) {</span>
<span class="p_add">+		/* Try up to five times to reset the chip */</span>
<span class="p_add">+		if (initcount &lt; 5) {</span>
<span class="p_add">+			++initcount;</span>
<span class="p_add">+			goto initialize;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
 }
 
 static int s35390a_disable_test_mode(struct s35390a *s35390a)
<span class="p_chunk">@@ -242,6 +291,8 @@</span> <span class="p_context"> static int s35390a_set_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)</span>
 
 	if (alm-&gt;time.tm_wday != -1)
 		buf[S35390A_ALRM_BYTE_WDAY] = bin2bcd(alm-&gt;time.tm_wday) | 0x80;
<span class="p_add">+	else</span>
<span class="p_add">+		buf[S35390A_ALRM_BYTE_WDAY] = 0;</span>
 
 	buf[S35390A_ALRM_BYTE_HOURS] = s35390a_hr2reg(s35390a,
 			alm-&gt;time.tm_hour) | 0x80;
<span class="p_chunk">@@ -265,27 +316,61 @@</span> <span class="p_context"> static int s35390a_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)</span>
 	char buf[3], sts;
 	int i, err;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * initialize all members to -1 to signal the core that they are not</span>
<span class="p_add">+	 * defined by the hardware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	alm-&gt;time.tm_sec = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_min = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_hour = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_mday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_mon = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_year = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_wday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_yday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_isdst = -1;</span>
<span class="p_add">+</span>
 	err = s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, &amp;sts, sizeof(sts));
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	if (bitrev8(sts) != S35390A_INT2_MODE_ALARM)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if ((bitrev8(sts) &amp; S35390A_INT2_MODE_MASK) != S35390A_INT2_MODE_ALARM) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When the alarm isn&#39;t enabled, the register to configure</span>
<span class="p_add">+		 * the alarm time isn&#39;t accessible.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		alm-&gt;enabled = 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		alm-&gt;enabled = 1;</span>
<span class="p_add">+	}</span>
 
 	err = s35390a_get_reg(s35390a, S35390A_CMD_INT2_REG1, buf, sizeof(buf));
 	if (err &lt; 0)
 		return err;
 
 	/* This chip returns the bits of each byte in reverse order */
<span class="p_del">-	for (i = 0; i &lt; 3; ++i) {</span>
<span class="p_add">+	for (i = 0; i &lt; 3; ++i)</span>
 		buf[i] = bitrev8(buf[i]);
<span class="p_del">-		buf[i] &amp;= ~0x80;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	alm-&gt;time.tm_wday = bcd2bin(buf[S35390A_ALRM_BYTE_WDAY]);</span>
<span class="p_del">-	alm-&gt;time.tm_hour = s35390a_reg2hr(s35390a,</span>
<span class="p_del">-						buf[S35390A_ALRM_BYTE_HOURS]);</span>
<span class="p_del">-	alm-&gt;time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS]);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * B0 of the three matching registers is an enable flag. Iff it is set</span>
<span class="p_add">+	 * the configured value is used for matching.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_WDAY] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_wday =</span>
<span class="p_add">+			bcd2bin(buf[S35390A_ALRM_BYTE_WDAY] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_HOURS] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_hour =</span>
<span class="p_add">+			s35390a_reg2hr(s35390a,</span>
<span class="p_add">+				       buf[S35390A_ALRM_BYTE_HOURS] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_MINS] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* alarm triggers always at s=0 */</span>
<span class="p_add">+	alm-&gt;time.tm_sec = 0;</span>
 
 	dev_dbg(&amp;client-&gt;dev, &quot;%s: alm is mins=%d, hours=%d, wday=%d\n&quot;,
 			__func__, alm-&gt;time.tm_min, alm-&gt;time.tm_hour,
<span class="p_chunk">@@ -327,11 +412,11 @@</span> <span class="p_context"> static struct i2c_driver s35390a_driver;</span>
 static int s35390a_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, err_reset;</span>
 	unsigned int i;
 	struct s35390a *s35390a;
 	struct rtc_time tm;
<span class="p_del">-	char buf[1];</span>
<span class="p_add">+	char buf, status1;</span>
 
 	if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
 		err = -ENODEV;
<span class="p_chunk">@@ -360,29 +445,35 @@</span> <span class="p_context"> static int s35390a_probe(struct i2c_client *client,</span>
 		}
 	}
 
<span class="p_del">-	err = s35390a_reset(s35390a);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_add">+	err_reset = s35390a_reset(s35390a, &amp;status1);</span>
<span class="p_add">+	if (err_reset &lt; 0) {</span>
<span class="p_add">+		err = err_reset;</span>
 		dev_err(&amp;client-&gt;dev, &quot;error resetting chip\n&quot;);
 		goto exit_dummy;
 	}
 
<span class="p_del">-	err = s35390a_disable_test_mode(s35390a);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;error disabling test mode\n&quot;);</span>
<span class="p_del">-		goto exit_dummy;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	err = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;error checking 12/24 hour mode\n&quot;);</span>
<span class="p_del">-		goto exit_dummy;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (buf[0] &amp; S35390A_FLAG_24H)</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_24H)</span>
 		s35390a-&gt;twentyfourhour = 1;
 	else
 		s35390a-&gt;twentyfourhour = 0;
 
<span class="p_del">-	if (s35390a_get_datetime(client, &amp;tm) &lt; 0)</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_INT2) {</span>
<span class="p_add">+		/* disable alarm (and maybe test mode) */</span>
<span class="p_add">+		buf = 0;</span>
<span class="p_add">+		err = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &amp;buf, 1);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;error disabling alarm&quot;);</span>
<span class="p_add">+			goto exit_dummy;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = s35390a_disable_test_mode(s35390a);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;error disabling test mode\n&quot;);</span>
<span class="p_add">+			goto exit_dummy;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err_reset &gt; 0 || s35390a_get_datetime(client, &amp;tm) &lt; 0)</span>
 		dev_warn(&amp;client-&gt;dev, &quot;clock needs to be set\n&quot;);
 
 	device_set_wakeup_capable(&amp;client-&gt;dev, 1);
<span class="p_chunk">@@ -395,6 +486,10 @@</span> <span class="p_context"> static int s35390a_probe(struct i2c_client *client,</span>
 		err = PTR_ERR(s35390a-&gt;rtc);
 		goto exit_dummy;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_INT2)</span>
<span class="p_add">+		rtc_update_irq(s35390a-&gt;rtc, 1, RTC_AF);</span>
<span class="p_add">+</span>
 	return 0;
 
 exit_dummy:
<span class="p_header">diff --git a/drivers/scsi/libsas/sas_ata.c b/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_header">index 9c706d8c1441..6f5e2720ffad 100644</span>
<span class="p_header">--- a/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_header">+++ b/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> static unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)</span>
 		task-&gt;num_scatter = qc-&gt;n_elem;
 	} else {
 		for_each_sg(qc-&gt;sg, sg, qc-&gt;n_elem, si)
<span class="p_del">-			xfer += sg-&gt;length;</span>
<span class="p_add">+			xfer += sg_dma_len(sg);</span>
 
 		task-&gt;total_xfer_len = xfer;
 		task-&gt;num_scatter = si;
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.h b/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_header">index 92648a5ea2d2..63f5965acc89 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.h</span>
<span class="p_chunk">@@ -390,6 +390,7 @@</span> <span class="p_context"> struct MPT3SAS_TARGET {</span>
  * @eedp_enable: eedp support enable bit
  * @eedp_type: 0(type_1), 1(type_2), 2(type_3)
  * @eedp_block_length: block size
<span class="p_add">+ * @ata_command_pending: SATL passthrough outstanding for device</span>
  */
 struct MPT3SAS_DEVICE {
 	struct MPT3SAS_TARGET *sas_target;
<span class="p_chunk">@@ -398,6 +399,17 @@</span> <span class="p_context"> struct MPT3SAS_DEVICE {</span>
 	u8	configured_lun;
 	u8	block;
 	u8	tlr_snoop_check;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bug workaround for SATL handling: the mpt2/3sas firmware</span>
<span class="p_add">+	 * doesn&#39;t return BUSY or TASK_SET_FULL for subsequent</span>
<span class="p_add">+	 * commands while a SATL pass through is in operation as the</span>
<span class="p_add">+	 * spec requires, it simply does nothing with them until the</span>
<span class="p_add">+	 * pass through completes, causing them possibly to timeout if</span>
<span class="p_add">+	 * the passthrough is a long executing command (like format or</span>
<span class="p_add">+	 * secure erase).  This variable allows us to do the right</span>
<span class="p_add">+	 * thing while a SATL command is pending.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned long ata_command_pending;</span>
 };
 
 #define MPT3_CMD_NOT_USED	0x8000	/* free */
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index f6a8e9958e75..8a5fbdb45cfd 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -3707,9 +3707,18 @@</span> <span class="p_context"> _scsih_temp_threshold_events(struct MPT3SAS_ADAPTER *ioc,</span>
 	}
 }
 
<span class="p_del">-static inline bool ata_12_16_cmd(struct scsi_cmnd *scmd)</span>
<span class="p_add">+static int _scsih_set_satl_pending(struct scsi_cmnd *scmd, bool pending)</span>
 {
<span class="p_del">-	return (scmd-&gt;cmnd[0] == ATA_12 || scmd-&gt;cmnd[0] == ATA_16);</span>
<span class="p_add">+	struct MPT3SAS_DEVICE *priv = scmd-&gt;device-&gt;hostdata;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (scmd-&gt;cmnd[0] != ATA_12 &amp;&amp; scmd-&gt;cmnd[0] != ATA_16)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pending)</span>
<span class="p_add">+		return test_and_set_bit(0, &amp;priv-&gt;ata_command_pending);</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(0, &amp;priv-&gt;ata_command_pending);</span>
<span class="p_add">+	return 0;</span>
 }
 
 /**
<span class="p_chunk">@@ -3733,9 +3742,7 @@</span> <span class="p_context"> _scsih_flush_running_cmds(struct MPT3SAS_ADAPTER *ioc)</span>
 		if (!scmd)
 			continue;
 		count++;
<span class="p_del">-		if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-			scsi_internal_device_unblock(scmd-&gt;device,</span>
<span class="p_del">-							SDEV_RUNNING);</span>
<span class="p_add">+		_scsih_set_satl_pending(scmd, false);</span>
 		mpt3sas_base_free_smid(ioc, smid);
 		scsi_dma_unmap(scmd);
 		if (ioc-&gt;pci_error_recovery)
<span class="p_chunk">@@ -3866,13 +3873,6 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 	if (ioc-&gt;logging_level &amp; MPT_DEBUG_SCSI)
 		scsi_print_command(scmd);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Lock the device for any subsequent command until command is</span>
<span class="p_del">-	 * done.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-		scsi_internal_device_block(scmd-&gt;device);</span>
<span class="p_del">-</span>
 	sas_device_priv_data = scmd-&gt;device-&gt;hostdata;
 	if (!sas_device_priv_data || !sas_device_priv_data-&gt;sas_target) {
 		scmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
<span class="p_chunk">@@ -3886,6 +3886,19 @@</span> <span class="p_context"> scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 		return 0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bug work around for firmware SATL handling.  The loop</span>
<span class="p_add">+	 * is based on atomic operations and ensures consistency</span>
<span class="p_add">+	 * since we&#39;re lockless at this point</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (test_bit(0, &amp;sas_device_priv_data-&gt;ata_command_pending)) {</span>
<span class="p_add">+			scmd-&gt;result = SAM_STAT_BUSY;</span>
<span class="p_add">+			scmd-&gt;scsi_done(scmd);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (_scsih_set_satl_pending(scmd, true));</span>
<span class="p_add">+</span>
 	sas_target_priv_data = sas_device_priv_data-&gt;sas_target;
 
 	/* invalid device handle */
<span class="p_chunk">@@ -4445,8 +4458,7 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	if (scmd == NULL)
 		return 1;
 
<span class="p_del">-	if (ata_12_16_cmd(scmd))</span>
<span class="p_del">-		scsi_internal_device_unblock(scmd-&gt;device, SDEV_RUNNING);</span>
<span class="p_add">+	_scsih_set_satl_pending(scmd, false);</span>
 
 	mpi_request = mpt3sas_base_get_msg_frame(ioc, smid);
 
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index dedcff9cabb5..6514636431ab 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1008,6 +1008,8 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 		result = get_user(val, ip);
 		if (result)
 			return result;
<span class="p_add">+		if (val &gt; SG_MAX_CDB_SIZE)</span>
<span class="p_add">+			return -ENOMEM;</span>
 		sfp-&gt;next_cmd_len = (val &gt; 0) ? val : 0;
 		return 0;
 	case SG_GET_VERSION_NUM:
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index a0f911641b04..a15070a7fcd6 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -1987,6 +1987,11 @@</span> <span class="p_context"> static void atmel_flush_buffer(struct uart_port *port)</span>
 		atmel_uart_writel(port, ATMEL_PDC_TCR, 0);
 		atmel_port-&gt;pdc_tx.ofs = 0;
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * in uart_flush_buffer(), the xmit circular buffer has just</span>
<span class="p_add">+	 * been cleared, so we have to reset tx_len accordingly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	atmel_port-&gt;tx_len = 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -2499,6 +2504,9 @@</span> <span class="p_context"> static void atmel_console_write(struct console *co, const char *s, u_int count)</span>
 	pdc_tx = atmel_uart_readl(port, ATMEL_PDC_PTSR) &amp; ATMEL_PDC_TXTEN;
 	atmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTDIS);
 
<span class="p_add">+	/* Make sure that tx path is actually able to send characters */</span>
<span class="p_add">+	atmel_uart_writel(port, ATMEL_US_CR, ATMEL_US_TXEN);</span>
<span class="p_add">+</span>
 	uart_console_write(port, s, count, atmel_console_putchar);
 
 	/*
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 5724d7c41e29..ca2cbdb3aa67 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -499,8 +499,10 @@</span> <span class="p_context"> static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)</span>
 	 */
 	tbuf_size =  max_t(u16, sizeof(struct usb_hub_descriptor), wLength);
 	tbuf = kzalloc(tbuf_size, GFP_KERNEL);
<span class="p_del">-	if (!tbuf)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!tbuf) {</span>
<span class="p_add">+		status = -ENOMEM;</span>
<span class="p_add">+		goto err_alloc;</span>
<span class="p_add">+	}</span>
 
 	bufp = tbuf;
 
<span class="p_chunk">@@ -705,6 +707,7 @@</span> <span class="p_context"> error:</span>
 	}
 
 	kfree(tbuf);
<span class="p_add">+ err_alloc:</span>
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
<span class="p_header">diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h</span>
<span class="p_header">index c923350ca20a..d7ce4e3280db 100644</span>
<span class="p_header">--- a/include/linux/kvm_host.h</span>
<span class="p_header">+++ b/include/linux/kvm_host.h</span>
<span class="p_chunk">@@ -182,8 +182,8 @@</span> <span class="p_context"> int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,</span>
 		    int len, void *val);
 int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
 			    int len, struct kvm_io_device *dev);
<span class="p_del">-int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_del">-			      struct kvm_io_device *dev);</span>
<span class="p_add">+void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_add">+			       struct kvm_io_device *dev);</span>
 
 #ifdef CONFIG_KVM_ASYNC_PF
 struct kvm_async_pf {
<span class="p_header">diff --git a/kernel/padata.c b/kernel/padata.c</span>
<span class="p_header">index b38bea9c466a..401227e3967c 100644</span>
<span class="p_header">--- a/kernel/padata.c</span>
<span class="p_header">+++ b/kernel/padata.c</span>
<span class="p_chunk">@@ -189,19 +189,20 @@</span> <span class="p_context"> static struct padata_priv *padata_get_next(struct parallel_data *pd)</span>
 
 	reorder = &amp;next_queue-&gt;reorder;
 
<span class="p_add">+	spin_lock(&amp;reorder-&gt;lock);</span>
 	if (!list_empty(&amp;reorder-&gt;list)) {
 		padata = list_entry(reorder-&gt;list.next,
 				    struct padata_priv, list);
 
<span class="p_del">-		spin_lock(&amp;reorder-&gt;lock);</span>
 		list_del_init(&amp;padata-&gt;list);
 		atomic_dec(&amp;pd-&gt;reorder_objects);
<span class="p_del">-		spin_unlock(&amp;reorder-&gt;lock);</span>
 
 		pd-&gt;processed++;
 
<span class="p_add">+		spin_unlock(&amp;reorder-&gt;lock);</span>
 		goto out;
 	}
<span class="p_add">+	spin_unlock(&amp;reorder-&gt;lock);</span>
 
 	if (__this_cpu_read(pd-&gt;pqueue-&gt;cpu_index) == next_queue-&gt;cpu_index) {
 		padata = ERR_PTR(-ENODATA);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index ea11123a9249..7294301d8495 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -4362,6 +4362,7 @@</span> <span class="p_context"> follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
 {
 	struct page *page = NULL;
 	spinlock_t *ptl;
<span class="p_add">+	pte_t pte;</span>
 retry:
 	ptl = pmd_lockptr(mm, pmd);
 	spin_lock(ptl);
<span class="p_chunk">@@ -4371,12 +4372,13 @@</span> <span class="p_context"> retry:</span>
 	 */
 	if (!pmd_huge(*pmd))
 		goto out;
<span class="p_del">-	if (pmd_present(*pmd)) {</span>
<span class="p_add">+	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="p_add">+	if (pte_present(pte)) {</span>
 		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_del">-		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="p_add">+		if (is_hugetlb_entry_migration(pte)) {</span>
 			spin_unlock(ptl);
 			__migration_entry_wait(mm, (pte_t *)pmd, ptl);
 			goto retry;
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index b8d927c56494..a6b2f2138c9d 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/net.h&gt;
 #include &lt;linux/nsproxy.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/socket.h&gt;
 #include &lt;linux/string.h&gt;
<span class="p_chunk">@@ -478,11 +479,16 @@</span> <span class="p_context"> static int ceph_tcp_connect(struct ceph_connection *con)</span>
 {
 	struct sockaddr_storage *paddr = &amp;con-&gt;peer_addr.in_addr;
 	struct socket *sock;
<span class="p_add">+	unsigned int noio_flag;</span>
 	int ret;
 
 	BUG_ON(con-&gt;sock);
<span class="p_add">+</span>
<span class="p_add">+	/* sock_create_kern() allocates with GFP_KERNEL */</span>
<span class="p_add">+	noio_flag = memalloc_noio_save();</span>
 	ret = sock_create_kern(read_pnet(&amp;con-&gt;msgr-&gt;net), paddr-&gt;ss_family,
 			       SOCK_STREAM, IPPROTO_TCP, &amp;sock);
<span class="p_add">+	memalloc_noio_restore(noio_flag);</span>
 	if (ret)
 		return ret;
 	sock-&gt;sk-&gt;sk_allocation = GFP_NOFS;
<span class="p_header">diff --git a/sound/core/seq/seq_fifo.c b/sound/core/seq/seq_fifo.c</span>
<span class="p_header">index 3f4efcb85df5..3490d21ab9e7 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_fifo.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_fifo.c</span>
<span class="p_chunk">@@ -265,6 +265,10 @@</span> <span class="p_context"> int snd_seq_fifo_resize(struct snd_seq_fifo *f, int poolsize)</span>
 	/* NOTE: overflow flag is not cleared */
 	spin_unlock_irqrestore(&amp;f-&gt;lock, flags);
 
<span class="p_add">+	/* close the old pool and wait until all users are gone */</span>
<span class="p_add">+	snd_seq_pool_mark_closing(oldpool);</span>
<span class="p_add">+	snd_use_lock_sync(&amp;f-&gt;use_lock);</span>
<span class="p_add">+</span>
 	/* release cells in old pool */
 	for (cell = oldhead; cell; cell = next) {
 		next = cell-&gt;next;
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 1d4f34379f56..46a34039ecdc 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4831,6 +4831,7 @@</span> <span class="p_context"> enum {</span>
 	ALC292_FIXUP_DISABLE_AAMIX,
 	ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK,
 	ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+	ALC298_FIXUP_DELL_AIO_MIC_NO_PRESENCE,</span>
 	ALC275_FIXUP_DELL_XPS,
 	ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE,
 	ALC293_FIXUP_LENOVO_SPK_NOISE,
<span class="p_chunk">@@ -5429,6 +5430,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC269_FIXUP_HEADSET_MODE
 	},
<span class="p_add">+	[ALC298_FIXUP_DELL_AIO_MIC_NO_PRESENCE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x18, 0x01a1913c }, /* use as headset mic, without its own jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE</span>
<span class="p_add">+	},</span>
 	[ALC275_FIXUP_DELL_XPS] = {
 		.type = HDA_FIXUP_VERBS,
 		.v.verbs = (const struct hda_verb[]) {
<span class="p_chunk">@@ -5501,7 +5511,7 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc298_fixup_speaker_volume,
 		.chained = true,
<span class="p_del">-		.chain_id = ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		.chain_id = ALC298_FIXUP_DELL_AIO_MIC_NO_PRESENCE,</span>
 	},
 	[ALC256_FIXUP_DELL_INSPIRON_7559_SUBWOOFER] = {
 		.type = HDA_FIXUP_PINS,
<span class="p_header">diff --git a/sound/soc/atmel/atmel-classd.c b/sound/soc/atmel/atmel-classd.c</span>
<span class="p_header">index 8276675730ef..78a985629607 100644</span>
<span class="p_header">--- a/sound/soc/atmel/atmel-classd.c</span>
<span class="p_header">+++ b/sound/soc/atmel/atmel-classd.c</span>
<span class="p_chunk">@@ -343,7 +343,7 @@</span> <span class="p_context"> static int atmel_classd_codec_dai_digital_mute(struct snd_soc_dai *codec_dai,</span>
 }
 
 #define CLASSD_ACLK_RATE_11M2896_MPY_8 (112896 * 100 * 8)
<span class="p_del">-#define CLASSD_ACLK_RATE_12M288_MPY_8  (12228 * 1000 * 8)</span>
<span class="p_add">+#define CLASSD_ACLK_RATE_12M288_MPY_8  (12288 * 1000 * 8)</span>
 
 static struct {
 	int rate;
<span class="p_header">diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c</span>
<span class="p_header">index 46dbc0a7dfc1..49001fa84ead 100644</span>
<span class="p_header">--- a/virt/kvm/eventfd.c</span>
<span class="p_header">+++ b/virt/kvm/eventfd.c</span>
<span class="p_chunk">@@ -868,7 +868,8 @@</span> <span class="p_context"> kvm_deassign_ioeventfd_idx(struct kvm *kvm, enum kvm_bus bus_idx,</span>
 			continue;
 
 		kvm_io_bus_unregister_dev(kvm, bus_idx, &amp;p-&gt;dev);
<span class="p_del">-		kvm-&gt;buses[bus_idx]-&gt;ioeventfd_count--;</span>
<span class="p_add">+		if (kvm-&gt;buses[bus_idx])</span>
<span class="p_add">+			kvm-&gt;buses[bus_idx]-&gt;ioeventfd_count--;</span>
 		ioeventfd_release(p);
 		ret = 0;
 		break;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 336ed267c407..cb092bd9965b 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -654,8 +654,11 @@</span> <span class="p_context"> static void kvm_destroy_vm(struct kvm *kvm)</span>
 	list_del(&amp;kvm-&gt;vm_list);
 	spin_unlock(&amp;kvm_lock);
 	kvm_free_irq_routing(kvm);
<span class="p_del">-	for (i = 0; i &lt; KVM_NR_BUSES; i++)</span>
<span class="p_del">-		kvm_io_bus_destroy(kvm-&gt;buses[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; KVM_NR_BUSES; i++) {</span>
<span class="p_add">+		if (kvm-&gt;buses[i])</span>
<span class="p_add">+			kvm_io_bus_destroy(kvm-&gt;buses[i]);</span>
<span class="p_add">+		kvm-&gt;buses[i] = NULL;</span>
<span class="p_add">+	}</span>
 	kvm_coalesced_mmio_free(kvm);
 #if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
 	mmu_notifier_unregister(&amp;kvm-&gt;mmu_notifier, kvm-&gt;mm);
<span class="p_chunk">@@ -3271,6 +3274,8 @@</span> <span class="p_context"> int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,</span>
 	};
 
 	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	r = __kvm_io_bus_write(vcpu, bus, &amp;range, val);
 	return r &lt; 0 ? r : 0;
 }
<span class="p_chunk">@@ -3288,6 +3293,8 @@</span> <span class="p_context"> int kvm_io_bus_write_cookie(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx,</span>
 	};
 
 	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* First try the device referenced by cookie. */
 	if ((cookie &gt;= 0) &amp;&amp; (cookie &lt; bus-&gt;dev_count) &amp;&amp;
<span class="p_chunk">@@ -3338,6 +3345,8 @@</span> <span class="p_context"> int kvm_io_bus_read(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,</span>
 	};
 
 	bus = srcu_dereference(vcpu-&gt;kvm-&gt;buses[bus_idx], &amp;vcpu-&gt;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	r = __kvm_io_bus_read(vcpu, bus, &amp;range, val);
 	return r &lt; 0 ? r : 0;
 }
<span class="p_chunk">@@ -3350,6 +3359,9 @@</span> <span class="p_context"> int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 	struct kvm_io_bus *new_bus, *bus;
 
 	bus = kvm-&gt;buses[bus_idx];
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	/* exclude ioeventfd which is limited by maximum fd */
 	if (bus-&gt;dev_count - bus-&gt;ioeventfd_count &gt; NR_IOBUS_DEVS - 1)
 		return -ENOSPC;
<span class="p_chunk">@@ -3369,37 +3381,41 @@</span> <span class="p_context"> int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 }
 
 /* Caller must hold slots_lock. */
<span class="p_del">-int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_del">-			      struct kvm_io_device *dev)</span>
<span class="p_add">+void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_add">+			       struct kvm_io_device *dev)</span>
 {
<span class="p_del">-	int i, r;</span>
<span class="p_add">+	int i;</span>
 	struct kvm_io_bus *new_bus, *bus;
 
 	bus = kvm-&gt;buses[bus_idx];
<span class="p_del">-	r = -ENOENT;</span>
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; bus-&gt;dev_count; i++)
 		if (bus-&gt;range[i].dev == dev) {
<span class="p_del">-			r = 0;</span>
 			break;
 		}
 
<span class="p_del">-	if (r)</span>
<span class="p_del">-		return r;</span>
<span class="p_add">+	if (i == bus-&gt;dev_count)</span>
<span class="p_add">+		return;</span>
 
 	new_bus = kmalloc(sizeof(*bus) + ((bus-&gt;dev_count - 1) *
 			  sizeof(struct kvm_io_range)), GFP_KERNEL);
<span class="p_del">-	if (!new_bus)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!new_bus)  {</span>
<span class="p_add">+		pr_err(&quot;kvm: failed to shrink bus, removing it completely\n&quot;);</span>
<span class="p_add">+		goto broken;</span>
<span class="p_add">+	}</span>
 
 	memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));
 	new_bus-&gt;dev_count--;
 	memcpy(new_bus-&gt;range + i, bus-&gt;range + i + 1,
 	       (new_bus-&gt;dev_count - i) * sizeof(struct kvm_io_range));
 
<span class="p_add">+broken:</span>
 	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
 	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);
 	kfree(bus);
<span class="p_del">-	return r;</span>
<span class="p_add">+	return;</span>
 }
 
 static struct notifier_block kvm_cpu_notifier = {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



