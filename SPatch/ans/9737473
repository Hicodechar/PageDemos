
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[06/10] paravirt: split pv_cpu_ops for support of PARAVIRT_FULL - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [06/10] paravirt: split pv_cpu_ops for support of PARAVIRT_FULL</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=100191">Juergen Gross</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 19, 2017, 3:47 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170519154746.29389-7-jgross@suse.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9737473/mbox/"
   >mbox</a>
|
   <a href="/patch/9737473/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9737473/">/patch/9737473/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DB4C36020B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 May 2017 15:50:11 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CE7D128A18
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 May 2017 15:50:11 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BE56A28A48; Fri, 19 May 2017 15:50:11 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B0C12288D2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 May 2017 15:50:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755988AbdESPsz (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 19 May 2017 11:48:55 -0400
Received: from mx2.suse.de ([195.135.220.15]:32985 &quot;EHLO mx1.suse.de&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1755565AbdESPr7 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 19 May 2017 11:47:59 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay1.suse.de (charybdis-ext.suse.de [195.135.220.254])
	by mx1.suse.de (Postfix) with ESMTP id 5CA75AD91;
	Fri, 19 May 2017 15:47:57 +0000 (UTC)
From: Juergen Gross &lt;jgross@suse.com&gt;
To: linux-kernel@vger.kernel.org, xen-devel@lists.xenproject.org,
	x86@kernel.org, virtualization@lists.linux-foundation.org
Cc: jeremy@goop.org, chrisw@sous-sol.org, akataria@vmware.com,
	rusty@rustcorp.com.au, boris.ostrovsky@oracle.com, hpa@zytor.com,
	tglx@linutronix.de, mingo@redhat.com, Juergen Gross &lt;jgross@suse.com&gt;
Subject: [PATCH 06/10] paravirt: split pv_cpu_ops for support of
	PARAVIRT_FULL
Date: Fri, 19 May 2017 17:47:42 +0200
Message-Id: &lt;20170519154746.29389-7-jgross@suse.com&gt;
X-Mailer: git-send-email 2.12.0
In-Reply-To: &lt;20170519154746.29389-1-jgross@suse.com&gt;
References: &lt;20170519154746.29389-1-jgross@suse.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=100191">Juergen Gross</a> - May 19, 2017, 3:47 p.m.</div>
<pre class="content">
Move functions needed for fully paravirtualized guests only into a new
structure pvfull_cpu_ops in paravirt_types_full.h, paravirt_full.h and
the associated vector into paravirt_full.c.
<span class="signed-off-by">
Signed-off-by: Juergen Gross &lt;jgross@suse.com&gt;</span>
---
 arch/x86/entry/entry_64.S                  |   4 +-
 arch/x86/include/asm/debugreg.h            |   2 +-
 arch/x86/include/asm/desc.h                |   4 +-
 arch/x86/include/asm/irqflags.h            |  16 +-
 arch/x86/include/asm/msr.h                 |   4 +-
 arch/x86/include/asm/paravirt.h            | 257 +--------------------------
 arch/x86/include/asm/paravirt_full.h       | 269 +++++++++++++++++++++++++++++
 arch/x86/include/asm/paravirt_types.h      |  78 +--------
 arch/x86/include/asm/paravirt_types_full.h |  78 +++++++++
 arch/x86/include/asm/pgtable.h             |   8 +-
 arch/x86/include/asm/processor.h           |   4 +-
 arch/x86/include/asm/special_insns.h       |  27 +--
 arch/x86/kernel/asm-offsets.c              |   9 +-
 arch/x86/kernel/asm-offsets_64.c           |   6 +-
 arch/x86/kernel/cpu/common.c               |   4 +-
 arch/x86/kernel/paravirt.c                 |  67 +------
 arch/x86/kernel/paravirt_full.c            |  66 +++++++
 arch/x86/kernel/paravirt_patch_32.c        |   8 +-
 arch/x86/kernel/paravirt_patch_64.c        |  18 +-
 arch/x86/lguest/boot.c                     |  38 ++--
 arch/x86/xen/enlighten_pv.c                |  14 +-
 21 files changed, 522 insertions(+), 459 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index cd47214ff402..4e85e9c9a2f8 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -42,12 +42,12 @@</span> <span class="p_context"></span>
 .code64
 .section .entry.text, &quot;ax&quot;
 
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
 ENTRY(native_usergs_sysret64)
 	swapgs
 	sysretq
 ENDPROC(native_usergs_sysret64)
<span class="p_del">-#endif /* CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif /* CONFIG_PARAVIRT_FULL */</span>
 
 .macro TRACE_IRQS_IRETQ
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_header">diff --git a/arch/x86/include/asm/debugreg.h b/arch/x86/include/asm/debugreg.h</span>
<span class="p_header">index 12cb66f6d3a5..6477da0e4869 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/debugreg.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/debugreg.h</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
 
 DECLARE_PER_CPU(unsigned long, cpu_dr7);
 
<span class="p_del">-#ifndef CONFIG_PARAVIRT</span>
<span class="p_add">+#ifndef CONFIG_PARAVIRT_FULL</span>
 /*
  * These special macros can be used to get or set a debugging register
  */
<span class="p_header">diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h</span>
<span class="p_header">index d0a21b12dd58..be2037db49a8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/desc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/desc.h</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> static inline int desc_empty(const void *ptr)</span>
 	return !(desc[0] | desc[1]);
 }
 
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
 #include &lt;asm/paravirt.h&gt;
 #else
 #define load_TR_desc()				native_load_tr_desc()
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
 static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)
 {
 }
<span class="p_del">-#endif	/* CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif	/* CONFIG_PARAVIRT_FULL */</span>
 
 #define store_ldt(ldt) asm(&quot;sldt %0&quot; : &quot;=m&quot;(ldt))
 
<span class="p_header">diff --git a/arch/x86/include/asm/irqflags.h b/arch/x86/include/asm/irqflags.h</span>
<span class="p_header">index ac7692dcfa2e..c3319c20127c 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/irqflags.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/irqflags.h</span>
<span class="p_chunk">@@ -119,6 +119,16 @@</span> <span class="p_context"> static inline notrace unsigned long arch_local_irq_save(void)</span>
 #define DISABLE_INTERRUPTS(x)	cli
 
 #ifdef CONFIG_X86_64
<span class="p_add">+#define PARAVIRT_ADJUST_EXCEPTION_FRAME	/*  */</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+#endif /* CONFIG_PARAVIRT */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+#ifdef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 #define SWAPGS	swapgs
 /*
  * Currently paravirt can&#39;t handle swapgs nicely when we
<span class="p_chunk">@@ -131,8 +141,6 @@</span> <span class="p_context"> static inline notrace unsigned long arch_local_irq_save(void)</span>
  */
 #define SWAPGS_UNSAFE_STACK	swapgs
 
<span class="p_del">-#define PARAVIRT_ADJUST_EXCEPTION_FRAME	/*  */</span>
<span class="p_del">-</span>
 #define INTERRUPT_RETURN	jmp native_iret
 #define USERGS_SYSRET64				\
 	swapgs;					\
<span class="p_chunk">@@ -143,13 +151,11 @@</span> <span class="p_context"> static inline notrace unsigned long arch_local_irq_save(void)</span>
 
 #else
 #define INTERRUPT_RETURN		iret
<span class="p_del">-#define ENABLE_INTERRUPTS_SYSEXIT	sti; sysexit</span>
 #define GET_CR0_INTO_EAX		movl %cr0, %eax
 #endif
 
<span class="p_del">-</span>
 #endif /* __ASSEMBLY__ */
<span class="p_del">-#endif /* CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif /* CONFIG_PARAVIRT_FULL */</span>
 
 #ifndef __ASSEMBLY__
 static inline int arch_irqs_disabled_flags(unsigned long flags)
<span class="p_header">diff --git a/arch/x86/include/asm/msr.h b/arch/x86/include/asm/msr.h</span>
<span class="p_header">index 898dba2e2e2c..7c715f811590 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/msr.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/msr.h</span>
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> static inline unsigned long long native_read_pmc(int counter)</span>
 	return EAX_EDX_VAL(val, low, high);
 }
 
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
 #include &lt;asm/paravirt.h&gt;
 #else
 #include &lt;linux/errno.h&gt;
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> do {							\</span>
 
 #define rdpmcl(counter, val) ((val) = native_read_pmc(counter))
 
<span class="p_del">-#endif	/* !CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif	/* !CONFIG_PARAVIRT_FULL */</span>
 
 /*
  * 64-bit version of wrmsr_safe():
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt.h b/arch/x86/include/asm/paravirt.h</span>
<span class="p_header">index 419a3b991e72..2287a2465486 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt.h</span>
<span class="p_chunk">@@ -19,42 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/paravirt_full.h&gt;
 #endif
 
<span class="p_del">-static inline void load_sp0(struct tss_struct *tss,</span>
<span class="p_del">-			     struct thread_struct *thread)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.load_sp0, tss, thread);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* The paravirtualized CPUID instruction. */</span>
<span class="p_del">-static inline void __cpuid(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_del">-			   unsigned int *ecx, unsigned int *edx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL4(pv_cpu_ops.cpuid, eax, ebx, ecx, edx);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * These special macros can be used to get or set a debugging register</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline unsigned long paravirt_get_debugreg(int reg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL1(unsigned long, pv_cpu_ops.get_debugreg, reg);</span>
<span class="p_del">-}</span>
<span class="p_del">-#define get_debugreg(var, reg) var = paravirt_get_debugreg(reg)</span>
<span class="p_del">-static inline void set_debugreg(unsigned long val, int reg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.set_debugreg, reg, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline unsigned long read_cr0(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL0(unsigned long, pv_cpu_ops.read_cr0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_cr0(unsigned long x)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.write_cr0, x);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long read_cr2(void)
 {
 	return PVOP_CALL0(unsigned long, pv_mmu_ops.read_cr2);
<span class="p_chunk">@@ -75,28 +39,6 @@</span> <span class="p_context"> static inline void write_cr3(unsigned long x)</span>
 	PVOP_VCALL1(pv_mmu_ops.write_cr3, x);
 }
 
<span class="p_del">-static inline unsigned long __read_cr4(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL0(unsigned long, pv_cpu_ops.read_cr4);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __write_cr4(unsigned long x)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.write_cr4, x);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static inline unsigned long read_cr8(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL0(unsigned long, pv_cpu_ops.read_cr8);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_cr8(unsigned long x)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.write_cr8, x);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static inline void arch_safe_halt(void)
 {
 	PVOP_VCALL0(pv_irq_ops.safe_halt);
<span class="p_chunk">@@ -107,77 +49,8 @@</span> <span class="p_context"> static inline void halt(void)</span>
 	PVOP_VCALL0(pv_irq_ops.halt);
 }
 
<span class="p_del">-static inline void wbinvd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL0(pv_cpu_ops.wbinvd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #define get_kernel_rpl()  (pv_info.kernel_rpl)
 
<span class="p_del">-static inline u64 paravirt_read_msr(unsigned msr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL1(u64, pv_cpu_ops.read_msr, msr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void paravirt_write_msr(unsigned msr,</span>
<span class="p_del">-				      unsigned low, unsigned high)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_VCALL3(pv_cpu_ops.write_msr, msr, low, high);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline u64 paravirt_read_msr_safe(unsigned msr, int *err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL2(u64, pv_cpu_ops.read_msr_safe, msr, err);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int paravirt_write_msr_safe(unsigned msr,</span>
<span class="p_del">-					  unsigned low, unsigned high)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL3(int, pv_cpu_ops.write_msr_safe, msr, low, high);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define rdmsr(msr, val1, val2)			\</span>
<span class="p_del">-do {						\</span>
<span class="p_del">-	u64 _l = paravirt_read_msr(msr);	\</span>
<span class="p_del">-	val1 = (u32)_l;				\</span>
<span class="p_del">-	val2 = _l &gt;&gt; 32;			\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define wrmsr(msr, val1, val2)			\</span>
<span class="p_del">-do {						\</span>
<span class="p_del">-	paravirt_write_msr(msr, val1, val2);	\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define rdmsrl(msr, val)			\</span>
<span class="p_del">-do {						\</span>
<span class="p_del">-	val = paravirt_read_msr(msr);		\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void wrmsrl(unsigned msr, u64 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	wrmsr(msr, (u32)val, (u32)(val&gt;&gt;32));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define wrmsr_safe(msr, a, b)	paravirt_write_msr_safe(msr, a, b)</span>
<span class="p_del">-</span>
<span class="p_del">-/* rdmsr with exception handling */</span>
<span class="p_del">-#define rdmsr_safe(msr, a, b)				\</span>
<span class="p_del">-({							\</span>
<span class="p_del">-	int _err;					\</span>
<span class="p_del">-	u64 _l = paravirt_read_msr_safe(msr, &amp;_err);	\</span>
<span class="p_del">-	(*a) = (u32)_l;					\</span>
<span class="p_del">-	(*b) = _l &gt;&gt; 32;				\</span>
<span class="p_del">-	_err;						\</span>
<span class="p_del">-})</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int rdmsrl_safe(unsigned msr, unsigned long long *p)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	*p = paravirt_read_msr_safe(msr, &amp;err);</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long long paravirt_sched_clock(void)
 {
 	return PVOP_CALL0(unsigned long long, pv_time_ops.sched_clock);
<span class="p_chunk">@@ -192,88 +65,6 @@</span> <span class="p_context"> static inline u64 paravirt_steal_clock(int cpu)</span>
 	return PVOP_CALL1(u64, pv_time_ops.steal_clock, cpu);
 }
 
<span class="p_del">-static inline unsigned long long paravirt_read_pmc(int counter)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL1(u64, pv_cpu_ops.read_pmc, counter);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define rdpmc(counter, low, high)		\</span>
<span class="p_del">-do {						\</span>
<span class="p_del">-	u64 _l = paravirt_read_pmc(counter);	\</span>
<span class="p_del">-	low = (u32)_l;				\</span>
<span class="p_del">-	high = _l &gt;&gt; 32;			\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define rdpmcl(counter, val) ((val) = paravirt_read_pmc(counter))</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.alloc_ldt, ldt, entries);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.free_ldt, ldt, entries);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void load_TR_desc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL0(pv_cpu_ops.load_tr_desc);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void load_gdt(const struct desc_ptr *dtr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.load_gdt, dtr);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void load_idt(const struct desc_ptr *dtr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.load_idt, dtr);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void set_ldt(const void *addr, unsigned entries)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.set_ldt, addr, entries);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void store_idt(struct desc_ptr *dtr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.store_idt, dtr);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline unsigned long paravirt_store_tr(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return PVOP_CALL0(unsigned long, pv_cpu_ops.store_tr);</span>
<span class="p_del">-}</span>
<span class="p_del">-#define store_tr(tr)	((tr) = paravirt_store_tr())</span>
<span class="p_del">-static inline void load_TLS(struct thread_struct *t, unsigned cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL2(pv_cpu_ops.load_tls, t, cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static inline void load_gs_index(unsigned int gs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.load_gs_index, gs);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_ldt_entry(struct desc_struct *dt, int entry,</span>
<span class="p_del">-				   const void *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL3(pv_cpu_ops.write_ldt_entry, dt, entry, desc);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_gdt_entry(struct desc_struct *dt, int entry,</span>
<span class="p_del">-				   void *desc, int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL4(pv_cpu_ops.write_gdt_entry, dt, entry, desc, type);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_idt_entry(gate_desc *dt, int entry, const gate_desc *g)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL3(pv_cpu_ops.write_idt_entry, dt, entry, g);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void set_iopl_mask(unsigned mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.set_iopl_mask, mask);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* The paravirtualized I/O functions */
 static inline void slow_down_io(void)
 {
<span class="p_chunk">@@ -670,17 +461,6 @@</span> <span class="p_context"> static inline void pmd_clear(pmd_t *pmdp)</span>
 }
 #endif	/* CONFIG_X86_PAE */
 
<span class="p_del">-#define  __HAVE_ARCH_START_CONTEXT_SWITCH</span>
<span class="p_del">-static inline void arch_start_context_switch(struct task_struct *prev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.start_context_switch, prev);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void arch_end_context_switch(struct task_struct *next)</span>
<span class="p_del">-{</span>
<span class="p_del">-	PVOP_VCALL1(pv_cpu_ops.end_context_switch, next);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #define  __HAVE_ARCH_ENTER_LAZY_MMU_MODE
 static inline void arch_enter_lazy_mmu_mode(void)
 {
<span class="p_chunk">@@ -924,10 +704,6 @@</span> <span class="p_context"> extern void default_banner(void);</span>
 #include &lt;asm/paravirt_full.h&gt;
 #endif
 
<span class="p_del">-#define INTERRUPT_RETURN						\</span>
<span class="p_del">-	PARA_SITE(PARA_PATCH(pv_cpu_ops, PV_CPU_iret), CLBR_NONE,	\</span>
<span class="p_del">-		  jmp PARA_INDIRECT(pv_cpu_ops+PV_CPU_iret))</span>
<span class="p_del">-</span>
 #define DISABLE_INTERRUPTS(clobbers)					\
 	PARA_SITE(PARA_PATCH(pv_irq_ops, PV_IRQ_irq_disable), clobbers, \
 		  PV_SAVE_REGS(clobbers | CLBR_CALLEE_SAVE);		\
<span class="p_chunk">@@ -940,32 +716,7 @@</span> <span class="p_context"> extern void default_banner(void);</span>
 		  call PARA_INDIRECT(pv_irq_ops+PV_IRQ_irq_enable);	\
 		  PV_RESTORE_REGS(clobbers | CLBR_CALLEE_SAVE);)
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-#define GET_CR0_INTO_EAX				\</span>
<span class="p_del">-	push %ecx; push %edx;				\</span>
<span class="p_del">-	call PARA_INDIRECT(pv_cpu_ops+PV_CPU_read_cr0);	\</span>
<span class="p_del">-	pop %edx; pop %ecx</span>
<span class="p_del">-#else	/* !CONFIG_X86_32 */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * If swapgs is used while the userspace stack is still current,</span>
<span class="p_del">- * there&#39;s no way to call a pvop.  The PV replacement *must* be</span>
<span class="p_del">- * inlined, or the swapgs instruction must be trapped and emulated.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define SWAPGS_UNSAFE_STACK						\</span>
<span class="p_del">-	PARA_SITE(PARA_PATCH(pv_cpu_ops, PV_CPU_swapgs), CLBR_NONE,	\</span>
<span class="p_del">-		  swapgs)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Note: swapgs is very special, and in practise is either going to be</span>
<span class="p_del">- * implemented with a single &quot;swapgs&quot; instruction or something very</span>
<span class="p_del">- * special.  Either way, we don&#39;t need to save any registers for</span>
<span class="p_del">- * it.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define SWAPGS								\</span>
<span class="p_del">-	PARA_SITE(PARA_PATCH(pv_cpu_ops, PV_CPU_swapgs), CLBR_NONE,	\</span>
<span class="p_del">-		  call PARA_INDIRECT(pv_cpu_ops+PV_CPU_swapgs)		\</span>
<span class="p_del">-		 )</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
 
 #define GET_CR2_INTO_RAX				\
 	call PARA_INDIRECT(pv_mmu_ops+PV_MMU_read_cr2)
<span class="p_chunk">@@ -975,11 +726,7 @@</span> <span class="p_context"> extern void default_banner(void);</span>
 		  CLBR_NONE,						\
 		  call PARA_INDIRECT(pv_irq_ops+PV_IRQ_adjust_exception_frame))
 
<span class="p_del">-#define USERGS_SYSRET64							\</span>
<span class="p_del">-	PARA_SITE(PARA_PATCH(pv_cpu_ops, PV_CPU_usergs_sysret64),	\</span>
<span class="p_del">-		  CLBR_NONE,						\</span>
<span class="p_del">-		  jmp PARA_INDIRECT(pv_cpu_ops+PV_CPU_usergs_sysret64))</span>
<span class="p_del">-#endif	/* CONFIG_X86_32 */</span>
<span class="p_add">+#endif	/* CONFIG_X86_64 */</span>
 
 #endif /* __ASSEMBLY__ */
 #else  /* CONFIG_PARAVIRT */
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt_full.h b/arch/x86/include/asm/paravirt_full.h</span>
<span class="p_header">index 1cabcfff6791..b3cf0960c161 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt_full.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt_full.h</span>
<span class="p_chunk">@@ -1,4 +1,273 @@</span> <span class="p_context"></span>
 #ifndef _ASM_X86_PARAVIRT_FULL_H
 #define _ASM_X86_PARAVIRT_FULL_H
 
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_sp0(struct tss_struct *tss,</span>
<span class="p_add">+			    struct thread_struct *thread)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.load_sp0, tss, thread);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* The paravirtualized CPUID instruction. */</span>
<span class="p_add">+static inline void __cpuid(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_add">+			   unsigned int *ecx, unsigned int *edx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL4(pvfull_cpu_ops.cpuid, eax, ebx, ecx, edx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * These special macros can be used to get or set a debugging register</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline unsigned long paravirt_get_debugreg(int reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL1(unsigned long, pvfull_cpu_ops.get_debugreg, reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define get_debugreg(var, reg) var = paravirt_get_debugreg(reg)</span>
<span class="p_add">+static inline void set_debugreg(unsigned long val, int reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.set_debugreg, reg, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long read_cr0(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL0(unsigned long, pvfull_cpu_ops.read_cr0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_cr0(unsigned long x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.write_cr0, x);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long __read_cr4(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL0(unsigned long, pvfull_cpu_ops.read_cr4);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __write_cr4(unsigned long x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.write_cr4, x);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static inline unsigned long read_cr8(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL0(unsigned long, pvfull_cpu_ops.read_cr8);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_cr8(unsigned long x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.write_cr8, x);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void wbinvd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL0(pvfull_cpu_ops.wbinvd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u64 paravirt_read_msr(unsigned msr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL1(u64, pvfull_cpu_ops.read_msr, msr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void paravirt_write_msr(unsigned msr,</span>
<span class="p_add">+				      unsigned low, unsigned high)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_VCALL3(pvfull_cpu_ops.write_msr, msr, low, high);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u64 paravirt_read_msr_safe(unsigned msr, int *err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL2(u64, pvfull_cpu_ops.read_msr_safe, msr, err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int paravirt_write_msr_safe(unsigned msr,</span>
<span class="p_add">+					  unsigned low, unsigned high)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL3(int, pvfull_cpu_ops.write_msr_safe, msr, low, high);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define rdmsr(msr, val1, val2)			\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	u64 _l = paravirt_read_msr(msr);	\</span>
<span class="p_add">+	val1 = (u32)_l;				\</span>
<span class="p_add">+	val2 = _l &gt;&gt; 32;			\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define wrmsr(msr, val1, val2)			\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	paravirt_write_msr(msr, val1, val2);	\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define rdmsrl(msr, val)			\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	val = paravirt_read_msr(msr);		\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void wrmsrl(unsigned msr, u64 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wrmsr(msr, (u32)val, (u32)(val&gt;&gt;32));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define wrmsr_safe(msr, a, b)	paravirt_write_msr_safe(msr, a, b)</span>
<span class="p_add">+</span>
<span class="p_add">+/* rdmsr with exception handling */</span>
<span class="p_add">+#define rdmsr_safe(msr, a, b)				\</span>
<span class="p_add">+({							\</span>
<span class="p_add">+	int _err;					\</span>
<span class="p_add">+	u64 _l = paravirt_read_msr_safe(msr, &amp;_err);	\</span>
<span class="p_add">+	(*a) = (u32)_l;					\</span>
<span class="p_add">+	(*b) = _l &gt;&gt; 32;				\</span>
<span class="p_add">+	_err;						\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int rdmsrl_safe(unsigned msr, unsigned long long *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	*p = paravirt_read_msr_safe(msr, &amp;err);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long long paravirt_read_pmc(int counter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL1(u64, pvfull_cpu_ops.read_pmc, counter);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define rdpmc(counter, low, high)		\</span>
<span class="p_add">+do {						\</span>
<span class="p_add">+	u64 _l = paravirt_read_pmc(counter);	\</span>
<span class="p_add">+	low = (u32)_l;				\</span>
<span class="p_add">+	high = _l &gt;&gt; 32;			\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define rdpmcl(counter, val) ((val) = paravirt_read_pmc(counter))</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void paravirt_alloc_ldt(struct desc_struct *ldt, unsigned entries)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.alloc_ldt, ldt, entries);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void paravirt_free_ldt(struct desc_struct *ldt, unsigned entries)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.free_ldt, ldt, entries);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_TR_desc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL0(pvfull_cpu_ops.load_tr_desc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_gdt(const struct desc_ptr *dtr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.load_gdt, dtr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_idt(const struct desc_ptr *dtr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.load_idt, dtr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void set_ldt(const void *addr, unsigned entries)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.set_ldt, addr, entries);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void store_idt(struct desc_ptr *dtr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.store_idt, dtr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long paravirt_store_tr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return PVOP_CALL0(unsigned long, pvfull_cpu_ops.store_tr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define store_tr(tr)	((tr) = paravirt_store_tr())</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_TLS(struct thread_struct *t, unsigned cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL2(pvfull_cpu_ops.load_tls, t, cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static inline void load_gs_index(unsigned int gs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.load_gs_index, gs);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_ldt_entry(struct desc_struct *dt, int entry,</span>
<span class="p_add">+				   const void *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL3(pvfull_cpu_ops.write_ldt_entry, dt, entry, desc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_gdt_entry(struct desc_struct *dt, int entry,</span>
<span class="p_add">+				   void *desc, int type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL4(pvfull_cpu_ops.write_gdt_entry, dt, entry, desc, type);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_idt_entry(gate_desc *dt, int entry, const gate_desc *g)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL3(pvfull_cpu_ops.write_idt_entry, dt, entry, g);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void set_iopl_mask(unsigned mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.set_iopl_mask, mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define  __HAVE_ARCH_START_CONTEXT_SWITCH</span>
<span class="p_add">+static inline void arch_start_context_switch(struct task_struct *prev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.start_context_switch, prev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_end_context_switch(struct task_struct *next)</span>
<span class="p_add">+{</span>
<span class="p_add">+	PVOP_VCALL1(pvfull_cpu_ops.end_context_switch, next);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define INTERRUPT_RETURN						\</span>
<span class="p_add">+	PARA_SITE(PARA_PATCH(pvfull_cpu_ops, PV_CPU_iret), CLBR_NONE,	\</span>
<span class="p_add">+		  jmp PARA_INDIRECT(pvfull_cpu_ops+PV_CPU_iret))</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+#define GET_CR0_INTO_EAX						\</span>
<span class="p_add">+	push %ecx; push %edx;						\</span>
<span class="p_add">+	call PARA_INDIRECT(pvfull_cpu_ops+PV_CPU_read_cr0);		\</span>
<span class="p_add">+	pop %edx; pop %ecx</span>
<span class="p_add">+#else   /* !CONFIG_X86_32 */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * If swapgs is used while the userspace stack is still current,</span>
<span class="p_add">+ * there&#39;s no way to call a pvop.  The PV replacement *must* be</span>
<span class="p_add">+ * inlined, or the swapgs instruction must be trapped and emulated.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SWAPGS_UNSAFE_STACK						\</span>
<span class="p_add">+	PARA_SITE(PARA_PATCH(pvfull_cpu_ops, PV_CPU_swapgs), CLBR_NONE,	\</span>
<span class="p_add">+		  swapgs)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Note: swapgs is very special, and in practise is either going to be</span>
<span class="p_add">+ * implemented with a single &quot;swapgs&quot; instruction or something very</span>
<span class="p_add">+ * special.  Either way, we don&#39;t need to save any registers for</span>
<span class="p_add">+ * it.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SWAPGS								\</span>
<span class="p_add">+	PARA_SITE(PARA_PATCH(pvfull_cpu_ops, PV_CPU_swapgs), CLBR_NONE,	\</span>
<span class="p_add">+		  call PARA_INDIRECT(pvfull_cpu_ops+PV_CPU_swapgs))</span>
<span class="p_add">+</span>
<span class="p_add">+#define USERGS_SYSRET64							\</span>
<span class="p_add">+	PARA_SITE(PARA_PATCH(pvfull_cpu_ops, PV_CPU_usergs_sysret64),	\</span>
<span class="p_add">+		  CLBR_NONE,						\</span>
<span class="p_add">+		  jmp PARA_INDIRECT(pvfull_cpu_ops+PV_CPU_usergs_sysret64))</span>
<span class="p_add">+#endif  /* CONFIG_X86_32 */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
 #endif /* _ASM_X86_PARAVIRT_FULL_H */
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt_types.h b/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_header">index dbb0e69cd5c6..e0fb1291bbdb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt_types.h</span>
<span class="p_chunk">@@ -103,82 +103,7 @@</span> <span class="p_context"> struct pv_time_ops {</span>
 };
 
 struct pv_cpu_ops {
<span class="p_del">-	/* hooks for various privileged instructions */</span>
<span class="p_del">-	unsigned long (*get_debugreg)(int regno);</span>
<span class="p_del">-	void (*set_debugreg)(int regno, unsigned long value);</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long (*read_cr0)(void);</span>
<span class="p_del">-	void (*write_cr0)(unsigned long);</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long (*read_cr4)(void);</span>
<span class="p_del">-	void (*write_cr4)(unsigned long);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	unsigned long (*read_cr8)(void);</span>
<span class="p_del">-	void (*write_cr8)(unsigned long);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Segment descriptor handling */</span>
<span class="p_del">-	void (*load_tr_desc)(void);</span>
<span class="p_del">-	void (*load_gdt)(const struct desc_ptr *);</span>
<span class="p_del">-	void (*load_idt)(const struct desc_ptr *);</span>
<span class="p_del">-	/* store_gdt has been removed. */</span>
<span class="p_del">-	void (*store_idt)(struct desc_ptr *);</span>
<span class="p_del">-	void (*set_ldt)(const void *desc, unsigned entries);</span>
<span class="p_del">-	unsigned long (*store_tr)(void);</span>
<span class="p_del">-	void (*load_tls)(struct thread_struct *t, unsigned int cpu);</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	void (*load_gs_index)(unsigned int idx);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	void (*write_ldt_entry)(struct desc_struct *ldt, int entrynum,</span>
<span class="p_del">-				const void *desc);</span>
<span class="p_del">-	void (*write_gdt_entry)(struct desc_struct *,</span>
<span class="p_del">-				int entrynum, const void *desc, int size);</span>
<span class="p_del">-	void (*write_idt_entry)(gate_desc *,</span>
<span class="p_del">-				int entrynum, const gate_desc *gate);</span>
<span class="p_del">-	void (*alloc_ldt)(struct desc_struct *ldt, unsigned entries);</span>
<span class="p_del">-	void (*free_ldt)(struct desc_struct *ldt, unsigned entries);</span>
<span class="p_del">-</span>
<span class="p_del">-	void (*load_sp0)(struct tss_struct *tss, struct thread_struct *t);</span>
<span class="p_del">-</span>
<span class="p_del">-	void (*set_iopl_mask)(unsigned mask);</span>
<span class="p_del">-</span>
<span class="p_del">-	void (*wbinvd)(void);</span>
 	void (*io_delay)(void);
<span class="p_del">-</span>
<span class="p_del">-	/* cpuid emulation, mostly so that caps bits can be disabled */</span>
<span class="p_del">-	void (*cpuid)(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_del">-		      unsigned int *ecx, unsigned int *edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Unsafe MSR operations.  These will warn or panic on failure. */</span>
<span class="p_del">-	u64 (*read_msr)(unsigned int msr);</span>
<span class="p_del">-	void (*write_msr)(unsigned int msr, unsigned low, unsigned high);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Safe MSR operations.</span>
<span class="p_del">-	 * read sets err to 0 or -EIO.  write returns 0 or -EIO.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	u64 (*read_msr_safe)(unsigned int msr, int *err);</span>
<span class="p_del">-	int (*write_msr_safe)(unsigned int msr, unsigned low, unsigned high);</span>
<span class="p_del">-</span>
<span class="p_del">-	u64 (*read_pmc)(int counter);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Switch to usermode gs and return to 64-bit usermode using</span>
<span class="p_del">-	 * sysret.  Only used in 64-bit kernels to return to 64-bit</span>
<span class="p_del">-	 * processes.  Usermode register state, including %rsp, must</span>
<span class="p_del">-	 * already be restored.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	void (*usergs_sysret64)(void);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Normal iret.  Jump to this with the standard iret stack</span>
<span class="p_del">-	   frame set up. */</span>
<span class="p_del">-	void (*iret)(void);</span>
<span class="p_del">-</span>
<span class="p_del">-	void (*swapgs)(void);</span>
<span class="p_del">-</span>
<span class="p_del">-	void (*start_context_switch)(struct task_struct *prev);</span>
<span class="p_del">-	void (*end_context_switch)(struct task_struct *next);</span>
 };
 
 struct pv_irq_ops {
<span class="p_chunk">@@ -339,6 +264,9 @@</span> <span class="p_context"> struct paravirt_patch_template {</span>
 	struct pv_irq_ops pv_irq_ops;
 	struct pv_mmu_ops pv_mmu_ops;
 	struct pv_lock_ops pv_lock_ops;
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+	struct pvfull_cpu_ops pvfull_cpu_ops;</span>
<span class="p_add">+#endif</span>
 };
 
 extern struct pv_info pv_info;
<span class="p_header">diff --git a/arch/x86/include/asm/paravirt_types_full.h b/arch/x86/include/asm/paravirt_types_full.h</span>
<span class="p_header">index 69c048324e70..50635628f6e8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/paravirt_types_full.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/paravirt_types_full.h</span>
<span class="p_chunk">@@ -1,4 +1,82 @@</span> <span class="p_context"></span>
 #ifndef _ASM_X86_PARAVIRT_TYPES_FULL_H
 #define _ASM_X86_PARAVIRT_TYPES_FULL_H
 
<span class="p_add">+struct pvfull_cpu_ops {</span>
<span class="p_add">+	/* hooks for various privileged instructions */</span>
<span class="p_add">+	unsigned long (*get_debugreg)(int regno);</span>
<span class="p_add">+	void (*set_debugreg)(int regno, unsigned long value);</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned long (*read_cr0)(void);</span>
<span class="p_add">+	void (*write_cr0)(unsigned long);</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned long (*read_cr4)(void);</span>
<span class="p_add">+	void (*write_cr4)(unsigned long);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	unsigned long (*read_cr8)(void);</span>
<span class="p_add">+	void (*write_cr8)(unsigned long);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Segment descriptor handling */</span>
<span class="p_add">+	void (*load_tr_desc)(void);</span>
<span class="p_add">+	void (*load_gdt)(const struct desc_ptr *);</span>
<span class="p_add">+	void (*load_idt)(const struct desc_ptr *);</span>
<span class="p_add">+	void (*store_idt)(struct desc_ptr *);</span>
<span class="p_add">+	void (*set_ldt)(const void *desc, unsigned entries);</span>
<span class="p_add">+	unsigned long (*store_tr)(void);</span>
<span class="p_add">+	void (*load_tls)(struct thread_struct *t, unsigned int cpu);</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	void (*load_gs_index)(unsigned int idx);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	void (*write_ldt_entry)(struct desc_struct *ldt, int entrynum,</span>
<span class="p_add">+				const void *desc);</span>
<span class="p_add">+	void (*write_gdt_entry)(struct desc_struct *,</span>
<span class="p_add">+				int entrynum, const void *desc, int size);</span>
<span class="p_add">+	void (*write_idt_entry)(gate_desc *,</span>
<span class="p_add">+				int entrynum, const gate_desc *gate);</span>
<span class="p_add">+	void (*alloc_ldt)(struct desc_struct *ldt, unsigned entries);</span>
<span class="p_add">+	void (*free_ldt)(struct desc_struct *ldt, unsigned entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*load_sp0)(struct tss_struct *tss, struct thread_struct *t);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*set_iopl_mask)(unsigned mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*wbinvd)(void);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* cpuid emulation, mostly so that caps bits can be disabled */</span>
<span class="p_add">+	void (*cpuid)(unsigned int *eax, unsigned int *ebx,</span>
<span class="p_add">+		      unsigned int *ecx, unsigned int *edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unsafe MSR operations.  These will warn or panic on failure. */</span>
<span class="p_add">+	u64 (*read_msr)(unsigned int msr);</span>
<span class="p_add">+	void (*write_msr)(unsigned int msr, unsigned low, unsigned high);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Safe MSR operations.</span>
<span class="p_add">+	 * read sets err to 0 or -EIO.  write returns 0 or -EIO.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	u64 (*read_msr_safe)(unsigned int msr, int *err);</span>
<span class="p_add">+	int (*write_msr_safe)(unsigned int msr, unsigned low, unsigned high);</span>
<span class="p_add">+</span>
<span class="p_add">+	u64 (*read_pmc)(int counter);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Switch to usermode gs and return to 64-bit usermode using</span>
<span class="p_add">+	 * sysret.  Only used in 64-bit kernels to return to 64-bit</span>
<span class="p_add">+	 * processes.  Usermode register state, including %rsp, must</span>
<span class="p_add">+	 * already be restored.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	void (*usergs_sysret64)(void);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Normal iret.  Jump to this with the std iret stack frame set up. */</span>
<span class="p_add">+	void (*iret)(void);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*swapgs)(void);</span>
<span class="p_add">+</span>
<span class="p_add">+	void (*start_context_switch)(struct task_struct *prev);</span>
<span class="p_add">+	void (*end_context_switch)(struct task_struct *next);</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct pvfull_cpu_ops pvfull_cpu_ops;</span>
<span class="p_add">+</span>
 #endif  /* _ASM_X86_PARAVIRT_TYPES_FULL_H */
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">index f5af95a0c6b8..fad12c481bf9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -98,10 +98,14 @@</span> <span class="p_context"> extern struct mm_struct *pgd_page_get_mm(struct page *page);</span>
 #define pte_val(x)	native_pte_val(x)
 #define __pte(x)	native_make_pte(x)
 
<span class="p_del">-#define arch_end_context_switch(prev)	do {} while(0)</span>
<span class="p_del">-</span>
 #endif	/* CONFIG_PARAVIRT */
 
<span class="p_add">+#ifndef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_end_context_switch(prev)	do {} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif  /* CONFIG_PARAVIRT_FULL */</span>
<span class="p_add">+</span>
 /*
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 3cada998a402..9592c47f52bc 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -531,7 +531,7 @@</span> <span class="p_context"> static inline unsigned long current_top_of_stack(void)</span>
 #endif
 }
 
<span class="p_del">-#ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
 #include &lt;asm/paravirt.h&gt;
 #else
 #define __cpuid			native_cpuid
<span class="p_chunk">@@ -543,7 +543,7 @@</span> <span class="p_context"> static inline void load_sp0(struct tss_struct *tss,</span>
 }
 
 #define set_iopl_mask native_set_iopl_mask
<span class="p_del">-#endif /* CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif /* CONFIG_PARAVIRT_FULL */</span>
 
 /* Free all resources held by a thread. */
 extern void release_thread(struct task_struct *);
<span class="p_header">diff --git a/arch/x86/include/asm/special_insns.h b/arch/x86/include/asm/special_insns.h</span>
<span class="p_header">index 12af3e35edfa..ca3a3103791d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/special_insns.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/special_insns.h</span>
<span class="p_chunk">@@ -139,16 +139,6 @@</span> <span class="p_context"> extern asmlinkage void native_load_gs_index(unsigned);</span>
 #include &lt;asm/paravirt.h&gt;
 #else
 
<span class="p_del">-static inline unsigned long read_cr0(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return native_read_cr0();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void write_cr0(unsigned long x)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_write_cr0(x);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long read_cr2(void)
 {
 	return native_read_cr2();
<span class="p_chunk">@@ -169,6 +159,20 @@</span> <span class="p_context"> static inline void write_cr3(unsigned long x)</span>
 	native_write_cr3(x);
 }
 
<span class="p_add">+#endif/* CONFIG_PARAVIRT */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long read_cr0(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return native_read_cr0();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void write_cr0(unsigned long x)</span>
<span class="p_add">+{</span>
<span class="p_add">+	native_write_cr0(x);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long __read_cr4(void)
 {
 	return native_read_cr4();
<span class="p_chunk">@@ -203,7 +207,8 @@</span> <span class="p_context"> static inline void load_gs_index(unsigned selector)</span>
 
 #endif
 
<span class="p_del">-#endif/* CONFIG_PARAVIRT */</span>
<span class="p_add">+#endif /* CONFIG_PARAVIRT_FULL */</span>
<span class="p_add">+</span>
 
 static inline void clflush(volatile void *__p)
 {
<span class="p_header">diff --git a/arch/x86/kernel/asm-offsets.c b/arch/x86/kernel/asm-offsets.c</span>
<span class="p_header">index de827d6ac8c2..7b393e453333 100644</span>
<span class="p_header">--- a/arch/x86/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/x86/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -64,14 +64,17 @@</span> <span class="p_context"> void common(void) {</span>
 
 #ifdef CONFIG_PARAVIRT
 	BLANK();
<span class="p_del">-	OFFSET(PARAVIRT_PATCH_pv_cpu_ops, paravirt_patch_template, pv_cpu_ops);</span>
 	OFFSET(PARAVIRT_PATCH_pv_irq_ops, paravirt_patch_template, pv_irq_ops);
 	OFFSET(PV_IRQ_irq_disable, pv_irq_ops, irq_disable);
 	OFFSET(PV_IRQ_irq_enable, pv_irq_ops, irq_enable);
<span class="p_del">-	OFFSET(PV_CPU_iret, pv_cpu_ops, iret);</span>
<span class="p_del">-	OFFSET(PV_CPU_read_cr0, pv_cpu_ops, read_cr0);</span>
 	OFFSET(PV_MMU_read_cr2, pv_mmu_ops, read_cr2);
 #endif
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+	OFFSET(PARAVIRT_PATCH_pvfull_cpu_ops, paravirt_patch_template,</span>
<span class="p_add">+	       pvfull_cpu_ops);</span>
<span class="p_add">+	OFFSET(PV_CPU_iret, pvfull_cpu_ops, iret);</span>
<span class="p_add">+	OFFSET(PV_CPU_read_cr0, pvfull_cpu_ops, read_cr0);</span>
<span class="p_add">+#endif</span>
 
 #ifdef CONFIG_XEN
 	BLANK();
<span class="p_header">diff --git a/arch/x86/kernel/asm-offsets_64.c b/arch/x86/kernel/asm-offsets_64.c</span>
<span class="p_header">index 99332f550c48..f4fe7d9ac0d9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/asm-offsets_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/asm-offsets_64.c</span>
<span class="p_chunk">@@ -21,8 +21,10 @@</span> <span class="p_context"> int main(void)</span>
 {
 #ifdef CONFIG_PARAVIRT
 	OFFSET(PV_IRQ_adjust_exception_frame, pv_irq_ops, adjust_exception_frame);
<span class="p_del">-	OFFSET(PV_CPU_usergs_sysret64, pv_cpu_ops, usergs_sysret64);</span>
<span class="p_del">-	OFFSET(PV_CPU_swapgs, pv_cpu_ops, swapgs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+	OFFSET(PV_CPU_usergs_sysret64, pvfull_cpu_ops, usergs_sysret64);</span>
<span class="p_add">+	OFFSET(PV_CPU_swapgs, pvfull_cpu_ops, swapgs);</span>
 	BLANK();
 #endif
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index c8b39870f33e..53081df88420 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1017,10 +1017,10 @@</span> <span class="p_context"> static void generic_identify(struct cpuinfo_x86 *c)</span>
 	 * ESPFIX issue, we can change this.
 	 */
 #ifdef CONFIG_X86_32
<span class="p_del">-# ifdef CONFIG_PARAVIRT</span>
<span class="p_add">+# ifdef CONFIG_PARAVIRT_FULL</span>
 	do {
 		extern void native_iret(void);
<span class="p_del">-		if (pv_cpu_ops.iret == native_iret)</span>
<span class="p_add">+		if (pvfull_cpu_ops.iret == native_iret)</span>
 			set_cpu_bug(c, X86_BUG_ESPFIX);
 	} while (0);
 # else
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index b8b23b3f24c2..6b90de65479e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -24,12 +24,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/bcd.h&gt;
 #include &lt;linux/highmem.h&gt;
<span class="p_del">-#include &lt;linux/kprobes.h&gt;</span>
 
 #include &lt;asm/bug.h&gt;
 #include &lt;asm/paravirt.h&gt;
<span class="p_del">-#include &lt;asm/debugreg.h&gt;</span>
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/time.h&gt;
<span class="p_chunk">@@ -128,6 +125,9 @@</span> <span class="p_context"> static void *get_call_destination(u8 type)</span>
 #ifdef CONFIG_PARAVIRT_SPINLOCKS
 		.pv_lock_ops = pv_lock_ops,
 #endif
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+		.pvfull_cpu_ops = pvfull_cpu_ops,</span>
<span class="p_add">+#endif</span>
 	};
 	return *((void **)&amp;tmpl + type);
 }
<span class="p_chunk">@@ -150,10 +150,12 @@</span> <span class="p_context"> unsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,</span>
 	else if (opfunc == _paravirt_ident_64)
 		ret = paravirt_patch_ident_64(insnbuf, len);
 
<span class="p_del">-	else if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||</span>
<span class="p_del">-		 type == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret64))</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+	else if (type == PARAVIRT_PATCH(pvfull_cpu_ops.iret) ||</span>
<span class="p_add">+		 type == PARAVIRT_PATCH(pvfull_cpu_ops.usergs_sysret64))</span>
 		/* If operation requires a jmp, then jmp */
 		ret = paravirt_patch_jmp(insnbuf, opfunc, addr, len);
<span class="p_add">+#endif</span>
 	else
 		/* Otherwise call the function; assume target could
 		   clobber any caller-save reg */
<span class="p_chunk">@@ -203,10 +205,6 @@</span> <span class="p_context"> static u64 native_steal_clock(int cpu)</span>
 	return 0;
 }
 
<span class="p_del">-/* These are in entry.S */</span>
<span class="p_del">-extern void native_iret(void);</span>
<span class="p_del">-extern void native_usergs_sysret64(void);</span>
<span class="p_del">-</span>
 static DEFINE_PER_CPU(enum paravirt_lazy_mode, paravirt_lazy_mode) = PARAVIRT_LAZY_NONE;
 
 static inline void enter_lazy(enum paravirt_lazy_mode mode)
<span class="p_chunk">@@ -306,60 +304,9 @@</span> <span class="p_context"> __visible struct pv_irq_ops pv_irq_ops = {</span>
 };
 
 __visible struct pv_cpu_ops pv_cpu_ops = {
<span class="p_del">-	.cpuid = native_cpuid,</span>
<span class="p_del">-	.get_debugreg = native_get_debugreg,</span>
<span class="p_del">-	.set_debugreg = native_set_debugreg,</span>
<span class="p_del">-	.read_cr0 = native_read_cr0,</span>
<span class="p_del">-	.write_cr0 = native_write_cr0,</span>
<span class="p_del">-	.read_cr4 = native_read_cr4,</span>
<span class="p_del">-	.write_cr4 = native_write_cr4,</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	.read_cr8 = native_read_cr8,</span>
<span class="p_del">-	.write_cr8 = native_write_cr8,</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	.wbinvd = native_wbinvd,</span>
<span class="p_del">-	.read_msr = native_read_msr,</span>
<span class="p_del">-	.write_msr = native_write_msr,</span>
<span class="p_del">-	.read_msr_safe = native_read_msr_safe,</span>
<span class="p_del">-	.write_msr_safe = native_write_msr_safe,</span>
<span class="p_del">-	.read_pmc = native_read_pmc,</span>
<span class="p_del">-	.load_tr_desc = native_load_tr_desc,</span>
<span class="p_del">-	.set_ldt = native_set_ldt,</span>
<span class="p_del">-	.load_gdt = native_load_gdt,</span>
<span class="p_del">-	.load_idt = native_load_idt,</span>
<span class="p_del">-	.store_idt = native_store_idt,</span>
<span class="p_del">-	.store_tr = native_store_tr,</span>
<span class="p_del">-	.load_tls = native_load_tls,</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	.load_gs_index = native_load_gs_index,</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	.write_ldt_entry = native_write_ldt_entry,</span>
<span class="p_del">-	.write_gdt_entry = native_write_gdt_entry,</span>
<span class="p_del">-	.write_idt_entry = native_write_idt_entry,</span>
<span class="p_del">-</span>
<span class="p_del">-	.alloc_ldt = paravirt_nop,</span>
<span class="p_del">-	.free_ldt = paravirt_nop,</span>
<span class="p_del">-</span>
<span class="p_del">-	.load_sp0 = native_load_sp0,</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	.usergs_sysret64 = native_usergs_sysret64,</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	.iret = native_iret,</span>
<span class="p_del">-	.swapgs = native_swapgs,</span>
<span class="p_del">-</span>
<span class="p_del">-	.set_iopl_mask = native_set_iopl_mask,</span>
 	.io_delay = native_io_delay,
<span class="p_del">-</span>
<span class="p_del">-	.start_context_switch = paravirt_nop,</span>
<span class="p_del">-	.end_context_switch = paravirt_nop,</span>
 };
 
<span class="p_del">-/* At this point, native_get/set_debugreg has real function entries */</span>
<span class="p_del">-NOKPROBE_SYMBOL(native_get_debugreg);</span>
<span class="p_del">-NOKPROBE_SYMBOL(native_set_debugreg);</span>
<span class="p_del">-NOKPROBE_SYMBOL(native_load_idt);</span>
<span class="p_del">-</span>
 #if defined(CONFIG_X86_32) &amp;&amp; !defined(CONFIG_X86_PAE)
 /* 32-bit pagetable entries */
 #define PTE_IDENT	__PV_IS_CALLEE_SAVE(_paravirt_ident_32)
<span class="p_header">diff --git a/arch/x86/kernel/paravirt_full.c b/arch/x86/kernel/paravirt_full.c</span>
<span class="p_header">index 0c7de64129c5..9b8708421cd2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt_full.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt_full.c</span>
<span class="p_chunk">@@ -13,4 +13,70 @@</span> <span class="p_context"></span>
     GNU General Public License for more details.
 */
 
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/kprobes.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;asm/paravirt.h&gt;
<span class="p_add">+#include &lt;asm/debugreg.h&gt;</span>
<span class="p_add">+#include &lt;asm/desc.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* These are in entry.S */</span>
<span class="p_add">+extern void native_iret(void);</span>
<span class="p_add">+extern void native_usergs_sysret64(void);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible struct pvfull_cpu_ops pvfull_cpu_ops = {</span>
<span class="p_add">+	.cpuid = native_cpuid,</span>
<span class="p_add">+	.get_debugreg = native_get_debugreg,</span>
<span class="p_add">+	.set_debugreg = native_set_debugreg,</span>
<span class="p_add">+	.read_cr0 = native_read_cr0,</span>
<span class="p_add">+	.write_cr0 = native_write_cr0,</span>
<span class="p_add">+	.read_cr4 = native_read_cr4,</span>
<span class="p_add">+	.write_cr4 = native_write_cr4,</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	.read_cr8 = native_read_cr8,</span>
<span class="p_add">+	.write_cr8 = native_write_cr8,</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.wbinvd = native_wbinvd,</span>
<span class="p_add">+	.read_msr = native_read_msr,</span>
<span class="p_add">+	.write_msr = native_write_msr,</span>
<span class="p_add">+	.read_msr_safe = native_read_msr_safe,</span>
<span class="p_add">+	.write_msr_safe = native_write_msr_safe,</span>
<span class="p_add">+	.read_pmc = native_read_pmc,</span>
<span class="p_add">+	.load_tr_desc = native_load_tr_desc,</span>
<span class="p_add">+	.set_ldt = native_set_ldt,</span>
<span class="p_add">+	.load_gdt = native_load_gdt,</span>
<span class="p_add">+	.load_idt = native_load_idt,</span>
<span class="p_add">+	.store_idt = native_store_idt,</span>
<span class="p_add">+	.store_tr = native_store_tr,</span>
<span class="p_add">+	.load_tls = native_load_tls,</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	.load_gs_index = native_load_gs_index,</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.write_ldt_entry = native_write_ldt_entry,</span>
<span class="p_add">+	.write_gdt_entry = native_write_gdt_entry,</span>
<span class="p_add">+	.write_idt_entry = native_write_idt_entry,</span>
<span class="p_add">+</span>
<span class="p_add">+	.alloc_ldt = paravirt_nop,</span>
<span class="p_add">+	.free_ldt = paravirt_nop,</span>
<span class="p_add">+</span>
<span class="p_add">+	.load_sp0 = native_load_sp0,</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	.usergs_sysret64 = native_usergs_sysret64,</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.iret = native_iret,</span>
<span class="p_add">+	.swapgs = native_swapgs,</span>
<span class="p_add">+</span>
<span class="p_add">+	.set_iopl_mask = native_set_iopl_mask,</span>
<span class="p_add">+</span>
<span class="p_add">+	.start_context_switch = paravirt_nop,</span>
<span class="p_add">+	.end_context_switch = paravirt_nop,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* At this point, native_get/set_debugreg has real function entries */</span>
<span class="p_add">+NOKPROBE_SYMBOL(native_get_debugreg);</span>
<span class="p_add">+NOKPROBE_SYMBOL(native_set_debugreg);</span>
<span class="p_add">+NOKPROBE_SYMBOL(native_load_idt);</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(pvfull_cpu_ops);</span>
<span class="p_header">diff --git a/arch/x86/kernel/paravirt_patch_32.c b/arch/x86/kernel/paravirt_patch_32.c</span>
<span class="p_header">index 553acbbb4d32..ccb75951aed5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt_patch_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt_patch_32.c</span>
<span class="p_chunk">@@ -4,10 +4,12 @@</span> <span class="p_context"> DEF_NATIVE(pv_irq_ops, irq_disable, &quot;cli&quot;);</span>
 DEF_NATIVE(pv_irq_ops, irq_enable, &quot;sti&quot;);
 DEF_NATIVE(pv_irq_ops, restore_fl, &quot;push %eax; popf&quot;);
 DEF_NATIVE(pv_irq_ops, save_fl, &quot;pushf; pop %eax&quot;);
<span class="p_del">-DEF_NATIVE(pv_cpu_ops, iret, &quot;iret&quot;);</span>
 DEF_NATIVE(pv_mmu_ops, read_cr2, &quot;mov %cr2, %eax&quot;);
 DEF_NATIVE(pv_mmu_ops, write_cr3, &quot;mov %eax, %cr3&quot;);
 DEF_NATIVE(pv_mmu_ops, read_cr3, &quot;mov %cr3, %eax&quot;);
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+DEF_NATIVE(pvfull_cpu_ops, iret, &quot;iret&quot;);</span>
<span class="p_add">+#endif</span>
 
 #if defined(CONFIG_PARAVIRT_SPINLOCKS)
 DEF_NATIVE(pv_lock_ops, queued_spin_unlock, &quot;movb $0, (%eax)&quot;);
<span class="p_chunk">@@ -45,10 +47,12 @@</span> <span class="p_context"> unsigned native_patch(u8 type, u16 clobbers, void *ibuf,</span>
 		PATCH_SITE(pv_irq_ops, irq_enable);
 		PATCH_SITE(pv_irq_ops, restore_fl);
 		PATCH_SITE(pv_irq_ops, save_fl);
<span class="p_del">-		PATCH_SITE(pv_cpu_ops, iret);</span>
 		PATCH_SITE(pv_mmu_ops, read_cr2);
 		PATCH_SITE(pv_mmu_ops, read_cr3);
 		PATCH_SITE(pv_mmu_ops, write_cr3);
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+		PATCH_SITE(pvfull_cpu_ops, iret);</span>
<span class="p_add">+#endif</span>
 #if defined(CONFIG_PARAVIRT_SPINLOCKS)
 		case PARAVIRT_PATCH(pv_lock_ops.queued_spin_unlock):
 			if (pv_is_native_spin_unlock()) {
<span class="p_header">diff --git a/arch/x86/kernel/paravirt_patch_64.c b/arch/x86/kernel/paravirt_patch_64.c</span>
<span class="p_header">index 11aaf1eaa0e4..00d5c77d23a7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt_patch_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt_patch_64.c</span>
<span class="p_chunk">@@ -10,14 +10,16 @@</span> <span class="p_context"> DEF_NATIVE(pv_mmu_ops, read_cr2, &quot;movq %cr2, %rax&quot;);</span>
 DEF_NATIVE(pv_mmu_ops, read_cr3, &quot;movq %cr3, %rax&quot;);
 DEF_NATIVE(pv_mmu_ops, write_cr3, &quot;movq %rdi, %cr3&quot;);
 DEF_NATIVE(pv_mmu_ops, flush_tlb_single, &quot;invlpg (%rdi)&quot;);
<span class="p_del">-DEF_NATIVE(pv_cpu_ops, wbinvd, &quot;wbinvd&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-DEF_NATIVE(pv_cpu_ops, usergs_sysret64, &quot;swapgs; sysretq&quot;);</span>
<span class="p_del">-DEF_NATIVE(pv_cpu_ops, swapgs, &quot;swapgs&quot;);</span>
 
 DEF_NATIVE(, mov32, &quot;mov %edi, %eax&quot;);
 DEF_NATIVE(, mov64, &quot;mov %rdi, %rax&quot;);
 
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+DEF_NATIVE(pvfull_cpu_ops, wbinvd, &quot;wbinvd&quot;);</span>
<span class="p_add">+DEF_NATIVE(pvfull_cpu_ops, usergs_sysret64, &quot;swapgs; sysretq&quot;);</span>
<span class="p_add">+DEF_NATIVE(pvfull_cpu_ops, swapgs, &quot;swapgs&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #if defined(CONFIG_PARAVIRT_SPINLOCKS)
 DEF_NATIVE(pv_lock_ops, queued_spin_unlock, &quot;movb $0, (%rdi)&quot;);
 DEF_NATIVE(pv_lock_ops, vcpu_is_preempted, &quot;xor %rax, %rax&quot;);
<span class="p_chunk">@@ -54,13 +56,15 @@</span> <span class="p_context"> unsigned native_patch(u8 type, u16 clobbers, void *ibuf,</span>
 		PATCH_SITE(pv_irq_ops, save_fl);
 		PATCH_SITE(pv_irq_ops, irq_enable);
 		PATCH_SITE(pv_irq_ops, irq_disable);
<span class="p_del">-		PATCH_SITE(pv_cpu_ops, usergs_sysret64);</span>
<span class="p_del">-		PATCH_SITE(pv_cpu_ops, swapgs);</span>
 		PATCH_SITE(pv_mmu_ops, read_cr2);
 		PATCH_SITE(pv_mmu_ops, read_cr3);
 		PATCH_SITE(pv_mmu_ops, write_cr3);
 		PATCH_SITE(pv_mmu_ops, flush_tlb_single);
<span class="p_del">-		PATCH_SITE(pv_cpu_ops, wbinvd);</span>
<span class="p_add">+#ifdef CONFIG_PARAVIRT_FULL</span>
<span class="p_add">+		PATCH_SITE(pvfull_cpu_ops, usergs_sysret64);</span>
<span class="p_add">+		PATCH_SITE(pvfull_cpu_ops, swapgs);</span>
<span class="p_add">+		PATCH_SITE(pvfull_cpu_ops, wbinvd);</span>
<span class="p_add">+#endif</span>
 #if defined(CONFIG_PARAVIRT_SPINLOCKS)
 		case PARAVIRT_PATCH(pv_lock_ops.queued_spin_unlock):
 			if (pv_is_native_spin_unlock()) {
<span class="p_header">diff --git a/arch/x86/lguest/boot.c b/arch/x86/lguest/boot.c</span>
<span class="p_header">index 99472698c931..fa79dbe220ad 100644</span>
<span class="p_header">--- a/arch/x86/lguest/boot.c</span>
<span class="p_header">+++ b/arch/x86/lguest/boot.c</span>
<span class="p_chunk">@@ -1410,25 +1410,25 @@</span> <span class="p_context"> __init void lguest_init(void)</span>
 	pv_init_ops.patch = lguest_patch;
 
 	/* Intercepts of various CPU instructions */
<span class="p_del">-	pv_cpu_ops.load_gdt = lguest_load_gdt;</span>
<span class="p_del">-	pv_cpu_ops.cpuid = lguest_cpuid;</span>
<span class="p_del">-	pv_cpu_ops.load_idt = lguest_load_idt;</span>
<span class="p_del">-	pv_cpu_ops.iret = lguest_iret;</span>
<span class="p_del">-	pv_cpu_ops.load_sp0 = lguest_load_sp0;</span>
<span class="p_del">-	pv_cpu_ops.load_tr_desc = lguest_load_tr_desc;</span>
<span class="p_del">-	pv_cpu_ops.set_ldt = lguest_set_ldt;</span>
<span class="p_del">-	pv_cpu_ops.load_tls = lguest_load_tls;</span>
<span class="p_del">-	pv_cpu_ops.get_debugreg = lguest_get_debugreg;</span>
<span class="p_del">-	pv_cpu_ops.set_debugreg = lguest_set_debugreg;</span>
<span class="p_del">-	pv_cpu_ops.read_cr0 = lguest_read_cr0;</span>
<span class="p_del">-	pv_cpu_ops.write_cr0 = lguest_write_cr0;</span>
<span class="p_del">-	pv_cpu_ops.read_cr4 = lguest_read_cr4;</span>
<span class="p_del">-	pv_cpu_ops.write_cr4 = lguest_write_cr4;</span>
<span class="p_del">-	pv_cpu_ops.write_gdt_entry = lguest_write_gdt_entry;</span>
<span class="p_del">-	pv_cpu_ops.write_idt_entry = lguest_write_idt_entry;</span>
<span class="p_del">-	pv_cpu_ops.wbinvd = lguest_wbinvd;</span>
<span class="p_del">-	pv_cpu_ops.start_context_switch = paravirt_start_context_switch;</span>
<span class="p_del">-	pv_cpu_ops.end_context_switch = lguest_end_context_switch;</span>
<span class="p_add">+	pvfull_cpu_ops.load_gdt = lguest_load_gdt;</span>
<span class="p_add">+	pvfull_cpu_ops.cpuid = lguest_cpuid;</span>
<span class="p_add">+	pvfull_cpu_ops.load_idt = lguest_load_idt;</span>
<span class="p_add">+	pvfull_cpu_ops.iret = lguest_iret;</span>
<span class="p_add">+	pvfull_cpu_ops.load_sp0 = lguest_load_sp0;</span>
<span class="p_add">+	pvfull_cpu_ops.load_tr_desc = lguest_load_tr_desc;</span>
<span class="p_add">+	pvfull_cpu_ops.set_ldt = lguest_set_ldt;</span>
<span class="p_add">+	pvfull_cpu_ops.load_tls = lguest_load_tls;</span>
<span class="p_add">+	pvfull_cpu_ops.get_debugreg = lguest_get_debugreg;</span>
<span class="p_add">+	pvfull_cpu_ops.set_debugreg = lguest_set_debugreg;</span>
<span class="p_add">+	pvfull_cpu_ops.read_cr0 = lguest_read_cr0;</span>
<span class="p_add">+	pvfull_cpu_ops.write_cr0 = lguest_write_cr0;</span>
<span class="p_add">+	pvfull_cpu_ops.read_cr4 = lguest_read_cr4;</span>
<span class="p_add">+	pvfull_cpu_ops.write_cr4 = lguest_write_cr4;</span>
<span class="p_add">+	pvfull_cpu_ops.write_gdt_entry = lguest_write_gdt_entry;</span>
<span class="p_add">+	pvfull_cpu_ops.write_idt_entry = lguest_write_idt_entry;</span>
<span class="p_add">+	pvfull_cpu_ops.wbinvd = lguest_wbinvd;</span>
<span class="p_add">+	pvfull_cpu_ops.start_context_switch = paravirt_start_context_switch;</span>
<span class="p_add">+	pvfull_cpu_ops.end_context_switch = lguest_end_context_switch;</span>
 
 	/* Pagetable management */
 	pv_mmu_ops.write_cr3 = lguest_write_cr3;
<span class="p_header">diff --git a/arch/x86/xen/enlighten_pv.c b/arch/x86/xen/enlighten_pv.c</span>
<span class="p_header">index 7cd442690f9d..89cd5cc5f1a2 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten_pv.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten_pv.c</span>
<span class="p_chunk">@@ -1072,7 +1072,7 @@</span> <span class="p_context"> static const struct pv_init_ops xen_init_ops __initconst = {</span>
 	.patch = xen_patch,
 };
 
<span class="p_del">-static const struct pv_cpu_ops xen_cpu_ops __initconst = {</span>
<span class="p_add">+static const struct pvfull_cpu_ops xen_cpu_ops __initconst = {</span>
 	.cpuid = xen_cpuid,
 
 	.set_debugreg = xen_set_debugreg,
<span class="p_chunk">@@ -1125,7 +1125,6 @@</span> <span class="p_context"> static const struct pv_cpu_ops xen_cpu_ops __initconst = {</span>
 	.load_sp0 = xen_load_sp0,
 
 	.set_iopl_mask = xen_set_iopl_mask,
<span class="p_del">-	.io_delay = xen_io_delay,</span>
 
 	/* Xen takes care of %gs when switching to usermode for us */
 	.swapgs = paravirt_nop,
<span class="p_chunk">@@ -1236,14 +1235,14 @@</span> <span class="p_context"> static void __init xen_boot_params_init_edd(void)</span>
  */
 static void xen_setup_gdt(int cpu)
 {
<span class="p_del">-	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry_boot;</span>
<span class="p_del">-	pv_cpu_ops.load_gdt = xen_load_gdt_boot;</span>
<span class="p_add">+	pvfull_cpu_ops.write_gdt_entry = xen_write_gdt_entry_boot;</span>
<span class="p_add">+	pvfull_cpu_ops.load_gdt = xen_load_gdt_boot;</span>
 
 	setup_stack_canary_segment(0);
 	switch_to_new_gdt(0);
 
<span class="p_del">-	pv_cpu_ops.write_gdt_entry = xen_write_gdt_entry;</span>
<span class="p_del">-	pv_cpu_ops.load_gdt = xen_load_gdt;</span>
<span class="p_add">+	pvfull_cpu_ops.write_gdt_entry = xen_write_gdt_entry;</span>
<span class="p_add">+	pvfull_cpu_ops.load_gdt = xen_load_gdt;</span>
 }
 
 static void __init xen_dom0_set_legacy_features(void)
<span class="p_chunk">@@ -1270,7 +1269,8 @@</span> <span class="p_context"> asmlinkage __visible void __init xen_start_kernel(void)</span>
 	/* Install Xen paravirt ops */
 	pv_info = xen_info;
 	pv_init_ops = xen_init_ops;
<span class="p_del">-	pv_cpu_ops = xen_cpu_ops;</span>
<span class="p_add">+	pvfull_cpu_ops = xen_cpu_ops;</span>
<span class="p_add">+	pv_cpu_ops.io_delay = xen_io_delay;</span>
 
 	x86_platform.get_nmi_reason = xen_get_nmi_reason;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



