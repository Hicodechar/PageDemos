
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>sparc64: Add support for Application Data Integrity (ADI) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    sparc64: Add support for Application Data Integrity (ADI)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 2, 2016, 6:54 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1456944849-21869-1-git-send-email-khalid.aziz@oracle.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8484751/mbox/"
   >mbox</a>
|
   <a href="/patch/8484751/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8484751/">/patch/8484751/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 0125D9F2F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 18:55:04 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 9C1DC20392
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 18:55:01 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id F22212037E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  2 Mar 2016 18:54:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756588AbcCBSyx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 2 Mar 2016 13:54:53 -0500
Received: from mailout.easymail.ca ([64.68.201.169]:32961 &quot;EHLO
	mailout.easymail.ca&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755146AbcCBSys (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 2 Mar 2016 13:54:48 -0500
Received: from localhost (localhost [127.0.0.1])
	by mailout.easymail.ca (Postfix) with ESMTP id 98F02EEDE;
	Wed,  2 Mar 2016 13:54:46 -0500 (EST)
X-Virus-Scanned: Debian amavisd-new at mailout.easymail.ca
X-Spam-Score: -3.707
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
Received: from mailout.easymail.ca ([127.0.0.1])
	by localhost (easymail-mailout.easydns.vpn [127.0.0.1]) (amavisd-new,
	port 10024)
	with ESMTP id Oa2Q4jcrZX9h; Wed,  2 Mar 2016 13:54:43 -0500 (EST)
Received: from mail.gonehiking.org (c-73-181-52-62.hsd1.co.comcast.net
	[73.181.52.62])
	by mailout.easymail.ca (Postfix) with ESMTPA id 07730EE52;
	Wed,  2 Mar 2016 13:54:41 -0500 (EST)
Received: from concerto.us.oracle.com (concerto-wl.internal [192.168.1.22])
	by mail.gonehiking.org (Postfix) with ESMTP id 05A379F154;
	Wed,  2 Mar 2016 11:54:39 -0700 (MST)
From: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;
To: davem@davemloft.net, corbet@lwn.net, akpm@linux-foundation.org,
	dingel@linux.vnet.ibm.com, zhenzhang.zhang@huawei.com,
	bob.picco@oracle.com, kirill.shutemov@linux.intel.com,
	aneesh.kumar@linux.vnet.ibm.com, aarcange@redhat.com,
	arnd@arndb.de, sparclinux@vger.kernel.org
Cc: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;, rob.gardner@oracle.com,
	mhocko@suse.cz, chris.hyser@oracle.com, richard@nod.at,
	vbabka@suse.cz, koct9i@gmail.com, oleg@redhat.com,
	gthelen@google.com, jack@suse.cz, xiexiuqi@huawei.com,
	Vineet.Gupta1@synopsys.com, luto@kernel.org, ebiederm@xmission.com,
	bsegall@google.com, geert@linux-m68k.org, dave@stgolabs.net,
	adobriyan@gmail.com, linux-doc@vger.kernel.org,
	linux-kernel@vger.kernel.org, linux-mm@kvack.org,
	linux-arch@vger.kernel.org, linux-api@vger.kernel.org
Subject: [PATCH] sparc64: Add support for Application Data Integrity (ADI)
Date: Wed,  2 Mar 2016 11:54:09 -0700
Message-Id: &lt;1456944849-21869-1-git-send-email-khalid.aziz@oracle.com&gt;
X-Mailer: git-send-email 2.1.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 2, 2016, 6:54 p.m.</div>
<pre class="content">
Enable Application Data Integrity (ADI) support in the sparc
kernel for applications to use ADI in userspace. ADI is a new
feature supported on sparc M7 and newer processors. ADI is supported
for data fetches only and not instruction fetches. This patch adds
prctl commands to enable and disable ADI (TSTATE.mcde), return ADI
parameters to userspace, enable/disable MCD (Memory Corruption
Detection) on selected memory ranges and enable TTE.mcd in PTEs. It
also adds handlers for all traps related to MCD. ADI is not enabled
by default for any task and a task must explicitly enable ADI
(TSTATE.mcde), turn MCD on on a memory range and set version tag
for ADI to be effective for the task. This patch adds support for
ADI for hugepages only. Addresses passed into system calls must be
non-ADI tagged addresses.
<span class="signed-off-by">
Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
---
NOTES: ADI is a new feature added to M7 processor to allow hardware
	to catch rogue accesses to memory. An app can enable ADI on
	its data pages, set version tags on them and use versioned
	addresses (bits 63-60 of the address contain a version tag)
	to access the data pages. If a rogue app attempts to access
	ADI enabled data pages, its access is blocked and processor
	generates an exception. Enabling this functionality for all
	data pages of an app requires adding infrastructure to save
	version tags for any data pages that get swapped out and
	restoring those tags when pages are swapped back in. In this
	first implementation I am enabling ADI for hugepages only
	since these pages are locked in memory and hence avoid the
	issue of saving and restoring tags. Once this core functionality
	is stable, ADI for other memory pages can be enabled more
	easily.

 Documentation/prctl/sparc_adi.txt     |  62 ++++++++++
 Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++
 arch/sparc/Kconfig                    |  12 ++
 arch/sparc/include/asm/hugetlb.h      |  14 +++
 arch/sparc/include/asm/hypervisor.h   |   2 +
 arch/sparc/include/asm/mmu_64.h       |   1 +
 arch/sparc/include/asm/pgtable_64.h   |  15 +++
 arch/sparc/include/asm/processor_64.h |  19 +++
 arch/sparc/include/asm/ttable.h       |  10 ++
 arch/sparc/include/uapi/asm/asi.h     |   3 +
 arch/sparc/include/uapi/asm/pstate.h  |  10 ++
 arch/sparc/kernel/entry.h             |   3 +
 arch/sparc/kernel/head_64.S           |   1 +
 arch/sparc/kernel/mdesc.c             |  81 +++++++++++++
 arch/sparc/kernel/process_64.c        | 221 ++++++++++++++++++++++++++++++++++
 arch/sparc/kernel/sun4v_mcd.S         |  16 +++
 arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-
 arch/sparc/kernel/ttable_64.S         |   6 +-
 include/linux/mm.h                    |   2 +
 include/uapi/asm-generic/siginfo.h    |   5 +-
 include/uapi/linux/prctl.h            |  16 +++
 kernel/sys.c                          |  30 +++++
 22 files changed, 825 insertions(+), 6 deletions(-)
 create mode 100644 Documentation/prctl/sparc_adi.txt
 create mode 100644 Documentation/sparc/adi.txt
 create mode 100644 arch/sparc/kernel/sun4v_mcd.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=143191">kbuild test robot</a> - March 2, 2016, 8:26 p.m.</div>
<pre class="content">
Hi Khalid,

[auto build test ERROR on sparc/master]
[also build test ERROR on v4.5-rc6]
[cannot apply to next-20160302]
[if your patch is applied to the wrong git tree, please drop us a note to help improving the system]

url:    https://github.com/0day-ci/linux/commits/Khalid-Aziz/sparc64-Add-support-for-Application-Data-Integrity-ADI/20160303-025709
base:   https://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc.git master
config: sparc64-allnoconfig (attached as .config)
reproduce:
        wget https://git.kernel.org/cgit/linux/kernel/git/wfg/lkp-tests.git/plain/sbin/make.cross -O ~/bin/make.cross
        chmod +x ~/bin/make.cross
        # save the attached .config to linux build tree
        make.cross ARCH=sparc64 

All errors (new ones prefixed by &gt;&gt;):

   arch/sparc/kernel/process_64.c: In function &#39;disable_sparc_adi&#39;:
<span class="quote">&gt;&gt; arch/sparc/kernel/process_64.c:961:6: error: implicit declaration of function &#39;vma_policy&#39; [-Werror=implicit-function-declaration]</span>
         vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);
         ^
   arch/sparc/kernel/process_64.c:959:10: error: passing argument 9 of &#39;vma_merge&#39; makes pointer from integer without a cast [-Werror]
      prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,
             ^
   In file included from arch/sparc/kernel/process_64.c:18:0:
   include/linux/mm.h:1922:31: note: expected &#39;struct mempolicy *&#39; but argument is of type &#39;int&#39;
    extern struct vm_area_struct *vma_merge(struct mm_struct *,
                                  ^
   cc1: all warnings being treated as errors

vim +/vma_policy +961 arch/sparc/kernel/process_64.c

   955			/* Update the ADI info in vma and check if this vma can
   956			 * be merged with adjacent ones
   957			 */
   958			pgoff = vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);
   959			prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,
   960					 vma-&gt;anon_vma, vma-&gt;vm_file, pgoff,
<span class="quote"> &gt; 961					 vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);</span>
   962			if (prev)
   963				vma = prev;
   964	

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 2, 2016, 8:36 p.m.</div>
<pre class="content">
On 03/02/2016 01:26 PM, kbuild test robot wrote:
<span class="quote">&gt; Hi Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [auto build test ERROR on sparc/master]</span>
<span class="quote">&gt; [also build test ERROR on v4.5-rc6]</span>
<span class="quote">&gt; [cannot apply to next-20160302]</span>
<span class="quote">&gt; [if your patch is applied to the wrong git tree, please drop us a note to help improving the system]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; url:    https://github.com/0day-ci/linux/commits/Khalid-Aziz/sparc64-Add-support-for-Application-Data-Integrity-ADI/20160303-025709</span>
<span class="quote">&gt; base:   https://git.kernel.org/pub/scm/linux/kernel/git/davem/sparc.git master</span>
<span class="quote">&gt; config: sparc64-allnoconfig (attached as .config)</span>
<span class="quote">&gt; reproduce:</span>
<span class="quote">&gt;          wget https://git.kernel.org/cgit/linux/kernel/git/wfg/lkp-tests.git/plain/sbin/make.cross -O ~/bin/make.cross</span>
<span class="quote">&gt;          chmod +x ~/bin/make.cross</span>
<span class="quote">&gt;          # save the attached .config to linux build tree</span>
<span class="quote">&gt;          make.cross ARCH=sparc64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; All errors (new ones prefixed by &gt;&gt;):</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     arch/sparc/kernel/process_64.c: In function &#39;disable_sparc_adi&#39;:</span>
<span class="quote">&gt;&gt;&gt; arch/sparc/kernel/process_64.c:961:6: error: implicit declaration of function &#39;vma_policy&#39; [-Werror=implicit-function-declaration]</span>
<span class="quote">&gt;           vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);</span>
<span class="quote">&gt;           ^</span>
<span class="quote">&gt;     arch/sparc/kernel/process_64.c:959:10: error: passing argument 9 of &#39;vma_merge&#39; makes pointer from integer without a cast [-Werror]</span>
<span class="quote">&gt;        prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,</span>
<span class="quote">&gt;               ^</span>
<span class="quote">&gt;     In file included from arch/sparc/kernel/process_64.c:18:0:</span>
<span class="quote">&gt;     include/linux/mm.h:1922:31: note: expected &#39;struct mempolicy *&#39; but argument is of type &#39;int&#39;</span>
<span class="quote">&gt;      extern struct vm_area_struct *vma_merge(struct mm_struct *,</span>
<span class="quote">&gt;                                    ^</span>

Not sure why it built without errors on my system. I will #include 
&lt;linux/mempolicy.h&gt; and send updated patch.

--
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=545">Julian Calaby</a> - March 3, 2016, 1:33 a.m.</div>
<pre class="content">
Hi Khalid,

A couple of other comments:

On Thu, Mar 3, 2016 at 5:54 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;         to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;         its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;         addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;         to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;         ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;         generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;         data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;         version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;         restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;         first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;         since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;         issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;         is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;         easily.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;  Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;  arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;  arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;  arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;  arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;  arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;  arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;  arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;  arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;  arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;  arch/sparc/kernel/process_64.c        | 221 ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;  arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;  arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;  include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;  include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;  include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;  kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;  22 files changed, 825 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;  create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;  create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt; index 131d36f..cddea30 100644</span>
<span class="quote">&gt; --- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt; +++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt; @@ -162,6 +162,9 @@ bool kern_addr_valid(unsigned long addr);</span>
<span class="quote">&gt;  #define _PAGE_E_4V       _AC(0x0000000000000800,UL) /* side-Effect          */</span>
<span class="quote">&gt;  #define _PAGE_CP_4V      _AC(0x0000000000000400,UL) /* Cacheable in P-Cache */</span>
<span class="quote">&gt;  #define _PAGE_CV_4V      _AC(0x0000000000000200,UL) /* Cacheable in V-Cache */</span>
<span class="quote">&gt; +/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define _PAGE_MCD_4V     _AC(0x0000000000000200,UL) /* Memory Corruption    */</span>

I&#39;m not sure that everywhere _PAGE_CV_4V is used is guarded against
setting it on M7, could someone who knows the code better than I do
please check that? It looks like the tests around it&#39;s use are
essentially &quot;is it sun4v&quot;.

I&#39;m probably being paranoid, but reused values like this make me worry.
<span class="quote">
&gt;  #define _PAGE_P_4V       _AC(0x0000000000000100,UL) /* Privileged Page      */</span>
<span class="quote">&gt;  #define _PAGE_EXEC_4V    _AC(0x0000000000000080,UL) /* Executable Page      */</span>
<span class="quote">&gt;  #define _PAGE_W_4V       _AC(0x0000000000000040,UL) /* Writable             */</span>
<span class="quote">&gt; diff --git a/arch/sparc/include/uapi/asm/pstate.h b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt; index cf832e1..d0521db 100644</span>
<span class="quote">&gt; --- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt; +++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt; @@ -10,7 +10,12 @@</span>
<span class="quote">&gt;   * -----------------------------------------------------------------------</span>
<span class="quote">&gt;   *  63  12  11   10    9     8    7   6   5     4     3     2     1    0</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; +/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="quote">&gt; + * processors that support ADI which do not use IG, hence there is no</span>
<span class="quote">&gt; + * functional conflict</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt;  #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.   */</span>
<span class="quote">&gt; +#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable           */</span>

Again, I can&#39;t tell if the code that uses PSTATE_IG is guarded against
use on M7. Could someone else please check? It&#39;s used in cherrs.S
which appears to be Cheetah specific, so that&#39;s not a problem, however
it&#39;s also used in ultra.S in xcall_sync_tick which might get patched
out however I don&#39;t know the code well enough to be certain. I&#39;m also
guessing that as this file is in include/uapi, userspace could use it
for something.
<span class="quote">
&gt;  #define PSTATE_MG   _AC(0x0000000000000400,UL) /* MMU Globals.         */</span>
<span class="quote">&gt;  #define PSTATE_CLE  _AC(0x0000000000000200,UL) /* Current Little Endian.*/</span>
<span class="quote">&gt;  #define PSTATE_TLE  _AC(0x0000000000000100,UL) /* Trap Little Endian.  */</span>
<span class="quote">&gt; @@ -47,7 +52,12 @@</span>
<span class="quote">&gt;  #define TSTATE_ASI     _AC(0x00000000ff000000,UL) /* AddrSpace ID.     */</span>
<span class="quote">&gt;  #define TSTATE_PIL     _AC(0x0000000000f00000,UL) /* %pil (Linux traps)*/</span>
<span class="quote">&gt;  #define TSTATE_PSTATE  _AC(0x00000000000fff00,UL) /* PSTATE.           */</span>
<span class="quote">&gt; +/* IG on V9 conflicts with MCDE on M7. TSTATE_MCDE will only be used on</span>
<span class="quote">&gt; + * processors that support ADI which do not support IG, hence there is</span>
<span class="quote">&gt; + * no functional conflict</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt;  #define TSTATE_IG      _AC(0x0000000000080000,UL) /* Interrupt Globals.*/</span>
<span class="quote">&gt; +#define TSTATE_MCDE    _AC(0x0000000000080000,UL) /* MCD enable.       */</span>

TSTATE_IG only seems to be referenced in cherrs.S which appears to be
Cheetah specific, so I&#39;m guessing this is safe unless userspace does
something with it.
<span class="quote">
&gt;  #define TSTATE_MG      _AC(0x0000000000040000,UL) /* MMU Globals.      */</span>
<span class="quote">&gt;  #define TSTATE_CLE     _AC(0x0000000000020000,UL) /* CurrLittleEndian. */</span>
<span class="quote">&gt;  #define TSTATE_TLE     _AC(0x0000000000010000,UL) /* TrapLittleEndian. */</span>
<span class="quote">&gt; diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c</span>
<span class="quote">&gt; index 46a5964..33fcc85 100644</span>
<span class="quote">&gt; --- a/arch/sparc/kernel/process_64.c</span>
<span class="quote">&gt; +++ b/arch/sparc/kernel/process_64.c</span>
<span class="quote">&gt; @@ -777,3 +779,222 @@ unsigned long get_wchan(struct task_struct *task)</span>
<span class="quote">&gt;  out:</span>
<span class="quote">&gt;         return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifdef CONFIG_SPARC_ADI</span>
<span class="quote">&gt; +long get_sparc_adicaps(unsigned long val)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct adi_caps *caps;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       caps = get_adi_caps();</span>
<span class="quote">&gt; +       if (val)</span>

Should we return 0 before calling get_adi_caps() if val is null?
<span class="quote">
&gt; +               if (copy_to_user((void *)val, caps, sizeof(struct adi_caps)))</span>
<span class="quote">&gt; +                       return -EFAULT;</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +long set_sparc_pstate_mcde(unsigned long val)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       unsigned long error;</span>
<span class="quote">&gt; +       struct pt_regs *regs;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* We do not allow anonymous tasks to enable ADI because they</span>
<span class="quote">&gt; +        * run in borrowed aadress space.</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       if (current-&gt;mm == NULL)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       regs = task_pt_regs(current);</span>
<span class="quote">&gt; +       if (regs-&gt;tstate &amp; TSTATE_MCDE)</span>
<span class="quote">&gt; +               error = 1;</span>
<span class="quote">&gt; +       else</span>
<span class="quote">&gt; +               error = 0;</span>
<span class="quote">&gt; +       switch (val) {</span>
<span class="quote">&gt; +       case 1:</span>
<span class="quote">&gt; +               regs-&gt;tstate |= TSTATE_MCDE;</span>
<span class="quote">&gt; +               current-&gt;mm-&gt;context.adi = 1;</span>
<span class="quote">&gt; +               break;</span>
<span class="quote">&gt; +       case 0:</span>
<span class="quote">&gt; +               regs-&gt;tstate &amp;= ~TSTATE_MCDE;</span>
<span class="quote">&gt; +               current-&gt;mm-&gt;context.adi = 0;</span>
<span class="quote">&gt; +               break;</span>
<span class="quote">&gt; +       default:</span>
<span class="quote">&gt; +               break;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return error;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       unsigned long end, pagemask;</span>
<span class="quote">&gt; +       int error;</span>
<span class="quote">&gt; +       struct vm_area_struct *vma, *vma2;</span>
<span class="quote">&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       vma = find_vma(current-&gt;mm, addr);</span>
<span class="quote">&gt; +       if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* ADI is supported for hugepages only</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       if (!is_vm_hugetlb_page(vma))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Is the start address page aligned and is the length multiple</span>
<span class="quote">&gt; +        * of page size?</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="quote">&gt; +       if (addr &amp; ~pagemask)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       if (len &amp; ~pagemask)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       end = addr + len;</span>
<span class="quote">&gt; +       if (end == addr)</span>
<span class="quote">&gt; +               return 0;</span>

Should we check if len == 0 before calculating the pagemask?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       /* Verify end of the region is not out of bounds</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="quote">&gt; +       if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       error = 0;</span>
<span class="quote">&gt; +       while (1) {</span>
<span class="quote">&gt; +               /* If the address space ADI is to be enabled in, does not cover</span>
<span class="quote">&gt; +                * this vma in its entirety, we will need to split it.</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               mm = vma-&gt;vm_mm;</span>
<span class="quote">&gt; +               if (addr != vma-&gt;vm_start) {</span>
<span class="quote">&gt; +                       error = split_vma(mm, vma, addr, 1);</span>
<span class="quote">&gt; +                       if (error)</span>
<span class="quote">&gt; +                               goto out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (end &lt; vma-&gt;vm_end) {</span>
<span class="quote">&gt; +                       error = split_vma(mm, vma, end, 0);</span>
<span class="quote">&gt; +                       if (error)</span>
<span class="quote">&gt; +                               goto out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /* Update the ADI info in vma and PTE</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               vma-&gt;vm_flags |= VM_SPARC_ADI;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (end &gt; vma-&gt;vm_end) {</span>
<span class="quote">&gt; +                       change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="quote">&gt; +                                         vma-&gt;vm_page_prot,</span>
<span class="quote">&gt; +                                         vma_wants_writenotify(vma), 0);</span>
<span class="quote">&gt; +                       addr = vma-&gt;vm_end;</span>
<span class="quote">&gt; +               } else {</span>
<span class="quote">&gt; +                       change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="quote">&gt; +                                       vma_wants_writenotify(vma), 0);</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               vma = find_vma(current-&gt;mm, addr);</span>
<span class="quote">&gt; +               if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="quote">&gt; +                       return -EFAULT;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +       if (error == -ENOMEM)</span>
<span class="quote">&gt; +               error = -EAGAIN;</span>
<span class="quote">&gt; +       return error;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +long disable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       unsigned long end, pagemask;</span>
<span class="quote">&gt; +       struct vm_area_struct *vma, *vma2, *prev;</span>
<span class="quote">&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; +       pgoff_t pgoff;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       vma = find_vma(current-&gt;mm, addr);</span>
<span class="quote">&gt; +       if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* ADI is supported for hugepages only</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       if (!is_vm_hugetlb_page(vma))</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Is the start address page aligned and is the length multiple</span>
<span class="quote">&gt; +        * of page size?</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="quote">&gt; +       if (addr &amp; ~pagemask)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       if (len &amp; ~pagemask)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       end = addr + len;</span>
<span class="quote">&gt; +       if (end == addr)</span>
<span class="quote">&gt; +               return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Verify end of the region is not out of bounds</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="quote">&gt; +       if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       while (1) {</span>
<span class="quote">&gt; +               mm = vma-&gt;vm_mm;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /* Update the ADI info in vma and check if this vma can</span>
<span class="quote">&gt; +                * be merged with adjacent ones</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               pgoff = vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt; +               prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,</span>
<span class="quote">&gt; +                                vma-&gt;anon_vma, vma-&gt;vm_file, pgoff,</span>
<span class="quote">&gt; +                                vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);</span>
<span class="quote">&gt; +               if (prev)</span>
<span class="quote">&gt; +                       vma = prev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               vma-&gt;vm_flags &amp;= ~VM_SPARC_ADI;</span>
<span class="quote">&gt; +               if (end &gt; vma-&gt;vm_end) {</span>
<span class="quote">&gt; +                       change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="quote">&gt; +                                         vma-&gt;vm_page_prot,</span>
<span class="quote">&gt; +                                         vma_wants_writenotify(vma), 0);</span>
<span class="quote">&gt; +                       addr = vma-&gt;vm_end;</span>
<span class="quote">&gt; +               } else {</span>
<span class="quote">&gt; +                       change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="quote">&gt; +                                         vma_wants_writenotify(vma), 0);</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               vma = find_vma_prev(current-&gt;mm, addr, &amp;prev);</span>
<span class="quote">&gt; +               if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="quote">&gt; +                       return -EFAULT;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +long get_sparc_adi_status(unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!ADI_CAPABLE())</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       vma = find_vma(current-&gt;mm, addr);</span>
<span class="quote">&gt; +       if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="quote">&gt; +               return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="quote">&gt; +               return 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +#endif</span>

Thanks,
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 3, 2016, 5:42 p.m.</div>
<pre class="content">
On 03/02/2016 06:33 PM, Julian Calaby wrote:
<span class="quote">&gt; Hi Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; A couple of other comments:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Thu, Mar 3, 2016 at 5:54 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;          to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;          its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;          addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;          to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;          ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;          generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;          data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;          version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;          restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;          first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;          since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;          issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;          is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;          easily.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;   Documentation/sparc/adi.txt           | 206 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;   arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/process_64.c        | 221 ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;   arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;   include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;   include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;   include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;   kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;   22 files changed, 825 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;   create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;   create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;   create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt; index 131d36f..cddea30 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt; @@ -162,6 +162,9 @@ bool kern_addr_valid(unsigned long addr);</span>
<span class="quote">&gt;&gt;   #define _PAGE_E_4V       _AC(0x0000000000000800,UL) /* side-Effect          */</span>
<span class="quote">&gt;&gt;   #define _PAGE_CP_4V      _AC(0x0000000000000400,UL) /* Cacheable in P-Cache */</span>
<span class="quote">&gt;&gt;   #define _PAGE_CV_4V      _AC(0x0000000000000200,UL) /* Cacheable in V-Cache */</span>
<span class="quote">&gt;&gt; +/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +#define _PAGE_MCD_4V     _AC(0x0000000000000200,UL) /* Memory Corruption    */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m not sure that everywhere _PAGE_CV_4V is used is guarded against</span>
<span class="quote">&gt; setting it on M7, could someone who knows the code better than I do</span>
<span class="quote">&gt; please check that? It looks like the tests around it&#39;s use are</span>
<span class="quote">&gt; essentially &quot;is it sun4v&quot;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m probably being paranoid, but reused values like this make me worry.</span>
<span class="quote">&gt;</span>

I took care of this issue in an earlier patch (commit 
494e5b6faeda1d1e830a13e10b3c7bc323f35d97 - &quot;sparc: Resolve conflict 
between sparc v9 and M7 on usage of bit 9 of TTE&quot;), so I think we are ok 
here.
<span class="quote">
&gt;&gt;   #define _PAGE_P_4V       _AC(0x0000000000000100,UL) /* Privileged Page      */</span>
<span class="quote">&gt;&gt;   #define _PAGE_EXEC_4V    _AC(0x0000000000000080,UL) /* Executable Page      */</span>
<span class="quote">&gt;&gt;   #define _PAGE_W_4V       _AC(0x0000000000000040,UL) /* Writable             */</span>
<span class="quote">&gt;&gt; diff --git a/arch/sparc/include/uapi/asm/pstate.h b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt; index cf832e1..d0521db 100644</span>
<span class="quote">&gt;&gt; --- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt; +++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt; @@ -10,7 +10,12 @@</span>
<span class="quote">&gt;&gt;    * -----------------------------------------------------------------------</span>
<span class="quote">&gt;&gt;    *  63  12  11   10    9     8    7   6   5     4     3     2     1    0</span>
<span class="quote">&gt;&gt;    */</span>
<span class="quote">&gt;&gt; +/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="quote">&gt;&gt; + * processors that support ADI which do not use IG, hence there is no</span>
<span class="quote">&gt;&gt; + * functional conflict</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt;   #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.   */</span>
<span class="quote">&gt;&gt; +#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable           */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Again, I can&#39;t tell if the code that uses PSTATE_IG is guarded against</span>
<span class="quote">&gt; use on M7. Could someone else please check? It&#39;s used in cherrs.S</span>
<span class="quote">&gt; which appears to be Cheetah specific, so that&#39;s not a problem, however</span>
<span class="quote">&gt; it&#39;s also used in ultra.S in xcall_sync_tick which might get patched</span>
<span class="quote">&gt; out however I don&#39;t know the code well enough to be certain. I&#39;m also</span>
<span class="quote">&gt; guessing that as this file is in include/uapi, userspace could use it</span>
<span class="quote">&gt; for something.</span>

My understanding of the code in ultra.S is xcall_sync_tick doe snot get 
called on sun4v, so PSTATE_IG will not get set unintentionally on M7. 
include/uapi is an interesting thought. PSTATE is a privileged register, 
so userspace can not write to it directly without using a system call. I 
don&#39;t think that is an issue here.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;   #define PSTATE_MG   _AC(0x0000000000000400,UL) /* MMU Globals.         */</span>
<span class="quote">&gt;&gt;   #define PSTATE_CLE  _AC(0x0000000000000200,UL) /* Current Little Endian.*/</span>
<span class="quote">&gt;&gt;   #define PSTATE_TLE  _AC(0x0000000000000100,UL) /* Trap Little Endian.  */</span>
<span class="quote">&gt;&gt; @@ -47,7 +52,12 @@</span>
<span class="quote">&gt;&gt;   #define TSTATE_ASI     _AC(0x00000000ff000000,UL) /* AddrSpace ID.     */</span>
<span class="quote">&gt;&gt;   #define TSTATE_PIL     _AC(0x0000000000f00000,UL) /* %pil (Linux traps)*/</span>
<span class="quote">&gt;&gt;   #define TSTATE_PSTATE  _AC(0x00000000000fff00,UL) /* PSTATE.           */</span>
<span class="quote">&gt;&gt; +/* IG on V9 conflicts with MCDE on M7. TSTATE_MCDE will only be used on</span>
<span class="quote">&gt;&gt; + * processors that support ADI which do not support IG, hence there is</span>
<span class="quote">&gt;&gt; + * no functional conflict</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt;   #define TSTATE_IG      _AC(0x0000000000080000,UL) /* Interrupt Globals.*/</span>
<span class="quote">&gt;&gt; +#define TSTATE_MCDE    _AC(0x0000000000080000,UL) /* MCD enable.       */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; TSTATE_IG only seems to be referenced in cherrs.S which appears to be</span>
<span class="quote">&gt; Cheetah specific, so I&#39;m guessing this is safe unless userspace does</span>
<span class="quote">&gt; something with it.</span>

TSTATE is a privileged register as well.


Thanks,
Khalid
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=545">Julian Calaby</a> - March 3, 2016, 10:26 p.m.</div>
<pre class="content">
Hi Khalid,

On Fri, Mar 4, 2016 at 4:42 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:
<span class="quote">&gt; On 03/02/2016 06:33 PM, Julian Calaby wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hi Khalid,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; A couple of other comments:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Thu, Mar 3, 2016 at 5:54 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;&gt;          to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;&gt;          its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;&gt;          addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;&gt;          to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;&gt;          ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;&gt;          generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;&gt;          data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;&gt;          version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;&gt;          restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;&gt;          first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;          since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;          issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;&gt;          is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;&gt;          easily.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;&gt;   Documentation/sparc/adi.txt           | 206</span>
<span class="quote">&gt;&gt;&gt; +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/process_64.c        | 221</span>
<span class="quote">&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;&gt;   arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;&gt;   include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;&gt;   include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;&gt;   include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;&gt;   kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;&gt;   22 files changed, 825 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;&gt;   create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt; b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt; index 131d36f..cddea30 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt; @@ -162,6 +162,9 @@ bool kern_addr_valid(unsigned long addr);</span>
<span class="quote">&gt;&gt;&gt;   #define _PAGE_E_4V       _AC(0x0000000000000800,UL) /* side-Effect</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;   #define _PAGE_CP_4V      _AC(0x0000000000000400,UL) /* Cacheable in</span>
<span class="quote">&gt;&gt;&gt; P-Cache */</span>
<span class="quote">&gt;&gt;&gt;   #define _PAGE_CV_4V      _AC(0x0000000000000200,UL) /* Cacheable in</span>
<span class="quote">&gt;&gt;&gt; V-Cache */</span>
<span class="quote">&gt;&gt;&gt; +/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="quote">&gt;&gt;&gt; + */</span>
<span class="quote">&gt;&gt;&gt; +#define _PAGE_MCD_4V     _AC(0x0000000000000200,UL) /* Memory Corruption</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;m not sure that everywhere _PAGE_CV_4V is used is guarded against</span>
<span class="quote">&gt;&gt; setting it on M7, could someone who knows the code better than I do</span>
<span class="quote">&gt;&gt; please check that? It looks like the tests around it&#39;s use are</span>
<span class="quote">&gt;&gt; essentially &quot;is it sun4v&quot;.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;m probably being paranoid, but reused values like this make me worry.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I took care of this issue in an earlier patch (commit</span>
<span class="quote">&gt; 494e5b6faeda1d1e830a13e10b3c7bc323f35d97 - &quot;sparc: Resolve conflict between</span>
<span class="quote">&gt; sparc v9 and M7 on usage of bit 9 of TTE&quot;), so I think we are ok here.</span>

Ah, I remember those changes, however I didn&#39;t recall which processor
they were for, so that&#39;s awesome.
<span class="quote">
&gt;&gt;&gt;   #define _PAGE_P_4V       _AC(0x0000000000000100,UL) /* Privileged Page</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;   #define _PAGE_EXEC_4V    _AC(0x0000000000000080,UL) /* Executable Page</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;   #define _PAGE_W_4V       _AC(0x0000000000000040,UL) /* Writable</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt; b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt; index cf832e1..d0521db 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt; @@ -10,7 +10,12 @@</span>
<span class="quote">&gt;&gt;&gt;    *</span>
<span class="quote">&gt;&gt;&gt; -----------------------------------------------------------------------</span>
<span class="quote">&gt;&gt;&gt;    *  63  12  11   10    9     8    7   6   5     4     3     2     1</span>
<span class="quote">&gt;&gt;&gt; 0</span>
<span class="quote">&gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt;&gt; +/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="quote">&gt;&gt;&gt; + * processors that support ADI which do not use IG, hence there is no</span>
<span class="quote">&gt;&gt;&gt; + * functional conflict</span>
<span class="quote">&gt;&gt;&gt; + */</span>
<span class="quote">&gt;&gt;&gt;   #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt; +#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Again, I can&#39;t tell if the code that uses PSTATE_IG is guarded against</span>
<span class="quote">&gt;&gt; use on M7. Could someone else please check? It&#39;s used in cherrs.S</span>
<span class="quote">&gt;&gt; which appears to be Cheetah specific, so that&#39;s not a problem, however</span>
<span class="quote">&gt;&gt; it&#39;s also used in ultra.S in xcall_sync_tick which might get patched</span>
<span class="quote">&gt;&gt; out however I don&#39;t know the code well enough to be certain. I&#39;m also</span>
<span class="quote">&gt;&gt; guessing that as this file is in include/uapi, userspace could use it</span>
<span class="quote">&gt;&gt; for something.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; My understanding of the code in ultra.S is xcall_sync_tick doe snot get</span>
<span class="quote">&gt; called on sun4v, so PSTATE_IG will not get set unintentionally on M7.</span>
<span class="quote">&gt; include/uapi is an interesting thought. PSTATE is a privileged register, so</span>
<span class="quote">&gt; userspace can not write to it directly without using a system call. I don&#39;t</span>
<span class="quote">&gt; think that is an issue here.</span>

Is it something userspace would interpret then? I guess any software
making use of the PSTATE or TSTATE registers would have to handle any
processor differences itself.

Thanks for explaining this!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=63231">Khalid Aziz</a> - March 3, 2016, 11:51 p.m.</div>
<pre class="content">
On 03/03/2016 03:26 PM, Julian Calaby wrote:
<span class="quote">&gt; Hi Khalid,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Fri, Mar 4, 2016 at 4:42 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On 03/02/2016 06:33 PM, Julian Calaby wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Hi Khalid,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; A couple of other comments:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On Thu, Mar 3, 2016 at 5:54 AM, Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Enable Application Data Integrity (ADI) support in the sparc</span>
<span class="quote">&gt;&gt;&gt;&gt; kernel for applications to use ADI in userspace. ADI is a new</span>
<span class="quote">&gt;&gt;&gt;&gt; feature supported on sparc M7 and newer processors. ADI is supported</span>
<span class="quote">&gt;&gt;&gt;&gt; for data fetches only and not instruction fetches. This patch adds</span>
<span class="quote">&gt;&gt;&gt;&gt; prctl commands to enable and disable ADI (TSTATE.mcde), return ADI</span>
<span class="quote">&gt;&gt;&gt;&gt; parameters to userspace, enable/disable MCD (Memory Corruption</span>
<span class="quote">&gt;&gt;&gt;&gt; Detection) on selected memory ranges and enable TTE.mcd in PTEs. It</span>
<span class="quote">&gt;&gt;&gt;&gt; also adds handlers for all traps related to MCD. ADI is not enabled</span>
<span class="quote">&gt;&gt;&gt;&gt; by default for any task and a task must explicitly enable ADI</span>
<span class="quote">&gt;&gt;&gt;&gt; (TSTATE.mcde), turn MCD on on a memory range and set version tag</span>
<span class="quote">&gt;&gt;&gt;&gt; for ADI to be effective for the task. This patch adds support for</span>
<span class="quote">&gt;&gt;&gt;&gt; ADI for hugepages only. Addresses passed into system calls must be</span>
<span class="quote">&gt;&gt;&gt;&gt; non-ADI tagged addresses.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt; NOTES: ADI is a new feature added to M7 processor to allow hardware</span>
<span class="quote">&gt;&gt;&gt;&gt;           to catch rogue accesses to memory. An app can enable ADI on</span>
<span class="quote">&gt;&gt;&gt;&gt;           its data pages, set version tags on them and use versioned</span>
<span class="quote">&gt;&gt;&gt;&gt;           addresses (bits 63-60 of the address contain a version tag)</span>
<span class="quote">&gt;&gt;&gt;&gt;           to access the data pages. If a rogue app attempts to access</span>
<span class="quote">&gt;&gt;&gt;&gt;           ADI enabled data pages, its access is blocked and processor</span>
<span class="quote">&gt;&gt;&gt;&gt;           generates an exception. Enabling this functionality for all</span>
<span class="quote">&gt;&gt;&gt;&gt;           data pages of an app requires adding infrastructure to save</span>
<span class="quote">&gt;&gt;&gt;&gt;           version tags for any data pages that get swapped out and</span>
<span class="quote">&gt;&gt;&gt;&gt;           restoring those tags when pages are swapped back in. In this</span>
<span class="quote">&gt;&gt;&gt;&gt;           first implementation I am enabling ADI for hugepages only</span>
<span class="quote">&gt;&gt;&gt;&gt;           since these pages are locked in memory and hence avoid the</span>
<span class="quote">&gt;&gt;&gt;&gt;           issue of saving and restoring tags. Once this core functionality</span>
<span class="quote">&gt;&gt;&gt;&gt;           is stable, ADI for other memory pages can be enabled more</span>
<span class="quote">&gt;&gt;&gt;&gt;           easily.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;    Documentation/prctl/sparc_adi.txt     |  62 ++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    Documentation/sparc/adi.txt           | 206</span>
<span class="quote">&gt;&gt;&gt;&gt; +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/Kconfig                    |  12 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/hugetlb.h      |  14 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/hypervisor.h   |   2 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/mmu_64.h       |   1 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/pgtable_64.h   |  15 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/processor_64.h |  19 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/asm/ttable.h       |  10 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/uapi/asm/asi.h     |   3 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/include/uapi/asm/pstate.h  |  10 ++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/entry.h             |   3 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/head_64.S           |   1 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/mdesc.c             |  81 +++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/process_64.c        | 221</span>
<span class="quote">&gt;&gt;&gt;&gt; ++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/sun4v_mcd.S         |  16 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/traps_64.c          |  96 ++++++++++++++-</span>
<span class="quote">&gt;&gt;&gt;&gt;    arch/sparc/kernel/ttable_64.S         |   6 +-</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/linux/mm.h                    |   2 +</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/uapi/asm-generic/siginfo.h    |   5 +-</span>
<span class="quote">&gt;&gt;&gt;&gt;    include/uapi/linux/prctl.h            |  16 +++</span>
<span class="quote">&gt;&gt;&gt;&gt;    kernel/sys.c                          |  30 +++++</span>
<span class="quote">&gt;&gt;&gt;&gt;    22 files changed, 825 insertions(+), 6 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 Documentation/prctl/sparc_adi.txt</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 Documentation/sparc/adi.txt</span>
<span class="quote">&gt;&gt;&gt;&gt;    create mode 100644 arch/sparc/kernel/sun4v_mcd.S</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt;&gt; b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt;&gt; index 131d36f..cddea30 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -162,6 +162,9 @@ bool kern_addr_valid(unsigned long addr);</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_E_4V       _AC(0x0000000000000800,UL) /* side-Effect</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_CP_4V      _AC(0x0000000000000400,UL) /* Cacheable in</span>
<span class="quote">&gt;&gt;&gt;&gt; P-Cache */</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_CV_4V      _AC(0x0000000000000200,UL) /* Cacheable in</span>
<span class="quote">&gt;&gt;&gt;&gt; V-Cache */</span>
<span class="quote">&gt;&gt;&gt;&gt; +/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="quote">&gt;&gt;&gt;&gt; + */</span>
<span class="quote">&gt;&gt;&gt;&gt; +#define _PAGE_MCD_4V     _AC(0x0000000000000200,UL) /* Memory Corruption</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I&#39;m not sure that everywhere _PAGE_CV_4V is used is guarded against</span>
<span class="quote">&gt;&gt;&gt; setting it on M7, could someone who knows the code better than I do</span>
<span class="quote">&gt;&gt;&gt; please check that? It looks like the tests around it&#39;s use are</span>
<span class="quote">&gt;&gt;&gt; essentially &quot;is it sun4v&quot;.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I&#39;m probably being paranoid, but reused values like this make me worry.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I took care of this issue in an earlier patch (commit</span>
<span class="quote">&gt;&gt; 494e5b6faeda1d1e830a13e10b3c7bc323f35d97 - &quot;sparc: Resolve conflict between</span>
<span class="quote">&gt;&gt; sparc v9 and M7 on usage of bit 9 of TTE&quot;), so I think we are ok here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ah, I remember those changes, however I didn&#39;t recall which processor</span>
<span class="quote">&gt; they were for, so that&#39;s awesome.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_P_4V       _AC(0x0000000000000100,UL) /* Privileged Page</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_EXEC_4V    _AC(0x0000000000000080,UL) /* Executable Page</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define _PAGE_W_4V       _AC(0x0000000000000040,UL) /* Writable</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt;&gt; b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt;&gt; index cf832e1..d0521db 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -10,7 +10,12 @@</span>
<span class="quote">&gt;&gt;&gt;&gt;     *</span>
<span class="quote">&gt;&gt;&gt;&gt; -----------------------------------------------------------------------</span>
<span class="quote">&gt;&gt;&gt;&gt;     *  63  12  11   10    9     8    7   6   5     4     3     2     1</span>
<span class="quote">&gt;&gt;&gt;&gt; 0</span>
<span class="quote">&gt;&gt;&gt;&gt;     */</span>
<span class="quote">&gt;&gt;&gt;&gt; +/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="quote">&gt;&gt;&gt;&gt; + * processors that support ADI which do not use IG, hence there is no</span>
<span class="quote">&gt;&gt;&gt;&gt; + * functional conflict</span>
<span class="quote">&gt;&gt;&gt;&gt; + */</span>
<span class="quote">&gt;&gt;&gt;&gt;    #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;&gt; +#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable</span>
<span class="quote">&gt;&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Again, I can&#39;t tell if the code that uses PSTATE_IG is guarded against</span>
<span class="quote">&gt;&gt;&gt; use on M7. Could someone else please check? It&#39;s used in cherrs.S</span>
<span class="quote">&gt;&gt;&gt; which appears to be Cheetah specific, so that&#39;s not a problem, however</span>
<span class="quote">&gt;&gt;&gt; it&#39;s also used in ultra.S in xcall_sync_tick which might get patched</span>
<span class="quote">&gt;&gt;&gt; out however I don&#39;t know the code well enough to be certain. I&#39;m also</span>
<span class="quote">&gt;&gt;&gt; guessing that as this file is in include/uapi, userspace could use it</span>
<span class="quote">&gt;&gt;&gt; for something.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; My understanding of the code in ultra.S is xcall_sync_tick doe snot get</span>
<span class="quote">&gt;&gt; called on sun4v, so PSTATE_IG will not get set unintentionally on M7.</span>
<span class="quote">&gt;&gt; include/uapi is an interesting thought. PSTATE is a privileged register, so</span>
<span class="quote">&gt;&gt; userspace can not write to it directly without using a system call. I don&#39;t</span>
<span class="quote">&gt;&gt; think that is an issue here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is it something userspace would interpret then? I guess any software</span>
<span class="quote">&gt; making use of the PSTATE or TSTATE registers would have to handle any</span>
<span class="quote">&gt; processor differences itself.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks for explaining this!</span>
<span class="quote">&gt;</span>

Same limitation applies even in that case. Since this is a privileged 
register, it can not be read by userspace without going into a system 
call. From the sparc manual - &quot;......visible only to software running in
privileged mode; that is, when PSTATE.PRIV = 1.&quot;

Thanks,
Khalid
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/prctl/sparc_adi.txt b/Documentation/prctl/sparc_adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..9cbdcae</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/prctl/sparc_adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,62 @@</span> <span class="p_context"></span>
<span class="p_add">+========</span>
<span class="p_add">+Overview</span>
<span class="p_add">+========</span>
<span class="p_add">+</span>
<span class="p_add">+SPARC M7 processor includes the feature Application Data Integrity (ADI).</span>
<span class="p_add">+ADI allows a tag to be associated with a virtual memory address range</span>
<span class="p_add">+and a process must access that memory range with the correct tag. ADI</span>
<span class="p_add">+tag is embedded in bits 63-60 of virtual address. Once ADI is enabled</span>
<span class="p_add">+on a range of memory addresses, the process can set a tag for blocks</span>
<span class="p_add">+in this memory range n the cache using ASI_MCD_PRIMARY or</span>
<span class="p_add">+ASI_MCD_ST_BLKINIT_PRIMARY. This tag is set for ADI block sized blocks</span>
<span class="p_add">+which is provided to the kernel by machine description table.</span>
<span class="p_add">+</span>
<span class="p_add">+Linux kernel supports an application enabling and setting the ADI tag</span>
<span class="p_add">+for a subset of its data pages. Those data pages have to be locked in</span>
<span class="p_add">+memory since saving ADI tags to swap is not supported.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+New prctl options for ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following new options to prctl() have been added to support ADI.</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_GET_SPARC_ADICAPS - Get ADI capabilities for the processor.</span>
<span class="p_add">+		These capabilities are used to set up ADI correctly</span>
<span class="p_add">+		from userspace. Machine description table provides all</span>
<span class="p_add">+		of the ADI capabilities information. arg2 to prctl() is</span>
<span class="p_add">+		a pointer to struct adi_caps which is defined in</span>
<span class="p_add">+		linux/prctl.h.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_SET_SPARC_ADI - Set the state of ADI in a user thread by</span>
<span class="p_add">+		setting PSTATE.mcde bit in the user mode PSTATE register</span>
<span class="p_add">+		of the calling thread based on the value passed in arg2:</span>
<span class="p_add">+			1 == enable, 0 == disable, other == no change</span>
<span class="p_add">+		Return the previous state of the PSTATE.mcde bit:</span>
<span class="p_add">+			0 == was disabled, 1 == was enabled.</span>
<span class="p_add">+		Set errno to EINVAL and return -1 if ADI is not available.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_ENABLE_SPARC_ADI - Enable ADI checking in all pages in the address</span>
<span class="p_add">+		range specified. The pages in the range must be already</span>
<span class="p_add">+		locked. This operation enables the TTE.mcd bit for the</span>
<span class="p_add">+		pages specified. arg2 is the starting address for address</span>
<span class="p_add">+		range and must be page aligned. arg3 is the length of</span>
<span class="p_add">+		memory address range and must be a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_DISABLE_SPARC_ADI - Disable ADI checking on all the pages in the</span>
<span class="p_add">+		address range specified. This operation disables the</span>
<span class="p_add">+		TTE.mcd bit for the pages specified. arg2 is the</span>
<span class="p_add">+		starting address for address range and must be page</span>
<span class="p_add">+		aligned. arg3 is the length of memory address range and</span>
<span class="p_add">+		must be a multiple of page size.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	PR_GET_SPARC_ADI_STATUS - Check if ADI is enabled or not for a</span>
<span class="p_add">+		given virtual address. Returns 1 for enabled, else 0.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+All addresses passed to kernel must be non-ADI tagged addresses.</span>
<span class="p_add">+Kernel does not enable ADI for kernel code.</span>
<span class="p_header">diff --git a/Documentation/sparc/adi.txt b/Documentation/sparc/adi.txt</span>
new file mode 100644
<span class="p_header">index 0000000..ac4a9d9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/sparc/adi.txt</span>
<span class="p_chunk">@@ -0,0 +1,206 @@</span> <span class="p_context"></span>
<span class="p_add">+Application Data Integrity (ADI)</span>
<span class="p_add">+================================</span>
<span class="p_add">+</span>
<span class="p_add">+Sparc M7 processor adds the Application Data Integrity (ADI) feature.</span>
<span class="p_add">+ADI allows a task to set version tags on any subset of its address</span>
<span class="p_add">+space. Once ADI is enabled and version tags are set for ranges of</span>
<span class="p_add">+address space of a task, the processor will compare the tag in pointers</span>
<span class="p_add">+to memory in these ranges to the version set by the application</span>
<span class="p_add">+previously. Access to memory is granted only if the tag in given</span>
<span class="p_add">+pointer matches the tag set by the application. In case of mismatch,</span>
<span class="p_add">+processor raises an exception.  ADI can be enabled on pages that are</span>
<span class="p_add">+locked in memory, i.e.  are not swappable.</span>
<span class="p_add">+</span>
<span class="p_add">+Following steps must be taken by a task to enable ADI fully:</span>
<span class="p_add">+</span>
<span class="p_add">+1. Set the user mode PSTATE.mcde bit</span>
<span class="p_add">+</span>
<span class="p_add">+2. Set TTE.mcd bit on any TLB entries that correspond to the range of</span>
<span class="p_add">+addresses ADI is being enabled on.</span>
<span class="p_add">+</span>
<span class="p_add">+3. Set the version tag for memory addresses.</span>
<span class="p_add">+</span>
<span class="p_add">+Kernel provides prctl() calls to perform steps 1 (PR_SET_SPARC_ADI) and</span>
<span class="p_add">+2 (PR_ENABLE_SPARC_ADI). Please see Documentation/prctl/sparc_adi.txt</span>
<span class="p_add">+for more details on these prctl calls. Step 3 is performed with an</span>
<span class="p_add">+stxa instruction on the address using ASI_MCD_PRIMARY or</span>
<span class="p_add">+ASI_MCD_ST_BLKINIT_PRIMARY. Version tags are stoed in bits 63-60 of</span>
<span class="p_add">+address and are set on a cache line. Version tag values of 0x0 and 0xf</span>
<span class="p_add">+are reserved.</span>
<span class="p_add">+</span>
<span class="p_add">+NOTE:	ADI is supported on hugepage only. Hugepages are already locked</span>
<span class="p_add">+	in memory.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ADI related traps</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+With ADI enabled, following new traps may occur:</span>
<span class="p_add">+</span>
<span class="p_add">+Disrupting memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory localtion that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. By</span>
<span class="p_add">+	default, it is a disrupting trap and is sent to the hypervisor</span>
<span class="p_add">+	first. Hypervisor creates a sun4v error report and sends a</span>
<span class="p_add">+	resumable error (TT=0x7e) trap to the kernel. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+		siginfo.si_addr = addr; /* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Precise memory corruption</span>
<span class="p_add">+</span>
<span class="p_add">+	When a store accesses a memory location that has TTE.mcd=1,</span>
<span class="p_add">+	the task is running with ADI enabled (PSTATE.mcde=1), and the ADI</span>
<span class="p_add">+	tag in the address used (bits 63:60) does not match the tag set on</span>
<span class="p_add">+	the corresponding cacheline, a memory corruption trap occurs. If</span>
<span class="p_add">+	MCD precise exception is enabled (MCDPERR=1), a precise</span>
<span class="p_add">+	exception is sent to the kernel with TT=0x1a. The kernel sends</span>
<span class="p_add">+	a SIGSEGV to the task that resulted in this trap with the following</span>
<span class="p_add">+	info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGSEGV;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	NOTE: ADI tag mismatch on a load always results in precise trap.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+MCD disabled</span>
<span class="p_add">+</span>
<span class="p_add">+	When a task has not enabled ADI and attempts to set ADI version</span>
<span class="p_add">+	on a memory address, processor sends an MCD disabled trap. This</span>
<span class="p_add">+	trap is handled by hypervisor first and the hypervisor vectors this</span>
<span class="p_add">+	trap through to the kernel as Data Access Exception trap with</span>
<span class="p_add">+	fault type set to 0xa (invalid ASI). When this occurs, the kernel</span>
<span class="p_add">+	sends the task SIGBUS signal with following info:</span>
<span class="p_add">+</span>
<span class="p_add">+		siginfo.si_signo = SIGBUS;</span>
<span class="p_add">+		siginfo.errno = 0;</span>
<span class="p_add">+		siginfo.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		siginfo.si_addr = addr;	/* address that caused trap */</span>
<span class="p_add">+		siginfo.si_trapno = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Sample program to use ADI</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Following sample program is meant to illustrate how to use the ADI</span>
<span class="p_add">+functionality with the default 8M hugepages.</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;unistd.h&gt;</span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;stdlib.h&gt;</span>
<span class="p_add">+#include &lt;sys/ipc.h&gt;</span>
<span class="p_add">+#include &lt;sys/shm.h&gt;</span>
<span class="p_add">+#include &lt;asm/asi.h&gt;</span>
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUFFER_SIZE	32*1024*1024</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps adicap;</span>
<span class="p_add">+</span>
<span class="p_add">+main()</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long i, mcde;</span>
<span class="p_add">+	char *shmaddr, *tmp_addr, *end, *veraddr, *clraddr;</span>
<span class="p_add">+	int shmid, version;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((shmid = shmget(2, BUFFER_SIZE,</span>
<span class="p_add">+				SHM_HUGETLB | IPC_CREAT | SHM_R | SHM_W)) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;shmget failed&quot;);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	shmaddr = shmat(shmid, NULL, 0);</span>
<span class="p_add">+	if (shmaddr == (char *)-1) {</span>
<span class="p_add">+		perror(&quot;shm attach failed&quot;);</span>
<span class="p_add">+		shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+		exit(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the values for various ADI capabilities bits. These will</span>
<span class="p_add">+	 * be used later for setting the ADI tag</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_GET_SPARC_ADICAPS, &amp;adicap) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;PR_GET_SPARC_ADICAPS failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set PSTATE.mcde</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((mcde = prctl(PR_SET_SPARC_ADI, PR_SET_SPARC_ADI_SET)) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;PR_SET_SPARC_ADI failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set TTE.mcd on the address range for shm segment</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_ENABLE_SPARC_ADI, shmaddr, BUFFER_SIZE) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;prctl failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the ADI version tag on the shm segment</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	version = 10;</span>
<span class="p_add">+	tmp_addr = shmaddr;</span>
<span class="p_add">+	end = shmaddr + BUFFER_SIZE;</span>
<span class="p_add">+	while (tmp_addr &lt; end) {</span>
<span class="p_add">+		asm volatile(</span>
<span class="p_add">+			&quot;stxa %1, [%0]ASI_MCD_PRIMARY\n\t&quot;</span>
<span class="p_add">+			:</span>
<span class="p_add">+			: &quot;r&quot; (tmp_addr), &quot;r&quot; (version));</span>
<span class="p_add">+		tmp_addr += adicap.blksz;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create a versioned address from the normal address</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	tmp_addr = (void *) ((unsigned long)shmaddr &lt;&lt; adicap.nbits);</span>
<span class="p_add">+	tmp_addr = (void *) ((unsigned long)tmp_addr &gt;&gt; adicap.nbits);</span>
<span class="p_add">+	veraddr = (void *) (((unsigned long)version &lt;&lt; (64-adicap.nbits))</span>
<span class="p_add">+			| (unsigned long)tmp_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;Starting the writes:\n&quot;);</span>
<span class="p_add">+	for (i = 0; i &lt; BUFFER_SIZE; i++) {</span>
<span class="p_add">+		veraddr[i] = (char)(i);</span>
<span class="p_add">+		if (!(i % (1024 * 1024)))</span>
<span class="p_add">+			printf(&quot;.&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	printf(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	printf(&quot;Verifying data...&quot;);</span>
<span class="p_add">+	for (i = 0; i &lt; BUFFER_SIZE; i++)</span>
<span class="p_add">+		if (veraddr[i] != (char)i)</span>
<span class="p_add">+			printf(&quot;\nIndex %lu mismatched\n&quot;, i);</span>
<span class="p_add">+	printf(&quot;Done.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable ADI and clean up</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (prctl(PR_DISABLE_SPARC_ADI, shmaddr, BUFFER_SIZE) &lt; 0) {</span>
<span class="p_add">+		perror(&quot;prctl failed&quot;);</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+		perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+	shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	exit(0);</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	if (shmdt((const void *)shmaddr) != 0)</span>
<span class="p_add">+		perror(&quot;Detach failure&quot;);</span>
<span class="p_add">+	shmctl(shmid, IPC_RMID, NULL);</span>
<span class="p_add">+	exit(1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/sparc/Kconfig b/arch/sparc/Kconfig</span>
<span class="p_header">index 56442d2..0aac0ae 100644</span>
<span class="p_header">--- a/arch/sparc/Kconfig</span>
<span class="p_header">+++ b/arch/sparc/Kconfig</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> config SPARC64</span>
 	select NO_BOOTMEM
 	select HAVE_ARCH_AUDITSYSCALL
 	select ARCH_SUPPORTS_ATOMIC_RMW
<span class="p_add">+	select SPARC_ADI</span>
 
 config ARCH_DEFCONFIG
 	string
<span class="p_chunk">@@ -314,6 +315,17 @@</span> <span class="p_context"> if SPARC64</span>
 source &quot;kernel/power/Kconfig&quot;
 endif
 
<span class="p_add">+config SPARC_ADI</span>
<span class="p_add">+	bool &quot;Application Data Integrity support&quot;</span>
<span class="p_add">+	def_bool y if SPARC64</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for Application Data Integrity (ADI). ADI feature allows</span>
<span class="p_add">+	  a process to tag memory blocks with version tags. Once ADI is</span>
<span class="p_add">+	  enabled and version tag is set on a memory block, any access to</span>
<span class="p_add">+	  it is allowed only if the correct version tag is presented by</span>
<span class="p_add">+	  a process. This feature is meant to help catch rogue accesses</span>
<span class="p_add">+	  to memory.</span>
<span class="p_add">+</span>
 config SCHED_SMT
 	bool &quot;SMT (Hyperthreading) scheduler support&quot;
 	depends on SPARC64 &amp;&amp; SMP
<span class="p_header">diff --git a/arch/sparc/include/asm/hugetlb.h b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">index 139e711..5e7547c 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -82,4 +82,18 @@</span> <span class="p_context"> static inline void arch_clear_hugepage_flags(struct page *page)</span>
 {
 }
 
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+static inline pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+			 struct page *page, int writeable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* If this vma has ADI enabled on it, turn on TTE.mcd</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return pte_mkmcd(entry);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return pte_mknotmcd(entry);</span>
<span class="p_add">+}</span>
<span class="p_add">+#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* _ASM_SPARC64_HUGETLB_H */
<span class="p_header">diff --git a/arch/sparc/include/asm/hypervisor.h b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">index f5b6537..2940bb3 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/hypervisor.h</span>
<span class="p_chunk">@@ -547,6 +547,8 @@</span> <span class="p_context"> struct hv_fault_status {</span>
 #define HV_FAULT_TYPE_RESV1	13
 #define HV_FAULT_TYPE_UNALIGNED	14
 #define HV_FAULT_TYPE_INV_PGSZ	15
<span class="p_add">+#define HV_FAULT_TYPE_MCD	17</span>
<span class="p_add">+#define HV_FAULT_TYPE_MCD_DIS	18</span>
 /* Values 16 --&gt; -2 are reserved.  */
 #define HV_FAULT_TYPE_MULTIPLE	-1
 
<span class="p_header">diff --git a/arch/sparc/include/asm/mmu_64.h b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">index 70067ce..8e98741 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/mmu_64.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> typedef struct {</span>
 	unsigned long		huge_pte_count;
 	struct tsb_config	tsb_block[MM_NUM_TSBS];
 	struct hv_tsb_descr	tsb_descr[MM_NUM_TSBS];
<span class="p_add">+	unsigned char		adi;</span>
 } mm_context_t;
 
 #endif /* !__ASSEMBLY__ */
<span class="p_header">diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">index 131d36f..cddea30 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -162,6 +162,9 @@</span> <span class="p_context"> bool kern_addr_valid(unsigned long addr);</span>
 #define _PAGE_E_4V	  _AC(0x0000000000000800,UL) /* side-Effect          */
 #define _PAGE_CP_4V	  _AC(0x0000000000000400,UL) /* Cacheable in P-Cache */
 #define _PAGE_CV_4V	  _AC(0x0000000000000200,UL) /* Cacheable in V-Cache */
<span class="p_add">+/* Bit 9 is used to enable MCD corruption detection instead on M7</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define _PAGE_MCD_4V	  _AC(0x0000000000000200,UL) /* Memory Corruption    */</span>
 #define _PAGE_P_4V	  _AC(0x0000000000000100,UL) /* Privileged Page      */
 #define _PAGE_EXEC_4V	  _AC(0x0000000000000080,UL) /* Executable Page      */
 #define _PAGE_W_4V	  _AC(0x0000000000000040,UL) /* Writable             */
<span class="p_chunk">@@ -541,6 +544,18 @@</span> <span class="p_context"> static inline pte_t pte_mkspecial(pte_t pte)</span>
 	return pte;
 }
 
<span class="p_add">+static inline pte_t pte_mkmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) |= _PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pte_t pte_mknotmcd(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_val(pte) &amp;= ~_PAGE_MCD_4V;</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long pte_young(pte_t pte)
 {
 	unsigned long mask;
<span class="p_header">diff --git a/arch/sparc/include/asm/processor_64.h b/arch/sparc/include/asm/processor_64.h</span>
<span class="p_header">index 6924bde..9a71701 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/processor_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/processor_64.h</span>
<span class="p_chunk">@@ -97,6 +97,25 @@</span> <span class="p_context"> struct thread_struct {</span>
 struct task_struct;
 unsigned long thread_saved_pc(struct task_struct *);
 
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+extern struct adi_caps *get_adi_caps(void);</span>
<span class="p_add">+extern long get_sparc_adicaps(unsigned long);</span>
<span class="p_add">+extern long set_sparc_pstate_mcde(unsigned long);</span>
<span class="p_add">+extern long enable_sparc_adi(unsigned long, unsigned long);</span>
<span class="p_add">+extern long disable_sparc_adi(unsigned long, unsigned long);</span>
<span class="p_add">+extern long get_sparc_adi_status(unsigned long);</span>
<span class="p_add">+extern bool adi_capable(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#define GET_SPARC_ADICAPS(a)	get_sparc_adicaps(a)</span>
<span class="p_add">+#define SET_SPARC_MCDE(a)	set_sparc_pstate_mcde(a)</span>
<span class="p_add">+#define ENABLE_SPARC_ADI(a, b)	enable_sparc_adi(a, b)</span>
<span class="p_add">+#define DISABLE_SPARC_ADI(a, b)	disable_sparc_adi(a, b)</span>
<span class="p_add">+#define GET_SPARC_ADI_STATUS(a)	get_sparc_adi_status(a)</span>
<span class="p_add">+#define ADI_CAPABLE()		adi_capable()</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define ADI_CAPABLE()		0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* On Uniprocessor, even in RMO processes see TSO semantics */
 #ifdef CONFIG_SMP
 #define TSTATE_INITIAL_MM	TSTATE_TSO
<span class="p_header">diff --git a/arch/sparc/include/asm/ttable.h b/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">index 71b5a67..342b457 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/ttable.h</span>
<span class="p_chunk">@@ -212,6 +212,16 @@</span> <span class="p_context"></span>
 	nop;						\
 	nop;
 
<span class="p_add">+#define SUN4V_MCD_PRECISE				\</span>
<span class="p_add">+	ldxa	[%g0] ASI_SCRATCHPAD, %g2;		\</span>
<span class="p_add">+	ldx	[%g2 + HV_FAULT_D_ADDR_OFFSET], %g4;	\</span>
<span class="p_add">+	ldx	[%g2 + HV_FAULT_D_CTX_OFFSET], %g5;	\</span>
<span class="p_add">+	ba,pt	%xcc, sun4v_mcd_detect_precise;		\</span>
<span class="p_add">+	 nop;						\</span>
<span class="p_add">+	nop;						\</span>
<span class="p_add">+	nop;						\</span>
<span class="p_add">+	nop;</span>
<span class="p_add">+</span>
 /* Before touching these macros, you owe it to yourself to go and
  * see how arch/sparc64/kernel/winfixup.S works... -DaveM
  *
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/asi.h b/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_header">index 7ad7203d..7d099ac 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/asi.h</span>
<span class="p_chunk">@@ -244,6 +244,9 @@</span> <span class="p_context"></span>
 #define ASI_UDBL_CONTROL_R	0x7f /* External UDB control regs rd low*/
 #define ASI_INTR_R		0x7f /* IRQ vector dispatch read	*/
 #define ASI_INTR_DATAN_R	0x7f /* (III) In irq vector data reg N	*/
<span class="p_add">+#define ASI_MCD_PRIMARY		0x90 /* (NG7) MCD version load/store	*/</span>
<span class="p_add">+#define ASI_MCD_ST_BLKINIT_PRIMARY	\</span>
<span class="p_add">+				0x92 /* (NG7) MCD store BLKINIT primary	*/</span>
 #define ASI_PIC			0xb0 /* (NG4) PIC registers		*/
 #define ASI_PST8_P		0xc0 /* Primary, 8 8-bit, partial	*/
 #define ASI_PST8_S		0xc1 /* Secondary, 8 8-bit, partial	*/
<span class="p_header">diff --git a/arch/sparc/include/uapi/asm/pstate.h b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_header">index cf832e1..d0521db 100644</span>
<span class="p_header">--- a/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_header">+++ b/arch/sparc/include/uapi/asm/pstate.h</span>
<span class="p_chunk">@@ -10,7 +10,12 @@</span> <span class="p_context"></span>
  * -----------------------------------------------------------------------
  *  63  12  11   10    9     8    7   6   5     4     3     2     1    0
  */
<span class="p_add">+/* IG on V9 conflicts with MCDE on M7. PSTATE_MCDE will only be used on</span>
<span class="p_add">+ * processors that support ADI which do not use IG, hence there is no</span>
<span class="p_add">+ * functional conflict</span>
<span class="p_add">+ */</span>
 #define PSTATE_IG   _AC(0x0000000000000800,UL) /* Interrupt Globals.	*/
<span class="p_add">+#define PSTATE_MCDE _AC(0x0000000000000800,UL) /* MCD Enable		*/</span>
 #define PSTATE_MG   _AC(0x0000000000000400,UL) /* MMU Globals.		*/
 #define PSTATE_CLE  _AC(0x0000000000000200,UL) /* Current Little Endian.*/
 #define PSTATE_TLE  _AC(0x0000000000000100,UL) /* Trap Little Endian.	*/
<span class="p_chunk">@@ -47,7 +52,12 @@</span> <span class="p_context"></span>
 #define TSTATE_ASI	_AC(0x00000000ff000000,UL) /* AddrSpace ID.	*/
 #define TSTATE_PIL	_AC(0x0000000000f00000,UL) /* %pil (Linux traps)*/
 #define TSTATE_PSTATE	_AC(0x00000000000fff00,UL) /* PSTATE.		*/
<span class="p_add">+/* IG on V9 conflicts with MCDE on M7. TSTATE_MCDE will only be used on</span>
<span class="p_add">+ * processors that support ADI which do not support IG, hence there is</span>
<span class="p_add">+ * no functional conflict</span>
<span class="p_add">+ */</span>
 #define TSTATE_IG	_AC(0x0000000000080000,UL) /* Interrupt Globals.*/
<span class="p_add">+#define TSTATE_MCDE	_AC(0x0000000000080000,UL) /* MCD enable.       */</span>
 #define TSTATE_MG	_AC(0x0000000000040000,UL) /* MMU Globals.	*/
 #define TSTATE_CLE	_AC(0x0000000000020000,UL) /* CurrLittleEndian.	*/
 #define TSTATE_TLE	_AC(0x0000000000010000,UL) /* TrapLittleEndian.	*/
<span class="p_header">diff --git a/arch/sparc/kernel/entry.h b/arch/sparc/kernel/entry.h</span>
<span class="p_header">index 0f67942..2078468 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/entry.h</span>
<span class="p_header">+++ b/arch/sparc/kernel/entry.h</span>
<span class="p_chunk">@@ -159,6 +159,9 @@</span> <span class="p_context"> void sun4v_resum_overflow(struct pt_regs *regs);</span>
 void sun4v_nonresum_error(struct pt_regs *regs,
 			  unsigned long offset);
 void sun4v_nonresum_overflow(struct pt_regs *regs);
<span class="p_add">+void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs,</span>
<span class="p_add">+				      unsigned long addr,</span>
<span class="p_add">+				      unsigned long context);</span>
 
 extern unsigned long sun4v_err_itlb_vaddr;
 extern unsigned long sun4v_err_itlb_ctx;
<span class="p_header">diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S</span>
<span class="p_header">index f2d30ca..f4a880b 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/head_64.S</span>
<span class="p_chunk">@@ -878,6 +878,7 @@</span> <span class="p_context"> sparc64_boot_end:</span>
 #include &quot;helpers.S&quot;
 #include &quot;hvcalls.S&quot;
 #include &quot;sun4v_tlb_miss.S&quot;
<span class="p_add">+#include &quot;sun4v_mcd.S&quot;</span>
 #include &quot;sun4v_ivec.S&quot;
 #include &quot;ktlb.S&quot;
 #include &quot;tsb.S&quot;
<span class="p_header">diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">index 6f80936..79f981c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/mdesc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/mdesc.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/bootmem.h&gt;
 #include &lt;linux/export.h&gt;
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
 
 #include &lt;asm/cpudata.h&gt;
 #include &lt;asm/hypervisor.h&gt;
<span class="p_chunk">@@ -512,6 +513,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(mdesc_node_name);</span>
 
 static u64 max_cpus = 64;
 
<span class="p_add">+static struct {</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	struct adi_caps caps;</span>
<span class="p_add">+} adi_state;</span>
<span class="p_add">+</span>
 static void __init report_platform_properties(void)
 {
 	struct mdesc_handle *hp = mdesc_grab();
<span class="p_chunk">@@ -1007,6 +1013,80 @@</span> <span class="p_context"> static int mdesc_open(struct inode *inode, struct file *file)</span>
 	return 0;
 }
 
<span class="p_add">+bool adi_capable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return adi_state.enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct adi_caps *get_adi_caps(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;adi_state.caps;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init</span>
<span class="p_add">+init_adi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mdesc_handle *hp = mdesc_grab();</span>
<span class="p_add">+	const char *prop;</span>
<span class="p_add">+	u64 pn, *val;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	adi_state.enabled = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hp)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;cpu&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	prop = mdesc_get_property(hp, pn, &quot;hwcap-list&quot;, &amp;len);</span>
<span class="p_add">+	if (!prop)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Look for &quot;adp&quot; keyword in hwcap-list which would indicate</span>
<span class="p_add">+	 * ADI support</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (len) {</span>
<span class="p_add">+		int plen;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!strcmp(prop, &quot;adp&quot;)) {</span>
<span class="p_add">+			adi_state.enabled = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		plen = strlen(prop) + 1;</span>
<span class="p_add">+		prop += plen;</span>
<span class="p_add">+		len -= plen;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!adi_state.enabled)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	pn = mdesc_node_by_name(hp, MDESC_NODE_NULL, &quot;platform&quot;);</span>
<span class="p_add">+	if (pn == MDESC_NODE_NULL)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-blksz&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.blksz = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;adp-nbits&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.nbits = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = (u64 *) mdesc_get_property(hp, pn, &quot;ue-on-adp&quot;, &amp;len);</span>
<span class="p_add">+	if (!val)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	adi_state.caps.ue_on_adi = *val;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mdesc_release(hp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ssize_t mdesc_read(struct file *file, char __user *buf,
 			  size_t len, loff_t *offp)
 {
<span class="p_chunk">@@ -1110,5 +1190,6 @@</span> <span class="p_context"> void __init sun4v_mdesc_init(void)</span>
 
 	cur_mdesc = hp;
 
<span class="p_add">+	init_adi();</span>
 	report_platform_properties();
 }
<span class="p_header">diff --git a/arch/sparc/kernel/process_64.c b/arch/sparc/kernel/process_64.c</span>
<span class="p_header">index 46a5964..33fcc85 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/process_64.c</span>
<span class="p_chunk">@@ -32,6 +32,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/sysrq.h&gt;
 #include &lt;linux/nmi.h&gt;
 #include &lt;linux/context_tracking.h&gt;
<span class="p_add">+#include &lt;linux/prctl.h&gt;</span>
<span class="p_add">+#include &lt;linux/hugetlb.h&gt;</span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_chunk">@@ -777,3 +779,222 @@</span> <span class="p_context"> unsigned long get_wchan(struct task_struct *task)</span>
 out:
 	return ret;
 }
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SPARC_ADI</span>
<span class="p_add">+long get_sparc_adicaps(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct adi_caps *caps;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	caps = get_adi_caps();</span>
<span class="p_add">+	if (val)</span>
<span class="p_add">+		if (copy_to_user((void *)val, caps, sizeof(struct adi_caps)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long set_sparc_pstate_mcde(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long error;</span>
<span class="p_add">+	struct pt_regs *regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We do not allow anonymous tasks to enable ADI because they</span>
<span class="p_add">+	 * run in borrowed aadress space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (current-&gt;mm == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	regs = task_pt_regs(current);</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_MCDE)</span>
<span class="p_add">+		error = 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		error = 0;</span>
<span class="p_add">+	switch (val) {</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		regs-&gt;tstate |= TSTATE_MCDE;</span>
<span class="p_add">+		current-&gt;mm-&gt;context.adi = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		regs-&gt;tstate &amp;= ~TSTATE_MCDE;</span>
<span class="p_add">+		current-&gt;mm-&gt;context.adi = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long enable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long end, pagemask;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+	struct vm_area_struct *vma, *vma2;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ADI is supported for hugepages only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!is_vm_hugetlb_page(vma))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Is the start address page aligned and is the length multiple</span>
<span class="p_add">+	 * of page size?</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="p_add">+	if (addr &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (len &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	end = addr + len;</span>
<span class="p_add">+	if (end == addr)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Verify end of the region is not out of bounds</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="p_add">+	if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = 0;</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		/* If the address space ADI is to be enabled in, does not cover</span>
<span class="p_add">+		 * this vma in its entirety, we will need to split it.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mm = vma-&gt;vm_mm;</span>
<span class="p_add">+		if (addr != vma-&gt;vm_start) {</span>
<span class="p_add">+			error = split_vma(mm, vma, addr, 1);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (end &lt; vma-&gt;vm_end) {</span>
<span class="p_add">+			error = split_vma(mm, vma, end, 0);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update the ADI info in vma and PTE</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		vma-&gt;vm_flags |= VM_SPARC_ADI;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (end &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+			change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="p_add">+					  vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			addr = vma-&gt;vm_end;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="p_add">+					vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+		if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if (error == -ENOMEM)</span>
<span class="p_add">+		error = -EAGAIN;</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long disable_sparc_adi(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long end, pagemask;</span>
<span class="p_add">+	struct vm_area_struct *vma, *vma2, *prev;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+	pgoff_t pgoff;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ADI is supported for hugepages only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!is_vm_hugetlb_page(vma))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Is the start address page aligned and is the length multiple</span>
<span class="p_add">+	 * of page size?</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pagemask = ~(vma_kernel_pagesize(vma) - 1);</span>
<span class="p_add">+	if (addr &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (len &amp; ~pagemask)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	end = addr + len;</span>
<span class="p_add">+	if (end == addr)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Verify end of the region is not out of bounds</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vma2 = find_vma(current-&gt;mm, end-1);</span>
<span class="p_add">+	if (unlikely(!vma2) || (vma2-&gt;vm_start &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		mm = vma-&gt;vm_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update the ADI info in vma and check if this vma can</span>
<span class="p_add">+		 * be merged with adjacent ones</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pgoff = vma-&gt;vm_pgoff + ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		prev = vma_merge(mm, prev, addr, end, vma-&gt;vm_flags,</span>
<span class="p_add">+				 vma-&gt;anon_vma, vma-&gt;vm_file, pgoff,</span>
<span class="p_add">+				 vma_policy(vma), vma-&gt;vm_userfaultfd_ctx);</span>
<span class="p_add">+		if (prev)</span>
<span class="p_add">+			vma = prev;</span>
<span class="p_add">+</span>
<span class="p_add">+		vma-&gt;vm_flags &amp;= ~VM_SPARC_ADI;</span>
<span class="p_add">+		if (end &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+			change_protection(vma, addr, vma-&gt;vm_end,</span>
<span class="p_add">+					  vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			addr = vma-&gt;vm_end;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			change_protection(vma, addr, end, vma-&gt;vm_page_prot,</span>
<span class="p_add">+					  vma_wants_writenotify(vma), 0);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(current-&gt;mm, addr, &amp;prev);</span>
<span class="p_add">+		if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long get_sparc_adi_status(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vm_area_struct *vma;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	vma = find_vma(current-&gt;mm, addr);</span>
<span class="p_add">+	if (unlikely(!vma) || (vma-&gt;vm_start &gt; addr))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SPARC_ADI)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/sparc/kernel/sun4v_mcd.S b/arch/sparc/kernel/sun4v_mcd.S</span>
new file mode 100644
<span class="p_header">index 0000000..d1d1259</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/sun4v_mcd.S</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+/* sun4v_mcd.S: Sun4v memory corruption detected precise exception handler</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2015 Bob Picco &lt;bob.picco@oracle.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2015 Khalid Aziz &lt;khalid.aziz@oracle.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.align 32</span>
<span class="p_add">+</span>
<span class="p_add">+sun4v_mcd_detect_precise:</span>
<span class="p_add">+	ba,pt	%xcc, etrap</span>
<span class="p_add">+	rd	%pc, %g7</span>
<span class="p_add">+	or	%l4, %g0, %o1</span>
<span class="p_add">+	or 	%l5, %g0, %o2</span>
<span class="p_add">+	call	sun4v_mem_corrupt_detect_precise</span>
<span class="p_add">+	add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+	ba,a,pt	%xcc, rtrap</span>
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index d21cd62..29db583 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -351,12 +351,31 @@</span> <span class="p_context"> void sun4v_data_access_exception(struct pt_regs *regs, unsigned long addr, unsig</span>
 		regs-&gt;tpc &amp;= 0xffffffff;
 		regs-&gt;tnpc &amp;= 0xffffffff;
 	}
<span class="p_del">-	info.si_signo = SIGSEGV;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MCD (Memory Corruption Detection) disabled trap (TT=0x19) in HV</span>
<span class="p_add">+	 * is vectored thorugh data access exception trap with fault type</span>
<span class="p_add">+	 * set to HV_FAULT_TYPE_MCD_DIS. Check for MCD disabled trap</span>
<span class="p_add">+	 */</span>
 	info.si_errno = 0;
<span class="p_del">-	info.si_code = SEGV_MAPERR;</span>
 	info.si_addr = (void __user *) addr;
 	info.si_trapno = 0;
<span class="p_del">-	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case HV_FAULT_TYPE_INV_ASI:</span>
<span class="p_add">+		info.si_signo = SIGILL;</span>
<span class="p_add">+		info.si_code = ILL_ILLADR;</span>
<span class="p_add">+		force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HV_FAULT_TYPE_MCD_DIS:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_ACCADI;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		info.si_code = SEGV_MAPERR;</span>
<span class="p_add">+		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void sun4v_data_access_exception_tl1(struct pt_regs *regs, unsigned long addr, unsigned long type_ctx)
<span class="p_chunk">@@ -1801,6 +1820,7 @@</span> <span class="p_context"> struct sun4v_error_entry {</span>
 #define SUN4V_ERR_ATTRS_ASI		0x00000080
 #define SUN4V_ERR_ATTRS_PRIV_REG	0x00000100
 #define SUN4V_ERR_ATTRS_SPSTATE_MSK	0x00000600
<span class="p_add">+#define SUN4V_ERR_ATTRS_MCD		0x00000800</span>
 #define SUN4V_ERR_ATTRS_SPSTATE_SHFT	9
 #define SUN4V_ERR_ATTRS_MODE_MSK	0x03000000
 #define SUN4V_ERR_ATTRS_MODE_SHFT	24
<span class="p_chunk">@@ -1998,6 +2018,36 @@</span> <span class="p_context"> static void sun4v_log_error(struct pt_regs *regs, struct sun4v_error_entry *ent,</span>
 	}
 }
 
<span class="p_add">+/* Handle memory corruption detected error which is vectored in</span>
<span class="p_add">+ * through resumable error trap.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void do_mcd_err(struct pt_regs *regs, struct sun4v_error_entry ent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;MCD error&quot;, regs,</span>
<span class="p_add">+		       0, 0x34, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		/* ADI tag mismatch in kernel mode means illegal access to</span>
<span class="p_add">+		 * kernel memory through rogue means potentially.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pr_emerg(&quot;mcd_err: ADI tag mismatch in kernel at &quot;</span>
<span class="p_add">+			&quot;ADDR[%016llx], going.\n&quot;, ent.err_raddr);</span>
<span class="p_add">+		die_if_kernel(&quot;MCD error&quot;, regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send SIGSEGV to the userspace process with the right code</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = SEGV_ADIDERR;</span>
<span class="p_add">+	info.si_addr = (void __user *)ent.err_raddr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We run with %pil set to PIL_NORMAL_MAX and PSTATE_IE enabled in %pstate.
  * Log the event and clear the first word of the entry.
  */
<span class="p_chunk">@@ -2035,6 +2085,14 @@</span> <span class="p_context"> void sun4v_resum_error(struct pt_regs *regs, unsigned long offset)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this is a memory corruption detected error, call the</span>
<span class="p_add">+	 * handler</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (local_copy.err_attrs &amp; SUN4V_ERR_ATTRS_MCD) {</span>
<span class="p_add">+		do_mcd_err(regs, local_copy);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sun4v_log_error(regs, &amp;local_copy, cpu,
 			KERN_ERR &quot;RESUMABLE ERROR&quot;,
 			&amp;sun4v_resum_oflow_cnt);
<span class="p_chunk">@@ -2531,6 +2589,38 @@</span> <span class="p_context"> void sun4v_do_mna(struct pt_regs *regs, unsigned long addr, unsigned long type_c</span>
 	force_sig_info(SIGBUS, &amp;info, current);
 }
 
<span class="p_add">+void sun4v_mem_corrupt_detect_precise(struct pt_regs *regs, unsigned long addr,</span>
<span class="p_add">+				      unsigned long context)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ADI_CAPABLE()) {</span>
<span class="p_add">+		bad_trap(regs, 0x1a);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (notify_die(DIE_TRAP, &quot;memory corruption precise exception&quot;, regs,</span>
<span class="p_add">+		       0, 0x8, SIGSEGV) == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;tstate &amp; TSTATE_PRIV) {</span>
<span class="p_add">+		pr_emerg(&quot;sun4v_mem_corrupt_detect_precise: ADDR[%016lx] &quot;</span>
<span class="p_add">+			&quot;CTX[%lx], going.\n&quot;, addr, context);</span>
<span class="p_add">+		die_if_kernel(&quot;MCD precise&quot;, regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_thread_flag(TIF_32BIT)) {</span>
<span class="p_add">+		regs-&gt;tpc &amp;= 0xffffffff;</span>
<span class="p_add">+		regs-&gt;tnpc &amp;= 0xffffffff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	info.si_signo = SIGSEGV;</span>
<span class="p_add">+	info.si_code = SEGV_ADIPERR;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_addr = (void __user *) addr;</span>
<span class="p_add">+	info.si_trapno = 0;</span>
<span class="p_add">+	force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void do_privop(struct pt_regs *regs)
 {
 	enum ctx_state prev_state = exception_enter();
<span class="p_header">diff --git a/arch/sparc/kernel/ttable_64.S b/arch/sparc/kernel/ttable_64.S</span>
<span class="p_header">index c6dfdaa..2343bf0 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ttable_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/ttable_64.S</span>
<span class="p_chunk">@@ -25,8 +25,10 @@</span> <span class="p_context"> tl0_ill:	membar #Sync</span>
 		TRAP_7INSNS(do_illegal_instruction)
 tl0_privop:	TRAP(do_privop)
 tl0_resv012:	BTRAP(0x12) BTRAP(0x13) BTRAP(0x14) BTRAP(0x15) BTRAP(0x16) BTRAP(0x17)
<span class="p_del">-tl0_resv018:	BTRAP(0x18) BTRAP(0x19) BTRAP(0x1a) BTRAP(0x1b) BTRAP(0x1c) BTRAP(0x1d)</span>
<span class="p_del">-tl0_resv01e:	BTRAP(0x1e) BTRAP(0x1f)</span>
<span class="p_add">+tl0_resv018:	BTRAP(0x18) BTRAP(0x19)</span>
<span class="p_add">+tl0_mcd:	SUN4V_MCD_PRECISE</span>
<span class="p_add">+tl0_resv01b:	BTRAP(0x1b)</span>
<span class="p_add">+tl0_resv01c:	BTRAP(0x1c) BTRAP(0x1d)	BTRAP(0x1e) BTRAP(0x1f)</span>
 tl0_fpdis:	TRAP_NOSAVE(do_fpdis)
 tl0_fpieee:	TRAP_SAVEFPU(do_fpieee)
 tl0_fpother:	TRAP_NOSAVE(do_fpother_check_fitos)
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 00bad77..5a80219 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -168,6 +168,8 @@</span> <span class="p_context"> extern unsigned int kobjsize(const void *objp);</span>
 # define VM_GROWSUP	VM_ARCH_1
 #elif defined(CONFIG_IA64)
 # define VM_GROWSUP	VM_ARCH_1
<span class="p_add">+#elif defined(CONFIG_SPARC64)</span>
<span class="p_add">+# define VM_SPARC_ADI	VM_ARCH_1	/* Uses ADI tag for access control */</span>
 #elif !defined(CONFIG_MMU)
 # define VM_MAPPED_COPY	VM_ARCH_1	/* T if mapped copy of data (nommu mmap) */
 #endif
<span class="p_header">diff --git a/include/uapi/asm-generic/siginfo.h b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">index 1e35520..8235d6e 100644</span>
<span class="p_header">--- a/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">+++ b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_chunk">@@ -206,7 +206,10 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 #define SEGV_MAPERR	(__SI_FAULT|1)	/* address not mapped to object */
 #define SEGV_ACCERR	(__SI_FAULT|2)	/* invalid permissions for mapped object */
 #define SEGV_BNDERR	(__SI_FAULT|3)  /* failed address bound checks */
<span class="p_del">-#define NSIGSEGV	3</span>
<span class="p_add">+#define SEGV_ACCADI	(__SI_FAULT|4)	/* ADI not enabled for mapped object */</span>
<span class="p_add">+#define SEGV_ADIDERR	(__SI_FAULT|5)	/* Disrupting MCD error */</span>
<span class="p_add">+#define SEGV_ADIPERR	(__SI_FAULT|6)	/* Precise MCD exception */</span>
<span class="p_add">+#define NSIGSEGV	6</span>
 
 /*
  * SIGBUS si_codes
<span class="p_header">diff --git a/include/uapi/linux/prctl.h b/include/uapi/linux/prctl.h</span>
<span class="p_header">index a8d0759..422c246 100644</span>
<span class="p_header">--- a/include/uapi/linux/prctl.h</span>
<span class="p_header">+++ b/include/uapi/linux/prctl.h</span>
<span class="p_chunk">@@ -197,4 +197,20 @@</span> <span class="p_context"> struct prctl_mm_map {</span>
 # define PR_CAP_AMBIENT_LOWER		3
 # define PR_CAP_AMBIENT_CLEAR_ALL	4
 
<span class="p_add">+/* SPARC ADI operations, see Documentation/prctl/sparc_adi.txt for details */</span>
<span class="p_add">+#define PR_GET_SPARC_ADICAPS	48</span>
<span class="p_add">+#define PR_SET_SPARC_ADI	49</span>
<span class="p_add">+# define PR_SET_SPARC_ADI_CLEAR	0</span>
<span class="p_add">+# define PR_SET_SPARC_ADI_SET	1</span>
<span class="p_add">+#define PR_ENABLE_SPARC_ADI	50</span>
<span class="p_add">+#define PR_DISABLE_SPARC_ADI	51</span>
<span class="p_add">+#define PR_GET_SPARC_ADI_STATUS	52</span>
<span class="p_add">+</span>
<span class="p_add">+/* Data structure returned by PR_GET_SPARC_ADICAPS */</span>
<span class="p_add">+struct adi_caps {</span>
<span class="p_add">+	__u64 blksz;</span>
<span class="p_add">+	__u64 nbits;</span>
<span class="p_add">+	__u64 ue_on_adi;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 #endif /* _LINUX_PRCTL_H */
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 6af9212..fa7b5d9 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -103,6 +103,21 @@</span> <span class="p_context"></span>
 #ifndef SET_FP_MODE
 # define SET_FP_MODE(a,b)	(-EINVAL)
 #endif
<span class="p_add">+#ifndef GET_SPARC_ADICAPS</span>
<span class="p_add">+# define GET_SPARC_ADICAPS(a)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef SET_SPARC_MCDE</span>
<span class="p_add">+# define SET_SPARC_MCDE(a)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef ENABLE_SPARC_ADI</span>
<span class="p_add">+# define ENABLE_SPARC_ADI(a, b)		(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef DISABLE_SPARC_ADI</span>
<span class="p_add">+# define DISABLE_SPARC_ADI(a, b)	(-EINVAL)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef GET_SPARC_ADI_STATUS</span>
<span class="p_add">+# define GET_SPARC_ADI_STATUS(a)	(-EINVAL)</span>
<span class="p_add">+#endif</span>
 
 /*
  * this is where the system-wide overflow UID and GID are defined, for
<span class="p_chunk">@@ -2266,6 +2281,21 @@</span> <span class="p_context"> SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,</span>
 	case PR_GET_FP_MODE:
 		error = GET_FP_MODE(me);
 		break;
<span class="p_add">+	case PR_GET_SPARC_ADICAPS:</span>
<span class="p_add">+		error = GET_SPARC_ADICAPS(arg2);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_SET_SPARC_ADI:</span>
<span class="p_add">+		error = SET_SPARC_MCDE(arg2);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_ENABLE_SPARC_ADI:</span>
<span class="p_add">+		error = ENABLE_SPARC_ADI(arg2, arg3);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_DISABLE_SPARC_ADI:</span>
<span class="p_add">+		error = DISABLE_SPARC_ADI(arg2, arg3);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PR_GET_SPARC_ADI_STATUS:</span>
<span class="p_add">+		error = GET_SPARC_ADI_STATUS(arg2);</span>
<span class="p_add">+		break;</span>
 	default:
 		error = -EINVAL;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



