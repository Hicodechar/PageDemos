
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.12 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.12</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 1, 2016, 9:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160601214617.GB19119@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9148247/mbox/"
   >mbox</a>
|
   <a href="/patch/9148247/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9148247/">/patch/9148247/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	BCF5260751 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:46:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A574B264FB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:46:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 970C027147; Wed,  1 Jun 2016 21:46:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3C261264FB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:46:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753025AbcFAVqj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 1 Jun 2016 17:46:39 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:42799 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751148AbcFAVqT (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 1 Jun 2016 17:46:19 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 1E5317D;
	Wed,  1 Jun 2016 21:46:18 +0000 (UTC)
Date: Wed, 1 Jun 2016 14:46:17 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.12
Message-ID: &lt;20160601214617.GB19119@kroah.com&gt;
References: &lt;20160601214610.GA19119@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160601214610.GA19119@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 1, 2016, 9:46 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/serial/tty.txt b/Documentation/serial/tty.txt</span>
<span class="p_header">index bc3842dc323a..e2dea3dc4307 100644</span>
<span class="p_header">--- a/Documentation/serial/tty.txt</span>
<span class="p_header">+++ b/Documentation/serial/tty.txt</span>
<span class="p_chunk">@@ -213,9 +213,6 @@</span> <span class="p_context"> TTY_IO_ERROR		If set, causes all subsequent userspace read/write</span>
 
 TTY_OTHER_CLOSED	Device is a pty and the other side has closed.
 
<span class="p_del">-TTY_OTHER_DONE		Device is a pty and the other side has closed and</span>
<span class="p_del">-			all pending input processing has been completed.</span>
<span class="p_del">-</span>
 TTY_NO_WRITE_SPLIT	Prevent driver from splitting up writes into
 			smaller chunks.
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index aad86274b61b..a1fbd691a36e 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 11</span>
<span class="p_add">+SUBLEVEL = 12</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_chunk">@@ -682,9 +682,10 @@</span> <span class="p_context"> KBUILD_CFLAGS += $(call cc-option, -mno-global-merge,)</span>
 KBUILD_CFLAGS += $(call cc-option, -fcatch-undefined-behavior)
 else
 
<span class="p_del">-# This warning generated too much noise in a regular build.</span>
<span class="p_del">-# Use make W=1 to enable this warning (see scripts/Makefile.build)</span>
<span class="p_add">+# These warnings generated too much noise in a regular build.</span>
<span class="p_add">+# Use make W=1 to enable them (see scripts/Makefile.build)</span>
 KBUILD_CFLAGS += $(call cc-disable-warning, unused-but-set-variable)
<span class="p_add">+KBUILD_CFLAGS += $(call cc-disable-warning, unused-const-variable)</span>
 endif
 
 ifdef CONFIG_FRAME_POINTER
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 61d96a645ff3..12d727fae0a7 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -886,11 +886,14 @@</span> <span class="p_context"> static int stage2_set_pmd_huge(struct kvm *kvm, struct kvm_mmu_memory_cache</span>
 	VM_BUG_ON(pmd_present(*pmd) &amp;&amp; pmd_pfn(*pmd) != pmd_pfn(*new_pmd));
 
 	old_pmd = *pmd;
<span class="p_del">-	kvm_set_pmd(pmd, *new_pmd);</span>
<span class="p_del">-	if (pmd_present(old_pmd))</span>
<span class="p_add">+	if (pmd_present(old_pmd)) {</span>
<span class="p_add">+		pmd_clear(pmd);</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pmd));
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_set_pmd(pmd, *new_pmd);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -939,12 +942,14 @@</span> <span class="p_context"> static int stage2_set_pte(struct kvm *kvm, struct kvm_mmu_memory_cache *cache,</span>
 
 	/* Create 2nd stage page table mapping - Level 3 */
 	old_pte = *pte;
<span class="p_del">-	kvm_set_pte(pte, *new_pte);</span>
<span class="p_del">-	if (pte_present(old_pte))</span>
<span class="p_add">+	if (pte_present(old_pte)) {</span>
<span class="p_add">+		kvm_set_pte(pte, __pte(0));</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pte));
<span class="p_add">+	}</span>
 
<span class="p_add">+	kvm_set_pte(pte, *new_pte);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">index d6739e836f7b..b9da9545b442 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_chunk">@@ -117,7 +117,6 @@</span> <span class="p_context"></span>
  * Section
  */
 #define PMD_SECT_VALID		(_AT(pmdval_t, 1) &lt;&lt; 0)
<span class="p_del">-#define PMD_SECT_PROT_NONE	(_AT(pmdval_t, 1) &lt;&lt; 58)</span>
 #define PMD_SECT_USER		(_AT(pmdval_t, 1) &lt;&lt; 6)		/* AP[1] */
 #define PMD_SECT_RDONLY		(_AT(pmdval_t, 1) &lt;&lt; 7)		/* AP[2] */
 #define PMD_SECT_S		(_AT(pmdval_t, 3) &lt;&lt; 8)
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index c63868ae9a4a..67c2ad6d33b7 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -347,6 +347,7 @@</span> <span class="p_context"> void pmdp_splitting_flush(struct vm_area_struct *vma, unsigned long address,</span>
 #endif /* CONFIG_HAVE_RCU_TABLE_FREE */
 #endif /* CONFIG_TRANSPARENT_HUGEPAGE */
 
<span class="p_add">+#define pmd_present(pmd)	pte_present(pmd_pte(pmd))</span>
 #define pmd_dirty(pmd)		pte_dirty(pmd_pte(pmd))
 #define pmd_young(pmd)		pte_young(pmd_pte(pmd))
 #define pmd_wrprotect(pmd)	pte_pmd(pte_wrprotect(pmd_pte(pmd)))
<span class="p_chunk">@@ -355,7 +356,7 @@</span> <span class="p_context"> void pmdp_splitting_flush(struct vm_area_struct *vma, unsigned long address,</span>
 #define pmd_mkwrite(pmd)	pte_pmd(pte_mkwrite(pmd_pte(pmd)))
 #define pmd_mkdirty(pmd)	pte_pmd(pte_mkdirty(pmd_pte(pmd)))
 #define pmd_mkyoung(pmd)	pte_pmd(pte_mkyoung(pmd_pte(pmd)))
<span class="p_del">-#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_TYPE_MASK))</span>
<span class="p_add">+#define pmd_mknotpresent(pmd)	(__pmd(pmd_val(pmd) &amp; ~PMD_SECT_VALID))</span>
 
 #define __HAVE_ARCH_PMD_WRITE
 #define pmd_write(pmd)		pte_write(pmd_pte(pmd))
<span class="p_chunk">@@ -394,7 +395,6 @@</span> <span class="p_context"> extern pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,</span>
 				     unsigned long size, pgprot_t vma_prot);
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
<span class="p_del">-#define pmd_present(pmd)	(pmd_val(pmd))</span>
 
 #define pmd_bad(pmd)		(!(pmd_val(pmd) &amp; 2))
 
<span class="p_chunk">@@ -538,6 +538,21 @@</span> <span class="p_context"> static inline pmd_t pmd_modify(pmd_t pmd, pgprot_t newprot)</span>
 }
 
 #ifdef CONFIG_ARM64_HW_AFDBM
<span class="p_add">+#define __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS</span>
<span class="p_add">+extern int ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+				 unsigned long address, pte_t *ptep,</span>
<span class="p_add">+				 pte_t entry, int dirty);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="p_add">+#define __HAVE_ARCH_PMDP_SET_ACCESS_FLAGS</span>
<span class="p_add">+static inline int pmdp_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+					unsigned long address, pmd_t *pmdp,</span>
<span class="p_add">+					pmd_t entry, int dirty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ptep_set_access_flags(vma, address, (pte_t *)pmdp, pmd_pte(entry), dirty);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * Atomic pte/pmd modifications.
  */
<span class="p_chunk">@@ -590,9 +605,9 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm,</span>
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-#define __HAVE_ARCH_PMDP_GET_AND_CLEAR</span>
<span class="p_del">-static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,</span>
<span class="p_del">-				       unsigned long address, pmd_t *pmdp)</span>
<span class="p_add">+#define __HAVE_ARCH_PMDP_HUGE_GET_AND_CLEAR</span>
<span class="p_add">+static inline pmd_t pmdp_huge_get_and_clear(struct mm_struct *mm,</span>
<span class="p_add">+					    unsigned long address, pmd_t *pmdp)</span>
 {
 	return pte_pmd(ptep_get_and_clear(mm, address, (pte_t *)pmdp));
 }
<span class="p_header">diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_header">index 212ae6361d8b..a5f234039616 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_chunk">@@ -85,7 +85,8 @@</span> <span class="p_context"> static const char *const compat_hwcap_str[] = {</span>
 	&quot;idivt&quot;,
 	&quot;vfpd32&quot;,
 	&quot;lpae&quot;,
<span class="p_del">-	&quot;evtstrm&quot;</span>
<span class="p_add">+	&quot;evtstrm&quot;,</span>
<span class="p_add">+	NULL</span>
 };
 
 static const char *const compat_hwcap2_str[] = {
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 648112e90ed5..3972e65fbd5a 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static void inject_abt64(struct kvm_vcpu *vcpu, bool is_iabt, unsigned long addr</span>
 		esr |= (ESR_ELx_EC_IABT_CUR &lt;&lt; ESR_ELx_EC_SHIFT);
 
 	if (!is_iabt)
<span class="p_del">-		esr |= ESR_ELx_EC_DABT_LOW;</span>
<span class="p_add">+		esr |= ESR_ELx_EC_DABT_LOW &lt;&lt; ESR_ELx_EC_SHIFT;</span>
 
 	vcpu_sys_reg(vcpu, ESR_EL1) = esr | ESR_ELx_FSC_EXTABT;
 }
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 92ddac1e8ca2..40f5522245a2 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -81,6 +81,56 @@</span> <span class="p_context"> void show_pte(struct mm_struct *mm, unsigned long addr)</span>
 	printk(&quot;\n&quot;);
 }
 
<span class="p_add">+#ifdef CONFIG_ARM64_HW_AFDBM</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function sets the access flags (dirty, accessed), as well as write</span>
<span class="p_add">+ * permission, and only to a more permissive setting.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It needs to cope with hardware update of the accessed/dirty state by other</span>
<span class="p_add">+ * agents in the system and can safely skip the __sync_icache_dcache() call as,</span>
<span class="p_add">+ * like set_pte_at(), the PTE is never changed from no-exec to exec here.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns whether or not the PTE actually changed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+			  unsigned long address, pte_t *ptep,</span>
<span class="p_add">+			  pte_t entry, int dirty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pteval_t old_pteval;</span>
<span class="p_add">+	unsigned int tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pte_same(*ptep, entry))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only preserve the access flags and write permission */</span>
<span class="p_add">+	pte_val(entry) &amp;= PTE_AF | PTE_WRITE | PTE_DIRTY;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PTE_RDONLY is cleared by default in the asm below, so set it in</span>
<span class="p_add">+	 * back if necessary (read-only or clean PTE).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!pte_write(entry) || !dirty)</span>
<span class="p_add">+		pte_val(entry) |= PTE_RDONLY;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Setting the flags must be done atomically to avoid racing with the</span>
<span class="p_add">+	 * hardware update of the access/dirty state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	asm volatile(&quot;//	ptep_set_access_flags\n&quot;</span>
<span class="p_add">+	&quot;	prfm	pstl1strm, %2\n&quot;</span>
<span class="p_add">+	&quot;1:	ldxr	%0, %2\n&quot;</span>
<span class="p_add">+	&quot;	and	%0, %0, %3		// clear PTE_RDONLY\n&quot;</span>
<span class="p_add">+	&quot;	orr	%0, %0, %4		// set flags\n&quot;</span>
<span class="p_add">+	&quot;	stxr	%w1, %0, %2\n&quot;</span>
<span class="p_add">+	&quot;	cbnz	%w1, 1b\n&quot;</span>
<span class="p_add">+	: &quot;=&amp;r&quot; (old_pteval), &quot;=&amp;r&quot; (tmp), &quot;+Q&quot; (pte_val(*ptep))</span>
<span class="p_add">+	: &quot;L&quot; (~PTE_RDONLY), &quot;r&quot; (pte_val(entry)));</span>
<span class="p_add">+</span>
<span class="p_add">+	flush_tlb_fix_spurious_fault(vma, address);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * The kernel tried to access some page that wasn&#39;t present.
  */
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index 6ded8d347af9..4e956b3e16f5 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -784,7 +784,7 @@</span> <span class="p_context"> extern enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 
 uint32_t kvm_mips_read_count(struct kvm_vcpu *vcpu);
 void kvm_mips_write_count(struct kvm_vcpu *vcpu, uint32_t count);
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare);</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack);</span>
 void kvm_mips_init_count(struct kvm_vcpu *vcpu);
 int kvm_mips_set_count_ctl(struct kvm_vcpu *vcpu, s64 count_ctl);
 int kvm_mips_set_count_resume(struct kvm_vcpu *vcpu, s64 count_resume);
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 41b1b090f56f..dc10c77b7500 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -302,12 +302,31 @@</span> <span class="p_context"> static inline ktime_t kvm_mips_count_time(struct kvm_vcpu *vcpu)</span>
  */
 static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)
 {
<span class="p_del">-	ktime_t expires;</span>
<span class="p_add">+	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;</span>
<span class="p_add">+	ktime_t expires, threshold;</span>
<span class="p_add">+	uint32_t count, compare;</span>
 	int running;
 
<span class="p_del">-	/* Is the hrtimer pending? */</span>
<span class="p_add">+	/* Calculate the biased and scaled guest CP0_Count */</span>
<span class="p_add">+	count = vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find whether CP0_Count has reached the closest timer interrupt. If</span>
<span class="p_add">+	 * not, we shouldn&#39;t inject it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((int32_t)(count - compare) &lt; 0)</span>
<span class="p_add">+		return count;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The CP0_Count we&#39;re going to return has already reached the closest</span>
<span class="p_add">+	 * timer interrupt. Quickly check if it really is a new interrupt by</span>
<span class="p_add">+	 * looking at whether the interval until the hrtimer expiry time is</span>
<span class="p_add">+	 * less than 1/4 of the timer period.</span>
<span class="p_add">+	 */</span>
 	expires = hrtimer_get_expires(&amp;vcpu-&gt;arch.comparecount_timer);
<span class="p_del">-	if (ktime_compare(now, expires) &gt;= 0) {</span>
<span class="p_add">+	threshold = ktime_add_ns(now, vcpu-&gt;arch.count_period / 4);</span>
<span class="p_add">+	if (ktime_before(expires, threshold)) {</span>
 		/*
 		 * Cancel it while we handle it so there&#39;s no chance of
 		 * interference with the timeout handler.
<span class="p_chunk">@@ -329,8 +348,7 @@</span> <span class="p_context"> static uint32_t kvm_mips_read_count_running(struct kvm_vcpu *vcpu, ktime_t now)</span>
 		}
 	}
 
<span class="p_del">-	/* Return the biased and scaled guest CP0_Count */</span>
<span class="p_del">-	return vcpu-&gt;arch.count_bias + kvm_mips_ktime_to_count(vcpu, now);</span>
<span class="p_add">+	return count;</span>
 }
 
 /**
<span class="p_chunk">@@ -420,32 +438,6 @@</span> <span class="p_context"> static void kvm_mips_resume_hrtimer(struct kvm_vcpu *vcpu,</span>
 }
 
 /**
<span class="p_del">- * kvm_mips_update_hrtimer() - Update next expiry time of hrtimer.</span>
<span class="p_del">- * @vcpu:	Virtual CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Recalculates and updates the expiry time of the hrtimer. This can be used</span>
<span class="p_del">- * after timer parameters have been altered which do not depend on the time that</span>
<span class="p_del">- * the change occurs (in those cases kvm_mips_freeze_hrtimer() and</span>
<span class="p_del">- * kvm_mips_resume_hrtimer() are used directly).</span>
<span class="p_del">- *</span>
<span class="p_del">- * It is guaranteed that no timer interrupts will be lost in the process.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Assumes !kvm_mips_count_disabled(@vcpu) (guest CP0_Count timer is running).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void kvm_mips_update_hrtimer(struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ktime_t now;</span>
<span class="p_del">-	uint32_t count;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * freeze_hrtimer takes care of a timer interrupts &lt;= count, and</span>
<span class="p_del">-	 * resume_hrtimer the hrtimer takes care of a timer interrupts &gt; count.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_del">-	kvm_mips_resume_hrtimer(vcpu, now, count);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * kvm_mips_write_count() - Modify the count and update timer.
  * @vcpu:	Virtual CPU.
  * @count:	Guest CP0_Count value to set.
<span class="p_chunk">@@ -540,23 +532,42 @@</span> <span class="p_context"> int kvm_mips_set_count_hz(struct kvm_vcpu *vcpu, s64 count_hz)</span>
  * kvm_mips_write_compare() - Modify compare and update timer.
  * @vcpu:	Virtual CPU.
  * @compare:	New CP0_Compare value.
<span class="p_add">+ * @ack:	Whether to acknowledge timer interrupt.</span>
  *
  * Update CP0_Compare to a new value and update the timeout.
<span class="p_add">+ * If @ack, atomically acknowledge any pending timer interrupt, otherwise ensure</span>
<span class="p_add">+ * any pending timer interrupt is preserved.</span>
  */
<span class="p_del">-void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare)</span>
<span class="p_add">+void kvm_mips_write_compare(struct kvm_vcpu *vcpu, uint32_t compare, bool ack)</span>
 {
 	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;
<span class="p_add">+	int dc;</span>
<span class="p_add">+	u32 old_compare = kvm_read_c0_guest_compare(cop0);</span>
<span class="p_add">+	ktime_t now;</span>
<span class="p_add">+	uint32_t count;</span>
 
 	/* if unchanged, must just be an ack */
<span class="p_del">-	if (kvm_read_c0_guest_compare(cop0) == compare)</span>
<span class="p_add">+	if (old_compare == compare) {</span>
<span class="p_add">+		if (!ack)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
<span class="p_add">+		kvm_write_c0_guest_compare(cop0, compare);</span>
 		return;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* freeze_hrtimer() takes care of timer interrupts &lt;= count */</span>
<span class="p_add">+	dc = kvm_mips_count_disabled(vcpu);</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		now = kvm_mips_freeze_hrtimer(vcpu, &amp;count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack)</span>
<span class="p_add">+		kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 
<span class="p_del">-	/* Update compare */</span>
 	kvm_write_c0_guest_compare(cop0, compare);
 
<span class="p_del">-	/* Update timeout if count enabled */</span>
<span class="p_del">-	if (!kvm_mips_count_disabled(vcpu))</span>
<span class="p_del">-		kvm_mips_update_hrtimer(vcpu);</span>
<span class="p_add">+	/* resume_hrtimer() takes care of timer interrupts &gt; count */</span>
<span class="p_add">+	if (!dc)</span>
<span class="p_add">+		kvm_mips_resume_hrtimer(vcpu, now, count);</span>
 }
 
 /**
<span class="p_chunk">@@ -1095,9 +1106,9 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 
 				/* If we are writing to COMPARE */
 				/* Clear pending timer interrupt, if any */
<span class="p_del">-				kvm_mips_callbacks-&gt;dequeue_timer_int(vcpu);</span>
 				kvm_mips_write_compare(vcpu,
<span class="p_del">-						       vcpu-&gt;arch.gprs[rt]);</span>
<span class="p_add">+						       vcpu-&gt;arch.gprs[rt],</span>
<span class="p_add">+						       true);</span>
 			} else if ((rd == MIPS_CP0_STATUS) &amp;&amp; (sel == 0)) {
 				unsigned int old_val, val, change;
 
<span class="p_header">diff --git a/arch/mips/kvm/trap_emul.c b/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">index d836ed5b0bc7..307cc4c98bdd 100644</span>
<span class="p_header">--- a/arch/mips/kvm/trap_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/trap_emul.c</span>
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static int kvm_trap_emul_set_one_reg(struct kvm_vcpu *vcpu,</span>
 		kvm_mips_write_count(vcpu, v);
 		break;
 	case KVM_REG_MIPS_CP0_COMPARE:
<span class="p_del">-		kvm_mips_write_compare(vcpu, v);</span>
<span class="p_add">+		kvm_mips_write_compare(vcpu, v, false);</span>
 		break;
 	case KVM_REG_MIPS_CP0_CAUSE:
 		/*
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_pt.c b/arch/x86/kernel/cpu/perf_event_intel_pt.c</span>
<span class="p_header">index 868e1194337f..49e35d003b74 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_pt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_pt.c</span>
<span class="p_chunk">@@ -694,6 +694,7 @@</span> <span class="p_context"> static int pt_buffer_reset_markers(struct pt_buffer *buf,</span>
 
 	/* clear STOP and INT from current entry */
 	buf-&gt;topa_index[buf-&gt;stop_pos]-&gt;stop = 0;
<span class="p_add">+	buf-&gt;topa_index[buf-&gt;stop_pos]-&gt;intr = 0;</span>
 	buf-&gt;topa_index[buf-&gt;intr_pos]-&gt;intr = 0;
 
 	/* how many pages till the STOP marker */
<span class="p_chunk">@@ -718,6 +719,7 @@</span> <span class="p_context"> static int pt_buffer_reset_markers(struct pt_buffer *buf,</span>
 	buf-&gt;intr_pos = idx;
 
 	buf-&gt;topa_index[buf-&gt;stop_pos]-&gt;stop = 1;
<span class="p_add">+	buf-&gt;topa_index[buf-&gt;stop_pos]-&gt;intr = 1;</span>
 	buf-&gt;topa_index[buf-&gt;intr_pos]-&gt;intr = 1;
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c</span>
<span class="p_header">index 6525e926f566..2e1fd586b895 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.c</span>
<span class="p_chunk">@@ -509,6 +509,7 @@</span> <span class="p_context"> static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,</span>
 			do_cpuid_1_ent(&amp;entry[i], function, idx);
 			if (idx == 1) {
 				entry[i].eax &amp;= kvm_supported_word10_x86_features;
<span class="p_add">+				cpuid_mask(&amp;entry[i].eax, 10);</span>
 				entry[i].ebx = 0;
 				if (entry[i].eax &amp; (F(XSAVES)|F(XSAVEC)))
 					entry[i].ebx =
<span class="p_header">diff --git a/arch/x86/kvm/mtrr.c b/arch/x86/kvm/mtrr.c</span>
<span class="p_header">index 3f8c732117ec..c146f3c262c3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mtrr.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mtrr.c</span>
<span class="p_chunk">@@ -44,8 +44,6 @@</span> <span class="p_context"> static bool msr_mtrr_valid(unsigned msr)</span>
 	case MSR_MTRRdefType:
 	case MSR_IA32_CR_PAT:
 		return true;
<span class="p_del">-	case 0x2f8:</span>
<span class="p_del">-		return true;</span>
 	}
 	return false;
 }
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index f34ab71dfd57..f314e9b9660b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -4954,8 +4954,8 @@</span> <span class="p_context"> static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)</span>
 		vmcs_write16(VIRTUAL_PROCESSOR_ID, vmx-&gt;vpid);
 
 	cr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;
<span class="p_del">-	vmx_set_cr0(vcpu, cr0); /* enter rmode */</span>
 	vmx-&gt;vcpu.arch.cr0 = cr0;
<span class="p_add">+	vmx_set_cr0(vcpu, cr0); /* enter rmode */</span>
 	vmx_set_cr4(vcpu, 0);
 	vmx_set_efer(vcpu, 0);
 	vmx_fpu_activate(vcpu);
<span class="p_header">diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c</span>
<span class="p_header">index ff31ab464213..c6d6efed392a 100644</span>
<span class="p_header">--- a/arch/x86/pci/xen.c</span>
<span class="p_header">+++ b/arch/x86/pci/xen.c</span>
<span class="p_chunk">@@ -488,8 +488,11 @@</span> <span class="p_context"> int __init pci_xen_initial_domain(void)</span>
 #endif
 	__acpi_register_gsi = acpi_register_gsi_xen;
 	__acpi_unregister_gsi = NULL;
<span class="p_del">-	/* Pre-allocate legacy irqs */</span>
<span class="p_del">-	for (irq = 0; irq &lt; nr_legacy_irqs(); irq++) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pre-allocate the legacy IRQs.  Use NR_LEGACY_IRQS here</span>
<span class="p_add">+	 * because we don&#39;t have a PIC and thus nr_legacy_irqs() is zero.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (irq = 0; irq &lt; NR_IRQS_LEGACY; irq++) {</span>
 		int trigger, polarity;
 
 		if (acpi_get_override_irq(irq, &amp;trigger, &amp;polarity) == -1)
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 32d684af0ec7..a000ecb995e6 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> static struct osi_linux {</span>
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
<span class="p_del">-	unsigned int	default_disabling:1;</span>
<span class="p_add">+	u8		default_disabling;</span>
 } osi_linux = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
<span class="p_chunk">@@ -1444,10 +1444,13 @@</span> <span class="p_context"> void __init acpi_osi_setup(char *str)</span>
 	if (*str == &#39;!&#39;) {
 		str++;
 		if (*str == &#39;\0&#39;) {
<span class="p_del">-			osi_linux.default_disabling = 1;</span>
<span class="p_add">+			/* Do not override acpi_osi=!* */</span>
<span class="p_add">+			if (!osi_linux.default_disabling)</span>
<span class="p_add">+				osi_linux.default_disabling =</span>
<span class="p_add">+					ACPI_DISABLE_ALL_VENDOR_STRINGS;</span>
 			return;
 		} else if (*str == &#39;*&#39;) {
<span class="p_del">-			acpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);</span>
<span class="p_add">+			osi_linux.default_disabling = ACPI_DISABLE_ALL_STRINGS;</span>
 			for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
 				osi = &amp;osi_setup_entries[i];
 				osi-&gt;enable = false;
<span class="p_chunk">@@ -1520,10 +1523,13 @@</span> <span class="p_context"> static void __init acpi_osi_setup_late(void)</span>
 	acpi_status status;
 
 	if (osi_linux.default_disabling) {
<span class="p_del">-		status = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);</span>
<span class="p_add">+		status = acpi_update_interfaces(osi_linux.default_disabling);</span>
 
 		if (ACPI_SUCCESS(status))
<span class="p_del">-			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors\n&quot;);</span>
<span class="p_add">+			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors%s\n&quot;,</span>
<span class="p_add">+				osi_linux.default_disabling ==</span>
<span class="p_add">+				ACPI_DISABLE_ALL_STRINGS ?</span>
<span class="p_add">+				&quot; and feature groups&quot; : &quot;&quot;);</span>
 	}
 
 	for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
<span class="p_header">diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">index ed888e302bc3..597b2d16b775 100644</span>
<span class="p_header">--- a/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">+++ b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> struct vhci_data {</span>
 	wait_queue_head_t read_wait;
 	struct sk_buff_head readq;
 
<span class="p_add">+	struct mutex open_mutex;</span>
 	struct delayed_work open_timeout;
 };
 
<span class="p_chunk">@@ -87,12 +88,15 @@</span> <span class="p_context"> static int vhci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)</span>
 	return 0;
 }
 
<span class="p_del">-static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
<span class="p_add">+static int __vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
 {
 	struct hci_dev *hdev;
 	struct sk_buff *skb;
 	__u8 dev_type;
 
<span class="p_add">+	if (data-&gt;hdev)</span>
<span class="p_add">+		return -EBADFD;</span>
<span class="p_add">+</span>
 	/* bits 0-1 are dev_type (BR/EDR or AMP) */
 	dev_type = opcode &amp; 0x03;
 
<span class="p_chunk">@@ -151,6 +155,17 @@</span> <span class="p_context"> static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
 	return 0;
 }
 
<span class="p_add">+static int vhci_create_device(struct vhci_data *data, __u8 opcode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+	err = __vhci_create_device(data, opcode);</span>
<span class="p_add">+	mutex_unlock(&amp;data-&gt;open_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline ssize_t vhci_get_user(struct vhci_data *data,
 				    struct iov_iter *from)
 {
<span class="p_chunk">@@ -189,11 +204,6 @@</span> <span class="p_context"> static inline ssize_t vhci_get_user(struct vhci_data *data,</span>
 		break;
 
 	case HCI_VENDOR_PKT:
<span class="p_del">-		if (data-&gt;hdev) {</span>
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_del">-			return -EBADFD;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
 		opcode = *((__u8 *) skb-&gt;data);
<span class="p_chunk">@@ -320,6 +330,7 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 	skb_queue_head_init(&amp;data-&gt;readq);
 	init_waitqueue_head(&amp;data-&gt;read_wait);
 
<span class="p_add">+	mutex_init(&amp;data-&gt;open_mutex);</span>
 	INIT_DELAYED_WORK(&amp;data-&gt;open_timeout, vhci_open_timeout);
 
 	file-&gt;private_data = data;
<span class="p_chunk">@@ -333,15 +344,18 @@</span> <span class="p_context"> static int vhci_open(struct inode *inode, struct file *file)</span>
 static int vhci_release(struct inode *inode, struct file *file)
 {
 	struct vhci_data *data = file-&gt;private_data;
<span class="p_del">-	struct hci_dev *hdev = data-&gt;hdev;</span>
<span class="p_add">+	struct hci_dev *hdev;</span>
 
 	cancel_delayed_work_sync(&amp;data-&gt;open_timeout);
 
<span class="p_add">+	hdev = data-&gt;hdev;</span>
<span class="p_add">+</span>
 	if (hdev) {
 		hci_unregister_dev(hdev);
 		hci_free_dev(hdev);
 	}
 
<span class="p_add">+	skb_queue_purge(&amp;data-&gt;readq);</span>
 	file-&gt;private_data = NULL;
 	kfree(data);
 
<span class="p_header">diff --git a/drivers/clk/bcm/clk-bcm2835.c b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">index 4f9830c1b121..185a4d859638 100644</span>
<span class="p_header">--- a/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">+++ b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_chunk">@@ -1068,10 +1068,12 @@</span> <span class="p_context"> static void bcm2835_pll_divider_off(struct clk_hw *hw)</span>
 	struct bcm2835_cprman *cprman = divider-&gt;cprman;
 	const struct bcm2835_pll_divider_data *data = divider-&gt;data;
 
<span class="p_add">+	spin_lock(&amp;cprman-&gt;regs_lock);</span>
 	cprman_write(cprman, data-&gt;cm_reg,
 		     (cprman_read(cprman, data-&gt;cm_reg) &amp;
 		      ~data-&gt;load_mask) | data-&gt;hold_mask);
 	cprman_write(cprman, data-&gt;a2w_reg, A2W_PLL_CHANNEL_DISABLE);
<span class="p_add">+	spin_unlock(&amp;cprman-&gt;regs_lock);</span>
 }
 
 static int bcm2835_pll_divider_on(struct clk_hw *hw)
<span class="p_chunk">@@ -1080,12 +1082,14 @@</span> <span class="p_context"> static int bcm2835_pll_divider_on(struct clk_hw *hw)</span>
 	struct bcm2835_cprman *cprman = divider-&gt;cprman;
 	const struct bcm2835_pll_divider_data *data = divider-&gt;data;
 
<span class="p_add">+	spin_lock(&amp;cprman-&gt;regs_lock);</span>
 	cprman_write(cprman, data-&gt;a2w_reg,
 		     cprman_read(cprman, data-&gt;a2w_reg) &amp;
 		     ~A2W_PLL_CHANNEL_DISABLE);
 
 	cprman_write(cprman, data-&gt;cm_reg,
 		     cprman_read(cprman, data-&gt;cm_reg) &amp; ~data-&gt;hold_mask);
<span class="p_add">+	spin_unlock(&amp;cprman-&gt;regs_lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-msm8916.c b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">index d0a0313d6bef..2e7f03d50f4e 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-msm8916.c</span>
<span class="p_chunk">@@ -2346,6 +2346,7 @@</span> <span class="p_context"> static struct clk_branch gcc_crypto_ahb_clk = {</span>
 				&quot;pcnoc_bfdcd_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_chunk">@@ -2381,6 +2382,7 @@</span> <span class="p_context"> static struct clk_branch gcc_crypto_clk = {</span>
 				&quot;crypto_clk_src&quot;,
 			},
 			.num_parents = 1,
<span class="p_add">+			.flags = CLK_SET_RATE_PARENT,</span>
 			.ops = &amp;clk_branch2_ops,
 		},
 	},
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index f7e0d8d4c3da..8f50a02ff68d 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -248,7 +248,7 @@</span> <span class="p_context"> static void caam_jr_dequeue(unsigned long devarg)</span>
 struct device *caam_jr_alloc(void)
 {
 	struct caam_drv_private_jr *jrpriv, *min_jrpriv = NULL;
<span class="p_del">-	struct device *dev = NULL;</span>
<span class="p_add">+	struct device *dev = ERR_PTR(-ENODEV);</span>
 	int min_tfm_cnt	= INT_MAX;
 	int tfm_cnt;
 
<span class="p_header">diff --git a/drivers/crypto/sunxi-ss/sun4i-ss-cipher.c b/drivers/crypto/sunxi-ss/sun4i-ss-cipher.c</span>
<span class="p_header">index a19ee127edca..e72fea737a0d 100644</span>
<span class="p_header">--- a/drivers/crypto/sunxi-ss/sun4i-ss-cipher.c</span>
<span class="p_header">+++ b/drivers/crypto/sunxi-ss/sun4i-ss-cipher.c</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"> static int sun4i_ss_opti_poll(struct ablkcipher_request *areq)</span>
 	unsigned int todo;
 	struct sg_mapping_iter mi, mo;
 	unsigned int oi, oo; /* offset for in and out */
<span class="p_add">+	unsigned long flags;</span>
 
 	if (areq-&gt;nbytes == 0)
 		return 0;
<span class="p_chunk">@@ -49,7 +50,7 @@</span> <span class="p_context"> static int sun4i_ss_opti_poll(struct ablkcipher_request *areq)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	spin_lock_bh(&amp;ss-&gt;slock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;ss-&gt;slock, flags);</span>
 
 	for (i = 0; i &lt; op-&gt;keylen; i += 4)
 		writel(*(op-&gt;key + i / 4), ss-&gt;base + SS_KEY0 + i);
<span class="p_chunk">@@ -117,7 +118,7 @@</span> <span class="p_context"> release_ss:</span>
 	sg_miter_stop(&amp;mi);
 	sg_miter_stop(&amp;mo);
 	writel(0, ss-&gt;base + SS_CTL);
<span class="p_del">-	spin_unlock_bh(&amp;ss-&gt;slock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;ss-&gt;slock, flags);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -149,6 +150,7 @@</span> <span class="p_context"> static int sun4i_ss_cipher_poll(struct ablkcipher_request *areq)</span>
 	unsigned int ob = 0;	/* offset in buf */
 	unsigned int obo = 0;	/* offset in bufo*/
 	unsigned int obl = 0;	/* length of data in bufo */
<span class="p_add">+	unsigned long flags;</span>
 
 	if (areq-&gt;nbytes == 0)
 		return 0;
<span class="p_chunk">@@ -181,7 +183,7 @@</span> <span class="p_context"> static int sun4i_ss_cipher_poll(struct ablkcipher_request *areq)</span>
 	if (no_chunk == 1)
 		return sun4i_ss_opti_poll(areq);
 
<span class="p_del">-	spin_lock_bh(&amp;ss-&gt;slock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;ss-&gt;slock, flags);</span>
 
 	for (i = 0; i &lt; op-&gt;keylen; i += 4)
 		writel(*(op-&gt;key + i / 4), ss-&gt;base + SS_KEY0 + i);
<span class="p_chunk">@@ -308,7 +310,7 @@</span> <span class="p_context"> release_ss:</span>
 	sg_miter_stop(&amp;mi);
 	sg_miter_stop(&amp;mo);
 	writel(0, ss-&gt;base + SS_CTL);
<span class="p_del">-	spin_unlock_bh(&amp;ss-&gt;slock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;ss-&gt;slock, flags);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index a04fea4d0063..9a8a18aafd5c 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -835,6 +835,16 @@</span> <span class="p_context"> struct talitos_ahash_req_ctx {</span>
 	struct scatterlist *psrc;
 };
 
<span class="p_add">+struct talitos_export_state {</span>
<span class="p_add">+	u32 hw_context[TALITOS_MDEU_MAX_CONTEXT_SIZE / sizeof(u32)];</span>
<span class="p_add">+	u8 buf[HASH_MAX_BLOCK_SIZE];</span>
<span class="p_add">+	unsigned int swinit;</span>
<span class="p_add">+	unsigned int first;</span>
<span class="p_add">+	unsigned int last;</span>
<span class="p_add">+	unsigned int to_hash_later;</span>
<span class="p_add">+	unsigned int nbuf;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int aead_setkey(struct crypto_aead *authenc,
 		       const u8 *key, unsigned int keylen)
 {
<span class="p_chunk">@@ -1954,6 +1964,46 @@</span> <span class="p_context"> static int ahash_digest(struct ahash_request *areq)</span>
 	return ahash_process_req(areq, areq-&gt;nbytes);
 }
 
<span class="p_add">+static int ahash_export(struct ahash_request *areq, void *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);</span>
<span class="p_add">+	struct talitos_export_state *export = out;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(export-&gt;hw_context, req_ctx-&gt;hw_context,</span>
<span class="p_add">+	       req_ctx-&gt;hw_context_size);</span>
<span class="p_add">+	memcpy(export-&gt;buf, req_ctx-&gt;buf, req_ctx-&gt;nbuf);</span>
<span class="p_add">+	export-&gt;swinit = req_ctx-&gt;swinit;</span>
<span class="p_add">+	export-&gt;first = req_ctx-&gt;first;</span>
<span class="p_add">+	export-&gt;last = req_ctx-&gt;last;</span>
<span class="p_add">+	export-&gt;to_hash_later = req_ctx-&gt;to_hash_later;</span>
<span class="p_add">+	export-&gt;nbuf = req_ctx-&gt;nbuf;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ahash_import(struct ahash_request *areq, const void *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct talitos_ahash_req_ctx *req_ctx = ahash_request_ctx(areq);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(areq);</span>
<span class="p_add">+	const struct talitos_export_state *export = in;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(req_ctx, 0, sizeof(*req_ctx));</span>
<span class="p_add">+	req_ctx-&gt;hw_context_size =</span>
<span class="p_add">+		(crypto_ahash_digestsize(tfm) &lt;= SHA256_DIGEST_SIZE)</span>
<span class="p_add">+			? TALITOS_MDEU_CONTEXT_SIZE_MD5_SHA1_SHA256</span>
<span class="p_add">+			: TALITOS_MDEU_CONTEXT_SIZE_SHA384_SHA512;</span>
<span class="p_add">+	memcpy(req_ctx-&gt;hw_context, export-&gt;hw_context,</span>
<span class="p_add">+	       req_ctx-&gt;hw_context_size);</span>
<span class="p_add">+	memcpy(req_ctx-&gt;buf, export-&gt;buf, export-&gt;nbuf);</span>
<span class="p_add">+	req_ctx-&gt;swinit = export-&gt;swinit;</span>
<span class="p_add">+	req_ctx-&gt;first = export-&gt;first;</span>
<span class="p_add">+	req_ctx-&gt;last = export-&gt;last;</span>
<span class="p_add">+	req_ctx-&gt;to_hash_later = export-&gt;to_hash_later;</span>
<span class="p_add">+	req_ctx-&gt;nbuf = export-&gt;nbuf;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct keyhash_result {
 	struct completion completion;
 	int err;
<span class="p_chunk">@@ -2348,6 +2398,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = MD5_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;md5&quot;,
 				.cra_driver_name = &quot;md5-talitos&quot;,
<span class="p_chunk">@@ -2363,6 +2414,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA1_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;sha1&quot;,
 				.cra_driver_name = &quot;sha1-talitos&quot;,
<span class="p_chunk">@@ -2378,6 +2430,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA224_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;sha224&quot;,
 				.cra_driver_name = &quot;sha224-talitos&quot;,
<span class="p_chunk">@@ -2393,6 +2446,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA256_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;sha256&quot;,
 				.cra_driver_name = &quot;sha256-talitos&quot;,
<span class="p_chunk">@@ -2408,6 +2462,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA384_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;sha384&quot;,
 				.cra_driver_name = &quot;sha384-talitos&quot;,
<span class="p_chunk">@@ -2423,6 +2478,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA512_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;sha512&quot;,
 				.cra_driver_name = &quot;sha512-talitos&quot;,
<span class="p_chunk">@@ -2438,6 +2494,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = MD5_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(md5)&quot;,
 				.cra_driver_name = &quot;hmac-md5-talitos&quot;,
<span class="p_chunk">@@ -2453,6 +2510,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA1_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(sha1)&quot;,
 				.cra_driver_name = &quot;hmac-sha1-talitos&quot;,
<span class="p_chunk">@@ -2468,6 +2526,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA224_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(sha224)&quot;,
 				.cra_driver_name = &quot;hmac-sha224-talitos&quot;,
<span class="p_chunk">@@ -2483,6 +2542,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA256_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(sha256)&quot;,
 				.cra_driver_name = &quot;hmac-sha256-talitos&quot;,
<span class="p_chunk">@@ -2498,6 +2558,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA384_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(sha384)&quot;,
 				.cra_driver_name = &quot;hmac-sha384-talitos&quot;,
<span class="p_chunk">@@ -2513,6 +2574,7 @@</span> <span class="p_context"> static struct talitos_alg_template driver_algs[] = {</span>
 	{	.type = CRYPTO_ALG_TYPE_AHASH,
 		.alg.hash = {
 			.halg.digestsize = SHA512_DIGEST_SIZE,
<span class="p_add">+			.halg.statesize = sizeof(struct talitos_export_state),</span>
 			.halg.base = {
 				.cra_name = &quot;hmac(sha512)&quot;,
 				.cra_driver_name = &quot;hmac-sha512-talitos&quot;,
<span class="p_chunk">@@ -2704,6 +2766,8 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		t_alg-&gt;algt.alg.hash.finup = ahash_finup;
 		t_alg-&gt;algt.alg.hash.digest = ahash_digest;
 		t_alg-&gt;algt.alg.hash.setkey = ahash_setkey;
<span class="p_add">+		t_alg-&gt;algt.alg.hash.import = ahash_import;</span>
<span class="p_add">+		t_alg-&gt;algt.alg.hash.export = ahash_export;</span>
 
 		if (!(priv-&gt;features &amp; TALITOS_FTR_HMAC_OK) &amp;&amp;
 		    !strncmp(alg-&gt;cra_name, &quot;hmac&quot;, 4)) {
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 3db9a659719b..5f0f4fc58f43 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -1519,7 +1519,7 @@</span> <span class="p_context"> static int srp_map_idb(struct srp_rdma_ch *ch, struct srp_request *req,</span>
 
 	if (dev-&gt;use_fast_reg) {
 		state.sg = idb_sg;
<span class="p_del">-		sg_set_buf(idb_sg, req-&gt;indirect_desc, idb_len);</span>
<span class="p_add">+		sg_init_one(idb_sg, req-&gt;indirect_desc, idb_len);</span>
 		idb_sg-&gt;dma_address = req-&gt;indirect_dma_addr; /* hack! */
 #ifdef CONFIG_NEED_SG_DMA_LENGTH
 		idb_sg-&gt;dma_length = idb_sg-&gt;length;	      /* hack^2 */
<span class="p_header">diff --git a/drivers/input/misc/pwm-beeper.c b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">index f2261ab54701..18663d4edae5 100644</span>
<span class="p_header">--- a/drivers/input/misc/pwm-beeper.c</span>
<span class="p_header">+++ b/drivers/input/misc/pwm-beeper.c</span>
<span class="p_chunk">@@ -20,21 +20,40 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/pwm.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 
 struct pwm_beeper {
 	struct input_dev *input;
 	struct pwm_device *pwm;
<span class="p_add">+	struct work_struct work;</span>
 	unsigned long period;
 };
 
 #define HZ_TO_NANOSECONDS(x) (1000000000UL/(x))
 
<span class="p_add">+static void __pwm_beeper_set(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long period = beeper-&gt;period;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (period) {</span>
<span class="p_add">+		pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_add">+		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper =</span>
<span class="p_add">+		container_of(work, struct pwm_beeper, work);</span>
<span class="p_add">+</span>
<span class="p_add">+	__pwm_beeper_set(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_event(struct input_dev *input,
 			    unsigned int type, unsigned int code, int value)
 {
<span class="p_del">-	int ret = 0;</span>
 	struct pwm_beeper *beeper = input_get_drvdata(input);
<span class="p_del">-	unsigned long period;</span>
 
 	if (type != EV_SND || value &lt; 0)
 		return -EINVAL;
<span class="p_chunk">@@ -49,22 +68,31 @@</span> <span class="p_context"> static int pwm_beeper_event(struct input_dev *input,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (value == 0) {</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_del">-		ret = pwm_config(beeper-&gt;pwm, period / 2, period);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		ret = pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		beeper-&gt;period = period;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (value == 0)</span>
<span class="p_add">+		beeper-&gt;period = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		beeper-&gt;period = HZ_TO_NANOSECONDS(value);</span>
<span class="p_add">+</span>
<span class="p_add">+	schedule_work(&amp;beeper-&gt;work);</span>
 
 	return 0;
 }
 
<span class="p_add">+static void pwm_beeper_stop(struct pwm_beeper *beeper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cancel_work_sync(&amp;beeper-&gt;work);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pwm_beeper_close(struct input_dev *input)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pwm_beeper *beeper = input_get_drvdata(input);</span>
<span class="p_add">+</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int pwm_beeper_probe(struct platform_device *pdev)
 {
 	unsigned long pwm_id = (unsigned long)dev_get_platdata(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -87,6 +115,8 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 		goto err_free;
 	}
 
<span class="p_add">+	INIT_WORK(&amp;beeper-&gt;work, pwm_beeper_work);</span>
<span class="p_add">+</span>
 	beeper-&gt;input = input_allocate_device();
 	if (!beeper-&gt;input) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to allocate input device\n&quot;);
<span class="p_chunk">@@ -106,6 +136,7 @@</span> <span class="p_context"> static int pwm_beeper_probe(struct platform_device *pdev)</span>
 	beeper-&gt;input-&gt;sndbit[0] = BIT(SND_TONE) | BIT(SND_BELL);
 
 	beeper-&gt;input-&gt;event = pwm_beeper_event;
<span class="p_add">+	beeper-&gt;input-&gt;close = pwm_beeper_close;</span>
 
 	input_set_drvdata(beeper-&gt;input, beeper);
 
<span class="p_chunk">@@ -135,7 +166,6 @@</span> <span class="p_context"> static int pwm_beeper_remove(struct platform_device *pdev)</span>
 
 	input_unregister_device(beeper-&gt;input);
 
<span class="p_del">-	pwm_disable(beeper-&gt;pwm);</span>
 	pwm_free(beeper-&gt;pwm);
 
 	kfree(beeper);
<span class="p_chunk">@@ -147,8 +177,7 @@</span> <span class="p_context"> static int __maybe_unused pwm_beeper_suspend(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period)</span>
<span class="p_del">-		pwm_disable(beeper-&gt;pwm);</span>
<span class="p_add">+	pwm_beeper_stop(beeper);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -157,10 +186,8 @@</span> <span class="p_context"> static int __maybe_unused pwm_beeper_resume(struct device *dev)</span>
 {
 	struct pwm_beeper *beeper = dev_get_drvdata(dev);
 
<span class="p_del">-	if (beeper-&gt;period) {</span>
<span class="p_del">-		pwm_config(beeper-&gt;pwm, beeper-&gt;period / 2, beeper-&gt;period);</span>
<span class="p_del">-		pwm_enable(beeper-&gt;pwm);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (beeper-&gt;period)</span>
<span class="p_add">+		__pwm_beeper_set(beeper);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index d7be6ddc34f6..2fc499a2207e 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -361,6 +361,13 @@</span> <span class="p_context"> static asmlinkage void __exception_irq_entry gic_handle_irq(struct pt_regs *regs</span>
 			if (static_key_true(&amp;supports_deactivate))
 				gic_write_dir(irqnr);
 #ifdef CONFIG_SMP
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Unlike GICv2, we don&#39;t need an smp_rmb() here.</span>
<span class="p_add">+			 * The control dependency from gic_read_iar to</span>
<span class="p_add">+			 * the ISB in gic_write_eoir is enough to ensure</span>
<span class="p_add">+			 * that any shared data read by handle_IPI will</span>
<span class="p_add">+			 * be read after the ACK.</span>
<span class="p_add">+			 */</span>
 			handle_IPI(irqnr, regs);
 #else
 			WARN_ONCE(true, &quot;Unexpected SGI received!\n&quot;);
<span class="p_chunk">@@ -380,6 +387,15 @@</span> <span class="p_context"> static void __init gic_dist_init(void)</span>
 	writel_relaxed(0, base + GICD_CTLR);
 	gic_dist_wait_for_rwp();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Configure SPIs as non-secure Group-1. This will only matter</span>
<span class="p_add">+	 * if the GIC only has a single security state. This will not</span>
<span class="p_add">+	 * do the right thing if the kernel is running in secure mode,</span>
<span class="p_add">+	 * but that&#39;s not the intended use case anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 32; i &lt; gic_data.irq_nr; i += 32)</span>
<span class="p_add">+		writel_relaxed(~0, base + GICD_IGROUPR + i / 8);</span>
<span class="p_add">+</span>
 	gic_dist_config(base, gic_data.irq_nr, gic_dist_wait_for_rwp);
 
 	/* Enable distributor with ARE, Group1 */
<span class="p_chunk">@@ -494,6 +510,9 @@</span> <span class="p_context"> static void gic_cpu_init(void)</span>
 
 	rbase = gic_data_rdist_sgi_base();
 
<span class="p_add">+	/* Configure SGIs/PPIs as non-secure Group-1 */</span>
<span class="p_add">+	writel_relaxed(~0, rbase + GICR_IGROUPR0);</span>
<span class="p_add">+</span>
 	gic_cpu_config(rbase, gic_redist_wait_for_rwp);
 
 	/* Give LPIs a spin */
<span class="p_header">diff --git a/drivers/irqchip/irq-gic.c b/drivers/irqchip/irq-gic.c</span>
<span class="p_header">index abf2ffaed392..cebd8efe651a 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic.c</span>
<span class="p_chunk">@@ -347,6 +347,14 @@</span> <span class="p_context"> static void __exception_irq_entry gic_handle_irq(struct pt_regs *regs)</span>
 			if (static_key_true(&amp;supports_deactivate))
 				writel_relaxed(irqstat, cpu_base + GIC_CPU_DEACTIVATE);
 #ifdef CONFIG_SMP
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Ensure any shared data written by the CPU sending</span>
<span class="p_add">+			 * the IPI is read after we&#39;ve read the ACK register</span>
<span class="p_add">+			 * on the GIC.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * Pairs with the write barrier in gic_raise_softirq</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			smp_rmb();</span>
 			handle_IPI(irqnr, regs);
 #endif
 			continue;
<span class="p_header">diff --git a/drivers/mcb/mcb-parse.c b/drivers/mcb/mcb-parse.c</span>
<span class="p_header">index 004926955263..b0155b05cddb 100644</span>
<span class="p_header">--- a/drivers/mcb/mcb-parse.c</span>
<span class="p_header">+++ b/drivers/mcb/mcb-parse.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> static int chameleon_parse_gdd(struct mcb_bus *bus,</span>
 	mdev-&gt;id = GDD_DEV(reg1);
 	mdev-&gt;rev = GDD_REV(reg1);
 	mdev-&gt;var = GDD_VAR(reg1);
<span class="p_del">-	mdev-&gt;bar = GDD_BAR(reg1);</span>
<span class="p_add">+	mdev-&gt;bar = GDD_BAR(reg2);</span>
 	mdev-&gt;group = GDD_GRP(reg2);
 	mdev-&gt;inst = GDD_INS(reg2);
 
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index b7b3e8ee64f2..c30290f33430 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -269,6 +269,8 @@</span> <span class="p_context"> static int usbtll_omap_probe(struct platform_device *pdev)</span>
 
 		if (IS_ERR(tll-&gt;ch_clk[i]))
 			dev_dbg(dev, &quot;can&#39;t get clock : %s\n&quot;, clkname);
<span class="p_add">+		else</span>
<span class="p_add">+			clk_prepare(tll-&gt;ch_clk[i]);</span>
 	}
 
 	pm_runtime_put_sync(dev);
<span class="p_chunk">@@ -301,9 +303,12 @@</span> <span class="p_context"> static int usbtll_omap_remove(struct platform_device *pdev)</span>
 	tll_dev = NULL;
 	spin_unlock(&amp;tll_lock);
 
<span class="p_del">-	for (i = 0; i &lt; tll-&gt;nch; i++)</span>
<span class="p_del">-		if (!IS_ERR(tll-&gt;ch_clk[i]))</span>
<span class="p_add">+	for (i = 0; i &lt; tll-&gt;nch; i++) {</span>
<span class="p_add">+		if (!IS_ERR(tll-&gt;ch_clk[i])) {</span>
<span class="p_add">+			clk_unprepare(tll-&gt;ch_clk[i]);</span>
 			clk_put(tll-&gt;ch_clk[i]);
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	return 0;
<span class="p_chunk">@@ -420,7 +425,7 @@</span> <span class="p_context"> int omap_tll_enable(struct usbhs_omap_platform_data *pdata)</span>
 			if (IS_ERR(tll-&gt;ch_clk[i]))
 				continue;
 
<span class="p_del">-			r = clk_prepare_enable(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+			r = clk_enable(tll-&gt;ch_clk[i]);</span>
 			if (r) {
 				dev_err(tll_dev,
 				 &quot;Error enabling ch %d clock: %d\n&quot;, i, r);
<span class="p_chunk">@@ -448,7 +453,7 @@</span> <span class="p_context"> int omap_tll_disable(struct usbhs_omap_platform_data *pdata)</span>
 	for (i = 0; i &lt; tll-&gt;nch; i++) {
 		if (omap_usb_mode_needs_tll(pdata-&gt;port_mode[i])) {
 			if (!IS_ERR(tll-&gt;ch_clk[i]))
<span class="p_del">-				clk_disable_unprepare(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+				clk_disable(tll-&gt;ch_clk[i]);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c</span>
<span class="p_header">index cd0403f09267..e79c0371ee6f 100644</span>
<span class="p_header">--- a/drivers/misc/mei/amthif.c</span>
<span class="p_header">+++ b/drivers/misc/mei/amthif.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> int mei_amthif_irq_read_msg(struct mei_cl *cl,</span>
 
 	dev = cl-&gt;dev;
 
<span class="p_del">-	if (dev-&gt;iamthif_state != MEI_IAMTHIF_READING)</span>
<span class="p_add">+	if (dev-&gt;iamthif_state != MEI_IAMTHIF_READING) {</span>
<span class="p_add">+		mei_irq_discard_msg(dev, mei_hdr);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	ret = mei_cl_irq_read_msg(cl, mei_hdr, cmpl_list);
 	if (ret)
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index 1a173d0af694..a77643954523 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -222,17 +222,23 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(mei_cldev_recv);</span>
 static void mei_cl_bus_event_work(struct work_struct *work)
 {
 	struct mei_cl_device *cldev;
<span class="p_add">+	struct mei_device *bus;</span>
 
 	cldev = container_of(work, struct mei_cl_device, event_work);
 
<span class="p_add">+	bus = cldev-&gt;bus;</span>
<span class="p_add">+</span>
 	if (cldev-&gt;event_cb)
 		cldev-&gt;event_cb(cldev, cldev-&gt;events, cldev-&gt;event_context);
 
 	cldev-&gt;events = 0;
 
 	/* Prepare for the next read */
<span class="p_del">-	if (cldev-&gt;events_mask &amp; BIT(MEI_CL_EVENT_RX))</span>
<span class="p_add">+	if (cldev-&gt;events_mask &amp; BIT(MEI_CL_EVENT_RX)) {</span>
<span class="p_add">+		mutex_lock(&amp;bus-&gt;device_lock);</span>
 		mei_cl_read_start(cldev-&gt;cl, 0, NULL);
<span class="p_add">+		mutex_unlock(&amp;bus-&gt;device_lock);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -296,6 +302,7 @@</span> <span class="p_context"> int mei_cldev_register_event_cb(struct mei_cl_device *cldev,</span>
 				unsigned long events_mask,
 				mei_cldev_event_cb_t event_cb, void *context)
 {
<span class="p_add">+	struct mei_device *bus = cldev-&gt;bus;</span>
 	int ret;
 
 	if (cldev-&gt;event_cb)
<span class="p_chunk">@@ -308,15 +315,17 @@</span> <span class="p_context"> int mei_cldev_register_event_cb(struct mei_cl_device *cldev,</span>
 	INIT_WORK(&amp;cldev-&gt;event_work, mei_cl_bus_event_work);
 
 	if (cldev-&gt;events_mask &amp; BIT(MEI_CL_EVENT_RX)) {
<span class="p_add">+		mutex_lock(&amp;bus-&gt;device_lock);</span>
 		ret = mei_cl_read_start(cldev-&gt;cl, 0, NULL);
<span class="p_add">+		mutex_unlock(&amp;bus-&gt;device_lock);</span>
 		if (ret &amp;&amp; ret != -EBUSY)
 			return ret;
 	}
 
 	if (cldev-&gt;events_mask &amp; BIT(MEI_CL_EVENT_NOTIF)) {
<span class="p_del">-		mutex_lock(&amp;cldev-&gt;cl-&gt;dev-&gt;device_lock);</span>
<span class="p_add">+		mutex_lock(&amp;bus-&gt;device_lock);</span>
 		ret = mei_cl_notify_request(cldev-&gt;cl, NULL, event_cb ? 1 : 0);
<span class="p_del">-		mutex_unlock(&amp;cldev-&gt;cl-&gt;dev-&gt;device_lock);</span>
<span class="p_add">+		mutex_unlock(&amp;bus-&gt;device_lock);</span>
 		if (ret)
 			return ret;
 	}
<span class="p_header">diff --git a/drivers/misc/mei/client.c b/drivers/misc/mei/client.c</span>
<span class="p_header">index a6c87c713193..958af84884b5 100644</span>
<span class="p_header">--- a/drivers/misc/mei/client.c</span>
<span class="p_header">+++ b/drivers/misc/mei/client.c</span>
<span class="p_chunk">@@ -1735,6 +1735,10 @@</span> <span class="p_context"> void mei_cl_complete(struct mei_cl *cl, struct mei_cl_cb *cb)</span>
 			wake_up(&amp;cl-&gt;wait);
 
 		break;
<span class="p_add">+	case MEI_FOP_DISCONNECT_RSP:</span>
<span class="p_add">+		mei_io_cb_free(cb);</span>
<span class="p_add">+		mei_cl_set_disconnected(cl);</span>
<span class="p_add">+		break;</span>
 	default:
 		BUG_ON(0);
 	}
<span class="p_header">diff --git a/drivers/misc/mei/hbm.c b/drivers/misc/mei/hbm.c</span>
<span class="p_header">index e7b7aad0999b..fd8a9f057ea6 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hbm.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hbm.c</span>
<span class="p_chunk">@@ -873,8 +873,7 @@</span> <span class="p_context"> static int mei_hbm_fw_disconnect_req(struct mei_device *dev,</span>
 		cb = mei_io_cb_init(cl, MEI_FOP_DISCONNECT_RSP, NULL);
 		if (!cb)
 			return -ENOMEM;
<span class="p_del">-		cl_dbg(dev, cl, &quot;add disconnect response as first\n&quot;);</span>
<span class="p_del">-		list_add(&amp;cb-&gt;list, &amp;dev-&gt;ctrl_wr_list.list);</span>
<span class="p_add">+		list_add_tail(&amp;cb-&gt;list, &amp;dev-&gt;ctrl_wr_list.list);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c</span>
<span class="p_header">index 64b568a0268d..d1df797c7568 100644</span>
<span class="p_header">--- a/drivers/misc/mei/interrupt.c</span>
<span class="p_header">+++ b/drivers/misc/mei/interrupt.c</span>
<span class="p_chunk">@@ -76,7 +76,6 @@</span> <span class="p_context"> static inline int mei_cl_hbm_equal(struct mei_cl *cl,</span>
  * @dev: mei device
  * @hdr: message header
  */
<span class="p_del">-static inline</span>
 void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr)
 {
 	/*
<span class="p_chunk">@@ -184,10 +183,7 @@</span> <span class="p_context"> static int mei_cl_irq_disconnect_rsp(struct mei_cl *cl, struct mei_cl_cb *cb,</span>
 		return -EMSGSIZE;
 
 	ret = mei_hbm_cl_disconnect_rsp(dev, cl);
<span class="p_del">-	mei_cl_set_disconnected(cl);</span>
<span class="p_del">-	mei_io_cb_free(cb);</span>
<span class="p_del">-	mei_me_cl_put(cl-&gt;me_cl);</span>
<span class="p_del">-	cl-&gt;me_cl = NULL;</span>
<span class="p_add">+	list_move_tail(&amp;cb-&gt;list, &amp;cmpl_list-&gt;list);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">index 4250555d5e72..1b06e2fd6858 100644</span>
<span class="p_header">--- a/drivers/misc/mei/mei_dev.h</span>
<span class="p_header">+++ b/drivers/misc/mei/mei_dev.h</span>
<span class="p_chunk">@@ -782,6 +782,8 @@</span> <span class="p_context"> bool mei_hbuf_acquire(struct mei_device *dev);</span>
 
 bool mei_write_is_idle(struct mei_device *dev);
 
<span class="p_add">+void mei_irq_discard_msg(struct mei_device *dev, struct mei_msg_hdr *hdr);</span>
<span class="p_add">+</span>
 #if IS_ENABLED(CONFIG_DEBUG_FS)
 int mei_dbgfs_register(struct mei_device *dev, const char *name);
 void mei_dbgfs_deregister(struct mei_device *dev);
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 553113eb1bdb..c641c202fe7e 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -2514,11 +2514,12 @@</span> <span class="p_context"> static const struct mmc_fixup blk_fixups[] =</span>
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
<span class="p_del">-	 * Some Micron MMC cards needs longer data read timeout than</span>
<span class="p_del">-	 * indicated in CSD.</span>
<span class="p_add">+	 * Some MMC cards need longer data read timeout than indicated in CSD.</span>
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
<span class="p_add">+	MMC_FIXUP(&quot;008GE0&quot;, CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,</span>
<span class="p_add">+		  MMC_QUIRK_LONG_READ_TIME),</span>
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 5ae89e48fd85..5f7d10ba498a 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -874,11 +874,11 @@</span> <span class="p_context"> void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)</span>
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a &quot;reasonably high&quot;
<span class="p_del">-	 * value. For the cards tested, 300ms has proven enough. If necessary,</span>
<span class="p_add">+	 * value. For the cards tested, 600ms has proven enough. If necessary,</span>
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) &amp;&amp; data-&gt;flags &amp; MMC_DATA_READ) {
<span class="p_del">-		data-&gt;timeout_ns = 300000000;</span>
<span class="p_add">+		data-&gt;timeout_ns = 600000000;</span>
 		data-&gt;timeout_clks = 0;
 	}
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 3d5087b03999..78187699467a 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -333,6 +333,9 @@</span> <span class="p_context"> static void mmc_manage_gp_partitions(struct mmc_card *card, u8 *ext_csd)</span>
 	}
 }
 
<span class="p_add">+/* Minimum partition switch timeout in milliseconds */</span>
<span class="p_add">+#define MMC_MIN_PART_SWITCH_TIME	300</span>
<span class="p_add">+</span>
 /*
  * Decode extended CSD.
  */
<span class="p_chunk">@@ -397,6 +400,10 @@</span> <span class="p_context"> static int mmc_decode_ext_csd(struct mmc_card *card, u8 *ext_csd)</span>
 
 		/* EXT_CSD value is in units of 10ms, but we store in ms */
 		card-&gt;ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
<span class="p_add">+		/* Some eMMC set the value too low so set a minimum */</span>
<span class="p_add">+		if (card-&gt;ext_csd.part_time &amp;&amp;</span>
<span class="p_add">+		    card-&gt;ext_csd.part_time &lt; MMC_MIN_PART_SWITCH_TIME)</span>
<span class="p_add">+			card-&gt;ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;</span>
 
 		/* Sleep / awake timeout in 100ns units */
 		if (sa_shift &gt; 0 &amp;&amp; sa_shift &lt;= 0x17)
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index a5cda926d38e..8aea3fa6938b 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {</span>
 	.chip    = &amp;sdhci_acpi_chip_int,
 	.caps    = MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 		   MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
<span class="p_del">-		   MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+		   MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.caps2   = MMC_CAP2_HC_ERASE_SZ,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
<span class="p_chunk">@@ -248,7 +248,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {</span>
 		   SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
 	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD |
<span class="p_del">-		   MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+		   MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.pm_caps = MMC_PM_KEEP_POWER,
 	.probe_slot	= sdhci_acpi_sdio_probe_slot,
<span class="p_chunk">@@ -260,7 +260,7 @@</span> <span class="p_context"> static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sd = {</span>
 	.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,
 	.quirks2 = SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON |
 		   SDHCI_QUIRK2_STOP_WITH_TC,
<span class="p_del">-	.caps    = MMC_CAP_BUS_WIDTH_TEST | MMC_CAP_WAIT_WHILE_BUSY,</span>
<span class="p_add">+	.caps    = MMC_CAP_WAIT_WHILE_BUSY,</span>
 	.probe_slot	= sdhci_acpi_sd_probe_slot,
 };
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">index 610154836d79..5ebe6eb6b89e 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_chunk">@@ -361,7 +361,6 @@</span> <span class="p_context"> static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
 {
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 				 MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
<span class="p_del">-				 MMC_CAP_BUS_WIDTH_TEST |</span>
 				 MMC_CAP_WAIT_WHILE_BUSY;
 	slot-&gt;host-&gt;mmc-&gt;caps2 |= MMC_CAP2_HC_ERASE_SZ;
 	slot-&gt;hw_reset = sdhci_pci_int_hw_reset;
<span class="p_chunk">@@ -377,15 +376,13 @@</span> <span class="p_context"> static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
 static int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)
 {
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |
<span class="p_del">-				 MMC_CAP_BUS_WIDTH_TEST |</span>
 				 MMC_CAP_WAIT_WHILE_BUSY;
 	return 0;
 }
 
 static int byt_sd_probe_slot(struct sdhci_pci_slot *slot)
 {
<span class="p_del">-	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_BUS_WIDTH_TEST |</span>
<span class="p_del">-				 MMC_CAP_WAIT_WHILE_BUSY;</span>
<span class="p_add">+	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_WAIT_WHILE_BUSY;</span>
 	slot-&gt;cd_con_id = NULL;
 	slot-&gt;cd_idx = 0;
 	slot-&gt;cd_override_level = true;
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 5b9834cf2820..96fddb016bf1 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -426,8 +426,25 @@</span> <span class="p_context"> retry:</span>
 						 pnum, vol_id, lnum);
 					err = -EBADMSG;
 				} else {
<span class="p_del">-					err = -EINVAL;</span>
<span class="p_del">-					ubi_ro_mode(ubi);</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * Ending up here in the non-Fastmap case</span>
<span class="p_add">+					 * is a clear bug as the VID header had to</span>
<span class="p_add">+					 * be present at scan time to have it referenced.</span>
<span class="p_add">+					 * With fastmap the story is more complicated.</span>
<span class="p_add">+					 * Fastmap has the mapping info without the need</span>
<span class="p_add">+					 * of a full scan. So the LEB could have been</span>
<span class="p_add">+					 * unmapped, Fastmap cannot know this and keeps</span>
<span class="p_add">+					 * the LEB referenced.</span>
<span class="p_add">+					 * This is valid and works as the layer above UBI</span>
<span class="p_add">+					 * has to do bookkeeping about used/referenced</span>
<span class="p_add">+					 * LEBs in any case.</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					if (ubi-&gt;fast_attach) {</span>
<span class="p_add">+						err = -EBADMSG;</span>
<span class="p_add">+					} else {</span>
<span class="p_add">+						err = -EINVAL;</span>
<span class="p_add">+						ubi_ro_mode(ubi);</span>
<span class="p_add">+					}</span>
 				}
 			}
 			goto out_free;
<span class="p_header">diff --git a/drivers/mtd/ubi/fastmap.c b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">index 263b439e21a8..990898b9dc72 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_chunk">@@ -1058,6 +1058,7 @@</span> <span class="p_context"> int ubi_scan_fastmap(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 	ubi_msg(ubi, &quot;fastmap WL pool size: %d&quot;,
 		ubi-&gt;fm_wl_pool.max_size);
 	ubi-&gt;fm_disabled = 0;
<span class="p_add">+	ubi-&gt;fast_attach = 1;</span>
 
 	ubi_free_vid_hdr(ubi, vh);
 	kfree(ech);
<span class="p_header">diff --git a/drivers/mtd/ubi/ubi.h b/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">index 2974b67f6c6c..de1ea2e4c37d 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/ubi.h</span>
<span class="p_header">+++ b/drivers/mtd/ubi/ubi.h</span>
<span class="p_chunk">@@ -462,6 +462,7 @@</span> <span class="p_context"> struct ubi_debug_info {</span>
  * @fm_eba_sem: allows ubi_update_fastmap() to block EBA table changes
  * @fm_work: fastmap work queue
  * @fm_work_scheduled: non-zero if fastmap work was scheduled
<span class="p_add">+ * @fast_attach: non-zero if UBI was attached by fastmap</span>
  *
  * @used: RB-tree of used physical eraseblocks
  * @erroneous: RB-tree of erroneous used physical eraseblocks
<span class="p_chunk">@@ -570,6 +571,7 @@</span> <span class="p_context"> struct ubi_device {</span>
 	size_t fm_size;
 	struct work_struct fm_work;
 	int fm_work_scheduled;
<span class="p_add">+	int fast_attach;</span>
 
 	/* Wear-leveling sub-system&#39;s stuff */
 	struct rb_root used;
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index 141c2a42d7ed..910c12e2638e 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -696,11 +696,17 @@</span> <span class="p_context"> int can_change_mtu(struct net_device *dev, int new_mtu)</span>
 	/* allow change of MTU according to the CANFD ability of the device */
 	switch (new_mtu) {
 	case CAN_MTU:
<span class="p_add">+		/* &#39;CANFD-only&#39; controllers can not switch to CAN_MTU */</span>
<span class="p_add">+		if (priv-&gt;ctrlmode_static &amp; CAN_CTRLMODE_FD)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		priv-&gt;ctrlmode &amp;= ~CAN_CTRLMODE_FD;
 		break;
 
 	case CANFD_MTU:
<span class="p_del">-		if (!(priv-&gt;ctrlmode_supported &amp; CAN_CTRLMODE_FD))</span>
<span class="p_add">+		/* check for potential CANFD ability */</span>
<span class="p_add">+		if (!(priv-&gt;ctrlmode_supported &amp; CAN_CTRLMODE_FD) &amp;&amp;</span>
<span class="p_add">+		    !(priv-&gt;ctrlmode_static &amp; CAN_CTRLMODE_FD))</span>
 			return -EINVAL;
 
 		priv-&gt;ctrlmode |= CAN_CTRLMODE_FD;
<span class="p_chunk">@@ -782,6 +788,35 @@</span> <span class="p_context"> static const struct nla_policy can_policy[IFLA_CAN_MAX + 1] = {</span>
 				= { .len = sizeof(struct can_bittiming_const) },
 };
 
<span class="p_add">+static int can_validate(struct nlattr *tb[], struct nlattr *data[])</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool is_can_fd = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make sure that valid CAN FD configurations always consist of</span>
<span class="p_add">+	 * - nominal/arbitration bittiming</span>
<span class="p_add">+	 * - data bittiming</span>
<span class="p_add">+	 * - control mode with CAN_CTRLMODE_FD set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data[IFLA_CAN_CTRLMODE]) {</span>
<span class="p_add">+		struct can_ctrlmode *cm = nla_data(data[IFLA_CAN_CTRLMODE]);</span>
<span class="p_add">+</span>
<span class="p_add">+		is_can_fd = cm-&gt;flags &amp; cm-&gt;mask &amp; CAN_CTRLMODE_FD;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_can_fd) {</span>
<span class="p_add">+		if (!data[IFLA_CAN_BITTIMING] || !data[IFLA_CAN_DATA_BITTIMING])</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data[IFLA_CAN_DATA_BITTIMING]) {</span>
<span class="p_add">+		if (!is_can_fd || !data[IFLA_CAN_BITTIMING])</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int can_changelink(struct net_device *dev,
 			  struct nlattr *tb[], struct nlattr *data[])
 {
<span class="p_chunk">@@ -813,19 +848,31 @@</span> <span class="p_context"> static int can_changelink(struct net_device *dev,</span>
 
 	if (data[IFLA_CAN_CTRLMODE]) {
 		struct can_ctrlmode *cm;
<span class="p_add">+		u32 ctrlstatic;</span>
<span class="p_add">+		u32 maskedflags;</span>
 
 		/* Do not allow changing controller mode while running */
 		if (dev-&gt;flags &amp; IFF_UP)
 			return -EBUSY;
 		cm = nla_data(data[IFLA_CAN_CTRLMODE]);
<span class="p_add">+		ctrlstatic = priv-&gt;ctrlmode_static;</span>
<span class="p_add">+		maskedflags = cm-&gt;flags &amp; cm-&gt;mask;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* check whether provided bits are allowed to be passed */</span>
<span class="p_add">+		if (cm-&gt;mask &amp; ~(priv-&gt;ctrlmode_supported | ctrlstatic))</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* do not check for static fd-non-iso if &#39;fd&#39; is disabled */</span>
<span class="p_add">+		if (!(maskedflags &amp; CAN_CTRLMODE_FD))</span>
<span class="p_add">+			ctrlstatic &amp;= ~CAN_CTRLMODE_FD_NON_ISO;</span>
 
<span class="p_del">-		/* check whether changed bits are allowed to be modified */</span>
<span class="p_del">-		if (cm-&gt;mask &amp; ~priv-&gt;ctrlmode_supported)</span>
<span class="p_add">+		/* make sure static options are provided by configuration */</span>
<span class="p_add">+		if ((maskedflags &amp; ctrlstatic) != ctrlstatic)</span>
 			return -EOPNOTSUPP;
 
 		/* clear bits to be modified and copy the flag values */
 		priv-&gt;ctrlmode &amp;= ~cm-&gt;mask;
<span class="p_del">-		priv-&gt;ctrlmode |= (cm-&gt;flags &amp; cm-&gt;mask);</span>
<span class="p_add">+		priv-&gt;ctrlmode |= maskedflags;</span>
 
 		/* CAN_CTRLMODE_FD can only be set when driver supports FD */
 		if (priv-&gt;ctrlmode &amp; CAN_CTRLMODE_FD)
<span class="p_chunk">@@ -966,6 +1013,7 @@</span> <span class="p_context"> static struct rtnl_link_ops can_link_ops __read_mostly = {</span>
 	.maxtype	= IFLA_CAN_MAX,
 	.policy		= can_policy,
 	.setup		= can_setup,
<span class="p_add">+	.validate	= can_validate,</span>
 	.newlink	= can_newlink,
 	.changelink	= can_changelink,
 	.get_size	= can_get_size,
<span class="p_header">diff --git a/drivers/net/can/m_can/m_can.c b/drivers/net/can/m_can/m_can.c</span>
<span class="p_header">index 39cf911f7a1e..195f15edb32e 100644</span>
<span class="p_header">--- a/drivers/net/can/m_can/m_can.c</span>
<span class="p_header">+++ b/drivers/net/can/m_can/m_can.c</span>
<span class="p_chunk">@@ -955,7 +955,7 @@</span> <span class="p_context"> static struct net_device *alloc_m_can_dev(void)</span>
 	priv-&gt;can.do_get_berr_counter = m_can_get_berr_counter;
 
 	/* CAN_CTRLMODE_FD_NON_ISO is fixed with M_CAN IP v3.0.1 */
<span class="p_del">-	priv-&gt;can.ctrlmode = CAN_CTRLMODE_FD_NON_ISO;</span>
<span class="p_add">+	can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);</span>
 
 	/* CAN_CTRLMODE_FD_NON_ISO can not be changed with M_CAN IP v3.0.1 */
 	priv-&gt;can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |
<span class="p_header">diff --git a/drivers/net/usb/asix_common.c b/drivers/net/usb/asix_common.c</span>
<span class="p_header">index bd9acff1eb7b..7fbd8f044207 100644</span>
<span class="p_header">--- a/drivers/net/usb/asix_common.c</span>
<span class="p_header">+++ b/drivers/net/usb/asix_common.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> int asix_rx_fixup_internal(struct usbnet *dev, struct sk_buff *skb,</span>
 	 * buffer.
 	 */
 	if (rx-&gt;remaining &amp;&amp; (rx-&gt;remaining + sizeof(u32) &lt;= skb-&gt;len)) {
<span class="p_del">-		offset = ((rx-&gt;remaining + 1) &amp; 0xfffe) + sizeof(u32);</span>
<span class="p_add">+		offset = ((rx-&gt;remaining + 1) &amp; 0xfffe);</span>
 		rx-&gt;header = get_unaligned_le32(skb-&gt;data + offset);
 		offset = 0;
 
<span class="p_header">diff --git a/drivers/platform/x86/dell-rbtn.c b/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_header">index cd410e392550..d33e9ad3218f 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-rbtn.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> struct rbtn_data {</span>
 	enum rbtn_type type;
 	struct rfkill *rfkill;
 	struct input_dev *input_dev;
<span class="p_add">+	bool suspended;</span>
 };
 
 
<span class="p_chunk">@@ -220,9 +221,55 @@</span> <span class="p_context"> static const struct acpi_device_id rbtn_ids[] = {</span>
 	{ &quot;&quot;, 0 },
 };
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+static void ACPI_SYSTEM_XFACE rbtn_clear_suspended_flag(void *context)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = context;</span>
<span class="p_add">+</span>
<span class="p_add">+	rbtn_data-&gt;suspended = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rbtn_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_device *device = to_acpi_device(dev);</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = acpi_driver_data(device);</span>
<span class="p_add">+</span>
<span class="p_add">+	rbtn_data-&gt;suspended = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rbtn_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_device *device = to_acpi_device(dev);</span>
<span class="p_add">+	struct rbtn_data *rbtn_data = acpi_driver_data(device);</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Upon resume, some BIOSes send an ACPI notification thet triggers</span>
<span class="p_add">+	 * an unwanted input event. In order to ignore it, we use a flag</span>
<span class="p_add">+	 * that we set at suspend and clear once we have received the extra</span>
<span class="p_add">+	 * ACPI notification. Since ACPI notifications are delivered</span>
<span class="p_add">+	 * asynchronously to drivers, we clear the flag from the workqueue</span>
<span class="p_add">+	 * used to deliver the notifications. This should be enough</span>
<span class="p_add">+	 * to have the flag cleared only after we received the extra</span>
<span class="p_add">+	 * notification, if any.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	status = acpi_os_execute(OSL_NOTIFY_HANDLER,</span>
<span class="p_add">+			 rbtn_clear_suspended_flag, rbtn_data);</span>
<span class="p_add">+	if (ACPI_FAILURE(status))</span>
<span class="p_add">+		rbtn_clear_suspended_flag(rbtn_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(rbtn_pm_ops, rbtn_suspend, rbtn_resume);</span>
<span class="p_add">+</span>
 static struct acpi_driver rbtn_driver = {
 	.name = &quot;dell-rbtn&quot;,
 	.ids = rbtn_ids,
<span class="p_add">+	.drv.pm = &amp;rbtn_pm_ops,</span>
 	.ops = {
 		.add = rbtn_add,
 		.remove = rbtn_remove,
<span class="p_chunk">@@ -384,6 +431,15 @@</span> <span class="p_context"> static void rbtn_notify(struct acpi_device *device, u32 event)</span>
 {
 	struct rbtn_data *rbtn_data = device-&gt;driver_data;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some BIOSes send a notification at resume.</span>
<span class="p_add">+	 * Ignore it to prevent unwanted input events.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rbtn_data-&gt;suspended) {</span>
<span class="p_add">+		dev_dbg(&amp;device-&gt;dev, &quot;ACPI notification ignored\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (event != 0x80) {
 		dev_info(&amp;device-&gt;dev, &quot;Received unknown event (0x%x)\n&quot;,
 			 event);
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 054923e3393c..f0cfaacbfabd 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -314,6 +314,7 @@</span> <span class="p_context"> static void scsi_target_destroy(struct scsi_target *starget)</span>
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
 	unsigned long flags;
 
<span class="p_add">+	BUG_ON(starget-&gt;state == STARGET_DEL);</span>
 	starget-&gt;state = STARGET_DEL;
 	transport_destroy_device(dev);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index c8115b4fe474..f7ae898833dd 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1192,18 +1192,18 @@</span> <span class="p_context"> static void __scsi_remove_target(struct scsi_target *starget)</span>
 void scsi_remove_target(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
<span class="p_del">-	struct scsi_target *starget, *last_target = NULL;</span>
<span class="p_add">+	struct scsi_target *starget;</span>
 	unsigned long flags;
 
 restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_for_each_entry(starget, &amp;shost-&gt;__targets, siblings) {
 		if (starget-&gt;state == STARGET_DEL ||
<span class="p_del">-		    starget == last_target)</span>
<span class="p_add">+		    starget-&gt;state == STARGET_REMOVE)</span>
 			continue;
 		if (starget-&gt;dev.parent == dev || &amp;starget-&gt;dev == dev) {
 			kref_get(&amp;starget-&gt;reap_ref);
<span class="p_del">-			last_target = starget;</span>
<span class="p_add">+			starget-&gt;state = STARGET_REMOVE;</span>
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 			__scsi_remove_target(starget);
 			scsi_target_reap(starget);
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_header">index 940781183fac..3be10963f98b 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/das1800.c</span>
<span class="p_chunk">@@ -567,14 +567,17 @@</span> <span class="p_context"> static int das1800_cancel(struct comedi_device *dev, struct comedi_subdevice *s)</span>
 	struct comedi_isadma_desc *desc;
 	int i;
 
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_STATUS);	/* disable conversions */</span>
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_B);	/* disable interrupts and dma */</span>
<span class="p_del">-	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_A);	/* disable and clear fifo and stop triggering */</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_del">-		desc = &amp;dma-&gt;desc[i];</span>
<span class="p_del">-		if (desc-&gt;chan)</span>
<span class="p_del">-			comedi_isadma_disable(desc-&gt;chan);</span>
<span class="p_add">+	/* disable and stop conversions */</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_STATUS);</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_B);</span>
<span class="p_add">+	outb(0x0, dev-&gt;iobase + DAS1800_CONTROL_A);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dma) {</span>
<span class="p_add">+		for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+			desc = &amp;dma-&gt;desc[i];</span>
<span class="p_add">+			if (desc-&gt;chan)</span>
<span class="p_add">+				comedi_isadma_disable(desc-&gt;chan);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -934,13 +937,14 @@</span> <span class="p_context"> static void das1800_ai_setup_dma(struct comedi_device *dev,</span>
 {
 	struct das1800_private *devpriv = dev-&gt;private;
 	struct comedi_isadma *dma = devpriv-&gt;dma;
<span class="p_del">-	struct comedi_isadma_desc *desc = &amp;dma-&gt;desc[0];</span>
<span class="p_add">+	struct comedi_isadma_desc *desc;</span>
 	unsigned int bytes;
 
 	if ((devpriv-&gt;irq_dma_bits &amp; DMA_ENABLED) == 0)
 		return;
 
 	dma-&gt;cur_dma = 0;
<span class="p_add">+	desc = &amp;dma-&gt;desc[0];</span>
 
 	/* determine a dma transfer size to fill buffer in 0.3 sec */
 	bytes = das1800_ai_transfer_size(dev, s, desc-&gt;maxsize, 300000000);
<span class="p_header">diff --git a/drivers/thunderbolt/eeprom.c b/drivers/thunderbolt/eeprom.c</span>
<span class="p_header">index 0dde34e3a7c5..545c60c826a1 100644</span>
<span class="p_header">--- a/drivers/thunderbolt/eeprom.c</span>
<span class="p_header">+++ b/drivers/thunderbolt/eeprom.c</span>
<span class="p_chunk">@@ -444,6 +444,7 @@</span> <span class="p_context"> int tb_drom_read(struct tb_switch *sw)</span>
 	return tb_drom_parse_entries(sw);
 err:
 	kfree(sw-&gt;drom);
<span class="p_add">+	sw-&gt;drom = NULL;</span>
 	return -EIO;
 
 }
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index c3fe026d3168..9aff37186246 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -2045,7 +2045,9 @@</span> <span class="p_context"> static void gsm_cleanup_mux(struct gsm_mux *gsm)</span>
 		}
 	}
 	spin_unlock(&amp;gsm_mux_lock);
<span class="p_del">-	WARN_ON(i == MAX_MUX);</span>
<span class="p_add">+	/* open failed before registering =&gt; nothing to do */</span>
<span class="p_add">+	if (i == MAX_MUX)</span>
<span class="p_add">+		return;</span>
 
 	/* In theory disconnecting DLCI 0 is sufficient but for some
 	   modems this is apparently not the case. */
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index bbc4ce66c2c1..644ddb841d9f 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,</span>
 	add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);
 
 	for (;;) {
<span class="p_del">-		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		/* set bits for operations that won&#39;t block */
 		if (n_hdlc-&gt;rx_buf_list.head)
 			mask |= POLLIN | POLLRDNORM;	/* readable */
<span class="p_del">-		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags))</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index cf000b331eed..84e71bd19082 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1955,18 +1955,6 @@</span> <span class="p_context"> static inline int input_available_p(struct tty_struct *tty, int poll)</span>
 		return ldata-&gt;commit_head - ldata-&gt;read_tail &gt;= amt;
 }
 
<span class="p_del">-static inline int check_other_done(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int done = test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags);</span>
<span class="p_del">-	if (done) {</span>
<span class="p_del">-		/* paired with cmpxchg() in check_other_closed(); ensures</span>
<span class="p_del">-		 * read buffer head index is not stale</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		smp_mb__after_atomic();</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return done;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  *	copy_from_read_buf	-	copy read data directly
  *	@tty: terminal device
<span class="p_chunk">@@ -2171,7 +2159,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 	unsigned char __user *b = buf;
 	DEFINE_WAIT_FUNC(wait, woken_wake_function);
<span class="p_del">-	int c, done;</span>
<span class="p_add">+	int c;</span>
 	int minimum, time;
 	ssize_t retval = 0;
 	long timeout;
<span class="p_chunk">@@ -2239,32 +2227,35 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 		    ((minimum - (b - buf)) &gt;= 1))
 			ldata-&gt;minimum_to_wake = (minimum - (b - buf));
 
<span class="p_del">-		done = check_other_done(tty);</span>
<span class="p_del">-</span>
 		if (!input_available_p(tty, 0)) {
<span class="p_del">-			if (done) {</span>
<span class="p_del">-				retval = -EIO;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tty_hung_up_p(file))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			if (!timeout)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			if (file-&gt;f_flags &amp; O_NONBLOCK) {</span>
<span class="p_del">-				retval = -EAGAIN;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (signal_pending(current)) {</span>
<span class="p_del">-				retval = -ERESTARTSYS;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
 			up_read(&amp;tty-&gt;termios_rwsem);
<span class="p_add">+			tty_buffer_flush_work(tty-&gt;port);</span>
<span class="p_add">+			down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+			if (!input_available_p(tty, 0)) {</span>
<span class="p_add">+				if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+					retval = -EIO;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (tty_hung_up_p(file))</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				if (!timeout)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				if (file-&gt;f_flags &amp; O_NONBLOCK) {</span>
<span class="p_add">+					retval = -EAGAIN;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (signal_pending(current)) {</span>
<span class="p_add">+					retval = -ERESTARTSYS;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				up_read(&amp;tty-&gt;termios_rwsem);</span>
 
<span class="p_del">-			timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_del">-					     timeout);</span>
<span class="p_add">+				timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_add">+						timeout);</span>
 
<span class="p_del">-			down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+				down_read(&amp;tty-&gt;termios_rwsem);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
 		}
 
 		if (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) {
<span class="p_chunk">@@ -2446,12 +2437,17 @@</span> <span class="p_context"> static unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,</span>
 
 	poll_wait(file, &amp;tty-&gt;read_wait, wait);
 	poll_wait(file, &amp;tty-&gt;write_wait, wait);
<span class="p_del">-	if (check_other_done(tty))</span>
<span class="p_del">-		mask |= POLLHUP;</span>
 	if (input_available_p(tty, 1))
 		mask |= POLLIN | POLLRDNORM;
<span class="p_add">+	else {</span>
<span class="p_add">+		tty_buffer_flush_work(tty-&gt;port);</span>
<span class="p_add">+		if (input_available_p(tty, 1))</span>
<span class="p_add">+			mask |= POLLIN | POLLRDNORM;</span>
<span class="p_add">+	}</span>
 	if (tty-&gt;packet &amp;&amp; tty-&gt;link-&gt;ctrl_status)
 		mask |= POLLPRI | POLLIN | POLLRDNORM;
<span class="p_add">+	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_add">+		mask |= POLLHUP;</span>
 	if (tty_hung_up_p(file))
 		mask |= POLLHUP;
 	if (!(mask &amp; (POLLHUP | POLLIN | POLLRDNORM))) {
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index 78e983677339..7865228f664f 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> static void pty_close(struct tty_struct *tty, struct file *filp)</span>
 	if (!tty-&gt;link)
 		return;
 	set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	tty_flip_buffer_push(tty-&gt;link-&gt;port);</span>
<span class="p_add">+	wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait);</span>
 	wake_up_interruptible(&amp;tty-&gt;link-&gt;write_wait);
 	if (tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags);
<span class="p_chunk">@@ -247,9 +247,7 @@</span> <span class="p_context"> static int pty_open(struct tty_struct *tty, struct file *filp)</span>
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);
<span class="p_del">-	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */</span>
 	clear_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	clear_bit(TTY_OTHER_DONE, &amp;tty-&gt;link-&gt;flags);</span>
 	set_bit(TTY_THROTTLED, &amp;tty-&gt;flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_mid.c b/drivers/tty/serial/8250/8250_mid.c</span>
<span class="p_header">index 88531a36b69c..ed489880e62b 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_mid.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_mid.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pci.h&gt;
 
 #include &lt;linux/dma/hsu.h&gt;
<span class="p_add">+#include &lt;linux/8250_pci.h&gt;</span>
 
 #include &quot;8250.h&quot;
 
<span class="p_chunk">@@ -24,6 +25,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_DNV_UART	0x19d8
 
 /* Intel MID Specific registers */
<span class="p_add">+#define INTEL_MID_UART_DNV_FISR		0x08</span>
 #define INTEL_MID_UART_PS		0x30
 #define INTEL_MID_UART_MUL		0x34
 #define INTEL_MID_UART_DIV		0x38
<span class="p_chunk">@@ -31,6 +33,7 @@</span> <span class="p_context"></span>
 struct mid8250;
 
 struct mid8250_board {
<span class="p_add">+	unsigned int flags;</span>
 	unsigned long freq;
 	unsigned int base_baud;
 	int (*setup)(struct mid8250 *, struct uart_port *p);
<span class="p_chunk">@@ -88,16 +91,16 @@</span> <span class="p_context"> static int tng_setup(struct mid8250 *mid, struct uart_port *p)</span>
 static int dnv_handle_irq(struct uart_port *p)
 {
 	struct mid8250 *mid = p-&gt;private_data;
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = hsu_dma_irq(&amp;mid-&gt;dma_chip, 0);</span>
<span class="p_del">-	ret |= hsu_dma_irq(&amp;mid-&gt;dma_chip, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* For now, letting the HW generate separate interrupt for the UART */</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	return serial8250_handle_irq(p, serial_port_in(p, UART_IIR));</span>
<span class="p_add">+	unsigned int fisr = serial_port_in(p, INTEL_MID_UART_DNV_FISR);</span>
<span class="p_add">+	int ret = IRQ_NONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fisr &amp; BIT(2))</span>
<span class="p_add">+		ret |= hsu_dma_irq(&amp;mid-&gt;dma_chip, 1);</span>
<span class="p_add">+	if (fisr &amp; BIT(1))</span>
<span class="p_add">+		ret |= hsu_dma_irq(&amp;mid-&gt;dma_chip, 0);</span>
<span class="p_add">+	if (fisr &amp; BIT(0))</span>
<span class="p_add">+		ret |= serial8250_handle_irq(p, serial_port_in(p, UART_IIR));</span>
<span class="p_add">+	return ret;</span>
 }
 
 #define DNV_DMA_CHAN_OFFSET 0x80
<span class="p_chunk">@@ -106,12 +109,13 @@</span> <span class="p_context"> static int dnv_setup(struct mid8250 *mid, struct uart_port *p)</span>
 {
 	struct hsu_dma_chip *chip = &amp;mid-&gt;dma_chip;
 	struct pci_dev *pdev = to_pci_dev(p-&gt;dev);
<span class="p_add">+	unsigned int bar = FL_GET_BASE(mid-&gt;board-&gt;flags);</span>
 	int ret;
 
 	chip-&gt;dev = &amp;pdev-&gt;dev;
 	chip-&gt;irq = pdev-&gt;irq;
 	chip-&gt;regs = p-&gt;membase;
<span class="p_del">-	chip-&gt;length = pci_resource_len(pdev, 0);</span>
<span class="p_add">+	chip-&gt;length = pci_resource_len(pdev, bar);</span>
 	chip-&gt;offset = DNV_DMA_CHAN_OFFSET;
 
 	/* Falling back to PIO mode if DMA probing fails */
<span class="p_chunk">@@ -217,6 +221,7 @@</span> <span class="p_context"> static int mid8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 {
 	struct uart_8250_port uart;
 	struct mid8250 *mid;
<span class="p_add">+	unsigned int bar;</span>
 	int ret;
 
 	ret = pcim_enable_device(pdev);
<span class="p_chunk">@@ -230,6 +235,7 @@</span> <span class="p_context"> static int mid8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 		return -ENOMEM;
 
 	mid-&gt;board = (struct mid8250_board *)id-&gt;driver_data;
<span class="p_add">+	bar = FL_GET_BASE(mid-&gt;board-&gt;flags);</span>
 
 	memset(&amp;uart, 0, sizeof(struct uart_8250_port));
 
<span class="p_chunk">@@ -242,8 +248,8 @@</span> <span class="p_context"> static int mid8250_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	uart.port.flags = UPF_SHARE_IRQ | UPF_FIXED_PORT | UPF_FIXED_TYPE;
 	uart.port.set_termios = mid8250_set_termios;
 
<span class="p_del">-	uart.port.mapbase = pci_resource_start(pdev, 0);</span>
<span class="p_del">-	uart.port.membase = pcim_iomap(pdev, 0, 0);</span>
<span class="p_add">+	uart.port.mapbase = pci_resource_start(pdev, bar);</span>
<span class="p_add">+	uart.port.membase = pcim_iomap(pdev, bar, 0);</span>
 	if (!uart.port.membase)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -282,18 +288,21 @@</span> <span class="p_context"> static void mid8250_remove(struct pci_dev *pdev)</span>
 }
 
 static const struct mid8250_board pnw_board = {
<span class="p_add">+	.flags = FL_BASE0,</span>
 	.freq = 50000000,
 	.base_baud = 115200,
 	.setup = pnw_setup,
 };
 
 static const struct mid8250_board tng_board = {
<span class="p_add">+	.flags = FL_BASE0,</span>
 	.freq = 38400000,
 	.base_baud = 1843200,
 	.setup = tng_setup,
 };
 
 static const struct mid8250_board dnv_board = {
<span class="p_add">+	.flags = FL_BASE1,</span>
 	.freq = 133333333,
 	.base_baud = 115200,
 	.setup = dnv_setup,
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 7cd6f9a90542..c1d4a8fa9be8 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -1401,6 +1401,9 @@</span> <span class="p_context"> byt_set_termios(struct uart_port *p, struct ktermios *termios,</span>
 	unsigned long m, n;
 	u32 reg;
 
<span class="p_add">+	/* Gracefully handle the B0 case: fall back to B9600 */</span>
<span class="p_add">+	fuart = fuart ? fuart : 9600 * 16;</span>
<span class="p_add">+</span>
 	/* Get Fuart closer to Fref */
 	fuart *= rounddown_pow_of_two(fref / fuart);
 
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 94294558943c..7bbadd176c74 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -277,6 +277,13 @@</span> <span class="p_context"> static bool atmel_use_dma_rx(struct uart_port *port)</span>
 	return atmel_port-&gt;use_dma_rx;
 }
 
<span class="p_add">+static bool atmel_use_fifo(struct uart_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);</span>
<span class="p_add">+</span>
<span class="p_add">+	return atmel_port-&gt;fifo_size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static unsigned int atmel_get_lines_status(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
<span class="p_chunk">@@ -2169,7 +2176,12 @@</span> <span class="p_context"> static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else if (termios-&gt;c_cflag &amp; CRTSCTS) {
 		/* RS232 with hardware handshake (RTS/CTS) */
<span class="p_del">-		mode |= ATMEL_US_USMODE_HWHS;</span>
<span class="p_add">+		if (atmel_use_dma_rx(port) &amp;&amp; !atmel_use_fifo(port)) {</span>
<span class="p_add">+			dev_info(port-&gt;dev, &quot;not enabling hardware flow control because DMA is used&quot;);</span>
<span class="p_add">+			termios-&gt;c_cflag &amp;= ~CRTSCTS;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			mode |= ATMEL_US_USMODE_HWHS;</span>
<span class="p_add">+		}</span>
 	} else {
 		/* RS232 without hadware handshake */
 		mode |= ATMEL_US_USMODE_NORMAL;
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index d72cd736bdc6..8320173af846 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -1263,6 +1263,8 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 	/* check to see if we need  to change clock source */
 
 	if (ourport-&gt;baudclk != clk) {
<span class="p_add">+		clk_prepare_enable(clk);</span>
<span class="p_add">+</span>
 		s3c24xx_serial_setsource(port, clk_sel);
 
 		if (!IS_ERR(ourport-&gt;baudclk)) {
<span class="p_chunk">@@ -1270,8 +1272,6 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 			ourport-&gt;baudclk = ERR_PTR(-EINVAL);
 		}
 
<span class="p_del">-		clk_prepare_enable(clk);</span>
<span class="p_del">-</span>
 		ourport-&gt;baudclk = clk;
 		ourport-&gt;baudclk_rate = clk ? clk_get_rate(clk) : 0;
 	}
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 3cd31e0d4bd9..fb31eecb708d 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -37,29 +37,6 @@</span> <span class="p_context"></span>
 
 #define TTY_BUFFER_PAGE	(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) &amp; ~0xFF)
 
<span class="p_del">-/*</span>
<span class="p_del">- * If all tty flip buffers have been processed by flush_to_ldisc() or</span>
<span class="p_del">- * dropped by tty_buffer_flush(), check if the linked pty has been closed.</span>
<span class="p_del">- * If so, wake the reader/poll to process</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void check_other_closed(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags, old;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* transition from TTY_OTHER_CLOSED =&gt; TTY_OTHER_DONE must be atomic */</span>
<span class="p_del">-	for (flags = ACCESS_ONCE(tty-&gt;flags);</span>
<span class="p_del">-	     test_bit(TTY_OTHER_CLOSED, &amp;flags);</span>
<span class="p_del">-	     ) {</span>
<span class="p_del">-		old = flags;</span>
<span class="p_del">-		__set_bit(TTY_OTHER_DONE, &amp;flags);</span>
<span class="p_del">-		flags = cmpxchg(&amp;tty-&gt;flags, old, flags);</span>
<span class="p_del">-		if (old == flags) {</span>
<span class="p_del">-			wake_up_interruptible(&amp;tty-&gt;read_wait);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  *	tty_buffer_lock_exclusive	-	gain exclusive access to buffer
  *	tty_buffer_unlock_exclusive	-	release exclusive access
<span class="p_chunk">@@ -254,8 +231,6 @@</span> <span class="p_context"> void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)</span>
 	if (ld &amp;&amp; ld-&gt;ops-&gt;flush_buffer)
 		ld-&gt;ops-&gt;flush_buffer(tty);
 
<span class="p_del">-	check_other_closed(tty);</span>
<span class="p_del">-</span>
 	atomic_dec(&amp;buf-&gt;priority);
 	mutex_unlock(&amp;buf-&gt;lock);
 }
<span class="p_chunk">@@ -505,10 +480,8 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 		 */
 		count = smp_load_acquire(&amp;head-&gt;commit) - head-&gt;read;
 		if (!count) {
<span class="p_del">-			if (next == NULL) {</span>
<span class="p_del">-				check_other_closed(tty);</span>
<span class="p_add">+			if (next == NULL)</span>
 				break;
<span class="p_del">-			}</span>
 			buf-&gt;head = next;
 			tty_buffer_free(port, head);
 			continue;
<span class="p_chunk">@@ -597,3 +570,8 @@</span> <span class="p_context"> bool tty_buffer_cancel_work(struct tty_port *port)</span>
 {
 	return cancel_work_sync(&amp;port-&gt;buf.work);
 }
<span class="p_add">+</span>
<span class="p_add">+void tty_buffer_flush_work(struct tty_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_work(&amp;port-&gt;buf.work);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 4462d167900c..cf20282f79f0 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -3583,9 +3583,10 @@</span> <span class="p_context"> static int do_register_con_driver(const struct consw *csw, int first, int last)</span>
 		goto err;
 
 	desc = csw-&gt;con_startup();
<span class="p_del">-</span>
<span class="p_del">-	if (!desc)</span>
<span class="p_add">+	if (!desc) {</span>
<span class="p_add">+		retval = -ENODEV;</span>
 		goto err;
<span class="p_add">+	}</span>
 
 	retval = -EINVAL;
 
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index 2057d91d8336..dadd1e8dfe09 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -284,7 +284,7 @@</span> <span class="p_context"> static int usb_probe_interface(struct device *dev)</span>
 	struct usb_device *udev = interface_to_usbdev(intf);
 	const struct usb_device_id *id;
 	int error = -ENODEV;
<span class="p_del">-	int lpm_disable_error;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	dev_dbg(dev, &quot;%s\n&quot;, __func__);
 
<span class="p_chunk">@@ -336,12 +336,14 @@</span> <span class="p_context"> static int usb_probe_interface(struct device *dev)</span>
 	 * setting during probe, that should also be fine.  usb_set_interface()
 	 * will attempt to disable LPM, and fail if it can&#39;t disable it.
 	 */
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_del">-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_del">-		dev_err(&amp;intf-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_del">-				__func__, driver-&gt;name);</span>
<span class="p_del">-		error = lpm_disable_error;</span>
<span class="p_del">-		goto err;</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+		if (lpm_disable_error) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_add">+					__func__, driver-&gt;name);</span>
<span class="p_add">+			error = lpm_disable_error;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Carry out a deferred switch to altsetting 0 */
<span class="p_chunk">@@ -391,7 +393,8 @@</span> <span class="p_context"> static int usb_unbind_interface(struct device *dev)</span>
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct usb_host_endpoint *ep, **eps = NULL;
 	struct usb_device *udev;
<span class="p_del">-	int i, j, error, r, lpm_disable_error;</span>
<span class="p_add">+	int i, j, error, r;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
<span class="p_chunk">@@ -399,12 +402,13 @@</span> <span class="p_context"> static int usb_unbind_interface(struct device *dev)</span>
 	udev = interface_to_usbdev(intf);
 	error = usb_autoresume_device(udev);
 
<span class="p_del">-	/* Hub-initiated LPM policy may change, so attempt to disable LPM until</span>
<span class="p_add">+	/* If hub-initiated LPM policy may change, attempt to disable LPM until</span>
 	 * the driver is unbound.  If LPM isn&#39;t disabled, that&#39;s fine because it
 	 * wouldn&#39;t be enabled unless all the bound interfaces supported
 	 * hub-initiated LPM.
 	 */
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm)</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
 
 	/*
 	 * Terminate all URBs for this interface unless the driver
<span class="p_chunk">@@ -505,7 +509,7 @@</span> <span class="p_context"> int usb_driver_claim_interface(struct usb_driver *driver,</span>
 	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
<span class="p_del">-	int lpm_disable_error;</span>
<span class="p_add">+	int lpm_disable_error = -ENODEV;</span>
 
 	if (!iface)
 		return -ENODEV;
<span class="p_chunk">@@ -526,12 +530,14 @@</span> <span class="p_context"> int usb_driver_claim_interface(struct usb_driver *driver,</span>
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
<span class="p_del">-	/* Disable LPM until this driver is bound. */</span>
<span class="p_del">-	lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_del">-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_del">-		dev_err(&amp;iface-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_del">-				__func__, driver-&gt;name);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	/* See the comment about disabling LPM in usb_probe_interface(). */</span>
<span class="p_add">+	if (driver-&gt;disable_hub_initiated_lpm) {</span>
<span class="p_add">+		lpm_disable_error = usb_unlocked_disable_lpm(udev);</span>
<span class="p_add">+		if (lpm_disable_error) {</span>
<span class="p_add">+			dev_err(&amp;iface-&gt;dev, &quot;%s Failed to disable LPM for driver %s\n.&quot;,</span>
<span class="p_add">+					__func__, driver-&gt;name);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Claimed interfaces are initially inactive (suspended) and
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 79d895c2dd71..97ef75af9632 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -651,7 +651,7 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 	if (io_data-&gt;read &amp;&amp; ret &gt; 0) {
 		use_mm(io_data-&gt;mm);
 		ret = copy_to_iter(io_data-&gt;buf, ret, &amp;io_data-&gt;data);
<span class="p_del">-		if (iov_iter_count(&amp;io_data-&gt;data))</span>
<span class="p_add">+		if (ret != io_data-&gt;req-&gt;actual &amp;&amp; iov_iter_count(&amp;io_data-&gt;data))</span>
 			ret = -EFAULT;
 		unuse_mm(io_data-&gt;mm);
 	}
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">index 223ccf89d226..a4f664062e0c 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_chunk">@@ -2977,25 +2977,6 @@</span> <span class="p_context"> void fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,</span>
 }
 EXPORT_SYMBOL_GPL(fsg_common_set_inquiry_string);
 
<span class="p_del">-int fsg_common_run_thread(struct fsg_common *common)</span>
<span class="p_del">-{</span>
<span class="p_del">-	common-&gt;state = FSG_STATE_IDLE;</span>
<span class="p_del">-	/* Tell the thread to start working */</span>
<span class="p_del">-	common-&gt;thread_task =</span>
<span class="p_del">-		kthread_create(fsg_main_thread, common, &quot;file-storage&quot;);</span>
<span class="p_del">-	if (IS_ERR(common-&gt;thread_task)) {</span>
<span class="p_del">-		common-&gt;state = FSG_STATE_TERMINATED;</span>
<span class="p_del">-		return PTR_ERR(common-&gt;thread_task);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	DBG(common, &quot;I/O thread pid: %d\n&quot;, task_pid_nr(common-&gt;thread_task));</span>
<span class="p_del">-</span>
<span class="p_del">-	wake_up_process(common-&gt;thread_task);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(fsg_common_run_thread);</span>
<span class="p_del">-</span>
 static void fsg_common_release(struct kref *ref)
 {
 	struct fsg_common *common = container_of(ref, struct fsg_common, ref);
<span class="p_chunk">@@ -3005,6 +2986,7 @@</span> <span class="p_context"> static void fsg_common_release(struct kref *ref)</span>
 	if (common-&gt;state != FSG_STATE_TERMINATED) {
 		raise_exception(common, FSG_STATE_EXIT);
 		wait_for_completion(&amp;common-&gt;thread_notifier);
<span class="p_add">+		common-&gt;thread_task = NULL;</span>
 	}
 
 	for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); ++i) {
<span class="p_chunk">@@ -3050,9 +3032,21 @@</span> <span class="p_context"> static int fsg_bind(struct usb_configuration *c, struct usb_function *f)</span>
 		if (ret)
 			return ret;
 		fsg_common_set_inquiry_string(fsg-&gt;common, NULL, NULL);
<span class="p_del">-		ret = fsg_common_run_thread(fsg-&gt;common);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!common-&gt;thread_task) {</span>
<span class="p_add">+		common-&gt;state = FSG_STATE_IDLE;</span>
<span class="p_add">+		common-&gt;thread_task =</span>
<span class="p_add">+			kthread_create(fsg_main_thread, common, &quot;file-storage&quot;);</span>
<span class="p_add">+		if (IS_ERR(common-&gt;thread_task)) {</span>
<span class="p_add">+			int ret = PTR_ERR(common-&gt;thread_task);</span>
<span class="p_add">+			common-&gt;thread_task = NULL;</span>
<span class="p_add">+			common-&gt;state = FSG_STATE_TERMINATED;</span>
 			return ret;
<span class="p_add">+		}</span>
<span class="p_add">+		DBG(common, &quot;I/O thread pid: %d\n&quot;,</span>
<span class="p_add">+		    task_pid_nr(common-&gt;thread_task));</span>
<span class="p_add">+		wake_up_process(common-&gt;thread_task);</span>
 	}
 
 	fsg-&gt;gadget = gadget;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.h b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">index 445df6775609..b6a9918eaefb 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.h</span>
<span class="p_chunk">@@ -153,8 +153,6 @@</span> <span class="p_context"> int fsg_common_create_luns(struct fsg_common *common, struct fsg_config *cfg);</span>
 void fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,
 				   const char *pn);
 
<span class="p_del">-int fsg_common_run_thread(struct fsg_common *common);</span>
<span class="p_del">-</span>
 void fsg_config_from_params(struct fsg_config *cfg,
 			    const struct fsg_module_parameters *params,
 			    unsigned int fsg_num_buffers);
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/acm_ms.c b/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_header">index 4b158e2d1e57..64b2cbb0bc6b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/acm_ms.c</span>
<span class="p_chunk">@@ -133,10 +133,6 @@</span> <span class="p_context"> static int acm_ms_do_config(struct usb_configuration *c)</span>
 	if (status &lt; 0)
 		goto put_msg;
 
<span class="p_del">-	status = fsg_common_run_thread(opts-&gt;common);</span>
<span class="p_del">-	if (status)</span>
<span class="p_del">-		goto remove_acm;</span>
<span class="p_del">-</span>
 	status = usb_add_function(c, f_msg);
 	if (status)
 		goto remove_acm;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/mass_storage.c b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">index bda3c519110f..99aa22c81770 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/mass_storage.c</span>
<span class="p_chunk">@@ -132,10 +132,6 @@</span> <span class="p_context"> static int msg_do_config(struct usb_configuration *c)</span>
 	if (IS_ERR(f_msg))
 		return PTR_ERR(f_msg);
 
<span class="p_del">-	ret = fsg_common_run_thread(opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto put_func;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg);
 	if (ret)
 		goto put_func;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/multi.c b/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_header">index 4fe794ddcd49..09c7c28f32f7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/multi.c</span>
<span class="p_chunk">@@ -137,7 +137,6 @@</span> <span class="p_context"> static struct usb_function *f_msg_rndis;</span>
 
 static int rndis_do_config(struct usb_configuration *c)
 {
<span class="p_del">-	struct fsg_opts *fsg_opts;</span>
 	int ret;
 
 	if (gadget_is_otg(c-&gt;cdev-&gt;gadget)) {
<span class="p_chunk">@@ -169,11 +168,6 @@</span> <span class="p_context"> static int rndis_do_config(struct usb_configuration *c)</span>
 		goto err_fsg;
 	}
 
<span class="p_del">-	fsg_opts = fsg_opts_from_func_inst(fi_msg);</span>
<span class="p_del">-	ret = fsg_common_run_thread(fsg_opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto err_run;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg_rndis);
 	if (ret)
 		goto err_run;
<span class="p_chunk">@@ -225,7 +219,6 @@</span> <span class="p_context"> static struct usb_function *f_msg_multi;</span>
 
 static int cdc_do_config(struct usb_configuration *c)
 {
<span class="p_del">-	struct fsg_opts *fsg_opts;</span>
 	int ret;
 
 	if (gadget_is_otg(c-&gt;cdev-&gt;gadget)) {
<span class="p_chunk">@@ -258,11 +251,6 @@</span> <span class="p_context"> static int cdc_do_config(struct usb_configuration *c)</span>
 		goto err_fsg;
 	}
 
<span class="p_del">-	fsg_opts = fsg_opts_from_func_inst(fi_msg);</span>
<span class="p_del">-	ret = fsg_common_run_thread(fsg_opts-&gt;common);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto err_run;</span>
<span class="p_del">-</span>
 	ret = usb_add_function(c, f_msg_multi);
 	if (ret)
 		goto err_run;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/nokia.c b/drivers/usb/gadget/legacy/nokia.c</span>
<span class="p_header">index 8b3f6fb1825d..05d3f79e768d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/nokia.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/nokia.c</span>
<span class="p_chunk">@@ -152,7 +152,6 @@</span> <span class="p_context"> static int nokia_bind_config(struct usb_configuration *c)</span>
 	struct usb_function *f_ecm;
 	struct usb_function *f_obex2 = NULL;
 	struct usb_function *f_msg;
<span class="p_del">-	struct fsg_opts *fsg_opts;</span>
 	int status = 0;
 	int obex1_stat = -1;
 	int obex2_stat = -1;
<span class="p_chunk">@@ -222,12 +221,6 @@</span> <span class="p_context"> static int nokia_bind_config(struct usb_configuration *c)</span>
 		goto err_ecm;
 	}
 
<span class="p_del">-	fsg_opts = fsg_opts_from_func_inst(fi_msg);</span>
<span class="p_del">-</span>
<span class="p_del">-	status = fsg_common_run_thread(fsg_opts-&gt;common);</span>
<span class="p_del">-	if (status)</span>
<span class="p_del">-		goto err_msg;</span>
<span class="p_del">-</span>
 	status = usb_add_function(c, f_msg);
 	if (status)
 		goto err_msg;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">index f660afba715d..89f7cd66f5e6 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> int usb_gadget_map_request(struct usb_gadget *gadget,</span>
 		mapped = dma_map_sg(dev, req-&gt;sg, req-&gt;num_sgs,
 				is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 		if (mapped == 0) {
<span class="p_del">-			dev_err(&amp;gadget-&gt;dev, &quot;failed to map SGs\n&quot;);</span>
<span class="p_add">+			dev_err(dev, &quot;failed to map SGs\n&quot;);</span>
 			return -EFAULT;
 		}
 
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 637f3f7cfce8..1a812eafe670 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> static struct scatterlist *</span>
 alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 {
 	struct scatterlist	*sg;
<span class="p_add">+	unsigned int		n_size = 0;</span>
 	unsigned		i;
 	unsigned		size = max;
 	unsigned		maxpacket =
<span class="p_chunk">@@ -537,7 +538,8 @@</span> <span class="p_context"> alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)</span>
 			break;
 		case 1:
 			for (j = 0; j &lt; size; j++)
<span class="p_del">-				*buf++ = (u8) ((j % maxpacket) % 63);</span>
<span class="p_add">+				*buf++ = (u8) (((j + n_size) % maxpacket) % 63);</span>
<span class="p_add">+			n_size += size;</span>
 			break;
 		}
 
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index c0866971db2b..1947ea0e0988 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2856,14 +2856,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;interrupt_read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;interrupt_read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;interrupt_read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;interrupt_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;interrupt_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;interrupt_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2891,14 +2893,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;bulk_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;bulk_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;bulk_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2924,9 +2928,22 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 			}
 		}
 
<span class="p_del">-		if (!interrupt_in_found || !bulk_in_found || !bulk_out_found) {</span>
<span class="p_del">-			dev_err(ddev, &quot;Error - the proper endpoints were not found!\n&quot;);</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (response || !interrupt_in_found || !bulk_in_found ||</span>
<span class="p_add">+							!bulk_out_found) {</span>
<span class="p_add">+			if (!response) {</span>
<span class="p_add">+				dev_err(ddev, &quot;expected endpoints not found\n&quot;);</span>
<span class="p_add">+				response = -ENODEV;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			kfree(edge_serial);</span>
<span class="p_add">+</span>
<span class="p_add">+			return response;</span>
 		}
 
 		/* start interrupt read for this edgeport this interrupt will
<span class="p_chunk">@@ -2949,16 +2966,9 @@</span> <span class="p_context"> static void edge_disconnect(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_del">-	/* stop reads and writes on all ports */</span>
<span class="p_del">-	/* free up our endpoint stuff */</span>
 	if (edge_serial-&gt;is_epic) {
 		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_del">-</span>
 		usb_kill_urb(edge_serial-&gt;read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;bulk_in_buffer);</span>
 	}
 }
 
<span class="p_chunk">@@ -2971,6 +2981,16 @@</span> <span class="p_context"> static void edge_release(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_add">+	if (edge_serial-&gt;is_epic) {</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(edge_serial);
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c</span>
<span class="p_header">index e07b15ed5814..7faa901ee47f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan.c</span>
<span class="p_chunk">@@ -2376,6 +2376,10 @@</span> <span class="p_context"> static void keyspan_release(struct usb_serial *serial)</span>
 
 	s_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	/* Make sure to unlink the URBs submitted in attach. */</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;instat_urb);</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;indat_urb);</span>
<span class="p_add">+</span>
 	usb_free_urb(s_priv-&gt;instat_urb);
 	usb_free_urb(s_priv-&gt;indat_urb);
 	usb_free_urb(s_priv-&gt;glocont_urb);
<span class="p_header">diff --git a/drivers/usb/serial/mxuport.c b/drivers/usb/serial/mxuport.c</span>
<span class="p_header">index 31a8b47f1ac6..c6596cbcc4b6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mxuport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mxuport.c</span>
<span class="p_chunk">@@ -1259,6 +1259,15 @@</span> <span class="p_context"> static int mxuport_attach(struct usb_serial *serial)</span>
 	return 0;
 }
 
<span class="p_add">+static void mxuport_release(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_serial_port *port0 = serial-&gt;port[0];</span>
<span class="p_add">+	struct usb_serial_port *port1 = serial-&gt;port[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_serial_generic_close(port1);</span>
<span class="p_add">+	usb_serial_generic_close(port0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct mxuport_port *mxport = usb_get_serial_port_data(port);
<span class="p_chunk">@@ -1361,6 +1370,7 @@</span> <span class="p_context"> static struct usb_serial_driver mxuport_device = {</span>
 	.probe			= mxuport_probe,
 	.port_probe		= mxuport_port_probe,
 	.attach			= mxuport_attach,
<span class="p_add">+	.release		= mxuport_release,</span>
 	.calc_num_ports		= mxuport_calc_num_ports,
 	.open			= mxuport_open,
 	.close			= mxuport_close,
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index c6f497f16526..d96d423d00e6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -375,18 +375,22 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define HAIER_PRODUCT_CE81B			0x10f8
 #define HAIER_PRODUCT_CE100			0x2009
 
<span class="p_del">-/* Cinterion (formerly Siemens) products */</span>
<span class="p_del">-#define SIEMENS_VENDOR_ID				0x0681</span>
<span class="p_del">-#define CINTERION_VENDOR_ID				0x1e2d</span>
<span class="p_add">+/* Gemalto&#39;s Cinterion products (formerly Siemens) */</span>
<span class="p_add">+#define SIEMENS_VENDOR_ID			0x0681</span>
<span class="p_add">+#define CINTERION_VENDOR_ID			0x1e2d</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC25_MDMNET		0x0040</span>
 #define CINTERION_PRODUCT_HC25_MDM		0x0047
<span class="p_del">-#define CINTERION_PRODUCT_HC25_MDMNET	0x0040</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC28_MDMNET		0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_HC28_MDM		0x004C
<span class="p_del">-#define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_EU3_E			0x0051
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 #define CINTERION_PRODUCT_AHXX			0x0055
 #define CINTERION_PRODUCT_PLXX			0x0060
<span class="p_add">+#define CINTERION_PRODUCT_PH8_2RMNET		0x0082</span>
<span class="p_add">+#define CINTERION_PRODUCT_PH8_AUDIO		0x0083</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_2RMNET		0x0084</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_AUDIO		0x0085</span>
 
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
<span class="p_chunk">@@ -633,6 +637,10 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
 	.reserved = BIT(1) | BIT(2) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1602,7 +1610,79 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },
<span class="p_del">-	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff42, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff43, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff44, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff45, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff46, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff47, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff48, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff49, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff4f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff50, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff51, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff52, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff53, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff54, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff55, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff56, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff57, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff58, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff59, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff5f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff60, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff61, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff62, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff63, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff64, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff65, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff66, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff67, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff68, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff69, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff6f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff70, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff71, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff72, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff73, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff74, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff75, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff76, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff77, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff78, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff79, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7a, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7b, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7c, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7d, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7e, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff7f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff80, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff81, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff82, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff83, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff84, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff85, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff86, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff87, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff88, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff89, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8a, 0xff, 0xff, 0xff) },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8b, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8c, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff8d, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1613,6 +1693,61 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff92, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff93, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff94, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff9f, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffa9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaa, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffab, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffac, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffae, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffaf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffb9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffba, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbe, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffbf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc6, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc7, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc8, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffc9, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffca, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcb, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcc, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcd, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffce, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffcf, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd0, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd1, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd2, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd3, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd4, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffd5, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffe9, 0xff, 0xff, 0xff) },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffec, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xffee, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xfff6, 0xff, 0xff, 0xff) },
<span class="p_chunk">@@ -1712,7 +1847,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, </span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_2RMNET, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;cinterion_rmnet2_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_AUDIO, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_2RMNET, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_AUDIO, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDMNET) },
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index 504f5bff79c0..b18974cbd995 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static void qt2_release(struct usb_serial *serial)</span>
 
 	serial_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	usb_kill_urb(serial_priv-&gt;read_urb);</span>
 	usb_free_urb(serial_priv-&gt;read_urb);
 	kfree(serial_priv-&gt;read_buffer);
 	kfree(serial_priv);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index f07d01bc4875..bfcd87ee8ff5 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1648,7 +1648,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 
 		src_inode = file_inode(src.file);
 		if (src_inode-&gt;i_sb != file_inode(file)-&gt;i_sb) {
<span class="p_del">-			btrfs_info(BTRFS_I(src_inode)-&gt;root-&gt;fs_info,</span>
<span class="p_add">+			btrfs_info(BTRFS_I(file_inode(file))-&gt;root-&gt;fs_info,</span>
 				   &quot;Snapshot src from another FS&quot;);
 			ret = -EXDEV;
 		} else if (!inode_owner_or_capable(src_inode)) {
<span class="p_header">diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c</span>
<span class="p_header">index 59727e32ed0f..af0ec2d5ad0e 100644</span>
<span class="p_header">--- a/fs/cifs/sess.c</span>
<span class="p_header">+++ b/fs/cifs/sess.c</span>
<span class="p_chunk">@@ -400,19 +400,27 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 	sec_blob-&gt;LmChallengeResponse.MaximumLength = 0;
 
 	sec_blob-&gt;NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_del">-		goto setup_ntlmv2_ret;</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_add">+			goto setup_ntlmv2_ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * don&#39;t send an NT Response for anonymous access</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length = 0;</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength = 0;</span>
 	}
<span class="p_del">-	memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
 
 	if (ses-&gt;domainName == NULL) {
 		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_chunk">@@ -670,20 +678,24 @@</span> <span class="p_context"> sess_auth_lanman(struct sess_data *sess_data)</span>
 
 	pSMB-&gt;req.hdr.Flags2 &amp;= ~SMBFLG2_UNICODE;
 
<span class="p_del">-	/* no capabilities flags in old lanman negotiation */</span>
<span class="p_del">-	pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_del">-	 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_del">-	 * security mode bit in Negottiate Protocol response states</span>
<span class="p_del">-	 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_del">-			      ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_del">-			      true : false, lnm_session_key);</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		/* no capabilities flags in old lanman negotiation */</span>
<span class="p_add">+		pSMB-&gt;old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Calculate hash with password and copy into bcc_ptr.</span>
<span class="p_add">+		 * Encryption Key (stored as in cryptkey) gets used if the</span>
<span class="p_add">+		 * security mode bit in Negottiate Protocol response states</span>
<span class="p_add">+		 * to use challenge/response method (i.e. Password bit is 1).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		rc = calc_lanman_hash(ses-&gt;password, ses-&gt;server-&gt;cryptkey,</span>
<span class="p_add">+				      ses-&gt;server-&gt;sec_mode &amp; SECMODE_PW_ENCRYPT ?</span>
<span class="p_add">+				      true : false, lnm_session_key);</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;old_req.PasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * can not sign if LANMAN negotiated so no need
<span class="p_chunk">@@ -769,26 +781,31 @@</span> <span class="p_context"> sess_auth_ntlm(struct sess_data *sess_data)</span>
 	capabilities = cifs_ssetup_hdr(ses, pSMB);
 
 	pSMB-&gt;req_no_secext.Capabilities = cpu_to_le32(capabilities);
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-			cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* calculate ntlm response and session key */</span>
<span class="p_del">-	rc = setup_ntlm_response(ses, sess_data-&gt;nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_del">-				 rc);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength =</span>
<span class="p_add">+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+				cpu_to_le16(CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* calculate ntlm response and session key */</span>
<span class="p_add">+		rc = setup_ntlm_response(ses, sess_data-&gt;nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLM authentication\n&quot;,</span>
<span class="p_add">+					 rc);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* copy ntlm response */</span>
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			CIFS_AUTH_RESP_SIZE);</span>
<span class="p_del">-	bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		/* copy ntlm response */</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				CIFS_AUTH_RESP_SIZE);</span>
<span class="p_add">+		bcc_ptr += CIFS_AUTH_RESP_SIZE;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 		/* unicode strings must be word aligned */
<span class="p_chunk">@@ -878,22 +895,26 @@</span> <span class="p_context"> sess_auth_ntlmv2(struct sess_data *sess_data)</span>
 	/* LM2 password would be here if we supported it */
 	pSMB-&gt;req_no_secext.CaseInsensitivePasswordLength = 0;
 
<span class="p_del">-	/* calculate nlmv2 response and session key */</span>
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, sess_data-&gt;nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;, rc);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		/* calculate nlmv2 response and session key */</span>
<span class="p_add">+		rc = setup_ntlmv2_rsp(ses, sess_data-&gt;nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLMv2 authentication\n&quot;, rc);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+		memcpy(bcc_ptr, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		bcc_ptr += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
 
<span class="p_del">-	/* set case sensitive password length after tilen may get</span>
<span class="p_del">-	 * assigned, tilen is 0 otherwise.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_del">-		cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		/* set case sensitive password length after tilen may get</span>
<span class="p_add">+		 * assigned, tilen is 0 otherwise.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength =</span>
<span class="p_add">+			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pSMB-&gt;req_no_secext.CaseSensitivePasswordLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;capabilities &amp; CAP_UNICODE) {
 		if (sess_data-&gt;iov[0].iov_len % 2) {
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index bc0bb9c34f72..0ffa18094335 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #define SMB2_OP_DELETE 7
 #define SMB2_OP_HARDLINK 8
 #define SMB2_OP_SET_EOF 9
<span class="p_add">+#define SMB2_OP_RMDIR 10</span>
 
 /* Used when constructing chained read requests. */
 #define CHAINED_REQUEST 1
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 899bbc86f73e..4f0231e685a9 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -80,6 +80,10 @@</span> <span class="p_context"> smb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		 * SMB2_open() call.
 		 */
 		break;
<span class="p_add">+	case SMB2_OP_RMDIR:</span>
<span class="p_add">+		tmprc = SMB2_rmdir(xid, tcon, fid.persistent_fid,</span>
<span class="p_add">+				   fid.volatile_fid);</span>
<span class="p_add">+		break;</span>
 	case SMB2_OP_RENAME:
 		tmprc = SMB2_rename(xid, tcon, fid.persistent_fid,
 				    fid.volatile_fid, (__le16 *)data);
<span class="p_chunk">@@ -191,8 +195,8 @@</span> <span class="p_context"> smb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,</span>
 	   struct cifs_sb_info *cifs_sb)
 {
 	return smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,
<span class="p_del">-				  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,</span>
<span class="p_del">-				  NULL, SMB2_OP_DELETE);</span>
<span class="p_add">+				  CREATE_NOT_FILE,</span>
<span class="p_add">+				  NULL, SMB2_OP_RMDIR);</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 373b5cd1c913..82c5f57382b2 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -2577,6 +2577,22 @@</span> <span class="p_context"> SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,</span>
 }
 
 int
<span class="p_add">+SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		  u64 persistent_fid, u64 volatile_fid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__u8 delete_pending = 1;</span>
<span class="p_add">+	void *data;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = &amp;delete_pending;</span>
<span class="p_add">+	size = 1; /* sizeof __u8 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return send_set_info(xid, tcon, persistent_fid, volatile_fid,</span>
<span class="p_add">+			current-&gt;tgid, FILE_DISPOSITION_INFORMATION, 1, &amp;data,</span>
<span class="p_add">+			&amp;size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
 SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 		  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)
 {
<span class="p_header">diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h</span>
<span class="p_header">index 79dc650c18b2..9bc59f9c12fb 100644</span>
<span class="p_header">--- a/fs/cifs/smb2proto.h</span>
<span class="p_header">+++ b/fs/cifs/smb2proto.h</span>
<span class="p_chunk">@@ -140,6 +140,8 @@</span> <span class="p_context"> extern int SMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,</span>
 extern int SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,
 		       u64 persistent_fid, u64 volatile_fid,
 		       __le16 *target_file);
<span class="p_add">+extern int SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		      u64 persistent_fid, u64 volatile_fid);</span>
 extern int SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 			     u64 persistent_fid, u64 volatile_fid,
 			     __le16 *target_file);
<span class="p_header">diff --git a/fs/ext4/move_extent.c b/fs/ext4/move_extent.c</span>
<span class="p_header">index 9bdbf98240a0..796ff0eafd3c 100644</span>
<span class="p_header">--- a/fs/ext4/move_extent.c</span>
<span class="p_header">+++ b/fs/ext4/move_extent.c</span>
<span class="p_chunk">@@ -390,6 +390,7 @@</span> <span class="p_context"> data_copy:</span>
 		*err = ext4_get_block(orig_inode, orig_blk_offset + i, bh, 0);
 		if (*err &lt; 0)
 			break;
<span class="p_add">+		bh = bh-&gt;b_this_page;</span>
 	}
 	if (!*err)
 		*err = block_commit_write(pagep[0], from, from + replaced_size);
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index a561591896bd..3713fd52b44b 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/bitmap.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
 
 /* Mark the filesystem dirty, so that chkdsk checks it when os/2 booted */
 
<span class="p_chunk">@@ -453,10 +454,6 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 	int lowercase, eas, chk, errs, chkdsk, timeshift;
 	int o;
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
<span class="p_del">-	char *new_opts = kstrdup(data, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!new_opts)</span>
<span class="p_del">-		return -ENOMEM;</span>
 
 	sync_filesystem(s);
 
<span class="p_chunk">@@ -493,17 +490,44 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 
 	if (!(*flags &amp; MS_RDONLY)) mark_dirty(s, 1);
 
<span class="p_del">-	replace_mount_options(s, new_opts);</span>
<span class="p_del">-</span>
 	hpfs_unlock(s);
 	return 0;
 
 out_err:
 	hpfs_unlock(s);
<span class="p_del">-	kfree(new_opts);</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static int hpfs_show_options(struct seq_file *seq, struct dentry *root)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hpfs_sb_info *sbi = hpfs_sb(root-&gt;d_sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(seq, &quot;,uid=%u&quot;, from_kuid_munged(&amp;init_user_ns, sbi-&gt;sb_uid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,gid=%u&quot;, from_kgid_munged(&amp;init_user_ns, sbi-&gt;sb_gid));</span>
<span class="p_add">+	seq_printf(seq, &quot;,umask=%03o&quot;, (~sbi-&gt;sb_mode &amp; 0777));</span>
<span class="p_add">+	if (sbi-&gt;sb_lowercase)</span>
<span class="p_add">+		seq_printf(seq, &quot;,case=lower&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=none&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,check=strict&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_err)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=continue&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_err == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,errors=panic&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_chkdsk)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_chkdsk == 2)</span>
<span class="p_add">+		seq_printf(seq, &quot;,chkdsk=always&quot;);</span>
<span class="p_add">+	if (!sbi-&gt;sb_eas)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=no&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_eas == 1)</span>
<span class="p_add">+		seq_printf(seq, &quot;,eas=ro&quot;);</span>
<span class="p_add">+	if (sbi-&gt;sb_timeshift)</span>
<span class="p_add">+		seq_printf(seq, &quot;,timeshift=%d&quot;, sbi-&gt;sb_timeshift);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Super operations */
 
 static const struct super_operations hpfs_sops =
<span class="p_chunk">@@ -514,7 +538,7 @@</span> <span class="p_context"> static const struct super_operations hpfs_sops =</span>
 	.put_super	= hpfs_put_super,
 	.statfs		= hpfs_statfs,
 	.remount_fs	= hpfs_remount_fs,
<span class="p_del">-	.show_options	= generic_show_options,</span>
<span class="p_add">+	.show_options	= hpfs_show_options,</span>
 };
 
 static int hpfs_fill_super(struct super_block *s, void *options, int silent)
<span class="p_chunk">@@ -537,8 +561,6 @@</span> <span class="p_context"> static int hpfs_fill_super(struct super_block *s, void *options, int silent)</span>
 
 	int o;
 
<span class="p_del">-	save_mount_options(s, options);</span>
<span class="p_del">-</span>
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi) {
 		return -ENOMEM;
<span class="p_header">diff --git a/include/asm-generic/qspinlock.h b/include/asm-generic/qspinlock.h</span>
<span class="p_header">index e2aadbc7151f..7d633f19e38a 100644</span>
<span class="p_header">--- a/include/asm-generic/qspinlock.h</span>
<span class="p_header">+++ b/include/asm-generic/qspinlock.h</span>
<span class="p_chunk">@@ -27,7 +27,30 @@</span> <span class="p_context"></span>
  */
 static __always_inline int queued_spin_is_locked(struct qspinlock *lock)
 {
<span class="p_del">-	return atomic_read(&amp;lock-&gt;val);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * queued_spin_lock_slowpath() can ACQUIRE the lock before</span>
<span class="p_add">+	 * issuing the unordered store that sets _Q_LOCKED_VAL.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * See both smp_cond_acquire() sites for more detail.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This however means that in code like:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   spin_lock(A)		spin_lock(B)</span>
<span class="p_add">+	 *   spin_unlock_wait(B)	spin_is_locked(A)</span>
<span class="p_add">+	 *   do_something()		do_something()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Both CPUs can end up running do_something() because the store</span>
<span class="p_add">+	 * setting _Q_LOCKED_VAL will pass through the loads in</span>
<span class="p_add">+	 * spin_unlock_wait() and/or spin_is_locked().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Avoid this by issuing a full memory barrier between the spin_lock()</span>
<span class="p_add">+	 * and the loads in spin_unlock_wait() and spin_is_locked().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that regular mutual exclusion doesn&#39;t care about this</span>
<span class="p_add">+	 * delayed store.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+	return atomic_read(&amp;lock-&gt;val) &amp; _Q_LOCKED_MASK;</span>
 }
 
 /**
<span class="p_chunk">@@ -107,6 +130,8 @@</span> <span class="p_context"> static __always_inline void queued_spin_unlock(struct qspinlock *lock)</span>
  */
 static inline void queued_spin_unlock_wait(struct qspinlock *lock)
 {
<span class="p_add">+	/* See queued_spin_is_locked() */</span>
<span class="p_add">+	smp_mb();</span>
 	while (atomic_read(&amp;lock-&gt;val) &amp; _Q_LOCKED_MASK)
 		cpu_relax();
 }
<span class="p_header">diff --git a/include/asm-generic/siginfo.h b/include/asm-generic/siginfo.h</span>
<span class="p_header">index 3d1a3af5cf59..a2508a8f9a9c 100644</span>
<span class="p_header">--- a/include/asm-generic/siginfo.h</span>
<span class="p_header">+++ b/include/asm-generic/siginfo.h</span>
<span class="p_chunk">@@ -17,21 +17,6 @@</span> <span class="p_context"></span>
 struct siginfo;
 void do_schedule_next_timer(struct siginfo *info);
 
<span class="p_del">-#ifndef HAVE_ARCH_COPY_SIGINFO</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/string.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (from-&gt;si_code &lt; 0)</span>
<span class="p_del">-		memcpy(to, from, sizeof(*to));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* _sigchld is currently the largest know union member */</span>
<span class="p_del">-		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from-&gt;_sifields._sigchld));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int copy_siginfo_to_user(struct siginfo __user *to, const struct siginfo *from);
 
 #endif
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index 735f9f8c4e43..5261751f6bd4 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -40,8 +40,11 @@</span> <span class="p_context"> struct can_priv {</span>
 	struct can_clock clock;
 
 	enum can_state state;
<span class="p_del">-	u32 ctrlmode;</span>
<span class="p_del">-	u32 ctrlmode_supported;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* CAN controller features - see include/uapi/linux/can/netlink.h */</span>
<span class="p_add">+	u32 ctrlmode;		/* current options setting */</span>
<span class="p_add">+	u32 ctrlmode_supported;	/* options that can be modified by netlink */</span>
<span class="p_add">+	u32 ctrlmode_static;	/* static enabled options for driver/hardware */</span>
 
 	int restart_ms;
 	struct timer_list restart_timer;
<span class="p_chunk">@@ -108,6 +111,21 @@</span> <span class="p_context"> static inline bool can_is_canfd_skb(const struct sk_buff *skb)</span>
 	return skb-&gt;len == CANFD_MTU;
 }
 
<span class="p_add">+/* helper to define static CAN controller features at device creation time */</span>
<span class="p_add">+static inline void can_set_static_ctrlmode(struct net_device *dev,</span>
<span class="p_add">+					   u32 static_mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct can_priv *priv = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* alloc_candev() succeeded =&gt; netdev_priv() is valid at this point */</span>
<span class="p_add">+	priv-&gt;ctrlmode = static_mode;</span>
<span class="p_add">+	priv-&gt;ctrlmode_static = static_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* override MTU which was set by default in can_setup()? */</span>
<span class="p_add">+	if (static_mode &amp; CAN_CTRLMODE_FD)</span>
<span class="p_add">+		dev-&gt;mtu = CANFD_MTU;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* get data length from can_dlc with sanitized can_dlc */
 u8 can_dlc2len(u8 can_dlc);
 
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index 92557bbce7e7..d80259afb9e5 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -28,6 +28,21 @@</span> <span class="p_context"> struct sigpending {</span>
 	sigset_t signal;
 };
 
<span class="p_add">+#ifndef HAVE_ARCH_COPY_SIGINFO</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void copy_siginfo(struct siginfo *to, struct siginfo *from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (from-&gt;si_code &lt; 0)</span>
<span class="p_add">+		memcpy(to, from, sizeof(*to));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* _sigchld is currently the largest know union member */</span>
<span class="p_add">+		memcpy(to, from, __ARCH_SI_PREAMBLE_SIZE + sizeof(from-&gt;_sifields._sigchld));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * Define some primitives to manipulate sigset_t.
  */
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 3bf03b6b52e9..83b264c52898 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -338,7 +338,6 @@</span> <span class="p_context"> struct tty_file_private {</span>
 #define TTY_EXCLUSIVE 		3	/* Exclusive open mode */
 #define TTY_DEBUG 		4	/* Debugging */
 #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
<span class="p_del">-#define TTY_OTHER_DONE		6	/* Closed pty has completed input processing */</span>
 #define TTY_LDISC_OPEN	 	11	/* Line discipline is open */
 #define TTY_PTY_LOCK 		16	/* pty private */
 #define TTY_NO_WRITE_SPLIT 	17	/* Preserve write boundaries to driver */
<span class="p_chunk">@@ -469,6 +468,7 @@</span> <span class="p_context"> extern void tty_buffer_init(struct tty_port *port);</span>
 extern void tty_buffer_set_lock_subclass(struct tty_port *port);
 extern bool tty_buffer_restart_work(struct tty_port *port);
 extern bool tty_buffer_cancel_work(struct tty_port *port);
<span class="p_add">+extern void tty_buffer_flush_work(struct tty_port *port);</span>
 extern speed_t tty_termios_baud_rate(struct ktermios *termios);
 extern speed_t tty_termios_input_baud_rate(struct ktermios *termios);
 extern void tty_termios_encode_baud_rate(struct ktermios *termios,
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index b79925dd2b41..12891ffd4bf0 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -1068,7 +1068,7 @@</span> <span class="p_context"> struct usbdrv_wrap {</span>
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver&#39;s disconnect method.
<span class="p_del">- * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs</span>
<span class="p_add">+ * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs</span>
  *	to initiate lower power link state transitions when an idle timeout
  *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index fe89d7cd67b9..4f6ba34cdee6 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -239,6 +239,7 @@</span> <span class="p_context"> scmd_printk(const char *, const struct scsi_cmnd *, const char *, ...);</span>
 enum scsi_target_state {
 	STARGET_CREATED = 1,
 	STARGET_RUNNING,
<span class="p_add">+	STARGET_REMOVE,</span>
 	STARGET_DEL,
 };
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 1e889a078dbc..95e47d2f2c67 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -946,6 +946,7 @@</span> <span class="p_context"> static void put_ctx(struct perf_event_context *ctx)</span>
  * function.
  *
  * Lock order:
<span class="p_add">+ *    cred_guard_mutex</span>
  *	task_struct::perf_event_mutex
  *	  perf_event_context::mutex
  *	    perf_event_context::lock
<span class="p_chunk">@@ -3418,7 +3419,6 @@</span> <span class="p_context"> static struct task_struct *</span>
 find_lively_task_by_vpid(pid_t vpid)
 {
 	struct task_struct *task;
<span class="p_del">-	int err;</span>
 
 	rcu_read_lock();
 	if (!vpid)
<span class="p_chunk">@@ -3432,16 +3432,7 @@</span> <span class="p_context"> find_lively_task_by_vpid(pid_t vpid)</span>
 	if (!task)
 		return ERR_PTR(-ESRCH);
 
<span class="p_del">-	/* Reuse ptrace permission checks for now. */</span>
<span class="p_del">-	err = -EACCES;</span>
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))</span>
<span class="p_del">-		goto errout;</span>
<span class="p_del">-</span>
 	return task;
<span class="p_del">-errout:</span>
<span class="p_del">-	put_task_struct(task);</span>
<span class="p_del">-	return ERR_PTR(err);</span>
<span class="p_del">-</span>
 }
 
 /*
<span class="p_chunk">@@ -8328,6 +8319,24 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 
 	get_online_cpus();
 
<span class="p_add">+	if (task) {</span>
<span class="p_add">+		err = mutex_lock_interruptible(&amp;task-&gt;signal-&gt;cred_guard_mutex);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto err_cpus;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Reuse ptrace permission checks for now.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We must hold cred_guard_mutex across this and any potential</span>
<span class="p_add">+		 * perf_install_in_context() call for this new event to</span>
<span class="p_add">+		 * serialize against exec() altering our credentials (and the</span>
<span class="p_add">+		 * perf_event_exit_task() that could imply).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = -EACCES;</span>
<span class="p_add">+		if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))</span>
<span class="p_add">+			goto err_cred;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (flags &amp; PERF_FLAG_PID_CGROUP)
 		cgroup_fd = pid;
 
<span class="p_chunk">@@ -8335,7 +8344,7 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 				 NULL, NULL, cgroup_fd);
 	if (IS_ERR(event)) {
 		err = PTR_ERR(event);
<span class="p_del">-		goto err_cpus;</span>
<span class="p_add">+		goto err_cred;</span>
 	}
 
 	if (is_sampling_event(event)) {
<span class="p_chunk">@@ -8394,11 +8403,6 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 		goto err_context;
 	}
 
<span class="p_del">-	if (task) {</span>
<span class="p_del">-		put_task_struct(task);</span>
<span class="p_del">-		task = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/*
 	 * Look up the group leader (we will attach this event to it):
 	 */
<span class="p_chunk">@@ -8486,6 +8490,11 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 
 	WARN_ON_ONCE(ctx-&gt;parent_ctx);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This is the point on no return; we cannot fail hereafter. This is</span>
<span class="p_add">+	 * where we start modifying current state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	if (move_group) {
 		/*
 		 * See perf_event_ctx_lock() for comments on the details
<span class="p_chunk">@@ -8555,6 +8564,11 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 		mutex_unlock(&amp;gctx-&gt;mutex);
 	mutex_unlock(&amp;ctx-&gt;mutex);
 
<span class="p_add">+	if (task) {</span>
<span class="p_add">+		mutex_unlock(&amp;task-&gt;signal-&gt;cred_guard_mutex);</span>
<span class="p_add">+		put_task_struct(task);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	put_online_cpus();
 
 	event-&gt;owner = current;
<span class="p_chunk">@@ -8589,6 +8603,9 @@</span> <span class="p_context"> err_alloc:</span>
 	 */
 	if (!event_file)
 		free_event(event);
<span class="p_add">+err_cred:</span>
<span class="p_add">+	if (task)</span>
<span class="p_add">+		mutex_unlock(&amp;task-&gt;signal-&gt;cred_guard_mutex);</span>
 err_cpus:
 	put_online_cpus();
 err_task:
<span class="p_chunk">@@ -8868,6 +8885,9 @@</span> <span class="p_context"> static void perf_event_exit_task_context(struct task_struct *child, int ctxn)</span>
 
 /*
  * When a child task exits, feed back event values to parent events.
<span class="p_add">+ *</span>
<span class="p_add">+ * Can be called with cred_guard_mutex held when called from</span>
<span class="p_add">+ * install_exec_creds().</span>
  */
 void perf_event_exit_task(struct task_struct *child)
 {
<span class="p_header">diff --git a/kernel/sched/loadavg.c b/kernel/sched/loadavg.c</span>
<span class="p_header">index ef7159012cf3..b0b93fd33af9 100644</span>
<span class="p_header">--- a/kernel/sched/loadavg.c</span>
<span class="p_header">+++ b/kernel/sched/loadavg.c</span>
<span class="p_chunk">@@ -99,10 +99,13 @@</span> <span class="p_context"> long calc_load_fold_active(struct rq *this_rq)</span>
 static unsigned long
 calc_load(unsigned long load, unsigned long exp, unsigned long active)
 {
<span class="p_del">-	load *= exp;</span>
<span class="p_del">-	load += active * (FIXED_1 - exp);</span>
<span class="p_del">-	load += 1UL &lt;&lt; (FSHIFT - 1);</span>
<span class="p_del">-	return load &gt;&gt; FSHIFT;</span>
<span class="p_add">+	unsigned long newload;</span>
<span class="p_add">+</span>
<span class="p_add">+	newload = load * exp + active * (FIXED_1 - exp);</span>
<span class="p_add">+	if (active &gt;= load)</span>
<span class="p_add">+		newload += FIXED_1-1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return newload / FIXED_1;</span>
 }
 
 #ifdef CONFIG_NO_HZ_COMMON
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 9c6045a27ba3..acbb0e73d3a2 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	raw_spinlock_t			reader_lock;	/* serialize readers */
 	arch_spinlock_t			lock;
 	struct lock_class_key		lock_key;
<span class="p_del">-	unsigned int			nr_pages;</span>
<span class="p_add">+	unsigned long			nr_pages;</span>
 	unsigned int			current_context;
 	struct list_head		*pages;
 	struct buffer_page		*head_page;	/* read from head */
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	u64				write_stamp;
 	u64				read_stamp;
 	/* ring buffer pages to update, &gt; 0 to add, &lt; 0 to remove */
<span class="p_del">-	int				nr_pages_to_update;</span>
<span class="p_add">+	long				nr_pages_to_update;</span>
 	struct list_head		new_pages; /* new pages to add */
 	struct work_struct		update_pages_work;
 	struct completion		update_done;
<span class="p_chunk">@@ -1137,10 +1137,10 @@</span> <span class="p_context"> static int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	return 0;
 }
 
<span class="p_del">-static int __rb_allocate_pages(int nr_pages, struct list_head *pages, int cpu)</span>
<span class="p_add">+static int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)</span>
 {
<span class="p_del">-	int i;</span>
 	struct buffer_page *bpage, *tmp;
<span class="p_add">+	long i;</span>
 
 	for (i = 0; i &lt; nr_pages; i++) {
 		struct page *page;
<span class="p_chunk">@@ -1177,7 +1177,7 @@</span> <span class="p_context"> free_pages:</span>
 }
 
 static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
<span class="p_del">-			     unsigned nr_pages)</span>
<span class="p_add">+			     unsigned long nr_pages)</span>
 {
 	LIST_HEAD(pages);
 
<span class="p_chunk">@@ -1202,7 +1202,7 @@</span> <span class="p_context"> static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,</span>
 }
 
 static struct ring_buffer_per_cpu *
<span class="p_del">-rb_allocate_cpu_buffer(struct ring_buffer *buffer, int nr_pages, int cpu)</span>
<span class="p_add">+rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)</span>
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	struct buffer_page *bpage;
<span class="p_chunk">@@ -1302,8 +1302,9 @@</span> <span class="p_context"> struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span>
 					struct lock_class_key *key)
 {
 	struct ring_buffer *buffer;
<span class="p_add">+	long nr_pages;</span>
 	int bsize;
<span class="p_del">-	int cpu, nr_pages;</span>
<span class="p_add">+	int cpu;</span>
 
 	/* keep it in its own cache line */
 	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),
<span class="p_chunk">@@ -1429,12 +1430,12 @@</span> <span class="p_context"> static inline unsigned long rb_page_write(struct buffer_page *bpage)</span>
 }
 
 static int
<span class="p_del">-rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned int nr_pages)</span>
<span class="p_add">+rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)</span>
 {
 	struct list_head *tail_page, *to_remove, *next_page;
 	struct buffer_page *to_remove_page, *tmp_iter_page;
 	struct buffer_page *last_page, *first_page;
<span class="p_del">-	unsigned int nr_removed;</span>
<span class="p_add">+	unsigned long nr_removed;</span>
 	unsigned long head_bit;
 	int page_entries;
 
<span class="p_chunk">@@ -1651,7 +1652,7 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
<span class="p_del">-	unsigned nr_pages;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 	int cpu, err = 0;
 
 	/*
<span class="p_chunk">@@ -1665,14 +1666,13 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 	    !cpumask_test_cpu(cpu_id, buffer-&gt;cpumask))
 		return size;
 
<span class="p_del">-	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_del">-	size *= BUF_PAGE_SIZE;</span>
<span class="p_add">+	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
 
 	/* we need a minimum of two pages */
<span class="p_del">-	if (size &lt; BUF_PAGE_SIZE * 2)</span>
<span class="p_del">-		size = BUF_PAGE_SIZE * 2;</span>
<span class="p_add">+	if (nr_pages &lt; 2)</span>
<span class="p_add">+		nr_pages = 2;</span>
 
<span class="p_del">-	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_add">+	size = nr_pages * BUF_PAGE_SIZE;</span>
 
 	/*
 	 * Don&#39;t succeed if resizing is disabled, as a reader might be
<span class="p_chunk">@@ -4645,8 +4645,9 @@</span> <span class="p_context"> static int rb_cpu_notify(struct notifier_block *self,</span>
 	struct ring_buffer *buffer =
 		container_of(self, struct ring_buffer, cpu_notify);
 	long cpu = (long)hcpu;
<span class="p_del">-	int cpu_i, nr_pages_same;</span>
<span class="p_del">-	unsigned int nr_pages;</span>
<span class="p_add">+	long nr_pages_same;</span>
<span class="p_add">+	int cpu_i;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 
 	switch (action) {
 	case CPU_UP_PREPARE:
<span class="p_header">diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn</span>
<span class="p_header">index 4efedcbe4165..da3386a9d244 100644</span>
<span class="p_header">--- a/scripts/Makefile.extrawarn</span>
<span class="p_header">+++ b/scripts/Makefile.extrawarn</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> warning-1 += $(call cc-option, -Wmissing-prototypes)</span>
 warning-1 += -Wold-style-definition
 warning-1 += $(call cc-option, -Wmissing-include-dirs)
 warning-1 += $(call cc-option, -Wunused-but-set-variable)
<span class="p_add">+warning-1 += $(call cc-option, -Wunused-const-variable)</span>
 warning-1 += $(call cc-disable-warning, missing-field-initializers)
 
 warning-2 := -Waggregate-return
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 4918ffa5ba68..d53c25e7a1c1 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -335,6 +335,7 @@</span> <span class="p_context"> static void alc_fill_eapd_coef(struct hda_codec *codec)</span>
 	case 0x10ec0283:
 	case 0x10ec0286:
 	case 0x10ec0288:
<span class="p_add">+	case 0x10ec0295:</span>
 	case 0x10ec0298:
 		alc_update_coef_idx(codec, 0x10, 1&lt;&lt;9, 0);
 		break;
<span class="p_chunk">@@ -342,6 +343,11 @@</span> <span class="p_context"> static void alc_fill_eapd_coef(struct hda_codec *codec)</span>
 	case 0x10ec0293:
 		alc_update_coef_idx(codec, 0xa, 1&lt;&lt;13, 0);
 		break;
<span class="p_add">+	case 0x10ec0234:</span>
<span class="p_add">+	case 0x10ec0274:</span>
<span class="p_add">+	case 0x10ec0294:</span>
<span class="p_add">+		alc_update_coef_idx(codec, 0x10, 1&lt;&lt;15, 0);</span>
<span class="p_add">+		break;</span>
 	case 0x10ec0662:
 		if ((coef &amp; 0x00f0) == 0x0030)
 			alc_update_coef_idx(codec, 0x4, 1&lt;&lt;10, 0); /* EAPD Ctrl */
<span class="p_chunk">@@ -902,6 +908,7 @@</span> <span class="p_context"> static struct alc_codec_rename_pci_table rename_pci_tbl[] = {</span>
 	{ 0x10ec0298, 0x1028, 0, &quot;ALC3266&quot; },
 	{ 0x10ec0256, 0x1028, 0, &quot;ALC3246&quot; },
 	{ 0x10ec0225, 0x1028, 0, &quot;ALC3253&quot; },
<span class="p_add">+	{ 0x10ec0295, 0x1028, 0, &quot;ALC3254&quot; },</span>
 	{ 0x10ec0670, 0x1025, 0, &quot;ALC669X&quot; },
 	{ 0x10ec0676, 0x1025, 0, &quot;ALC679X&quot; },
 	{ 0x10ec0282, 0x1043, 0, &quot;ALC3229&quot; },
<span class="p_chunk">@@ -2647,6 +2654,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_TYPE_ALC255,
 	ALC269_TYPE_ALC256,
 	ALC269_TYPE_ALC225,
<span class="p_add">+	ALC269_TYPE_ALC294,</span>
 };
 
 /*
<span class="p_chunk">@@ -2677,6 +2685,7 @@</span> <span class="p_context"> static int alc269_parse_auto_config(struct hda_codec *codec)</span>
 	case ALC269_TYPE_ALC255:
 	case ALC269_TYPE_ALC256:
 	case ALC269_TYPE_ALC225:
<span class="p_add">+	case ALC269_TYPE_ALC294:</span>
 		ssids = alc269_ssids;
 		break;
 	default:
<span class="p_chunk">@@ -3690,6 +3699,7 @@</span> <span class="p_context"> static void alc_headset_mode_unplugged(struct hda_codec *codec)</span>
 		alc_process_coef_fw(codec, coef0668);
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_process_coef_fw(codec, coef0225);
 		break;
 	}
<span class="p_chunk">@@ -3790,6 +3800,7 @@</span> <span class="p_context"> static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,</span>
 		snd_hda_set_pin_ctl_cache(codec, mic_pin, PIN_VREF50);
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_update_coef_idx(codec, 0x45, 0x3f&lt;&lt;10, 0x31&lt;&lt;10);
 		snd_hda_set_pin_ctl_cache(codec, hp_pin, 0);
 		alc_process_coef_fw(codec, coef0225);
<span class="p_chunk">@@ -3847,6 +3858,7 @@</span> <span class="p_context"> static void alc_headset_mode_default(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_process_coef_fw(codec, coef0225);
 		break;
 	case 0x10ec0255:
<span class="p_chunk">@@ -3950,6 +3962,7 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 		alc_process_coef_fw(codec, coef0688);
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_process_coef_fw(codec, coef0225);
 		break;
 	}
<span class="p_chunk">@@ -4031,6 +4044,7 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 		alc_process_coef_fw(codec, coef0688);
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_process_coef_fw(codec, coef0225);
 		break;
 	}
<span class="p_chunk">@@ -4114,6 +4128,7 @@</span> <span class="p_context"> static void alc_determine_headset_type(struct hda_codec *codec)</span>
 		is_ctia = (val &amp; 0x1c02) == 0x1c02;
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		alc_process_coef_fw(codec, coef0225);
 		msleep(800);
 		val = alc_read_coef_idx(codec, 0x46);
<span class="p_chunk">@@ -5459,8 +5474,9 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x06de, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
 	SND_PCI_QUIRK(0x1028, 0x06df, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
 	SND_PCI_QUIRK(0x1028, 0x06e0, &quot;Dell&quot;, ALC293_FIXUP_DISABLE_AAMIX_MULTIJACK),
<span class="p_del">-	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13 9350&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x0725, &quot;Dell Inspiron 3162&quot;, ALC255_FIXUP_DELL_SPK_NOISE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x075b, &quot;Dell XPS 13 9360&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -5704,6 +5720,9 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170110},
 		{0x21, 0x02211020}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x12, 0x90a60140},
 		{0x14, 0x90170110},
 		{0x21, 0x02211020}),
<span class="p_chunk">@@ -6026,8 +6045,14 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 		alc_update_coef_idx(codec, 0x36, 1 &lt;&lt; 13, 1 &lt;&lt; 5); /* Switch pcbeep path to Line in path*/
 		break;
 	case 0x10ec0225:
<span class="p_add">+	case 0x10ec0295:</span>
 		spec-&gt;codec_variant = ALC269_TYPE_ALC225;
 		break;
<span class="p_add">+	case 0x10ec0234:</span>
<span class="p_add">+	case 0x10ec0274:</span>
<span class="p_add">+	case 0x10ec0294:</span>
<span class="p_add">+		spec-&gt;codec_variant = ALC269_TYPE_ALC294;</span>
<span class="p_add">+		break;</span>
 	}
 
 	if (snd_hda_codec_read(codec, 0x51, 0, AC_VERB_PARAMETERS, 0) == 0x10ec5505) {
<span class="p_chunk">@@ -6942,6 +6967,7 @@</span> <span class="p_context"> static const struct hda_device_id snd_hda_id_realtek[] = {</span>
 	HDA_CODEC_ENTRY(0x10ec0225, &quot;ALC225&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0231, &quot;ALC231&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0233, &quot;ALC233&quot;, patch_alc269),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0234, &quot;ALC234&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0235, &quot;ALC233&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0255, &quot;ALC255&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0256, &quot;ALC256&quot;, patch_alc269),
<span class="p_chunk">@@ -6952,6 +6978,7 @@</span> <span class="p_context"> static const struct hda_device_id snd_hda_id_realtek[] = {</span>
 	HDA_CODEC_ENTRY(0x10ec0269, &quot;ALC269&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0270, &quot;ALC270&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0272, &quot;ALC272&quot;, patch_alc662),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0274, &quot;ALC274&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0275, &quot;ALC275&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0276, &quot;ALC276&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0280, &quot;ALC280&quot;, patch_alc269),
<span class="p_chunk">@@ -6964,6 +6991,8 @@</span> <span class="p_context"> static const struct hda_device_id snd_hda_id_realtek[] = {</span>
 	HDA_CODEC_ENTRY(0x10ec0290, &quot;ALC290&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0292, &quot;ALC292&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0293, &quot;ALC293&quot;, patch_alc269),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0294, &quot;ALC294&quot;, patch_alc269),</span>
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0295, &quot;ALC295&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0298, &quot;ALC298&quot;, patch_alc269),
 	HDA_CODEC_REV_ENTRY(0x10ec0861, 0x100340, &quot;ALC660&quot;, patch_alc861),
 	HDA_CODEC_ENTRY(0x10ec0660, &quot;ALC660-VD&quot;, patch_alc861vd),
<span class="p_header">diff --git a/tools/perf/tests/bpf.c b/tools/perf/tests/bpf.c</span>
<span class="p_header">index ec16f7812c8b..6ebfdee3e2c6 100644</span>
<span class="p_header">--- a/tools/perf/tests/bpf.c</span>
<span class="p_header">+++ b/tools/perf/tests/bpf.c</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> prepare_bpf(void *obj_buf, size_t obj_buf_sz, const char *name)</span>
 	return obj;
 }
 
<span class="p_del">-static int __test__bpf(int index)</span>
<span class="p_add">+static int __test__bpf(int idx)</span>
 {
 	int ret;
 	void *obj_buf;
<span class="p_chunk">@@ -154,27 +154,27 @@</span> <span class="p_context"> static int __test__bpf(int index)</span>
 	struct bpf_object *obj;
 
 	ret = test_llvm__fetch_bpf_obj(&amp;obj_buf, &amp;obj_buf_sz,
<span class="p_del">-				       bpf_testcase_table[index].prog_id,</span>
<span class="p_add">+				       bpf_testcase_table[idx].prog_id,</span>
 				       true);
 	if (ret != TEST_OK || !obj_buf || !obj_buf_sz) {
 		pr_debug(&quot;Unable to get BPF object, %s\n&quot;,
<span class="p_del">-			 bpf_testcase_table[index].msg_compile_fail);</span>
<span class="p_del">-		if (index == 0)</span>
<span class="p_add">+			 bpf_testcase_table[idx].msg_compile_fail);</span>
<span class="p_add">+		if (idx == 0)</span>
 			return TEST_SKIP;
 		else
 			return TEST_FAIL;
 	}
 
 	obj = prepare_bpf(obj_buf, obj_buf_sz,
<span class="p_del">-			  bpf_testcase_table[index].name);</span>
<span class="p_add">+			  bpf_testcase_table[idx].name);</span>
 	if (!obj) {
 		ret = TEST_FAIL;
 		goto out;
 	}
 
 	ret = do_test(obj,
<span class="p_del">-		      bpf_testcase_table[index].target_func,</span>
<span class="p_del">-		      bpf_testcase_table[index].expect_result);</span>
<span class="p_add">+		      bpf_testcase_table[idx].target_func,</span>
<span class="p_add">+		      bpf_testcase_table[idx].expect_result);</span>
 out:
 	bpf__clear();
 	return ret;
<span class="p_header">diff --git a/tools/perf/tests/llvm.c b/tools/perf/tests/llvm.c</span>
<span class="p_header">index bc4cf507cde5..366e38ba8b49 100644</span>
<span class="p_header">--- a/tools/perf/tests/llvm.c</span>
<span class="p_header">+++ b/tools/perf/tests/llvm.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> static struct {</span>
 int
 test_llvm__fetch_bpf_obj(void **p_obj_buf,
 			 size_t *p_obj_buf_sz,
<span class="p_del">-			 enum test_llvm__testcase index,</span>
<span class="p_add">+			 enum test_llvm__testcase idx,</span>
 			 bool force)
 {
 	const char *source;
<span class="p_chunk">@@ -59,11 +59,11 @@</span> <span class="p_context"> test_llvm__fetch_bpf_obj(void **p_obj_buf,</span>
 	char *tmpl_new = NULL, *clang_opt_new = NULL;
 	int err, old_verbose, ret = TEST_FAIL;
 
<span class="p_del">-	if (index &gt;= __LLVM_TESTCASE_MAX)</span>
<span class="p_add">+	if (idx &gt;= __LLVM_TESTCASE_MAX)</span>
 		return TEST_FAIL;
 
<span class="p_del">-	source = bpf_source_table[index].source;</span>
<span class="p_del">-	desc = bpf_source_table[index].desc;</span>
<span class="p_add">+	source = bpf_source_table[idx].source;</span>
<span class="p_add">+	desc = bpf_source_table[idx].desc;</span>
 
 	perf_config(perf_config_cb, NULL);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



