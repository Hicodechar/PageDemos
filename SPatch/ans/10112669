
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,for,4.16,02/21] rseq: Introduce restartable sequences system call (v12) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,for,4.16,02/21] rseq: Introduce restartable sequences system call (v12)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 14, 2017, 4:13 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171214161403.30643-3-mathieu.desnoyers@efficios.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10112669/mbox/"
   >mbox</a>
|
   <a href="/patch/10112669/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10112669/">/patch/10112669/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	97FF36019C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 16:20:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8200929B48
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 16:20:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7459B29B7D; Thu, 14 Dec 2017 16:20:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 53C7429BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 16:20:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753789AbdLNQUa convert rfc822-to-8bit (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Dec 2017 11:20:30 -0500
Received: from mail.efficios.com ([167.114.142.141]:55988 &quot;EHLO
	mail.efficios.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753358AbdLNQOs (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Dec 2017 11:14:48 -0500
Received: from localhost (localhost.localdomain [127.0.0.1])
	by mail.efficios.com (Postfix) with ESMTP id EB3E334042C;
	Thu, 14 Dec 2017 16:17:00 +0000 (UTC)
Received: from mail.efficios.com ([127.0.0.1])
	by localhost (evm-mail-1.efficios.com [127.0.0.1]) (amavisd-new,
	port 10032)
	with ESMTP id M8b7TKV7hR5z; Thu, 14 Dec 2017 16:16:45 +0000 (UTC)
Received: from localhost (localhost.localdomain [127.0.0.1])
	by mail.efficios.com (Postfix) with ESMTP id DA19234040B;
	Thu, 14 Dec 2017 16:16:45 +0000 (UTC)
X-Virus-Scanned: amavisd-new at efficios.com
Received: from mail.efficios.com ([127.0.0.1])
	by localhost (evm-mail-1.efficios.com [127.0.0.1]) (amavisd-new,
	port 10026)
	with ESMTP id RtBECHMT7d2K; Thu, 14 Dec 2017 16:16:45 +0000 (UTC)
Received: from thinkos.internal.efficios.com
	(192-222-157-41.qc.cable.ebox.net [192.222.157.41])
	by mail.efficios.com (Postfix) with ESMTPSA id 660A034012E;
	Thu, 14 Dec 2017 16:16:45 +0000 (UTC)
From: Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;
To: Peter Zijlstra &lt;peterz@infradead.org&gt;,
	&quot;Paul E . McKenney&quot; &lt;paulmck@linux.vnet.ibm.com&gt;,
	Boqun Feng &lt;boqun.feng@gmail.com&gt;, Andy Lutomirski &lt;luto@amacapital.net&gt;,
	Dave Watson &lt;davejwatson@fb.com&gt;
Cc: linux-kernel@vger.kernel.org, linux-api@vger.kernel.org,
	Paul Turner &lt;pjt@google.com&gt;, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Russell King &lt;linux@arm.linux.org.uk&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	&quot;H . Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Andrew Hunter &lt;ahh@google.com&gt;,
	Andi Kleen &lt;andi@firstfloor.org&gt;, Chris Lameter &lt;cl@linux.com&gt;,
	Ben Maurer &lt;bmaurer@fb.com&gt;, Steven Rostedt &lt;rostedt@goodmis.org&gt;,
	Josh Triplett &lt;josh@joshtriplett.org&gt;,
	Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	Will Deacon &lt;will.deacon@arm.com&gt;,
	Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;,
	Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;,
	Alexander Viro &lt;viro@zeniv.linux.org.uk&gt;
Subject: [RFC PATCH for 4.16 02/21] rseq: Introduce restartable sequences
	system call (v12)
Date: Thu, 14 Dec 2017 11:13:44 -0500
Message-Id: &lt;20171214161403.30643-3-mathieu.desnoyers@efficios.com&gt;
X-Mailer: git-send-email 2.11.0
In-Reply-To: &lt;20171214161403.30643-1-mathieu.desnoyers@efficios.com&gt;
References: &lt;20171214161403.30643-1-mathieu.desnoyers@efficios.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8BIT
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a> - Dec. 14, 2017, 4:13 p.m.</div>
<pre class="content">
Expose a new system call allowing each thread to register one userspace
memory area to be used as an ABI between kernel and user-space for two
purposes: user-space restartable sequences and quick access to read the
current CPU number value from user-space.

* Restartable sequences (per-cpu atomics)

Restartables sequences allow user-space to perform update operations on
per-cpu data without requiring heavy-weight atomic operations.

The restartable critical sections (percpu atomics) work has been started
by Paul Turner and Andrew Hunter. It lets the kernel handle restart of
critical sections. [1] [2] The re-implementation proposed here brings a
few simplifications to the ABI which facilitates porting to other
architectures and speeds up the user-space fast path. A second system
call, cpu_opv(), is proposed as fallback to deal with debugger
single-stepping. cpu_opv() executes a sequence of operations on behalf
of user-space with preemption disabled.

Here are benchmarks of various rseq use-cases.

Test hardware:

arm32: ARMv7 Processor rev 4 (v7l) &quot;Cubietruck&quot;, 2-core
x86-64: Intel E5-2630 v3@2.40GHz, 16-core, hyperthreading

The following benchmarks were all performed on a single thread.

* Per-CPU statistic counter increment

                getcpu+atomic (ns/op)    rseq (ns/op)    speedup
arm32:                344.0                 31.4          11.0
x86-64:                15.3                  2.0           7.7

* LTTng-UST: write event 32-bit header, 32-bit payload into tracer
             per-cpu buffer

                getcpu+atomic (ns/op)    rseq (ns/op)    speedup
arm32:               2502.0                 2250.0         1.1
x86-64:               117.4                   98.0         1.2

* liburcu percpu: lock-unlock pair, dereference, read/compare word

                getcpu+atomic (ns/op)    rseq (ns/op)    speedup
arm32:                751.0                 128.5          5.8
x86-64:                53.4                  28.6          1.9

* jemalloc memory allocator adapted to use rseq

Using rseq with per-cpu memory pools in jemalloc at Facebook (based on
rseq 2016 implementation):

The production workload response-time has 1-2% gain avg. latency, and
the P99 overall latency drops by 2-3%.

* Reading the current CPU number

Speeding up reading the current CPU number on which the caller thread is
running is done by keeping the current CPU number up do date within the
cpu_id field of the memory area registered by the thread. This is done
by making scheduler preemption set the TIF_NOTIFY_RESUME flag on the
current thread. Upon return to user-space, a notify-resume handler
updates the current CPU value within the registered user-space memory
area. User-space can then read the current CPU number directly from
memory.

Keeping the current cpu id in a memory area shared between kernel and
user-space is an improvement over current mechanisms available to read
the current CPU number, which has the following benefits over
alternative approaches:

- 35x speedup on ARM vs system call through glibc
- 20x speedup on x86 compared to calling glibc, which calls vdso
  executing a &quot;lsl&quot; instruction,
- 14x speedup on x86 compared to inlined &quot;lsl&quot; instruction,
- Unlike vdso approaches, this cpu_id value can be read from an inline
  assembly, which makes it a useful building block for restartable
  sequences.
- The approach of reading the cpu id through memory mapping shared
  between kernel and user-space is portable (e.g. ARM), which is not the
  case for the lsl-based x86 vdso.

On x86, yet another possible approach would be to use the gs segment
selector to point to user-space per-cpu data. This approach performs
similarly to the cpu id cache, but it has two disadvantages: it is
not portable, and it is incompatible with existing applications already
using the gs segment selector for other purposes.

Benchmarking various approaches for reading the current CPU number:

ARMv7 Processor rev 4 (v7l)
Machine model: Cubietruck
- Baseline (empty loop):                                    8.4 ns
- Read CPU from rseq cpu_id:                               16.7 ns
- Read CPU from rseq cpu_id (lazy register):               19.8 ns
- glibc 2.19-0ubuntu6.6 getcpu:                           301.8 ns
- getcpu system call:                                     234.9 ns

x86-64 Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz:
- Baseline (empty loop):                                    0.8 ns
- Read CPU from rseq cpu_id:                                0.8 ns
- Read CPU from rseq cpu_id (lazy register):                0.8 ns
- Read using gs segment selector:                           0.8 ns
- &quot;lsl&quot; inline assembly:                                   13.0 ns
- glibc 2.19-0ubuntu6 getcpu:                              16.6 ns
- getcpu system call:                                      53.9 ns

- Speed (benchmark taken on v8 of patchset)

Running 10 runs of hackbench -l 100000 seems to indicate, contrary to
expectations, that enabling CONFIG_RSEQ slightly accelerates the
scheduler:

Configuration: 2 sockets * 8-core Intel(R) Xeon(R) CPU E5-2630 v3 @
2.40GHz (directly on hardware, hyperthreading disabled in BIOS, energy
saving disabled in BIOS, turboboost disabled in BIOS, cpuidle.off=1
kernel parameter), with a Linux v4.6 defconfig+localyesconfig,
restartable sequences series applied.

* CONFIG_RSEQ=n

avg.:      41.37 s
std.dev.:   0.36 s

* CONFIG_RSEQ=y

avg.:      40.46 s
std.dev.:   0.33 s

- Size

On x86-64, between CONFIG_RSEQ=n/y, the text size increase of vmlinux is
567 bytes, and the data size increase of vmlinux is 5696 bytes.

On x86-64, between CONFIG_CPU_OPV=n/y, the text size increase of vmlinux is
5576 bytes, and the data size increase of vmlinux is 6164 bytes.

[1] https://lwn.net/Articles/650333/
[2] http://www.linuxplumbersconf.org/2013/ocw/system/presentations/1695/original/LPC%20-%20PerCpu%20Atomics.pdf

Link: http://lkml.kernel.org/r/20151027235635.16059.11630.stgit@pjt-glaptop.roam.corp.google.com
Link: http://lkml.kernel.org/r/20150624222609.6116.86035.stgit@kitami.mtv.corp.google.com
<span class="signed-off-by">Signed-off-by: Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;</span>
CC: Thomas Gleixner &lt;tglx@linutronix.de&gt;
CC: Paul Turner &lt;pjt@google.com&gt;
CC: Andrew Hunter &lt;ahh@google.com&gt;
CC: Peter Zijlstra &lt;peterz@infradead.org&gt;
CC: Andy Lutomirski &lt;luto@amacapital.net&gt;
CC: Andi Kleen &lt;andi@firstfloor.org&gt;
CC: Dave Watson &lt;davejwatson@fb.com&gt;
CC: Chris Lameter &lt;cl@linux.com&gt;
CC: Ingo Molnar &lt;mingo@redhat.com&gt;
CC: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
CC: Ben Maurer &lt;bmaurer@fb.com&gt;
CC: Steven Rostedt &lt;rostedt@goodmis.org&gt;
CC: &quot;Paul E. McKenney&quot; &lt;paulmck@linux.vnet.ibm.com&gt;
CC: Josh Triplett &lt;josh@joshtriplett.org&gt;
CC: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
CC: Andrew Morton &lt;akpm@linux-foundation.org&gt;
CC: Russell King &lt;linux@arm.linux.org.uk&gt;
CC: Catalin Marinas &lt;catalin.marinas@arm.com&gt;
CC: Will Deacon &lt;will.deacon@arm.com&gt;
CC: Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;
CC: Boqun Feng &lt;boqun.feng@gmail.com&gt;
CC: Alexander Viro &lt;viro@zeniv.linux.org.uk&gt;
CC: linux-api@vger.kernel.org
---

Changes since v1:
- Return -1, errno=EINVAL if cpu_cache pointer is not aligned on
  sizeof(int32_t).
- Update man page to describe the pointer alignement requirements and
  update atomicity guarantees.
- Add MAINTAINERS file GETCPU_CACHE entry.
- Remove dynamic memory allocation: go back to having a single
  getcpu_cache entry per thread. Update documentation accordingly.
- Rebased on Linux 4.4.

Changes since v2:
- Introduce a &quot;cmd&quot; argument, along with an enum with GETCPU_CACHE_GET
  and GETCPU_CACHE_SET. Introduce a uapi header linux/getcpu_cache.h
  defining this enumeration.
- Split resume notifier architecture implementation from the system call
  wire up in the following arch-specific patches.
- Man pages updates.
- Handle 32-bit compat pointers.
- Simplify handling of getcpu_cache GETCPU_CACHE_SET compiler barrier:
  set the current cpu cache pointer before doing the cache update, and
  set it back to NULL if the update fails. Setting it back to NULL on
  error ensures that no resume notifier will trigger a SIGSEGV if a
  migration happened concurrently.

Changes since v3:
- Fix __user annotations in compat code,
- Update memory ordering comments.
- Rebased on kernel v4.5-rc5.

Changes since v4:
- Inline getcpu_cache_fork, getcpu_cache_execve, and getcpu_cache_exit.
- Add new line between if() and switch() to improve readability.
- Added sched switch benchmarks (hackbench) and size overhead comparison
  to change log.

Changes since v5:
- Rename &quot;getcpu_cache&quot; to &quot;thread_local_abi&quot;, allowing to extend
  this system call to cover future features such as restartable critical
  sections. Generalizing this system call ensures that we can add
  features similar to the cpu_id field within the same cache-line
  without having to track one pointer per feature within the task
  struct.
- Add a tlabi_nr parameter to the system call, thus allowing to extend
  the ABI beyond the initial 64-byte structure by registering structures
  with tlabi_nr greater than 0. The initial ABI structure is associated
  with tlabi_nr 0.
- Rebased on kernel v4.5.

Changes since v6:
- Integrate &quot;restartable sequences&quot; v2 patchset from Paul Turner.
- Add handling of single-stepping purely in user-space, with a
  fallback to locking after 2 rseq failures to ensure progress, and
  by exposing a __rseq_table section to debuggers so they know where
  to put breakpoints when dealing with rseq assembly blocks which
  can be aborted at any point.
- make the code and ABI generic: porting the kernel implementation
  simply requires to wire up the signal handler and return to user-space
  hooks, and allocate the syscall number.
- extend testing with a fully configurable test program. See
  param_spinlock_test -h for details.
- handling of rseq ENOSYS in user-space, also with a fallback
  to locking.
- modify Paul Turner&#39;s rseq ABI to only require a single TLS store on
  the user-space fast-path, removing the need to populate two additional
  registers. This is made possible by introducing struct rseq_cs into
  the ABI to describe a critical section start_ip, post_commit_ip, and
  abort_ip.
- Rebased on kernel v4.7-rc7.

Changes since v7:
- Documentation updates.
- Integrated powerpc architecture support.
- Compare rseq critical section start_ip, allows shriking the user-space
  fast-path code size.
- Added Peter Zijlstra, Paul E. McKenney and Boqun Feng as
  co-maintainers.
- Added do_rseq2 and do_rseq_memcpy to test program helper library.
- Code cleanup based on review from Peter Zijlstra, Andy Lutomirski and
  Boqun Feng.
- Rebase on kernel v4.8-rc2.

Changes since v8:
- clear rseq_cs even if non-nested. Speeds up user-space fast path by
  removing the final &quot;rseq_cs=NULL&quot; assignment.
- add enum rseq_flags: critical sections and threads can set migration,
  preemption and signal &quot;disable&quot; flags to inhibit rseq behavior.
- rseq_event_counter needs to be updated with a pre-increment: Otherwise
  misses an increment after exec (when TLS and in-kernel states are
  initially 0).

Changes since v9:
- Update changelog.
- Fold instrumentation patch.
- check abort-ip signature: Add a signature before the abort-ip landing
  address. This signature is also received as a new parameter to the
  rseq system call. The kernel uses it ensures that rseq cannot be used
  as an exploit vector to redirect execution to arbitrary code.
- Use rseq pointer for both register and unregister. This is more
  symmetric, and eventually allow supporting a linked list of rseq
  struct per thread if needed in the future.
- Unregistration of a rseq structure is now done with
  RSEQ_FLAG_UNREGISTER.
- Remove reference counting. Return &quot;EBUSY&quot; to the caller if rseq is
  already registered for the current thread. This simplifies
  implementation while still allowing user-space to perform lazy
  registration in multi-lib use-cases. (suggested by Ben Maurer)
- Clear rseq_cs upon unregister.
- Set cpu_id back to -1 on unregister, so if rseq user libraries follow
  an unregister, and they expect to lazily register rseq, they can do
  so.
- Document rseq_cs clear requirement: JIT should reset the rseq_cs
  pointer before reclaiming memory of rseq_cs structure.
- Introduce rseq_len syscall parameter, rseq_cs version field:
  Allow keeping track of the registered rseq struct length, for future
  extensions. Add rseq_cs version as first field. Will allow future
  extensions.
- Use offset and unsigned arithmetic to save a branch:  Save a
  conditional branch when comparing instruction pointer against a
  rseq_cs descriptor&#39;s address range by having post_commit_ip as an
  offset from start_ip, and using unsigned integer comparison.
  Suggested by Ben Maurer.
- Remove event counter from ABI. Suggested by Andy Lutomirski.
- Add INIT_ONSTACK macro: Introduce the
  RSEQ_FIELD_u32_u64_INIT_ONSTACK() macros to ensure that users
  correctly initialize the upper bits of RSEQ_FIELD_u32_u64() on their
  stack to 0 on 32-bit architectures.
- Select MEMBARRIER: Allows user-space rseq fast-paths to use the value
  of cpu_id field (inherently required by the rseq algorithm) to figure
  out whether membarrier can be expected to be available.
  This effectively allows user-space fast-paths to remove extra
  comparisons and branch testing whether membarrier is enabled, and thus
  whether a full barrier is required (e.g. in userspace RCU
  implementation after rcu_read_lock/before rcu_read_unlock).
- Expose cpu_id_start field: Checking whether the (cpu_id &lt; 0) in the C
  preparation part of the rseq fast-path brings significant overhead at
  least on arm32. We can remove this extra comparison by exposing two
  distinct cpu_id fields in the rseq TLS:

  The field cpu_id_start always contain a *possible* cpu number, although
  it may not be the current one if, for instance, rseq is not initialized
  for the current thread. cpu_id_start is meant to be used in the C code
  for the pointer chasing to figure out which per-cpu data structure
  should be passed to the rseq asm sequence.

  The field cpu_id values -1 means rseq is not initialized, and -2 means
  initialization failed. That field is used in the rseq asm sequence to
  confirm that the cpu_id_start value was indeed the current cpu number.
  It also ends up confirming that rseq is initialized for the current
  thread, because values -1 and -2 will never match the cpu_id_start
  possible cpu number values.

  This allows checking the current CPU number and rseq initialization
  state with a single comparison on the fast-path.

Changes since v10:

- Update rseq.c comment, removing reference to event_counter.

Changes since v11:

- Replace task struct rseq_preempt, rseq_signal, and rseq_migrate
  bool by u32 rseq_event_mask.
- Add missing sys_rseq() asmlinkage declaration to
  include/linux/syscalls.h.
- Copy event mask on process fork, set to 0 on exec and thread-fork.
- Cleanups based on review from Peter Zijlstra.
- Cleanups based on review from Thomas Gleixner.
- Fix: rseq_cs needs to be cleared only when:
  - Nested over non-critical-section userspace code,
  - Nested over rseq_cs _and_ handling abort.
  Basically, we should never clear rseq_cs when the rseq resume to
  userspace handler is called and it is not handling abort: the
  problematic case is if any of the __get_user()/__put_user done
  by the handler trigger a page fault (e.g. page protection
  done by NUMA page migration work), which triggers preemption:
  the next call to the rseq resume to userspace handler needs to
  perform the abort.
- Perform rseq event mask updates atomically wrt preemption,
- Move rseq_migrate to __set_task_cpu(), thus catching migration
  scenario that bypass set_task_cpu(): fork and wake_up_new_task.
- Merge content of rseq_sched_out into rseq_preempt. There is no
  need to have two hook sites. Both setting the rseq event mask
  preempt bit and setting the notify resume thread flag can be
  done from rseq_preempt().
- Issue rseq_preempt() from fork(), thus ensuring that we handle
  abort if needed.

Man page associated:

RSEQ(2)                Linux Programmer&#39;s Manual               RSEQ(2)

NAME
       rseq - Restartable sequences and cpu number cache

SYNOPSIS
       #include &lt;linux/rseq.h&gt;

       int rseq(struct rseq * rseq, uint32_t rseq_len, int flags, uint32_t sig);

DESCRIPTION
       The  rseq()  ABI  accelerates  user-space operations on per-cpu
       data by defining a shared data structure ABI between each user-
       space thread and the kernel.

       It  allows  user-space  to perform update operations on per-cpu
       data without requiring heavy-weight atomic operations.

       Restartable sequences are atomic  with  respect  to  preemption
       (making  it atomic with respect to other threads running on the
       same CPU), as well as  signal  delivery  (user-space  execution
       contexts nested over the same thread).

       It is suited for update operations on per-cpu data.

       It can be used on data structures shared between threads within
       a process, and on data structures shared between threads across
       different processes.

       Some examples of operations that can be accelerated or improved
       by this ABI:

       · Memory allocator per-cpu free-lists,

       · Querying the current CPU number,

       · Incrementing per-CPU counters,

       · Modifying data protected by per-CPU spinlocks,

       · Inserting/removing elements in per-CPU linked-lists,

       · Writing/reading per-CPU ring buffers content.

       · Accurately reading performance monitoring unit counters  with
         respect to thread migration.

       The  rseq argument is a pointer to the thread-local rseq struc‐
       ture to be shared between kernel and user-space.  A  NULL  rseq
       value unregisters the current thread rseq structure.

       The layout of struct rseq is as follows:

       Structure alignment
              This structure is aligned on multiples of 32 bytes.

       Structure size
              This  structure  is  extensible.  Its  size is passed as
              parameter to the rseq system call.

       Fields

           cpu_id_start
              Optimistic cache of the CPU number on which the  current
              thread  is running. Its value is guaranteed to always be
              a possible CPU number, even when rseq  is  not  initial‐
              ized.  The  value it contains should always be confirmed
              by reading the cpu_id field.

           cpu_id
              Cache of the CPU number on which the current  thread  is
              running.  -1 if uninitialized.

           rseq_cs
              The  rseq_cs  field is a pointer to a struct rseq_cs. Is
              is NULL when no rseq assembly block critical section  is
              active for the current thread.  Setting it to point to a
              critical section descriptor (struct rseq_cs)  marks  the
              beginning of the critical section.

           flags
              Flags  indicating  the  restart behavior for the current
              thread. This is mainly used for debugging purposes.  Can
              be either:

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE

       The layout of struct rseq_cs version 0 is as follows:

       Structure alignment
              This structure is aligned on multiples of 32 bytes.

       Structure size
              This structure has a fixed size of 32 bytes.

       Fields

           version
              Version of this structure.

           flags
              Flags indicating the restart behavior of this structure.
              Can be either:

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL

       ·      RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE

           start_ip
              Instruction pointer address of the first instruction  of
              the sequence of consecutive assembly instructions.

           post_commit_offset
              Offset  (from start_ip address) of the address after the
              last instruction of the sequence of consecutive assembly
              instructions.

           abort_ip
              Instruction  pointer address where to move the execution
              flow in case of abort of  the  sequence  of  consecutive
              assembly instructions.

       The  rseq_len argument is the size of the struct rseq to regis‐
       ter.

       The flags argument is 0 for registration, and  RSEQ_FLAG_UNREG‐
       ISTER for unregistration.

       The  sig argument is the 32-bit signature to be expected before
       the abort handler code.

       A single library per process should keep the rseq structure  in
       a  thread-local  storage  variable.  The cpu_id field should be
       initialized to -1, and the cpu_id_start field  should  be  ini‐
       tialized to a possible CPU value (typically 0).

       Each  thread  is  responsible for registering and unregistering
       its rseq structure. No more than one rseq structure address can
       be registered per thread at a given time.

       In  a  typical  usage scenario, the thread registering the rseq
       structure will be performing  loads  and  stores  from/to  that
       structure.  It  is  however also allowed to read that structure
       from other threads.  The rseq field updates  performed  by  the
       kernel  provide  relaxed  atomicity  semantics, which guarantee
       that other threads performing relaxed atomic reads of  the  cpu
       number cache will always observe a consistent value.

RETURN VALUE
       A  return  value  of  0  indicates  success.  On  error,  -1 is
       returned, and errno is set appropriately.

ERRORS
       EINVAL Either flags contains an invalid value, or rseq contains
              an  address  which  is  not  appropriately  aligned,  or
              rseq_len contains a size that does not  match  the  size
              received on registration.

       ENOSYS The  rseq()  system call is not implemented by this ker‐
              nel.

       EFAULT rseq is an invalid address.

       EBUSY  Restartable sequence  is  already  registered  for  this
              thread.

       EPERM  The  sig  argument  on unregistration does not match the
              signature received on registration.

VERSIONS
       The rseq() system call was added in Linux 4.X (TODO).

CONFORMING TO
       rseq() is Linux-specific.

SEE ALSO
       sched_getcpu(3)

Linux                         2017-11-06                       RSEQ(2)
---
 MAINTAINERS                 |  11 ++
 arch/Kconfig                |   7 +
 fs/exec.c                   |   1 +
 include/linux/sched.h       | 109 ++++++++++++++
 include/linux/syscalls.h    |   3 +
 include/trace/events/rseq.h |  56 +++++++
 include/uapi/linux/rseq.h   | 150 +++++++++++++++++++
 init/Kconfig                |  14 ++
 kernel/Makefile             |   1 +
 kernel/fork.c               |   2 +
 kernel/rseq.c               | 358 ++++++++++++++++++++++++++++++++++++++++++++
 kernel/sched/core.c         |   1 +
 kernel/sched/sched.h        |   1 +
 kernel/sys_ni.c             |   3 +
 14 files changed, 717 insertions(+)
 create mode 100644 include/trace/events/rseq.h
 create mode 100644 include/uapi/linux/rseq.h
 create mode 100644 kernel/rseq.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - Dec. 14, 2017, 4:44 p.m.</div>
<pre class="content">
On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:
<span class="quote">
&gt; On x86, yet another possible approach would be to use the gs segment</span>
<span class="quote">&gt; selector to point to user-space per-cpu data. This approach performs</span>
<span class="quote">&gt; similarly to the cpu id cache, but it has two disadvantages: it is</span>
<span class="quote">&gt; not portable, and it is incompatible with existing applications already</span>
<span class="quote">&gt; using the gs segment selector for other purposes.</span>

I think the proper way to think about gs and fs on x86 is as base
registers. They are essentially values in registers added to the address
generated in an instruction. As such the approach is transferable to other
processor architecture. Many support base register and base register
relative processing. If a processor can do RMV instructions base register
relative then you have something similar.

In a restartable sequence you could increase efficieny by avoiding full
atomic instructions. This would be similar to the lockless RMV available
on x86 then. And in that form it is portable.

A context switch to another processors would mean that the value of the
base register has changed and that we therefore are accessing another per
cpu segment. Restarting the sequence will yield a correct result without
any reloading of registers.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a> - Dec. 14, 2017, 6:12 p.m.</div>
<pre class="content">
----- On Dec 14, 2017, at 11:44 AM, Chris Lameter cl@linux.com wrote:
<span class="quote">
&gt; On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; On x86, yet another possible approach would be to use the gs segment</span>
<span class="quote">&gt;&gt; selector to point to user-space per-cpu data. This approach performs</span>
<span class="quote">&gt;&gt; similarly to the cpu id cache, but it has two disadvantages: it is</span>
<span class="quote">&gt;&gt; not portable, and it is incompatible with existing applications already</span>
<span class="quote">&gt;&gt; using the gs segment selector for other purposes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think the proper way to think about gs and fs on x86 is as base</span>
<span class="quote">&gt; registers. They are essentially values in registers added to the address</span>
<span class="quote">&gt; generated in an instruction. As such the approach is transferable to other</span>
<span class="quote">&gt; processor architecture. Many support base register and base register</span>
<span class="quote">&gt; relative processing. If a processor can do RMV instructions base register</span>
<span class="quote">&gt; relative then you have something similar.</span>

How would you do it on ARM32 ?
<span class="quote">
&gt; </span>
<span class="quote">&gt; In a restartable sequence you could increase efficieny by avoiding full</span>
<span class="quote">&gt; atomic instructions. This would be similar to the lockless RMV available</span>
<span class="quote">&gt; on x86 then. And in that form it is portable.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A context switch to another processors would mean that the value of the</span>
<span class="quote">&gt; base register has changed and that we therefore are accessing another per</span>
<span class="quote">&gt; cpu segment. Restarting the sequence will yield a correct result without</span>
<span class="quote">&gt; any reloading of registers.</span>

As a concrete example, let&#39;s try to apply your proposal on a common use-case:
a compare-and-store on user-space per-cpu data.

With my rseq proposal the fast-path pseudo-code boils down to:

load TLS::cpu_id_start into reg_X
add reg_X offset to base to find target v
store pointer to TLS::rseq_cs
compare reg_X against TLS::cpu_id
jne abort
cmp *v, value
jne cmpfail
store newval to *v

My benchmark on Intel x86-64 E5-2630 shows that it takes 1.9 ns/iteration
for a test-case incrementing a counter with this rseq compare-and-store
sequence.

Let&#39;s assume we can reserve the gs segment selector for use in user-space,
and that the per-cpu data layout allows using this segment selector as offset.
The compare-and-store use-case would require a &quot;cmpxchg&quot; instruction with
a gs segment selector.

A single-threaded test-case which uses non-lock-prefixed cmpxchg in a loop
on a E5-2630, I get 2.8 ns/iteration. (no per-cpu data involved, done on a single
global value)

One benefit of your proposal is to lessen the number of retired instructions,
but if we take the IPC into account, it is slower than rseq in my benchmark. What
benefits do you expect from using segment selectors and non-lock-prefixed atomic
instructions on the fast-path ?

Thanks,

Mathieu
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - Dec. 14, 2017, 6:50 p.m.</div>
<pre class="content">
On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:
<span class="quote">
&gt; &gt; I think the proper way to think about gs and fs on x86 is as base</span>
<span class="quote">&gt; &gt; registers. They are essentially values in registers added to the address</span>
<span class="quote">&gt; &gt; generated in an instruction. As such the approach is transferable to other</span>
<span class="quote">&gt; &gt; processor architecture. Many support base register and base register</span>
<span class="quote">&gt; &gt; relative processing. If a processor can do RMV instructions base register</span>
<span class="quote">&gt; &gt; relative then you have something similar.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; How would you do it on ARM32 ?</span>

Actually you do not really need RMV instructions. The data is cpu specific
so within a restartable sequence you would have exclusive access right?

F.e. a increment would be

1. Load base register relative
2. add 1
3. Store base register relative

The main overhead would be the registeration of the sequence.

The advantage on x86 is that you do not need a restartable sequence
since a single lockless RMV instruction can do this (this_cpu_inc f.e.)
<span class="quote">
&gt; One benefit of your proposal is to lessen the number of retired instructions,</span>
<span class="quote">&gt; but if we take the IPC into account, it is slower than rseq in my benchmark. What</span>
<span class="quote">&gt; benefits do you expect from using segment selectors and non-lock-prefixed atomic</span>
<span class="quote">&gt; instructions on the fast-path ?</span>

Ultimately I wish fast increments like done by this_cpu_inc() could be
implemented in an efficient way on non x86 platforms that do not have
cheap instructions like that.

If cmpxchg local is slower than a group of instructions to do the same
then there is an obvious question to the cpu architects why we would need
the instruction at all (aside from the fact that we do not need a
restartable sequence for these instructions).
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a> - Dec. 14, 2017, 7:24 p.m.</div>
<pre class="content">
----- On Dec 14, 2017, at 1:50 PM, Chris Lameter cl@linux.com wrote:
<span class="quote">
&gt; On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; &gt; I think the proper way to think about gs and fs on x86 is as base</span>
<span class="quote">&gt;&gt; &gt; registers. They are essentially values in registers added to the address</span>
<span class="quote">&gt;&gt; &gt; generated in an instruction. As such the approach is transferable to other</span>
<span class="quote">&gt;&gt; &gt; processor architecture. Many support base register and base register</span>
<span class="quote">&gt;&gt; &gt; relative processing. If a processor can do RMV instructions base register</span>
<span class="quote">&gt;&gt; &gt; relative then you have something similar.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; How would you do it on ARM32 ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Actually you do not really need RMV instructions. The data is cpu specific</span>
<span class="quote">&gt; so within a restartable sequence you would have exclusive access right?</span>

Yep.
<span class="quote">
&gt; </span>
<span class="quote">&gt; F.e. a increment would be</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1. Load base register relative</span>
<span class="quote">&gt; 2. add 1</span>
<span class="quote">&gt; 3. Store base register relative</span>

Actually, for the increment case, rseq headers provide a &quot;add&quot; API,
which uses a &quot;add&quot; instruction on x86. On arm 32, it does indeed:

RSEQ_ASM_STORE_RSEQ_CS(1, 3f, rseq_cs)
RSEQ_ASM_CMP_CPU_ID(cpu_id, current_cpu_id, 4f)
&quot;ldr r0, %[v]\n\t&quot;
&quot;add r0, %[count]\n\t&quot;
/* final store */
&quot;str r0, %[v]\n\t&quot;
<span class="quote">
&gt; </span>
<span class="quote">&gt; The main overhead would be the registeration of the sequence.</span>

Registering a rseq is a single store to a TLS (in user-space),
which really isn&#39;t that expensive.

If we port this concept to kernel-space (as I start to understand
would be your wish), then a simple pointer store to the current
task_struct would suffice.
<span class="quote">
&gt; </span>
<span class="quote">&gt; The advantage on x86 is that you do not need a restartable sequence</span>
<span class="quote">&gt; since a single lockless RMV instruction can do this (this_cpu_inc f.e.)</span>

Indeed, on x86, for the specific case of counter increment, the single-instruction
&quot;add&quot; or &quot;inc&quot; with a segment-selector prefix can save setting up the rseq
(a pointer store), and offsetting from a base using the cpu number.

If your wish is to do this at kernel level, where we have full control over
the gs segment, this makes sense. I&#39;m worried that applying this to user-space
might create conflicts wrt who owns that segment selector register wrt
pre-existing applications.
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; One benefit of your proposal is to lessen the number of retired instructions,</span>
<span class="quote">&gt;&gt; but if we take the IPC into account, it is slower than rseq in my benchmark.</span>
<span class="quote">&gt;&gt; What</span>
<span class="quote">&gt;&gt; benefits do you expect from using segment selectors and non-lock-prefixed atomic</span>
<span class="quote">&gt;&gt; instructions on the fast-path ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ultimately I wish fast increments like done by this_cpu_inc() could be</span>
<span class="quote">&gt; implemented in an efficient way on non x86 platforms that do not have</span>
<span class="quote">&gt; cheap instructions like that.</span>

My understanding is that your focus is mainly on kernel code, right ? Or is
your aim to port this_cpu_inc() to userspace as well ?

Indeed, the concepts behind rseq could be ported to kernel code eventually.
The immediate gain is much higher by exposing this to user-space though,
given that there is no good way to perform per-cpu operations efficiently
at all there, whereas kernel code can always disable preemption.
<span class="quote">
&gt; </span>
<span class="quote">&gt; If cmpxchg local is slower than a group of instructions to do the same</span>
<span class="quote">&gt; then there is an obvious question to the cpu architects why we would need</span>
<span class="quote">&gt; the instruction at all (aside from the fact that we do not need a</span>
<span class="quote">&gt; restartable sequence for these instructions).</span>

I&#39;m not a specialist in CPU instruction scheduling, so I won&#39;t speculate
on this topic. ;-)

Thanks,

Mathieu
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Dec. 14, 2017, 7:48 p.m.</div>
<pre class="content">
On Thu, Dec 14, 2017 at 12:50:13PM -0600, Christopher Lameter wrote:
<span class="quote">&gt; Ultimately I wish fast increments like done by this_cpu_inc() could be</span>
<span class="quote">&gt; implemented in an efficient way on non x86 platforms that do not have</span>
<span class="quote">&gt; cheap instructions like that.</span>

So the problem isn&#39;t migration; for that we could wrap the operation in
preempt_disable() which is not more expensive than rseq would be. And a
lot more deterministic.

The problem instead is interrupts, which can result in nested load-store
operations, and that comes apart. This then means having to disable
interrupts over these things and _that_ is expensive.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a> - Dec. 14, 2017, 7:57 p.m.</div>
<pre class="content">
----- On Dec 14, 2017, at 2:48 PM, Peter Zijlstra peterz@infradead.org wrote:
<span class="quote">
&gt; On Thu, Dec 14, 2017 at 12:50:13PM -0600, Christopher Lameter wrote:</span>
<span class="quote">&gt;&gt; Ultimately I wish fast increments like done by this_cpu_inc() could be</span>
<span class="quote">&gt;&gt; implemented in an efficient way on non x86 platforms that do not have</span>
<span class="quote">&gt;&gt; cheap instructions like that.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So the problem isn&#39;t migration; for that we could wrap the operation in</span>
<span class="quote">&gt; preempt_disable() which is not more expensive than rseq would be. And a</span>
<span class="quote">&gt; lot more deterministic.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The problem instead is interrupts, which can result in nested load-store</span>
<span class="quote">&gt; operations, and that comes apart. This then means having to disable</span>
<span class="quote">&gt; interrupts over these things and _that_ is expensive.</span>

Then could we consider checking a per task-struct rseq_cs pointer when
returning from interrupt handler ? This rseq_cs pointer would track
kernel restartable sequences. This would also work for NMI handlers.

Thanks,

Mathieu
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Dec. 14, 2017, 8:09 p.m.</div>
<pre class="content">
On Thu, Dec 14, 2017 at 07:57:08PM +0000, Mathieu Desnoyers wrote:
<span class="quote">&gt; ----- On Dec 14, 2017, at 2:48 PM, Peter Zijlstra peterz@infradead.org wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Thu, Dec 14, 2017 at 12:50:13PM -0600, Christopher Lameter wrote:</span>
<span class="quote">&gt; &gt;&gt; Ultimately I wish fast increments like done by this_cpu_inc() could be</span>
<span class="quote">&gt; &gt;&gt; implemented in an efficient way on non x86 platforms that do not have</span>
<span class="quote">&gt; &gt;&gt; cheap instructions like that.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So the problem isn&#39;t migration; for that we could wrap the operation in</span>
<span class="quote">&gt; &gt; preempt_disable() which is not more expensive than rseq would be. And a</span>
<span class="quote">&gt; &gt; lot more deterministic.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The problem instead is interrupts, which can result in nested load-store</span>
<span class="quote">&gt; &gt; operations, and that comes apart. This then means having to disable</span>
<span class="quote">&gt; &gt; interrupts over these things and _that_ is expensive.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then could we consider checking a per task-struct rseq_cs pointer when</span>
<span class="quote">&gt; returning from interrupt handler ? This rseq_cs pointer would track</span>
<span class="quote">&gt; kernel restartable sequences. This would also work for NMI handlers.</span>

I really don&#39;t much like making the interrupt handlers more expensive
for this.

And I don&#39;t think NMIs are a real worry, you should be very careful when
you share state with any of them in any case.

Also; what you can do is soft interrupt disable, which is effectively
the oppose approach, instead of restarting the sequence, you delay the
interrupt handler. And that has the obvious benefit of making all the
local_irq_disable/enable crud much faster all over.

This is something PowerPC already does.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - Dec. 14, 2017, 9:14 p.m.</div>
<pre class="content">
On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:
<span class="quote">
&gt; If we port this concept to kernel-space (as I start to understand</span>
<span class="quote">&gt; would be your wish), then a simple pointer store to the current</span>
<span class="quote">&gt; task_struct would suffice.</span>

Certainly such a port would be beneficial for non x86 archs.

But my company has extensive user space code that maintains a lot of
counters and does other tricks to get full performance out of the
hardware. Such a mechanism would also be good from user space. Why keep
the good stuff only inside the kernel?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137">Peter Zijlstra</a> - Dec. 14, 2017, 9:20 p.m.</div>
<pre class="content">
On Thu, Dec 14, 2017 at 03:14:00PM -0600, Christopher Lameter wrote:
<span class="quote">&gt; On Thu, 14 Dec 2017, Mathieu Desnoyers wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; If we port this concept to kernel-space (as I start to understand</span>
<span class="quote">&gt; &gt; would be your wish), then a simple pointer store to the current</span>
<span class="quote">&gt; &gt; task_struct would suffice.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Certainly such a port would be beneficial for non x86 archs.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But my company has extensive user space code that maintains a lot of</span>
<span class="quote">&gt; counters and does other tricks to get full performance out of the</span>
<span class="quote">&gt; hardware. Such a mechanism would also be good from user space. Why keep</span>
<span class="quote">&gt; the good stuff only inside the kernel?</span>

Mathieu&#39;s proposal is for userspace, _only_ userspace.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - Dec. 15, 2017, 3:05 p.m.</div>
<pre class="content">
On Thu, 14 Dec 2017, Peter Zijlstra wrote:
<span class="quote">
&gt; &gt; But my company has extensive user space code that maintains a lot of</span>
<span class="quote">&gt; &gt; counters and does other tricks to get full performance out of the</span>
<span class="quote">&gt; &gt; hardware. Such a mechanism would also be good from user space. Why keep</span>
<span class="quote">&gt; &gt; the good stuff only inside the kernel?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Mathieu&#39;s proposal is for userspace, _only_ userspace.</span>

But what we were talking about are instructions that work effectively in
kernel space whose efficiency restartable sequences could bring to user
space.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=6835">Mathieu Desnoyers</a> - Dec. 15, 2017, 4:52 p.m.</div>
<pre class="content">
----- On Dec 15, 2017, at 10:05 AM, Chris Lameter cl@linux.com wrote:
<span class="quote">
&gt; On Thu, 14 Dec 2017, Peter Zijlstra wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; &gt; But my company has extensive user space code that maintains a lot of</span>
<span class="quote">&gt;&gt; &gt; counters and does other tricks to get full performance out of the</span>
<span class="quote">&gt;&gt; &gt; hardware. Such a mechanism would also be good from user space. Why keep</span>
<span class="quote">&gt;&gt; &gt; the good stuff only inside the kernel?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Mathieu&#39;s proposal is for userspace, _only_ userspace.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But what we were talking about are instructions that work effectively in</span>
<span class="quote">&gt; kernel space whose efficiency restartable sequences could bring to user</span>
<span class="quote">&gt; space.</span>

It can be worthwhile to recap my understanding of this thread so far:

AFAIU, Chris&#39; proposal is to use the &quot;gs&quot; segment selector as instruction
prefix on x86 rather than explicitly loading CPU number and calculating
offsets.

This can turn sequences of rseq operations like this cmpxchg:

Registers:

  R1: return value
  R2: expected value
  R3: new value
  R4: cpu_id

rseq cmpxchg:

  load TLS::cpu_id_start into R4
  calculate offset of v
  fs:mov (store rseq descriptor address into TLS::rseq_cs)
  compare R4 against TLS::cpu_id
  jne abort
  mov (load v into R1)
  compare R1 against R2
  jne cmpfail
  mov (store R3 into *v)

into:

  fs:mov (store rseq descriptor address into TLS::rseq_cs)
  gs:mov (load *v+off into R1)
  compare R1 against R2
  jne cmpfail
  gs:mov (store R3 into *v+off)

My first concern with this approach is the lack of flexibility of the segment
selector method wrt variety of schemes user-space has to deal with for memory
allocation. In the kernel, this is achieved by ensuring that all per-cpu data
layout is segment-selector-prefix friendly.

Another aspect that worries me is applications using the gs segment selector
for other purposes. Suddenly reserving the gs segment selector for use by a
library like glibc may lead to incompatibilities with applications already
using it.

Thanks,

Mathieu
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - Dec. 15, 2017, 5:13 p.m.</div>
<pre class="content">
On Fri, 15 Dec 2017, Mathieu Desnoyers wrote:
<span class="quote">
&gt; Another aspect that worries me is applications using the gs segment selector</span>
<span class="quote">&gt; for other purposes. Suddenly reserving the gs segment selector for use by a</span>
<span class="quote">&gt; library like glibc may lead to incompatibilities with applications already</span>
<span class="quote">&gt; using it.</span>

fs/gs seems to be reserved for thread local storage. So it would
be shared in user space like the corresponding cpu segment register in
kernel space where multiple subsystems share %gs.

The same can be done in user space. Ulrich Drepper has a writeup on this

https://www.akkadia.org/drepper/tls.pdf

Savings in execution time could come about because there would not be the
need to determine the address of the processor specific memory area in
each restartable sequence and there would be memory free of contention for
such a sequence in order f.e. to realize fast counters.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 82ad0eabce4f..4ede6c16d49f 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -11620,6 +11620,17 @@</span> <span class="p_context"> F:	include/dt-bindings/reset/</span>
 F:	include/linux/reset.h
 F:	include/linux/reset-controller.h
 
<span class="p_add">+RESTARTABLE SEQUENCES SUPPORT</span>
<span class="p_add">+M:	Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;</span>
<span class="p_add">+M:	Peter Zijlstra &lt;peterz@infradead.org&gt;</span>
<span class="p_add">+M:	&quot;Paul E. McKenney&quot; &lt;paulmck@linux.vnet.ibm.com&gt;</span>
<span class="p_add">+M:	Boqun Feng &lt;boqun.feng@gmail.com&gt;</span>
<span class="p_add">+L:	linux-kernel@vger.kernel.org</span>
<span class="p_add">+S:	Supported</span>
<span class="p_add">+F:	kernel/rseq.c</span>
<span class="p_add">+F:	include/uapi/linux/rseq.h</span>
<span class="p_add">+F:	include/trace/events/rseq.h</span>
<span class="p_add">+</span>
 RFKILL
 M:	Johannes Berg &lt;johannes@sipsolutions.net&gt;
 L:	linux-wireless@vger.kernel.org
<span class="p_header">diff --git a/arch/Kconfig b/arch/Kconfig</span>
<span class="p_header">index 400b9e1b2f27..2d7f54a5784b 100644</span>
<span class="p_header">--- a/arch/Kconfig</span>
<span class="p_header">+++ b/arch/Kconfig</span>
<span class="p_chunk">@@ -258,6 +258,13 @@</span> <span class="p_context"> config HAVE_REGS_AND_STACK_ACCESS_API</span>
 	  declared in asm/ptrace.h
 	  For example the kprobes-based event tracer needs this API.
 
<span class="p_add">+config HAVE_RSEQ</span>
<span class="p_add">+	bool</span>
<span class="p_add">+	depends on HAVE_REGS_AND_STACK_ACCESS_API</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This symbol should be selected by an architecture if it</span>
<span class="p_add">+	  supports an implementation of restartable sequences.</span>
<span class="p_add">+</span>
 config HAVE_CLK
 	bool
 	help
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 6be2aa0ab26f..8d6eac1e20d8 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1808,6 +1808,7 @@</span> <span class="p_context"> static int do_execveat_common(int fd, struct filename *filename,</span>
 	current-&gt;fs-&gt;in_exec = 0;
 	current-&gt;in_execve = 0;
 	membarrier_execve(current);
<span class="p_add">+	rseq_execve(current);</span>
 	acct_update_integrals(current);
 	task_numa_free(current);
 	free_bprm(bprm);
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 21991d668d35..503f076d6f21 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/signal_types.h&gt;
 #include &lt;linux/mm_types_task.h&gt;
 #include &lt;linux/task_io_accounting.h&gt;
<span class="p_add">+#include &lt;linux/rseq.h&gt;</span>
 
 /* task_struct member predeclarations (sorted alphabetically): */
 struct audit_context;
<span class="p_chunk">@@ -978,6 +979,17 @@</span> <span class="p_context"> struct task_struct {</span>
 	unsigned long			numa_pages_migrated;
 #endif /* CONFIG_NUMA_BALANCING */
 
<span class="p_add">+#ifdef CONFIG_RSEQ</span>
<span class="p_add">+	struct rseq __user *rseq;</span>
<span class="p_add">+	u32 rseq_len;</span>
<span class="p_add">+	u32 rseq_sig;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * RmW on rseq_event_mask must be performed atomically</span>
<span class="p_add">+	 * with respect to preemption.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned long rseq_event_mask;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	struct tlbflush_unmap_batch	tlb_ubc;
 
 	struct rcu_head			rcu;
<span class="p_chunk">@@ -1668,4 +1680,101 @@</span> <span class="p_context"> extern long sched_getaffinity(pid_t pid, struct cpumask *mask);</span>
 #define TASK_SIZE_OF(tsk)	TASK_SIZE
 #endif
 
<span class="p_add">+#ifdef CONFIG_RSEQ</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Map the event mask on the user-space ABI enum rseq_cs_flags</span>
<span class="p_add">+ * for direct mask checks.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_event_mask_bits {</span>
<span class="p_add">+	RSEQ_EVENT_PREEMPT_BIT	= RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT,</span>
<span class="p_add">+	RSEQ_EVENT_SIGNAL_BIT	= RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT,</span>
<span class="p_add">+	RSEQ_EVENT_MIGRATE_BIT	= RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_event_mask {</span>
<span class="p_add">+	RSEQ_EVENT_PREEMPT	= (1U &lt;&lt; RSEQ_EVENT_PREEMPT_BIT),</span>
<span class="p_add">+	RSEQ_EVENT_SIGNAL	= (1U &lt;&lt; RSEQ_EVENT_SIGNAL_BIT),</span>
<span class="p_add">+	RSEQ_EVENT_MIGRATE	= (1U &lt;&lt; RSEQ_EVENT_MIGRATE_BIT),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void rseq_set_notify_resume(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (t-&gt;rseq)</span>
<span class="p_add">+		set_tsk_thread_flag(t, TIF_NOTIFY_RESUME);</span>
<span class="p_add">+}</span>
<span class="p_add">+void __rseq_handle_notify_resume(struct pt_regs *regs);</span>
<span class="p_add">+static inline void rseq_handle_notify_resume(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (current-&gt;rseq)</span>
<span class="p_add">+		__rseq_handle_notify_resume(regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_signal_deliver(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_bit(RSEQ_EVENT_SIGNAL_BIT, &amp;current-&gt;rseq_event_mask);</span>
<span class="p_add">+	rseq_handle_notify_resume(regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_preempt(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_bit(RSEQ_EVENT_PREEMPT_BIT, &amp;t-&gt;rseq_event_mask);</span>
<span class="p_add">+	rseq_set_notify_resume(t);</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_migrate(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_bit(RSEQ_EVENT_MIGRATE_BIT, &amp;t-&gt;rseq_event_mask);</span>
<span class="p_add">+	rseq_set_notify_resume(t);</span>
<span class="p_add">+}</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * If parent process has a registered restartable sequences area, the</span>
<span class="p_add">+ * child inherits. Only applies when forking a process, not a thread. In</span>
<span class="p_add">+ * case a parent fork() in the middle of a restartable sequence, set the</span>
<span class="p_add">+ * resume notifier to force the child to retry.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void rseq_fork(struct task_struct *t, unsigned long clone_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (clone_flags &amp; CLONE_THREAD) {</span>
<span class="p_add">+		t-&gt;rseq = NULL;</span>
<span class="p_add">+		t-&gt;rseq_len = 0;</span>
<span class="p_add">+		t-&gt;rseq_sig = 0;</span>
<span class="p_add">+		t-&gt;rseq_event_mask = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		t-&gt;rseq = current-&gt;rseq;</span>
<span class="p_add">+		t-&gt;rseq_len = current-&gt;rseq_len;</span>
<span class="p_add">+		t-&gt;rseq_sig = current-&gt;rseq_sig;</span>
<span class="p_add">+		t-&gt;rseq_event_mask = current-&gt;rseq_event_mask;</span>
<span class="p_add">+		rseq_preempt(t);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_execve(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	t-&gt;rseq = NULL;</span>
<span class="p_add">+	t-&gt;rseq_len = 0;</span>
<span class="p_add">+	t-&gt;rseq_sig = 0;</span>
<span class="p_add">+	t-&gt;rseq_event_mask = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void rseq_set_notify_resume(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_handle_notify_resume(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_signal_deliver(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_preempt(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_migrate(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_fork(struct task_struct *t, unsigned long clone_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline void rseq_execve(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h</span>
<span class="p_header">index a78186d826d7..340650b4ec54 100644</span>
<span class="p_header">--- a/include/linux/syscalls.h</span>
<span class="p_header">+++ b/include/linux/syscalls.h</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> struct old_linux_dirent;</span>
 struct perf_event_attr;
 struct file_handle;
 struct sigaltstack;
<span class="p_add">+struct rseq;</span>
 union bpf_attr;
 
 #include &lt;linux/types.h&gt;
<span class="p_chunk">@@ -940,5 +941,7 @@</span> <span class="p_context"> asmlinkage long sys_pkey_alloc(unsigned long flags, unsigned long init_val);</span>
 asmlinkage long sys_pkey_free(int pkey);
 asmlinkage long sys_statx(int dfd, const char __user *path, unsigned flags,
 			  unsigned mask, struct statx __user *buffer);
<span class="p_add">+asmlinkage long sys_rseq(struct rseq __user *rseq, uint32_t rseq_len,</span>
<span class="p_add">+			int flags, uint32_t sig);</span>
 
 #endif
<span class="p_header">diff --git a/include/trace/events/rseq.h b/include/trace/events/rseq.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c4609a3f5008</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/include/trace/events/rseq.h</span>
<span class="p_chunk">@@ -0,0 +1,56 @@</span> <span class="p_context"></span>
<span class="p_add">+#undef TRACE_SYSTEM</span>
<span class="p_add">+#define TRACE_SYSTEM rseq</span>
<span class="p_add">+</span>
<span class="p_add">+#if !defined(_TRACE_RSEQ_H) || defined(TRACE_HEADER_MULTI_READ)</span>
<span class="p_add">+#define _TRACE_RSEQ_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/tracepoint.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+TRACE_EVENT(rseq_update,</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_PROTO(struct task_struct *t),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_ARGS(t),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_STRUCT__entry(</span>
<span class="p_add">+		__field(s32, cpu_id)</span>
<span class="p_add">+	),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_fast_assign(</span>
<span class="p_add">+		__entry-&gt;cpu_id = raw_smp_processor_id();</span>
<span class="p_add">+	),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_printk(&quot;cpu_id=%d&quot;, __entry-&gt;cpu_id)</span>
<span class="p_add">+);</span>
<span class="p_add">+</span>
<span class="p_add">+TRACE_EVENT(rseq_ip_fixup,</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_PROTO(unsigned long regs_ip, unsigned long start_ip,</span>
<span class="p_add">+		unsigned long post_commit_offset, unsigned long abort_ip),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_ARGS(regs_ip, start_ip, post_commit_offset, abort_ip),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_STRUCT__entry(</span>
<span class="p_add">+		__field(unsigned long, regs_ip)</span>
<span class="p_add">+		__field(unsigned long, start_ip)</span>
<span class="p_add">+		__field(unsigned long, post_commit_offset)</span>
<span class="p_add">+		__field(unsigned long, abort_ip)</span>
<span class="p_add">+	),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_fast_assign(</span>
<span class="p_add">+		__entry-&gt;regs_ip = regs_ip;</span>
<span class="p_add">+		__entry-&gt;start_ip = start_ip;</span>
<span class="p_add">+		__entry-&gt;post_commit_offset = post_commit_offset;</span>
<span class="p_add">+		__entry-&gt;abort_ip = abort_ip;</span>
<span class="p_add">+	),</span>
<span class="p_add">+</span>
<span class="p_add">+	TP_printk(&quot;regs_ip=0x%lx start_ip=0x%lx post_commit_offset=%lu abort_ip=0x%lx&quot;,</span>
<span class="p_add">+		__entry-&gt;regs_ip, __entry-&gt;start_ip,</span>
<span class="p_add">+		__entry-&gt;post_commit_offset, __entry-&gt;abort_ip)</span>
<span class="p_add">+);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _TRACE_SOCK_H */</span>
<span class="p_add">+</span>
<span class="p_add">+/* This part must be outside protection */</span>
<span class="p_add">+#include &lt;trace/define_trace.h&gt;</span>
<span class="p_header">diff --git a/include/uapi/linux/rseq.h b/include/uapi/linux/rseq.h</span>
new file mode 100644
<span class="p_header">index 000000000000..3895ec940059</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/include/uapi/linux/rseq.h</span>
<span class="p_chunk">@@ -0,0 +1,150 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _UAPI_LINUX_RSEQ_H</span>
<span class="p_add">+#define _UAPI_LINUX_RSEQ_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * linux/rseq.h</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Restartable sequences system call API</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (c) 2015-2016 Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="p_add">+ * of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="p_add">+ * in the Software without restriction, including without limitation the rights</span>
<span class="p_add">+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="p_add">+ * copies of the Software, and to permit persons to whom the Software is</span>
<span class="p_add">+ * furnished to do so, subject to the following conditions:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The above copyright notice and this permission notice shall be included in</span>
<span class="p_add">+ * all copies or substantial portions of the Software.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="p_add">+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="p_add">+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="p_add">+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="p_add">+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="p_add">+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="p_add">+ * SOFTWARE.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+# include &lt;linux/types.h&gt;</span>
<span class="p_add">+#else</span>
<span class="p_add">+# include &lt;stdint.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types_32_64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_cpu_id_state {</span>
<span class="p_add">+	RSEQ_CPU_ID_UNINITIALIZED		= -1,</span>
<span class="p_add">+	RSEQ_CPU_ID_REGISTRATION_FAILED		= -2,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_flags {</span>
<span class="p_add">+	RSEQ_FLAG_UNREGISTER = (1 &lt;&lt; 0),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_cs_flags_bit {</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT	= 0,</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT	= 1,</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT	= 2,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum rseq_cs_flags {</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT	=</span>
<span class="p_add">+		(1U &lt;&lt; RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT),</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL	=</span>
<span class="p_add">+		(1U &lt;&lt; RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT),</span>
<span class="p_add">+	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE	=</span>
<span class="p_add">+		(1U &lt;&lt; RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * struct rseq_cs is aligned on 4 * 8 bytes to ensure it is always</span>
<span class="p_add">+ * contained within a single cache-line. It is usually declared as</span>
<span class="p_add">+ * link-time constant data.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct rseq_cs {</span>
<span class="p_add">+	/* Version of this structure. */</span>
<span class="p_add">+	uint32_t version;</span>
<span class="p_add">+	/* enum rseq_cs_flags */</span>
<span class="p_add">+	uint32_t flags;</span>
<span class="p_add">+	LINUX_FIELD_u32_u64(start_ip);</span>
<span class="p_add">+	/* Offset from start_ip. */</span>
<span class="p_add">+	LINUX_FIELD_u32_u64(post_commit_offset);</span>
<span class="p_add">+	LINUX_FIELD_u32_u64(abort_ip);</span>
<span class="p_add">+} __attribute__((aligned(4 * sizeof(uint64_t))));</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * struct rseq is aligned on 4 * 8 bytes to ensure it is always</span>
<span class="p_add">+ * contained within a single cache-line.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A single struct rseq per thread is allowed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct rseq {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Restartable sequences cpu_id_start field. Updated by the</span>
<span class="p_add">+	 * kernel, and read by user-space with single-copy atomicity</span>
<span class="p_add">+	 * semantics. Aligned on 32-bit. Always contains a value in the</span>
<span class="p_add">+	 * range of possible CPUs, although the value may not be the</span>
<span class="p_add">+	 * actual current CPU (e.g. if rseq is not initialized). This</span>
<span class="p_add">+	 * CPU number value should always be compared against the value</span>
<span class="p_add">+	 * of the cpu_id field before performing a rseq commit or</span>
<span class="p_add">+	 * returning a value read from a data structure indexed using</span>
<span class="p_add">+	 * the cpu_id_start value.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uint32_t cpu_id_start;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Restartable sequences cpu_id field. Updated by the kernel,</span>
<span class="p_add">+	 * and read by user-space with single-copy atomicity semantics.</span>
<span class="p_add">+	 * Aligned on 32-bit. Values RSEQ_CPU_ID_UNINITIALIZED and</span>
<span class="p_add">+	 * RSEQ_CPU_ID_REGISTRATION_FAILED have a special semantic: the</span>
<span class="p_add">+	 * former means &quot;rseq uninitialized&quot;, and latter means &quot;rseq</span>
<span class="p_add">+	 * initialization failed&quot;. This value is meant to be read within</span>
<span class="p_add">+	 * rseq critical sections and compared with the cpu_id_start</span>
<span class="p_add">+	 * value previously read, before performing the commit instruction,</span>
<span class="p_add">+	 * or read and compared with the cpu_id_start value before returning</span>
<span class="p_add">+	 * a value loaded from a data structure indexed using the</span>
<span class="p_add">+	 * cpu_id_start value.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uint32_t cpu_id;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Restartable sequences rseq_cs field.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Contains NULL when no critical section is active for the current</span>
<span class="p_add">+	 * thread, or holds a pointer to the currently active struct rseq_cs.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Updated by user-space, which sets the address of the currently</span>
<span class="p_add">+	 * active rseq_cs at the beginning of assembly instruction sequence</span>
<span class="p_add">+	 * block, and set to NULL by the kernel when it restarts an assembly</span>
<span class="p_add">+	 * instruction sequence block, as well as when the kernel detects that</span>
<span class="p_add">+	 * it is preempting or delivering a signal outside of the range</span>
<span class="p_add">+	 * targeted by the rseq_cs. Also needs to be set to NULL by user-space</span>
<span class="p_add">+	 * before reclaiming memory that contains the targeted struct rseq_cs.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Read and set by the kernel with single-copy atomicity semantics.</span>
<span class="p_add">+	 * Set by user-space with single-copy atomicity semantics. Aligned</span>
<span class="p_add">+	 * on 64-bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	LINUX_FIELD_u32_u64(rseq_cs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * - RSEQ_DISABLE flag:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Fallback fast-track flag for single-stepping.</span>
<span class="p_add">+	 * Set by user-space if lack of progress is detected.</span>
<span class="p_add">+	 * Cleared by user-space after rseq finish.</span>
<span class="p_add">+	 * Read by the kernel.</span>
<span class="p_add">+	 * - RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT</span>
<span class="p_add">+	 *     Inhibit instruction sequence block restart and event</span>
<span class="p_add">+	 *     counter increment on preemption for this thread.</span>
<span class="p_add">+	 * - RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL</span>
<span class="p_add">+	 *     Inhibit instruction sequence block restart and event</span>
<span class="p_add">+	 *     counter increment on signal delivery for this thread.</span>
<span class="p_add">+	 * - RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE</span>
<span class="p_add">+	 *     Inhibit instruction sequence block restart and event</span>
<span class="p_add">+	 *     counter increment on migration for this thread.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uint32_t flags;</span>
<span class="p_add">+} __attribute__((aligned(4 * sizeof(uint64_t))));</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _UAPI_LINUX_RSEQ_H */</span>
<span class="p_header">diff --git a/init/Kconfig b/init/Kconfig</span>
<span class="p_header">index 2934249fba46..88e36395390f 100644</span>
<span class="p_header">--- a/init/Kconfig</span>
<span class="p_header">+++ b/init/Kconfig</span>
<span class="p_chunk">@@ -1400,6 +1400,20 @@</span> <span class="p_context"> config USERFAULTFD</span>
 	  Enable the userfaultfd() system call that allows to intercept and
 	  handle page faults in userland.
 
<span class="p_add">+config RSEQ</span>
<span class="p_add">+	bool &quot;Enable rseq() system call&quot; if EXPERT</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	depends on HAVE_RSEQ</span>
<span class="p_add">+	select MEMBARRIER</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Enable the restartable sequences system call. It provides a</span>
<span class="p_add">+	  user-space cache for the current CPU number value, which</span>
<span class="p_add">+	  speeds up getting the current CPU number from user-space,</span>
<span class="p_add">+	  as well as an ABI to speed up user-space operations on</span>
<span class="p_add">+	  per-CPU data.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
 config EMBEDDED
 	bool &quot;Embedded system&quot;
 	option allnoconfig_y
<span class="p_header">diff --git a/kernel/Makefile b/kernel/Makefile</span>
<span class="p_header">index 172d151d429c..3574669dafd9 100644</span>
<span class="p_header">--- a/kernel/Makefile</span>
<span class="p_header">+++ b/kernel/Makefile</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> obj-$(CONFIG_CONTEXT_TRACKING) += context_tracking.o</span>
 obj-$(CONFIG_TORTURE_TEST) += torture.o
 
 obj-$(CONFIG_HAS_IOMEM) += memremap.o
<span class="p_add">+obj-$(CONFIG_RSEQ) += rseq.o</span>
 
 $(obj)/configs.o: $(obj)/config_data.h
 
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 432eadf6b58c..e903ee4f21ba 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -1858,6 +1858,8 @@</span> <span class="p_context"> static __latent_entropy struct task_struct *copy_process(</span>
 	 */
 	copy_seccomp(p);
 
<span class="p_add">+	rseq_fork(p, clone_flags);</span>
<span class="p_add">+</span>
 	/*
 	 * Process group and session signals need to be delivered to just the
 	 * parent before the fork or both the parent and the child after the
<span class="p_header">diff --git a/kernel/rseq.c b/kernel/rseq.c</span>
new file mode 100644
<span class="p_header">index 000000000000..93f3f169e112</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/kernel/rseq.c</span>
<span class="p_chunk">@@ -0,0 +1,358 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restartable sequences system call</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2015, Google, Inc.,</span>
<span class="p_add">+ * Paul Turner &lt;pjt@google.com&gt; and Andrew Hunter &lt;ahh@google.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2015-2016, EfficiOS Inc.,</span>
<span class="p_add">+ * Mathieu Desnoyers &lt;mathieu.desnoyers@efficios.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+#include &lt;linux/rseq.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define CREATE_TRACE_POINTS</span>
<span class="p_add">+#include &lt;trace/events/rseq.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Restartable sequences are a lightweight interface that allows</span>
<span class="p_add">+ * user-level code to be executed atomically relative to scheduler</span>
<span class="p_add">+ * preemption and signal delivery. Typically used for implementing</span>
<span class="p_add">+ * per-cpu operations.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It allows user-space to perform update operations on per-cpu data</span>
<span class="p_add">+ * without requiring heavy-weight atomic operations.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Detailed algorithm of rseq user-space assembly sequences:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *                     init(rseq_cs)</span>
<span class="p_add">+ *                     cpu = TLS-&gt;rseq::cpu_id_start</span>
<span class="p_add">+ *   [1]               TLS-&gt;rseq::rseq_cs = rseq_cs</span>
<span class="p_add">+ *   [start_ip]        ----------------------------</span>
<span class="p_add">+ *   [2]               if (cpu != TLS-&gt;rseq::cpu_id)</span>
<span class="p_add">+ *                             goto abort_ip;</span>
<span class="p_add">+ *   [3]               &lt;last_instruction_in_cs&gt;</span>
<span class="p_add">+ *   [post_commit_ip]  ----------------------------</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   The address of jump target abort_ip must be outside the critical</span>
<span class="p_add">+ *   region, i.e.:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *     [abort_ip] &lt; [start_ip]  || [abort_ip] &gt;= [post_commit_ip]</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   Steps [2]-[3] (inclusive) need to be a sequence of instructions in</span>
<span class="p_add">+ *   userspace that can handle being interrupted between any of those</span>
<span class="p_add">+ *   instructions, and then resumed to the abort_ip.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   1.  Userspace stores the address of the struct rseq_cs assembly</span>
<span class="p_add">+ *       block descriptor into the rseq_cs field of the registered</span>
<span class="p_add">+ *       struct rseq TLS area. This update is performed through a single</span>
<span class="p_add">+ *       store within the inline assembly instruction sequence.</span>
<span class="p_add">+ *       [start_ip]</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   2.  Userspace tests to check whether the current cpu_id field match</span>
<span class="p_add">+ *       the cpu number loaded before start_ip, branching to abort_ip</span>
<span class="p_add">+ *       in case of a mismatch.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *       If the sequence is preempted or interrupted by a signal</span>
<span class="p_add">+ *       at or after start_ip and before post_commit_ip, then the kernel</span>
<span class="p_add">+ *       clears TLS-&gt;__rseq_abi::rseq_cs, and sets the user-space return</span>
<span class="p_add">+ *       ip to abort_ip before returning to user-space, so the preempted</span>
<span class="p_add">+ *       execution resumes at abort_ip.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   3.  Userspace critical section final instruction before</span>
<span class="p_add">+ *       post_commit_ip is the commit. The critical section is</span>
<span class="p_add">+ *       self-terminating.</span>
<span class="p_add">+ *       [post_commit_ip]</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   4.  &lt;success&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   On failure at [2], or if interrupted by preempt or signal delivery</span>
<span class="p_add">+ *   between [1] and [3]:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *       [abort_ip]</span>
<span class="p_add">+ *   F1. &lt;failure&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int rseq_update_cpu_id(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t cpu_id = raw_smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__put_user(cpu_id, &amp;t-&gt;rseq-&gt;cpu_id_start))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	if (__put_user(cpu_id, &amp;t-&gt;rseq-&gt;cpu_id))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	trace_rseq_update(t);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rseq_reset_rseq_cpu_id(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t cpu_id_start = 0, cpu_id = RSEQ_CPU_ID_UNINITIALIZED;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reset cpu_id_start to its initial state (0).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__put_user(cpu_id_start, &amp;t-&gt;rseq-&gt;cpu_id_start))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reset cpu_id to RSEQ_CPU_ID_UNINITIALIZED, so any user coming</span>
<span class="p_add">+	 * in after unregistration can figure out that rseq needs to be</span>
<span class="p_add">+	 * registered again.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__put_user(cpu_id, &amp;t-&gt;rseq-&gt;cpu_id))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rseq_get_rseq_cs(struct task_struct *t,</span>
<span class="p_add">+			    unsigned long *start_ip,</span>
<span class="p_add">+			    unsigned long *post_commit_offset,</span>
<span class="p_add">+			    unsigned long *abort_ip,</span>
<span class="p_add">+			    uint32_t *cs_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rseq_cs __user *urseq_cs;</span>
<span class="p_add">+	struct rseq_cs rseq_cs;</span>
<span class="p_add">+	unsigned long ptr;</span>
<span class="p_add">+	u32 __user *usig;</span>
<span class="p_add">+	u32 sig;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __get_user(ptr, &amp;t-&gt;rseq-&gt;rseq_cs);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	if (!ptr)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	urseq_cs = (struct rseq_cs __user *)ptr;</span>
<span class="p_add">+	if (copy_from_user(&amp;rseq_cs, urseq_cs, sizeof(rseq_cs)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	if (rseq_cs.version &gt; 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ensure that abort_ip is not in the critical section. */</span>
<span class="p_add">+	if (rseq_cs.abort_ip - rseq_cs.start_ip &lt; rseq_cs.post_commit_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	*cs_flags = rseq_cs.flags;</span>
<span class="p_add">+	*start_ip = rseq_cs.start_ip;</span>
<span class="p_add">+	*post_commit_offset = rseq_cs.post_commit_offset;</span>
<span class="p_add">+	*abort_ip = rseq_cs.abort_ip;</span>
<span class="p_add">+</span>
<span class="p_add">+	usig = (u32 __user *)(rseq_cs.abort_ip - sizeof(u32));</span>
<span class="p_add">+	ret = get_user(sig, usig);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;rseq_sig != sig) {</span>
<span class="p_add">+		printk_ratelimited(KERN_WARNING</span>
<span class="p_add">+			&quot;Possible attack attempt. Unexpected rseq signature 0x%x, expecting 0x%x (pid=%d, addr=%p).\n&quot;,</span>
<span class="p_add">+			sig, current-&gt;rseq_sig, current-&gt;pid, usig);</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rseq_need_restart(struct task_struct *t, uint32_t cs_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t flags, event_mask;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get thread flags. */</span>
<span class="p_add">+	ret = __get_user(flags, &amp;t-&gt;rseq-&gt;flags);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Take critical section flags into account. */</span>
<span class="p_add">+	flags |= cs_flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Restart on signal can only be inhibited when restart on</span>
<span class="p_add">+	 * preempt and restart on migrate are inhibited too. Otherwise,</span>
<span class="p_add">+	 * a preempted signal handler could fail to restart the prior</span>
<span class="p_add">+	 * execution context on sigreturn.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(flags &amp; RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL)) {</span>
<span class="p_add">+		if ((flags &amp; (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE</span>
<span class="p_add">+		    | RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT)) !=</span>
<span class="p_add">+		    (RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE</span>
<span class="p_add">+		     | RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load and clear event mask atomically with respect to</span>
<span class="p_add">+	 * scheduler preemption.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	event_mask = t-&gt;rseq_event_mask;</span>
<span class="p_add">+	t-&gt;rseq_event_mask = 0;</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+	event_mask &amp;= ~flags;</span>
<span class="p_add">+	if (event_mask)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int clear_rseq_cs(struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ptr = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rseq_cs field is set to NULL on preemption or signal</span>
<span class="p_add">+	 * delivery on top of rseq assembly block, as well as on top</span>
<span class="p_add">+	 * of code outside of the rseq assembly block. This performs</span>
<span class="p_add">+	 * a lazy clear of the rseq_cs field.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Set rseq_cs to NULL with single-copy atomicity.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return __put_user(ptr, &amp;t-&gt;rseq-&gt;rseq_cs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int rseq_ip_fixup(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ip = instruction_pointer(regs), start_ip = 0,</span>
<span class="p_add">+		post_commit_offset = 0, abort_ip = 0;</span>
<span class="p_add">+	struct task_struct *t = current;</span>
<span class="p_add">+	uint32_t cs_flags = 0;</span>
<span class="p_add">+	bool in_rseq_cs = false;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = rseq_get_rseq_cs(t, &amp;start_ip, &amp;post_commit_offset, &amp;abort_ip,</span>
<span class="p_add">+			&amp;cs_flags);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Handle potentially not being within a critical section.</span>
<span class="p_add">+	 * Unsigned comparison will be true when</span>
<span class="p_add">+	 * ip &gt;= start_ip, and when ip &lt; start_ip + post_commit_offset.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ip - start_ip &lt; post_commit_offset)</span>
<span class="p_add">+		in_rseq_cs = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If not nested over a rseq critical section, restart is</span>
<span class="p_add">+	 * useless. Clear the rseq_cs pointer and return.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!in_rseq_cs)</span>
<span class="p_add">+		return clear_rseq_cs(t);</span>
<span class="p_add">+	ret = rseq_need_restart(t, cs_flags);</span>
<span class="p_add">+	if (ret &lt;= 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	ret = clear_rseq_cs(t);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	trace_rseq_ip_fixup(ip, start_ip, post_commit_offset, abort_ip);</span>
<span class="p_add">+	instruction_pointer_set(regs, (unsigned long)abort_ip);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This resume handler must always be executed between any of:</span>
<span class="p_add">+ * - preemption,</span>
<span class="p_add">+ * - signal delivery,</span>
<span class="p_add">+ * and return to user-space.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is how we can ensure that the entire rseq critical section,</span>
<span class="p_add">+ * consisting of both the C part and the assembly instruction sequence,</span>
<span class="p_add">+ * will issue the commit instruction only if executed atomically with</span>
<span class="p_add">+ * respect to other threads scheduled on the same CPU, and with respect</span>
<span class="p_add">+ * to signal handlers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __rseq_handle_notify_resume(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *t = current;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(t-&gt;flags &amp; PF_EXITING))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (unlikely(!access_ok(VERIFY_WRITE, t-&gt;rseq, sizeof(*t-&gt;rseq))))</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	ret = rseq_ip_fixup(regs);</span>
<span class="p_add">+	if (unlikely(ret &lt; 0))</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	if (unlikely(rseq_update_cpu_id(t)))</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+error:</span>
<span class="p_add">+	force_sig(SIGSEGV, t);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * sys_rseq - setup restartable sequences for caller thread.</span>
<span class="p_add">+ */</span>
<span class="p_add">+SYSCALL_DEFINE4(rseq, struct rseq __user *, rseq, uint32_t, rseq_len,</span>
<span class="p_add">+		int, flags, uint32_t, sig)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (flags &amp; RSEQ_FLAG_UNREGISTER) {</span>
<span class="p_add">+		/* Unregister rseq for current thread. */</span>
<span class="p_add">+		if (current-&gt;rseq != rseq || !current-&gt;rseq)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (current-&gt;rseq_len != rseq_len)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (current-&gt;rseq_sig != sig)</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+		ret = rseq_reset_rseq_cpu_id(current);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		current-&gt;rseq = NULL;</span>
<span class="p_add">+		current-&gt;rseq_len = 0;</span>
<span class="p_add">+		current-&gt;rseq_sig = 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(flags))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;rseq) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If rseq is already registered, check whether</span>
<span class="p_add">+		 * the provided address differs from the prior</span>
<span class="p_add">+		 * one.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (current-&gt;rseq != rseq || current-&gt;rseq_len != rseq_len)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		if (current-&gt;rseq_sig != sig)</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+		/* Already registered. */</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If there was no rseq previously registered,</span>
<span class="p_add">+	 * ensure the provided rseq is properly aligned and valid.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!IS_ALIGNED((unsigned long)rseq, __alignof__(*rseq)) ||</span>
<span class="p_add">+	    rseq_len != sizeof(*rseq))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, rseq, rseq_len))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	current-&gt;rseq = rseq;</span>
<span class="p_add">+	current-&gt;rseq_len = rseq_len;</span>
<span class="p_add">+	current-&gt;rseq_sig = sig;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If rseq was previously inactive, and has just been</span>
<span class="p_add">+	 * registered, ensure the cpu_id_start and cpu_id fields</span>
<span class="p_add">+	 * are updated before returning to user-space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rseq_set_notify_resume(current);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 75554f366fd3..a7cc81d1fcb6 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -2590,6 +2590,7 @@</span> <span class="p_context"> prepare_task_switch(struct rq *rq, struct task_struct *prev,</span>
 {
 	sched_info_switch(rq, prev, next);
 	perf_event_task_sched_out(prev, next);
<span class="p_add">+	rseq_preempt(prev);</span>
 	fire_sched_out_preempt_notifiers(prev, next);
 	prepare_lock_switch(rq, next);
 	prepare_arch_switch(next);
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index b19552a212de..85e7a622ee88 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -1221,6 +1221,7 @@</span> <span class="p_context"> static inline void __set_task_cpu(struct task_struct *p, unsigned int cpu)</span>
 #endif
 	p-&gt;wake_cpu = cpu;
 #endif
<span class="p_add">+	rseq_migrate(p);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c</span>
<span class="p_header">index b5189762d275..bfa1ee1bf669 100644</span>
<span class="p_header">--- a/kernel/sys_ni.c</span>
<span class="p_header">+++ b/kernel/sys_ni.c</span>
<span class="p_chunk">@@ -259,3 +259,6 @@</span> <span class="p_context"> cond_syscall(sys_membarrier);</span>
 cond_syscall(sys_pkey_mprotect);
 cond_syscall(sys_pkey_alloc);
 cond_syscall(sys_pkey_free);
<span class="p_add">+</span>
<span class="p_add">+/* restartable sequence */</span>
<span class="p_add">+cond_syscall(sys_rseq);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



