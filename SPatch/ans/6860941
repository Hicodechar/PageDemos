
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,v2,1/4] mm: make alloc_pages_exact_node pass __GFP_THISNODE - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,v2,1/4] mm: make alloc_pages_exact_node pass __GFP_THISNODE</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 24, 2015, 2:45 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437749126-25867-1-git-send-email-vbabka@suse.cz&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6860941/mbox/"
   >mbox</a>
|
   <a href="/patch/6860941/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6860941/">/patch/6860941/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id D3F9B9F380
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jul 2015 14:46:59 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 62A11205EE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jul 2015 14:46:58 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D2D01205DF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jul 2015 14:46:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754135AbbGXOqn (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 24 Jul 2015 10:46:43 -0400
Received: from mx2.suse.de ([195.135.220.15]:49391 &quot;EHLO mx2.suse.de&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752173AbbGXOp4 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 24 Jul 2015 10:45:56 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay1.suse.de (charybdis-ext.suse.de [195.135.220.254])
	by mx2.suse.de (Postfix) with ESMTP id 8254AAAC1;
	Fri, 24 Jul 2015 14:45:52 +0000 (UTC)
From: Vlastimil Babka &lt;vbabka@suse.cz&gt;
To: linux-mm@kvack.org
Cc: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Mel Gorman &lt;mgorman@suse.de&gt;, David Rientjes &lt;rientjes@google.com&gt;,
	Greg Thelen &lt;gthelen@google.com&gt;,
	&quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;,
	Christoph Lameter &lt;cl@linux.com&gt;, Pekka Enberg &lt;penberg@kernel.org&gt;,
	Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt;,
	Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;,
	Vlastimil Babka &lt;vbabka@suse.cz&gt;
Subject: [RFC v2 1/4] mm: make alloc_pages_exact_node pass __GFP_THISNODE
Date: Fri, 24 Jul 2015 16:45:23 +0200
Message-Id: &lt;1437749126-25867-1-git-send-email-vbabka@suse.cz&gt;
X-Mailer: git-send-email 2.4.6
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a> - July 24, 2015, 2:45 p.m.</div>
<pre class="content">
The function alloc_pages_exact_node() was introduced in 6484eb3e2a81 (&quot;page
allocator: do not check NUMA node ID when the caller knows the node is valid&quot;)
as an optimized variant of alloc_pages_node(), that doesn&#39;t allow the node id
to be -1. Unfortunately the name of the function can easily suggest that the
allocation is restricted to the given node and fails otherwise. In truth, the
node is only preferred, unless __GFP_THISNODE is passed among the gfp flags.

The misleading name has lead to mistakes in the past, see 5265047ac301 (&quot;mm,
thp: really limit transparent hugepage allocation to local node&quot;) and
b360edb43f8e (&quot;mm, mempolicy: migrate_to_node should only migrate to node&quot;).

To prevent further mistakes and provide a convenience function for allocations
truly restricted to a node, this patch makes alloc_pages_exact_node() pass
__GFP_THISNODE to that effect. The previous implementation of
alloc_pages_exact_node() is copied as __alloc_pages_node() which implies it&#39;s
an optimized variant of __alloc_pages_node() not intended for general usage.
All three functions are described in the comment.

Existing callers of alloc_pages_exact_node() are adjusted as follows:
- those that explicitly pass __GFP_THISNODE keep calling
  alloc_pages_exact_node(), but the flag is removed from the call
- others are converted to call __alloc_pages_node(). Some may still pass
  __GFP_THISNODE if they serve as wrappers that get gfp_flags from higher
  layers.

There&#39;s exception of sba_alloc_coherent() which open-codes the check for
nid == -1, so it is converted to use alloc_pages_node() instead. This means
it no longer performs some VM_BUG_ON checks, but otherwise the whole patch
makes no functional changes.
<span class="signed-off-by">
Signed-off-by: Vlastimil Babka &lt;vbabka@suse.cz&gt;</span>
---
I&#39;ve dropped non-mm guys from CC for now and marked as RFC until we agree on
the API.

 arch/ia64/hp/common/sba_iommu.c   |  6 +-----
 arch/ia64/kernel/uncached.c       |  2 +-
 arch/ia64/sn/pci/pci_dma.c        |  2 +-
 arch/powerpc/platforms/cell/ras.c |  2 +-
 arch/x86/kvm/vmx.c                |  2 +-
 drivers/misc/sgi-xp/xpc_uv.c      |  2 +-
 include/linux/gfp.h               | 23 +++++++++++++++++++++++
 kernel/profile.c                  |  8 ++++----
 mm/filemap.c                      |  2 +-
 mm/hugetlb.c                      |  7 +++----
 mm/memory-failure.c               |  2 +-
 mm/mempolicy.c                    |  6 ++----
 mm/migrate.c                      |  6 ++----
 mm/slab.c                         |  2 +-
 mm/slob.c                         |  2 +-
 mm/slub.c                         |  2 +-
 16 files changed, 45 insertions(+), 31 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=579">David Rientjes</a> - July 24, 2015, 8:08 p.m.</div>
<pre class="content">
On Fri, 24 Jul 2015, Vlastimil Babka wrote:
<span class="quote">
&gt; diff --git a/include/linux/gfp.h b/include/linux/gfp.h</span>
<span class="quote">&gt; index 15928f0..c50848e 100644</span>
<span class="quote">&gt; --- a/include/linux/gfp.h</span>
<span class="quote">&gt; +++ b/include/linux/gfp.h</span>
<span class="quote">&gt; @@ -300,6 +300,22 @@ __alloc_pages(gfp_t gfp_mask, unsigned int order,</span>
<span class="quote">&gt;  	return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * An optimized version of alloc_pages_node(), to be only used in places where</span>
<span class="quote">&gt; + * the overhead of the check for nid == -1 could matter.</span>

We don&#39;t actually check for nid == -1, or nid == NUMA_NO_NODE, in any of 
the functions.  I would just state that nid must be valid and possible to 
allocate from when passed to this function.
<span class="quote">
&gt; + */</span>
<span class="quote">&gt; +static inline struct page *</span>
<span class="quote">&gt; +__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Allocate pages, preferring the node given as nid. When nid equals -1,</span>
<span class="quote">&gt; + * prefer the current CPU&#39;s node.</span>
<span class="quote">&gt; + */</span>

We&#39;ve done quite a bit of work to refer only to NUMA_NO_NODE, so we&#39;d like 
to avoid hardcoded -1 anywhere we can.
<span class="quote">
&gt;  static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;  						unsigned int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -310,11 +326,18 @@ static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Allocate pages, restricting the allocation to the node given as nid. The</span>
<span class="quote">&gt; + * node must be valid and online. This is achieved by adding __GFP_THISNODE</span>
<span class="quote">&gt; + * to gfp_mask.</span>

Not sure we need to point out that __GPF_THISNODE does this, it stands out 
pretty well in the function already :)
<span class="quote">
&gt; + */</span>
<span class="quote">&gt;  static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;  						unsigned int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	gfp_mask |= __GFP_THISNODE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
[snip]

I assume you looked at the collapse_huge_page() case and decided that it 
needs no modification since the gfp mask is used later for other calls?
<span class="quote">
&gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt; index f53838f..d139222 100644</span>
<span class="quote">&gt; --- a/mm/migrate.c</span>
<span class="quote">&gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt; @@ -1554,10 +1554,8 @@ static struct page *alloc_misplaced_dst_page(struct page *page,</span>
<span class="quote">&gt;  	struct page *newpage;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	newpage = alloc_pages_exact_node(nid,</span>
<span class="quote">&gt; -					 (GFP_HIGHUSER_MOVABLE |</span>
<span class="quote">&gt; -					  __GFP_THISNODE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt; -					  __GFP_NORETRY | __GFP_NOWARN) &amp;</span>
<span class="quote">&gt; -					 ~GFP_IOFS, 0);</span>
<span class="quote">&gt; +				(GFP_HIGHUSER_MOVABLE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt; +				 __GFP_NORETRY | __GFP_NOWARN) &amp; ~GFP_IOFS, 0);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return newpage;</span>
<span class="quote">&gt;  }</span>
[snip]

What about the alloc_pages_exact_node() in new_page_node()?
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a> - July 24, 2015, 8:52 p.m.</div>
<pre class="content">
On 24.7.2015 22:08, David Rientjes wrote:
<span class="quote">&gt; On Fri, 24 Jul 2015, Vlastimil Babka wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; diff --git a/include/linux/gfp.h b/include/linux/gfp.h</span>
<span class="quote">&gt;&gt; index 15928f0..c50848e 100644</span>
<span class="quote">&gt;&gt; --- a/include/linux/gfp.h</span>
<span class="quote">&gt;&gt; +++ b/include/linux/gfp.h</span>
<span class="quote">&gt;&gt; @@ -300,6 +300,22 @@ __alloc_pages(gfp_t gfp_mask, unsigned int order,</span>
<span class="quote">&gt;&gt;  	return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL);</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * An optimized version of alloc_pages_node(), to be only used in places where</span>
<span class="quote">&gt;&gt; + * the overhead of the check for nid == -1 could matter.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We don&#39;t actually check for nid == -1, or nid == NUMA_NO_NODE, in any of </span>
<span class="quote">&gt; the functions.  I would just state that nid must be valid and possible to </span>
<span class="quote">&gt; allocate from when passed to this function.</span>

OK
<span class="quote">
&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +static inline struct page *</span>
<span class="quote">&gt;&gt; +__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Allocate pages, preferring the node given as nid. When nid equals -1,</span>
<span class="quote">&gt;&gt; + * prefer the current CPU&#39;s node.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We&#39;ve done quite a bit of work to refer only to NUMA_NO_NODE, so we&#39;d like </span>
<span class="quote">&gt; to avoid hardcoded -1 anywhere we can.</span>

OK
<span class="quote">
&gt;&gt;  static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;&gt;  						unsigned int order)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; @@ -310,11 +326,18 @@ static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Allocate pages, restricting the allocation to the node given as nid. The</span>
<span class="quote">&gt;&gt; + * node must be valid and online. This is achieved by adding __GFP_THISNODE</span>
<span class="quote">&gt;&gt; + * to gfp_mask.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not sure we need to point out that __GPF_THISNODE does this, it stands out </span>
<span class="quote">&gt; pretty well in the function already :)</span>

Right.
<span class="quote">
&gt;&gt; + */</span>
<span class="quote">&gt;&gt;  static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;&gt;  						unsigned int order)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;  	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +	gfp_mask |= __GFP_THISNODE;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt; [snip]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I assume you looked at the collapse_huge_page() case and decided that it </span>
<span class="quote">&gt; needs no modification since the gfp mask is used later for other calls?</span>

Yeah. Not that the memcg charge parts would seem to care about __GFP_THISNODE,
though.
<span class="quote">
&gt;&gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt;&gt; index f53838f..d139222 100644</span>
<span class="quote">&gt;&gt; --- a/mm/migrate.c</span>
<span class="quote">&gt;&gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt;&gt; @@ -1554,10 +1554,8 @@ static struct page *alloc_misplaced_dst_page(struct page *page,</span>
<span class="quote">&gt;&gt;  	struct page *newpage;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	newpage = alloc_pages_exact_node(nid,</span>
<span class="quote">&gt;&gt; -					 (GFP_HIGHUSER_MOVABLE |</span>
<span class="quote">&gt;&gt; -					  __GFP_THISNODE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt;&gt; -					  __GFP_NORETRY | __GFP_NOWARN) &amp;</span>
<span class="quote">&gt;&gt; -					 ~GFP_IOFS, 0);</span>
<span class="quote">&gt;&gt; +				(GFP_HIGHUSER_MOVABLE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt;&gt; +				 __GFP_NORETRY | __GFP_NOWARN) &amp; ~GFP_IOFS, 0);</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	return newpage;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt; [snip]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What about the alloc_pages_exact_node() in new_page_node()?</span>

Oops, seems I missed that one. So the API seems ok otherwise?

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=579">David Rientjes</a> - July 24, 2015, 11:09 p.m.</div>
<pre class="content">
On Fri, 24 Jul 2015, Vlastimil Babka wrote:
<span class="quote">
&gt; &gt; I assume you looked at the collapse_huge_page() case and decided that it </span>
<span class="quote">&gt; &gt; needs no modification since the gfp mask is used later for other calls?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yeah. Not that the memcg charge parts would seem to care about __GFP_THISNODE,</span>
<span class="quote">&gt; though.</span>
<span class="quote">&gt; </span>

Hmm, not sure that memcg would ever care about __GFP_THISNODE.  I wonder 
if it make more sense to remove setting __GFP_THISNODE in 
collapse_huge_page()?  khugepaged_alloc_page() seems fine with the new 
alloc_pages_exact_node() semantics.
<span class="quote">
&gt; &gt;&gt; diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="quote">&gt; &gt;&gt; index f53838f..d139222 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/mm/migrate.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/mm/migrate.c</span>
<span class="quote">&gt; &gt;&gt; @@ -1554,10 +1554,8 @@ static struct page *alloc_misplaced_dst_page(struct page *page,</span>
<span class="quote">&gt; &gt;&gt;  	struct page *newpage;</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  	newpage = alloc_pages_exact_node(nid,</span>
<span class="quote">&gt; &gt;&gt; -					 (GFP_HIGHUSER_MOVABLE |</span>
<span class="quote">&gt; &gt;&gt; -					  __GFP_THISNODE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt; &gt;&gt; -					  __GFP_NORETRY | __GFP_NOWARN) &amp;</span>
<span class="quote">&gt; &gt;&gt; -					 ~GFP_IOFS, 0);</span>
<span class="quote">&gt; &gt;&gt; +				(GFP_HIGHUSER_MOVABLE | __GFP_NOMEMALLOC |</span>
<span class="quote">&gt; &gt;&gt; +				 __GFP_NORETRY | __GFP_NOWARN) &amp; ~GFP_IOFS, 0);</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  	return newpage;</span>
<span class="quote">&gt; &gt;&gt;  }</span>
<span class="quote">&gt; &gt; [snip]</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; What about the alloc_pages_exact_node() in new_page_node()?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Oops, seems I missed that one. So the API seems ok otherwise?</span>
<span class="quote">&gt; </span>

Yup!  And I believe that this patch doesn&#39;t cause any regression after the 
new_page_node() issue is fixed.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45">Johannes Weiner</a> - July 27, 2015, 3:39 p.m.</div>
<pre class="content">
On Fri, Jul 24, 2015 at 04:45:23PM +0200, Vlastimil Babka wrote:
<span class="quote">&gt; @@ -310,11 +326,18 @@ static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Allocate pages, restricting the allocation to the node given as nid. The</span>
<span class="quote">&gt; + * node must be valid and online. This is achieved by adding __GFP_THISNODE</span>
<span class="quote">&gt; + * to gfp_mask.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt;  static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;  						unsigned int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	gfp_mask |= __GFP_THISNODE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;  }</span>

The &quot;exact&quot; name is currently ambiguous within the allocator API, and
it&#39;s bad that we have _exact_node() and _exact_nid() with entirely
different meanings. It&#39;d be good to make &quot;thisnode&quot; refer to specific
and exclusive node requests, and &quot;exact&quot; to mean page allocation
chunks that are not in powers of two.

Would you consider renaming this function to alloc_pages_thisnode() as
part of this series?
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=72672">Vlastimil Babka</a> - July 27, 2015, 3:47 p.m.</div>
<pre class="content">
On 07/27/2015 05:39 PM, Johannes Weiner wrote:
<span class="quote">&gt; On Fri, Jul 24, 2015 at 04:45:23PM +0200, Vlastimil Babka wrote:</span>
<span class="quote">&gt;&gt; @@ -310,11 +326,18 @@ static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;&gt;   	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Allocate pages, restricting the allocation to the node given as nid. The</span>
<span class="quote">&gt;&gt; + * node must be valid and online. This is achieved by adding __GFP_THISNODE</span>
<span class="quote">&gt;&gt; + * to gfp_mask.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt;   static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,</span>
<span class="quote">&gt;&gt;   						unsigned int order)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;   	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +	gfp_mask |= __GFP_THISNODE;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;   	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The &quot;exact&quot; name is currently ambiguous within the allocator API, and</span>
<span class="quote">&gt; it&#39;s bad that we have _exact_node() and _exact_nid() with entirely</span>
<span class="quote">&gt; different meanings. It&#39;d be good to make &quot;thisnode&quot; refer to specific</span>
<span class="quote">&gt; and exclusive node requests, and &quot;exact&quot; to mean page allocation</span>
<span class="quote">&gt; chunks that are not in powers of two.</span>

Ugh, good point.
<span class="quote">
&gt; Would you consider renaming this function to alloc_pages_thisnode() as</span>
<span class="quote">&gt; part of this series?</span>

Sure, let&#39;s do it properly while at it. Yet &quot;thisnode&quot; is somewhat 
misleading name as it might imply the cpu&#39;s local node. The same applies 
to __GFP_THISNODE. So maybe find a better name for both? restrict_node? 
single_node?

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=138281">Mel Gorman</a> - July 29, 2015, 1:30 p.m.</div>
<pre class="content">
On Fri, Jul 24, 2015 at 04:45:23PM +0200, Vlastimil Babka wrote:
<span class="quote">&gt; The function alloc_pages_exact_node() was introduced in 6484eb3e2a81 (&quot;page</span>
<span class="quote">&gt; allocator: do not check NUMA node ID when the caller knows the node is valid&quot;)</span>

No gold stars for that one.
<span class="quote">
&gt; as an optimized variant of alloc_pages_node(), that doesn&#39;t allow the node id</span>
<span class="quote">&gt; to be -1. Unfortunately the name of the function can easily suggest that the</span>
<span class="quote">&gt; allocation is restricted to the given node and fails otherwise. In truth, the</span>
<span class="quote">&gt; node is only preferred, unless __GFP_THISNODE is passed among the gfp flags.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The misleading name has lead to mistakes in the past, see 5265047ac301 (&quot;mm,</span>
<span class="quote">&gt; thp: really limit transparent hugepage allocation to local node&quot;) and</span>
<span class="quote">&gt; b360edb43f8e (&quot;mm, mempolicy: migrate_to_node should only migrate to node&quot;).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To prevent further mistakes and provide a convenience function for allocations</span>
<span class="quote">&gt; truly restricted to a node, this patch makes alloc_pages_exact_node() pass</span>
<span class="quote">&gt; __GFP_THISNODE to that effect. The previous implementation of</span>

The change of what we have now is a good idea. What you have is a solid
improvement in my view but I see there are a few different suggestions
in the thread. Based on that I think it makes sense to just destroy
alloc_pages_exact_node. In the future &quot;exact&quot; in the allocator API will
mean &quot;exactly this number of pages&quot;. Use your __alloc_pages_node helper
and specify __GFP_THISNODE if the caller requires that specific node.
<span class="quote">
&gt; alloc_pages_exact_node() is copied as __alloc_pages_node() which implies it&#39;s</span>
<span class="quote">&gt; an optimized variant of __alloc_pages_node() not intended for general usage.</span>
<span class="quote">&gt; All three functions are described in the comment.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Existing callers of alloc_pages_exact_node() are adjusted as follows:</span>
<span class="quote">&gt; - those that explicitly pass __GFP_THISNODE keep calling</span>
<span class="quote">&gt;   alloc_pages_exact_node(), but the flag is removed from the call</span>

__alloc_pages_node(__GFP_THISNODE) would be harder to get wrong in the future
<span class="quote">
&gt; - others are converted to call __alloc_pages_node(). Some may still pass</span>
<span class="quote">&gt;   __GFP_THISNODE if they serve as wrappers that get gfp_flags from higher</span>
<span class="quote">&gt;   layers.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There&#39;s exception of sba_alloc_coherent() which open-codes the check for</span>
<span class="quote">&gt; nid == -1, so it is converted to use alloc_pages_node() instead. This means</span>
<span class="quote">&gt; it no longer performs some VM_BUG_ON checks, but otherwise the whole patch</span>
<span class="quote">&gt; makes no functional changes.</span>
<span class="quote">&gt; </span>

In general, checks for -1 should go away, particularly with new patches.
Use NUMA_NO_NODE.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1731">Christoph Lameter</a> - July 30, 2015, 2:33 p.m.</div>
<pre class="content">
On Wed, 29 Jul 2015, Mel Gorman wrote:
<span class="quote">
&gt; The change of what we have now is a good idea. What you have is a solid</span>
<span class="quote">&gt; improvement in my view but I see there are a few different suggestions</span>
<span class="quote">&gt; in the thread. Based on that I think it makes sense to just destroy</span>
<span class="quote">&gt; alloc_pages_exact_node. In the future &quot;exact&quot; in the allocator API will</span>
<span class="quote">&gt; mean &quot;exactly this number of pages&quot;. Use your __alloc_pages_node helper</span>
<span class="quote">&gt; and specify __GFP_THISNODE if the caller requires that specific node.</span>

Yes please.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45">Johannes Weiner</a> - July 30, 2015, 3:14 p.m.</div>
<pre class="content">
On Wed, Jul 29, 2015 at 02:30:43PM +0100, Mel Gorman wrote:
<span class="quote">&gt; The change of what we have now is a good idea. What you have is a solid</span>
<span class="quote">&gt; improvement in my view but I see there are a few different suggestions</span>
<span class="quote">&gt; in the thread. Based on that I think it makes sense to just destroy</span>
<span class="quote">&gt; alloc_pages_exact_node. In the future &quot;exact&quot; in the allocator API will</span>
<span class="quote">&gt; mean &quot;exactly this number of pages&quot;. Use your __alloc_pages_node helper</span>
<span class="quote">&gt; and specify __GFP_THISNODE if the caller requires that specific node.</span>

+1
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/ia64/hp/common/sba_iommu.c b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">index 344387a..a6d6190 100644</span>
<span class="p_header">--- a/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">+++ b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_chunk">@@ -1140,13 +1140,9 @@</span> <span class="p_context"> sba_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,</span>
 
 #ifdef CONFIG_NUMA
 	{
<span class="p_del">-		int node = ioc-&gt;node;</span>
 		struct page *page;
 
<span class="p_del">-		if (node == NUMA_NO_NODE)</span>
<span class="p_del">-			node = numa_node_id();</span>
<span class="p_del">-</span>
<span class="p_del">-		page = alloc_pages_exact_node(node, flags, get_order(size));</span>
<span class="p_add">+		page = alloc_pages_node(ioc-&gt;node, flags, get_order(size));</span>
 		if (unlikely(!page))
 			return NULL;
 
<span class="p_header">diff --git a/arch/ia64/kernel/uncached.c b/arch/ia64/kernel/uncached.c</span>
<span class="p_header">index 20e8a9b..b187c87 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/uncached.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/uncached.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static int uncached_add_chunk(struct uncached_pool *uc_pool, int nid)</span>
 	/* attempt to allocate a granule&#39;s worth of cached memory pages */
 
 	page = alloc_pages_exact_node(nid,
<span class="p_del">-				GFP_KERNEL | __GFP_ZERO | __GFP_THISNODE,</span>
<span class="p_add">+				GFP_KERNEL | __GFP_ZERO,</span>
 				IA64_GRANULE_SHIFT-PAGE_SHIFT);
 	if (!page) {
 		mutex_unlock(&amp;uc_pool-&gt;add_chunk_mutex);
<span class="p_header">diff --git a/arch/ia64/sn/pci/pci_dma.c b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">index d0853e8..8f59907 100644</span>
<span class="p_header">--- a/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static void *sn_dma_alloc_coherent(struct device *dev, size_t size,</span>
 	 */
 	node = pcibus_to_node(pdev-&gt;bus);
 	if (likely(node &gt;=0)) {
<span class="p_del">-		struct page *p = alloc_pages_exact_node(node,</span>
<span class="p_add">+		struct page *p = __alloc_pages_node(node,</span>
 						flags, get_order(size));
 
 		if (likely(p))
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/ras.c b/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_header">index e865d74..ff5ae13 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static int __init cbe_ptcal_enable_on_node(int nid, int order)</span>
 	area-&gt;nid = nid;
 	area-&gt;order = order;
 	area-&gt;pages = alloc_pages_exact_node(area-&gt;nid,
<span class="p_del">-						GFP_KERNEL|__GFP_THISNODE,</span>
<span class="p_add">+						GFP_KERNEL,</span>
 						area-&gt;order);
 
 	if (!area-&gt;pages) {
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 2d73807..8c7f3b0 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -3158,7 +3158,7 @@</span> <span class="p_context"> static struct vmcs *alloc_vmcs_cpu(int cpu)</span>
 	struct page *pages;
 	struct vmcs *vmcs;
 
<span class="p_del">-	pages = alloc_pages_exact_node(node, GFP_KERNEL, vmcs_config.order);</span>
<span class="p_add">+	pages = __alloc_pages_node(node, GFP_KERNEL, vmcs_config.order);</span>
 	if (!pages)
 		return NULL;
 	vmcs = page_address(pages);
<span class="p_header">diff --git a/drivers/misc/sgi-xp/xpc_uv.c b/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_header">index 95c8944..a4758cd 100644</span>
<span class="p_header">--- a/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_header">+++ b/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> xpc_create_gru_mq_uv(unsigned int mq_size, int cpu, char *irq_name,</span>
 
 	nid = cpu_to_node(cpu);
 	page = alloc_pages_exact_node(nid,
<span class="p_del">-				      GFP_KERNEL | __GFP_ZERO | __GFP_THISNODE,</span>
<span class="p_add">+				      GFP_KERNEL | __GFP_ZERO,</span>
 				      pg_order);
 	if (page == NULL) {
 		dev_err(xpc_part, &quot;xpc_create_gru_mq_uv() failed to alloc %d &quot;
<span class="p_header">diff --git a/include/linux/gfp.h b/include/linux/gfp.h</span>
<span class="p_header">index 15928f0..c50848e 100644</span>
<span class="p_header">--- a/include/linux/gfp.h</span>
<span class="p_header">+++ b/include/linux/gfp.h</span>
<span class="p_chunk">@@ -300,6 +300,22 @@</span> <span class="p_context"> __alloc_pages(gfp_t gfp_mask, unsigned int order,</span>
 	return __alloc_pages_nodemask(gfp_mask, order, zonelist, NULL);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * An optimized version of alloc_pages_node(), to be only used in places where</span>
<span class="p_add">+ * the overhead of the check for nid == -1 could matter.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct page *</span>
<span class="p_add">+__alloc_pages_node(int nid, gfp_t gfp_mask, unsigned int order)</span>
<span class="p_add">+{</span>
<span class="p_add">+	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));</span>
<span class="p_add">+</span>
<span class="p_add">+	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Allocate pages, preferring the node given as nid. When nid equals -1,</span>
<span class="p_add">+ * prefer the current CPU&#39;s node.</span>
<span class="p_add">+ */</span>
 static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,
 						unsigned int order)
 {
<span class="p_chunk">@@ -310,11 +326,18 @@</span> <span class="p_context"> static inline struct page *alloc_pages_node(int nid, gfp_t gfp_mask,</span>
 	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Allocate pages, restricting the allocation to the node given as nid. The</span>
<span class="p_add">+ * node must be valid and online. This is achieved by adding __GFP_THISNODE</span>
<span class="p_add">+ * to gfp_mask.</span>
<span class="p_add">+ */</span>
 static inline struct page *alloc_pages_exact_node(int nid, gfp_t gfp_mask,
 						unsigned int order)
 {
 	VM_BUG_ON(nid &lt; 0 || nid &gt;= MAX_NUMNODES || !node_online(nid));
 
<span class="p_add">+	gfp_mask |= __GFP_THISNODE;</span>
<span class="p_add">+</span>
 	return __alloc_pages(gfp_mask, order, node_zonelist(nid, gfp_mask));
 }
 
<span class="p_header">diff --git a/kernel/profile.c b/kernel/profile.c</span>
<span class="p_header">index a7bcd28..30a9404 100644</span>
<span class="p_header">--- a/kernel/profile.c</span>
<span class="p_header">+++ b/kernel/profile.c</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> static int profile_cpu_callback(struct notifier_block *info,</span>
 		node = cpu_to_mem(cpu);
 		per_cpu(cpu_profile_flip, cpu) = 0;
 		if (!per_cpu(cpu_profile_hits, cpu)[1]) {
<span class="p_del">-			page = alloc_pages_exact_node(node,</span>
<span class="p_add">+			page = __alloc_pages_node(node,</span>
 					GFP_KERNEL | __GFP_ZERO,
 					0);
 			if (!page)
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> static int profile_cpu_callback(struct notifier_block *info,</span>
 			per_cpu(cpu_profile_hits, cpu)[1] = page_address(page);
 		}
 		if (!per_cpu(cpu_profile_hits, cpu)[0]) {
<span class="p_del">-			page = alloc_pages_exact_node(node,</span>
<span class="p_add">+			page = __alloc_pages_node(node,</span>
 					GFP_KERNEL | __GFP_ZERO,
 					0);
 			if (!page)
<span class="p_chunk">@@ -544,14 +544,14 @@</span> <span class="p_context"> static int create_hash_tables(void)</span>
 		struct page *page;
 
 		page = alloc_pages_exact_node(node,
<span class="p_del">-				GFP_KERNEL | __GFP_ZERO | __GFP_THISNODE,</span>
<span class="p_add">+				GFP_KERNEL | __GFP_ZERO,</span>
 				0);
 		if (!page)
 			goto out_cleanup;
 		per_cpu(cpu_profile_hits, cpu)[1]
 				= (struct profile_hit *)page_address(page);
 		page = alloc_pages_exact_node(node,
<span class="p_del">-				GFP_KERNEL | __GFP_ZERO | __GFP_THISNODE,</span>
<span class="p_add">+				GFP_KERNEL | __GFP_ZERO,</span>
 				0);
 		if (!page)
 			goto out_cleanup;
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 6bf5e42..5a7d4e2 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -648,7 +648,7 @@</span> <span class="p_context"> struct page *__page_cache_alloc(gfp_t gfp)</span>
 		do {
 			cpuset_mems_cookie = read_mems_allowed_begin();
 			n = cpuset_mem_spread_node();
<span class="p_del">-			page = alloc_pages_exact_node(n, gfp, 0);</span>
<span class="p_add">+			page = __alloc_pages_node(n, gfp, 0);</span>
 		} while (!page &amp;&amp; read_mems_allowed_retry(cpuset_mems_cookie));
 
 		return page;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 271e443..156d8d7 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1089,8 +1089,7 @@</span> <span class="p_context"> static struct page *alloc_fresh_huge_page_node(struct hstate *h, int nid)</span>
 	struct page *page;
 
 	page = alloc_pages_exact_node(nid,
<span class="p_del">-		htlb_alloc_mask(h)|__GFP_COMP|__GFP_THISNODE|</span>
<span class="p_del">-						__GFP_REPEAT|__GFP_NOWARN,</span>
<span class="p_add">+		htlb_alloc_mask(h)|__GFP_COMP|__GFP_REPEAT|__GFP_NOWARN,</span>
 		huge_page_order(h));
 	if (page) {
 		if (arch_prepare_hugepage(page)) {
<span class="p_chunk">@@ -1251,8 +1250,8 @@</span> <span class="p_context"> static struct page *alloc_buddy_huge_page(struct hstate *h, int nid)</span>
 				   huge_page_order(h));
 	else
 		page = alloc_pages_exact_node(nid,
<span class="p_del">-			htlb_alloc_mask(h)|__GFP_COMP|__GFP_THISNODE|</span>
<span class="p_del">-			__GFP_REPEAT|__GFP_NOWARN, huge_page_order(h));</span>
<span class="p_add">+			htlb_alloc_mask(h)|__GFP_COMP|__GFP_REPEAT|</span>
<span class="p_add">+			__GFP_NOWARN, huge_page_order(h));</span>
 
 	if (page &amp;&amp; arch_prepare_hugepage(page)) {
 		__free_pages(page, huge_page_order(h));
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 501820c..b783bc5 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1503,7 +1503,7 @@</span> <span class="p_context"> static struct page *new_page(struct page *p, unsigned long private, int **x)</span>
 		return alloc_huge_page_node(page_hstate(compound_head(p)),
 						   nid);
 	else
<span class="p_del">-		return alloc_pages_exact_node(nid, GFP_HIGHUSER_MOVABLE, 0);</span>
<span class="p_add">+		return __alloc_pages_node(nid, GFP_HIGHUSER_MOVABLE, 0);</span>
 }
 
 /*
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index 7477432..4547960 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -945,8 +945,7 @@</span> <span class="p_context"> static struct page *new_node_page(struct page *page, unsigned long node, int **x</span>
 		return alloc_huge_page_node(page_hstate(compound_head(page)),
 					node);
 	else
<span class="p_del">-		return alloc_pages_exact_node(node, GFP_HIGHUSER_MOVABLE |</span>
<span class="p_del">-						    __GFP_THISNODE, 0);</span>
<span class="p_add">+		return alloc_pages_exact_node(node, GFP_HIGHUSER_MOVABLE, 0);</span>
 }
 
 /*
<span class="p_chunk">@@ -1986,8 +1985,7 @@</span> <span class="p_context"> alloc_pages_vma(gfp_t gfp, int order, struct vm_area_struct *vma,</span>
 		nmask = policy_nodemask(gfp, pol);
 		if (!nmask || node_isset(node, *nmask)) {
 			mpol_cond_put(pol);
<span class="p_del">-			page = alloc_pages_exact_node(node,</span>
<span class="p_del">-						gfp | __GFP_THISNODE, order);</span>
<span class="p_add">+			page = alloc_pages_exact_node(node, gfp, order);</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/mm/migrate.c b/mm/migrate.c</span>
<span class="p_header">index f53838f..d139222 100644</span>
<span class="p_header">--- a/mm/migrate.c</span>
<span class="p_header">+++ b/mm/migrate.c</span>
<span class="p_chunk">@@ -1554,10 +1554,8 @@</span> <span class="p_context"> static struct page *alloc_misplaced_dst_page(struct page *page,</span>
 	struct page *newpage;
 
 	newpage = alloc_pages_exact_node(nid,
<span class="p_del">-					 (GFP_HIGHUSER_MOVABLE |</span>
<span class="p_del">-					  __GFP_THISNODE | __GFP_NOMEMALLOC |</span>
<span class="p_del">-					  __GFP_NORETRY | __GFP_NOWARN) &amp;</span>
<span class="p_del">-					 ~GFP_IOFS, 0);</span>
<span class="p_add">+				(GFP_HIGHUSER_MOVABLE | __GFP_NOMEMALLOC |</span>
<span class="p_add">+				 __GFP_NORETRY | __GFP_NOWARN) &amp; ~GFP_IOFS, 0);</span>
 
 	return newpage;
 }
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index 7eb38dd..5f49e63 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -1594,7 +1594,7 @@</span> <span class="p_context"> static struct page *kmem_getpages(struct kmem_cache *cachep, gfp_t flags,</span>
 	if (memcg_charge_slab(cachep, flags, cachep-&gt;gfporder))
 		return NULL;
 
<span class="p_del">-	page = alloc_pages_exact_node(nodeid, flags | __GFP_NOTRACK, cachep-&gt;gfporder);</span>
<span class="p_add">+	page = __alloc_pages_node(nodeid, flags | __GFP_NOTRACK, cachep-&gt;gfporder);</span>
 	if (!page) {
 		memcg_uncharge_slab(cachep, cachep-&gt;gfporder);
 		slab_out_of_memory(cachep, flags, nodeid);
<span class="p_header">diff --git a/mm/slob.c b/mm/slob.c</span>
<span class="p_header">index 4765f65..10d8e02 100644</span>
<span class="p_header">--- a/mm/slob.c</span>
<span class="p_header">+++ b/mm/slob.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> static void *slob_new_pages(gfp_t gfp, int order, int node)</span>
 
 #ifdef CONFIG_NUMA
 	if (node != NUMA_NO_NODE)
<span class="p_del">-		page = alloc_pages_exact_node(node, gfp, order);</span>
<span class="p_add">+		page = __alloc_pages_node(node, gfp, order);</span>
 	else
 #endif
 		page = alloc_pages(gfp, order);
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 54c0876..0486343 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -1323,7 +1323,7 @@</span> <span class="p_context"> static inline struct page *alloc_slab_page(struct kmem_cache *s,</span>
 	if (node == NUMA_NO_NODE)
 		page = alloc_pages(flags, order);
 	else
<span class="p_del">-		page = alloc_pages_exact_node(node, flags, order);</span>
<span class="p_add">+		page = __alloc_pages_node(node, flags, order);</span>
 
 	if (!page)
 		memcg_uncharge_slab(s, order);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



