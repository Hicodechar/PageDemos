
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>mm: save/restore current-&gt;journal_info in handle_mm_fault - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    mm: save/restore current-&gt;journal_info in handle_mm_fault</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=108291">Yan, Zheng</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 14, 2017, 10:55 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171214105527.5885-1-zyan@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10111821/mbox/"
   >mbox</a>
|
   <a href="/patch/10111821/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10111821/">/patch/10111821/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A2AD260327 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:55:43 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9677228EAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:55:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8B639299D3; Thu, 14 Dec 2017 10:55:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2BE7328EAA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Dec 2017 10:55:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751962AbdLNKzh (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Dec 2017 05:55:37 -0500
Received: from mx1.redhat.com ([209.132.183.28]:45510 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751587AbdLNKzf (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Dec 2017 05:55:35 -0500
Received: from smtp.corp.redhat.com
	(int-mx03.intmail.prod.int.phx2.redhat.com [10.5.11.13])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 0EFD6C057FA4;
	Thu, 14 Dec 2017 10:55:35 +0000 (UTC)
Received: from ovpn-12-55.pek2.redhat.com (ovpn-12-55.pek2.redhat.com
	[10.72.12.55])
	by smtp.corp.redhat.com (Postfix) with ESMTP id F17C66F971;
	Thu, 14 Dec 2017 10:55:29 +0000 (UTC)
From: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;
To: linux-kernel@vger.kernel.org, linux-fsdevel@vger.kernel.org,
	ceph-devel@vger.kernel.org, linux-ext4@vger.kernel.org,
	linux-btrfs@vger.kernel.org, linux-mm@kvack.org,
	akpm@linux-foundation.org
Cc: viro@zeniv.linux.org.uk, jlayton@redhat.com,
	&quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;, stable@vger.kernel.org
Subject: [PATCH] mm: save/restore current-&gt;journal_info in handle_mm_fault
Date: Thu, 14 Dec 2017 18:55:27 +0800
Message-Id: &lt;20171214105527.5885-1-zyan@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.13
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.32]);
	Thu, 14 Dec 2017 10:55:35 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=108291">Yan, Zheng</a> - Dec. 14, 2017, 10:55 a.m.</div>
<pre class="content">
We recently got an Oops report:

BUG: unable to handle kernel NULL pointer dereference at (null)
IP: jbd2__journal_start+0x38/0x1a2
[...]
Call Trace:
  ext4_page_mkwrite+0x307/0x52b
  _ext4_get_block+0xd8/0xd8
  do_page_mkwrite+0x6e/0xd8
  handle_mm_fault+0x686/0xf9b
  mntput_no_expire+0x1f/0x21e
  __do_page_fault+0x21d/0x465
  dput+0x4a/0x2f7
  page_fault+0x22/0x30
  copy_user_generic_string+0x2c/0x40
  copy_page_to_iter+0x8c/0x2b8
  generic_file_read_iter+0x26e/0x845
  timerqueue_del+0x31/0x90
  ceph_read_iter+0x697/0xa33 [ceph]
  hrtimer_cancel+0x23/0x41
  futex_wait+0x1c8/0x24d
  get_futex_key+0x32c/0x39a
  __vfs_read+0xe0/0x130
  vfs_read.part.1+0x6c/0x123
  handle_mm_fault+0x831/0xf9b
  __fget+0x7e/0xbf
  SyS_read+0x4d/0xb5

ceph_read_iter() uses current-&gt;journal_info to pass context info to
ceph_readpages(). Because ceph_readpages() needs to know if its caller
has already gotten capability of using page cache (distinguish read
from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,
then calls generic_file_read_iter().

In above Oops, page fault happened when copying data to userspace.
Page fault handler called ext4_page_mkwrite(). Ext4 code read
current-&gt;journal_info and assumed it is journal handle.

I checked other filesystems, btrfs probably suffers similar problem
for its readpage. (page fault happens when write() copies data from
userspace memory and the memory is mapped to a file in btrfs.
verify_parent_transid() can be called during readpage)

Cc: stable@vger.kernel.org
<span class="signed-off-by">Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>
---
 mm/memory.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Dec. 14, 2017, 1:30 p.m.</div>
<pre class="content">
On Thu 14-12-17 18:55:27, Yan, Zheng wrote:
<span class="quote">&gt; We recently got an Oops report:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt;   ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt;   _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt;   do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt;   handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt;   mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt;   __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt;   dput+0x4a/0x2f7</span>
<span class="quote">&gt;   page_fault+0x22/0x30</span>
<span class="quote">&gt;   copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt;   copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt;   generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt;   timerqueue_del+0x31/0x90</span>
<span class="quote">&gt;   ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt;   hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt;   futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt;   get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt;   __vfs_read+0xe0/0x130</span>
<span class="quote">&gt;   vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt;   handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt;   __fget+0x7e/0xbf</span>
<span class="quote">&gt;   SyS_read+0x4d/0xb5</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>

I am not an FS expert so (ab)using journal_info for unrelated purposes
might be acceptable in general but hooking into the generic PF path like
this is just too ugly to live. Can this be limited to a FS code so that
not everybody has to pay additional cycles? With a big fat warning that
(ab)users might want to find a better way to comunicate their internal
stuff.
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;  mm/memory.c | 14 ++++++++++++++</span>
<span class="quote">&gt;  1 file changed, 14 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="quote">&gt; index a728bed16c20..db2a50233c49 100644</span>
<span class="quote">&gt; --- a/mm/memory.c</span>
<span class="quote">&gt; +++ b/mm/memory.c</span>
<span class="quote">&gt; @@ -4044,6 +4044,7 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;  		unsigned int flags)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt; +	void *old_journal_info;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	__set_current_state(TASK_RUNNING);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -4065,11 +4066,24 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;  	if (flags &amp; FAULT_FLAG_USER)</span>
<span class="quote">&gt;  		mem_cgroup_oom_enable();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Fault can happen when filesystem A&#39;s read_iter()/write_iter()</span>
<span class="quote">&gt; +	 * copies data to/from userspace. Filesystem A may have set</span>
<span class="quote">&gt; +	 * current-&gt;journal_info. If the userspace memory is MAP_SHARED</span>
<span class="quote">&gt; +	 * mapped to a file in filesystem B, we later may call filesystem</span>
<span class="quote">&gt; +	 * B&#39;s vm operation. Filesystem B may also want to read/set</span>
<span class="quote">&gt; +	 * current-&gt;journal_info.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	old_journal_info = current-&gt;journal_info;</span>
<span class="quote">&gt; +	current-&gt;journal_info = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (unlikely(is_vm_hugetlb_page(vma)))</span>
<span class="quote">&gt;  		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span>
<span class="quote">&gt;  	else</span>
<span class="quote">&gt;  		ret = __handle_mm_fault(vma, address, flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	current-&gt;journal_info = old_journal_info;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (flags &amp; FAULT_FLAG_USER) {</span>
<span class="quote">&gt;  		mem_cgroup_oom_disable();</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.13.6</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - Dec. 14, 2017, 1:43 p.m.</div>
<pre class="content">
On Thu 14-12-17 18:55:27, Yan, Zheng wrote:
<span class="quote">&gt; We recently got an Oops report:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt;   ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt;   _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt;   do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt;   handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt;   mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt;   __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt;   dput+0x4a/0x2f7</span>
<span class="quote">&gt;   page_fault+0x22/0x30</span>
<span class="quote">&gt;   copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt;   copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt;   generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt;   timerqueue_del+0x31/0x90</span>
<span class="quote">&gt;   ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt;   hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt;   futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt;   get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt;   __vfs_read+0xe0/0x130</span>
<span class="quote">&gt;   vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt;   handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt;   __fget+0x7e/0xbf</span>
<span class="quote">&gt;   SyS_read+0x4d/0xb5</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>

I agree with the analysis but the patch is too ugly too live. Ceph just
should not be abusing current-&gt;journal_info for passing information between
two random functions or when it does a hackery like this, it should just
make sure the pieces hold together. Poluting generic code to accommodate
this hack in Ceph is not acceptable. Also bear in mind there are likely
other code paths (e.g. memory reclaim) which could recurse into another
filesystem confusing it with non-NULL current-&gt;journal_info in the same
way.

In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into
readpage() / readpages() handler when it already gets that pointer as part
of arguments...

								Honza
<span class="quote">
&gt; diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="quote">&gt; index a728bed16c20..db2a50233c49 100644</span>
<span class="quote">&gt; --- a/mm/memory.c</span>
<span class="quote">&gt; +++ b/mm/memory.c</span>
<span class="quote">&gt; @@ -4044,6 +4044,7 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;  		unsigned int flags)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt; +	void *old_journal_info;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	__set_current_state(TASK_RUNNING);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -4065,11 +4066,24 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;  	if (flags &amp; FAULT_FLAG_USER)</span>
<span class="quote">&gt;  		mem_cgroup_oom_enable();</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Fault can happen when filesystem A&#39;s read_iter()/write_iter()</span>
<span class="quote">&gt; +	 * copies data to/from userspace. Filesystem A may have set</span>
<span class="quote">&gt; +	 * current-&gt;journal_info. If the userspace memory is MAP_SHARED</span>
<span class="quote">&gt; +	 * mapped to a file in filesystem B, we later may call filesystem</span>
<span class="quote">&gt; +	 * B&#39;s vm operation. Filesystem B may also want to read/set</span>
<span class="quote">&gt; +	 * current-&gt;journal_info.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	old_journal_info = current-&gt;journal_info;</span>
<span class="quote">&gt; +	current-&gt;journal_info = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (unlikely(is_vm_hugetlb_page(vma)))</span>
<span class="quote">&gt;  		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span>
<span class="quote">&gt;  	else</span>
<span class="quote">&gt;  		ret = __handle_mm_fault(vma, address, flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	current-&gt;journal_info = old_journal_info;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (flags &amp; FAULT_FLAG_USER) {</span>
<span class="quote">&gt;  		mem_cgroup_oom_disable();</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.13.6</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=70561">Yan, Zheng</a> - Dec. 14, 2017, 2:30 p.m.</div>
<pre class="content">
On Thu, Dec 14, 2017 at 9:43 PM, Jan Kara &lt;jack@suse.cz&gt; wrote:
<span class="quote">&gt; On Thu 14-12-17 18:55:27, Yan, Zheng wrote:</span>
<span class="quote">&gt;&gt; We recently got an Oops report:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt;&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt; Call Trace:</span>
<span class="quote">&gt;&gt;   ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt;&gt;   _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt;&gt;   do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt;&gt;   handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt;&gt;   mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt;&gt;   __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt;&gt;   dput+0x4a/0x2f7</span>
<span class="quote">&gt;&gt;   page_fault+0x22/0x30</span>
<span class="quote">&gt;&gt;   copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt;&gt;   copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt;&gt;   generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt;&gt;   timerqueue_del+0x31/0x90</span>
<span class="quote">&gt;&gt;   ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt;&gt;   hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt;&gt;   futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt;&gt;   get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt;&gt;   __vfs_read+0xe0/0x130</span>
<span class="quote">&gt;&gt;   vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt;&gt;   handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt;&gt;   __fget+0x7e/0xbf</span>
<span class="quote">&gt;&gt;   SyS_read+0x4d/0xb5</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt;&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt;&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt;&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt;&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt;&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt;&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt;&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt;&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt;&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt;&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I agree with the analysis but the patch is too ugly too live. Ceph just</span>
<span class="quote">&gt; should not be abusing current-&gt;journal_info for passing information between</span>
<span class="quote">&gt; two random functions or when it does a hackery like this, it should just</span>
<span class="quote">&gt; make sure the pieces hold together. Poluting generic code to accommodate</span>
<span class="quote">&gt; this hack in Ceph is not acceptable. Also bear in mind there are likely</span>
<span class="quote">&gt; other code paths (e.g. memory reclaim) which could recurse into another</span>
<span class="quote">&gt; filesystem confusing it with non-NULL current-&gt;journal_info in the same</span>
<span class="quote">&gt; way.</span>

But ...

some filesystem set journal_info in its write_begin(), then clear it
in write_end(). If buffer for write is mapped to another filesystem,
current-&gt;journal can leak to the later filesystem&#39;s page_readpage().
The later filesystem may read current-&gt;journal and treat it as its own
journal handle.  Besides, most filesystem&#39;s vm fault handle is
filemap_fault(), filemap also may tigger memory reclaim.
<span class="quote">
&gt;</span>
<span class="quote">&gt; In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into</span>
<span class="quote">&gt; readpage() / readpages() handler when it already gets that pointer as part</span>
<span class="quote">&gt; of arguments...</span>

It actually a flag which tells ceph_readpages() if its caller is
ceph_read_iter or readahead/fadvise/madvise. because when there are
multiple clients read/write a file a the same time, page cache should
be disabled.

Regards
Yan, Zheng
<span class="quote">
&gt;</span>
<span class="quote">&gt;                                                                 Honza</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="quote">&gt;&gt; index a728bed16c20..db2a50233c49 100644</span>
<span class="quote">&gt;&gt; --- a/mm/memory.c</span>
<span class="quote">&gt;&gt; +++ b/mm/memory.c</span>
<span class="quote">&gt;&gt; @@ -4044,6 +4044,7 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;&gt;               unsigned int flags)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;       int ret;</span>
<span class="quote">&gt;&gt; +     void *old_journal_info;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;       __set_current_state(TASK_RUNNING);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; @@ -4065,11 +4066,24 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;&gt;       if (flags &amp; FAULT_FLAG_USER)</span>
<span class="quote">&gt;&gt;               mem_cgroup_oom_enable();</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +     /*</span>
<span class="quote">&gt;&gt; +      * Fault can happen when filesystem A&#39;s read_iter()/write_iter()</span>
<span class="quote">&gt;&gt; +      * copies data to/from userspace. Filesystem A may have set</span>
<span class="quote">&gt;&gt; +      * current-&gt;journal_info. If the userspace memory is MAP_SHARED</span>
<span class="quote">&gt;&gt; +      * mapped to a file in filesystem B, we later may call filesystem</span>
<span class="quote">&gt;&gt; +      * B&#39;s vm operation. Filesystem B may also want to read/set</span>
<span class="quote">&gt;&gt; +      * current-&gt;journal_info.</span>
<span class="quote">&gt;&gt; +      */</span>
<span class="quote">&gt;&gt; +     old_journal_info = current-&gt;journal_info;</span>
<span class="quote">&gt;&gt; +     current-&gt;journal_info = NULL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;       if (unlikely(is_vm_hugetlb_page(vma)))</span>
<span class="quote">&gt;&gt;               ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span>
<span class="quote">&gt;&gt;       else</span>
<span class="quote">&gt;&gt;               ret = __handle_mm_fault(vma, address, flags);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +     current-&gt;journal_info = old_journal_info;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;       if (flags &amp; FAULT_FLAG_USER) {</span>
<span class="quote">&gt;&gt;               mem_cgroup_oom_disable();</span>
<span class="quote">&gt;&gt;               /*</span>
<span class="quote">&gt;&gt; --</span>
<span class="quote">&gt;&gt; 2.13.6</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Jan Kara &lt;jack@suse.com&gt;</span>
<span class="quote">&gt; SUSE Labs, CR</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe ceph-devel&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - Dec. 14, 2017, 4:53 p.m.</div>
<pre class="content">
On Thu 14-12-17 22:30:26, Yan, Zheng wrote:
<span class="quote">&gt; On Thu, Dec 14, 2017 at 9:43 PM, Jan Kara &lt;jack@suse.cz&gt; wrote:</span>
<span class="quote">&gt; &gt; On Thu 14-12-17 18:55:27, Yan, Zheng wrote:</span>
<span class="quote">&gt; &gt;&gt; We recently got an Oops report:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt; &gt;&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt; Call Trace:</span>
<span class="quote">&gt; &gt;&gt;   ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt; &gt;&gt;   _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt; &gt;&gt;   do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt; &gt;&gt;   handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt; &gt;&gt;   mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt; &gt;&gt;   __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt; &gt;&gt;   dput+0x4a/0x2f7</span>
<span class="quote">&gt; &gt;&gt;   page_fault+0x22/0x30</span>
<span class="quote">&gt; &gt;&gt;   copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt; &gt;&gt;   copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt; &gt;&gt;   generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt; &gt;&gt;   timerqueue_del+0x31/0x90</span>
<span class="quote">&gt; &gt;&gt;   ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt; &gt;&gt;   hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt; &gt;&gt;   futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt; &gt;&gt;   get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt; &gt;&gt;   __vfs_read+0xe0/0x130</span>
<span class="quote">&gt; &gt;&gt;   vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt; &gt;&gt;   handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt; &gt;&gt;   __fget+0x7e/0xbf</span>
<span class="quote">&gt; &gt;&gt;   SyS_read+0x4d/0xb5</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt; &gt;&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt; &gt;&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt; &gt;&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt; &gt;&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt; &gt;&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt; &gt;&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt; &gt;&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt; &gt;&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt; &gt;&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt; &gt;&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I agree with the analysis but the patch is too ugly too live. Ceph just</span>
<span class="quote">&gt; &gt; should not be abusing current-&gt;journal_info for passing information between</span>
<span class="quote">&gt; &gt; two random functions or when it does a hackery like this, it should just</span>
<span class="quote">&gt; &gt; make sure the pieces hold together. Poluting generic code to accommodate</span>
<span class="quote">&gt; &gt; this hack in Ceph is not acceptable. Also bear in mind there are likely</span>
<span class="quote">&gt; &gt; other code paths (e.g. memory reclaim) which could recurse into another</span>
<span class="quote">&gt; &gt; filesystem confusing it with non-NULL current-&gt;journal_info in the same</span>
<span class="quote">&gt; &gt; way.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; some filesystem set journal_info in its write_begin(), then clear it</span>
<span class="quote">&gt; in write_end(). If buffer for write is mapped to another filesystem,</span>
<span class="quote">&gt; current-&gt;journal can leak to the later filesystem&#39;s page_readpage().</span>
<span class="quote">&gt; The later filesystem may read current-&gt;journal and treat it as its own</span>
<span class="quote">&gt; journal handle.  Besides, most filesystem&#39;s vm fault handle is</span>
<span class="quote">&gt; filemap_fault(), filemap also may tigger memory reclaim.</span>

Did you really observe this? Because write path uses
iov_iter_copy_from_user_atomic() which does not allow page faults to
happen. All page faulting happens in iov_iter_fault_in_readable() before
-&gt;write_begin() is called. And the recursion problems like you mention
above are exactly the reason why things are done in a more complicated way
like this.
<span class="quote">
&gt; &gt;</span>
<span class="quote">&gt; &gt; In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into</span>
<span class="quote">&gt; &gt; readpage() / readpages() handler when it already gets that pointer as part</span>
<span class="quote">&gt; &gt; of arguments...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It actually a flag which tells ceph_readpages() if its caller is</span>
<span class="quote">&gt; ceph_read_iter or readahead/fadvise/madvise. because when there are</span>
<span class="quote">&gt; multiple clients read/write a file a the same time, page cache should</span>
<span class="quote">&gt; be disabled.</span>

I&#39;m not sure I understand the reasoning properly but from what you say
above it rather seems the &#39;hint&#39; should be stored in the inode (or possibly
struct file)?

								Honza
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=8253">Andreas Dilger</a> - Dec. 14, 2017, 8:48 p.m.</div>
<pre class="content">
[remove stable@ as this is not really a stable patch]

On Dec 14, 2017, at 7:30 AM, Yan, Zheng &lt;ukernel@gmail.com&gt; wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; On Thu, Dec 14, 2017 at 9:43 PM, Jan Kara &lt;jack@suse.cz&gt; wrote:</span>
<span class="quote">&gt;&gt; On Thu 14-12-17 18:55:27, Yan, Zheng wrote:</span>
<span class="quote">&gt;&gt;&gt; We recently got an Oops report:</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt;&gt;&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt;&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt; Call Trace:</span>
<span class="quote">&gt;&gt;&gt;  ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt;&gt;&gt;  _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt;&gt;&gt;  do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt;&gt;&gt;  handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt;&gt;&gt;  mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt;&gt;&gt;  __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt;&gt;&gt;  dput+0x4a/0x2f7</span>
<span class="quote">&gt;&gt;&gt;  page_fault+0x22/0x30</span>
<span class="quote">&gt;&gt;&gt;  copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt;&gt;&gt;  copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt;&gt;&gt;  generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt;&gt;&gt;  timerqueue_del+0x31/0x90</span>
<span class="quote">&gt;&gt;&gt;  ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt;&gt;&gt;  hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt;&gt;&gt;  futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt;&gt;&gt;  get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt;&gt;&gt;  __vfs_read+0xe0/0x130</span>
<span class="quote">&gt;&gt;&gt;  vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt;&gt;&gt;  handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt;&gt;&gt;  __fget+0x7e/0xbf</span>
<span class="quote">&gt;&gt;&gt;  SyS_read+0x4d/0xb5</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt;&gt;&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt;&gt;&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt;&gt;&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt;&gt;&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt;&gt;&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt;&gt;&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt;&gt;&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt;&gt;&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt;&gt;&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; I agree with the analysis but the patch is too ugly too live. Ceph just</span>
<span class="quote">&gt;&gt; should not be abusing current-&gt;journal_info for passing information between</span>
<span class="quote">&gt;&gt; two random functions or when it does a hackery like this, it should just</span>
<span class="quote">&gt;&gt; make sure the pieces hold together. Poluting generic code to accommodate</span>
<span class="quote">&gt;&gt; this hack in Ceph is not acceptable. Also bear in mind there are likely</span>
<span class="quote">&gt;&gt; other code paths (e.g. memory reclaim) which could recurse into another</span>
<span class="quote">&gt;&gt; filesystem confusing it with non-NULL current-&gt;journal_info in the same</span>
<span class="quote">&gt;&gt; way.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; some filesystem set journal_info in its write_begin(), then clear it</span>
<span class="quote">&gt; in write_end(). If buffer for write is mapped to another filesystem,</span>
<span class="quote">&gt; current-&gt;journal can leak to the later filesystem&#39;s page_readpage().</span>
<span class="quote">&gt; The later filesystem may read current-&gt;journal and treat it as its own</span>
<span class="quote">&gt; journal handle.  Besides, most filesystem&#39;s vm fault handle is</span>
<span class="quote">&gt; filemap_fault(), filemap also may tigger memory reclaim.</span>

Shouldn&#39;t the memory reclaim be prevented from recursing into the other
filesystem by use of GFP_NOFS, or the new memalloc_nofs annotation?

I don&#39;t think that ext4 is ever using current-&gt;journal on any read paths,
only in case of writes.
<span class="quote">
&gt;&gt; In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into</span>
<span class="quote">&gt;&gt; readpage() / readpages() handler when it already gets that pointer as part</span>
<span class="quote">&gt;&gt; of arguments...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It actually a flag which tells ceph_readpages() if its caller is</span>
<span class="quote">&gt; ceph_read_iter or readahead/fadvise/madvise. because when there are</span>
<span class="quote">&gt; multiple clients read/write a file a the same time, page cache should</span>
<span class="quote">&gt; be disabled.</span>

I&#39;ve wanted something similar for other reasons.  It would be better to
have a separate fs-specific pointer in the task struct to handle this
kind of information.  This can be used by the filesystem &quot;upper half&quot; to
communicate with the &quot;lower half&quot; (doing the writeout or other IO below
the VFS), and the &quot;lower half&quot; can use -&gt;journal for handling the writeout.

However, some care would be needed to ensure that other processes accessing
this pointer would only do so if it is their own.  Something like
-&gt;fs_private_sb and -&gt;fs_private_data would allow this sanely.  If the
-&gt;fs_private_sb != sb in the filesystem then -&gt;fs_private_data is not valid
for this fs and cannot be used by the current filesystem code.  Alternately,
we could have a single -&gt;fs_private pointer to reduce impact on task_struct
so long as all filesystems used the first field of the structure to point to
&quot;sb&quot;, probably with a library helper to ensure this was done consistently:

	data = current_fs_private_get(sb);
        current_fs_private_set(sb, data);
	data = current_fs_private_alloc(sb, size, gfp);

or whatever.
<span class="quote">
&gt; Regards</span>
<span class="quote">&gt; Yan, Zheng</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt;                                                                Honza</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="quote">&gt;&gt;&gt; index a728bed16c20..db2a50233c49 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/mm/memory.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/mm/memory.c</span>
<span class="quote">&gt;&gt;&gt; @@ -4044,6 +4044,7 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;&gt;&gt;              unsigned int flags)</span>
<span class="quote">&gt;&gt;&gt; {</span>
<span class="quote">&gt;&gt;&gt;      int ret;</span>
<span class="quote">&gt;&gt;&gt; +     void *old_journal_info;</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt;      __set_current_state(TASK_RUNNING);</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; @@ -4065,11 +4066,24 @@ int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt;&gt;&gt;      if (flags &amp; FAULT_FLAG_USER)</span>
<span class="quote">&gt;&gt;&gt;              mem_cgroup_oom_enable();</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; +     /*</span>
<span class="quote">&gt;&gt;&gt; +      * Fault can happen when filesystem A&#39;s read_iter()/write_iter()</span>
<span class="quote">&gt;&gt;&gt; +      * copies data to/from userspace. Filesystem A may have set</span>
<span class="quote">&gt;&gt;&gt; +      * current-&gt;journal_info. If the userspace memory is MAP_SHARED</span>
<span class="quote">&gt;&gt;&gt; +      * mapped to a file in filesystem B, we later may call filesystem</span>
<span class="quote">&gt;&gt;&gt; +      * B&#39;s vm operation. Filesystem B may also want to read/set</span>
<span class="quote">&gt;&gt;&gt; +      * current-&gt;journal_info.</span>
<span class="quote">&gt;&gt;&gt; +      */</span>
<span class="quote">&gt;&gt;&gt; +     old_journal_info = current-&gt;journal_info;</span>
<span class="quote">&gt;&gt;&gt; +     current-&gt;journal_info = NULL;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;      if (unlikely(is_vm_hugetlb_page(vma)))</span>
<span class="quote">&gt;&gt;&gt;              ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span>
<span class="quote">&gt;&gt;&gt;      else</span>
<span class="quote">&gt;&gt;&gt;              ret = __handle_mm_fault(vma, address, flags);</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt;&gt; +     current-&gt;journal_info = old_journal_info;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;      if (flags &amp; FAULT_FLAG_USER) {</span>
<span class="quote">&gt;&gt;&gt;              mem_cgroup_oom_disable();</span>
<span class="quote">&gt;&gt;&gt;              /*</span>
<span class="quote">&gt;&gt;&gt; --</span>
<span class="quote">&gt;&gt;&gt; 2.13.6</span>
<span class="quote">&gt;&gt;&gt; </span>
<span class="quote">&gt;&gt; --</span>
<span class="quote">&gt;&gt; Jan Kara &lt;jack@suse.com&gt;</span>
<span class="quote">&gt;&gt; SUSE Labs, CR</span>


Cheers, Andreas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=70561">Yan, Zheng</a> - Dec. 15, 2017, 1:17 a.m.</div>
<pre class="content">
On Fri, Dec 15, 2017 at 12:53 AM, Jan Kara &lt;jack@suse.cz&gt; wrote:
<span class="quote">&gt; On Thu 14-12-17 22:30:26, Yan, Zheng wrote:</span>
<span class="quote">&gt;&gt; On Thu, Dec 14, 2017 at 9:43 PM, Jan Kara &lt;jack@suse.cz&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; On Thu 14-12-17 18:55:27, Yan, Zheng wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt; We recently got an Oops report:</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; BUG: unable to handle kernel NULL pointer dereference at (null)</span>
<span class="quote">&gt;&gt; &gt;&gt; IP: jbd2__journal_start+0x38/0x1a2</span>
<span class="quote">&gt;&gt; &gt;&gt; [...]</span>
<span class="quote">&gt;&gt; &gt;&gt; Call Trace:</span>
<span class="quote">&gt;&gt; &gt;&gt;   ext4_page_mkwrite+0x307/0x52b</span>
<span class="quote">&gt;&gt; &gt;&gt;   _ext4_get_block+0xd8/0xd8</span>
<span class="quote">&gt;&gt; &gt;&gt;   do_page_mkwrite+0x6e/0xd8</span>
<span class="quote">&gt;&gt; &gt;&gt;   handle_mm_fault+0x686/0xf9b</span>
<span class="quote">&gt;&gt; &gt;&gt;   mntput_no_expire+0x1f/0x21e</span>
<span class="quote">&gt;&gt; &gt;&gt;   __do_page_fault+0x21d/0x465</span>
<span class="quote">&gt;&gt; &gt;&gt;   dput+0x4a/0x2f7</span>
<span class="quote">&gt;&gt; &gt;&gt;   page_fault+0x22/0x30</span>
<span class="quote">&gt;&gt; &gt;&gt;   copy_user_generic_string+0x2c/0x40</span>
<span class="quote">&gt;&gt; &gt;&gt;   copy_page_to_iter+0x8c/0x2b8</span>
<span class="quote">&gt;&gt; &gt;&gt;   generic_file_read_iter+0x26e/0x845</span>
<span class="quote">&gt;&gt; &gt;&gt;   timerqueue_del+0x31/0x90</span>
<span class="quote">&gt;&gt; &gt;&gt;   ceph_read_iter+0x697/0xa33 [ceph]</span>
<span class="quote">&gt;&gt; &gt;&gt;   hrtimer_cancel+0x23/0x41</span>
<span class="quote">&gt;&gt; &gt;&gt;   futex_wait+0x1c8/0x24d</span>
<span class="quote">&gt;&gt; &gt;&gt;   get_futex_key+0x32c/0x39a</span>
<span class="quote">&gt;&gt; &gt;&gt;   __vfs_read+0xe0/0x130</span>
<span class="quote">&gt;&gt; &gt;&gt;   vfs_read.part.1+0x6c/0x123</span>
<span class="quote">&gt;&gt; &gt;&gt;   handle_mm_fault+0x831/0xf9b</span>
<span class="quote">&gt;&gt; &gt;&gt;   __fget+0x7e/0xbf</span>
<span class="quote">&gt;&gt; &gt;&gt;   SyS_read+0x4d/0xb5</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; ceph_read_iter() uses current-&gt;journal_info to pass context info to</span>
<span class="quote">&gt;&gt; &gt;&gt; ceph_readpages(). Because ceph_readpages() needs to know if its caller</span>
<span class="quote">&gt;&gt; &gt;&gt; has already gotten capability of using page cache (distinguish read</span>
<span class="quote">&gt;&gt; &gt;&gt; from readahead/fadvise). ceph_read_iter() set current-&gt;journal_info,</span>
<span class="quote">&gt;&gt; &gt;&gt; then calls generic_file_read_iter().</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; In above Oops, page fault happened when copying data to userspace.</span>
<span class="quote">&gt;&gt; &gt;&gt; Page fault handler called ext4_page_mkwrite(). Ext4 code read</span>
<span class="quote">&gt;&gt; &gt;&gt; current-&gt;journal_info and assumed it is journal handle.</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; I checked other filesystems, btrfs probably suffers similar problem</span>
<span class="quote">&gt;&gt; &gt;&gt; for its readpage. (page fault happens when write() copies data from</span>
<span class="quote">&gt;&gt; &gt;&gt; userspace memory and the memory is mapped to a file in btrfs.</span>
<span class="quote">&gt;&gt; &gt;&gt; verify_parent_transid() can be called during readpage)</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Cc: stable@vger.kernel.org</span>
<span class="quote">&gt;&gt; &gt;&gt; Signed-off-by: &quot;Yan, Zheng&quot; &lt;zyan@redhat.com&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; I agree with the analysis but the patch is too ugly too live. Ceph just</span>
<span class="quote">&gt;&gt; &gt; should not be abusing current-&gt;journal_info for passing information between</span>
<span class="quote">&gt;&gt; &gt; two random functions or when it does a hackery like this, it should just</span>
<span class="quote">&gt;&gt; &gt; make sure the pieces hold together. Poluting generic code to accommodate</span>
<span class="quote">&gt;&gt; &gt; this hack in Ceph is not acceptable. Also bear in mind there are likely</span>
<span class="quote">&gt;&gt; &gt; other code paths (e.g. memory reclaim) which could recurse into another</span>
<span class="quote">&gt;&gt; &gt; filesystem confusing it with non-NULL current-&gt;journal_info in the same</span>
<span class="quote">&gt;&gt; &gt; way.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; But ...</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; some filesystem set journal_info in its write_begin(), then clear it</span>
<span class="quote">&gt;&gt; in write_end(). If buffer for write is mapped to another filesystem,</span>
<span class="quote">&gt;&gt; current-&gt;journal can leak to the later filesystem&#39;s page_readpage().</span>
<span class="quote">&gt;&gt; The later filesystem may read current-&gt;journal and treat it as its own</span>
<span class="quote">&gt;&gt; journal handle.  Besides, most filesystem&#39;s vm fault handle is</span>
<span class="quote">&gt;&gt; filemap_fault(), filemap also may tigger memory reclaim.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Did you really observe this? Because write path uses</span>
<span class="quote">&gt; iov_iter_copy_from_user_atomic() which does not allow page faults to</span>
<span class="quote">&gt; happen. All page faulting happens in iov_iter_fault_in_readable() before</span>
<span class="quote">&gt; -&gt;write_begin() is called. And the recursion problems like you mention</span>
<span class="quote">&gt; above are exactly the reason why things are done in a more complicated way</span>
<span class="quote">&gt; like this.</span>

I think you are right.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into</span>
<span class="quote">&gt;&gt; &gt; readpage() / readpages() handler when it already gets that pointer as part</span>
<span class="quote">&gt;&gt; &gt; of arguments...</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It actually a flag which tells ceph_readpages() if its caller is</span>
<span class="quote">&gt;&gt; ceph_read_iter or readahead/fadvise/madvise. because when there are</span>
<span class="quote">&gt;&gt; multiple clients read/write a file a the same time, page cache should</span>
<span class="quote">&gt;&gt; be disabled.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m not sure I understand the reasoning properly but from what you say</span>
<span class="quote">&gt; above it rather seems the &#39;hint&#39; should be stored in the inode (or possibly</span>
<span class="quote">&gt; struct file)?</span>
<span class="quote">&gt;</span>

The capability of using page cache is hold by the process who got it.
ceph_read_iter() first gets the capability, calls
generic_file_read_iter(), then release the capability. The capability
can not be easily stored in inode or file because it can be revoked by
server any time if caller does not hold it

Regards
Yan, Zheng
<span class="quote">

&gt;                                                                 Honza</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Jan Kara &lt;jack@suse.com&gt;</span>
<span class="quote">&gt; SUSE Labs, CR</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - Dec. 15, 2017, 10:33 a.m.</div>
<pre class="content">
On Fri 15-12-17 09:17:42, Yan, Zheng wrote:
<span class="quote">&gt; On Fri, Dec 15, 2017 at 12:53 AM, Jan Kara &lt;jack@suse.cz&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; In this particular case I&#39;m not sure why does ceph pass &#39;filp&#39; into</span>
<span class="quote">&gt; &gt;&gt; &gt; readpage() / readpages() handler when it already gets that pointer as part</span>
<span class="quote">&gt; &gt;&gt; &gt; of arguments...</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; It actually a flag which tells ceph_readpages() if its caller is</span>
<span class="quote">&gt; &gt;&gt; ceph_read_iter or readahead/fadvise/madvise. because when there are</span>
<span class="quote">&gt; &gt;&gt; multiple clients read/write a file a the same time, page cache should</span>
<span class="quote">&gt; &gt;&gt; be disabled.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I&#39;m not sure I understand the reasoning properly but from what you say</span>
<span class="quote">&gt; &gt; above it rather seems the &#39;hint&#39; should be stored in the inode (or possibly</span>
<span class="quote">&gt; &gt; struct file)?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The capability of using page cache is hold by the process who got it.</span>
<span class="quote">&gt; ceph_read_iter() first gets the capability, calls</span>
<span class="quote">&gt; generic_file_read_iter(), then release the capability. The capability</span>
<span class="quote">&gt; can not be easily stored in inode or file because it can be revoked by</span>
<span class="quote">&gt; server any time if caller does not hold it</span>

OK, understood. But using storage in task_struct (such as journal_info) is
problematic as it has hard to fix recursion issues as the bug you&#39;re trying
to fix shows (it is difficult to track down all the paths that can recurse
into another filesystem which will clobber the stored info). So either you
have to come up with some scheme to safely use current-&gt;journal_info (by
somehow tracking owner as Andreas suggests) and convert all users to it or
you have to come up with some scheme propagating the information through
the inode / file-&gt;private_data and use it in Ceph.

								Honza
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index a728bed16c20..db2a50233c49 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -4044,6 +4044,7 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 		unsigned int flags)
 {
 	int ret;
<span class="p_add">+	void *old_journal_info;</span>
 
 	__set_current_state(TASK_RUNNING);
 
<span class="p_chunk">@@ -4065,11 +4066,24 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	if (flags &amp; FAULT_FLAG_USER)
 		mem_cgroup_oom_enable();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fault can happen when filesystem A&#39;s read_iter()/write_iter()</span>
<span class="p_add">+	 * copies data to/from userspace. Filesystem A may have set</span>
<span class="p_add">+	 * current-&gt;journal_info. If the userspace memory is MAP_SHARED</span>
<span class="p_add">+	 * mapped to a file in filesystem B, we later may call filesystem</span>
<span class="p_add">+	 * B&#39;s vm operation. Filesystem B may also want to read/set</span>
<span class="p_add">+	 * current-&gt;journal_info.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	old_journal_info = current-&gt;journal_info;</span>
<span class="p_add">+	current-&gt;journal_info = NULL;</span>
<span class="p_add">+</span>
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);
 	else
 		ret = __handle_mm_fault(vma, address, flags);
 
<span class="p_add">+	current-&gt;journal_info = old_journal_info;</span>
<span class="p_add">+</span>
 	if (flags &amp; FAULT_FLAG_USER) {
 		mem_cgroup_oom_disable();
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



