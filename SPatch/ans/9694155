
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.18.50 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.18.50</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 22, 2017, 5:32 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170422053245.GB27706@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9694155/mbox/"
   >mbox</a>
|
   <a href="/patch/9694155/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9694155/">/patch/9694155/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	97E1C602A7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Apr 2017 05:33:29 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7A05B26E3A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Apr 2017 05:33:29 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6A7B82841F; Sat, 22 Apr 2017 05:33:29 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9CF3226E3A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 22 Apr 2017 05:33:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1041244AbdDVFdR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 22 Apr 2017 01:33:17 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:39364 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1161139AbdDVFdE (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 22 Apr 2017 01:33:04 -0400
Received: from localhost (LFbn-1-12060-104.w90-92.abo.wanadoo.fr
	[90.92.122.104])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0ED448D7;
	Sat, 22 Apr 2017 05:32:56 +0000 (UTC)
Date: Sat, 22 Apr 2017 07:32:45 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.18.50
Message-ID: &lt;20170422053245.GB27706@kroah.com&gt;
References: &lt;20170422053233.GA27706@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170422053233.GA27706@kroah.com&gt;
User-Agent: Mutt/1.8.2 (2017-04-18)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - April 22, 2017, 5:32 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 252070fdf91c..8665178e2a36 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 18
<span class="p_del">-SUBLEVEL = 49</span>
<span class="p_add">+SUBLEVEL = 50</span>
 EXTRAVERSION =
 NAME = Diseased Newt
 
<span class="p_header">diff --git a/arch/arm/include/asm/psci.h b/arch/arm/include/asm/psci.h</span>
<span class="p_header">index e3789fb02c9c..c25ef3ec6d1f 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/psci.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/psci.h</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> struct psci_operations {</span>
 extern struct psci_operations psci_ops;
 extern struct smp_operations psci_smp_ops;
 
<span class="p_del">-#if defined(CONFIG_SMP) &amp;&amp; defined(CONFIG_ARM_PSCI)</span>
<span class="p_add">+#ifdef CONFIG_ARM_PSCI</span>
 int psci_init(void);
 bool psci_smp_available(void);
 #else
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index feda3ff185e9..9fb14a37263b 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -1407,6 +1407,7 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 	    (KVM_PHYS_SIZE &gt;&gt; PAGE_SHIFT))
 		return -EFAULT;
 
<span class="p_add">+	down_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	/*
 	 * A memory region could potentially cover multiple VMAs, and any holes
 	 * between them, so iterate over all of them to find out if we can map
<span class="p_chunk">@@ -1464,6 +1465,8 @@</span> <span class="p_context"> int kvm_arch_prepare_memory_region(struct kvm *kvm,</span>
 	else
 		stage2_flush_memslot(kvm, memslot);
 	spin_unlock(&amp;kvm-&gt;mmu_lock);
<span class="p_add">+</span>
<span class="p_add">+	up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/c6x/kernel/ptrace.c b/arch/c6x/kernel/ptrace.c</span>
<span class="p_header">index 3c494e84444d..a511ac16a8e3 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/ptrace.c</span>
<span class="p_chunk">@@ -69,46 +69,6 @@</span> <span class="p_context"> static int gpr_get(struct task_struct *target,</span>
 				   0, sizeof(*regs));
 }
 
<span class="p_del">-static int gpr_set(struct task_struct *target,</span>
<span class="p_del">-		   const struct user_regset *regset,</span>
<span class="p_del">-		   unsigned int pos, unsigned int count,</span>
<span class="p_del">-		   const void *kbuf, const void __user *ubuf)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-	struct pt_regs *regs = task_pt_regs(target);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t copyin TSR or CSR */</span>
<span class="p_del">-	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,</span>
<span class="p_del">-				 &amp;regs,</span>
<span class="p_del">-				 0, PT_TSR * sizeof(long));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = user_regset_copyin_ignore(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,</span>
<span class="p_del">-					PT_TSR * sizeof(long),</span>
<span class="p_del">-					(PT_TSR + 1) * sizeof(long));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,</span>
<span class="p_del">-				 &amp;regs,</span>
<span class="p_del">-				 (PT_TSR + 1) * sizeof(long),</span>
<span class="p_del">-				 PT_CSR * sizeof(long));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = user_regset_copyin_ignore(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,</span>
<span class="p_del">-					PT_CSR * sizeof(long),</span>
<span class="p_del">-					(PT_CSR + 1) * sizeof(long));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,</span>
<span class="p_del">-				 &amp;regs,</span>
<span class="p_del">-				 (PT_CSR + 1) * sizeof(long), -1);</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 enum c6x_regset {
 	REGSET_GPR,
 };
<span class="p_chunk">@@ -120,7 +80,6 @@</span> <span class="p_context"> static const struct user_regset c6x_regsets[] = {</span>
 		.size = sizeof(u32),
 		.align = sizeof(u32),
 		.get = gpr_get,
<span class="p_del">-		.set = gpr_set</span>
 	},
 };
 
<span class="p_header">diff --git a/arch/metag/include/asm/uaccess.h b/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">index 7841f2290385..9d523375f68a 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -192,20 +192,21 @@</span> <span class="p_context"> extern long __must_check strnlen_user(const char __user *src, long count);</span>
 
 #define strlen_user(str) strnlen_user(str, 32767)
 
<span class="p_del">-extern unsigned long __must_check __copy_user_zeroing(void *to,</span>
<span class="p_del">-						      const void __user *from,</span>
<span class="p_del">-						      unsigned long n);</span>
<span class="p_add">+extern unsigned long raw_copy_from_user(void *to, const void __user *from,</span>
<span class="p_add">+					unsigned long n);</span>
 
 static inline unsigned long
 copy_from_user(void *to, const void __user *from, unsigned long n)
 {
<span class="p_add">+	unsigned long res = n;</span>
 	if (likely(access_ok(VERIFY_READ, from, n)))
<span class="p_del">-		return __copy_user_zeroing(to, from, n);</span>
<span class="p_del">-	memset(to, 0, n);</span>
<span class="p_del">-	return n;</span>
<span class="p_add">+		res = raw_copy_from_user(to, from, n);</span>
<span class="p_add">+	if (unlikely(res))</span>
<span class="p_add">+		memset(to + (n - res), 0, res);</span>
<span class="p_add">+	return res;</span>
 }
 
<span class="p_del">-#define __copy_from_user(to, from, n) __copy_user_zeroing(to, from, n)</span>
<span class="p_add">+#define __copy_from_user(to, from, n) raw_copy_from_user(to, from, n)</span>
 #define __copy_from_user_inatomic __copy_from_user
 
 extern unsigned long __must_check __copy_user(void __user *to,
<span class="p_header">diff --git a/arch/metag/kernel/ptrace.c b/arch/metag/kernel/ptrace.c</span>
<span class="p_header">index 7563628822bd..5e2dc7defd2c 100644</span>
<span class="p_header">--- a/arch/metag/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/metag/kernel/ptrace.c</span>
<span class="p_chunk">@@ -24,6 +24,16 @@</span> <span class="p_context"></span>
  * user_regset definitions.
  */
 
<span class="p_add">+static unsigned long user_txstatus(const struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long data = (unsigned long)regs-&gt;ctx.Flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs-&gt;ctx.SaveMask &amp; TBICTX_CBUF_BIT)</span>
<span class="p_add">+		data |= USER_GP_REGS_STATUS_CATCH_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return data;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int metag_gp_regs_copyout(const struct pt_regs *regs,
 			  unsigned int pos, unsigned int count,
 			  void *kbuf, void __user *ubuf)
<span class="p_chunk">@@ -62,9 +72,7 @@</span> <span class="p_context"> int metag_gp_regs_copyout(const struct pt_regs *regs,</span>
 	if (ret)
 		goto out;
 	/* TXSTATUS */
<span class="p_del">-	data = (unsigned long)regs-&gt;ctx.Flags;</span>
<span class="p_del">-	if (regs-&gt;ctx.SaveMask &amp; TBICTX_CBUF_BIT)</span>
<span class="p_del">-		data |= USER_GP_REGS_STATUS_CATCH_BIT;</span>
<span class="p_add">+	data = user_txstatus(regs);</span>
 	ret = user_regset_copyout(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				  &amp;data, 4*25, 4*26);
 	if (ret)
<span class="p_chunk">@@ -119,6 +127,7 @@</span> <span class="p_context"> int metag_gp_regs_copyin(struct pt_regs *regs,</span>
 	if (ret)
 		goto out;
 	/* TXSTATUS */
<span class="p_add">+	data = user_txstatus(regs);</span>
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 &amp;data, 4*25, 4*26);
 	if (ret)
<span class="p_chunk">@@ -244,6 +253,8 @@</span> <span class="p_context"> int metag_rp_state_copyin(struct pt_regs *regs,</span>
 	unsigned long long *ptr;
 	int ret, i;
 
<span class="p_add">+	if (count &lt; 4*13)</span>
<span class="p_add">+		return -EINVAL;</span>
 	/* Read the entire pipeline before making any changes */
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 				 &amp;rp, 0, 4*13);
<span class="p_chunk">@@ -303,7 +314,7 @@</span> <span class="p_context"> static int metag_tls_set(struct task_struct *target,</span>
 			const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	void __user *tls;</span>
<span class="p_add">+	void __user *tls = target-&gt;thread.tls_ptr;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_header">diff --git a/arch/metag/lib/usercopy.c b/arch/metag/lib/usercopy.c</span>
<span class="p_header">index b3ebfe9c8e88..2792fc621088 100644</span>
<span class="p_header">--- a/arch/metag/lib/usercopy.c</span>
<span class="p_header">+++ b/arch/metag/lib/usercopy.c</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"></span>
 		COPY						 \
 		&quot;1:\n&quot;						 \
 		&quot;	.section .fixup,\&quot;ax\&quot;\n&quot;		 \
<span class="p_del">-		&quot;	MOV D1Ar1,#0\n&quot;				 \</span>
 		FIXUP						 \
 		&quot;	MOVT    D1Ar1,#HI(1b)\n&quot;		 \
 		&quot;	JUMP    D1Ar1,#LO(1b)\n&quot;		 \
<span class="p_chunk">@@ -260,27 +259,31 @@</span> <span class="p_context"></span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;22:\n&quot;							\
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_del">-		&quot;SUB	%3, %3, #32\n&quot;					\</span>
 		&quot;23:\n&quot;							\
<span class="p_del">-		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;SUB	%3, %3, #32\n&quot;					\</span>
 		&quot;24:\n&quot;							\
<span class="p_add">+		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;25:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;26:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #32\n&quot;					\
 		&quot;DCACHE	[%1+#-64], D0Ar6\n&quot;				\
 		&quot;BR	$Lloop&quot;id&quot;\n&quot;					\
 									\
 		&quot;MOV	RAPF, %1\n&quot;					\
<span class="p_del">-		&quot;25:\n&quot;							\</span>
<span class="p_add">+		&quot;27:\n&quot;							\</span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;26:\n&quot;							\</span>
<span class="p_add">+		&quot;28:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;29:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #32\n&quot;					\
<span class="p_del">-		&quot;27:\n&quot;							\</span>
<span class="p_add">+		&quot;30:\n&quot;							\</span>
 		&quot;MGETL	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;28:\n&quot;							\</span>
<span class="p_add">+		&quot;31:\n&quot;							\</span>
 		&quot;MSETL	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;32:\n&quot;							\</span>
 		&quot;SUB	%0, %0, #8\n&quot;					\
<span class="p_del">-		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;33:\n&quot;							\</span>
 		&quot;SETL	[%0++], D0.7, D1.7\n&quot;				\
 		&quot;SUB	%3, %3, #32\n&quot;					\
 		&quot;1:&quot;							\
<span class="p_chunk">@@ -312,11 +315,15 @@</span> <span class="p_context"></span>
 		&quot;	.long 26b,3b\n&quot;					\
 		&quot;	.long 27b,3b\n&quot;					\
 		&quot;	.long 28b,3b\n&quot;					\
<span class="p_del">-		&quot;	.long 29b,4b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 29b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 30b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 31b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 32b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 33b,4b\n&quot;					\</span>
 		&quot;	.previous\n&quot;					\
 		: &quot;=r&quot; (to), &quot;=r&quot; (from), &quot;=r&quot; (ret), &quot;=d&quot; (n)		\
 		: &quot;0&quot; (to), &quot;1&quot; (from), &quot;2&quot; (ret), &quot;3&quot; (n)		\
<span class="p_del">-		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;memory&quot;)</span>
<span class="p_add">+		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;cc&quot;, &quot;memory&quot;)</span>
 
 /*	rewind &#39;to&#39; and &#39;from&#39;  pointers when a fault occurs
  *
<span class="p_chunk">@@ -342,7 +349,7 @@</span> <span class="p_context"></span>
 #define __asm_copy_to_user_64bit_rapf_loop(to,	from, ret, n, id)\
 	__asm_copy_user_64bit_rapf_loop(to, from, ret, n, id,		\
 		&quot;LSR	D0Ar2, D0Ar2, #8\n&quot;				\
<span class="p_del">-		&quot;AND	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
 		&quot;ADDZ	D0Ar2, D0Ar2, #4\n&quot;				\
 		&quot;SUB	D0Ar2, D0Ar2, #1\n&quot;				\
 		&quot;MOV	D1Ar1, #4\n&quot;					\
<span class="p_chunk">@@ -403,47 +410,55 @@</span> <span class="p_context"></span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;22:\n&quot;							\
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_del">-		&quot;SUB	%3, %3, #16\n&quot;					\</span>
 		&quot;23:\n&quot;							\
<span class="p_del">-		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;24:\n&quot;							\</span>
<span class="p_del">-		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;25:\n&quot;							\</span>
<span class="p_add">+		&quot;24:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;26:\n&quot;							\</span>
<span class="p_add">+		&quot;25:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;26:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;27:\n&quot;							\
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
 		&quot;28:\n&quot;							\
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;SUB	%3, %3, #16\n&quot;					\</span>
<span class="p_add">+		&quot;30:\n&quot;							\</span>
<span class="p_add">+		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\</span>
<span class="p_add">+		&quot;31:\n&quot;							\</span>
<span class="p_add">+		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\</span>
<span class="p_add">+		&quot;32:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;DCACHE	[%1+#-64], D0Ar6\n&quot;				\
 		&quot;BR	$Lloop&quot;id&quot;\n&quot;					\
 									\
 		&quot;MOV	RAPF, %1\n&quot;					\
<span class="p_del">-		&quot;29:\n&quot;							\</span>
<span class="p_add">+		&quot;33:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;30:\n&quot;							\</span>
<span class="p_add">+		&quot;34:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;35:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;31:\n&quot;							\</span>
<span class="p_add">+		&quot;36:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;32:\n&quot;							\</span>
<span class="p_add">+		&quot;37:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;38:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;33:\n&quot;							\</span>
<span class="p_add">+		&quot;39:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;34:\n&quot;							\</span>
<span class="p_add">+		&quot;40:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;41:\n&quot;							\</span>
 		&quot;SUB	%3, %3, #16\n&quot;					\
<span class="p_del">-		&quot;35:\n&quot;							\</span>
<span class="p_add">+		&quot;42:\n&quot;							\</span>
 		&quot;MGETD	D0FrT, D0.5, D0.6, D0.7, [%1++]\n&quot;		\
<span class="p_del">-		&quot;36:\n&quot;							\</span>
<span class="p_add">+		&quot;43:\n&quot;							\</span>
 		&quot;MSETD	[%0++], D0FrT, D0.5, D0.6, D0.7\n&quot;		\
<span class="p_add">+		&quot;44:\n&quot;							\</span>
 		&quot;SUB	%0, %0, #4\n&quot;					\
<span class="p_del">-		&quot;37:\n&quot;							\</span>
<span class="p_add">+		&quot;45:\n&quot;							\</span>
 		&quot;SETD	[%0++], D0.7\n&quot;					\
 		&quot;SUB	%3, %3, #16\n&quot;					\
 		&quot;1:&quot;							\
<span class="p_chunk">@@ -483,11 +498,19 @@</span> <span class="p_context"></span>
 		&quot;	.long 34b,3b\n&quot;					\
 		&quot;	.long 35b,3b\n&quot;					\
 		&quot;	.long 36b,3b\n&quot;					\
<span class="p_del">-		&quot;	.long 37b,4b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 37b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 38b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 39b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 40b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 41b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 42b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 43b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 44b,3b\n&quot;					\</span>
<span class="p_add">+		&quot;	.long 45b,4b\n&quot;					\</span>
 		&quot;	.previous\n&quot;					\
 		: &quot;=r&quot; (to), &quot;=r&quot; (from), &quot;=r&quot; (ret), &quot;=d&quot; (n)		\
 		: &quot;0&quot; (to), &quot;1&quot; (from), &quot;2&quot; (ret), &quot;3&quot; (n)		\
<span class="p_del">-		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;memory&quot;)</span>
<span class="p_add">+		: &quot;D1Ar1&quot;, &quot;D0Ar2&quot;, &quot;cc&quot;, &quot;memory&quot;)</span>
 
 /*	rewind &#39;to&#39; and &#39;from&#39;  pointers when a fault occurs
  *
<span class="p_chunk">@@ -513,7 +536,7 @@</span> <span class="p_context"></span>
 #define __asm_copy_to_user_32bit_rapf_loop(to, from, ret, n, id)\
 	__asm_copy_user_32bit_rapf_loop(to, from, ret, n, id,		\
 		&quot;LSR	D0Ar2, D0Ar2, #8\n&quot;				\
<span class="p_del">-		&quot;AND	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x7\n&quot;				\</span>
 		&quot;ADDZ	D0Ar2, D0Ar2, #4\n&quot;				\
 		&quot;SUB	D0Ar2, D0Ar2, #1\n&quot;				\
 		&quot;MOV	D1Ar1, #4\n&quot;					\
<span class="p_chunk">@@ -538,23 +561,31 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 	if ((unsigned long) src &amp; 1) {
 		__asm_copy_to_user_1(dst, src, retn);
 		n--;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 1) {
 		/* Worst case - byte copy */
 		while (n &gt; 0) {
 			__asm_copy_to_user_1(dst, src, retn);
 			n--;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (((unsigned long) src &amp; 2) &amp;&amp; n &gt;= 2) {
 		__asm_copy_to_user_2(dst, src, retn);
 		n -= 2;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 2) {
 		/* Second worst case - word copy */
 		while (n &gt;= 2) {
 			__asm_copy_to_user_2(dst, src, retn);
 			n -= 2;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_chunk">@@ -569,6 +600,8 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		while (n &gt;= 8) {
 			__asm_copy_to_user_8x64(dst, src, retn);
 			n -= 8;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (n &gt;= RAPF_MIN_BUF_SIZE) {
<span class="p_chunk">@@ -581,6 +614,8 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		while (n &gt;= 8) {
 			__asm_copy_to_user_8x64(dst, src, retn);
 			n -= 8;
<span class="p_add">+			if (retn)</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -588,11 +623,15 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 	while (n &gt;= 16) {
 		__asm_copy_to_user_16(dst, src, retn);
 		n -= 16;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	while (n &gt;= 4) {
 		__asm_copy_to_user_4(dst, src, retn);
 		n -= 4;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	switch (n) {
<span class="p_chunk">@@ -609,6 +648,10 @@</span> <span class="p_context"> unsigned long __copy_user(void __user *pdst, const void *psrc,</span>
 		break;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we get here, retn correctly reflects the number of failing</span>
<span class="p_add">+	 * bytes.</span>
<span class="p_add">+	 */</span>
 	return retn;
 }
 EXPORT_SYMBOL(__copy_user);
<span class="p_chunk">@@ -617,16 +660,14 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
 	__asm_copy_user_cont(to, from, ret,	\
 		&quot;	GETB D1Ar1,[%1++]\n&quot;	\
 		&quot;2:	SETB [%0++],D1Ar1\n&quot;,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#1\n&quot;	\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#1\n&quot;,	\</span>
 		&quot;	.long 2b,3b\n&quot;)
 
 #define __asm_copy_from_user_2x_cont(to, from, ret, COPY, FIXUP, TENTRY) \
 	__asm_copy_user_cont(to, from, ret,		\
 		&quot;	GETW D1Ar1,[%1++]\n&quot;		\
 		&quot;2:	SETW [%0++],D1Ar1\n&quot; COPY,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#2\n&quot; FIXUP,		\</span>
 		&quot;	.long 2b,3b\n&quot; TENTRY)
 
 #define __asm_copy_from_user_2(to, from, ret) \
<span class="p_chunk">@@ -636,145 +677,26 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
 	__asm_copy_from_user_2x_cont(to, from, ret,	\
 		&quot;	GETB D1Ar1,[%1++]\n&quot;		\
 		&quot;4:	SETB [%0++],D1Ar1\n&quot;,		\
<span class="p_del">-		&quot;5:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_add">+		&quot;5:	ADD  %2,%2,#1\n&quot;,		\</span>
 		&quot;	.long 4b,5b\n&quot;)
 
 #define __asm_copy_from_user_4x_cont(to, from, ret, COPY, FIXUP, TENTRY) \
 	__asm_copy_user_cont(to, from, ret,		\
 		&quot;	GETD D1Ar1,[%1++]\n&quot;		\
 		&quot;2:	SETD [%0++],D1Ar1\n&quot; COPY,	\
<span class="p_del">-		&quot;3:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_add">+		&quot;3:	ADD  %2,%2,#4\n&quot; FIXUP,		\</span>
 		&quot;	.long 2b,3b\n&quot; TENTRY)
 
 #define __asm_copy_from_user_4(to, from, ret) \
 	__asm_copy_from_user_4x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)
 
<span class="p_del">-#define __asm_copy_from_user_5(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_6x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_6(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_6x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_7(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_6x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_8x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_4x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;4:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;5:	ADD  %2,%2,#4\n&quot;			\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,		\</span>
<span class="p_del">-		&quot;	.long 4b,5b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_8(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_9(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_10x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_10(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_10x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_11(to, from, ret)		\</span>
<span class="p_del">-	__asm_copy_from_user_10x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_12x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_8x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;6:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;7:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 6b,7b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_12(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_13(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_14x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETW D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETW [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#2\n&quot;		\</span>
<span class="p_del">-		&quot;	SETW [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_14(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_14x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_15(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_14x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETB D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;10:	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;11:	ADD  %2,%2,#1\n&quot;		\</span>
<span class="p_del">-		&quot;	SETB [%0++],D1Ar1\n&quot;,		\</span>
<span class="p_del">-		&quot;	.long 10b,11b\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_16x_cont(to, from, ret, COPY, FIXUP, TENTRY) \</span>
<span class="p_del">-	__asm_copy_from_user_12x_cont(to, from, ret,	\</span>
<span class="p_del">-		&quot;	GETD D1Ar1,[%1++]\n&quot;		\</span>
<span class="p_del">-		&quot;8:	SETD [%0++],D1Ar1\n&quot; COPY,	\</span>
<span class="p_del">-		&quot;9:	ADD  %2,%2,#4\n&quot;		\</span>
<span class="p_del">-		&quot;	SETD [%0++],D1Ar1\n&quot; FIXUP,	\</span>
<span class="p_del">-		&quot;	.long 8b,9b\n&quot; TENTRY)</span>
<span class="p_del">-</span>
<span class="p_del">-#define __asm_copy_from_user_16(to, from, ret) \</span>
<span class="p_del">-	__asm_copy_from_user_16x_cont(to, from, ret, &quot;&quot;, &quot;&quot;, &quot;&quot;)</span>
<span class="p_del">-</span>
 #define __asm_copy_from_user_8x64(to, from, ret) \
 	asm volatile (				\
 		&quot;	GETL D0Ar2,D1Ar1,[%1++]\n&quot;	\
 		&quot;2:	SETL [%0++],D0Ar2,D1Ar1\n&quot;	\
 		&quot;1:\n&quot;					\
 		&quot;	.section .fixup,\&quot;ax\&quot;\n&quot;	\
<span class="p_del">-		&quot;	MOV D1Ar1,#0\n&quot;			\</span>
<span class="p_del">-		&quot;	MOV D0Ar2,#0\n&quot;			\</span>
 		&quot;3:	ADD  %2,%2,#8\n&quot;		\
<span class="p_del">-		&quot;	SETL [%0++],D0Ar2,D1Ar1\n&quot;	\</span>
 		&quot;	MOVT    D0Ar2,#HI(1b)\n&quot;	\
 		&quot;	JUMP    D0Ar2,#LO(1b)\n&quot;	\
 		&quot;	.previous\n&quot;			\
<span class="p_chunk">@@ -789,36 +711,57 @@</span> <span class="p_context"> EXPORT_SYMBOL(__copy_user);</span>
  *
  *	Rationale:
  *		A fault occurs while reading from user buffer, which is the
<span class="p_del">- *		source. Since the fault is at a single address, we only</span>
<span class="p_del">- *		need to rewind by 8 bytes.</span>
<span class="p_add">+ *		source.</span>
  *		Since we don&#39;t write to kernel buffer until we read first,
  *		the kernel buffer is at the right state and needn&#39;t be
<span class="p_del">- *		corrected.</span>
<span class="p_add">+ *		corrected, but the source must be rewound to the beginning of</span>
<span class="p_add">+ *		the block, which is LSM_STEP*8 bytes.</span>
<span class="p_add">+ *		LSM_STEP is bits 10:8 in TXSTATUS which is already read</span>
<span class="p_add">+ *		and stored in D0Ar2</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *		NOTE: If a fault occurs at the last operation in M{G,S}ETL</span>
<span class="p_add">+ *			LSM_STEP will be 0. ie: we do 4 writes in our case, if</span>
<span class="p_add">+ *			a fault happens at the 4th write, LSM_STEP will be 0</span>
<span class="p_add">+ *			instead of 4. The code copes with that.</span>
  */
 #define __asm_copy_from_user_64bit_rapf_loop(to, from, ret, n, id)	\
 	__asm_copy_user_64bit_rapf_loop(to, from, ret, n, id,		\
<span class="p_del">-		&quot;SUB	%1, %1, #8\n&quot;)</span>
<span class="p_add">+		&quot;LSR	D0Ar2, D0Ar2, #5\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x38\n&quot;				\</span>
<span class="p_add">+		&quot;ADDZ	D0Ar2, D0Ar2, #32\n&quot;				\</span>
<span class="p_add">+		&quot;SUB	%1, %1, D0Ar2\n&quot;)</span>
 
 /*	rewind &#39;from&#39; pointer when a fault occurs
  *
  *	Rationale:
  *		A fault occurs while reading from user buffer, which is the
<span class="p_del">- *		source. Since the fault is at a single address, we only</span>
<span class="p_del">- *		need to rewind by 4 bytes.</span>
<span class="p_add">+ *		source.</span>
  *		Since we don&#39;t write to kernel buffer until we read first,
  *		the kernel buffer is at the right state and needn&#39;t be
<span class="p_del">- *		corrected.</span>
<span class="p_add">+ *		corrected, but the source must be rewound to the beginning of</span>
<span class="p_add">+ *		the block, which is LSM_STEP*4 bytes.</span>
<span class="p_add">+ *		LSM_STEP is bits 10:8 in TXSTATUS which is already read</span>
<span class="p_add">+ *		and stored in D0Ar2</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *		NOTE: If a fault occurs at the last operation in M{G,S}ETL</span>
<span class="p_add">+ *			LSM_STEP will be 0. ie: we do 4 writes in our case, if</span>
<span class="p_add">+ *			a fault happens at the 4th write, LSM_STEP will be 0</span>
<span class="p_add">+ *			instead of 4. The code copes with that.</span>
  */
 #define __asm_copy_from_user_32bit_rapf_loop(to, from, ret, n, id)	\
 	__asm_copy_user_32bit_rapf_loop(to, from, ret, n, id,		\
<span class="p_del">-		&quot;SUB	%1, %1, #4\n&quot;)</span>
<span class="p_add">+		&quot;LSR	D0Ar2, D0Ar2, #6\n&quot;				\</span>
<span class="p_add">+		&quot;ANDS	D0Ar2, D0Ar2, #0x1c\n&quot;				\</span>
<span class="p_add">+		&quot;ADDZ	D0Ar2, D0Ar2, #16\n&quot;				\</span>
<span class="p_add">+		&quot;SUB	%1, %1, D0Ar2\n&quot;)</span>
 
 
<span class="p_del">-/* Copy from user to kernel, zeroing the bytes that were inaccessible in</span>
<span class="p_del">-   userland.  The return-value is the number of bytes that were</span>
<span class="p_del">-   inaccessible.  */</span>
<span class="p_del">-unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
<span class="p_del">-				  unsigned long n)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copy from user to kernel. The return-value is the number of bytes that were</span>
<span class="p_add">+ * inaccessible.</span>
<span class="p_add">+ */</span>
<span class="p_add">+unsigned long raw_copy_from_user(void *pdst, const void __user *psrc,</span>
<span class="p_add">+				 unsigned long n)</span>
 {
 	register char *dst asm (&quot;A0.2&quot;) = pdst;
 	register const char __user *src asm (&quot;A1.2&quot;) = psrc;
<span class="p_chunk">@@ -830,6 +773,8 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 	if ((unsigned long) src &amp; 1) {
 		__asm_copy_from_user_1(dst, src, retn);
 		n--;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 1) {
 		/* Worst case - byte copy */
<span class="p_chunk">@@ -837,12 +782,14 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_1(dst, src, retn);
 			n--;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 	if (((unsigned long) src &amp; 2) &amp;&amp; n &gt;= 2) {
 		__asm_copy_from_user_2(dst, src, retn);
 		n -= 2;
<span class="p_add">+		if (retn)</span>
<span class="p_add">+			return retn + n;</span>
 	}
 	if ((unsigned long) dst &amp; 2) {
 		/* Second worst case - word copy */
<span class="p_chunk">@@ -850,16 +797,10 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_2(dst, src, retn);
 			n -= 2;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_del">-	/* We only need one check after the unalignment-adjustments,</span>
<span class="p_del">-	   because if both adjustments were done, either both or</span>
<span class="p_del">-	   neither reference had an exception.  */</span>
<span class="p_del">-	if (retn != 0)</span>
<span class="p_del">-		goto copy_exception_bytes;</span>
<span class="p_del">-</span>
 #ifdef USE_RAPF
 	/* 64 bit copy loop */
 	if (!(((unsigned long) src | (unsigned long) dst) &amp; 7)) {
<span class="p_chunk">@@ -872,7 +813,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_8x64(dst, src, retn);
 			n -= 8;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 
<span class="p_chunk">@@ -888,7 +829,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 			__asm_copy_from_user_8x64(dst, src, retn);
 			n -= 8;
 			if (retn)
<span class="p_del">-				goto copy_exception_bytes;</span>
<span class="p_add">+				return retn + n;</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -898,7 +839,7 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 		n -= 4;
 
 		if (retn)
<span class="p_del">-			goto copy_exception_bytes;</span>
<span class="p_add">+			return retn + n;</span>
 	}
 
 	/* If we get here, there were no memory read faults.  */
<span class="p_chunk">@@ -924,21 +865,8 @@</span> <span class="p_context"> unsigned long __copy_user_zeroing(void *pdst, const void __user *psrc,</span>
 	/* If we get here, retn correctly reflects the number of failing
 	   bytes.  */
 	return retn;
<span class="p_del">-</span>
<span class="p_del">- copy_exception_bytes:</span>
<span class="p_del">-	/* We already have &quot;retn&quot; bytes cleared, and need to clear the</span>
<span class="p_del">-	   remaining &quot;n&quot; bytes.  A non-optimized simple byte-for-byte in-line</span>
<span class="p_del">-	   memset is preferred here, since this isn&#39;t speed-critical code and</span>
<span class="p_del">-	   we&#39;d rather have this a leaf-function than calling memset.  */</span>
<span class="p_del">-	{</span>
<span class="p_del">-		char *endp;</span>
<span class="p_del">-		for (endp = dst + n; dst &lt; endp; dst++)</span>
<span class="p_del">-			*dst = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return retn + n;</span>
 }
<span class="p_del">-EXPORT_SYMBOL(__copy_user_zeroing);</span>
<span class="p_add">+EXPORT_SYMBOL(raw_copy_from_user);</span>
 
 #define __asm_clear_8x64(to, ret) \
 	asm volatile (					\
<span class="p_header">diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c</span>
<span class="p_header">index 9d1487d83293..7aaf0dca09da 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace.c</span>
<span class="p_chunk">@@ -444,7 +444,8 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target,</span>
 					  &amp;target-&gt;thread.fpu,
 					  0, sizeof(elf_fpregset_t));
 
<span class="p_del">-	for (i = 0; i &lt; NUM_FPU_REGS; i++) {</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(fpr_val) != sizeof(elf_fpreg_t));</span>
<span class="p_add">+	for (i = 0; i &lt; NUM_FPU_REGS &amp;&amp; count &gt;= sizeof(elf_fpreg_t); i++) {</span>
 		err = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 					 &amp;fpr_val, i * sizeof(elf_fpreg_t),
 					 (i + 1) * sizeof(elf_fpreg_t));
<span class="p_header">diff --git a/arch/powerpc/boot/zImage.lds.S b/arch/powerpc/boot/zImage.lds.S</span>
<span class="p_header">index 861e72109df2..f080abfc2f83 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/zImage.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/boot/zImage.lds.S</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> SECTIONS</span>
   }
 
 #ifdef CONFIG_PPC64_BOOT_WRAPPER
<span class="p_add">+  . = ALIGN(256);</span>
   .got :
   {
     __toc_start = .;
<span class="p_header">diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c</span>
<span class="p_header">index 34f55524d456..ce068cb2071f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/align.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/align.c</span>
<span class="p_chunk">@@ -808,14 +808,25 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 	nb = aligninfo[instr].len;
 	flags = aligninfo[instr].flags;
 
<span class="p_del">-	/* ldbrx/stdbrx overlap lfs/stfs in the DSISR unfortunately */</span>
<span class="p_del">-	if (IS_XFORM(instruction) &amp;&amp; ((instruction &gt;&gt; 1) &amp; 0x3ff) == 532) {</span>
<span class="p_del">-		nb = 8;</span>
<span class="p_del">-		flags = LD+SW;</span>
<span class="p_del">-	} else if (IS_XFORM(instruction) &amp;&amp;</span>
<span class="p_del">-		   ((instruction &gt;&gt; 1) &amp; 0x3ff) == 660) {</span>
<span class="p_del">-		nb = 8;</span>
<span class="p_del">-		flags = ST+SW;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Handle some cases which give overlaps in the DSISR values.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_XFORM(instruction)) {</span>
<span class="p_add">+		switch (get_xop(instruction)) {</span>
<span class="p_add">+		case 532:	/* ldbrx */</span>
<span class="p_add">+			nb = 8;</span>
<span class="p_add">+			flags = LD+SW;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 660:	/* stdbrx */</span>
<span class="p_add">+			nb = 8;</span>
<span class="p_add">+			flags = ST+SW;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 20:	/* lwarx */</span>
<span class="p_add">+		case 84:	/* ldarx */</span>
<span class="p_add">+		case 116:	/* lharx */</span>
<span class="p_add">+		case 276:	/* lqarx */</span>
<span class="p_add">+			return 0;	/* not emulated ever */</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Byteswap little endian loads and stores */
<span class="p_header">diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">index 4f3cfe1b6a33..3dac0e66f915 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup_64.c</span>
<span class="p_chunk">@@ -211,6 +211,15 @@</span> <span class="p_context"> static void cpu_ready_for_interrupts(void)</span>
 		unsigned long lpcr = mfspr(SPRN_LPCR);
 		mtspr(SPRN_LPCR, lpcr | LPCR_AIL_3);
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fixup HFSCR:TM based on CPU features. The bit is set by our</span>
<span class="p_add">+	 * early asm init because at that point we haven&#39;t updated our</span>
<span class="p_add">+	 * CPU features from firmware and device-tree. Here we have,</span>
<span class="p_add">+	 * so let&#39;s do it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_HVMODE) &amp;&amp; !cpu_has_feature(CPU_FTR_TM_COMP))</span>
<span class="p_add">+		mtspr(SPRN_HFSCR, mfspr(SPRN_HFSCR) &amp; ~HFSCR_TM);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/powerpc/kvm/emulate.c b/arch/powerpc/kvm/emulate.c</span>
<span class="p_header">index 5cc2e7af3a7b..b379146de55b 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/emulate.c</span>
<span class="p_chunk">@@ -302,7 +302,6 @@</span> <span class="p_context"> int kvmppc_emulate_instruction(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			advance = 0;
 			printk(KERN_ERR &quot;Couldn&#39;t emulate instruction 0x%08x &quot;
 			       &quot;(op %d xop %d)\n&quot;, inst, get_op(inst), get_xop(inst));
<span class="p_del">-			kvmppc_core_queue_program(vcpu, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/hash_native_64.c b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">index ae4962a06476..42213a374996 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_native_64.c</span>
<span class="p_chunk">@@ -633,6 +633,10 @@</span> <span class="p_context"> static void native_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long psize = batch-&gt;psize;
 	int ssize = batch-&gt;ssize;
 	int i;
<span class="p_add">+	unsigned int use_local;</span>
<span class="p_add">+</span>
<span class="p_add">+	use_local = local &amp;&amp; mmu_has_feature(MMU_FTR_TLBIEL) &amp;&amp;</span>
<span class="p_add">+		mmu_psize_defs[psize].tlbiel &amp;&amp; !cxl_ctx_in_use();</span>
 
 	local_irq_save(flags);
 
<span class="p_chunk">@@ -659,8 +663,7 @@</span> <span class="p_context"> static void native_flush_hash_range(unsigned long number, int local)</span>
 		} pte_iterate_hashed_end();
 	}
 
<span class="p_del">-	if (mmu_has_feature(MMU_FTR_TLBIEL) &amp;&amp;</span>
<span class="p_del">-	    mmu_psize_defs[psize].tlbiel &amp;&amp; local) {</span>
<span class="p_add">+	if (use_local) {</span>
 		asm volatile(&quot;ptesync&quot;:::&quot;memory&quot;);
 		for (i = 0; i &lt; number; i++) {
 			vpn = batch-&gt;vpn[i];
<span class="p_header">diff --git a/arch/s390/boot/compressed/misc.c b/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">index 57cbaff1f397..d73c8878b0c1 100644</span>
<span class="p_header">--- a/arch/s390/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/s390/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -142,31 +142,34 @@</span> <span class="p_context"> static void check_ipl_parmblock(void *start, unsigned long size)</span>
 
 unsigned long decompress_kernel(void)
 {
<span class="p_del">-	unsigned long output_addr;</span>
<span class="p_del">-	unsigned char *output;</span>
<span class="p_add">+	void *output, *kernel_end;</span>
 
<span class="p_del">-	output_addr = ((unsigned long) &amp;_end + HEAP_SIZE + 4095UL) &amp; -4096UL;</span>
<span class="p_del">-	check_ipl_parmblock((void *) 0, output_addr + SZ__bss_start);</span>
<span class="p_del">-	memset(&amp;_bss, 0, &amp;_ebss - &amp;_bss);</span>
<span class="p_del">-	free_mem_ptr = (unsigned long)&amp;_end;</span>
<span class="p_del">-	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;</span>
<span class="p_del">-	output = (unsigned char *) output_addr;</span>
<span class="p_add">+	output = (void *) ALIGN((unsigned long) &amp;_end + HEAP_SIZE, PAGE_SIZE);</span>
<span class="p_add">+	kernel_end = output + SZ__bss_start;</span>
<span class="p_add">+	check_ipl_parmblock((void *) 0, (unsigned long) kernel_end);</span>
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/*
 	 * Move the initrd right behind the end of the decompressed
<span class="p_del">-	 * kernel image.</span>
<span class="p_add">+	 * kernel image. This also prevents initrd corruption caused by</span>
<span class="p_add">+	 * bss clearing since kernel_end will always be located behind the</span>
<span class="p_add">+	 * current bss section..</span>
 	 */
<span class="p_del">-	if (INITRD_START &amp;&amp; INITRD_SIZE &amp;&amp;</span>
<span class="p_del">-	    INITRD_START &lt; (unsigned long) output + SZ__bss_start) {</span>
<span class="p_del">-		check_ipl_parmblock(output + SZ__bss_start,</span>
<span class="p_del">-				    INITRD_START + INITRD_SIZE);</span>
<span class="p_del">-		memmove(output + SZ__bss_start,</span>
<span class="p_del">-			(void *) INITRD_START, INITRD_SIZE);</span>
<span class="p_del">-		INITRD_START = (unsigned long) output + SZ__bss_start;</span>
<span class="p_add">+	if (INITRD_START &amp;&amp; INITRD_SIZE &amp;&amp; kernel_end &gt; (void *) INITRD_START) {</span>
<span class="p_add">+		check_ipl_parmblock(kernel_end, INITRD_SIZE);</span>
<span class="p_add">+		memmove(kernel_end, (void *) INITRD_START, INITRD_SIZE);</span>
<span class="p_add">+		INITRD_START = (unsigned long) kernel_end;</span>
 	}
 #endif
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear bss section. free_mem_ptr and free_mem_end_ptr need to be</span>
<span class="p_add">+	 * initialized afterwards since they reside in bss.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(&amp;_bss, 0, &amp;_ebss - &amp;_bss);</span>
<span class="p_add">+	free_mem_ptr = (unsigned long) &amp;_end;</span>
<span class="p_add">+	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;</span>
<span class="p_add">+</span>
 	puts(&quot;Uncompressing Linux... &quot;);
 	decompress(input_data, input_len, NULL, NULL, output, NULL, error);
 	puts(&quot;Ok, booting the kernel.\n&quot;);
<span class="p_header">diff --git a/arch/s390/include/asm/uaccess.h b/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">index 528f08c1d584..6e5fc2d8c400 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> unsigned long __must_check __copy_to_user(void __user *to, const void *from,</span>
 		&quot;	jg	2b\n&quot;				\
 		&quot;.popsection\n&quot;					\
 		EX_TABLE(0b,3b) EX_TABLE(1b,3b)			\
<span class="p_del">-		: &quot;=d&quot; (__rc), &quot;=Q&quot; (*(to))			\</span>
<span class="p_add">+		: &quot;=d&quot; (__rc), &quot;+Q&quot; (*(to))			\</span>
 		: &quot;d&quot; (size), &quot;Q&quot; (*(from)),			\
 		  &quot;d&quot; (__reg0), &quot;K&quot; (-EFAULT)			\
 		: &quot;cc&quot;);					\
<span class="p_header">diff --git a/arch/sparc/kernel/ptrace_64.c b/arch/sparc/kernel/ptrace_64.c</span>
<span class="p_header">index 9ddc4928a089..c1566170964f 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ptrace_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ptrace_64.c</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> static int genregs64_set(struct task_struct *target,</span>
 	}
 
 	if (!ret) {
<span class="p_del">-		unsigned long y;</span>
<span class="p_add">+		unsigned long y = regs-&gt;y;</span>
 
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf,
 					 &amp;y,
<span class="p_header">diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h</span>
<span class="p_header">index ca3347a9dab5..2e5a79ad9061 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -277,7 +277,7 @@</span> <span class="p_context"> struct task_struct;</span>
 
 #define	ARCH_DLINFO_IA32						\
 do {									\
<span class="p_del">-	if (vdso32_enabled) {						\</span>
<span class="p_add">+	if (VDSO_CURRENT_BASE) {					\</span>
 		NEW_AUX_ENT(AT_SYSINFO,	VDSO_ENTRY);			\
 		NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE);	\
 	}								\
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_lbr.c b/arch/x86/kernel/cpu/perf_event_intel_lbr.c</span>
<span class="p_header">index 45fa730a5283..eafcdb15ceee 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_lbr.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_lbr.c</span>
<span class="p_chunk">@@ -268,6 +268,8 @@</span> <span class="p_context"> static void intel_pmu_lbr_read_32(struct cpu_hw_events *cpuc)</span>
 		cpuc-&gt;lbr_entries[i].to		= msr_lastbranch.to;
 		cpuc-&gt;lbr_entries[i].mispred	= 0;
 		cpuc-&gt;lbr_entries[i].predicted	= 0;
<span class="p_add">+		cpuc-&gt;lbr_entries[i].in_tx	= 0;</span>
<span class="p_add">+		cpuc-&gt;lbr_entries[i].abort	= 0;</span>
 		cpuc-&gt;lbr_entries[i].reserved	= 0;
 	}
 	cpuc-&gt;lbr_stack.nr = i;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 888eaab57fbc..cf53e4acddb6 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -6079,14 +6079,20 @@</span> <span class="p_context"> static int nested_vmx_check_vmptr(struct kvm_vcpu *vcpu, int exit_reason,</span>
 		}
 
 		page = nested_get_page(vcpu, vmptr);
<span class="p_del">-		if (page == NULL ||</span>
<span class="p_del">-		    *(u32 *)kmap(page) != VMCS12_REVISION) {</span>
<span class="p_add">+		if (page == NULL) {</span>
 			nested_vmx_failInvalid(vcpu);
<span class="p_add">+			skip_emulated_instruction(vcpu);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (*(u32 *)kmap(page) != VMCS12_REVISION) {</span>
 			kunmap(page);
<span class="p_add">+			nested_release_page_clean(page);</span>
<span class="p_add">+			nested_vmx_failInvalid(vcpu);</span>
 			skip_emulated_instruction(vcpu);
 			return 1;
 		}
 		kunmap(page);
<span class="p_add">+		nested_release_page_clean(page);</span>
 		vmx-&gt;nested.vmxon_ptr = vmptr;
 		break;
 	case EXIT_REASON_VMCLEAR:
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 0a59a63bcdad..bd03a95b9f89 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -581,20 +581,40 @@</span> <span class="p_context"> void __init init_mem_mapping(void)</span>
  * is valid. The argument is a physical page number.
  *
  *
<span class="p_del">- * On x86, access has to be given to the first megabyte of ram because that area</span>
<span class="p_del">- * contains bios code and data regions used by X and dosemu and similar apps.</span>
<span class="p_del">- * Access has to be given to non-kernel-ram areas as well, these contain the PCI</span>
<span class="p_del">- * mmio resources as well as potential bios/acpi data regions.</span>
<span class="p_add">+ * On x86, access has to be given to the first megabyte of RAM because that</span>
<span class="p_add">+ * area traditionally contains BIOS code and data regions used by X, dosemu,</span>
<span class="p_add">+ * and similar apps. Since they map the entire memory range, the whole range</span>
<span class="p_add">+ * must be allowed (for mapping), but any areas that would otherwise be</span>
<span class="p_add">+ * disallowed are flagged as being &quot;zero filled&quot; instead of rejected.</span>
<span class="p_add">+ * Access has to be given to non-kernel-ram areas as well, these contain the</span>
<span class="p_add">+ * PCI mmio resources as well as potential bios/acpi data regions.</span>
  */
 int devmem_is_allowed(unsigned long pagenr)
 {
<span class="p_del">-	if (pagenr &lt; 256)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	if (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT))</span>
<span class="p_add">+	if (page_is_ram(pagenr)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * For disallowed memory regions in the low 1MB range,</span>
<span class="p_add">+		 * request that the page be shown as all zeros.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (pagenr &lt; 256)</span>
<span class="p_add">+			return 2;</span>
<span class="p_add">+</span>
 		return 0;
<span class="p_del">-	if (!page_is_ram(pagenr))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This must follow RAM test, since System RAM is considered a</span>
<span class="p_add">+	 * restricted resource under CONFIG_STRICT_IOMEM.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iomem_is_exclusive(pagenr &lt;&lt; PAGE_SHIFT)) {</span>
<span class="p_add">+		/* Low 1MB bypasses iomem restrictions. */</span>
<span class="p_add">+		if (pagenr &lt; 256)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
 }
 
 void free_init_pages(char *what, unsigned long begin, unsigned long end)
<span class="p_header">diff --git a/arch/x86/vdso/vdso32-setup.c b/arch/x86/vdso/vdso32-setup.c</span>
<span class="p_header">index e904c270573b..566a51ee18da 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso32-setup.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso32-setup.c</span>
<span class="p_chunk">@@ -31,8 +31,10 @@</span> <span class="p_context"> static int __init vdso32_setup(char *s)</span>
 {
 	vdso32_enabled = simple_strtoul(s, NULL, 0);
 
<span class="p_del">-	if (vdso32_enabled &gt; 1)</span>
<span class="p_add">+	if (vdso32_enabled &gt; 1) {</span>
 		pr_warn(&quot;vdso32 values other than 0 and 1 are no longer allowed; vdso disabled\n&quot;);
<span class="p_add">+		vdso32_enabled = 0;</span>
<span class="p_add">+	}</span>
 
 	return 1;
 }
<span class="p_chunk">@@ -89,13 +91,18 @@</span> <span class="p_context"> subsys_initcall(sysenter_setup);</span>
 /* Register vsyscall32 into the ABI table */
 #include &lt;linux/sysctl.h&gt;
 
<span class="p_add">+static const int zero;</span>
<span class="p_add">+static const int one = 1;</span>
<span class="p_add">+</span>
 static struct ctl_table abi_table2[] = {
 	{
 		.procname	= &quot;vsyscall32&quot;,
 		.data		= &amp;vdso32_enabled,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= (int *)&amp;zero,</span>
<span class="p_add">+		.extra2		= (int *)&amp;one,</span>
 	},
 	{}
 };
<span class="p_header">diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c</span>
<span class="p_header">index b0c2a616c8f9..4a2735dce513 100644</span>
<span class="p_header">--- a/block/scsi_ioctl.c</span>
<span class="p_header">+++ b/block/scsi_ioctl.c</span>
<span class="p_chunk">@@ -182,6 +182,9 @@</span> <span class="p_context"> static void blk_set_cmd_filter_defaults(struct blk_cmd_filter *filter)</span>
 	__set_bit(WRITE_16, filter-&gt;write_ok);
 	__set_bit(WRITE_LONG, filter-&gt;write_ok);
 	__set_bit(WRITE_LONG_2, filter-&gt;write_ok);
<span class="p_add">+	__set_bit(WRITE_SAME, filter-&gt;write_ok);</span>
<span class="p_add">+	__set_bit(WRITE_SAME_16, filter-&gt;write_ok);</span>
<span class="p_add">+	__set_bit(WRITE_SAME_32, filter-&gt;write_ok);</span>
 	__set_bit(ERASE, filter-&gt;write_ok);
 	__set_bit(GPCMD_MODE_SELECT_10, filter-&gt;write_ok);
 	__set_bit(MODE_SELECT, filter-&gt;write_ok);
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 46ab9099c330..a11220e78152 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct ahash_request_priv {</span>
 	crypto_completion_t complete;
 	void *data;
 	u8 *result;
<span class="p_add">+	u32 flags;</span>
 	void *ubuf[] CRYPTO_MINALIGN_ATTR;
 };
 
<span class="p_chunk">@@ -269,6 +270,8 @@</span> <span class="p_context"> static int ahash_save_req(struct ahash_request *req, crypto_completion_t cplt)</span>
 	priv-&gt;result = req-&gt;result;
 	priv-&gt;complete = req-&gt;base.complete;
 	priv-&gt;data = req-&gt;base.data;
<span class="p_add">+	priv-&gt;flags = req-&gt;base.flags;</span>
<span class="p_add">+</span>
 	/*
 	 * WARNING: We do not backup req-&gt;priv here! The req-&gt;priv
 	 *          is for internal use of the Crypto API and the
<span class="p_chunk">@@ -283,38 +286,44 @@</span> <span class="p_context"> static int ahash_save_req(struct ahash_request *req, crypto_completion_t cplt)</span>
 	return 0;
 }
 
<span class="p_del">-static void ahash_restore_req(struct ahash_request *req)</span>
<span class="p_add">+static void ahash_restore_req(struct ahash_request *req, int err)</span>
 {
 	struct ahash_request_priv *priv = req-&gt;priv;
 
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		memcpy(priv-&gt;result, req-&gt;result,</span>
<span class="p_add">+		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));</span>
<span class="p_add">+</span>
 	/* Restore the original crypto request. */
 	req-&gt;result = priv-&gt;result;
<span class="p_del">-	req-&gt;base.complete = priv-&gt;complete;</span>
<span class="p_del">-	req-&gt;base.data = priv-&gt;data;</span>
<span class="p_add">+</span>
<span class="p_add">+	ahash_request_set_callback(req, priv-&gt;flags,</span>
<span class="p_add">+				   priv-&gt;complete, priv-&gt;data);</span>
 	req-&gt;priv = NULL;
 
 	/* Free the req-&gt;priv.priv from the ADJUSTED request. */
 	kzfree(priv);
 }
 
<span class="p_del">-static void ahash_op_unaligned_finish(struct ahash_request *req, int err)</span>
<span class="p_add">+static void ahash_notify_einprogress(struct ahash_request *req)</span>
 {
 	struct ahash_request_priv *priv = req-&gt;priv;
<span class="p_add">+	struct crypto_async_request oreq;</span>
 
<span class="p_del">-	if (err == -EINPROGRESS)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		memcpy(priv-&gt;result, req-&gt;result,</span>
<span class="p_del">-		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));</span>
<span class="p_add">+	oreq.data = priv-&gt;data;</span>
 
<span class="p_del">-	ahash_restore_req(req);</span>
<span class="p_add">+	priv-&gt;complete(&amp;oreq, -EINPROGRESS);</span>
 }
 
 static void ahash_op_unaligned_done(struct crypto_async_request *req, int err)
 {
 	struct ahash_request *areq = req-&gt;data;
 
<span class="p_add">+	if (err == -EINPROGRESS) {</span>
<span class="p_add">+		ahash_notify_einprogress(areq);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Restore the original request, see ahash_op_unaligned() for what
 	 * goes where.
<span class="p_chunk">@@ -325,7 +334,7 @@</span> <span class="p_context"> static void ahash_op_unaligned_done(struct crypto_async_request *req, int err)</span>
 	 */
 
 	/* First copy req-&gt;result into req-&gt;priv.result */
<span class="p_del">-	ahash_op_unaligned_finish(areq, err);</span>
<span class="p_add">+	ahash_restore_req(areq, err);</span>
 
 	/* Complete the ORIGINAL request. */
 	areq-&gt;base.complete(&amp;areq-&gt;base, err);
<span class="p_chunk">@@ -341,7 +350,12 @@</span> <span class="p_context"> static int ahash_op_unaligned(struct ahash_request *req,</span>
 		return err;
 
 	err = op(req);
<span class="p_del">-	ahash_op_unaligned_finish(req, err);</span>
<span class="p_add">+	if (err == -EINPROGRESS ||</span>
<span class="p_add">+	    (err == -EBUSY &amp;&amp; (ahash_request_flags(req) &amp;</span>
<span class="p_add">+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	ahash_restore_req(req, err);</span>
 
 	return err;
 }
<span class="p_chunk">@@ -376,25 +390,14 @@</span> <span class="p_context"> int crypto_ahash_digest(struct ahash_request *req)</span>
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_digest);
 
<span class="p_del">-static void ahash_def_finup_finish2(struct ahash_request *req, int err)</span>
<span class="p_add">+static void ahash_def_finup_done2(struct crypto_async_request *req, int err)</span>
 {
<span class="p_del">-	struct ahash_request_priv *priv = req-&gt;priv;</span>
<span class="p_add">+	struct ahash_request *areq = req-&gt;data;</span>
 
 	if (err == -EINPROGRESS)
 		return;
 
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		memcpy(priv-&gt;result, req-&gt;result,</span>
<span class="p_del">-		       crypto_ahash_digestsize(crypto_ahash_reqtfm(req)));</span>
<span class="p_del">-</span>
<span class="p_del">-	ahash_restore_req(req);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void ahash_def_finup_done2(struct crypto_async_request *req, int err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ahash_request *areq = req-&gt;data;</span>
<span class="p_del">-</span>
<span class="p_del">-	ahash_def_finup_finish2(areq, err);</span>
<span class="p_add">+	ahash_restore_req(areq, err);</span>
 
 	areq-&gt;base.complete(&amp;areq-&gt;base, err);
 }
<span class="p_chunk">@@ -405,11 +408,15 @@</span> <span class="p_context"> static int ahash_def_finup_finish1(struct ahash_request *req, int err)</span>
 		goto out;
 
 	req-&gt;base.complete = ahash_def_finup_done2;
<span class="p_del">-	req-&gt;base.flags &amp;= ~CRYPTO_TFM_REQ_MAY_SLEEP;</span>
<span class="p_add">+</span>
 	err = crypto_ahash_reqtfm(req)-&gt;final(req);
<span class="p_add">+	if (err == -EINPROGRESS ||</span>
<span class="p_add">+	    (err == -EBUSY &amp;&amp; (ahash_request_flags(req) &amp;</span>
<span class="p_add">+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))</span>
<span class="p_add">+		return err;</span>
 
 out:
<span class="p_del">-	ahash_def_finup_finish2(req, err);</span>
<span class="p_add">+	ahash_restore_req(req, err);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -417,7 +424,16 @@</span> <span class="p_context"> static void ahash_def_finup_done1(struct crypto_async_request *req, int err)</span>
 {
 	struct ahash_request *areq = req-&gt;data;
 
<span class="p_add">+	if (err == -EINPROGRESS) {</span>
<span class="p_add">+		ahash_notify_einprogress(areq);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	areq-&gt;base.flags &amp;= ~CRYPTO_TFM_REQ_MAY_SLEEP;</span>
<span class="p_add">+</span>
 	err = ahash_def_finup_finish1(areq, err);
<span class="p_add">+	if (areq-&gt;priv)</span>
<span class="p_add">+		return;</span>
 
 	areq-&gt;base.complete(&amp;areq-&gt;base, err);
 }
<span class="p_chunk">@@ -432,6 +448,11 @@</span> <span class="p_context"> static int ahash_def_finup(struct ahash_request *req)</span>
 		return err;
 
 	err = tfm-&gt;update(req);
<span class="p_add">+	if (err == -EINPROGRESS ||</span>
<span class="p_add">+	    (err == -EBUSY &amp;&amp; (ahash_request_flags(req) &amp;</span>
<span class="p_add">+			       CRYPTO_TFM_REQ_MAY_BACKLOG)))</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	return ahash_def_finup_finish1(req, err);
 }
 
<span class="p_header">diff --git a/drivers/acpi/Makefile b/drivers/acpi/Makefile</span>
<span class="p_header">index 6d11522f0e48..d21802bf4fd7 100644</span>
<span class="p_header">--- a/drivers/acpi/Makefile</span>
<span class="p_header">+++ b/drivers/acpi/Makefile</span>
<span class="p_chunk">@@ -2,7 +2,6 @@</span> <span class="p_context"></span>
 # Makefile for the Linux ACPI interpreter
 #
 
<span class="p_del">-ccflags-y			:= -Os</span>
 ccflags-$(CONFIG_ACPI_DEBUG)	+= -DACPI_DEBUG_OUTPUT
 
 #
<span class="p_header">diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c</span>
<span class="p_header">index 6ba8beb6b9d2..ce115ed71a2a 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_platform.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_platform.c</span>
<span class="p_chunk">@@ -24,9 +24,11 @@</span> <span class="p_context"></span>
 ACPI_MODULE_NAME(&quot;platform&quot;);
 
 static const struct acpi_device_id forbidden_id_list[] = {
<span class="p_del">-	{&quot;PNP0000&quot;, 0},	/* PIC */</span>
<span class="p_del">-	{&quot;PNP0100&quot;, 0},	/* Timer */</span>
<span class="p_del">-	{&quot;PNP0200&quot;, 0},	/* AT DMA Controller */</span>
<span class="p_add">+	{&quot;PNP0000&quot;,  0},	/* PIC */</span>
<span class="p_add">+	{&quot;PNP0100&quot;,  0},	/* Timer */</span>
<span class="p_add">+	{&quot;PNP0200&quot;,  0},	/* AT DMA Controller */</span>
<span class="p_add">+	{&quot;ACPI0009&quot;, 0},	/* IOxAPIC */</span>
<span class="p_add">+	{&quot;ACPI000A&quot;, 0},	/* IOAPIC */</span>
 	{&quot;&quot;, 0},
 };
 
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 3920ee45aa59..7e94459a489a 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -431,13 +431,13 @@</span> <span class="p_context"> static int zram_decompress_page(struct zram *zram, char *mem, u32 index)</span>
 
 	if (!handle || zram_test_flag(meta, index, ZRAM_ZERO)) {
 		bit_spin_unlock(ZRAM_ACCESS, &amp;meta-&gt;table[index].value);
<span class="p_del">-		clear_page(mem);</span>
<span class="p_add">+		memset(mem, 0, PAGE_SIZE);</span>
 		return 0;
 	}
 
 	cmem = zs_map_object(meta-&gt;mem_pool, handle, ZS_MM_RO);
 	if (size == PAGE_SIZE)
<span class="p_del">-		copy_page(mem, cmem);</span>
<span class="p_add">+		memcpy(mem, cmem, PAGE_SIZE);</span>
 	else
 		ret = zcomp_decompress(zram-&gt;comp, cmem, size, mem);
 	zs_unmap_object(meta-&gt;mem_pool, handle);
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> static int zram_bvec_write(struct zram *zram, struct bio_vec *bvec, u32 index,</span>
 
 	if ((clen == PAGE_SIZE) &amp;&amp; !is_partial_io(bvec)) {
 		src = kmap_atomic(page);
<span class="p_del">-		copy_page(cmem, src);</span>
<span class="p_add">+		memcpy(cmem, src, PAGE_SIZE);</span>
 		kunmap_atomic(src);
 	} else {
 		memcpy(cmem, src, clen);
<span class="p_header">diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig</span>
<span class="p_header">index efefd12a0f7b..68dabd7edd1d 100644</span>
<span class="p_header">--- a/drivers/char/Kconfig</span>
<span class="p_header">+++ b/drivers/char/Kconfig</span>
<span class="p_chunk">@@ -574,10 +574,12 @@</span> <span class="p_context"> config TELCLOCK</span>
 	  controlling the behavior of this hardware.
 
 config DEVPORT
<span class="p_del">-	bool</span>
<span class="p_del">-	depends on !M68K</span>
<span class="p_add">+	bool &quot;/dev/port character device&quot;</span>
 	depends on ISA || PCI
 	default y
<span class="p_add">+	help</span>
<span class="p_add">+	  Say Y here if you want to support the /dev/port device. The /dev/port</span>
<span class="p_add">+	  device is similar to /dev/mem, but for I/O ports.</span>
 
 source &quot;drivers/s390/char/Kconfig&quot;
 
<span class="p_header">diff --git a/drivers/char/mem.c b/drivers/char/mem.c</span>
<span class="p_header">index 524b707894ef..7d7e84174474 100644</span>
<span class="p_header">--- a/drivers/char/mem.c</span>
<span class="p_header">+++ b/drivers/char/mem.c</span>
<span class="p_chunk">@@ -59,6 +59,10 @@</span> <span class="p_context"> static inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size)</span>
 #endif
 
 #ifdef CONFIG_STRICT_DEVMEM
<span class="p_add">+static inline int page_is_allowed(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return devmem_is_allowed(pfn);</span>
<span class="p_add">+}</span>
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	u64 from = ((u64)pfn) &lt;&lt; PAGE_SHIFT;
<span class="p_chunk">@@ -78,6 +82,10 @@</span> <span class="p_context"> static inline int range_is_allowed(unsigned long pfn, unsigned long size)</span>
 	return 1;
 }
 #else
<span class="p_add">+static inline int page_is_allowed(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
 static inline int range_is_allowed(unsigned long pfn, unsigned long size)
 {
 	return 1;
<span class="p_chunk">@@ -122,23 +130,31 @@</span> <span class="p_context"> static ssize_t read_mem(struct file *file, char __user *buf,</span>
 
 	while (count &gt; 0) {
 		unsigned long remaining;
<span class="p_add">+		int allowed;</span>
 
 		sz = size_inside_page(p, count);
 
<span class="p_del">-		if (!range_is_allowed(p &gt;&gt; PAGE_SHIFT, count))</span>
<span class="p_add">+		allowed = page_is_allowed(p &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		if (!allowed)</span>
 			return -EPERM;
<span class="p_add">+		if (allowed == 2) {</span>
<span class="p_add">+			/* Show zeros for restricted memory. */</span>
<span class="p_add">+			remaining = clear_user(buf, sz);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * On ia64 if a page has been mapped somewhere as</span>
<span class="p_add">+			 * uncached, then it must also be accessed uncached</span>
<span class="p_add">+			 * by the kernel or data corruption may occur.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ptr = xlate_dev_mem_ptr(p);</span>
<span class="p_add">+			if (!ptr)</span>
<span class="p_add">+				return -EFAULT;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * On ia64 if a page has been mapped somewhere as uncached, then</span>
<span class="p_del">-		 * it must also be accessed uncached by the kernel or data</span>
<span class="p_del">-		 * corruption may occur.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		ptr = xlate_dev_mem_ptr(p);</span>
<span class="p_del">-		if (!ptr)</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			remaining = copy_to_user(buf, ptr, sz);</span>
<span class="p_add">+</span>
<span class="p_add">+			unxlate_dev_mem_ptr(p, ptr);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		remaining = copy_to_user(buf, ptr, sz);</span>
<span class="p_del">-		unxlate_dev_mem_ptr(p, ptr);</span>
 		if (remaining)
 			return -EFAULT;
 
<span class="p_chunk">@@ -181,30 +197,36 @@</span> <span class="p_context"> static ssize_t write_mem(struct file *file, const char __user *buf,</span>
 #endif
 
 	while (count &gt; 0) {
<span class="p_add">+		int allowed;</span>
<span class="p_add">+</span>
 		sz = size_inside_page(p, count);
 
<span class="p_del">-		if (!range_is_allowed(p &gt;&gt; PAGE_SHIFT, sz))</span>
<span class="p_add">+		allowed = page_is_allowed(p &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+		if (!allowed)</span>
 			return -EPERM;
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * On ia64 if a page has been mapped somewhere as uncached, then</span>
<span class="p_del">-		 * it must also be accessed uncached by the kernel or data</span>
<span class="p_del">-		 * corruption may occur.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		ptr = xlate_dev_mem_ptr(p);</span>
<span class="p_del">-		if (!ptr) {</span>
<span class="p_del">-			if (written)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* Skip actual writing when a page is marked as restricted. */</span>
<span class="p_add">+		if (allowed == 1) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * On ia64 if a page has been mapped somewhere as</span>
<span class="p_add">+			 * uncached, then it must also be accessed uncached</span>
<span class="p_add">+			 * by the kernel or data corruption may occur.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ptr = xlate_dev_mem_ptr(p);</span>
<span class="p_add">+			if (!ptr) {</span>
<span class="p_add">+				if (written)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		copied = copy_from_user(ptr, buf, sz);</span>
<span class="p_del">-		unxlate_dev_mem_ptr(p, ptr);</span>
<span class="p_del">-		if (copied) {</span>
<span class="p_del">-			written += sz - copied;</span>
<span class="p_del">-			if (written)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			copied = copy_from_user(ptr, buf, sz);</span>
<span class="p_add">+			unxlate_dev_mem_ptr(p, ptr);</span>
<span class="p_add">+			if (copied) {</span>
<span class="p_add">+				written += sz - copied;</span>
<span class="p_add">+				if (written)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			}</span>
 		}
 
 		buf += sz;
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index 2453a9f20d01..5480deb4b895 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1129,6 +1129,8 @@</span> <span class="p_context"> static int put_chars(u32 vtermno, const char *buf, int count)</span>
 {
 	struct port *port;
 	struct scatterlist sg[1];
<span class="p_add">+	void *data;</span>
<span class="p_add">+	int ret;</span>
 
 	if (unlikely(early_put_chars))
 		return early_put_chars(vtermno, buf, count);
<span class="p_chunk">@@ -1137,8 +1139,14 @@</span> <span class="p_context"> static int put_chars(u32 vtermno, const char *buf, int count)</span>
 	if (!port)
 		return -EPIPE;
 
<span class="p_del">-	sg_init_one(sg, buf, count);</span>
<span class="p_del">-	return __send_to_port(port, sg, 1, count, (void *)buf, false);</span>
<span class="p_add">+	data = kmemdup(buf, count, GFP_ATOMIC);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	sg_init_one(sg, data, count);</span>
<span class="p_add">+	ret = __send_to_port(port, sg, 1, count, data, false);</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 31000c8c4a90..a23062eef751 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -263,7 +263,8 @@</span> <span class="p_context"> static int deinstantiate_rng(struct device *ctrldev, int state_handle_mask)</span>
 			/* Try to run it through DECO0 */
 			ret = run_descriptor_deco0(ctrldev, desc, &amp;status);
 
<span class="p_del">-			if (ret || status) {</span>
<span class="p_add">+			if (ret ||</span>
<span class="p_add">+			    (status &amp;&amp; status != JRSTA_SSRC_JUMP_HALT_CC)) {</span>
 				dev_err(ctrldev,
 					&quot;Failed to deinstantiate RNG4 SH%d\n&quot;,
 					sh_idx);
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_object.c b/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_header">index 12c87110db3a..bc3cd300e1b8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_object.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> int ttm_base_object_init(struct ttm_object_file *tfile,</span>
 	if (unlikely(ret != 0))
 		goto out_err0;
 
<span class="p_del">-	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL, false);</span>
 	if (unlikely(ret != 0))
 		goto out_err1;
 
<span class="p_chunk">@@ -318,7 +318,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(ttm_ref_object_exists);</span>
 
 int ttm_ref_object_add(struct ttm_object_file *tfile,
 		       struct ttm_base_object *base,
<span class="p_del">-		       enum ttm_ref_type ref_type, bool *existed)</span>
<span class="p_add">+		       enum ttm_ref_type ref_type, bool *existed,</span>
<span class="p_add">+		       bool require_existed)</span>
 {
 	struct drm_open_hash *ht = &amp;tfile-&gt;ref_hash[ref_type];
 	struct ttm_ref_object *ref;
<span class="p_chunk">@@ -345,6 +346,9 @@</span> <span class="p_context"> int ttm_ref_object_add(struct ttm_object_file *tfile,</span>
 		}
 
 		rcu_read_unlock();
<span class="p_add">+		if (require_existed)</span>
<span class="p_add">+			return -EPERM;</span>
<span class="p_add">+</span>
 		ret = ttm_mem_global_alloc(mem_glob, sizeof(*ref),
 					   false, false);
 		if (unlikely(ret != 0))
<span class="p_chunk">@@ -635,7 +639,7 @@</span> <span class="p_context"> int ttm_prime_fd_to_handle(struct ttm_object_file *tfile,</span>
 	prime = (struct ttm_prime_object *) dma_buf-&gt;priv;
 	base = &amp;prime-&gt;base;
 	*handle = base-&gt;hash.key;
<span class="p_del">-	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL, false);</span>
 
 	dma_buf_put(dma_buf);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_header">index 945f1e0dad92..540b23bce8cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c</span>
<span class="p_chunk">@@ -539,7 +539,7 @@</span> <span class="p_context"> int vmw_fence_create(struct vmw_fence_manager *fman,</span>
 		     struct vmw_fence_obj **p_fence)
 {
 	struct vmw_fence_obj *fence;
<span class="p_del">-	int ret;</span>
<span class="p_add">+ 	int ret;</span>
 
 	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
 	if (unlikely(fence == NULL))
<span class="p_chunk">@@ -702,6 +702,41 @@</span> <span class="p_context"> void vmw_fence_fifo_up(struct vmw_fence_manager *fman)</span>
 }
 
 
<span class="p_add">+/**</span>
<span class="p_add">+ * vmw_fence_obj_lookup - Look up a user-space fence object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @tfile: A struct ttm_object_file identifying the caller.</span>
<span class="p_add">+ * @handle: A handle identifying the fence object.</span>
<span class="p_add">+ * @return: A struct vmw_user_fence base ttm object on success or</span>
<span class="p_add">+ * an error pointer on failure.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The fence object is looked up and type-checked. The caller needs</span>
<span class="p_add">+ * to have opened the fence object first, but since that happens on</span>
<span class="p_add">+ * creation and fence objects aren&#39;t shareable, that&#39;s not an</span>
<span class="p_add">+ * issue currently.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct ttm_base_object *</span>
<span class="p_add">+vmw_fence_obj_lookup(struct ttm_object_file *tfile, u32 handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ttm_base_object *base = ttm_base_object_lookup(tfile, handle);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base) {</span>
<span class="p_add">+		pr_err(&quot;Invalid fence object handle 0x%08lx.\n&quot;,</span>
<span class="p_add">+		       (unsigned long)handle);</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (base-&gt;refcount_release != vmw_user_fence_base_release) {</span>
<span class="p_add">+		pr_err(&quot;Invalid fence object handle 0x%08lx.\n&quot;,</span>
<span class="p_add">+		       (unsigned long)handle);</span>
<span class="p_add">+		ttm_base_object_unref(&amp;base);</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return base;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 int vmw_fence_obj_wait_ioctl(struct drm_device *dev, void *data,
 			     struct drm_file *file_priv)
 {
<span class="p_chunk">@@ -727,13 +762,9 @@</span> <span class="p_context"> int vmw_fence_obj_wait_ioctl(struct drm_device *dev, void *data,</span>
 		arg-&gt;kernel_cookie = jiffies + wait_timeout;
 	}
 
<span class="p_del">-	base = ttm_base_object_lookup(tfile, arg-&gt;handle);</span>
<span class="p_del">-	if (unlikely(base == NULL)) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;Wait invalid fence object handle &quot;</span>
<span class="p_del">-		       &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-		       (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	base = vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+	if (IS_ERR(base))</span>
<span class="p_add">+		return PTR_ERR(base);</span>
 
 	fence = &amp;(container_of(base, struct vmw_user_fence, base)-&gt;fence);
 
<span class="p_chunk">@@ -772,13 +803,9 @@</span> <span class="p_context"> int vmw_fence_obj_signaled_ioctl(struct drm_device *dev, void *data,</span>
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)-&gt;tfile;
 	struct vmw_private *dev_priv = vmw_priv(dev);
 
<span class="p_del">-	base = ttm_base_object_lookup(tfile, arg-&gt;handle);</span>
<span class="p_del">-	if (unlikely(base == NULL)) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;Fence signaled invalid fence object handle &quot;</span>
<span class="p_del">-		       &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-		       (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	base = vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+	if (IS_ERR(base))</span>
<span class="p_add">+		return PTR_ERR(base);</span>
 
 	fence = &amp;(container_of(base, struct vmw_user_fence, base)-&gt;fence);
 	fman = fman_from_fence(fence);
<span class="p_chunk">@@ -1093,6 +1120,7 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 		(struct drm_vmw_fence_event_arg *) data;
 	struct vmw_fence_obj *fence = NULL;
 	struct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);
<span class="p_add">+	struct ttm_object_file *tfile = vmw_fp-&gt;tfile;</span>
 	struct drm_vmw_fence_rep __user *user_fence_rep =
 		(struct drm_vmw_fence_rep __user *)(unsigned long)
 		arg-&gt;fence_rep;
<span class="p_chunk">@@ -1106,24 +1134,18 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 	 */
 	if (arg-&gt;handle) {
 		struct ttm_base_object *base =
<span class="p_del">-			ttm_base_object_lookup_for_ref(dev_priv-&gt;tdev,</span>
<span class="p_del">-						       arg-&gt;handle);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (unlikely(base == NULL)) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Fence event invalid fence object handle &quot;</span>
<span class="p_del">-				  &quot;0x%08lx.\n&quot;,</span>
<span class="p_del">-				  (unsigned long)arg-&gt;handle);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+			vmw_fence_obj_lookup(tfile, arg-&gt;handle);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_ERR(base))</span>
<span class="p_add">+			return PTR_ERR(base);</span>
<span class="p_add">+</span>
 		fence = &amp;(container_of(base, struct vmw_user_fence,
 				       base)-&gt;fence);
 		(void) vmw_fence_obj_reference(fence);
 
 		if (user_fence_rep != NULL) {
<span class="p_del">-			bool existed;</span>
<span class="p_del">-</span>
 			ret = ttm_ref_object_add(vmw_fp-&gt;tfile, base,
<span class="p_del">-						 TTM_REF_USAGE, &amp;existed);</span>
<span class="p_add">+						 TTM_REF_USAGE, NULL, false);</span>
 			if (unlikely(ret != 0)) {
 				DRM_ERROR(&quot;Failed to reference a fence &quot;
 					  &quot;object.\n&quot;);
<span class="p_chunk">@@ -1166,8 +1188,7 @@</span> <span class="p_context"> int vmw_fence_event_ioctl(struct drm_device *dev, void *data,</span>
 	return 0;
 out_no_create:
 	if (user_fence_rep != NULL)
<span class="p_del">-		ttm_ref_object_base_unref(vmw_fpriv(file_priv)-&gt;tfile,</span>
<span class="p_del">-					  handle, TTM_REF_USAGE);</span>
<span class="p_add">+		ttm_ref_object_base_unref(tfile, handle, TTM_REF_USAGE);</span>
 out_no_ref_obj:
 	vmw_fence_obj_unreference(&amp;fence);
 	return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c b/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_header">index 69c8ce23123c..df2fb96da16a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_ioctl.c</span>
<span class="p_chunk">@@ -106,8 +106,6 @@</span> <span class="p_context"> int vmw_getparam_ioctl(struct drm_device *dev, void *data,</span>
 		param-&gt;value = dev_priv-&gt;max_mob_size;
 		break;
 	default:
<span class="p_del">-		DRM_ERROR(&quot;Illegal vmwgfx get param request: %d\n&quot;,</span>
<span class="p_del">-			  param-&gt;param);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -161,7 +159,7 @@</span> <span class="p_context"> int vmw_get_cap_3d_ioctl(struct drm_device *dev, void *data,</span>
 	bool gb_objects = !!(dev_priv-&gt;capabilities &amp; SVGA_CAP_GBOBJECTS);
 	struct vmw_fpriv *vmw_fp = vmw_fpriv(file_priv);
 
<span class="p_del">-	if (unlikely(arg-&gt;pad64 != 0)) {</span>
<span class="p_add">+	if (unlikely(arg-&gt;pad64 != 0 || arg-&gt;max_size == 0)) {</span>
 		DRM_ERROR(&quot;Illegal GET_3D_CAP argument.\n&quot;);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">index 026de7cea0f6..8f32d7c86944 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_chunk">@@ -588,7 +588,7 @@</span> <span class="p_context"> static int vmw_user_dmabuf_synccpu_grab(struct vmw_user_dma_buffer *user_bo,</span>
 		return ret;
 
 	ret = ttm_ref_object_add(tfile, &amp;user_bo-&gt;prime.base,
<span class="p_del">-				 TTM_REF_SYNCCPU_WRITE, &amp;existed);</span>
<span class="p_add">+				 TTM_REF_SYNCCPU_WRITE, &amp;existed, false);</span>
 	if (ret != 0 || existed)
 		ttm_bo_synccpu_write_release(&amp;user_bo-&gt;dma.base);
 
<span class="p_chunk">@@ -764,7 +764,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_reference(struct ttm_object_file *tfile,</span>
 
 	*handle = user_bo-&gt;prime.base.hash.key;
 	return ttm_ref_object_add(tfile, &amp;user_bo-&gt;prime.base,
<span class="p_del">-				  TTM_REF_USAGE, NULL);</span>
<span class="p_add">+				  TTM_REF_USAGE, NULL, false);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">index 4ecdbf3e59da..75c3c2a1eb7f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_chunk">@@ -708,11 +708,14 @@</span> <span class="p_context"> int vmw_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 			128;
 
 	num_sizes = 0;
<span class="p_del">-	for (i = 0; i &lt; DRM_VMW_MAX_SURFACE_FACES; ++i)</span>
<span class="p_add">+	for (i = 0; i &lt; DRM_VMW_MAX_SURFACE_FACES; ++i) {</span>
<span class="p_add">+		if (req-&gt;mip_levels[i] &gt; DRM_VMW_MAX_MIP_LEVELS)</span>
<span class="p_add">+			return -EINVAL;</span>
 		num_sizes += req-&gt;mip_levels[i];
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (num_sizes &gt; DRM_VMW_MAX_SURFACE_FACES *</span>
<span class="p_del">-	    DRM_VMW_MAX_MIP_LEVELS)</span>
<span class="p_add">+	if (num_sizes &gt; DRM_VMW_MAX_SURFACE_FACES * DRM_VMW_MAX_MIP_LEVELS ||</span>
<span class="p_add">+	    num_sizes == 0)</span>
 		return -EINVAL;
 
 	size = vmw_user_surface_size + 128 +
<span class="p_chunk">@@ -895,17 +898,16 @@</span> <span class="p_context"> vmw_surface_handle_reference(struct vmw_private *dev_priv,</span>
 	uint32_t handle;
 	struct ttm_base_object *base;
 	int ret;
<span class="p_add">+	bool require_exist = false;</span>
 
 	if (handle_type == DRM_VMW_HANDLE_PRIME) {
 		ret = ttm_prime_fd_to_handle(tfile, u_handle, &amp;handle);
 		if (unlikely(ret != 0))
 			return ret;
 	} else {
<span class="p_del">-		if (unlikely(drm_is_render_client(file_priv))) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Render client refused legacy &quot;</span>
<span class="p_del">-				  &quot;surface reference.\n&quot;);</span>
<span class="p_del">-			return -EACCES;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (unlikely(drm_is_render_client(file_priv)))</span>
<span class="p_add">+			require_exist = true;</span>
<span class="p_add">+</span>
 		handle = u_handle;
 	}
 
<span class="p_chunk">@@ -927,17 +929,14 @@</span> <span class="p_context"> vmw_surface_handle_reference(struct vmw_private *dev_priv,</span>
 
 		/*
 		 * Make sure the surface creator has the same
<span class="p_del">-		 * authenticating master.</span>
<span class="p_add">+		 * authenticating master, or is already registered with us.</span>
 		 */
 		if (drm_is_primary_client(file_priv) &amp;&amp;
<span class="p_del">-		    user_srf-&gt;master != file_priv-&gt;master) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Trying to reference surface outside of&quot;</span>
<span class="p_del">-				  &quot; master domain.\n&quot;);</span>
<span class="p_del">-			ret = -EACCES;</span>
<span class="p_del">-			goto out_bad_resource;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		    user_srf-&gt;master != file_priv-&gt;master)</span>
<span class="p_add">+			require_exist = true;</span>
 
<span class="p_del">-		ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);</span>
<span class="p_add">+		ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL,</span>
<span class="p_add">+					 require_exist);</span>
 		if (unlikely(ret != 0)) {
 			DRM_ERROR(&quot;Could not add a reference to a surface.\n&quot;);
 			goto out_bad_resource;
<span class="p_header">diff --git a/drivers/hv/hv_balloon.c b/drivers/hv/hv_balloon.c</span>
<span class="p_header">index 5e90c5d771a7..040bbfd1fff6 100644</span>
<span class="p_header">--- a/drivers/hv/hv_balloon.c</span>
<span class="p_header">+++ b/drivers/hv/hv_balloon.c</span>
<span class="p_chunk">@@ -673,7 +673,7 @@</span> <span class="p_context"> static bool pfn_covered(unsigned long start_pfn, unsigned long pfn_cnt)</span>
 		 * If the pfn range we are dealing with is not in the current
 		 * &quot;hot add block&quot;, move on.
 		 */
<span class="p_del">-		if ((start_pfn &gt;= has-&gt;end_pfn))</span>
<span class="p_add">+		if (start_pfn &lt; has-&gt;start_pfn || start_pfn &gt;= has-&gt;end_pfn)</span>
 			continue;
 		/*
 		 * If the current hot add-request extends beyond
<span class="p_chunk">@@ -728,7 +728,7 @@</span> <span class="p_context"> static unsigned long handle_pg_range(unsigned long pg_start,</span>
 		 * If the pfn range we are dealing with is not in the current
 		 * &quot;hot add block&quot;, move on.
 		 */
<span class="p_del">-		if ((start_pfn &gt;= has-&gt;end_pfn))</span>
<span class="p_add">+		if (start_pfn &lt; has-&gt;start_pfn || start_pfn &gt;= has-&gt;end_pfn)</span>
 			continue;
 
 		old_covered_state = has-&gt;covered_end_pfn;
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index b730864731e8..3f8fc28c33e4 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -122,7 +122,9 @@</span> <span class="p_context"> static irqreturn_t tiadc_irq_h(int irq, void *private)</span>
 {
 	struct iio_dev *indio_dev = private;
 	struct tiadc_device *adc_dev = iio_priv(indio_dev);
<span class="p_del">-	unsigned int status, config;</span>
<span class="p_add">+	unsigned int status, config, adc_fsm;</span>
<span class="p_add">+	unsigned short count = 0;</span>
<span class="p_add">+</span>
 	status = tiadc_readl(adc_dev, REG_IRQSTATUS);
 
 	/*
<span class="p_chunk">@@ -136,6 +138,15 @@</span> <span class="p_context"> static irqreturn_t tiadc_irq_h(int irq, void *private)</span>
 		tiadc_writel(adc_dev, REG_CTRL, config);
 		tiadc_writel(adc_dev, REG_IRQSTATUS, IRQENB_FIFO1OVRRUN
 				| IRQENB_FIFO1UNDRFLW | IRQENB_FIFO1THRES);
<span class="p_add">+</span>
<span class="p_add">+		/* wait for idle state.</span>
<span class="p_add">+		 * ADC needs to finish the current conversion</span>
<span class="p_add">+		 * before disabling the module</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			adc_fsm = tiadc_readl(adc_dev, REG_ADCFSM);</span>
<span class="p_add">+		} while (adc_fsm != 0x10 &amp;&amp; count++ &lt; 100);</span>
<span class="p_add">+</span>
 		tiadc_writel(adc_dev, REG_CTRL, (config | CNTRLREG_TSCSSENB));
 		return IRQ_HANDLED;
 	} else if (status &amp; IRQENB_FIFO1THRES) {
<span class="p_header">diff --git a/drivers/input/joystick/iforce/iforce-usb.c b/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_header">index d96aa27dfcdc..db64adfbe1af 100644</span>
<span class="p_header">--- a/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_header">+++ b/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_chunk">@@ -141,6 +141,9 @@</span> <span class="p_context"> static int iforce_usb_probe(struct usb_interface *intf,</span>
 
 	interface = intf-&gt;cur_altsetting;
 
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	epirq = &amp;interface-&gt;endpoint[0].desc;
 	epout = &amp;interface-&gt;endpoint[1].desc;
 
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index 7b41d543a41f..1a728f310b27 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"> static const struct xpad_device {</span>
 	{ 0x1430, 0x8888, &quot;TX6500+ Dance Pad (first generation)&quot;, MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },
 	{ 0x146b, 0x0601, &quot;BigBen Interactive XBOX 360 Controller&quot;, 0, XTYPE_XBOX360 },
 	{ 0x1532, 0x0037, &quot;Razer Sabertooth&quot;, 0, XTYPE_XBOX360 },
<span class="p_add">+	{ 0x1532, 0x0a03, &quot;Razer Wildcat&quot;, 0, XTYPE_XBOXONE },</span>
 	{ 0x15e4, 0x3f00, &quot;Power A Mini Pro Elite&quot;, 0, XTYPE_XBOX360 },
 	{ 0x15e4, 0x3f0a, &quot;Xbox Airflo wired controller&quot;, 0, XTYPE_XBOX360 },
 	{ 0x15e4, 0x3f10, &quot;Batarang Xbox 360 controller&quot;, 0, XTYPE_XBOX360 },
<span class="p_chunk">@@ -308,6 +309,7 @@</span> <span class="p_context"> static struct usb_device_id xpad_table[] = {</span>
 	XPAD_XBOX360_VENDOR(0x1689),		/* Razer Onza */
 	XPAD_XBOX360_VENDOR(0x24c6),		/* PowerA Controllers */
 	XPAD_XBOX360_VENDOR(0x1532),		/* Razer Sabertooth */
<span class="p_add">+	XPAD_XBOXONE_VENDOR(0x1532),		/* Razer Wildcat */</span>
 	XPAD_XBOX360_VENDOR(0x15e4),		/* Numark X-Box 360 controllers */
 	XPAD_XBOX360_VENDOR(0x162e),		/* Joytech X-Box 360 controllers */
 	{ }
<span class="p_header">diff --git a/drivers/input/misc/cm109.c b/drivers/input/misc/cm109.c</span>
<span class="p_header">index 9365535ba7f1..50a7faa504f7 100644</span>
<span class="p_header">--- a/drivers/input/misc/cm109.c</span>
<span class="p_header">+++ b/drivers/input/misc/cm109.c</span>
<span class="p_chunk">@@ -675,6 +675,10 @@</span> <span class="p_context"> static int cm109_usb_probe(struct usb_interface *intf,</span>
 	int error = -ENOMEM;
 
 	interface = intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	endpoint = &amp;interface-&gt;endpoint[0].desc;
 
 	if (!usb_endpoint_is_int_in(endpoint))
<span class="p_header">diff --git a/drivers/input/misc/ims-pcu.c b/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">index 41ef29b516f3..25bd4d701722 100644</span>
<span class="p_header">--- a/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">+++ b/drivers/input/misc/ims-pcu.c</span>
<span class="p_chunk">@@ -1667,6 +1667,10 @@</span> <span class="p_context"> static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc</span>
 		return -EINVAL;
 
 	alt = pcu-&gt;ctrl_intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (alt-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	pcu-&gt;ep_ctrl = &amp;alt-&gt;endpoint[0].desc;
 	pcu-&gt;max_ctrl_size = usb_endpoint_maxp(pcu-&gt;ep_ctrl);
 
<span class="p_header">diff --git a/drivers/input/misc/yealink.c b/drivers/input/misc/yealink.c</span>
<span class="p_header">index 79c964c075f1..6e7ff9561d92 100644</span>
<span class="p_header">--- a/drivers/input/misc/yealink.c</span>
<span class="p_header">+++ b/drivers/input/misc/yealink.c</span>
<span class="p_chunk">@@ -875,6 +875,10 @@</span> <span class="p_context"> static int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	int ret, pipe, i;
 
 	interface = intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	endpoint = &amp;interface-&gt;endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -ENODEV;
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index faccb8349647..baa160e7e4ee 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -120,6 +120,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Dell Embedded Box PC 3000 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Embedded Box PC 3000&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* OQO Model 01 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;OQO&quot;),
<span class="p_header">diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c</span>
<span class="p_header">index cd852059b99e..df4bea96d7ed 100644</span>
<span class="p_header">--- a/drivers/input/tablet/hanwang.c</span>
<span class="p_header">+++ b/drivers/input/tablet/hanwang.c</span>
<span class="p_chunk">@@ -340,6 +340,9 @@</span> <span class="p_context"> static int hanwang_probe(struct usb_interface *intf, const struct usb_device_id</span>
 	int error;
 	int i;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	hanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!hanwang || !input_dev) {
<span class="p_header">diff --git a/drivers/input/tablet/kbtab.c b/drivers/input/tablet/kbtab.c</span>
<span class="p_header">index d2ac7c2b5b82..2812f9236b7d 100644</span>
<span class="p_header">--- a/drivers/input/tablet/kbtab.c</span>
<span class="p_header">+++ b/drivers/input/tablet/kbtab.c</span>
<span class="p_chunk">@@ -122,6 +122,9 @@</span> <span class="p_context"> static int kbtab_probe(struct usb_interface *intf, const struct usb_device_id *i</span>
 	struct input_dev *input_dev;
 	int error = -ENOMEM;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	kbtab = kzalloc(sizeof(struct kbtab), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!kbtab || !input_dev)
<span class="p_header">diff --git a/drivers/input/touchscreen/sur40.c b/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">index f1cb05148b46..af96ffcbcffd 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/sur40.c</span>
<span class="p_chunk">@@ -361,6 +361,9 @@</span> <span class="p_context"> static int sur40_probe(struct usb_interface *interface,</span>
 	if (iface_desc-&gt;desc.bInterfaceClass != 0xFF)
 		return -ENODEV;
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 5)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* Use endpoint #4 (0x86). */
 	endpoint = &amp;iface_desc-&gt;endpoint[4].desc;
 	if (endpoint-&gt;bEndpointAddress != TOUCH_ENDPOINT)
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 1689632e4e92..410541edbb18 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -719,7 +719,7 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 				 * which we used for the IOMMU lookup. Strictly speaking
 				 * we could do this for all PCI devices; we only need to
 				 * get the BDF# from the scope table for ACPI matches. */
<span class="p_del">-				if (pdev-&gt;is_virtfn)</span>
<span class="p_add">+				if (pdev &amp;&amp; pdev-&gt;is_virtfn)</span>
 					goto got_pdev;
 
 				*bus = drhd-&gt;devices[i].bus;
<span class="p_header">diff --git a/drivers/isdn/gigaset/bas-gigaset.c b/drivers/isdn/gigaset/bas-gigaset.c</span>
<span class="p_header">index aecec6d32463..7f1c625b08ec 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/bas-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/bas-gigaset.c</span>
<span class="p_chunk">@@ -2317,6 +2317,9 @@</span> <span class="p_context"> static int gigaset_probe(struct usb_interface *interface,</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	if (hostif-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	dev_info(&amp;udev-&gt;dev,
 		 &quot;%s: Device matched (Vendor: 0x%x, Product: 0x%x)\n&quot;,
 		 __func__, le16_to_cpu(udev-&gt;descriptor.idVendor),
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 3e4def3c2b9f..1b49827757b5 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1578,7 +1578,25 @@</span> <span class="p_context"> static void make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If a bio is splitted, the first part of bio will pass</span>
<span class="p_add">+		 * barrier but the bio is queued in current-&gt;bio_list (see</span>
<span class="p_add">+		 * generic_make_request). If there is a raise_barrier() called</span>
<span class="p_add">+		 * here, the second part of bio can&#39;t pass barrier. But since</span>
<span class="p_add">+		 * the first part bio isn&#39;t dispatched to underlaying disks</span>
<span class="p_add">+		 * yet, the barrier is never released, hence raise_barrier will</span>
<span class="p_add">+		 * alays wait. We have a deadlock.</span>
<span class="p_add">+		 * Note, this only happens in read path. For write path, the</span>
<span class="p_add">+		 * first part of bio is dispatched in a schedule() call</span>
<span class="p_add">+		 * (because of blk plug) or offloaded to raid10d.</span>
<span class="p_add">+		 * Quitting from the function immediately can change the bio</span>
<span class="p_add">+		 * order queued in bio_list and avoid the deadlock.</span>
<span class="p_add">+		 */</span>
 		__make_request(mddev, split);
<span class="p_add">+		if (split != bio &amp;&amp; bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			generic_make_request(bio);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 	} while (split != bio);
 
 	/* In case raid10d snuck in to freeze_array */
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c</span>
<span class="p_header">index 1950f37df835..d429a6d109f8 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/dvb_usb_core.c</span>
<span class="p_chunk">@@ -952,8 +952,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(dvb_usbv2_probe);</span>
 void dvb_usbv2_disconnect(struct usb_interface *intf)
 {
 	struct dvb_usb_device *d = usb_get_intfdata(intf);
<span class="p_del">-	const char *name = d-&gt;name;</span>
<span class="p_del">-	struct device dev = d-&gt;udev-&gt;dev;</span>
<span class="p_add">+	const char *devname = kstrdup(dev_name(&amp;d-&gt;udev-&gt;dev), GFP_KERNEL);</span>
<span class="p_add">+	const char *drvname = d-&gt;name;</span>
<span class="p_add">+</span>
 	dev_dbg(&amp;d-&gt;udev-&gt;dev, &quot;%s: bInterfaceNumber=%d\n&quot;, __func__,
 			intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
 
<span class="p_chunk">@@ -962,8 +963,9 @@</span> <span class="p_context"> void dvb_usbv2_disconnect(struct usb_interface *intf)</span>
 
 	dvb_usbv2_exit(d);
 
<span class="p_del">-	dev_info(&amp;dev, &quot;%s: &#39;%s&#39; successfully deinitialized and disconnected\n&quot;,</span>
<span class="p_del">-			KBUILD_MODNAME, name);</span>
<span class="p_add">+	pr_info(&quot;%s: &#39;%s:%s&#39; successfully deinitialized and disconnected\n&quot;,</span>
<span class="p_add">+		KBUILD_MODNAME, drvname, devname);</span>
<span class="p_add">+	kfree(devname);</span>
 }
 EXPORT_SYMBOL(dvb_usbv2_disconnect);
 
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dvb-usb-firmware.c b/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_header">index 733a7ff7b207..caad3b5c01ad 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_chunk">@@ -35,42 +35,51 @@</span> <span class="p_context"> static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 le</span>
 
 int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)
 {
<span class="p_del">-	struct hexline hx;</span>
<span class="p_del">-	u8 reset;</span>
<span class="p_del">-	int ret,pos=0;</span>
<span class="p_add">+	struct hexline *hx;</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+	int ret, pos = 0;</span>
<span class="p_add">+	u16 cpu_cs_register = cypress[type].cpu_cs_register;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(sizeof(*hx), GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	hx = (struct hexline *)buf;</span>
 
 	/* stop the CPU */
<span class="p_del">-	reset = 1;</span>
<span class="p_del">-	if ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&amp;reset,1)) != 1)</span>
<span class="p_add">+	buf[0] = 1;</span>
<span class="p_add">+	if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)</span>
 		err(&quot;could not stop the USB controller CPU.&quot;);
 
<span class="p_del">-	while ((ret = dvb_usb_get_hexline(fw,&amp;hx,&amp;pos)) &gt; 0) {</span>
<span class="p_del">-		deb_fw(&quot;writing to address 0x%04x (buffer: 0x%02x %02x)\n&quot;,hx.addr,hx.len,hx.chk);</span>
<span class="p_del">-		ret = usb_cypress_writemem(udev,hx.addr,hx.data,hx.len);</span>
<span class="p_add">+	while ((ret = dvb_usb_get_hexline(fw, hx, &amp;pos)) &gt; 0) {</span>
<span class="p_add">+		deb_fw(&quot;writing to address 0x%04x (buffer: 0x%02x %02x)\n&quot;, hx-&gt;addr, hx-&gt;len, hx-&gt;chk);</span>
<span class="p_add">+		ret = usb_cypress_writemem(udev, hx-&gt;addr, hx-&gt;data, hx-&gt;len);</span>
 
<span class="p_del">-		if (ret != hx.len) {</span>
<span class="p_add">+		if (ret != hx-&gt;len) {</span>
 			err(&quot;error while transferring firmware &quot;
 				&quot;(transferred size: %d, block size: %d)&quot;,
<span class="p_del">-				ret,hx.len);</span>
<span class="p_add">+				ret, hx-&gt;len);</span>
 			ret = -EINVAL;
 			break;
 		}
 	}
 	if (ret &lt; 0) {
 		err(&quot;firmware download failed at %d with %d&quot;,pos,ret);
<span class="p_add">+		kfree(buf);</span>
 		return ret;
 	}
 
 	if (ret == 0) {
 		/* restart the CPU */
<span class="p_del">-		reset = 0;</span>
<span class="p_del">-		if (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&amp;reset,1) != 1) {</span>
<span class="p_add">+		buf[0] = 0;</span>
<span class="p_add">+		if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {</span>
 			err(&quot;could not restart the USB controller CPU.&quot;);
 			ret = -EINVAL;
 		}
 	} else
 		ret = -EIO;
 
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+</span>
 	return ret;
 }
 EXPORT_SYMBOL(usb_cypress_load_firmware);
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c</span>
<span class="p_header">index 3c07af96b30f..13d1090c2ba5 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_driver.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_driver.c</span>
<span class="p_chunk">@@ -1553,6 +1553,114 @@</span> <span class="p_context"> static const char *uvc_print_chain(struct uvc_video_chain *chain)</span>
 	return buffer;
 }
 
<span class="p_add">+static struct uvc_video_chain *uvc_alloc_chain(struct uvc_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct uvc_video_chain *chain;</span>
<span class="p_add">+</span>
<span class="p_add">+	chain = kzalloc(sizeof(*chain), GFP_KERNEL);</span>
<span class="p_add">+	if (chain == NULL)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;chain-&gt;entities);</span>
<span class="p_add">+	mutex_init(&amp;chain-&gt;ctrl_mutex);</span>
<span class="p_add">+	chain-&gt;dev = dev;</span>
<span class="p_add">+	v4l2_prio_init(&amp;chain-&gt;prio);</span>
<span class="p_add">+</span>
<span class="p_add">+	return chain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Fallback heuristic for devices that don&#39;t connect units and terminals in a</span>
<span class="p_add">+ * valid chain.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some devices have invalid baSourceID references, causing uvc_scan_chain()</span>
<span class="p_add">+ * to fail, but if we just take the entities we can find and put them together</span>
<span class="p_add">+ * in the most sensible chain we can think of, turns out they do work anyway.</span>
<span class="p_add">+ * Note: This heuristic assumes there is a single chain.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * At the time of writing, devices known to have such a broken chain are</span>
<span class="p_add">+ *  - Acer Integrated Camera (5986:055a)</span>
<span class="p_add">+ *  - Realtek rtl157a7 (0bda:57a7)</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int uvc_scan_fallback(struct uvc_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct uvc_video_chain *chain;</span>
<span class="p_add">+	struct uvc_entity *iterm = NULL;</span>
<span class="p_add">+	struct uvc_entity *oterm = NULL;</span>
<span class="p_add">+	struct uvc_entity *entity;</span>
<span class="p_add">+	struct uvc_entity *prev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Start by locating the input and output terminals. We only support</span>
<span class="p_add">+	 * devices with exactly one of each for now.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_entry(entity, &amp;dev-&gt;entities, list) {</span>
<span class="p_add">+		if (UVC_ENTITY_IS_ITERM(entity)) {</span>
<span class="p_add">+			if (iterm)</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			iterm = entity;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (UVC_ENTITY_IS_OTERM(entity)) {</span>
<span class="p_add">+			if (oterm)</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			oterm = entity;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iterm == NULL || oterm == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Allocate the chain and fill it. */</span>
<span class="p_add">+	chain = uvc_alloc_chain(dev);</span>
<span class="p_add">+	if (chain == NULL)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (uvc_scan_chain_entity(chain, oterm) &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+</span>
<span class="p_add">+	prev = oterm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Add all Processing and Extension Units with two pads. The order</span>
<span class="p_add">+	 * doesn&#39;t matter much, use reverse list traversal to connect units in</span>
<span class="p_add">+	 * UVC descriptor order as we build the chain from output to input. This</span>
<span class="p_add">+	 * leads to units appearing in the order meant by the manufacturer for</span>
<span class="p_add">+	 * the cameras known to require this heuristic.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_entry_reverse(entity, &amp;dev-&gt;entities, list) {</span>
<span class="p_add">+		if (entity-&gt;type != UVC_VC_PROCESSING_UNIT &amp;&amp;</span>
<span class="p_add">+		    entity-&gt;type != UVC_VC_EXTENSION_UNIT)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (entity-&gt;num_pads != 2)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uvc_scan_chain_entity(chain, entity) &lt; 0)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+</span>
<span class="p_add">+		prev-&gt;baSourceID[0] = entity-&gt;id;</span>
<span class="p_add">+		prev = entity;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (uvc_scan_chain_entity(chain, iterm) &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+</span>
<span class="p_add">+	prev-&gt;baSourceID[0] = iterm-&gt;id;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_add_tail(&amp;chain-&gt;list, &amp;dev-&gt;chains);</span>
<span class="p_add">+</span>
<span class="p_add">+	uvc_trace(UVC_TRACE_PROBE,</span>
<span class="p_add">+		  &quot;Found a video chain by fallback heuristic (%s).\n&quot;,</span>
<span class="p_add">+		  uvc_print_chain(chain));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+error:</span>
<span class="p_add">+	kfree(chain);</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Scan the device for video chains and register video devices.
  *
<span class="p_chunk">@@ -1575,15 +1683,10 @@</span> <span class="p_context"> static int uvc_scan_device(struct uvc_device *dev)</span>
 		if (term-&gt;chain.next || term-&gt;chain.prev)
 			continue;
 
<span class="p_del">-		chain = kzalloc(sizeof(*chain), GFP_KERNEL);</span>
<span class="p_add">+		chain = uvc_alloc_chain(dev);</span>
 		if (chain == NULL)
 			return -ENOMEM;
 
<span class="p_del">-		INIT_LIST_HEAD(&amp;chain-&gt;entities);</span>
<span class="p_del">-		mutex_init(&amp;chain-&gt;ctrl_mutex);</span>
<span class="p_del">-		chain-&gt;dev = dev;</span>
<span class="p_del">-		v4l2_prio_init(&amp;chain-&gt;prio);</span>
<span class="p_del">-</span>
 		term-&gt;flags |= UVC_ENTITY_FLAG_DEFAULT;
 
 		if (uvc_scan_chain(chain, term) &lt; 0) {
<span class="p_chunk">@@ -1597,6 +1700,9 @@</span> <span class="p_context"> static int uvc_scan_device(struct uvc_device *dev)</span>
 		list_add_tail(&amp;chain-&gt;list, &amp;dev-&gt;chains);
 	}
 
<span class="p_add">+	if (list_empty(&amp;dev-&gt;chains))</span>
<span class="p_add">+		uvc_scan_fallback(dev);</span>
<span class="p_add">+</span>
 	if (list_empty(&amp;dev-&gt;chains)) {
 		uvc_printk(KERN_INFO, &quot;No valid video chain found.\n&quot;);
 		return -1;
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index fd033cda0d53..56578504fd24 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -1232,7 +1232,9 @@</span> <span class="p_context"> clock_set:</span>
 			return;
 		}
 		timeout--;
<span class="p_del">-		mdelay(1);</span>
<span class="p_add">+		spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+		usleep_range(900, 1100);</span>
<span class="p_add">+		spin_lock_irq(&amp;host-&gt;lock);</span>
 	}
 
 	clk |= SDHCI_CLOCK_CARD_EN;
<span class="p_header">diff --git a/drivers/mmc/host/ushc.c b/drivers/mmc/host/ushc.c</span>
<span class="p_header">index d2c386f09d69..1d843357422e 100644</span>
<span class="p_header">--- a/drivers/mmc/host/ushc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/ushc.c</span>
<span class="p_chunk">@@ -426,6 +426,9 @@</span> <span class="p_context"> static int ushc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct ushc_data *ushc;
 	int ret;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	mmc = mmc_alloc_host(sizeof(struct ushc_data), &amp;intf-&gt;dev);
 	if (mmc == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/mtd/bcm47xxpart.c b/drivers/mtd/bcm47xxpart.c</span>
<span class="p_header">index 8057f52a45b7..dd432f935976 100644</span>
<span class="p_header">--- a/drivers/mtd/bcm47xxpart.c</span>
<span class="p_header">+++ b/drivers/mtd/bcm47xxpart.c</span>
<span class="p_chunk">@@ -183,12 +183,10 @@</span> <span class="p_context"> static int bcm47xxpart_parse(struct mtd_info *master,</span>
 
 			last_trx_part = curr_part - 1;
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We have whole TRX scanned, skip to the next part. Use</span>
<span class="p_del">-			 * roundown (not roundup), as the loop will increase</span>
<span class="p_del">-			 * offset in next step.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			offset = rounddown(offset + trx-&gt;length, blocksize);</span>
<span class="p_add">+			/* Jump to the end of TRX */</span>
<span class="p_add">+			offset = roundup(offset + trx-&gt;length, blocksize);</span>
<span class="p_add">+			/* Next loop iteration will increase the offset */</span>
<span class="p_add">+			offset -= blocksize;</span>
 			continue;
 		}
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">index 1db35f8053a1..936448e4894c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_chunk">@@ -2695,7 +2695,8 @@</span> <span class="p_context"> static int bcmgenet_suspend(struct device *d)</span>
 
 	bcmgenet_netif_stop(dev);
 
<span class="p_del">-	phy_suspend(priv-&gt;phydev);</span>
<span class="p_add">+	if (!device_may_wakeup(d))</span>
<span class="p_add">+		phy_suspend(priv-&gt;phydev);</span>
 
 	netif_device_detach(dev);
 
<span class="p_chunk">@@ -2784,7 +2785,8 @@</span> <span class="p_context"> static int bcmgenet_resume(struct device *d)</span>
 
 	netif_device_attach(dev);
 
<span class="p_del">-	phy_resume(priv-&gt;phydev);</span>
<span class="p_add">+	if (!device_may_wakeup(d))</span>
<span class="p_add">+		phy_resume(priv-&gt;phydev);</span>
 
 	bcmgenet_netif_start(dev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/e1000_phy.c b/drivers/net/ethernet/intel/igb/e1000_phy.c</span>
<span class="p_header">index c1bb64d8366f..62e36649ea09 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/e1000_phy.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/e1000_phy.c</span>
<span class="p_chunk">@@ -83,6 +83,10 @@</span> <span class="p_context"> s32 igb_get_phy_id(struct e1000_hw *hw)</span>
 	s32 ret_val = 0;
 	u16 phy_id;
 
<span class="p_add">+	/* ensure PHY page selection to fix misconfigured i210 */</span>
<span class="p_add">+	if ((hw-&gt;mac.type == e1000_i210) || (hw-&gt;mac.type == e1000_i211))</span>
<span class="p_add">+		phy-&gt;ops.write_reg(hw, I347AT4_PAGE_SELECT, 0);</span>
<span class="p_add">+</span>
 	ret_val = phy-&gt;ops.read_reg(hw, PHY_ID1, &amp;phy_id);
 	if (ret_val)
 		goto out;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 71b10b210792..efffe94aae1f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> static struct mlx5_profile profile[] = {</span>
 	[2] = {
 		.mask		= MLX5_PROF_MASK_QP_SIZE |
 				  MLX5_PROF_MASK_MR_CACHE,
<span class="p_del">-		.log_max_qp	= 17,</span>
<span class="p_add">+		.log_max_qp	= 18,</span>
 		.mr_cache[0]	= {
 			.size	= 500,
 			.limit	= 250
<span class="p_header">diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c</span>
<span class="p_header">index 8cfc3bb0c6a6..436da0c3ce3b 100644</span>
<span class="p_header">--- a/drivers/net/usb/catc.c</span>
<span class="p_header">+++ b/drivers/net/usb/catc.c</span>
<span class="p_chunk">@@ -777,7 +777,7 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct net_device *netdev;
 	struct catc *catc;
 	u8 broadcast[ETH_ALEN];
<span class="p_del">-	int i, pktsz;</span>
<span class="p_add">+	int pktsz, ret;</span>
 
 	if (usb_set_interface(usbdev,
 			intf-&gt;altsetting-&gt;desc.bInterfaceNumber, 1)) {
<span class="p_chunk">@@ -812,12 +812,8 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	if ((!catc-&gt;ctrl_urb) || (!catc-&gt;tx_urb) || 
 	    (!catc-&gt;rx_urb) || (!catc-&gt;irq_urb)) {
 		dev_err(&amp;intf-&gt;dev, &quot;No free urbs available.\n&quot;);
<span class="p_del">-		usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_del">-		free_netdev(netdev);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto fail_free;</span>
 	}
 
 	/* The F5U011 has the same vendor/product as the netmate but a device version of 0x130 */
<span class="p_chunk">@@ -845,15 +841,24 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
                 catc-&gt;irq_buf, 2, catc_irq_done, catc, 1);
 
 	if (!catc-&gt;is_f5u011) {
<span class="p_add">+		u32 *buf;</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
 		dev_dbg(dev, &quot;Checking memory size\n&quot;);
 
<span class="p_del">-		i = 0x12345678;</span>
<span class="p_del">-		catc_write_mem(catc, 0x7a80, &amp;i, 4);</span>
<span class="p_del">-		i = 0x87654321;	</span>
<span class="p_del">-		catc_write_mem(catc, 0xfa80, &amp;i, 4);</span>
<span class="p_del">-		catc_read_mem(catc, 0x7a80, &amp;i, 4);</span>
<span class="p_add">+		buf = kmalloc(4, GFP_KERNEL);</span>
<span class="p_add">+		if (!buf) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto fail_free;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		*buf = 0x12345678;</span>
<span class="p_add">+		catc_write_mem(catc, 0x7a80, buf, 4);</span>
<span class="p_add">+		*buf = 0x87654321;</span>
<span class="p_add">+		catc_write_mem(catc, 0xfa80, buf, 4);</span>
<span class="p_add">+		catc_read_mem(catc, 0x7a80, buf, 4);</span>
 	  
<span class="p_del">-		switch (i) {</span>
<span class="p_add">+		switch (*buf) {</span>
 		case 0x12345678:
 			catc_set_reg(catc, TxBufCount, 8);
 			catc_set_reg(catc, RxBufCount, 32);
<span class="p_chunk">@@ -868,6 +873,8 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 			dev_dbg(dev, &quot;32k Memory\n&quot;);
 			break;
 		}
<span class="p_add">+</span>
<span class="p_add">+		kfree(buf);</span>
 	  
 		dev_dbg(dev, &quot;Getting MAC from SEEROM.\n&quot;);
 	  
<span class="p_chunk">@@ -914,16 +921,21 @@</span> <span class="p_context"> static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	usb_set_intfdata(intf, catc);
 
 	SET_NETDEV_DEV(netdev, &amp;intf-&gt;dev);
<span class="p_del">-	if (register_netdev(netdev) != 0) {</span>
<span class="p_del">-		usb_set_intfdata(intf, NULL);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_del">-		usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_del">-		free_netdev(netdev);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ret = register_netdev(netdev);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto fail_clear_intfdata;</span>
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+fail_clear_intfdata:</span>
<span class="p_add">+	usb_set_intfdata(intf, NULL);</span>
<span class="p_add">+fail_free:</span>
<span class="p_add">+	usb_free_urb(catc-&gt;ctrl_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;tx_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;rx_urb);</span>
<span class="p_add">+	usb_free_urb(catc-&gt;irq_urb);</span>
<span class="p_add">+	free_netdev(netdev);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void catc_disconnect(struct usb_interface *intf)
<span class="p_header">diff --git a/drivers/net/usb/pegasus.c b/drivers/net/usb/pegasus.c</span>
<span class="p_header">index f84080215915..17fac0121e56 100644</span>
<span class="p_header">--- a/drivers/net/usb/pegasus.c</span>
<span class="p_header">+++ b/drivers/net/usb/pegasus.c</span>
<span class="p_chunk">@@ -126,40 +126,61 @@</span> <span class="p_context"> static void async_ctrl_callback(struct urb *urb)</span>
 
 static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmalloc(size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_rcvctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,
<span class="p_del">-			      indx, data, size, 1000);</span>
<span class="p_add">+			      indx, buf, size, 1000);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	else if (ret &lt;= size)</span>
<span class="p_add">+		memcpy(data, buf, ret);</span>
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
<span class="p_del">-static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)</span>
<span class="p_add">+static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,</span>
<span class="p_add">+			 const void *data)</span>
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmemdup(data, size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_sndctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,
<span class="p_del">-			      indx, data, size, 100);</span>
<span class="p_add">+			      indx, buf, size, 100);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
 static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
<span class="p_add">+	u8 *buf;</span>
 	int ret;
 
<span class="p_add">+	buf = kmemdup(&amp;data, 1, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = usb_control_msg(pegasus-&gt;usb, usb_sndctrlpipe(pegasus-&gt;usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
<span class="p_del">-			      indx, &amp;data, 1, 1000);</span>
<span class="p_add">+			      indx, buf, 1, 1000);</span>
 	if (ret &lt; 0)
 		netif_dbg(pegasus, drv, pegasus-&gt;net,
 			  &quot;%s returned %d\n&quot;, __func__, ret);
<span class="p_add">+	kfree(buf);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c</span>
<span class="p_header">index 6e87e5710048..eab8fba1f8c9 100644</span>
<span class="p_header">--- a/drivers/net/usb/rtl8150.c</span>
<span class="p_header">+++ b/drivers/net/usb/rtl8150.c</span>
<span class="p_chunk">@@ -155,16 +155,36 @@</span> <span class="p_context"> static const char driver_name [] = &quot;rtl8150&quot;;</span>
 */
 static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
<span class="p_del">-	return usb_control_msg(dev-&gt;udev, usb_rcvctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_del">-			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,</span>
<span class="p_del">-			       indx, 0, data, size, 500);</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = usb_control_msg(dev-&gt;udev, usb_rcvctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_add">+			      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,</span>
<span class="p_add">+			      indx, 0, buf, size, 500);</span>
<span class="p_add">+	if (ret &gt; 0 &amp;&amp; ret &lt;= size)</span>
<span class="p_add">+		memcpy(data, buf, ret);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)</span>
<span class="p_add">+static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)</span>
 {
<span class="p_del">-	return usb_control_msg(dev-&gt;udev, usb_sndctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_del">-			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,</span>
<span class="p_del">-			       indx, 0, data, size, 500);</span>
<span class="p_add">+	void *buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmemdup(data, size, GFP_NOIO);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = usb_control_msg(dev-&gt;udev, usb_sndctrlpipe(dev-&gt;udev, 0),</span>
<span class="p_add">+			      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,</span>
<span class="p_add">+			      indx, 0, buf, size, 500);</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void async_set_reg_cb(struct urb *urb)
<span class="p_header">diff --git a/drivers/pinctrl/qcom/pinctrl-msm.c b/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_header">index ed7017df065d..db4c22dd07fa 100644</span>
<span class="p_header">--- a/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_header">+++ b/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_chunk">@@ -616,10 +616,6 @@</span> <span class="p_context"> static void msm_gpio_irq_unmask(struct irq_data *d)</span>
 
 	spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);
 
<span class="p_del">-	val = readl(pctrl-&gt;regs + g-&gt;intr_status_reg);</span>
<span class="p_del">-	val &amp;= ~BIT(g-&gt;intr_status_bit);</span>
<span class="p_del">-	writel(val, pctrl-&gt;regs + g-&gt;intr_status_reg);</span>
<span class="p_del">-</span>
 	val = readl(pctrl-&gt;regs + g-&gt;intr_cfg_reg);
 	val |= BIT(g-&gt;intr_enable_bit);
 	writel(val, pctrl-&gt;regs + g-&gt;intr_cfg_reg);
<span class="p_header">diff --git a/drivers/platform/x86/acer-wmi.c b/drivers/platform/x86/acer-wmi.c</span>
<span class="p_header">index 26c4fd1394da..e89f88c437f3 100644</span>
<span class="p_header">--- a/drivers/platform/x86/acer-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/acer-wmi.c</span>
<span class="p_chunk">@@ -1867,11 +1867,24 @@</span> <span class="p_context"> static int __init acer_wmi_enable_lm(void)</span>
 	return status;
 }
 
<span class="p_add">+#define ACER_WMID_ACCEL_HID	&quot;BST0001&quot;</span>
<span class="p_add">+</span>
 static acpi_status __init acer_wmi_get_handle_cb(acpi_handle ah, u32 level,
 						void *ctx, void **retval)
 {
<span class="p_add">+	struct acpi_device *dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!strcmp(ctx, &quot;SENR&quot;)) {</span>
<span class="p_add">+		if (acpi_bus_get_device(ah, &amp;dev))</span>
<span class="p_add">+			return AE_OK;</span>
<span class="p_add">+		if (!strcmp(ACER_WMID_ACCEL_HID, acpi_device_hid(dev)))</span>
<span class="p_add">+			return AE_OK;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		return AE_OK;</span>
<span class="p_add">+</span>
 	*(acpi_handle *)retval = ah;
<span class="p_del">-	return AE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+	return AE_CTRL_TERMINATE;</span>
 }
 
 static int __init acer_wmi_get_handle(const char *name, const char *prop,
<span class="p_chunk">@@ -1898,7 +1911,7 @@</span> <span class="p_context"> static int __init acer_wmi_accel_setup(void)</span>
 {
 	int err;
 
<span class="p_del">-	err = acer_wmi_get_handle(&quot;SENR&quot;, &quot;BST0001&quot;, &amp;gsensor_handle);</span>
<span class="p_add">+	err = acer_wmi_get_handle(&quot;SENR&quot;, ACER_WMID_ACCEL_HID, &amp;gsensor_handle);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -2274,10 +2287,11 @@</span> <span class="p_context"> static int __init acer_wmi_init(void)</span>
 		err = acer_wmi_input_setup();
 		if (err)
 			return err;
<span class="p_add">+		err = acer_wmi_accel_setup();</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 	}
 
<span class="p_del">-	acer_wmi_accel_setup();</span>
<span class="p_del">-</span>
 	err = platform_driver_register(&amp;acer_platform_driver);
 	if (err) {
 		pr_err(&quot;Unable to register platform driver\n&quot;);
<span class="p_header">diff --git a/drivers/rtc/rtc-s35390a.c b/drivers/rtc/rtc-s35390a.c</span>
<span class="p_header">index f40afdd0e5f5..00662dd28d66 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s35390a.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s35390a.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitrev.h&gt;
 #include &lt;linux/bcd.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #define S35390A_CMD_STATUS1	0
 #define S35390A_CMD_STATUS2	1
<span class="p_chunk">@@ -34,10 +35,14 @@</span> <span class="p_context"></span>
 #define S35390A_ALRM_BYTE_HOURS	1
 #define S35390A_ALRM_BYTE_MINS	2
 
<span class="p_add">+/* flags for STATUS1 */</span>
 #define S35390A_FLAG_POC	0x01
 #define S35390A_FLAG_BLD	0x02
<span class="p_add">+#define S35390A_FLAG_INT2	0x04</span>
 #define S35390A_FLAG_24H	0x40
 #define S35390A_FLAG_RESET	0x80
<span class="p_add">+</span>
<span class="p_add">+/* flag for STATUS2 */</span>
 #define S35390A_FLAG_TEST	0x01
 
 #define S35390A_INT2_MODE_MASK		0xF0
<span class="p_chunk">@@ -94,19 +99,63 @@</span> <span class="p_context"> static int s35390a_get_reg(struct s35390a *s35390a, int reg, char *buf, int len)</span>
 	return 0;
 }
 
<span class="p_del">-static int s35390a_reset(struct s35390a *s35390a)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns &lt;0 on error, 0 if rtc is setup fine and 1 if the chip was reset.</span>
<span class="p_add">+ * To keep the information if an irq is pending, pass the value read from</span>
<span class="p_add">+ * STATUS1 to the caller.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int s35390a_reset(struct s35390a *s35390a, char *status1)</span>
 {
<span class="p_del">-	char buf[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf)) &lt; 0)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(buf[0] &amp; (S35390A_FLAG_POC | S35390A_FLAG_BLD)))</span>
<span class="p_add">+	char buf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	unsigned initcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, status1, 1);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (*status1 &amp; S35390A_FLAG_POC)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not communicate for 0.5 seconds since the power-on</span>
<span class="p_add">+		 * detection circuit is in operation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		msleep(500);</span>
<span class="p_add">+	else if (!(*status1 &amp; S35390A_FLAG_BLD))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If both POC and BLD are unset everything is fine.</span>
<span class="p_add">+		 */</span>
 		return 0;
 
<span class="p_del">-	buf[0] |= (S35390A_FLAG_RESET | S35390A_FLAG_24H);</span>
<span class="p_del">-	buf[0] &amp;= 0xf0;</span>
<span class="p_del">-	return s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * At least one of POC and BLD are set, so reinitialise chip. Keeping</span>
<span class="p_add">+	 * this information in the hardware to know later that the time isn&#39;t</span>
<span class="p_add">+	 * valid is unfortunately not possible because POC and BLD are cleared</span>
<span class="p_add">+	 * on read. So the reset is best done now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The 24H bit is kept over reset, so set it already here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+initialize:</span>
<span class="p_add">+	*status1 = S35390A_FLAG_24H;</span>
<span class="p_add">+	buf = S35390A_FLAG_RESET | S35390A_FLAG_24H;</span>
<span class="p_add">+	ret = s35390a_set_reg(s35390a, S35390A_CMD_STATUS1, &amp;buf, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, &amp;buf, 1);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf &amp; (S35390A_FLAG_POC | S35390A_FLAG_BLD)) {</span>
<span class="p_add">+		/* Try up to five times to reset the chip */</span>
<span class="p_add">+		if (initcount &lt; 5) {</span>
<span class="p_add">+			++initcount;</span>
<span class="p_add">+			goto initialize;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
 }
 
 static int s35390a_disable_test_mode(struct s35390a *s35390a)
<span class="p_chunk">@@ -242,6 +291,8 @@</span> <span class="p_context"> static int s35390a_set_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)</span>
 
 	if (alm-&gt;time.tm_wday != -1)
 		buf[S35390A_ALRM_BYTE_WDAY] = bin2bcd(alm-&gt;time.tm_wday) | 0x80;
<span class="p_add">+	else</span>
<span class="p_add">+		buf[S35390A_ALRM_BYTE_WDAY] = 0;</span>
 
 	buf[S35390A_ALRM_BYTE_HOURS] = s35390a_hr2reg(s35390a,
 			alm-&gt;time.tm_hour) | 0x80;
<span class="p_chunk">@@ -265,27 +316,61 @@</span> <span class="p_context"> static int s35390a_read_alarm(struct i2c_client *client, struct rtc_wkalrm *alm)</span>
 	char buf[3], sts;
 	int i, err;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * initialize all members to -1 to signal the core that they are not</span>
<span class="p_add">+	 * defined by the hardware.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	alm-&gt;time.tm_sec = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_min = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_hour = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_mday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_mon = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_year = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_wday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_yday = -1;</span>
<span class="p_add">+	alm-&gt;time.tm_isdst = -1;</span>
<span class="p_add">+</span>
 	err = s35390a_get_reg(s35390a, S35390A_CMD_STATUS2, &amp;sts, sizeof(sts));
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	if (bitrev8(sts) != S35390A_INT2_MODE_ALARM)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if ((bitrev8(sts) &amp; S35390A_INT2_MODE_MASK) != S35390A_INT2_MODE_ALARM) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When the alarm isn&#39;t enabled, the register to configure</span>
<span class="p_add">+		 * the alarm time isn&#39;t accessible.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		alm-&gt;enabled = 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		alm-&gt;enabled = 1;</span>
<span class="p_add">+	}</span>
 
 	err = s35390a_get_reg(s35390a, S35390A_CMD_INT2_REG1, buf, sizeof(buf));
 	if (err &lt; 0)
 		return err;
 
 	/* This chip returns the bits of each byte in reverse order */
<span class="p_del">-	for (i = 0; i &lt; 3; ++i) {</span>
<span class="p_add">+	for (i = 0; i &lt; 3; ++i)</span>
 		buf[i] = bitrev8(buf[i]);
<span class="p_del">-		buf[i] &amp;= ~0x80;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	alm-&gt;time.tm_wday = bcd2bin(buf[S35390A_ALRM_BYTE_WDAY]);</span>
<span class="p_del">-	alm-&gt;time.tm_hour = s35390a_reg2hr(s35390a,</span>
<span class="p_del">-						buf[S35390A_ALRM_BYTE_HOURS]);</span>
<span class="p_del">-	alm-&gt;time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS]);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * B0 of the three matching registers is an enable flag. Iff it is set</span>
<span class="p_add">+	 * the configured value is used for matching.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_WDAY] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_wday =</span>
<span class="p_add">+			bcd2bin(buf[S35390A_ALRM_BYTE_WDAY] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_HOURS] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_hour =</span>
<span class="p_add">+			s35390a_reg2hr(s35390a,</span>
<span class="p_add">+				       buf[S35390A_ALRM_BYTE_HOURS] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf[S35390A_ALRM_BYTE_MINS] &amp; 0x80)</span>
<span class="p_add">+		alm-&gt;time.tm_min = bcd2bin(buf[S35390A_ALRM_BYTE_MINS] &amp; ~0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* alarm triggers always at s=0 */</span>
<span class="p_add">+	alm-&gt;time.tm_sec = 0;</span>
 
 	dev_dbg(&amp;client-&gt;dev, &quot;%s: alm is mins=%d, hours=%d, wday=%d\n&quot;,
 			__func__, alm-&gt;time.tm_min, alm-&gt;time.tm_hour,
<span class="p_chunk">@@ -327,11 +412,11 @@</span> <span class="p_context"> static struct i2c_driver s35390a_driver;</span>
 static int s35390a_probe(struct i2c_client *client,
 			 const struct i2c_device_id *id)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, err_reset;</span>
 	unsigned int i;
 	struct s35390a *s35390a;
 	struct rtc_time tm;
<span class="p_del">-	char buf[1];</span>
<span class="p_add">+	char buf, status1;</span>
 
 	if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
 		err = -ENODEV;
<span class="p_chunk">@@ -360,29 +445,35 @@</span> <span class="p_context"> static int s35390a_probe(struct i2c_client *client,</span>
 		}
 	}
 
<span class="p_del">-	err = s35390a_reset(s35390a);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_add">+	err_reset = s35390a_reset(s35390a, &amp;status1);</span>
<span class="p_add">+	if (err_reset &lt; 0) {</span>
<span class="p_add">+		err = err_reset;</span>
 		dev_err(&amp;client-&gt;dev, &quot;error resetting chip\n&quot;);
 		goto exit_dummy;
 	}
 
<span class="p_del">-	err = s35390a_disable_test_mode(s35390a);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;error disabling test mode\n&quot;);</span>
<span class="p_del">-		goto exit_dummy;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	err = s35390a_get_reg(s35390a, S35390A_CMD_STATUS1, buf, sizeof(buf));</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev, &quot;error checking 12/24 hour mode\n&quot;);</span>
<span class="p_del">-		goto exit_dummy;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (buf[0] &amp; S35390A_FLAG_24H)</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_24H)</span>
 		s35390a-&gt;twentyfourhour = 1;
 	else
 		s35390a-&gt;twentyfourhour = 0;
 
<span class="p_del">-	if (s35390a_get_datetime(client, &amp;tm) &lt; 0)</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_INT2) {</span>
<span class="p_add">+		/* disable alarm (and maybe test mode) */</span>
<span class="p_add">+		buf = 0;</span>
<span class="p_add">+		err = s35390a_set_reg(s35390a, S35390A_CMD_STATUS2, &amp;buf, 1);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;error disabling alarm&quot;);</span>
<span class="p_add">+			goto exit_dummy;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = s35390a_disable_test_mode(s35390a);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;error disabling test mode\n&quot;);</span>
<span class="p_add">+			goto exit_dummy;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err_reset &gt; 0 || s35390a_get_datetime(client, &amp;tm) &lt; 0)</span>
 		dev_warn(&amp;client-&gt;dev, &quot;clock needs to be set\n&quot;);
 
 	device_set_wakeup_capable(&amp;client-&gt;dev, 1);
<span class="p_chunk">@@ -395,6 +486,10 @@</span> <span class="p_context"> static int s35390a_probe(struct i2c_client *client,</span>
 		err = PTR_ERR(s35390a-&gt;rtc);
 		goto exit_dummy;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (status1 &amp; S35390A_FLAG_INT2)</span>
<span class="p_add">+		rtc_update_irq(s35390a-&gt;rtc, 1, RTC_AF);</span>
<span class="p_add">+</span>
 	return 0;
 
 exit_dummy:
<span class="p_header">diff --git a/drivers/rtc/rtc-tegra.c b/drivers/rtc/rtc-tegra.c</span>
<span class="p_header">index 76af92ad5a8a..1a79a5f20f67 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-tegra.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-tegra.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
  * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 #include &lt;linux/kernel.h&gt;
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_chunk">@@ -59,6 +60,7 @@</span> <span class="p_context"> struct tegra_rtc_info {</span>
 	struct platform_device	*pdev;
 	struct rtc_device	*rtc_dev;
 	void __iomem		*rtc_base; /* NULL if not initialized. */
<span class="p_add">+	struct clk		*clk;</span>
 	int			tegra_rtc_irq; /* alarm and periodic irq */
 	spinlock_t		tegra_rtc_lock;
 };
<span class="p_chunk">@@ -330,6 +332,14 @@</span> <span class="p_context"> static int __init tegra_rtc_probe(struct platform_device *pdev)</span>
 	if (info-&gt;tegra_rtc_irq &lt;= 0)
 		return -EBUSY;
 
<span class="p_add">+	info-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, NULL);</span>
<span class="p_add">+	if (IS_ERR(info-&gt;clk))</span>
<span class="p_add">+		return PTR_ERR(info-&gt;clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(info-&gt;clk);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	/* set context info. */
 	info-&gt;pdev = pdev;
 	spin_lock_init(&amp;info-&gt;tegra_rtc_lock);
<span class="p_chunk">@@ -350,7 +360,7 @@</span> <span class="p_context"> static int __init tegra_rtc_probe(struct platform_device *pdev)</span>
 		ret = PTR_ERR(info-&gt;rtc_dev);
 		dev_err(&amp;pdev-&gt;dev, &quot;Unable to register device (err=%d).\n&quot;,
 			ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto disable_clk;</span>
 	}
 
 	ret = devm_request_irq(&amp;pdev-&gt;dev, info-&gt;tegra_rtc_irq,
<span class="p_chunk">@@ -360,12 +370,25 @@</span> <span class="p_context"> static int __init tegra_rtc_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev,
 			&quot;Unable to request interrupt for device (err=%d).\n&quot;,
 			ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto disable_clk;</span>
 	}
 
 	dev_notice(&amp;pdev-&gt;dev, &quot;Tegra internal Real Time Clock\n&quot;);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+disable_clk:</span>
<span class="p_add">+	clk_disable_unprepare(info-&gt;clk);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int tegra_rtc_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tegra_rtc_info *info = platform_get_drvdata(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	clk_disable_unprepare(info-&gt;clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -417,6 +440,7 @@</span> <span class="p_context"> static void tegra_rtc_shutdown(struct platform_device *pdev)</span>
 
 MODULE_ALIAS(&quot;platform:tegra_rtc&quot;);
 static struct platform_driver tegra_rtc_driver = {
<span class="p_add">+	.remove		= tegra_rtc_remove,</span>
 	.shutdown	= tegra_rtc_shutdown,
 	.driver		= {
 		.name	= &quot;tegra_rtc&quot;,
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 7854584ebd59..4c74cf9ffe16 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -560,8 +560,12 @@</span> <span class="p_context"> static void iscsi_complete_task(struct iscsi_task *task, int state)</span>
 	WARN_ON_ONCE(task-&gt;state == ISCSI_TASK_FREE);
 	task-&gt;state = state;
 
<span class="p_del">-	if (!list_empty(&amp;task-&gt;running))</span>
<span class="p_add">+	spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
<span class="p_add">+	if (!list_empty(&amp;task-&gt;running)) {</span>
<span class="p_add">+		pr_debug_once(&quot;%s while task on list&quot;, __func__);</span>
 		list_del_init(&amp;task-&gt;running);
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 
 	if (conn-&gt;task == task)
 		conn-&gt;task = NULL;
<span class="p_chunk">@@ -783,7 +787,9 @@</span> <span class="p_context"> __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,</span>
 		if (session-&gt;tt-&gt;xmit_task(task))
 			goto free_task;
 	} else {
<span class="p_add">+		spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;mgmtqueue);
<span class="p_add">+		spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		iscsi_conn_queue_work(conn);
 	}
 
<span class="p_chunk">@@ -1474,8 +1480,10 @@</span> <span class="p_context"> void iscsi_requeue_task(struct iscsi_task *task)</span>
 	 * this may be on the requeue list already if the xmit_task callout
 	 * is handling the r2ts while we are adding new ones
 	 */
<span class="p_add">+	spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 	if (list_empty(&amp;task-&gt;running))
 		list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;requeue);
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 	iscsi_conn_queue_work(conn);
 }
 EXPORT_SYMBOL_GPL(iscsi_requeue_task);
<span class="p_chunk">@@ -1512,22 +1520,26 @@</span> <span class="p_context"> static int iscsi_data_xmit(struct iscsi_conn *conn)</span>
 	 * only have one nop-out as a ping from us and targets should not
 	 * overflow us with nop-ins
 	 */
<span class="p_add">+	spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 check_mgmt:
 	while (!list_empty(&amp;conn-&gt;mgmtqueue)) {
 		conn-&gt;task = list_entry(conn-&gt;mgmtqueue.next,
 					 struct iscsi_task, running);
 		list_del_init(&amp;conn-&gt;task-&gt;running);
<span class="p_add">+		spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		if (iscsi_prep_mgmt_task(conn, conn-&gt;task)) {
 			/* regular RX path uses back_lock */
 			spin_lock_bh(&amp;conn-&gt;session-&gt;back_lock);
 			__iscsi_put_task(conn-&gt;task);
 			spin_unlock_bh(&amp;conn-&gt;session-&gt;back_lock);
 			conn-&gt;task = NULL;
<span class="p_add">+			spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 			continue;
 		}
 		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto done;
<span class="p_add">+		spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 	}
 
 	/* process pending command queue */
<span class="p_chunk">@@ -1535,19 +1547,24 @@</span> <span class="p_context"> check_mgmt:</span>
 		conn-&gt;task = list_entry(conn-&gt;cmdqueue.next, struct iscsi_task,
 					running);
 		list_del_init(&amp;conn-&gt;task-&gt;running);
<span class="p_add">+		spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT) {
 			fail_scsi_task(conn-&gt;task, DID_IMM_RETRY);
<span class="p_add">+			spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 			continue;
 		}
 		rc = iscsi_prep_scsi_cmd_pdu(conn-&gt;task);
 		if (rc) {
 			if (rc == -ENOMEM || rc == -EACCES) {
<span class="p_add">+				spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 				list_add_tail(&amp;conn-&gt;task-&gt;running,
 					      &amp;conn-&gt;cmdqueue);
 				conn-&gt;task = NULL;
<span class="p_add">+				spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 				goto done;
 			} else
 				fail_scsi_task(conn-&gt;task, DID_ABORT);
<span class="p_add">+			spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 			continue;
 		}
 		rc = iscsi_xmit_task(conn);
<span class="p_chunk">@@ -1558,6 +1575,7 @@</span> <span class="p_context"> check_mgmt:</span>
 		 * we need to check the mgmt queue for nops that need to
 		 * be sent to aviod starvation
 		 */
<span class="p_add">+		spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		if (!list_empty(&amp;conn-&gt;mgmtqueue))
 			goto check_mgmt;
 	}
<span class="p_chunk">@@ -1577,12 +1595,15 @@</span> <span class="p_context"> check_mgmt:</span>
 		conn-&gt;task = task;
 		list_del_init(&amp;conn-&gt;task-&gt;running);
 		conn-&gt;task-&gt;state = ISCSI_TASK_RUNNING;
<span class="p_add">+		spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto done;
<span class="p_add">+		spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		if (!list_empty(&amp;conn-&gt;mgmtqueue))
 			goto check_mgmt;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;frwd_lock);
 	return -ENODATA;
 
<span class="p_chunk">@@ -1738,7 +1759,9 @@</span> <span class="p_context"> int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)</span>
 			goto prepd_reject;
 		}
 	} else {
<span class="p_add">+		spin_lock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;cmdqueue);
<span class="p_add">+		spin_unlock_bh(&amp;conn-&gt;taskqueuelock);</span>
 		iscsi_conn_queue_work(conn);
 	}
 
<span class="p_chunk">@@ -2917,6 +2940,7 @@</span> <span class="p_context"> iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,</span>
 	INIT_LIST_HEAD(&amp;conn-&gt;mgmtqueue);
 	INIT_LIST_HEAD(&amp;conn-&gt;cmdqueue);
 	INIT_LIST_HEAD(&amp;conn-&gt;requeue);
<span class="p_add">+	spin_lock_init(&amp;conn-&gt;taskqueuelock);</span>
 	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker);
 
 	/* allocate login_task used for the login/text sequences */
<span class="p_header">diff --git a/drivers/scsi/libsas/sas_ata.c b/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_header">index 766098af4eb7..3f0c3e0b5838 100644</span>
<span class="p_header">--- a/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_header">+++ b/drivers/scsi/libsas/sas_ata.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static unsigned int sas_ata_qc_issue(struct ata_queued_cmd *qc)</span>
 		task-&gt;num_scatter = qc-&gt;n_elem;
 	} else {
 		for_each_sg(qc-&gt;sg, sg, qc-&gt;n_elem, si)
<span class="p_del">-			xfer += sg-&gt;length;</span>
<span class="p_add">+			xfer += sg_dma_len(sg);</span>
 
 		task-&gt;total_xfer_len = xfer;
 		task-&gt;num_scatter = si;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index 6a6b3db5780d..1c80ae1e4c06 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -11249,6 +11249,7 @@</span> <span class="p_context"> static struct pci_driver lpfc_driver = {</span>
 	.id_table	= lpfc_id_table,
 	.probe		= lpfc_pci_probe_one,
 	.remove		= lpfc_pci_remove_one,
<span class="p_add">+	.shutdown	= lpfc_pci_remove_one,</span>
 	.suspend        = lpfc_pci_suspend_one,
 	.resume		= lpfc_pci_resume_one,
 	.err_handler    = &amp;lpfc_err_handler,
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index fedf432eef30..d52af6a89d4c 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1979,6 +1979,22 @@</span> <span class="p_context"> static void read_capacity_error(struct scsi_disk *sdkp, struct scsi_device *sdp,</span>
 
 #define READ_CAPACITY_RETRIES_ON_RESET	10
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensure that we don&#39;t overflow sector_t when CONFIG_LBDAF is not set</span>
<span class="p_add">+ * and the reported logical block size is bigger than 512 bytes. Note</span>
<span class="p_add">+ * that last_sector is a u64 and therefore logical_to_sectors() is not</span>
<span class="p_add">+ * applicable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool sd_addressable_capacity(u64 lba, unsigned int sector_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 last_sector = (lba + 1ULL) &lt;&lt; (ilog2(sector_size) - 9);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sizeof(sector_t) == 4 &amp;&amp; last_sector &gt; U32_MAX)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int read_capacity_16(struct scsi_disk *sdkp, struct scsi_device *sdp,
 						unsigned char *buffer)
 {
<span class="p_chunk">@@ -2044,7 +2060,7 @@</span> <span class="p_context"> static int read_capacity_16(struct scsi_disk *sdkp, struct scsi_device *sdp,</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	if ((sizeof(sdkp-&gt;capacity) == 4) &amp;&amp; (lba &gt;= 0xffffffffULL)) {</span>
<span class="p_add">+	if (!sd_addressable_capacity(lba, sector_size)) {</span>
 		sd_printk(KERN_ERR, sdkp, &quot;Too big for this kernel. Use a &quot;
 			&quot;kernel compiled with support for large block &quot;
 			&quot;devices.\n&quot;);
<span class="p_chunk">@@ -2130,7 +2146,7 @@</span> <span class="p_context"> static int read_capacity_10(struct scsi_disk *sdkp, struct scsi_device *sdp,</span>
 		return sector_size;
 	}
 
<span class="p_del">-	if ((sizeof(sdkp-&gt;capacity) == 4) &amp;&amp; (lba == 0xffffffff)) {</span>
<span class="p_add">+	if (!sd_addressable_capacity(lba, sector_size)) {</span>
 		sd_printk(KERN_ERR, sdkp, &quot;Too big for this kernel. Use a &quot;
 			&quot;kernel compiled with support for large block &quot;
 			&quot;devices.\n&quot;);
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 0becdb6e1ba0..e50adf710229 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1017,6 +1017,8 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 		result = get_user(val, ip);
 		if (result)
 			return result;
<span class="p_add">+		if (val &gt; SG_MAX_CDB_SIZE)</span>
<span class="p_add">+			return -ENOMEM;</span>
 		sfp-&gt;next_cmd_len = (val &gt; 0) ? val : 0;
 		return 0;
 	case SG_GET_VERSION_NUM:
<span class="p_header">diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c</span>
<span class="p_header">index b8475b817aa2..288bd5f7dc03 100644</span>
<span class="p_header">--- a/drivers/scsi/sr.c</span>
<span class="p_header">+++ b/drivers/scsi/sr.c</span>
<span class="p_chunk">@@ -839,6 +839,7 @@</span> <span class="p_context"> static void get_capabilities(struct scsi_cd *cd)</span>
 	unsigned char *buffer;
 	struct scsi_mode_data data;
 	struct scsi_sense_hdr sshdr;
<span class="p_add">+	unsigned int ms_len = 128;</span>
 	int rc, n;
 
 	static const char *loadmech[] =
<span class="p_chunk">@@ -865,10 +866,11 @@</span> <span class="p_context"> static void get_capabilities(struct scsi_cd *cd)</span>
 	scsi_test_unit_ready(cd-&gt;device, SR_TIMEOUT, MAX_RETRIES, &amp;sshdr);
 
 	/* ask for mode page 0x2a */
<span class="p_del">-	rc = scsi_mode_sense(cd-&gt;device, 0, 0x2a, buffer, 128,</span>
<span class="p_add">+	rc = scsi_mode_sense(cd-&gt;device, 0, 0x2a, buffer, ms_len,</span>
 			     SR_TIMEOUT, 3, &amp;data, NULL);
 
<span class="p_del">-	if (!scsi_status_is_good(rc)) {</span>
<span class="p_add">+	if (!scsi_status_is_good(rc) || data.length &gt; ms_len ||</span>
<span class="p_add">+	    data.header_length + data.block_descriptor_length &gt; data.length) {</span>
 		/* failed, drive doesn&#39;t have capabilities mode page */
 		cd-&gt;cdi.speed = 1;
 		cd-&gt;cdi.mask |= (CDC_CD_R | CDC_CD_RW | CDC_DVD_R |
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_parameters.c b/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_header">index 18c29260b4a2..578f5d03d84e 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_parameters.c</span>
<span class="p_chunk">@@ -804,22 +804,6 @@</span> <span class="p_context"> static void iscsi_check_proposer_for_optional_reply(struct iscsi_param *param)</span>
 		if (!strcmp(param-&gt;name, MAXRECVDATASEGMENTLENGTH))
 			SET_PSTATE_REPLY_OPTIONAL(param);
 		/*
<span class="p_del">-		 * The GlobalSAN iSCSI Initiator for MacOSX does</span>
<span class="p_del">-		 * not respond to MaxBurstLength, FirstBurstLength,</span>
<span class="p_del">-		 * DefaultTime2Wait or DefaultTime2Retain parameter keys.</span>
<span class="p_del">-		 * So, we set them to &#39;reply optional&#39; here, and assume the</span>
<span class="p_del">-		 * the defaults from iscsi_parameters.h if the initiator</span>
<span class="p_del">-		 * is not RFC compliant and the keys are not negotiated.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, MAXBURSTLENGTH))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, FIRSTBURSTLENGTH))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, DEFAULTTIME2WAIT))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_del">-		if (!strcmp(param-&gt;name, DEFAULTTIME2RETAIN))</span>
<span class="p_del">-			SET_PSTATE_REPLY_OPTIONAL(param);</span>
<span class="p_del">-		/*</span>
 		 * Required for gPXE iSCSI boot client
 		 */
 		if (!strcmp(param-&gt;name, MAXCONNECTIONS))
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_util.c b/drivers/target/iscsi/iscsi_target_util.c</span>
<span class="p_header">index 9062bdaf26ae..fdbf318ba437 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_util.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_util.c</span>
<span class="p_chunk">@@ -731,21 +731,23 @@</span> <span class="p_context"> void iscsit_free_cmd(struct iscsi_cmd *cmd, bool shutdown)</span>
 {
 	struct se_cmd *se_cmd = NULL;
 	int rc;
<span class="p_add">+	bool op_scsi = false;</span>
 	/*
 	 * Determine if a struct se_cmd is associated with
 	 * this struct iscsi_cmd.
 	 */
 	switch (cmd-&gt;iscsi_opcode) {
 	case ISCSI_OP_SCSI_CMD:
<span class="p_del">-		se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_del">-		__iscsit_free_cmd(cmd, true, shutdown);</span>
<span class="p_add">+		op_scsi = true;</span>
 		/*
 		 * Fallthrough
 		 */
 	case ISCSI_OP_SCSI_TMFUNC:
<span class="p_del">-		rc = transport_generic_free_cmd(&amp;cmd-&gt;se_cmd, shutdown);</span>
<span class="p_del">-		if (!rc &amp;&amp; shutdown &amp;&amp; se_cmd &amp;&amp; se_cmd-&gt;se_sess) {</span>
<span class="p_del">-			__iscsit_free_cmd(cmd, true, shutdown);</span>
<span class="p_add">+		se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_add">+		__iscsit_free_cmd(cmd, op_scsi, shutdown);</span>
<span class="p_add">+		rc = transport_generic_free_cmd(se_cmd, shutdown);</span>
<span class="p_add">+		if (!rc &amp;&amp; shutdown &amp;&amp; se_cmd-&gt;se_sess) {</span>
<span class="p_add">+			__iscsit_free_cmd(cmd, op_scsi, shutdown);</span>
 			target_put_sess_cmd(se_cmd);
 		}
 		break;
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index 3ee77db03cb7..aced4c4aa803 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> static void pscsi_tape_read_blocksize(struct se_device *dev,</span>
 
 	buf = kzalloc(12, GFP_KERNEL);
 	if (!buf)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_free;</span>
 
 	memset(cdb, 0, MAX_COMMAND_SIZE);
 	cdb[0] = MODE_SENSE;
<span class="p_chunk">@@ -172,9 +172,10 @@</span> <span class="p_context"> static void pscsi_tape_read_blocksize(struct se_device *dev,</span>
 	 * If MODE_SENSE still returns zero, set the default value to 1024.
 	 */
 	sdev-&gt;sector_size = (buf[9] &lt;&lt; 16) | (buf[10] &lt;&lt; 8) | (buf[11]);
<span class="p_add">+out_free:</span>
 	if (!sdev-&gt;sector_size)
 		sdev-&gt;sector_size = 1024;
<span class="p_del">-out_free:</span>
<span class="p_add">+</span>
 	kfree(buf);
 }
 
<span class="p_chunk">@@ -317,9 +318,10 @@</span> <span class="p_context"> static int pscsi_add_device_to_list(struct se_device *dev,</span>
 				sd-&gt;lun, sd-&gt;queue_depth);
 	}
 
<span class="p_del">-	dev-&gt;dev_attrib.hw_block_size = sd-&gt;sector_size;</span>
<span class="p_add">+	dev-&gt;dev_attrib.hw_block_size =</span>
<span class="p_add">+		min_not_zero((int)sd-&gt;sector_size, 512);</span>
 	dev-&gt;dev_attrib.hw_max_sectors =
<span class="p_del">-		min_t(int, sd-&gt;host-&gt;max_sectors, queue_max_hw_sectors(q));</span>
<span class="p_add">+		min_not_zero(sd-&gt;host-&gt;max_sectors, queue_max_hw_sectors(q));</span>
 	dev-&gt;dev_attrib.hw_queue_depth = sd-&gt;queue_depth;
 
 	/*
<span class="p_chunk">@@ -342,8 +344,10 @@</span> <span class="p_context"> static int pscsi_add_device_to_list(struct se_device *dev,</span>
 	/*
 	 * For TYPE_TAPE, attempt to determine blocksize with MODE_SENSE.
 	 */
<span class="p_del">-	if (sd-&gt;type == TYPE_TAPE)</span>
<span class="p_add">+	if (sd-&gt;type == TYPE_TAPE) {</span>
 		pscsi_tape_read_blocksize(dev, sd);
<span class="p_add">+		dev-&gt;dev_attrib.hw_block_size = sd-&gt;sector_size;</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -409,7 +413,7 @@</span> <span class="p_context"> static int pscsi_create_type_disk(struct se_device *dev, struct scsi_device *sd)</span>
 /*
  * Called with struct Scsi_Host-&gt;host_lock called.
  */
<span class="p_del">-static int pscsi_create_type_rom(struct se_device *dev, struct scsi_device *sd)</span>
<span class="p_add">+static int pscsi_create_type_nondisk(struct se_device *dev, struct scsi_device *sd)</span>
 	__releases(sh-&gt;host_lock)
 {
 	struct pscsi_hba_virt *phv = dev-&gt;se_hba-&gt;hba_ptr;
<span class="p_chunk">@@ -436,28 +440,6 @@</span> <span class="p_context"> static int pscsi_create_type_rom(struct se_device *dev, struct scsi_device *sd)</span>
 	return 0;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Called with struct Scsi_Host-&gt;host_lock called.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int pscsi_create_type_other(struct se_device *dev,</span>
<span class="p_del">-		struct scsi_device *sd)</span>
<span class="p_del">-	__releases(sh-&gt;host_lock)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pscsi_hba_virt *phv = dev-&gt;se_hba-&gt;hba_ptr;</span>
<span class="p_del">-	struct Scsi_Host *sh = sd-&gt;host;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock_irq(sh-&gt;host_lock);</span>
<span class="p_del">-	ret = pscsi_add_device_to_list(dev, sd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_debug(&quot;CORE_PSCSI[%d] - Added Type: %s for %d:%d:%d:%llu\n&quot;,</span>
<span class="p_del">-		phv-&gt;phv_host_id, scsi_device_type(sd-&gt;type), sh-&gt;host_no,</span>
<span class="p_del">-		sd-&gt;channel, sd-&gt;id, sd-&gt;lun);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int pscsi_configure_device(struct se_device *dev)
 {
 	struct se_hba *hba = dev-&gt;se_hba;
<span class="p_chunk">@@ -545,11 +527,8 @@</span> <span class="p_context"> static int pscsi_configure_device(struct se_device *dev)</span>
 		case TYPE_DISK:
 			ret = pscsi_create_type_disk(dev, sd);
 			break;
<span class="p_del">-		case TYPE_ROM:</span>
<span class="p_del">-			ret = pscsi_create_type_rom(dev, sd);</span>
<span class="p_del">-			break;</span>
 		default:
<span class="p_del">-			ret = pscsi_create_type_other(dev, sd);</span>
<span class="p_add">+			ret = pscsi_create_type_nondisk(dev, sd);</span>
 			break;
 		}
 
<span class="p_chunk">@@ -606,8 +585,7 @@</span> <span class="p_context"> static void pscsi_free_device(struct se_device *dev)</span>
 		else if (pdv-&gt;pdv_lld_host)
 			scsi_host_put(pdv-&gt;pdv_lld_host);
 
<span class="p_del">-		if ((sd-&gt;type == TYPE_DISK) || (sd-&gt;type == TYPE_ROM))</span>
<span class="p_del">-			scsi_device_put(sd);</span>
<span class="p_add">+		scsi_device_put(sd);</span>
 
 		pdv-&gt;pdv_sd = NULL;
 	}
<span class="p_chunk">@@ -1133,7 +1111,6 @@</span> <span class="p_context"> static sector_t pscsi_get_blocks(struct se_device *dev)</span>
 	if (pdv-&gt;pdv_bd &amp;&amp; pdv-&gt;pdv_bd-&gt;bd_part)
 		return pdv-&gt;pdv_bd-&gt;bd_part-&gt;nr_sects;
 
<span class="p_del">-	dump_stack();</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index 496133a4be4f..2cd7e239fbaf 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -946,9 +946,15 @@</span> <span class="p_context"> sbc_parse_cdb(struct se_cmd *cmd, struct sbc_ops *ops)</span>
 			return ret;
 		break;
 	case VERIFY:
<span class="p_add">+	case VERIFY_16:</span>
 		size = 0;
<span class="p_del">-		sectors = transport_get_sectors_10(cdb);</span>
<span class="p_del">-		cmd-&gt;t_task_lba = transport_lba_32(cdb);</span>
<span class="p_add">+		if (cdb[0] == VERIFY) {</span>
<span class="p_add">+			sectors = transport_get_sectors_10(cdb);</span>
<span class="p_add">+			cmd-&gt;t_task_lba = transport_lba_32(cdb);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			sectors = transport_get_sectors_16(cdb);</span>
<span class="p_add">+			cmd-&gt;t_task_lba = transport_lba_64(cdb);</span>
<span class="p_add">+		}</span>
 		cmd-&gt;execute_cmd = sbc_emulate_noop;
 		goto check_lba;
 	case REZERO_UNIT:
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 786bc9e6bed9..54921ac390ed 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"> struct serial_private {</span>
 	unsigned int		nr;
 	void __iomem		*remapped_bar[PCI_NUM_BAR_RESOURCES];
 	struct pci_serial_quirk	*quirk;
<span class="p_add">+	const struct pciserial_board *board;</span>
 	int			line[0];
 };
 
<span class="p_chunk">@@ -3868,6 +3869,7 @@</span> <span class="p_context"> pciserial_init_ports(struct pci_dev *dev, const struct pciserial_board *board)</span>
 		}
 	}
 	priv-&gt;nr = i;
<span class="p_add">+	priv-&gt;board = board;</span>
 	return priv;
 
 err_deinit:
<span class="p_chunk">@@ -3878,7 +3880,7 @@</span> <span class="p_context"> err_out:</span>
 }
 EXPORT_SYMBOL_GPL(pciserial_init_ports);
 
<span class="p_del">-void pciserial_remove_ports(struct serial_private *priv)</span>
<span class="p_add">+void pciserial_detach_ports(struct serial_private *priv)</span>
 {
 	struct pci_serial_quirk *quirk;
 	int i;
<span class="p_chunk">@@ -3898,7 +3900,11 @@</span> <span class="p_context"> void pciserial_remove_ports(struct serial_private *priv)</span>
 	quirk = find_quirk(priv-&gt;dev);
 	if (quirk-&gt;exit)
 		quirk-&gt;exit(priv-&gt;dev);
<span class="p_add">+}</span>
 
<span class="p_add">+void pciserial_remove_ports(struct serial_private *priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pciserial_detach_ports(priv);</span>
 	kfree(priv);
 }
 EXPORT_SYMBOL_GPL(pciserial_remove_ports);
<span class="p_chunk">@@ -5505,7 +5511,7 @@</span> <span class="p_context"> static pci_ers_result_t serial8250_io_error_detected(struct pci_dev *dev,</span>
 		return PCI_ERS_RESULT_DISCONNECT;
 
 	if (priv)
<span class="p_del">-		pciserial_suspend_ports(priv);</span>
<span class="p_add">+		pciserial_detach_ports(priv);</span>
 
 	pci_disable_device(dev);
 
<span class="p_chunk">@@ -5530,9 +5536,18 @@</span> <span class="p_context"> static pci_ers_result_t serial8250_io_slot_reset(struct pci_dev *dev)</span>
 static void serial8250_io_resume(struct pci_dev *dev)
 {
 	struct serial_private *priv = pci_get_drvdata(dev);
<span class="p_add">+	const struct pciserial_board *board;</span>
 
<span class="p_del">-	if (priv)</span>
<span class="p_del">-		pciserial_resume_ports(priv);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	board = priv-&gt;board;</span>
<span class="p_add">+	kfree(priv);</span>
<span class="p_add">+	priv = pciserial_init_ports(dev, board);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(priv)) {</span>
<span class="p_add">+		pci_set_drvdata(dev, priv);</span>
<span class="p_add">+	}</span>
 }
 
 static const struct pci_error_handlers serial8250_err_handler = {
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index daaed7c79e4f..f958ccda379a 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -1867,6 +1867,11 @@</span> <span class="p_context"> static void atmel_flush_buffer(struct uart_port *port)</span>
 		UART_PUT_TCR(port, 0);
 		atmel_port-&gt;pdc_tx.ofs = 0;
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * in uart_flush_buffer(), the xmit circular buffer has just</span>
<span class="p_add">+	 * been cleared, so we have to reset tx_len accordingly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sg_dma_len(&amp;atmel_port-&gt;sg_tx) = 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c</span>
<span class="p_header">index 49978cc495e9..fbf1dbd3e487 100644</span>
<span class="p_header">--- a/drivers/usb/class/usbtmc.c</span>
<span class="p_header">+++ b/drivers/usb/class/usbtmc.c</span>
<span class="p_chunk">@@ -1164,6 +1164,12 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 		}
 	}
 
<span class="p_add">+	if (!data-&gt;bulk_out || !data-&gt;bulk_in) {</span>
<span class="p_add">+		dev_err(&amp;intf-&gt;dev, &quot;bulk endpoints not found\n&quot;);</span>
<span class="p_add">+		retcode = -ENODEV;</span>
<span class="p_add">+		goto err_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	retcode = get_capabilities(data);
 	if (retcode)
 		dev_err(&amp;intf-&gt;dev, &quot;can&#39;t read capabilities\n&quot;);
<span class="p_chunk">@@ -1187,6 +1193,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 error_register:
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;capability_attr_grp);
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;data_attr_grp);
<span class="p_add">+err_put:</span>
 	kref_put(&amp;data-&gt;kref, usbtmc_delete);
 	return retcode;
 }
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_acm.c b/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_header">index aad8165e98ef..13f9bc4d847a 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_chunk">@@ -540,13 +540,15 @@</span> <span class="p_context"> static int acm_notify_serial_state(struct f_acm *acm)</span>
 {
 	struct usb_composite_dev *cdev = acm-&gt;port.func.config-&gt;cdev;
 	int			status;
<span class="p_add">+	__le16			serial_state;</span>
 
 	spin_lock(&amp;acm-&gt;lock);
 	if (acm-&gt;notify_req) {
 		dev_dbg(&amp;cdev-&gt;gadget-&gt;dev, &quot;acm ttyGS%d serial state %04x\n&quot;,
 			acm-&gt;port_num, acm-&gt;serial_state);
<span class="p_add">+		serial_state = cpu_to_le16(acm-&gt;serial_state);</span>
 		status = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,
<span class="p_del">-				0, &amp;acm-&gt;serial_state, sizeof(acm-&gt;serial_state));</span>
<span class="p_add">+				0, &amp;serial_state, sizeof(acm-&gt;serial_state));</span>
 	} else {
 		acm-&gt;pending = true;
 		status = 0;
<span class="p_header">diff --git a/drivers/uwb/hwa-rc.c b/drivers/uwb/hwa-rc.c</span>
<span class="p_header">index 0257f35cfb9d..e75bbe5a10cd 100644</span>
<span class="p_header">--- a/drivers/uwb/hwa-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/hwa-rc.c</span>
<span class="p_chunk">@@ -825,6 +825,9 @@</span> <span class="p_context"> static int hwarc_probe(struct usb_interface *iface,</span>
 	struct hwarc *hwarc;
 	struct device *dev = &amp;iface-&gt;dev;
 
<span class="p_add">+	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	result = -ENOMEM;
 	uwb_rc = uwb_rc_alloc();
 	if (uwb_rc == NULL) {
<span class="p_header">diff --git a/drivers/uwb/i1480/dfu/usb.c b/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_header">index 2bfc846ac071..6345e85822a4 100644</span>
<span class="p_header">--- a/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_header">+++ b/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_chunk">@@ -362,6 +362,9 @@</span> <span class="p_context"> int i1480_usb_probe(struct usb_interface *iface, const struct usb_device_id *id)</span>
 				 result);
 	}
 
<span class="p_add">+	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	result = -ENOMEM;
 	i1480_usb = kzalloc(sizeof(*i1480_usb), GFP_KERNEL);
 	if (i1480_usb == NULL) {
<span class="p_header">diff --git a/drivers/video/fbdev/xen-fbfront.c b/drivers/video/fbdev/xen-fbfront.c</span>
<span class="p_header">index 09dc44736c1a..4230af1b3a2d 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/xen-fbfront.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/xen-fbfront.c</span>
<span class="p_chunk">@@ -644,7 +644,6 @@</span> <span class="p_context"> static void xenfb_backend_changed(struct xenbus_device *dev,</span>
 		break;
 
 	case XenbusStateInitWait:
<span class="p_del">-InitWait:</span>
 		xenbus_switch_state(dev, XenbusStateConnected);
 		break;
 
<span class="p_chunk">@@ -655,7 +654,8 @@</span> <span class="p_context"> InitWait:</span>
 		 * get Connected twice here.
 		 */
 		if (dev-&gt;state != XenbusStateConnected)
<span class="p_del">-			goto InitWait; /* no InitWait seen yet, fudge it */</span>
<span class="p_add">+			/* no InitWait seen yet, fudge it */</span>
<span class="p_add">+			xenbus_switch_state(dev, XenbusStateConnected);</span>
 
 		if (xenbus_scanf(XBT_NIL, info-&gt;xbdev-&gt;otherend,
 				 &quot;request-update&quot;, &quot;%d&quot;, &amp;val) &lt; 0)
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 0f9638e72b91..771d9e76fcc1 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -355,6 +355,8 @@</span> <span class="p_context"> static int init_vqs(struct virtio_balloon *vb)</span>
 		 * Prime this virtqueue with one buffer so the hypervisor can
 		 * use it to signal us later (it can&#39;t be broken yet!).
 		 */
<span class="p_add">+		update_balloon_stats(vb);</span>
<span class="p_add">+</span>
 		sg_init_one(&amp;sg, vb-&gt;stats, sizeof vb-&gt;stats);
 		if (virtqueue_add_outbuf(vb-&gt;stats_vq, &amp;sg, 1, vb, GFP_KERNEL)
 		    &lt; 0)
<span class="p_header">diff --git a/drivers/xen/xen-acpi-processor.c b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">index b96e207bf250..57dbeef2d667 100644</span>
<span class="p_header">--- a/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">+++ b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_chunk">@@ -27,10 +27,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/syscore_ops.h&gt;</span>
 #include &lt;linux/acpi.h&gt;
 #include &lt;acpi/processor.h&gt;
 #include &lt;xen/xen.h&gt;
<span class="p_del">-#include &lt;xen/xen-ops.h&gt;</span>
 #include &lt;xen/interface/platform.h&gt;
 #include &lt;asm/xen/hypercall.h&gt;
 
<span class="p_chunk">@@ -466,15 +466,33 @@</span> <span class="p_context"> static int xen_upload_processor_pm_data(void)</span>
 	return rc;
 }
 
<span class="p_del">-static int xen_acpi_processor_resume(struct notifier_block *nb,</span>
<span class="p_del">-				     unsigned long action, void *data)</span>
<span class="p_add">+static void xen_acpi_processor_resume_worker(struct work_struct *dummy)</span>
 {
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
 	bitmap_zero(acpi_ids_done, nr_acpi_bits);
<span class="p_del">-	return xen_upload_processor_pm_data();</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = xen_upload_processor_pm_data();</span>
<span class="p_add">+	if (rc != 0)</span>
<span class="p_add">+		pr_info(&quot;ACPI data upload failed, error = %d\n&quot;, rc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_acpi_processor_resume(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static DECLARE_WORK(wq, xen_acpi_processor_resume_worker);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * xen_upload_processor_pm_data() calls non-atomic code.</span>
<span class="p_add">+	 * However, the context for xen_acpi_processor_resume is syscore</span>
<span class="p_add">+	 * with only the boot CPU online and in an atomic context.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * So defer the upload for some point safer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;wq);</span>
 }
 
<span class="p_del">-struct notifier_block xen_acpi_processor_resume_nb = {</span>
<span class="p_del">-	.notifier_call = xen_acpi_processor_resume,</span>
<span class="p_add">+static struct syscore_ops xap_syscore_ops = {</span>
<span class="p_add">+	.resume	= xen_acpi_processor_resume,</span>
 };
 
 static int __init xen_acpi_processor_init(void)
<span class="p_chunk">@@ -527,7 +545,7 @@</span> <span class="p_context"> static int __init xen_acpi_processor_init(void)</span>
 	if (rc)
 		goto err_unregister;
 
<span class="p_del">-	xen_resume_notifier_register(&amp;xen_acpi_processor_resume_nb);</span>
<span class="p_add">+	register_syscore_ops(&amp;xap_syscore_ops);</span>
 
 	return 0;
 err_unregister:
<span class="p_chunk">@@ -546,7 +564,7 @@</span> <span class="p_context"> static void __exit xen_acpi_processor_exit(void)</span>
 {
 	int i;
 
<span class="p_del">-	xen_resume_notifier_unregister(&amp;xen_acpi_processor_resume_nb);</span>
<span class="p_add">+	unregister_syscore_ops(&amp;xap_syscore_ops);</span>
 	kfree(acpi_ids_done);
 	kfree(acpi_id_present);
 	kfree(acpi_id_cst_present);
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 9431449a73ab..a3badede1b32 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -2542,7 +2542,7 @@</span> <span class="p_context"> cifs_write_from_iter(loff_t offset, size_t len, struct iov_iter *from,</span>
 		wdata-&gt;credits = credits;
 
 		if (!wdata-&gt;cfile-&gt;invalidHandle ||
<span class="p_del">-		    !cifs_reopen_file(wdata-&gt;cfile, false))</span>
<span class="p_add">+		    !(rc = cifs_reopen_file(wdata-&gt;cfile, false)))</span>
 			rc = server-&gt;ops-&gt;async_writev(wdata,
 					cifs_uncached_writedata_release);
 		if (rc) {
<span class="p_chunk">@@ -2977,7 +2977,7 @@</span> <span class="p_context"> cifs_send_async_read(loff_t offset, size_t len, struct cifsFileInfo *open_file,</span>
 		rdata-&gt;credits = credits;
 
 		if (!rdata-&gt;cfile-&gt;invalidHandle ||
<span class="p_del">-		    !cifs_reopen_file(rdata-&gt;cfile, true))</span>
<span class="p_add">+		    !(rc = cifs_reopen_file(rdata-&gt;cfile, true)))</span>
 			rc = server-&gt;ops-&gt;async_readv(rdata);
 error:
 		if (rc) {
<span class="p_chunk">@@ -3564,7 +3564,7 @@</span> <span class="p_context"> static int cifs_readpages(struct file *file, struct address_space *mapping,</span>
 		}
 
 		if (!rdata-&gt;cfile-&gt;invalidHandle ||
<span class="p_del">-		    !cifs_reopen_file(rdata-&gt;cfile, true))</span>
<span class="p_add">+		    !(rc = cifs_reopen_file(rdata-&gt;cfile, true)))</span>
 			rc = server-&gt;ops-&gt;async_readv(rdata);
 		if (rc) {
 			add_credits_and_wake_if(server, rdata-&gt;credits, 0);
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index c39773959a49..c9531b78876e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -868,6 +868,10 @@</span> <span class="p_context"> SMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	/* SMB2 TREE_CONNECT request must be called with TreeId == 0 */</span>
<span class="p_add">+	if (tcon)</span>
<span class="p_add">+		tcon-&gt;tid = 0;</span>
<span class="p_add">+</span>
 	rc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &amp;req);
 	if (rc) {
 		kfree(unc_path);
<span class="p_header">diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c</span>
<span class="p_header">index 3968b164df6e..8fc2357c6867 100644</span>
<span class="p_header">--- a/fs/ext4/inline.c</span>
<span class="p_header">+++ b/fs/ext4/inline.c</span>
<span class="p_chunk">@@ -1148,10 +1148,9 @@</span> <span class="p_context"> static int ext4_finish_convert_inline_dir(handle_t *handle,</span>
 	set_buffer_uptodate(dir_block);
 	err = ext4_handle_dirty_dirent_node(handle, inode, dir_block);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return err;</span>
 	set_buffer_verified(dir_block);
<span class="p_del">-out:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return ext4_mark_inode_dirty(handle, inode);</span>
 }
 
 static int ext4_convert_inline_data_nolock(handle_t *handle,
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_buf.c b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">index 1bf2f1ccd957..fb958db7a134 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_chunk">@@ -304,6 +304,14 @@</span> <span class="p_context"> xfs_dinode_verify(</span>
 	if (dip-&gt;di_magic != cpu_to_be16(XFS_DINODE_MAGIC))
 		return false;
 
<span class="p_add">+	/* don&#39;t allow invalid i_size */</span>
<span class="p_add">+	if (be64_to_cpu(dip-&gt;di_size) &amp; (1ULL &lt;&lt; 63))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No zero-length symlinks. */</span>
<span class="p_add">+	if (S_ISLNK(be16_to_cpu(dip-&gt;di_mode)) &amp;&amp; dip-&gt;di_size == 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	/* only version 3 or greater inodes are extensively verified here */
 	if (dip-&gt;di_version &lt; 3)
 		return true;
<span class="p_header">diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">index 281002689d64..f7af2eeacbd4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_bmap_util.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_bmap_util.c</span>
<span class="p_chunk">@@ -1622,6 +1622,7 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 	xfs_trans_t	*tp;
 	xfs_bstat_t	*sbp = &amp;sxp-&gt;sx_stat;
 	xfs_ifork_t	*tempifp, *ifp, *tifp;
<span class="p_add">+	xfs_extnum_t	nextents;</span>
 	int		src_log_flags, target_log_flags;
 	int		error = 0;
 	int		aforkblks = 0;
<span class="p_chunk">@@ -1802,7 +1803,8 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 		 * pointer.  Otherwise it&#39;s already NULL or
 		 * pointing to the extent.
 		 */
<span class="p_del">-		if (ip-&gt;i_d.di_nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_add">+		nextents = ip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
 			ifp-&gt;if_u1.if_extents =
 				ifp-&gt;if_u2.if_inline_ext;
 		}
<span class="p_chunk">@@ -1821,7 +1823,8 @@</span> <span class="p_context"> xfs_swap_extents(</span>
 		 * pointer.  Otherwise it&#39;s already NULL or
 		 * pointing to the extent.
 		 */
<span class="p_del">-		if (tip-&gt;i_d.di_nextents &lt;= XFS_INLINE_EXTS) {</span>
<span class="p_add">+		nextents = tip-&gt;i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t);</span>
<span class="p_add">+		if (nextents &lt;= XFS_INLINE_EXTS) {</span>
 			tifp-&gt;if_u1.if_extents =
 				tifp-&gt;if_u2.if_inline_ext;
 		}
<span class="p_header">diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c</span>
<span class="p_header">index 284c2b2cf810..f2492bdaa7f1 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_buf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_buf.c</span>
<span class="p_chunk">@@ -376,6 +376,7 @@</span> <span class="p_context"> retry:</span>
 out_free_pages:
 	for (i = 0; i &lt; bp-&gt;b_page_count; i++)
 		__free_page(bp-&gt;b_pages[i]);
<span class="p_add">+	bp-&gt;b_flags &amp;= ~_XBF_PAGES;</span>
 	return error;
 }
 
<span class="p_header">diff --git a/include/crypto/internal/hash.h b/include/crypto/internal/hash.h</span>
<span class="p_header">index 3b4af1d7c7e9..a25414ce2898 100644</span>
<span class="p_header">--- a/include/crypto/internal/hash.h</span>
<span class="p_header">+++ b/include/crypto/internal/hash.h</span>
<span class="p_chunk">@@ -173,6 +173,16 @@</span> <span class="p_context"> static inline struct ahash_instance *ahash_alloc_instance(</span>
 	return crypto_alloc_instance2(name, alg, ahash_instance_headroom());
 }
 
<span class="p_add">+static inline void ahash_request_complete(struct ahash_request *req, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	req-&gt;base.complete(&amp;req-&gt;base, err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u32 ahash_request_flags(struct ahash_request *req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return req-&gt;base.flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct crypto_ahash *crypto_spawn_ahash(
 	struct crypto_ahash_spawn *spawn)
 {
<span class="p_header">diff --git a/include/drm/ttm/ttm_object.h b/include/drm/ttm/ttm_object.h</span>
<span class="p_header">index ed953f98f0e1..1487011fe057 100644</span>
<span class="p_header">--- a/include/drm/ttm/ttm_object.h</span>
<span class="p_header">+++ b/include/drm/ttm/ttm_object.h</span>
<span class="p_chunk">@@ -229,6 +229,8 @@</span> <span class="p_context"> extern void ttm_base_object_unref(struct ttm_base_object **p_base);</span>
  * @ref_type: The type of reference.
  * @existed: Upon completion, indicates that an identical reference object
  * already existed, and the refcount was upped on that object instead.
<span class="p_add">+ * @require_existed: Fail with -EPERM if an identical ref object didn&#39;t</span>
<span class="p_add">+ * already exist.</span>
  *
  * Checks that the base object is shareable and adds a ref object to it.
  *
<span class="p_chunk">@@ -243,7 +245,8 @@</span> <span class="p_context"> extern void ttm_base_object_unref(struct ttm_base_object **p_base);</span>
  */
 extern int ttm_ref_object_add(struct ttm_object_file *tfile,
 			      struct ttm_base_object *base,
<span class="p_del">-			      enum ttm_ref_type ref_type, bool *existed);</span>
<span class="p_add">+			      enum ttm_ref_type ref_type, bool *existed,</span>
<span class="p_add">+			      bool require_existed);</span>
 
 extern bool ttm_ref_object_exists(struct ttm_object_file *tfile,
 				  struct ttm_base_object *base);
<span class="p_header">diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h</span>
<span class="p_header">index e4d8f705fecd..aa75be9cbc3d 100644</span>
<span class="p_header">--- a/include/linux/kvm_host.h</span>
<span class="p_header">+++ b/include/linux/kvm_host.h</span>
<span class="p_chunk">@@ -177,8 +177,8 @@</span> <span class="p_context"> int kvm_io_bus_read(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr, int len,</span>
 		    void *val);
 int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,
 			    int len, struct kvm_io_device *dev);
<span class="p_del">-int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_del">-			      struct kvm_io_device *dev);</span>
<span class="p_add">+void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_add">+			       struct kvm_io_device *dev);</span>
 
 #ifdef CONFIG_KVM_ASYNC_PF
 struct kvm_async_pf {
<span class="p_header">diff --git a/include/linux/log2.h b/include/linux/log2.h</span>
<span class="p_header">index fd7ff3d91e6a..f38fae23bdac 100644</span>
<span class="p_header">--- a/include/linux/log2.h</span>
<span class="p_header">+++ b/include/linux/log2.h</span>
<span class="p_chunk">@@ -16,12 +16,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitops.h&gt;
 
 /*
<span class="p_del">- * deal with unrepresentable constant logarithms</span>
<span class="p_del">- */</span>
<span class="p_del">-extern __attribute__((const, noreturn))</span>
<span class="p_del">-int ____ilog2_NaN(void);</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * non-constant log of base 2 calculators
  * - the arch may override these in asm/bitops.h if they can be implemented
  *   more efficiently than using fls() and fls64()
<span class="p_chunk">@@ -85,7 +79,7 @@</span> <span class="p_context"> unsigned long __rounddown_pow_of_two(unsigned long n)</span>
 #define ilog2(n)				\
 (						\
 	__builtin_constant_p(n) ? (		\
<span class="p_del">-		(n) &lt; 1 ? ____ilog2_NaN() :	\</span>
<span class="p_add">+		(n) &lt; 2 ? 0 :			\</span>
 		(n) &amp; (1ULL &lt;&lt; 63) ? 63 :	\
 		(n) &amp; (1ULL &lt;&lt; 62) ? 62 :	\
 		(n) &amp; (1ULL &lt;&lt; 61) ? 61 :	\
<span class="p_chunk">@@ -148,10 +142,7 @@</span> <span class="p_context"> unsigned long __rounddown_pow_of_two(unsigned long n)</span>
 		(n) &amp; (1ULL &lt;&lt;  4) ?  4 :	\
 		(n) &amp; (1ULL &lt;&lt;  3) ?  3 :	\
 		(n) &amp; (1ULL &lt;&lt;  2) ?  2 :	\
<span class="p_del">-		(n) &amp; (1ULL &lt;&lt;  1) ?  1 :	\</span>
<span class="p_del">-		(n) &amp; (1ULL &lt;&lt;  0) ?  0 :	\</span>
<span class="p_del">-		____ilog2_NaN()			\</span>
<span class="p_del">-				   ) :		\</span>
<span class="p_add">+		1 ) :				\</span>
 	(sizeof(n) &lt;= 4) ?			\
 	__ilog2_u32(n) :			\
 	__ilog2_u64(n)				\
<span class="p_header">diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h</span>
<span class="p_header">index 728c9ad9feb0..5cea174406c0 100644</span>
<span class="p_header">--- a/include/scsi/libiscsi.h</span>
<span class="p_header">+++ b/include/scsi/libiscsi.h</span>
<span class="p_chunk">@@ -196,6 +196,7 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 	struct iscsi_task	*task;		/* xmit task in progress */
 
 	/* xmit */
<span class="p_add">+	spinlock_t		taskqueuelock;  /* protects the next three lists */</span>
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
 	struct list_head	cmdqueue;	/* data-path cmd queue */
 	struct list_head	requeue;	/* tasks needing another run */
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 44a47ac6c1e8..0f903680080d 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -8058,7 +8058,7 @@</span> <span class="p_context"> static int perf_event_init_context(struct task_struct *child, int ctxn)</span>
 		ret = inherit_task_group(event, parent, parent_ctx,
 					 child, ctxn, &amp;inherited_all);
 		if (ret)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out_unlock;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -8074,7 +8074,7 @@</span> <span class="p_context"> static int perf_event_init_context(struct task_struct *child, int ctxn)</span>
 		ret = inherit_task_group(event, parent, parent_ctx,
 					 child, ctxn, &amp;inherited_all);
 		if (ret)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto out_unlock;</span>
 	}
 
 	raw_spin_lock_irqsave(&amp;parent_ctx-&gt;lock, flags);
<span class="p_chunk">@@ -8102,6 +8102,7 @@</span> <span class="p_context"> static int perf_event_init_context(struct task_struct *child, int ctxn)</span>
 	}
 
 	raw_spin_unlock_irqrestore(&amp;parent_ctx-&gt;lock, flags);
<span class="p_add">+out_unlock:</span>
 	mutex_unlock(&amp;parent_ctx-&gt;mutex);
 
 	perf_unpin_context(parent_ctx);
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index 0856b9720598..8d2c10714530 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -144,11 +144,17 @@</span> <span class="p_context"> static void ptrace_unfreeze_traced(struct task_struct *task)</span>
 
 	WARN_ON(!task-&gt;ptrace || task-&gt;parent != current);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PTRACE_LISTEN can allow ptrace_trap_notify to wake us up remotely.</span>
<span class="p_add">+	 * Recheck state under the lock to close this race.</span>
<span class="p_add">+	 */</span>
 	spin_lock_irq(&amp;task-&gt;sighand-&gt;siglock);
<span class="p_del">-	if (__fatal_signal_pending(task))</span>
<span class="p_del">-		wake_up_state(task, __TASK_TRACED);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		task-&gt;state = TASK_TRACED;</span>
<span class="p_add">+	if (task-&gt;state == __TASK_TRACED) {</span>
<span class="p_add">+		if (__fatal_signal_pending(task))</span>
<span class="p_add">+			wake_up_state(task, __TASK_TRACED);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			task-&gt;state = TASK_TRACED;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);
 }
 
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index d1eff3dd8a02..f01d4ecdf5ab 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -3408,23 +3408,24 @@</span> <span class="p_context"> static void __enable_ftrace_function_probe(struct ftrace_ops_hash *old_hash)</span>
 	ftrace_probe_registered = 1;
 }
 
<span class="p_del">-static void __disable_ftrace_function_probe(void)</span>
<span class="p_add">+static bool __disable_ftrace_function_probe(void)</span>
 {
 	int i;
 
 	if (!ftrace_probe_registered)
<span class="p_del">-		return;</span>
<span class="p_add">+		return false;</span>
 
 	for (i = 0; i &lt; FTRACE_FUNC_HASHSIZE; i++) {
 		struct hlist_head *hhd = &amp;ftrace_func_hash[i];
 		if (hhd-&gt;first)
<span class="p_del">-			return;</span>
<span class="p_add">+			return false;</span>
 	}
 
 	/* no more funcs left */
 	ftrace_shutdown(&amp;trace_probe_ops, 0);
 
 	ftrace_probe_registered = 0;
<span class="p_add">+	return true;</span>
 }
 
 
<span class="p_chunk">@@ -3550,6 +3551,7 @@</span> <span class="p_context"> static void</span>
 __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,
 				  void *data, int flags)
 {
<span class="p_add">+	struct ftrace_ops_hash old_hash_ops;</span>
 	struct ftrace_func_entry *rec_entry;
 	struct ftrace_func_probe *entry;
 	struct ftrace_func_probe *p;
<span class="p_chunk">@@ -3563,6 +3565,7 @@</span> <span class="p_context"> __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span>
 	int i, len = 0;
 	char *search;
 	int ret;
<span class="p_add">+	bool disabled;</span>
 
 	if (glob &amp;&amp; (strcmp(glob, &quot;*&quot;) == 0 || !strlen(glob)))
 		glob = NULL;
<span class="p_chunk">@@ -3579,6 +3582,10 @@</span> <span class="p_context"> __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span>
 
 	mutex_lock(&amp;trace_probe_ops.func_hash-&gt;regex_lock);
 
<span class="p_add">+	old_hash_ops.filter_hash = old_hash;</span>
<span class="p_add">+	/* Probes only have filters */</span>
<span class="p_add">+	old_hash_ops.notrace_hash = NULL;</span>
<span class="p_add">+</span>
 	hash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, *orig_hash);
 	if (!hash)
 		/* Hmm, should report this somehow */
<span class="p_chunk">@@ -3616,12 +3623,17 @@</span> <span class="p_context"> __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span>
 		}
 	}
 	mutex_lock(&amp;ftrace_lock);
<span class="p_del">-	__disable_ftrace_function_probe();</span>
<span class="p_add">+	disabled = __disable_ftrace_function_probe();</span>
 	/*
 	 * Remove after the disable is called. Otherwise, if the last
 	 * probe is removed, a null hash means *all enabled*.
 	 */
 	ret = ftrace_hash_move(&amp;trace_probe_ops, 1, orig_hash, hash);
<span class="p_add">+</span>
<span class="p_add">+	/* still need to update the function call sites */</span>
<span class="p_add">+	if (ftrace_enabled &amp;&amp; !disabled)</span>
<span class="p_add">+		ftrace_run_modify_code(&amp;trace_probe_ops, FTRACE_UPDATE_CALLS,</span>
<span class="p_add">+				       &amp;old_hash_ops);</span>
 	synchronize_sched();
 	if (!ret)
 		free_ftrace_hash_rcu(old_hash);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index d4588b08e07a..6d65966cdc8a 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -4883,9 +4883,9 @@</span> <span class="p_context"> static __init int test_ringbuffer(void)</span>
 		rb_data[cpu].cnt = cpu;
 		rb_threads[cpu] = kthread_create(rb_test, &amp;rb_data[cpu],
 						 &quot;rbtester/%d&quot;, cpu);
<span class="p_del">-		if (WARN_ON(!rb_threads[cpu])) {</span>
<span class="p_add">+		if (WARN_ON(IS_ERR(rb_threads[cpu]))) {</span>
 			pr_cont(&quot;FAILED\n&quot;);
<span class="p_del">-			ret = -1;</span>
<span class="p_add">+			ret = PTR_ERR(rb_threads[cpu]);</span>
 			goto out_free;
 		}
 
<span class="p_chunk">@@ -4895,9 +4895,9 @@</span> <span class="p_context"> static __init int test_ringbuffer(void)</span>
 
 	/* Now create the rb hammer! */
 	rb_hammer = kthread_run(rb_hammer_test, NULL, &quot;rbhammer&quot;);
<span class="p_del">-	if (WARN_ON(!rb_hammer)) {</span>
<span class="p_add">+	if (WARN_ON(IS_ERR(rb_hammer))) {</span>
 		pr_cont(&quot;FAILED\n&quot;);
<span class="p_del">-		ret = -1;</span>
<span class="p_add">+		ret = PTR_ERR(rb_hammer);</span>
 		goto out_free;
 	}
 
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 7a57e302338f..63a6518f0bec 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3753,6 +3753,7 @@</span> <span class="p_context"> follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
 {
 	struct page *page = NULL;
 	spinlock_t *ptl;
<span class="p_add">+	pte_t pte;</span>
 retry:
 	ptl = pmd_lockptr(mm, pmd);
 	spin_lock(ptl);
<span class="p_chunk">@@ -3762,13 +3763,14 @@</span> <span class="p_context"> retry:</span>
 	 */
 	if (!pmd_huge(*pmd))
 		goto out;
<span class="p_del">-	if (pmd_present(*pmd)) {</span>
<span class="p_add">+	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="p_add">+	if (pte_present(pte)) {</span>
 		page = pte_page(*(pte_t *)pmd) +
 			((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_del">-		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="p_add">+		if (is_hugetlb_entry_migration(pte)) {</span>
 			spin_unlock(ptl);
 			__migration_entry_wait(mm, (pte_t *)pmd, ptl);
 			goto retry;
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index 39198cb78c6f..6a23ccc46f0f 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -1546,7 +1546,6 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE5(get_mempolicy, int __user *, policy,</span>
 COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode)
 {
<span class="p_del">-	long err = 0;</span>
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	DECLARE_BITMAP(bm, MAX_NUMNODES);
<span class="p_chunk">@@ -1555,14 +1554,13 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,</span>
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
<span class="p_del">-		err = compat_get_bitmap(bm, nmask, nr_bits);</span>
<span class="p_add">+		if (compat_get_bitmap(bm, nmask, nr_bits))</span>
<span class="p_add">+			return -EFAULT;</span>
 		nm = compat_alloc_user_space(alloc_size);
<span class="p_del">-		err |= copy_to_user(nm, bm, alloc_size);</span>
<span class="p_add">+		if (copy_to_user(nm, bm, alloc_size))</span>
<span class="p_add">+			return -EFAULT;</span>
 	}
 
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
 	return sys_set_mempolicy(mode, nm, nr_bits+1);
 }
 
<span class="p_chunk">@@ -1570,7 +1568,6 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,</span>
 		       compat_ulong_t, mode, compat_ulong_t __user *, nmask,
 		       compat_ulong_t, maxnode, compat_ulong_t, flags)
 {
<span class="p_del">-	long err = 0;</span>
 	unsigned long __user *nm = NULL;
 	unsigned long nr_bits, alloc_size;
 	nodemask_t bm;
<span class="p_chunk">@@ -1579,14 +1576,13 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,</span>
 	alloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;
 
 	if (nmask) {
<span class="p_del">-		err = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);</span>
<span class="p_add">+		if (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))</span>
<span class="p_add">+			return -EFAULT;</span>
 		nm = compat_alloc_user_space(alloc_size);
<span class="p_del">-		err |= copy_to_user(nm, nodes_addr(bm), alloc_size);</span>
<span class="p_add">+		if (copy_to_user(nm, nodes_addr(bm), alloc_size))</span>
<span class="p_add">+			return -EFAULT;</span>
 	}
 
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
 	return sys_mbind(start, len, mode, nm, nr_bits+1, flags);
 }
 
<span class="p_header">diff --git a/mm/percpu.c b/mm/percpu.c</span>
<span class="p_header">index 5ae6e0284967..f7da3a3070c4 100644</span>
<span class="p_header">--- a/mm/percpu.c</span>
<span class="p_header">+++ b/mm/percpu.c</span>
<span class="p_chunk">@@ -1012,8 +1012,11 @@</span> <span class="p_context"> area_found:</span>
 		mutex_unlock(&amp;pcpu_alloc_mutex);
 	}
 
<span class="p_del">-	if (chunk != pcpu_reserved_chunk)</span>
<span class="p_add">+	if (chunk != pcpu_reserved_chunk) {</span>
<span class="p_add">+		spin_lock_irqsave(&amp;pcpu_lock, flags);</span>
 		pcpu_nr_empty_pop_pages -= occ_pages;
<span class="p_add">+		spin_unlock_irqrestore(&amp;pcpu_lock, flags);</span>
<span class="p_add">+	}</span>
 
 	if (pcpu_nr_empty_pop_pages &lt; PCPU_EMPTY_POP_PAGES_LOW)
 		pcpu_schedule_balance_work();
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index b1a6ff0a9041..3b3734f81e64 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1420,6 +1420,11 @@</span> <span class="p_context"> static void __sk_free(struct sock *sk)</span>
 		pr_debug(&quot;%s: optmem leakage (%d bytes) detected\n&quot;,
 			 __func__, atomic_read(&amp;sk-&gt;sk_omem_alloc));
 
<span class="p_add">+	if (sk-&gt;sk_frag.page) {</span>
<span class="p_add">+		put_page(sk-&gt;sk_frag.page);</span>
<span class="p_add">+		sk-&gt;sk_frag.page = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (sk-&gt;sk_peer_cred)
 		put_cred(sk-&gt;sk_peer_cred);
 	put_pid(sk-&gt;sk_peer_pid);
<span class="p_chunk">@@ -1524,6 +1529,12 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 			is_charged = sk_filter_charge(newsk, filter);
 
 		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk))) {
<span class="p_add">+			/* We need to make sure that we don&#39;t uncharge the new</span>
<span class="p_add">+			 * socket if we couldn&#39;t charge it in the first place</span>
<span class="p_add">+			 * as otherwise we uncharge the parent&#39;s filter.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!is_charged)</span>
<span class="p_add">+				RCU_INIT_POINTER(newsk-&gt;sk_filter, NULL);</span>
 			/* It is still raw copy of parent, so invalidate
 			 * destructor and make plain sk_free() */
 			newsk-&gt;sk_destruct = NULL;
<span class="p_chunk">@@ -2598,11 +2609,6 @@</span> <span class="p_context"> void sk_common_release(struct sock *sk)</span>
 
 	sk_refcnt_debug_release(sk);
 
<span class="p_del">-	if (sk-&gt;sk_frag.page) {</span>
<span class="p_del">-		put_page(sk-&gt;sk_frag.page);</span>
<span class="p_del">-		sk-&gt;sk_frag.page = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sock_put(sk);
 }
 EXPORT_SYMBOL(sk_common_release);
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index d4c698ce0838..1c77a94c0cbf 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -961,7 +961,8 @@</span> <span class="p_context"> static void nl_fib_input(struct sk_buff *skb)</span>
 
 	net = sock_net(skb-&gt;sk);
 	nlh = nlmsg_hdr(skb);
<span class="p_del">-	if (skb-&gt;len &lt; NLMSG_HDRLEN || skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span>
<span class="p_add">+	if (skb-&gt;len &lt; nlmsg_total_size(sizeof(*frn)) ||</span>
<span class="p_add">+	    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span>
 	    nlmsg_len(nlh) &lt; sizeof(*frn))
 		return;
 
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 737186dbbd74..82632fdb3ef3 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -5293,6 +5293,7 @@</span> <span class="p_context"> void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)</span>
 	struct inet_connection_sock *icsk = inet_csk(sk);
 
 	tcp_set_state(sk, TCP_ESTABLISHED);
<span class="p_add">+	icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 
 	if (skb != NULL) {
 		icsk-&gt;icsk_af_ops-&gt;sk_rx_dst_set(sk, skb);
<span class="p_chunk">@@ -5496,7 +5497,6 @@</span> <span class="p_context"> static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,</span>
 			 * to stand against the temptation 8)     --ANK
 			 */
 			inet_csk_schedule_ack(sk);
<span class="p_del">-			icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 			tcp_enter_quickack_mode(sk);
 			inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
 						  TCP_DELACK_MAX, TCP_RTO_MAX);
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index 2f6667116e85..93b77cc28c2d 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -432,6 +432,7 @@</span> <span class="p_context"> struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,</span>
 		newtp-&gt;srtt_us = 0;
 		newtp-&gt;mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);
 		newicsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;
<span class="p_add">+		newicsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 
 		newtp-&gt;packets_out = 0;
 		newtp-&gt;retrans_out = 0;
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 8d3103459b2d..1f38cb927774 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1731,6 +1731,8 @@</span> <span class="p_context"> static int ip6_route_del(struct fib6_config *cfg)</span>
 				continue;
 			if (cfg-&gt;fc_metric &amp;&amp; cfg-&gt;fc_metric != rt-&gt;rt6i_metric)
 				continue;
<span class="p_add">+			if (cfg-&gt;fc_protocol &amp;&amp; cfg-&gt;fc_protocol != rt-&gt;rt6i_protocol)</span>
<span class="p_add">+				continue;</span>
 			dst_hold(&amp;rt-&gt;dst);
 			read_unlock_bh(&amp;table-&gt;tb6_lock);
 
<span class="p_header">diff --git a/net/sched/act_api.c b/net/sched/act_api.c</span>
<span class="p_header">index 3d43e4979f27..df763d506181 100644</span>
<span class="p_header">--- a/net/sched/act_api.c</span>
<span class="p_header">+++ b/net/sched/act_api.c</span>
<span class="p_chunk">@@ -801,10 +801,8 @@</span> <span class="p_context"> static int tca_action_flush(struct net *net, struct nlattr *nla,</span>
 		goto out_module_put;
 
 	err = a.ops-&gt;walk(skb, &amp;dcb, RTM_DELACTION, &amp;a);
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_add">+	if (err &lt;= 0)</span>
 		goto out_module_put;
<span class="p_del">-	if (err == 0)</span>
<span class="p_del">-		goto noflush_out;</span>
 
 	nla_nest_end(skb, nest);
 
<span class="p_chunk">@@ -821,7 +819,6 @@</span> <span class="p_context"> static int tca_action_flush(struct net *net, struct nlattr *nla,</span>
 out_module_put:
 	module_put(a.ops-&gt;owner);
 err_out:
<span class="p_del">-noflush_out:</span>
 	kfree_skb(skb);
 	return err;
 }
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 1e557ee4cd65..4a737666dbca 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4433,6 +4433,12 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_add">+	/* If there is a thread waiting on more sndbuf space for</span>
<span class="p_add">+	 * sending on this asoc, it cannot be peeled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (waitqueue_active(&amp;asoc-&gt;wait))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
 	/* An association cannot be branched off from an already peeled-off
 	 * socket, nor is this supported for tcp style sockets.
 	 */
<span class="p_chunk">@@ -6965,8 +6971,6 @@</span> <span class="p_context"> static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,</span>
 		 */
 		release_sock(sk);
 		current_timeo = schedule_timeout(current_timeo);
<span class="p_del">-		if (sk != asoc-&gt;base.sk)</span>
<span class="p_del">-			goto do_error;</span>
 		lock_sock(sk);
 
 		*timeo_p = current_timeo;
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index 6247787e4760..58783dcfd35d 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -152,6 +152,7 @@</span> <span class="p_context"> void unix_notinflight(struct file *fp)</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_add">+		BUG_ON(!atomic_long_read(&amp;u-&gt;inflight));</span>
 		BUG_ON(list_empty(&amp;u-&gt;link));
 		if (atomic_long_dec_and_test(&amp;u-&gt;inflight))
 			list_del_init(&amp;u-&gt;link);
<span class="p_chunk">@@ -358,6 +359,14 @@</span> <span class="p_context"> void unix_gc(void)</span>
 	}
 	list_del(&amp;cursor);
 
<span class="p_add">+	/* Now gc_candidates contains only garbage.  Restore original</span>
<span class="p_add">+	 * inflight counters for these as well, and remove the skbuffs</span>
<span class="p_add">+	 * which are creating the cycle(s).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	skb_queue_head_init(&amp;hitlist);</span>
<span class="p_add">+	list_for_each_entry(u, &amp;gc_candidates, link)</span>
<span class="p_add">+		scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span>
<span class="p_add">+</span>
 	/*
 	 * not_cycle_list contains those sockets which do not make up a
 	 * cycle.  Restore these to the inflight list.
<span class="p_chunk">@@ -368,15 +377,6 @@</span> <span class="p_context"> void unix_gc(void)</span>
 		list_move_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now gc_candidates contains only garbage.  Restore original</span>
<span class="p_del">-	 * inflight counters for these as well, and remove the skbuffs</span>
<span class="p_del">-	 * which are creating the cycle(s).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	skb_queue_head_init(&amp;hitlist);</span>
<span class="p_del">-	list_for_each_entry(u, &amp;gc_candidates, link)</span>
<span class="p_del">-	scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span>
<span class="p_del">-</span>
 	spin_unlock(&amp;unix_gc_lock);
 
 	/* Here we are. Hitlist is filled. Die. */
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index a4dabd55e397..4a240416b830 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1921,6 +1921,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,</span>
 	     info.output_pool != client-&gt;pool-&gt;size)) {
 		if (snd_seq_write_pool_allocated(client)) {
 			/* remove all existing cells */
<span class="p_add">+			snd_seq_pool_mark_closing(client-&gt;pool);</span>
 			snd_seq_queue_client_leave_cells(client-&gt;number);
 			snd_seq_pool_done(client-&gt;pool);
 		}
<span class="p_header">diff --git a/sound/core/seq/seq_fifo.c b/sound/core/seq/seq_fifo.c</span>
<span class="p_header">index 1d5acbe0c08b..a2ff0d44fd3b 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_fifo.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_fifo.c</span>
<span class="p_chunk">@@ -70,6 +70,9 @@</span> <span class="p_context"> void snd_seq_fifo_delete(struct snd_seq_fifo **fifo)</span>
 		return;
 	*fifo = NULL;
 
<span class="p_add">+	if (f-&gt;pool)</span>
<span class="p_add">+		snd_seq_pool_mark_closing(f-&gt;pool);</span>
<span class="p_add">+</span>
 	snd_seq_fifo_clear(f);
 
 	/* wake up clients if any */
<span class="p_chunk">@@ -259,6 +262,10 @@</span> <span class="p_context"> int snd_seq_fifo_resize(struct snd_seq_fifo *f, int poolsize)</span>
 	/* NOTE: overflow flag is not cleared */
 	spin_unlock_irqrestore(&amp;f-&gt;lock, flags);
 
<span class="p_add">+	/* close the old pool and wait until all users are gone */</span>
<span class="p_add">+	snd_seq_pool_mark_closing(oldpool);</span>
<span class="p_add">+	snd_use_lock_sync(&amp;f-&gt;use_lock);</span>
<span class="p_add">+</span>
 	/* release cells in old pool */
 	for (cell = oldhead; cell; cell = next) {
 		next = cell-&gt;next;
<span class="p_header">diff --git a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c</span>
<span class="p_header">index c850345c43b5..b855c087cd8a 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.c</span>
<span class="p_chunk">@@ -414,6 +414,18 @@</span> <span class="p_context"> int snd_seq_pool_init(struct snd_seq_pool *pool)</span>
 	return 0;
 }
 
<span class="p_add">+/* refuse the further insertion to the pool */</span>
<span class="p_add">+void snd_seq_pool_mark_closing(struct snd_seq_pool *pool)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (snd_BUG_ON(!pool))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pool-&gt;lock, flags);</span>
<span class="p_add">+	pool-&gt;closing = 1;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* remove events */
 int snd_seq_pool_done(struct snd_seq_pool *pool)
 {
<span class="p_chunk">@@ -425,10 +437,6 @@</span> <span class="p_context"> int snd_seq_pool_done(struct snd_seq_pool *pool)</span>
 		return -EINVAL;
 
 	/* wait for closing all threads */
<span class="p_del">-	spin_lock_irqsave(&amp;pool-&gt;lock, flags);</span>
<span class="p_del">-	pool-&gt;closing = 1;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	if (waitqueue_active(&amp;pool-&gt;output_sleep))
 		wake_up(&amp;pool-&gt;output_sleep);
 
<span class="p_chunk">@@ -491,6 +499,7 @@</span> <span class="p_context"> int snd_seq_pool_delete(struct snd_seq_pool **ppool)</span>
 	*ppool = NULL;
 	if (pool == NULL)
 		return 0;
<span class="p_add">+	snd_seq_pool_mark_closing(pool);</span>
 	snd_seq_pool_done(pool);
 	kfree(pool);
 	return 0;
<span class="p_header">diff --git a/sound/core/seq/seq_memory.h b/sound/core/seq/seq_memory.h</span>
<span class="p_header">index 4a2ec779b8a7..32f959c17786 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.h</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.h</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> static inline int snd_seq_total_cells(struct snd_seq_pool *pool)</span>
 int snd_seq_pool_init(struct snd_seq_pool *pool);
 
 /* done pool - free events */
<span class="p_add">+void snd_seq_pool_mark_closing(struct snd_seq_pool *pool);</span>
 int snd_seq_pool_done(struct snd_seq_pool *pool);
 
 /* create pool */
<span class="p_header">diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c</span>
<span class="p_header">index 5a310caf4bbe..64238c9c5dce 100644</span>
<span class="p_header">--- a/virt/kvm/eventfd.c</span>
<span class="p_header">+++ b/virt/kvm/eventfd.c</span>
<span class="p_chunk">@@ -866,7 +866,8 @@</span> <span class="p_context"> kvm_deassign_ioeventfd_idx(struct kvm *kvm, enum kvm_bus bus_idx,</span>
 			continue;
 
 		kvm_io_bus_unregister_dev(kvm, bus_idx, &amp;p-&gt;dev);
<span class="p_del">-		kvm-&gt;buses[bus_idx]-&gt;ioeventfd_count--;</span>
<span class="p_add">+		if (kvm-&gt;buses[bus_idx])</span>
<span class="p_add">+			kvm-&gt;buses[bus_idx]-&gt;ioeventfd_count--;</span>
 		ioeventfd_release(p);
 		ret = 0;
 		break;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index e013f90f7a29..3d5ae6f655df 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -614,8 +614,11 @@</span> <span class="p_context"> static void kvm_destroy_vm(struct kvm *kvm)</span>
 	list_del(&amp;kvm-&gt;vm_list);
 	spin_unlock(&amp;kvm_lock);
 	kvm_free_irq_routing(kvm);
<span class="p_del">-	for (i = 0; i &lt; KVM_NR_BUSES; i++)</span>
<span class="p_del">-		kvm_io_bus_destroy(kvm-&gt;buses[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; KVM_NR_BUSES; i++) {</span>
<span class="p_add">+		if (kvm-&gt;buses[i])</span>
<span class="p_add">+			kvm_io_bus_destroy(kvm-&gt;buses[i]);</span>
<span class="p_add">+		kvm-&gt;buses[i] = NULL;</span>
<span class="p_add">+	}</span>
 	kvm_coalesced_mmio_free(kvm);
 #if defined(CONFIG_MMU_NOTIFIER) &amp;&amp; defined(KVM_ARCH_WANT_MMU_NOTIFIER)
 	mmu_notifier_unregister(&amp;kvm-&gt;mmu_notifier, kvm-&gt;mm);
<span class="p_chunk">@@ -2978,6 +2981,8 @@</span> <span class="p_context"> int kvm_io_bus_write(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 	};
 
 	bus = srcu_dereference(kvm-&gt;buses[bus_idx], &amp;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	r = __kvm_io_bus_write(bus, &amp;range, val);
 	return r &lt; 0 ? r : 0;
 }
<span class="p_chunk">@@ -2995,6 +3000,8 @@</span> <span class="p_context"> int kvm_io_bus_write_cookie(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 	};
 
 	bus = srcu_dereference(kvm-&gt;buses[bus_idx], &amp;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* First try the device referenced by cookie. */
 	if ((cookie &gt;= 0) &amp;&amp; (cookie &lt; bus-&gt;dev_count) &amp;&amp;
<span class="p_chunk">@@ -3045,6 +3052,8 @@</span> <span class="p_context"> int kvm_io_bus_read(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 	};
 
 	bus = srcu_dereference(kvm-&gt;buses[bus_idx], &amp;kvm-&gt;srcu);
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
 	r = __kvm_io_bus_read(bus, &amp;range, val);
 	return r &lt; 0 ? r : 0;
 }
<span class="p_chunk">@@ -3057,6 +3066,9 @@</span> <span class="p_context"> int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 	struct kvm_io_bus *new_bus, *bus;
 
 	bus = kvm-&gt;buses[bus_idx];
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	/* exclude ioeventfd which is limited by maximum fd */
 	if (bus-&gt;dev_count - bus-&gt;ioeventfd_count &gt; NR_IOBUS_DEVS - 1)
 		return -ENOSPC;
<span class="p_chunk">@@ -3076,37 +3088,41 @@</span> <span class="p_context"> int kvm_io_bus_register_dev(struct kvm *kvm, enum kvm_bus bus_idx, gpa_t addr,</span>
 }
 
 /* Caller must hold slots_lock. */
<span class="p_del">-int kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_del">-			      struct kvm_io_device *dev)</span>
<span class="p_add">+void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,</span>
<span class="p_add">+			       struct kvm_io_device *dev)</span>
 {
<span class="p_del">-	int i, r;</span>
<span class="p_add">+	int i;</span>
 	struct kvm_io_bus *new_bus, *bus;
 
 	bus = kvm-&gt;buses[bus_idx];
<span class="p_del">-	r = -ENOENT;</span>
<span class="p_add">+	if (!bus)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; bus-&gt;dev_count; i++)
 		if (bus-&gt;range[i].dev == dev) {
<span class="p_del">-			r = 0;</span>
 			break;
 		}
 
<span class="p_del">-	if (r)</span>
<span class="p_del">-		return r;</span>
<span class="p_add">+	if (i == bus-&gt;dev_count)</span>
<span class="p_add">+		return;</span>
 
 	new_bus = kzalloc(sizeof(*bus) + ((bus-&gt;dev_count - 1) *
 			  sizeof(struct kvm_io_range)), GFP_KERNEL);
<span class="p_del">-	if (!new_bus)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!new_bus)  {</span>
<span class="p_add">+		pr_err(&quot;kvm: failed to shrink bus, removing it completely\n&quot;);</span>
<span class="p_add">+		goto broken;</span>
<span class="p_add">+	}</span>
 
 	memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));
 	new_bus-&gt;dev_count--;
 	memcpy(new_bus-&gt;range + i, bus-&gt;range + i + 1,
 	       (new_bus-&gt;dev_count - i) * sizeof(struct kvm_io_range));
 
<span class="p_add">+broken:</span>
 	rcu_assign_pointer(kvm-&gt;buses[bus_idx], new_bus);
 	synchronize_srcu_expedited(&amp;kvm-&gt;srcu);
 	kfree(bus);
<span class="p_del">-	return r;</span>
<span class="p_add">+	return;</span>
 }
 
 static struct notifier_block kvm_cpu_notifier = {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



