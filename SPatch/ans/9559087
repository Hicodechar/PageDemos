
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[7/8] fb: hisilicon: Add framebuffer driver for hi3660 SoC - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [7/8] fb: hisilicon: Add framebuffer driver for hi3660 SoC</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=172513">cailiwei</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 7, 2017, 2:35 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170207023559.79455-7-cailiwei@hisilicon.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9559087/mbox/"
   >mbox</a>
|
   <a href="/patch/9559087/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9559087/">/patch/9559087/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AE55960236 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Feb 2017 02:37:53 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7AB7F2236A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Feb 2017 02:37:53 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 4E00227FA8; Tue,  7 Feb 2017 02:37:53 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0C5A727F93
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Feb 2017 02:37:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752811AbdBGChb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 6 Feb 2017 21:37:31 -0500
Received: from szxga02-in.huawei.com ([119.145.14.65]:19478 &quot;EHLO
	szxga02-in.huawei.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752579AbdBGChZ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 6 Feb 2017 21:37:25 -0500
Received: from 172.24.1.136 (EHLO szxeml433-hub.china.huawei.com)
	([172.24.1.136])
	by szxrg02-dlp.huawei.com (MOS 4.3.7-GA FastPath queued)
	with ESMTP id DUE66726; Tue, 07 Feb 2017 10:37:00 +0800 (CST)
Received: from huawei.com (100.106.171.187) by szxeml433-hub.china.huawei.com
	(10.82.67.210) with Microsoft SMTP Server id 14.3.235.1;
	Tue, 7 Feb 2017 10:36:50 +0800
From: cailiwei &lt;cailiwei@hisilicon.com&gt;
To: &lt;linux-fbdev@vger.kernel.org&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	&lt;b.zolnierkie@samsung.com&gt;, &lt;guodong.xu@linaro.org&gt;
CC: &lt;suzhuangluan@hisilicon.com&gt;, &lt;dengqingshan@hisilicon.com&gt;,
	&lt;xuhongtao8@hisilicon.com&gt;, &lt;zhengwanchun@hisilicon.com&gt;,
	&lt;shizongxuan@huawei.com&gt;, &lt;cailiwei@hisilicon.com&gt;
Subject: [PATCH 7/8] fb: hisilicon: Add framebuffer driver for hi3660 SoC
Date: Tue, 7 Feb 2017 10:35:58 +0800
Message-ID: &lt;20170207023559.79455-7-cailiwei@hisilicon.com&gt;
X-Mailer: git-send-email 2.11.1
In-Reply-To: &lt;20170207023559.79455-1-cailiwei@hisilicon.com&gt;
References: &lt;20170207023559.79455-1-cailiwei@hisilicon.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [100.106.171.187]
X-CFilter-Loop: Reflected
X-Mirapoint-Virus-RAPID-Raw: score=unknown(0),
	refid=str=0001.0A020201.589932CD.0114, ss=1, re=0.000, recu=0.000,
	reip=0.000, cl=1, cld=1, fgs=0, ip=0.0.0.0,
	so=2013-06-18 04:22:30, dmn=2013-03-21 17:37:32
X-Mirapoint-Loop-Id: 3bc359a30bc5c8cca416397d27813765
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=172513">cailiwei</a> - Feb. 7, 2017, 2:35 a.m.</div>
<pre class="content">
<span class="from">From: Levy-Cai &lt;cailiwei@hisilicon.com&gt;</span>

Add framebuffer driver for hi3660 SoC, this driver include lcd
driver &amp; Hdmi adv7533/adv7535 driver, support lcd display at
1080p@60 and hdmi display at 1080p@60.
<span class="signed-off-by">
Signed-off-by: cailiwei &lt;cailiwei@hisilicon.com&gt;</span>
---
 drivers/video/fbdev/hisi/dss/hisi_overlay_online.c |  733 ++
 drivers/video/fbdev/hisi/dss/hisi_overlay_utils.c  | 8495 ++++++++++++++++++++
 drivers/video/fbdev/hisi/dss/hisi_overlay_utils.h  |  269 +
 .../fbdev/hisi/dss/hisi_overlay_utils_hi3660.c     | 2741 +++++++
 .../fbdev/hisi/dss/hisi_overlay_utils_hi3660.h     |   73 +
 5 files changed, 12311 insertions(+)
 create mode 100755 drivers/video/fbdev/hisi/dss/hisi_overlay_online.c
 create mode 100755 drivers/video/fbdev/hisi/dss/hisi_overlay_utils.c
 create mode 100755 drivers/video/fbdev/hisi/dss/hisi_overlay_utils.h
 create mode 100755 drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.c
 create mode 100755 drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.h
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/video/fbdev/hisi/dss/hisi_overlay_online.c b/drivers/video/fbdev/hisi/dss/hisi_overlay_online.c</span>
new file mode 100755
<span class="p_header">index 000000000000..9cb65225dc63</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/video/fbdev/hisi/dss/hisi_overlay_online.c</span>
<span class="p_chunk">@@ -0,0 +1,733 @@</span> <span class="p_context"></span>
<span class="p_add">+/* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 and</span>
<span class="p_add">+ * only version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;hisi_overlay_utils.h&quot;</span>
<span class="p_add">+#include &quot;hisi_dpe_utils.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_get_ov_data_from_user(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      dss_overlay_t *pov_req,</span>
<span class="p_add">+				      void __user *argp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == argp) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;user data is invalid\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pov_h_block_infos = hisifd-&gt;ov_block_infos;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = copy_from_user(pov_req, argp, sizeof(dss_overlay_t));</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, copy_from_user failed!\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;ov_block_nums &lt;= 0) ||</span>
<span class="p_add">+	    (pov_req-&gt;ov_block_nums &gt; HISI_DSS_OV_BLOCK_NUMS)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, ov_block_nums(%d) is out of range!\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, pov_req-&gt;ov_block_nums);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    copy_from_user(pov_h_block_infos,</span>
<span class="p_add">+			   (dss_overlay_block_t *) pov_req-&gt;ov_block_infos_ptr,</span>
<span class="p_add">+			   pov_req-&gt;ov_block_nums *</span>
<span class="p_add">+			   sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, dss_overlay_block_t copy_from_user failed!\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_check_userdata(hisifd, pov_req, pov_h_block_infos);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_check_userdata failed!\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req-&gt;ov_block_infos_ptr = (uint64_t) pov_h_block_infos;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_pan_display(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	struct fb_info *fbi = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	dss_rect_ltrb_t clip_rect;</span>
<span class="p_add">+	dss_rect_t aligned_rect;</span>
<span class="p_add">+	bool rdma_stretch_enable = false;</span>
<span class="p_add">+	uint32_t offset = 0;</span>
<span class="p_add">+	uint32_t addr = 0;</span>
<span class="p_add">+	int hal_format = 0;</span>
<span class="p_add">+	uint32_t cmdlist_pre_idxs = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs = 0;</span>
<span class="p_add">+	int enable_cmdlist = 0;</span>
<span class="p_add">+	bool has_base = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == hisifd) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi fd is invalid\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	fbi = hisifd-&gt;fbi;</span>
<span class="p_add">+	if (NULL == fbi) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisifd fbi is invalid\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req = &amp;(hisifd-&gt;ov_req);</span>
<span class="p_add">+	pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hisifd-&gt;panel_power_on) {</span>
<span class="p_add">+		HISI_FB_INFO(&quot;fb%d, panel is power off!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ldi_underflow) {</span>
<span class="p_add">+		if (g_err_status &amp;</span>
<span class="p_add">+		    (DSS_PDP_LDI_UNDERFLOW | DSS_SDP_LDI_UNDERFLOW))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	offset = fbi-&gt;var.xoffset * (fbi-&gt;var.bits_per_pixel &gt;&gt; 3) +</span>
<span class="p_add">+	    fbi-&gt;var.yoffset * fbi-&gt;fix.line_length;</span>
<span class="p_add">+	addr = fbi-&gt;fix.smem_start + offset;</span>
<span class="p_add">+	if (!fbi-&gt;fix.smem_start) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, smem_start is null!\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fbi-&gt;fix.smem_len &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, smem_len(%d) is out of range!\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, fbi-&gt;fix.smem_len);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hal_format = hisi_get_hal_format(fbi);</span>
<span class="p_add">+	if (hal_format &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not support this fb_info&#39;s format!\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_cmdlist = g_enable_ovl_cmdlist_online;</span>
<span class="p_add">+	if ((hisifd-&gt;index == EXTERNAL_PANEL_IDX)</span>
<span class="p_add">+	    &amp;&amp; hisifd-&gt;panel_info.fake_hdmi)</span>
<span class="p_add">+		enable_cmdlist = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_activate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_vactive0_start_config(hisifd, pov_req);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, hisi_vactive0_start_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer == 1) {</span>
<span class="p_add">+		dumpDssOverlay(hisifd, pov_req, false);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(pov_req, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+	pov_req-&gt;ov_block_infos_ptr = (uint64_t) (&amp;(hisifd-&gt;ov_block_infos));</span>
<span class="p_add">+	pov_req-&gt;ov_block_nums = 1;</span>
<span class="p_add">+	pov_req-&gt;ovl_idx = DSS_OVL0;</span>
<span class="p_add">+	pov_req-&gt;dirty_rect.x = 0;</span>
<span class="p_add">+	pov_req-&gt;dirty_rect.y = 0;</span>
<span class="p_add">+	pov_req-&gt;dirty_rect.w = fbi-&gt;var.xres;</span>
<span class="p_add">+	pov_req-&gt;dirty_rect.h = fbi-&gt;var.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req-&gt;res_updt_rect.x = 0;</span>
<span class="p_add">+	pov_req-&gt;res_updt_rect.y = 0;</span>
<span class="p_add">+	pov_req-&gt;res_updt_rect.w = fbi-&gt;var.xres;</span>
<span class="p_add">+	pov_req-&gt;res_updt_rect.h = fbi-&gt;var.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_h_block_infos =</span>
<span class="p_add">+	    (dss_overlay_block_t *) (pov_req-&gt;ov_block_infos_ptr);</span>
<span class="p_add">+	pov_h_block = &amp;(pov_h_block_infos[0]);</span>
<span class="p_add">+	pov_h_block-&gt;layer_nums = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	layer = &amp;(pov_h_block-&gt;layer_infos[0]);</span>
<span class="p_add">+	layer-&gt;img.format = hal_format;</span>
<span class="p_add">+	layer-&gt;img.width = fbi-&gt;var.xres;</span>
<span class="p_add">+	layer-&gt;img.height = fbi-&gt;var.yres;</span>
<span class="p_add">+	layer-&gt;img.bpp = fbi-&gt;var.bits_per_pixel &gt;&gt; 3;</span>
<span class="p_add">+	layer-&gt;img.stride = fbi-&gt;fix.line_length;</span>
<span class="p_add">+	layer-&gt;img.buf_size = layer-&gt;img.stride * layer-&gt;img.height;</span>
<span class="p_add">+	layer-&gt;img.phy_addr = addr;</span>
<span class="p_add">+	layer-&gt;img.vir_addr = addr;</span>
<span class="p_add">+	layer-&gt;img.mmu_enable = 1;</span>
<span class="p_add">+	layer-&gt;src_rect.x = 0;</span>
<span class="p_add">+	layer-&gt;src_rect.y = 0;</span>
<span class="p_add">+	layer-&gt;src_rect.w = fbi-&gt;var.xres;</span>
<span class="p_add">+	layer-&gt;src_rect.h = fbi-&gt;var.yres;</span>
<span class="p_add">+	layer-&gt;dst_rect.x = 0;</span>
<span class="p_add">+	layer-&gt;dst_rect.y = 0;</span>
<span class="p_add">+	layer-&gt;dst_rect.w = fbi-&gt;var.xres;</span>
<span class="p_add">+	layer-&gt;dst_rect.h = fbi-&gt;var.yres;</span>
<span class="p_add">+	layer-&gt;transform = HISI_FB_TRANSFORM_NOP;</span>
<span class="p_add">+	layer-&gt;blending = HISI_FB_BLENDING_NONE;</span>
<span class="p_add">+	layer-&gt;glb_alpha = 0xFF;</span>
<span class="p_add">+	layer-&gt;color = 0x0;</span>
<span class="p_add">+	layer-&gt;layer_idx = 0x0;</span>
<span class="p_add">+	layer-&gt;chn_idx = DSS_RCHN_D2;</span>
<span class="p_add">+	layer-&gt;need_cap = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_handle_cur_ovl_req(hisifd, pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_module_init(hisifd);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_module_init failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_mmbuf_info_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_cmdlist_data_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev,</span>
<span class="p_add">+						  &amp;cmdlist_pre_idxs, NULL);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs pov_req_prev failed! &quot;</span>
<span class="p_add">+			     &quot;ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_get_cmdlist_idxs(pov_req, &amp;cmdlist_pre_idxs,</span>
<span class="p_add">+						  &amp;cmdlist_idxs);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs pov_req failed! &quot;</span>
<span class="p_add">+			     &quot;ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_pre_idxs, 0, 0);</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs, 0, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_dss_mctl_mutex_lock(hisifd, pov_req-&gt;ovl_idx);</span>
<span class="p_add">+		cmdlist_pre_idxs = ~0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_prev_module_set_regs(hisifd, pov_req_prev, cmdlist_pre_idxs,</span>
<span class="p_add">+				      enable_cmdlist, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_aif_handler(hisifd, pov_req, pov_h_block);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_ovl_base_config(hisifd, pov_req, NULL, NULL,</span>
<span class="p_add">+				     pov_req-&gt;ovl_idx, 0);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_ovl_init failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_ov_compose_handler(hisifd, pov_req, pov_h_block, layer, NULL,</span>
<span class="p_add">+				    NULL, &amp;clip_rect, &amp;aligned_rect,</span>
<span class="p_add">+				    &amp;rdma_stretch_enable, &amp;has_base, true,</span>
<span class="p_add">+				    enable_cmdlist);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_ov_compose_handler failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_mctl_ov_config(hisifd, pov_req, pov_req-&gt;ovl_idx, has_base,</span>
<span class="p_add">+				    true);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_mctl_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+		ret = hisi_dss_dirty_region_dbuf_config(hisifd, pov_req);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_dirty_region_dbuf_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_post_scf_config(hisifd, pov_req);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_post_scf_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_ov_module_set_regs(hisifd, pov_req, pov_req-&gt;ovl_idx,</span>
<span class="p_add">+					enable_cmdlist, 0, 0, true);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_module_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisi_dss_unflow_handler(hisifd, pov_req, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs, 0, 0);</span>
<span class="p_add">+		hisi_cmdlist_config_stop(hisifd, cmdlist_pre_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+		cmdlist_idxs |= cmdlist_pre_idxs;</span>
<span class="p_add">+		hisi_cmdlist_flush_cache(hisifd, hisifd-&gt;ion_client,</span>
<span class="p_add">+					 cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_debug_ovl_cmdlist) {</span>
<span class="p_add">+			hisi_cmdlist_dump_all_node(hisifd, NULL, cmdlist_idxs);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_cmdlist_config_start(hisifd, pov_req-&gt;ovl_idx,</span>
<span class="p_add">+					  cmdlist_idxs, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisi_dss_mctl_mutex_unlock(hisifd, pov_req-&gt;ovl_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+		hisi_dss_dirty_region_updt_config(hisifd, pov_req);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	single_frame_update(hisifd);</span>
<span class="p_add">+	hisifb_frame_updated(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;frame_count++;</span>
<span class="p_add">+	memcpy(&amp;hisifd-&gt;ov_req_prev_prev, &amp;hisifd-&gt;ov_req_prev,</span>
<span class="p_add">+	       sizeof(dss_overlay_t));</span>
<span class="p_add">+	memcpy(&amp;(hisifd-&gt;ov_block_infos_prev_prev),</span>
<span class="p_add">+	       &amp;(hisifd-&gt;ov_block_infos_prev),</span>
<span class="p_add">+	       hisifd-&gt;ov_req_prev.ov_block_nums * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	hisifd-&gt;ov_req_prev_prev.ov_block_infos_ptr =</span>
<span class="p_add">+	    (uint64_t) (&amp;(hisifd-&gt;ov_block_infos_prev_prev));</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;hisifd-&gt;ov_req_prev, pov_req, sizeof(dss_overlay_t));</span>
<span class="p_add">+	memcpy(&amp;(hisifd-&gt;ov_block_infos_prev), &amp;(hisifd-&gt;ov_block_infos),</span>
<span class="p_add">+	       pov_req-&gt;ov_block_nums * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	hisifd-&gt;ov_req_prev.ov_block_infos_ptr =</span>
<span class="p_add">+	    (uint64_t) (&amp;(hisifd-&gt;ov_block_infos_prev));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+		hisifd-&gt;vactive0_start_flag = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		single_frame_update(hisifd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_ov_online_play(struct hisi_fb_data_type *hisifd, void __user *argp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int dss_free_buffer_refcount;</span>
<span class="p_add">+	dss_overlay_t *pov_req = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	dss_rect_ltrb_t clip_rect;</span>
<span class="p_add">+	dss_rect_t aligned_rect;</span>
<span class="p_add">+	bool rdma_stretch_enable = false;</span>
<span class="p_add">+	uint32_t cmdlist_pre_idxs = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs = 0;</span>
<span class="p_add">+	int enable_cmdlist = 0;</span>
<span class="p_add">+	bool has_base = false;</span>
<span class="p_add">+#ifdef CONFIG_BUF_SYNC_USED</span>
<span class="p_add">+	unsigned long flags = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	int need_skip = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int m = 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t timediff = 0;</span>
<span class="p_add">+	struct list_head lock_list;</span>
<span class="p_add">+	struct timeval tv0;</span>
<span class="p_add">+	struct timeval tv1;</span>
<span class="p_add">+	struct timeval tv2;</span>
<span class="p_add">+	struct timeval tv3;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == hisifd) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;NULL Pointer!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == argp) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;NULL Pointer!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req = &amp;(hisifd-&gt;ov_req);</span>
<span class="p_add">+	pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;lock_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hisifd-&gt;panel_power_on) {</span>
<span class="p_add">+		HISI_FB_INFO(&quot;fb%d, panel is power off!\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer_return) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer_timediff &amp; 0x2) {</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_cmdlist = g_enable_ovl_cmdlist_online;</span>
<span class="p_add">+	if ((hisifd-&gt;index == EXTERNAL_PANEL_IDX)</span>
<span class="p_add">+	    &amp;&amp; hisifd-&gt;panel_info.fake_hdmi) {</span>
<span class="p_add">+		enable_cmdlist = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_activate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer_timediff &amp; 0x4) {</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv2);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_get_ov_data_from_user(hisifd, pov_req, argp);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_get_ov_data_from_user failed! ret=%d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		need_skip = 1;</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#ifdef CONFIG_BUF_SYNC_USED</span>
<span class="p_add">+	if (is_mipi_video_panel(hisifd)) {</span>
<span class="p_add">+		ret = hisifb_buf_sync_handle(hisifd, pov_req);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisifb_buf_sync_handle failed! ret=%d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			need_skip = 1;</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_vactive0_start_config(hisifd, pov_req);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_vactive0_start_config failed! ret=%d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		need_skip = 1;</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	down(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer_timediff &amp; 0x4) {</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv3);</span>
<span class="p_add">+		timediff = hisifb_timestamp_diff(&amp;tv2, &amp;tv3);</span>
<span class="p_add">+		if (timediff &gt;= g_debug_ovl_online_composer_time_threshold)</span>
<span class="p_add">+			HISI_FB_ERR(&quot;ONLINE_VACTIVE_TIMEDIFF is %u us!\n&quot;,</span>
<span class="p_add">+				    timediff);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer == 1) {</span>
<span class="p_add">+		dumpDssOverlay(hisifd, pov_req, false);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisifb_layerbuf_lock(hisifd, pov_req, &amp;lock_list);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisifb_layerbuf_lock failed! ret=%d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_handle_cur_ovl_req(hisifd, pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_module_init(hisifd);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_dss_module_init failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisi_mmbuf_info_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+		hisi_cmdlist_data_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev,</span>
<span class="p_add">+						  &amp;cmdlist_pre_idxs, NULL);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs pov_req_prev failed! &quot;</span>
<span class="p_add">+			     &quot;ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_get_cmdlist_idxs(pov_req, &amp;cmdlist_pre_idxs,</span>
<span class="p_add">+						  &amp;cmdlist_idxs);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs pov_req failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_pre_idxs, 0, 0);</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs, 0, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+		hisi_dss_mctl_mutex_lock(hisifd, pov_req-&gt;ovl_idx);</span>
<span class="p_add">+		cmdlist_pre_idxs = ~0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_prev_module_set_regs(hisifd, pov_req_prev, cmdlist_pre_idxs,</span>
<span class="p_add">+				      enable_cmdlist, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_h_block_infos =</span>
<span class="p_add">+	    (dss_overlay_block_t *) (pov_req-&gt;ov_block_infos_ptr);</span>
<span class="p_add">+	for (m = 0; m &lt; pov_req-&gt;ov_block_nums; m++) {</span>
<span class="p_add">+		pov_h_block = &amp;(pov_h_block_infos[m]);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = hisi_dss_module_init(hisifd);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_module_init failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		hisi_dss_aif_handler(hisifd, pov_req, pov_h_block);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ovl_base_config(hisifd, pov_req, pov_h_block, NULL,</span>
<span class="p_add">+					     pov_req-&gt;ovl_idx, m);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_ovl_init failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; pov_h_block-&gt;layer_nums; i++) {</span>
<span class="p_add">+			layer = &amp;(pov_h_block-&gt;layer_infos[i]);</span>
<span class="p_add">+			memset(&amp;clip_rect, 0, sizeof(dss_rect_ltrb_t));</span>
<span class="p_add">+			memset(&amp;aligned_rect, 0, sizeof(dss_rect_ltrb_t));</span>
<span class="p_add">+			rdma_stretch_enable = false;</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_ov_compose_handler(hisifd, pov_req,</span>
<span class="p_add">+						    pov_h_block, layer, NULL,</span>
<span class="p_add">+						    NULL, &amp;clip_rect,</span>
<span class="p_add">+						    &amp;aligned_rect,</span>
<span class="p_add">+						    &amp;rdma_stretch_enable,</span>
<span class="p_add">+						    &amp;has_base, true,</span>
<span class="p_add">+						    enable_cmdlist);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, hisi_ov_compose_handler failed! ret = %d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_return;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_mctl_ov_config(hisifd, pov_req, pov_req-&gt;ovl_idx,</span>
<span class="p_add">+					    has_base, (m == 0));</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_mctl_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (m == 0) {</span>
<span class="p_add">+			if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+				ret =</span>
<span class="p_add">+				    hisi_dss_dirty_region_dbuf_config(hisifd, pov_req);</span>
<span class="p_add">+				if (ret != 0) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, hisi_dss_dirty_region_dbuf_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, ret);</span>
<span class="p_add">+					goto err_return;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = hisi_dss_post_scf_config(hisifd, pov_req);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_post_scf_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ov_module_set_regs(hisifd, pov_req,</span>
<span class="p_add">+						pov_req-&gt;ovl_idx,</span>
<span class="p_add">+						enable_cmdlist, 0, 0, (m == 0));</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_module_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		g_online_cmdlist_idxs |= cmdlist_idxs;</span>
<span class="p_add">+		hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs, 0, 0);</span>
<span class="p_add">+		hisi_cmdlist_config_stop(hisifd, cmdlist_pre_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+		cmdlist_idxs |= cmdlist_pre_idxs;</span>
<span class="p_add">+		hisi_cmdlist_flush_cache(hisifd, hisifd-&gt;ion_client,</span>
<span class="p_add">+					 cmdlist_idxs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_crc_enable(hisifd, pov_req);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, hisi_crc_enable failed!\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisi_dss_unflow_handler(hisifd, pov_req, true);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BUF_SYNC_USED</span>
<span class="p_add">+	if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+		ret = hisifb_buf_sync_handle(hisifd, pov_req);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisifb_buf_sync_handle failed! ret=%d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req-&gt;release_fence =</span>
<span class="p_add">+	    hisifb_buf_sync_create_fence(hisifd,</span>
<span class="p_add">+					 ++hisifd-&gt;buf_sync_ctrl.timeline_max);</span>
<span class="p_add">+	if (pov_req-&gt;release_fence &lt; 0) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;fb%d, hisi_create_fence failed! pov_req-&gt;release_fence = 0x%x\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, pov_req-&gt;release_fence);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;hisifd-&gt;buf_sync_ctrl.refresh_lock, flags);</span>
<span class="p_add">+	hisifd-&gt;buf_sync_ctrl.refresh++;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;hisifd-&gt;buf_sync_ctrl.refresh_lock, flags);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		hisi_cmdlist_config_start(hisifd, pov_req-&gt;ovl_idx,</span>
<span class="p_add">+					  cmdlist_idxs, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisi_dss_mctl_mutex_unlock(hisifd, pov_req-&gt;ovl_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+		hisi_dss_dirty_region_updt_config(hisifd, pov_req);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	single_frame_update(hisifd);</span>
<span class="p_add">+	hisifb_frame_updated(hisifd);</span>
<span class="p_add">+	hisi_crc_config(hisifd, pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_to_user((struct dss_overlay_t __user *)argp,</span>
<span class="p_add">+			 pov_req, sizeof(dss_overlay_t))) {</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;release_fence &gt;= 0)</span>
<span class="p_add">+			put_unused_fd(pov_req-&gt;release_fence);</span>
<span class="p_add">+</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+	hisifb_layerbuf_flush(hisifd, &amp;lock_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index == PRIMARY_PANEL_IDX)</span>
<span class="p_add">+	    &amp;&amp; (dss_free_buffer_refcount &gt; 1)) {</span>
<span class="p_add">+		if (!hisifd-&gt;fb_mem_free_flag) {</span>
<span class="p_add">+			hisifb_free_fb_buffer(hisifd);</span>
<span class="p_add">+			hisifd-&gt;fb_mem_free_flag = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer == 2) {</span>
<span class="p_add">+		dumpDssOverlay(hisifd, pov_req, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_cmdlist &amp;&amp; enable_cmdlist)</span>
<span class="p_add">+		hisi_cmdlist_dump_all_node(hisifd, NULL, cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;frame_count++;</span>
<span class="p_add">+	dss_free_buffer_refcount++;</span>
<span class="p_add">+	memcpy(&amp;hisifd-&gt;ov_req_prev_prev, &amp;hisifd-&gt;ov_req_prev,</span>
<span class="p_add">+	       sizeof(dss_overlay_t));</span>
<span class="p_add">+	memcpy(&amp;(hisifd-&gt;ov_block_infos_prev_prev),</span>
<span class="p_add">+	       &amp;(hisifd-&gt;ov_block_infos_prev),</span>
<span class="p_add">+	       hisifd-&gt;ov_req_prev.ov_block_nums * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	hisifd-&gt;ov_req_prev_prev.ov_block_infos_ptr =</span>
<span class="p_add">+	    (uint64_t) (&amp;(hisifd-&gt;ov_block_infos_prev_prev));</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;hisifd-&gt;ov_req_prev, pov_req, sizeof(dss_overlay_t));</span>
<span class="p_add">+	memcpy(&amp;(hisifd-&gt;ov_block_infos_prev), &amp;(hisifd-&gt;ov_block_infos),</span>
<span class="p_add">+	       pov_req-&gt;ov_block_nums * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	hisifd-&gt;ov_req_prev.ov_block_infos_ptr =</span>
<span class="p_add">+	    (uint64_t) (&amp;(hisifd-&gt;ov_block_infos_prev));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer_timediff &amp; 0x2) {</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv1);</span>
<span class="p_add">+		timediff = hisifb_timestamp_diff(&amp;tv0, &amp;tv1);</span>
<span class="p_add">+		if (timediff &gt;= g_debug_ovl_online_composer_time_threshold)</span>
<span class="p_add">+			HISI_FB_ERR(&quot;ONLINE_TIMEDIFF is %u us!\n&quot;, timediff);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	up(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+		hisifd-&gt;vactive0_start_flag = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisifb_layerbuf_lock_exception(hisifd, &amp;lock_list);</span>
<span class="p_add">+	hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+	if (!need_skip) {</span>
<span class="p_add">+		up(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.c b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.c</span>
new file mode 100755
<span class="p_header">index 000000000000..97d71df5a38d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.c</span>
<span class="p_chunk">@@ -0,0 +1,8495 @@</span> <span class="p_context"></span>
<span class="p_add">+/* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 and</span>
<span class="p_add">+ * only version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+/*lint -e778 -e732*/</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;hisi_overlay_utils.h&quot;</span>
<span class="p_add">+#include &quot;hisi_dpe_utils.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define SMMU_RW_ERR_ADDR_SIZE	(128)</span>
<span class="p_add">+</span>
<span class="p_add">+/* mmbuf gen pool */</span>
<span class="p_add">+static struct gen_pool *g_mmbuf_gen_pool = NULL;</span>
<span class="p_add">+static dss_mmbuf_t g_pre_online_mmbuf[DSS_CHN_MAX_DEFINE] = { {0, 0} };</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t vactive_timeout_count = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool hisi_dss_is_sharpness_support(int32_t width, int32_t height)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ((16 &lt;= width) &amp;&amp; (width &lt;= 1600) &amp;&amp; (4 &lt;= height)</span>
<span class="p_add">+		&amp;&amp; (height &lt;= 2560));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int32_t hisi_transform2degree(uint32_t transform)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (transform) {</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_ROT_90:</span>
<span class="p_add">+		ret = 90;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+		ret = 180;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_ROT_270:</span>
<span class="p_add">+		ret = 270;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support transform(%d)!&quot;, transform);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define DUMP_BUF_SIZE	SZ_256K</span>
<span class="p_add">+</span>
<span class="p_add">+struct dss_dump_data_type {</span>
<span class="p_add">+	char *dss_buf;</span>
<span class="p_add">+	uint32_t dss_buf_len;</span>
<span class="p_add">+	char dss_filename[256];</span>
<span class="p_add">+</span>
<span class="p_add">+	char *scene_buf;</span>
<span class="p_add">+	uint32_t scene_buf_len;</span>
<span class="p_add">+	char scene_filename[256];</span>
<span class="p_add">+</span>
<span class="p_add">+	char image_bin_filename[MAX_DSS_SRC_NUM][256];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void dumpDssOverlay(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req,</span>
<span class="p_add">+		    bool isNeedSaveFile)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t i = 0;</span>
<span class="p_add">+	uint32_t k = 0;</span>
<span class="p_add">+	dss_layer_t const *layer = NULL;</span>
<span class="p_add">+	dss_wb_layer_t const *wb_layer = NULL;</span>
<span class="p_add">+	struct timeval tv;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_block_info = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct dss_dump_data_type *dumpDss = NULL;</span>
<span class="p_add">+	char *image_src_addr = NULL;</span>
<span class="p_add">+	struct ion_handle *ionhnd = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	static const char *const layer_format[] = {</span>
<span class="p_add">+		&quot;RGB565&quot;, &quot;RGBX4444&quot;, &quot;RGBA4444&quot;, &quot;RGBX5551&quot;, &quot;RGBA5551&quot;,</span>
<span class="p_add">+		    &quot;RGBX8888&quot;, &quot;RGBA8888&quot;,</span>
<span class="p_add">+		&quot;BGR565&quot;, &quot;BGRX4444&quot;, &quot;BGRA4444&quot;, &quot;BGRX5551&quot;, &quot;BGRA5551&quot;,</span>
<span class="p_add">+		    &quot;BGRX8888&quot;, &quot;BGRA8888&quot;,</span>
<span class="p_add">+		&quot;YCbYCr&quot;, &quot;&quot;, &quot;&quot;, &quot;NV12&quot;, &quot;NV21&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;YV12&quot;, &quot;&quot;, &quot;&quot;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON((pov_req-&gt;ovl_idx &lt; DSS_OVL0)</span>
<span class="p_add">+	       || (pov_req-&gt;ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	dumpDss = kmalloc(sizeof(struct dss_dump_data_type), GFP_KERNEL);</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(dumpDss)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;alloc dumpDss failed!\n&quot;);</span>
<span class="p_add">+		goto alloc_dump_dss_data_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(dumpDss, 0, sizeof(struct dss_dump_data_type));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (isNeedSaveFile) {</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv);</span>
<span class="p_add">+		snprintf(dumpDss-&gt;scene_filename,</span>
<span class="p_add">+			 sizeof(dumpDss-&gt;scene_filename),</span>
<span class="p_add">+			 &quot;/data/dssdump/Scene_%ld.sce&quot;, tv.tv_sec);</span>
<span class="p_add">+		snprintf(dumpDss-&gt;dss_filename, sizeof(dumpDss-&gt;dss_filename),</span>
<span class="p_add">+			 &quot;/data/dssdump/Dss_%ld.txt&quot;, tv.tv_sec);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+		dumpDss-&gt;scene_buf_len = 0;</span>
<span class="p_add">+		dumpDss-&gt;scene_buf = kmalloc(DUMP_BUF_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		if (IS_ERR_OR_NULL(dumpDss-&gt;scene_buf)) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;alloc scene_buf failed!\n&quot;);</span>
<span class="p_add">+			goto alloc_scene_buf_err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		memset(dumpDss-&gt;scene_buf, 0, DUMP_BUF_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dumpDss-&gt;dss_buf_len = 0;</span>
<span class="p_add">+	dumpDss-&gt;dss_buf = kmalloc(DUMP_BUF_SIZE, GFP_KERNEL);</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(dumpDss-&gt;dss_buf)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;alloc dss_buf failed!\n&quot;);</span>
<span class="p_add">+		goto alloc_dss_buf_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(dumpDss-&gt;dss_buf, 0, DUMP_BUF_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	dumpDss-&gt;dss_buf_len +=</span>
<span class="p_add">+	    snprintf(dumpDss-&gt;dss_buf + dumpDss-&gt;dss_buf_len, 4 * SZ_1K,</span>
<span class="p_add">+		     &quot;\n\n----------------------------&lt;dump begin&gt;----------------------------\n&quot;</span>
<span class="p_add">+		     &quot;frame_no=%d\n&quot; &quot;ovl_idx=%d\n&quot;</span>
<span class="p_add">+		     &quot;res_updt_rect(%d, %d, %d, %d)\n&quot;</span>
<span class="p_add">+		     &quot;dirty_rect(%d,%d, %d,%d)\n&quot; &quot;release_fence=%d\n&quot;</span>
<span class="p_add">+		     &quot;crc_enable_status=%d\n&quot; &quot;crc_info(%d,%d)\n&quot;</span>
<span class="p_add">+		     &quot;ov_block_nums=%d\n&quot; &quot;ov_block_infos_ptr=0x%llx\n&quot;</span>
<span class="p_add">+		     &quot;wb_enable=%d\n&quot; &quot;wb_layer_nums=%d\n&quot;</span>
<span class="p_add">+		     &quot;wb_ov_rect(%d,%d, %d,%d)\n&quot;, pov_req-&gt;frame_no,</span>
<span class="p_add">+		     pov_req-&gt;ovl_idx, pov_req-&gt;res_updt_rect.x,</span>
<span class="p_add">+		     pov_req-&gt;res_updt_rect.y, pov_req-&gt;res_updt_rect.w,</span>
<span class="p_add">+		     pov_req-&gt;res_updt_rect.h, pov_req-&gt;dirty_rect.x,</span>
<span class="p_add">+		     pov_req-&gt;dirty_rect.y, pov_req-&gt;dirty_rect.w,</span>
<span class="p_add">+		     pov_req-&gt;dirty_rect.h, pov_req-&gt;release_fence,</span>
<span class="p_add">+		     pov_req-&gt;crc_enable_status,</span>
<span class="p_add">+		     pov_req-&gt;crc_info.crc_ov_result,</span>
<span class="p_add">+		     pov_req-&gt;crc_info.err_status, pov_req-&gt;ov_block_nums,</span>
<span class="p_add">+		     pov_req-&gt;ov_block_infos_ptr, pov_req-&gt;wb_enable,</span>
<span class="p_add">+		     pov_req-&gt;wb_layer_nums, pov_req-&gt;wb_ov_rect.x,</span>
<span class="p_add">+		     pov_req-&gt;wb_ov_rect.y, pov_req-&gt;wb_ov_rect.w,</span>
<span class="p_add">+		     pov_req-&gt;wb_ov_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; pov_req-&gt;ov_block_nums; i++) {</span>
<span class="p_add">+		pov_h_block_infos =</span>
<span class="p_add">+		    (dss_overlay_block_t *) (pov_req-&gt;ov_block_infos_ptr);</span>
<span class="p_add">+		pov_block_info = &amp;(pov_h_block_infos[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		dumpDss-&gt;dss_buf_len +=</span>
<span class="p_add">+		    snprintf(dumpDss-&gt;dss_buf + dumpDss-&gt;dss_buf_len, 4 * SZ_1K,</span>
<span class="p_add">+			     &quot;\nov_block_rect(%d,%d, %d,%d)\n&quot;</span>
<span class="p_add">+			     &quot;layer_nums=%d\n&quot;, pov_block_info-&gt;ov_block_rect.x,</span>
<span class="p_add">+			     pov_block_info-&gt;ov_block_rect.y,</span>
<span class="p_add">+			     pov_block_info-&gt;ov_block_rect.w,</span>
<span class="p_add">+			     pov_block_info-&gt;ov_block_rect.h,</span>
<span class="p_add">+			     pov_block_info-&gt;layer_nums);</span>
<span class="p_add">+</span>
<span class="p_add">+		for (k = 0; k &lt; pov_block_info-&gt;layer_nums; k++) {</span>
<span class="p_add">+			layer = &amp;(pov_block_info-&gt;layer_infos[k]);</span>
<span class="p_add">+</span>
<span class="p_add">+			dumpDss-&gt;dss_buf_len +=</span>
<span class="p_add">+			    snprintf(dumpDss-&gt;dss_buf + dumpDss-&gt;dss_buf_len,</span>
<span class="p_add">+				     4 * SZ_1K,</span>
<span class="p_add">+				     &quot;\nLayerInfo[%d]:\n&quot; &quot;format=%d\n&quot;</span>
<span class="p_add">+				     &quot;width=%d\n&quot; &quot;height=%d\n&quot; &quot;bpp=%d\n&quot;</span>
<span class="p_add">+				     &quot;buf_size=%d\n&quot; &quot;stride=%d\n&quot;</span>
<span class="p_add">+				     &quot;stride_plane1=0x%x\n&quot;</span>
<span class="p_add">+				     &quot;stride_plane2=0x%x\n&quot; &quot;phy_addr=0x%llx\n&quot;</span>
<span class="p_add">+				     &quot;vir_addr=0x%llx\n&quot; &quot;offset_plane1=%d\n&quot;</span>
<span class="p_add">+				     &quot;offset_plane2=%d\n&quot;</span>
<span class="p_add">+				     &quot;afbc_header_addr=0x%llx\n&quot;</span>
<span class="p_add">+				     &quot;afbc_payload_addr=0x%llx\n&quot;</span>
<span class="p_add">+				     &quot;afbc_header_stride=%d\n&quot;</span>
<span class="p_add">+				     &quot;afbc_payload_stride=%d\n&quot;</span>
<span class="p_add">+				     &quot;afbc_scramble_mode=%d\n&quot;</span>
<span class="p_add">+				     &quot;mmbuf_base=0x%x\n&quot; &quot;mmbuf_size=%d\n&quot;</span>
<span class="p_add">+				     &quot;mmu_enable=%d\n&quot; &quot;csc_mode=%d\n&quot;</span>
<span class="p_add">+				     &quot;secure_mode=%d\n&quot; &quot;shared_fd=%d\n&quot;</span>
<span class="p_add">+				     &quot;src_rect(%d,%d, %d,%d)\n&quot;</span>
<span class="p_add">+				     &quot;src_rect_mask(%d,%d, %d,%d)\n&quot;</span>
<span class="p_add">+				     &quot;dst_rect(%d,%d, %d,%d)\n&quot; &quot;transform=%d\n&quot;</span>
<span class="p_add">+				     &quot;blending=%d\n&quot; &quot;glb_alpha=0x%x\n&quot;</span>
<span class="p_add">+				     &quot;color=0x%x\n&quot; &quot;layer_idx=%d\n&quot;</span>
<span class="p_add">+				     &quot;chn_idx=%d\n&quot; &quot;need_cap=0x%x\n&quot;</span>
<span class="p_add">+				     &quot;acquire_fence=%d\n&quot;, k, layer-&gt;img.format,</span>
<span class="p_add">+				     layer-&gt;img.width, layer-&gt;img.height,</span>
<span class="p_add">+				     layer-&gt;img.bpp, layer-&gt;img.buf_size,</span>
<span class="p_add">+				     layer-&gt;img.stride,</span>
<span class="p_add">+				     layer-&gt;img.stride_plane1,</span>
<span class="p_add">+				     layer-&gt;img.stride_plane2,</span>
<span class="p_add">+				     layer-&gt;img.phy_addr, layer-&gt;img.vir_addr,</span>
<span class="p_add">+				     layer-&gt;img.offset_plane1,</span>
<span class="p_add">+				     layer-&gt;img.offset_plane2,</span>
<span class="p_add">+				     layer-&gt;img.afbc_header_addr,</span>
<span class="p_add">+				     layer-&gt;img.afbc_payload_addr,</span>
<span class="p_add">+				     layer-&gt;img.afbc_header_stride,</span>
<span class="p_add">+				     layer-&gt;img.afbc_payload_stride,</span>
<span class="p_add">+				     layer-&gt;img.afbc_scramble_mode,</span>
<span class="p_add">+				     layer-&gt;img.mmbuf_base,</span>
<span class="p_add">+				     layer-&gt;img.mmbuf_size,</span>
<span class="p_add">+				     layer-&gt;img.mmu_enable, layer-&gt;img.csc_mode,</span>
<span class="p_add">+				     layer-&gt;img.secure_mode,</span>
<span class="p_add">+				     layer-&gt;img.shared_fd, layer-&gt;src_rect.x,</span>
<span class="p_add">+				     layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+				     layer-&gt;src_rect.h, layer-&gt;src_rect_mask.x,</span>
<span class="p_add">+				     layer-&gt;src_rect_mask.y,</span>
<span class="p_add">+				     layer-&gt;src_rect_mask.w,</span>
<span class="p_add">+				     layer-&gt;src_rect_mask.h, layer-&gt;dst_rect.x,</span>
<span class="p_add">+				     layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+				     layer-&gt;dst_rect.h, layer-&gt;transform,</span>
<span class="p_add">+				     layer-&gt;blending, layer-&gt;glb_alpha,</span>
<span class="p_add">+				     layer-&gt;color, layer-&gt;layer_idx,</span>
<span class="p_add">+				     layer-&gt;chn_idx, layer-&gt;need_cap,</span>
<span class="p_add">+				     layer-&gt;acquire_fence);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+			if (isNeedSaveFile) {</span>
<span class="p_add">+				if (layer-&gt;dst_rect.y &lt;</span>
<span class="p_add">+				    pov_block_info-&gt;ov_block_rect.y)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+</span>
<span class="p_add">+				dumpDss-&gt;scene_buf_len +=</span>
<span class="p_add">+				    snprintf(dumpDss-&gt;scene_buf +</span>
<span class="p_add">+					     dumpDss-&gt;scene_buf_len, SZ_1K,</span>
<span class="p_add">+					     &quot;[BaseColor]=0x%x\n&quot;</span>
<span class="p_add">+					     &quot;[ScreenSize]=(%u,%u)\n\n&quot;</span>
<span class="p_add">+					     &quot;[BlendMode]=%d\n&quot; &quot;[Caption]=\n&quot;</span>
<span class="p_add">+					     &quot;[Channel]=%u\n&quot;</span>
<span class="p_add">+					     &quot;[CropLoc]=(%u,%u)\n&quot;</span>
<span class="p_add">+					     &quot;[CropSize]=(%u,%u)\n&quot;</span>
<span class="p_add">+					     &quot;[FlipHV]=(%u,%u)\n&quot;</span>
<span class="p_add">+					     &quot;[Format]=%s\n&quot;</span>
<span class="p_add">+					     &quot;[GlobalAlpha]=%u\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;dss_module.ov[pov_req-&gt;</span>
<span class="p_add">+								   ovl_idx].</span>
<span class="p_add">+					     ovl_bg_color,</span>
<span class="p_add">+					     get_panel_xres(hisifd),</span>
<span class="p_add">+					     get_panel_yres(hisifd),</span>
<span class="p_add">+					     layer-&gt;blending, layer-&gt;chn_idx, 0,</span>
<span class="p_add">+					     0, layer-&gt;src_rect.w,</span>
<span class="p_add">+					     layer-&gt;src_rect.h,</span>
<span class="p_add">+					     (layer-&gt;</span>
<span class="p_add">+					      transform &amp;</span>
<span class="p_add">+					      HISI_FB_TRANSFORM_FLIP_H),</span>
<span class="p_add">+					     (layer-&gt;</span>
<span class="p_add">+					      transform &amp;</span>
<span class="p_add">+					      HISI_FB_TRANSFORM_FLIP_V),</span>
<span class="p_add">+					     layer_format[layer-&gt;img.format],</span>
<span class="p_add">+					     layer-&gt;glb_alpha);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (layer-&gt;need_cap &amp; (CAP_DIM | CAP_PURE_COLOR |</span>
<span class="p_add">+						CAP_BASE)) {</span>
<span class="p_add">+					if (layer-&gt;need_cap &amp; CAP_BASE) {</span>
<span class="p_add">+						dumpDss-&gt;scene_buf_len +=</span>
<span class="p_add">+						    snprintf(dumpDss-&gt;scene_buf +</span>
<span class="p_add">+							     dumpDss-&gt;scene_buf_len,</span>
<span class="p_add">+							     SZ_1K,</span>
<span class="p_add">+							     &quot;[BaseColor]=0x%x\n&quot;,</span>
<span class="p_add">+							     layer-&gt;color);</span>
<span class="p_add">+					} else if (layer-&gt;need_cap &amp; CAP_PURE_COLOR) {</span>
<span class="p_add">+						dumpDss-&gt;scene_buf_len +=</span>
<span class="p_add">+						    snprintf(dumpDss-&gt;scene_buf +</span>
<span class="p_add">+							     dumpDss-&gt;scene_buf_len,</span>
<span class="p_add">+							     SZ_1K,</span>
<span class="p_add">+							     &quot;[Color]=0x%x\n&quot;,</span>
<span class="p_add">+							     layer-&gt;color);</span>
<span class="p_add">+					}</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					dumpDss-&gt;scene_buf_len +=</span>
<span class="p_add">+					    snprintf(dumpDss-&gt;scene_buf +</span>
<span class="p_add">+						     dumpDss-&gt;scene_buf_len,</span>
<span class="p_add">+						     SZ_1K,</span>
<span class="p_add">+						     &quot;[ImageSource]=pic%d_%ld.bin\n&quot;,</span>
<span class="p_add">+						     k, tv.tv_sec);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				dumpDss-&gt;scene_buf_len +=</span>
<span class="p_add">+				    snprintf(dumpDss-&gt;scene_buf +</span>
<span class="p_add">+					     dumpDss-&gt;scene_buf_len, SZ_1K,</span>
<span class="p_add">+					     &quot;[Location]=(%u,%u)\n&quot;</span>
<span class="p_add">+					     &quot;[Rotate]=%u\n&quot; &quot;[Scale]=(%u,%u)\n&quot;</span>
<span class="p_add">+					     &quot;[Size]=(%u,%u)\n\n&quot;,</span>
<span class="p_add">+					     layer-&gt;dst_rect.x,</span>
<span class="p_add">+					     layer-&gt;dst_rect.y,</span>
<span class="p_add">+					     hisi_transform2degree(layer-&gt;transform),</span>
<span class="p_add">+					     layer-&gt;dst_rect.w,</span>
<span class="p_add">+					     layer-&gt;dst_rect.h,</span>
<span class="p_add">+					     layer-&gt;dst_rect.w,</span>
<span class="p_add">+					     layer-&gt;dst_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+				if (layer-&gt;need_cap &amp; (CAP_DIM | CAP_PURE_COLOR |</span>
<span class="p_add">+						CAP_BASE))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (layer-&gt;img.shared_fd &lt; 0)</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+</span>
<span class="p_add">+				ionhnd =</span>
<span class="p_add">+				    ion_import_dma_buf(hisifd-&gt;ion_client,</span>
<span class="p_add">+						       layer-&gt;img.shared_fd);</span>
<span class="p_add">+				if (IS_ERR(ionhnd)) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;ion import dma buf err, ionclient %p, share_fd %d, layer index %d&quot;,</span>
<span class="p_add">+					     hisifd-&gt;ion_client,</span>
<span class="p_add">+					     layer-&gt;img.shared_fd, i);</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				snprintf(dumpDss-&gt;image_bin_filename[k],</span>
<span class="p_add">+					 sizeof(dumpDss-&gt;image_bin_filename[k]),</span>
<span class="p_add">+					 &quot;/data/dssdump/pic%d_%ld.bin&quot;, k,</span>
<span class="p_add">+					 tv.tv_sec);</span>
<span class="p_add">+</span>
<span class="p_add">+				image_src_addr =</span>
<span class="p_add">+				    ion_map_kernel(hisifd-&gt;ion_client, ionhnd);</span>
<span class="p_add">+				if (image_src_addr) {</span>
<span class="p_add">+					hisifb_save_file(dumpDss-&gt;image_bin_filename[k],</span>
<span class="p_add">+							 image_src_addr,</span>
<span class="p_add">+							 layer-&gt;img.buf_size);</span>
<span class="p_add">+					ion_unmap_kernel(hisifd-&gt;ion_client, ionhnd);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				ion_free(hisifd-&gt;ion_client, ionhnd);</span>
<span class="p_add">+				ionhnd = NULL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (k = 0; k &lt; pov_req-&gt;wb_layer_nums; k++) {</span>
<span class="p_add">+		wb_layer = &amp;(pov_req-&gt;wb_layer_infos[k]);</span>
<span class="p_add">+</span>
<span class="p_add">+		dumpDss-&gt;dss_buf_len +=</span>
<span class="p_add">+		    snprintf(dumpDss-&gt;dss_buf + dumpDss-&gt;dss_buf_len, 4 * SZ_1K,</span>
<span class="p_add">+			     &quot;\nWbLayerInfo[%d]:\n&quot; &quot;format=%d\n&quot; &quot;width=%d\n&quot;</span>
<span class="p_add">+			     &quot;height=%d\n&quot; &quot;bpp=%d\n&quot; &quot;buf_size=%d\n&quot;</span>
<span class="p_add">+			     &quot;stride=%d\n&quot; &quot;stride_plane1=%d\n&quot;</span>
<span class="p_add">+			     &quot;stride_plane2=%d\n&quot; &quot;phy_addr=0x%llx\n&quot;</span>
<span class="p_add">+			     &quot;vir_addr=0x%llx\n&quot; &quot;offset_plane1=%d\n&quot;</span>
<span class="p_add">+			     &quot;offset_plane2=%d\n&quot; &quot;afbc_header_addr=0x%llx\n&quot;</span>
<span class="p_add">+			     &quot;afbc_payload_addr=0x%llx\n&quot;</span>
<span class="p_add">+			     &quot;afbc_header_stride=%d\n&quot;</span>
<span class="p_add">+			     &quot;afbc_payload_stride=%d\n&quot;</span>
<span class="p_add">+			     &quot;afbc_scramble_mode=%d\n&quot; &quot;mmbuf_base=0x%x\n&quot;</span>
<span class="p_add">+			     &quot;mmbuf_size=%d\n&quot; &quot;mmu_enable=%d\n&quot; &quot;csc_mode=%d\n&quot;</span>
<span class="p_add">+			     &quot;secure_mode=%d\n&quot; &quot;shared_fd=%d\n&quot;</span>
<span class="p_add">+			     &quot;src_rect(%d,%d, %d,%d)\n&quot;</span>
<span class="p_add">+			     &quot;dst_rect(%d,%d, %d,%d)\n&quot; &quot;transform=%d\n&quot;</span>
<span class="p_add">+			     &quot;chn_idx=%d\n&quot; &quot;need_cap=0x%x\n&quot;</span>
<span class="p_add">+			     &quot;acquire_fence=%d\n&quot; &quot;release_fence=%d\n&quot;, k,</span>
<span class="p_add">+			     wb_layer-&gt;dst.format, wb_layer-&gt;dst.width,</span>
<span class="p_add">+			     wb_layer-&gt;dst.height, wb_layer-&gt;dst.bpp,</span>
<span class="p_add">+			     wb_layer-&gt;dst.buf_size, wb_layer-&gt;dst.stride,</span>
<span class="p_add">+			     wb_layer-&gt;dst.stride_plane1,</span>
<span class="p_add">+			     wb_layer-&gt;dst.stride_plane2,</span>
<span class="p_add">+			     wb_layer-&gt;dst.phy_addr, wb_layer-&gt;dst.vir_addr,</span>
<span class="p_add">+			     wb_layer-&gt;dst.offset_plane1,</span>
<span class="p_add">+			     wb_layer-&gt;dst.offset_plane2,</span>
<span class="p_add">+			     wb_layer-&gt;dst.afbc_header_addr,</span>
<span class="p_add">+			     wb_layer-&gt;dst.afbc_payload_addr,</span>
<span class="p_add">+			     wb_layer-&gt;dst.afbc_header_stride,</span>
<span class="p_add">+			     wb_layer-&gt;dst.afbc_payload_stride,</span>
<span class="p_add">+			     wb_layer-&gt;dst.afbc_scramble_mode,</span>
<span class="p_add">+			     wb_layer-&gt;dst.mmbuf_base, wb_layer-&gt;dst.mmbuf_size,</span>
<span class="p_add">+			     wb_layer-&gt;dst.mmu_enable, wb_layer-&gt;dst.csc_mode,</span>
<span class="p_add">+			     wb_layer-&gt;dst.secure_mode, wb_layer-&gt;dst.shared_fd,</span>
<span class="p_add">+			     wb_layer-&gt;src_rect.x, wb_layer-&gt;src_rect.y,</span>
<span class="p_add">+			     wb_layer-&gt;src_rect.w, wb_layer-&gt;src_rect.h,</span>
<span class="p_add">+			     wb_layer-&gt;dst_rect.x, wb_layer-&gt;dst_rect.y,</span>
<span class="p_add">+			     wb_layer-&gt;dst_rect.w, wb_layer-&gt;dst_rect.h,</span>
<span class="p_add">+			     wb_layer-&gt;transform, wb_layer-&gt;chn_idx,</span>
<span class="p_add">+			     wb_layer-&gt;need_cap, wb_layer-&gt;acquire_fence,</span>
<span class="p_add">+			     wb_layer-&gt;release_fence);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dumpDss-&gt;dss_buf_len +=</span>
<span class="p_add">+	    snprintf(dumpDss-&gt;dss_buf + dumpDss-&gt;dss_buf_len, 4 * SZ_1K,</span>
<span class="p_add">+		     &quot;----------------------------&lt;dump end&gt;----------------------------\n\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (k = 0; k &lt; dumpDss-&gt;dss_buf_len; k += 255) {</span>
<span class="p_add">+		printk(&quot;%.255s&quot;, dumpDss-&gt;dss_buf + k);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (isNeedSaveFile) {</span>
<span class="p_add">+		if (dumpDss-&gt;scene_buf)</span>
<span class="p_add">+			hisifb_save_file(dumpDss-&gt;scene_filename,</span>
<span class="p_add">+					 dumpDss-&gt;scene_buf,</span>
<span class="p_add">+					 dumpDss-&gt;scene_buf_len);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dumpDss-&gt;dss_buf)</span>
<span class="p_add">+			hisifb_save_file(dumpDss-&gt;dss_filename,</span>
<span class="p_add">+					 dumpDss-&gt;dss_buf,</span>
<span class="p_add">+					 dumpDss-&gt;dss_buf_len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dumpDss-&gt;dss_buf) {</span>
<span class="p_add">+		kfree(dumpDss-&gt;dss_buf);</span>
<span class="p_add">+		dumpDss-&gt;dss_buf = NULL;</span>
<span class="p_add">+		dumpDss-&gt;dss_buf_len = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+ alloc_dss_buf_err:</span>
<span class="p_add">+	if (dumpDss-&gt;scene_buf) {</span>
<span class="p_add">+		kfree(dumpDss-&gt;scene_buf);</span>
<span class="p_add">+		dumpDss-&gt;scene_buf = NULL;</span>
<span class="p_add">+		dumpDss-&gt;scene_buf_len = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+ alloc_scene_buf_err:</span>
<span class="p_add">+	if (dumpDss) {</span>
<span class="p_add">+		kfree(dumpDss);</span>
<span class="p_add">+		dumpDss = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+ alloc_dump_dss_data_err:</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_dss_lcd_refresh_direction_layer(struct hisi_fb_data_type</span>
<span class="p_add">+						*hisifd,</span>
<span class="p_add">+						dss_overlay_t *pov_req,</span>
<span class="p_add">+						dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;ovl_idx != DSS_OVL0) &amp;&amp; (pov_req-&gt;ovl_idx != DSS_OVL1))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_LEFT_TOP) {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_RIGHT_TOP) {</span>
<span class="p_add">+		switch (layer-&gt;transform) {</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_H;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_NOP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_180;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_90:</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_H);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_V;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_270:</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_V);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_H):</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_90;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_V):</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_270;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			HISI_FB_ERR(&quot;not support this transform(%d).\n&quot;,</span>
<span class="p_add">+				    layer-&gt;transform);</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret == 0) {</span>
<span class="p_add">+			if ((pinfo-&gt;dirty_region_updt_support == 1) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.w &gt; 0) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.h &gt; 0)) {</span>
<span class="p_add">+				layer-&gt;dst_rect.x =</span>
<span class="p_add">+				    (pov_req-&gt;dirty_rect.w -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.x + layer-&gt;dst_rect.w));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				layer-&gt;dst_rect.x =</span>
<span class="p_add">+				    (get_panel_xres(hisifd) -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.x + layer-&gt;dst_rect.w));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_LEFT_BOTTOM) {</span>
<span class="p_add">+		switch (layer-&gt;transform) {</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_V;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_180;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_NOP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_90:</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_V);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_H;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_270:</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_H);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_H):</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_270;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_V):</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_90;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			HISI_FB_ERR(&quot;not support this transform(%d).\n&quot;,</span>
<span class="p_add">+				    layer-&gt;transform);</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret == 0) {</span>
<span class="p_add">+			if ((pinfo-&gt;dirty_region_updt_support == 1) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.w &gt; 0) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.h &gt; 0)) {</span>
<span class="p_add">+				layer-&gt;dst_rect.y =</span>
<span class="p_add">+				    (pov_req-&gt;dirty_rect.h -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.y + layer-&gt;dst_rect.h));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				layer-&gt;dst_rect.y =</span>
<span class="p_add">+				    (get_panel_yres(hisifd) -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.y + layer-&gt;dst_rect.h));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl ==</span>
<span class="p_add">+		   LCD_REFRESH_RIGHT_BOTTOM) {</span>
<span class="p_add">+		switch (layer-&gt;transform) {</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_180;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_V;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_FLIP_H;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_90:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_270;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_NOP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_270:</span>
<span class="p_add">+			layer-&gt;transform = HISI_FB_TRANSFORM_ROT_90;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_H):</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_V);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_V):</span>
<span class="p_add">+			layer-&gt;transform =</span>
<span class="p_add">+			    (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			     HISI_FB_TRANSFORM_FLIP_H);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			HISI_FB_ERR(&quot;not support this transform(%d).\n&quot;,</span>
<span class="p_add">+				    layer-&gt;transform);</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret == 0) {</span>
<span class="p_add">+			if ((pinfo-&gt;dirty_region_updt_support == 1) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.w &gt; 0) &amp;&amp;</span>
<span class="p_add">+			    (pov_req-&gt;dirty_rect.h &gt; 0)) {</span>
<span class="p_add">+				layer-&gt;dst_rect.x =</span>
<span class="p_add">+				    (pov_req-&gt;dirty_rect.w -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.x + layer-&gt;dst_rect.w));</span>
<span class="p_add">+				layer-&gt;dst_rect.y =</span>
<span class="p_add">+				    (pov_req-&gt;dirty_rect.h -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.y + layer-&gt;dst_rect.h));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				layer-&gt;dst_rect.x =</span>
<span class="p_add">+				    (get_panel_xres(hisifd) -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.x + layer-&gt;dst_rect.w));</span>
<span class="p_add">+				layer-&gt;dst_rect.y =</span>
<span class="p_add">+				    (get_panel_yres(hisifd) -</span>
<span class="p_add">+				     (layer-&gt;dst_rect.y + layer-&gt;dst_rect.h));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, not support this lcd_refresh_direction_ctrl(%d)!\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, pinfo-&gt;lcd_refresh_direction_ctrl);</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_dss_lcd_refresh_direction_dirty_region(struct hisi_fb_data_type</span>
<span class="p_add">+						       *hisifd,</span>
<span class="p_add">+						       dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+	if ((pov_req-&gt;ovl_idx != DSS_OVL0) &amp;&amp; (pov_req-&gt;ovl_idx != DSS_OVL1))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_LEFT_TOP) {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_RIGHT_TOP) {</span>
<span class="p_add">+		if (pinfo-&gt;dirty_region_updt_support == 1) {</span>
<span class="p_add">+			pov_req-&gt;dirty_rect.x =</span>
<span class="p_add">+			    (get_panel_xres(hisifd) -</span>
<span class="p_add">+			     (pov_req-&gt;dirty_rect.x + pov_req-&gt;dirty_rect.w));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl == LCD_REFRESH_LEFT_BOTTOM) {</span>
<span class="p_add">+		if (pinfo-&gt;dirty_region_updt_support == 1) {</span>
<span class="p_add">+			pov_req-&gt;dirty_rect.y =</span>
<span class="p_add">+			    (get_panel_yres(hisifd) -</span>
<span class="p_add">+			     (pov_req-&gt;dirty_rect.y + pov_req-&gt;dirty_rect.h));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (pinfo-&gt;lcd_refresh_direction_ctrl ==</span>
<span class="p_add">+		   LCD_REFRESH_RIGHT_BOTTOM) {</span>
<span class="p_add">+		if (pinfo-&gt;dirty_region_updt_support == 1) {</span>
<span class="p_add">+			pov_req-&gt;dirty_rect.x =</span>
<span class="p_add">+			    (get_panel_xres(hisifd) -</span>
<span class="p_add">+			     (pov_req-&gt;dirty_rect.x + pov_req-&gt;dirty_rect.w));</span>
<span class="p_add">+			pov_req-&gt;dirty_rect.y =</span>
<span class="p_add">+			    (get_panel_yres(hisifd) -</span>
<span class="p_add">+			     (pov_req-&gt;dirty_rect.y + pov_req-&gt;dirty_rect.h));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, not support this lcd_refresh_direction_ctrl(%d)!\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, pinfo-&gt;lcd_refresh_direction_ctrl);</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_handle_cur_ovl_req(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int m = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;resolution_rect = pov_req-&gt;res_updt_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_h_block_infos =</span>
<span class="p_add">+	    (dss_overlay_block_t *) (pov_req-&gt;ov_block_infos_ptr);</span>
<span class="p_add">+	for (m = 0; m &lt; pov_req-&gt;ov_block_nums; m++) {</span>
<span class="p_add">+		pov_h_block = &amp;(pov_h_block_infos[m]);</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; pov_h_block-&gt;layer_nums; i++) {</span>
<span class="p_add">+			layer = &amp;(pov_h_block-&gt;layer_infos[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_lcd_refresh_direction_layer(hisifd, pov_req,</span>
<span class="p_add">+							     layer);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisi_dss_lcd_refresh_direction_dirty_region(hisifd, pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+int hisi_get_hal_format(struct fb_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fb_var_screeninfo *var = NULL;</span>
<span class="p_add">+	int hal_format = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(info == NULL);</span>
<span class="p_add">+	var = &amp;info-&gt;var;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (var-&gt;bits_per_pixel) {</span>
<span class="p_add">+	case 16:</span>
<span class="p_add">+		if (var-&gt;blue.offset == 0) {</span>
<span class="p_add">+			if (var-&gt;red.offset == 8) {</span>
<span class="p_add">+				hal_format = (var-&gt;transp.offset == 12) ?</span>
<span class="p_add">+				    HISI_FB_PIXEL_FORMAT_BGRA_4444 :</span>
<span class="p_add">+				    HISI_FB_PIXEL_FORMAT_BGRX_4444;</span>
<span class="p_add">+			} else if (var-&gt;red.offset == 10) {</span>
<span class="p_add">+				hal_format = (var-&gt;transp.offset == 12) ?</span>
<span class="p_add">+				    HISI_FB_PIXEL_FORMAT_BGRA_5551 :</span>
<span class="p_add">+				    HISI_FB_PIXEL_FORMAT_BGRX_5551;</span>
<span class="p_add">+			} else if (var-&gt;red.offset == 11) {</span>
<span class="p_add">+				hal_format = HISI_FB_PIXEL_FORMAT_RGB_565;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 32:</span>
<span class="p_add">+		if (var-&gt;blue.offset == 0) {</span>
<span class="p_add">+			/* BUGFIX: Modified for Standard Android Format */</span>
<span class="p_add">+			/* hal_format = (var-&gt;transp.length == 8) ?</span>
<span class="p_add">+				HISI_FB_PIXEL_FORMAT_BGRA_8888 : HISI_FB_PIXEL_FORMAT_BGRX_8888; */</span>
<span class="p_add">+			hal_format = (var-&gt;transp.length == 8) ?</span>
<span class="p_add">+				HISI_FB_PIXEL_FORMAT_RGBA_8888 :</span>
<span class="p_add">+				HISI_FB_PIXEL_FORMAT_RGBX_8888;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			hal_format = (var-&gt;transp.length == 8) ?</span>
<span class="p_add">+			    HISI_FB_PIXEL_FORMAT_RGBA_8888 :</span>
<span class="p_add">+			    HISI_FB_PIXEL_FORMAT_RGBX_8888;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return hal_format;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	HISI_FB_ERR(&quot;not support this bits_per_pixel(%d)!\n&quot;,</span>
<span class="p_add">+		    var-&gt;bits_per_pixel);</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool hal_format_has_alpha(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_8888:</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_8888:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool isYUVPackage(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUV_422_I:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUYV_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YVYU_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_UYVY_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_VYUY_422_Pkg:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool isYUVSemiPlanar(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_SP:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool isYUVPlanar(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_P:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool isYUV(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return isYUVPackage(format) ||</span>
<span class="p_add">+	    isYUVSemiPlanar(format) || isYUVPlanar(format);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_YUV_SP_420(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_SP:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_YUV_SP_422(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_SP:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_YUV_P_420(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_P:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_YUV_P_422(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_P:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_RGBX(uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_8888:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_8888:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool isNeedDither(int fmt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (fmt == DFC_PIXEL_FORMAT_RGB_565) ||</span>
<span class="p_add">+	    (fmt == DFC_PIXEL_FORMAT_BGR_565);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool isNeedRectClip(dss_rect_ltrb_t clip_rect)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ((clip_rect.left &gt; 0) || (clip_rect.top &gt; 0) ||</span>
<span class="p_add">+		(clip_rect.right &gt; 0) || (clip_rect.bottom &gt; 0));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool isSrcRectMasked(dss_layer_t *layer, int aligned_pixel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ((layer-&gt;src_rect_mask.w != 0) &amp;&amp;</span>
<span class="p_add">+		(layer-&gt;src_rect_mask.h != 0) &amp;&amp;</span>
<span class="p_add">+		(ALIGN_DOWN</span>
<span class="p_add">+		 (layer-&gt;src_rect_mask.x + layer-&gt;src_rect_mask.w,</span>
<span class="p_add">+		  aligned_pixel) &gt; 1));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t isNeedRdmaStretchBlt(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				     dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t v_stretch_ratio_threshold = 0;</span>
<span class="p_add">+	uint32_t v_stretch_ratio = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCD) {</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+		v_stretch_ratio = layer-&gt;src_rect.h / layer-&gt;dst_rect.h;</span>
<span class="p_add">+		if (v_stretch_ratio &lt; 2)</span>
<span class="p_add">+			v_stretch_ratio = 0;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		v_stretch_ratio = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+			v_stretch_ratio_threshold =</span>
<span class="p_add">+			    ((layer-&gt;src_rect.h + layer-&gt;dst_rect.h -</span>
<span class="p_add">+			      1) / layer-&gt;dst_rect.h);</span>
<span class="p_add">+			v_stretch_ratio =</span>
<span class="p_add">+			    ((layer-&gt;src_rect.h / layer-&gt;dst_rect.h) / 2) * 2;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			v_stretch_ratio_threshold =</span>
<span class="p_add">+			    ((layer-&gt;src_rect.h + layer-&gt;dst_rect.h -</span>
<span class="p_add">+			      1) / layer-&gt;dst_rect.h);</span>
<span class="p_add">+			v_stretch_ratio =</span>
<span class="p_add">+			    (layer-&gt;src_rect.h / layer-&gt;dst_rect.h);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (v_stretch_ratio_threshold &lt;= g_rdma_stretch_threshold)</span>
<span class="p_add">+			v_stretch_ratio = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return v_stretch_ratio;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_adjust_clip_rect(dss_layer_t *layer,</span>
<span class="p_add">+				 dss_rect_ltrb_t *clip_rect)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t temp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+	BUG_ON(clip_rect == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((clip_rect-&gt;left &lt; 0 || clip_rect-&gt;left &gt; DFC_MAX_CLIP_NUM) ||</span>
<span class="p_add">+	    (clip_rect-&gt;right &lt; 0 || clip_rect-&gt;right &gt; DFC_MAX_CLIP_NUM) ||</span>
<span class="p_add">+	    (clip_rect-&gt;top &lt; 0 || clip_rect-&gt;top &gt; DFC_MAX_CLIP_NUM) ||</span>
<span class="p_add">+	    (clip_rect-&gt;bottom &lt; 0 || clip_rect-&gt;bottom &gt; DFC_MAX_CLIP_NUM)) {</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (layer-&gt;transform) {</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+		{</span>
<span class="p_add">+			temp = clip_rect-&gt;left;</span>
<span class="p_add">+			clip_rect-&gt;left = clip_rect-&gt;right;</span>
<span class="p_add">+			clip_rect-&gt;right = temp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+		{</span>
<span class="p_add">+			temp = clip_rect-&gt;top;</span>
<span class="p_add">+			clip_rect-&gt;top = clip_rect-&gt;bottom;</span>
<span class="p_add">+			clip_rect-&gt;bottom = temp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+		{</span>
<span class="p_add">+			temp = clip_rect-&gt;left;</span>
<span class="p_add">+			clip_rect-&gt;left = clip_rect-&gt;right;</span>
<span class="p_add">+			clip_rect-&gt;right = temp;</span>
<span class="p_add">+</span>
<span class="p_add">+			temp = clip_rect-&gt;top;</span>
<span class="p_add">+			clip_rect-&gt;top = clip_rect-&gt;bottom;</span>
<span class="p_add">+			clip_rect-&gt;bottom = temp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not supported this transform(%d)!&quot;,</span>
<span class="p_add">+			    layer-&gt;transform);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_pixel_format_hal2dma(int format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGB_565:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGR_565:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_RGB_565;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_4444:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_XRGB_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_4444:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_ARGB_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_5551:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_XRGB_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_5551:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_ARGB_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_8888:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_8888:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_XRGB_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_8888:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_8888:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_ARGB_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUV_422_I:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUYV_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YVYU_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_UYVY_422_Pkg:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_VYUY_422_Pkg:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_YUYV_422_Pkg;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_P:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_YUV_422_P_HP;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_P:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_YUV_420_P_HP;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_SP:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_YUV_422_SP_HP;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_SP:</span>
<span class="p_add">+		ret = DMA_PIXEL_FORMAT_YUV_420_SP_HP;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support format(%d)!\n&quot;, format);</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_transform_hal2dma(int transform, int chn_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (chn_idx &lt; DSS_WCHN_W0 || chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+		switch (transform) {</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+			ret = DSS_TRANSFORM_NOP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+			ret = DSS_TRANSFORM_FLIP_H;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+			ret = DSS_TRANSFORM_FLIP_V;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+			ret = DSS_TRANSFORM_FLIP_V | DSS_TRANSFORM_FLIP_H;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			HISI_FB_ERR(&quot;Transform %d is not supported&quot;, transform);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (transform == HISI_FB_TRANSFORM_NOP) {</span>
<span class="p_add">+			ret = DSS_TRANSFORM_NOP;</span>
<span class="p_add">+		} else if (transform ==</span>
<span class="p_add">+			   (HISI_FB_TRANSFORM_ROT_90 |</span>
<span class="p_add">+			    HISI_FB_TRANSFORM_FLIP_V)) {</span>
<span class="p_add">+			ret = DSS_TRANSFORM_ROT;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = -1;</span>
<span class="p_add">+			HISI_FB_ERR(&quot;Transform %d is not supported&quot;, transform);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_pixel_format_hal2dfc(int format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGB_565:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_RGB_565;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_4444:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XBGR_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_4444:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ABGR_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_5551:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XBGR_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_5551:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ABGR_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBX_8888:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XBGR_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_RGBA_8888:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ABGR_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGR_565:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_BGR_565;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_4444:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XRGB_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_4444:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ARGB_4444;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_5551:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XRGB_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_5551:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ARGB_5551;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_8888:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_XRGB_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_8888:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_ARGB_8888;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUV_422_I:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YUYV_422_Pkg:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YUYV422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YVYU_422_Pkg:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YVYU422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_UYVY_422_Pkg:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_UYVY422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_VYUY_422_Pkg:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_VYUY422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_SP:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YUYV422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_SP:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YVYU422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_SP:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YUYV422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_SP:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YVYU422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCbCr_420_P:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YUYV422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_P:</span>
<span class="p_add">+		ret = DFC_PIXEL_FORMAT_YVYU422;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support format(%d)!\n&quot;, format);</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_rb_swap(int format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGR_565:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_4444:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_5551:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRX_8888:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_BGRA_8888:</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_uv_swap(int format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (format) {</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_SP:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_422_P:</span>
<span class="p_add">+	case HISI_FB_PIXEL_FORMAT_YCrCb_420_P:</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_dfc_get_bpp(int dfc_format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (dfc_format) {</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_RGB_565:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XRGB_4444:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ARGB_4444:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XRGB_5551:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ARGB_5551:</span>
<span class="p_add">+</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_BGR_565:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XBGR_4444:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ABGR_4444:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XBGR_5551:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ABGR_5551:</span>
<span class="p_add">+		ret = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XRGB_8888:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ARGB_8888:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_XBGR_8888:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_ABGR_8888:</span>
<span class="p_add">+		ret = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_YUV444:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_YVU444:</span>
<span class="p_add">+		ret = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_YUYV422:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_YVYU422:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_VYUY422:</span>
<span class="p_add">+	case DFC_PIXEL_FORMAT_UYVY422:</span>
<span class="p_add">+		ret = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support format(%d)!\n&quot;, dfc_format);</span>
<span class="p_add">+		ret = -1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t hisi_calculate_display_addr(bool mmu_enable,</span>
<span class="p_add">+					    dss_layer_t *layer,</span>
<span class="p_add">+					    dss_rect_ltrb_t *aligned_rect,</span>
<span class="p_add">+					    int add_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t addr = 0;</span>
<span class="p_add">+	uint32_t src_addr = 0;</span>
<span class="p_add">+	uint32_t stride = 0;</span>
<span class="p_add">+	uint32_t offset = 0;</span>
<span class="p_add">+	int bpp = 0;</span>
<span class="p_add">+	int left = 0;</span>
<span class="p_add">+	int right = 0;</span>
<span class="p_add">+	int top = 0;</span>
<span class="p_add">+	int bottom = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	left = aligned_rect-&gt;left;</span>
<span class="p_add">+	right = aligned_rect-&gt;right;</span>
<span class="p_add">+	top = aligned_rect-&gt;top;</span>
<span class="p_add">+	bottom = aligned_rect-&gt;bottom;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (add_type == DSS_ADDR_PLANE0) {</span>
<span class="p_add">+		stride = layer-&gt;img.stride;</span>
<span class="p_add">+		offset = 0;</span>
<span class="p_add">+		src_addr =</span>
<span class="p_add">+		    mmu_enable ? layer-&gt;img.vir_addr : layer-&gt;img.phy_addr;</span>
<span class="p_add">+		bpp = layer-&gt;img.bpp;</span>
<span class="p_add">+	} else if (add_type == DSS_ADDR_PLANE1) {</span>
<span class="p_add">+		stride = layer-&gt;img.stride_plane1;</span>
<span class="p_add">+		offset = layer-&gt;img.offset_plane1;</span>
<span class="p_add">+		src_addr = mmu_enable ? (layer-&gt;img.vir_addr + offset) :</span>
<span class="p_add">+		    (layer-&gt;img.phy_addr + offset);</span>
<span class="p_add">+		bpp = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_P_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_422(layer-&gt;img.format)) {</span>
<span class="p_add">+			left /= 2;</span>
<span class="p_add">+			right /= 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+			top /= 2;</span>
<span class="p_add">+			bottom /= 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (add_type == DSS_ADDR_PLANE2) {</span>
<span class="p_add">+		stride = layer-&gt;img.stride_plane2;</span>
<span class="p_add">+		offset = layer-&gt;img.offset_plane2;</span>
<span class="p_add">+		src_addr = mmu_enable ? (layer-&gt;img.vir_addr + offset) :</span>
<span class="p_add">+		    (layer-&gt;img.phy_addr + offset);</span>
<span class="p_add">+		bpp = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_P_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_422(layer-&gt;img.format)) {</span>
<span class="p_add">+			left /= 2;</span>
<span class="p_add">+			right /= 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+			top /= 2;</span>
<span class="p_add">+			bottom /= 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;NOT SUPPORT this add_type(%d).\n&quot;, add_type);</span>
<span class="p_add">+		BUG_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (layer-&gt;transform) {</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_NOP:</span>
<span class="p_add">+		addr = src_addr + top * stride + left * bpp;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_H:</span>
<span class="p_add">+		addr = src_addr + top * stride + right * bpp;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_FLIP_V:</span>
<span class="p_add">+		addr = src_addr + bottom * stride + left * bpp;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HISI_FB_TRANSFORM_ROT_180:</span>
<span class="p_add">+		addr = src_addr + bottom * stride + right * bpp;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not supported this transform(%d)!&quot;,</span>
<span class="p_add">+			    layer-&gt;transform);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS MIF</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_mif_init(char __iomem *mif_ch_base,</span>
<span class="p_add">+			      dss_mif_t *s_mif, int chn_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t rw_type = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(mif_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mif == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_mif, 0, sizeof(dss_mif_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl1 = 0x00000020;</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl2 = 0x0;</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl3 = 0x0;</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl4 = 0x0;</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl5 = 0x0;</span>
<span class="p_add">+	rw_type = (chn_idx &lt; DSS_WCHN_W0 || chn_idx == DSS_RCHN_V2) ? 0x0 : 0x1;</span>
<span class="p_add">+</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl1 = set_bits32(s_mif-&gt;mif_ctrl1, 0x0, 1, 5);</span>
<span class="p_add">+	s_mif-&gt;mif_ctrl1 = set_bits32(s_mif-&gt;mif_ctrl1, rw_type, 1, 17);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mif_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				 char __iomem *mif_ch_base, dss_mif_t *s_mif,</span>
<span class="p_add">+				 int chn_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(mif_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mif == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mif_ch_base + MIF_CTRL1,</span>
<span class="p_add">+			s_mif-&gt;mif_ctrl1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mif_ch_base + MIF_CTRL2,</span>
<span class="p_add">+			s_mif-&gt;mif_ctrl2, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mif_ch_base + MIF_CTRL3,</span>
<span class="p_add">+			s_mif-&gt;mif_ctrl3, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mif_ch_base + MIF_CTRL4,</span>
<span class="p_add">+			s_mif-&gt;mif_ctrl4, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mif_ch_base + MIF_CTRL5,</span>
<span class="p_add">+			s_mif-&gt;mif_ctrl5, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mif_on(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *mif_base = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mif_base = hisifd-&gt;dss_base + DSS_MIF_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(mif_base + MIF_ENABLE, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH0_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH1_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH2_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH3_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH4_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH5_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH6_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH7_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH8_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH9_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH10_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+	set_reg(hisifd-&gt;dss_base + MIF_CH11_OFFSET + MIF_CTRL0, 0x1, 1, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_mif_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_layer_t *layer, dss_wb_layer_t *wb_layer,</span>
<span class="p_add">+			bool rdma_stretch_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_mif_t *mif = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_img_t *img = NULL;</span>
<span class="p_add">+	uint32_t transform = 0;</span>
<span class="p_add">+	uint32_t invalid_sel = 0;</span>
<span class="p_add">+	uint32_t need_cap = 0;</span>
<span class="p_add">+	uint32_t *semi_plane1 = NULL;</span>
<span class="p_add">+	int v_scaling_factor = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((layer == NULL) &amp;&amp; (wb_layer == NULL));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		img = &amp;(wb_layer-&gt;dst);</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+		transform = wb_layer-&gt;transform;</span>
<span class="p_add">+		need_cap = wb_layer-&gt;need_cap;</span>
<span class="p_add">+		v_scaling_factor = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		img = &amp;(layer-&gt;img);</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+		transform = layer-&gt;transform;</span>
<span class="p_add">+		need_cap = layer-&gt;need_cap;</span>
<span class="p_add">+		v_scaling_factor =</span>
<span class="p_add">+		    layer-&gt;src_rect.h / layer-&gt;dst_rect.h +</span>
<span class="p_add">+		    ((layer-&gt;src_rect.h % layer-&gt;dst_rect.h) &gt; 0 ? 1 : 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mif = &amp;(hisifd-&gt;dss_module.mif[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.mif_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	semi_plane1 = &amp;mif-&gt;mif_ctrl4;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (img-&gt;mmu_enable == 0) {</span>
<span class="p_add">+		mif-&gt;mif_ctrl1 = set_bits32(mif-&gt;mif_ctrl1, 0x1, 1, 5);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (need_cap &amp; (CAP_AFBCD | CAP_AFBCE)) {</span>
<span class="p_add">+			invalid_sel = 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			invalid_sel =</span>
<span class="p_add">+			    hisi_dss_mif_get_invalid_sel(img, transform,</span>
<span class="p_add">+							 v_scaling_factor,</span>
<span class="p_add">+							 ((need_cap &amp; CAP_TILE)</span>
<span class="p_add">+							  ? 1 : 0),</span>
<span class="p_add">+							 rdma_stretch_enable);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mif-&gt;mif_ctrl1 = set_bits32(mif-&gt;mif_ctrl1, 0x0, 1, 5);</span>
<span class="p_add">+		mif-&gt;mif_ctrl1 = set_bits32(mif-&gt;mif_ctrl1, invalid_sel, 2, 10);</span>
<span class="p_add">+		mif-&gt;mif_ctrl1 =</span>
<span class="p_add">+		    set_bits32(mif-&gt;mif_ctrl1, ((invalid_sel == 0) ? 0x1 : 0x0),</span>
<span class="p_add">+			       1, 19);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (invalid_sel == 0) {</span>
<span class="p_add">+			mif-&gt;mif_ctrl2 = set_bits32(mif-&gt;mif_ctrl2, 0x0, 20, 0);</span>
<span class="p_add">+			mif-&gt;mif_ctrl3 = set_bits32(mif-&gt;mif_ctrl3, 0x0, 20, 0);</span>
<span class="p_add">+			mif-&gt;mif_ctrl4 = set_bits32(mif-&gt;mif_ctrl4, 0x0, 20, 0);</span>
<span class="p_add">+			mif-&gt;mif_ctrl5 = set_bits32(mif-&gt;mif_ctrl5, 0x0, 20, 0);</span>
<span class="p_add">+		} else if ((invalid_sel == 1) || (invalid_sel == 2)) {</span>
<span class="p_add">+			if (img-&gt;stride &gt; 0) {</span>
<span class="p_add">+				mif-&gt;mif_ctrl5 = set_bits32(mif-&gt;mif_ctrl5,</span>
<span class="p_add">+							    ((img-&gt;stride /MIF_STRIDE_UNIT) +</span>
<span class="p_add">+							     (((img-&gt;stride % MIF_STRIDE_UNIT) &gt; 0) ?</span>
<span class="p_add">+							        1 : 0)), 20, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (isYUVSemiPlanar(img-&gt;format)) {</span>
<span class="p_add">+				if (img-&gt;stride_plane1 &gt; 0) {</span>
<span class="p_add">+					*semi_plane1 = set_bits32(*semi_plane1,</span>
<span class="p_add">+							((img-&gt;stride_plane1 / MIF_STRIDE_UNIT) +</span>
<span class="p_add">+							 (((img-&gt;stride_plane1 % MIF_STRIDE_UNIT) &gt;0) ?</span>
<span class="p_add">+							   1 : 0)), 20, 0);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			} else if (isYUVPlanar(img-&gt;format)) {</span>
<span class="p_add">+				if (img-&gt;stride_plane1 &gt; 0) {</span>
<span class="p_add">+					mif-&gt;mif_ctrl4 =</span>
<span class="p_add">+					    set_bits32(mif-&gt;mif_ctrl4,</span>
<span class="p_add">+						       ((img-&gt;stride_plane1 /</span>
<span class="p_add">+							 MIF_STRIDE_UNIT) +</span>
<span class="p_add">+							(((img-&gt;stride_plane1 %</span>
<span class="p_add">+							   MIF_STRIDE_UNIT) &gt;</span>
<span class="p_add">+							  0) ? 1 : 0)), 20, 0);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				if (img-&gt;stride_plane2 &gt; 0) {</span>
<span class="p_add">+					mif-&gt;mif_ctrl3 =</span>
<span class="p_add">+					    set_bits32(mif-&gt;mif_ctrl3,</span>
<span class="p_add">+						       ((img-&gt;stride_plane2 /</span>
<span class="p_add">+							 MIF_STRIDE_UNIT) +</span>
<span class="p_add">+							(((img-&gt;stride_plane2 %</span>
<span class="p_add">+							   MIF_STRIDE_UNIT) &gt;</span>
<span class="p_add">+							  0) ? 1 : 0)), 20, 0);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else if (invalid_sel == 3) {</span>
<span class="p_add">+			if (img-&gt;stride &gt; 0) {</span>
<span class="p_add">+				mif-&gt;mif_ctrl5 =</span>
<span class="p_add">+				    set_bits32(mif-&gt;mif_ctrl5,</span>
<span class="p_add">+					       DSS_MIF_CTRL2_INVAL_SEL3_STRIDE_MASK, 4, 16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (isYUVSemiPlanar(img-&gt;format)) {</span>
<span class="p_add">+				if (img-&gt;stride_plane1 &gt; 0)</span>
<span class="p_add">+					*semi_plane1 =</span>
<span class="p_add">+					    set_bits32(*semi_plane1, 0xE, 4, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+			} else if (isYUVPlanar(img-&gt;format)) {</span>
<span class="p_add">+				if (img-&gt;stride_plane1 &gt; 0)</span>
<span class="p_add">+					mif-&gt;mif_ctrl3 =</span>
<span class="p_add">+					    set_bits32(mif-&gt;mif_ctrl3, 0xE, 4, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (img-&gt;stride_plane2 &gt; 0)</span>
<span class="p_add">+					mif-&gt;mif_ctrl4 =</span>
<span class="p_add">+					    set_bits32(mif-&gt;mif_ctrl4, 0xE, 4, 16);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, invalid_sel(%d) not support!\n&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, invalid_sel);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS RDMA</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_rdma_init(char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_dma, 0, sizeof(dss_rdma_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;oft_x0 = inp32(dma_base + DMA_OFT_X0);</span>
<span class="p_add">+	s_dma-&gt;oft_y0 = inp32(dma_base + DMA_OFT_Y0);</span>
<span class="p_add">+	s_dma-&gt;oft_x1 = inp32(dma_base + DMA_OFT_X1);</span>
<span class="p_add">+	s_dma-&gt;oft_y1 = inp32(dma_base + DMA_OFT_Y1);</span>
<span class="p_add">+	s_dma-&gt;mask0 = inp32(dma_base + DMA_MASK0);</span>
<span class="p_add">+	s_dma-&gt;mask1 = inp32(dma_base + DMA_MASK1);</span>
<span class="p_add">+	s_dma-&gt;stretch_size_vrt = inp32(dma_base + DMA_STRETCH_SIZE_VRT);</span>
<span class="p_add">+	s_dma-&gt;ctrl = inp32(dma_base + DMA_CTRL);</span>
<span class="p_add">+	s_dma-&gt;tile_scram = inp32(dma_base + DMA_TILE_SCRAM);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;ch_rd_shadow = inp32(dma_base + CH_RD_SHADOW);</span>
<span class="p_add">+	s_dma-&gt;ch_ctl = inp32(dma_base + CH_CTL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;data_addr0 = inp32(dma_base + DMA_DATA_ADDR0);</span>
<span class="p_add">+	s_dma-&gt;stride0 = inp32(dma_base + DMA_STRIDE0);</span>
<span class="p_add">+	s_dma-&gt;stretch_stride0 = inp32(dma_base + DMA_STRETCH_STRIDE0);</span>
<span class="p_add">+	s_dma-&gt;data_num0 = inp32(dma_base + DMA_DATA_NUM0);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;vpp_ctrl = inp32(dma_base + VPP_CTRL);</span>
<span class="p_add">+	s_dma-&gt;vpp_mem_ctrl = inp32(dma_base + VPP_MEM_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;dma_buf_ctrl = inp32(dma_base + DMA_BUF_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;afbcd_hreg_hdr_ptr_lo = inp32(dma_base + AFBCD_HREG_HDR_PTR_LO);</span>
<span class="p_add">+	s_dma-&gt;afbcd_hreg_pic_width = inp32(dma_base + AFBCD_HREG_PIC_WIDTH);</span>
<span class="p_add">+	s_dma-&gt;afbcd_hreg_pic_height = inp32(dma_base + AFBCD_HREG_PIC_HEIGHT);</span>
<span class="p_add">+	s_dma-&gt;afbcd_hreg_format = inp32(dma_base + AFBCD_HREG_FORMAT);</span>
<span class="p_add">+	s_dma-&gt;afbcd_ctl = inp32(dma_base + AFBCD_CTL);</span>
<span class="p_add">+	s_dma-&gt;afbcd_str = inp32(dma_base + AFBCD_STR);</span>
<span class="p_add">+	s_dma-&gt;afbcd_line_crop = inp32(dma_base + AFBCD_LINE_CROP);</span>
<span class="p_add">+	s_dma-&gt;afbcd_input_header_stride =</span>
<span class="p_add">+	    inp32(dma_base + AFBCD_INPUT_HEADER_STRIDE);</span>
<span class="p_add">+	s_dma-&gt;afbcd_payload_stride = inp32(dma_base + AFBCD_PAYLOAD_STRIDE);</span>
<span class="p_add">+	s_dma-&gt;afbcd_mm_base_0 = inp32(dma_base + AFBCD_MM_BASE_0);</span>
<span class="p_add">+	s_dma-&gt;afbcd_afbcd_payload_pointer =</span>
<span class="p_add">+	    inp32(dma_base + AFBCD_AFBCD_PAYLOAD_POINTER);</span>
<span class="p_add">+	s_dma-&gt;afbcd_height_bf_str = inp32(dma_base + AFBCD_HEIGHT_BF_STR);</span>
<span class="p_add">+	s_dma-&gt;afbcd_os_cfg = inp32(dma_base + AFBCD_OS_CFG);</span>
<span class="p_add">+	s_dma-&gt;afbcd_mem_ctrl = inp32(dma_base + AFBCD_MEM_CTRL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_rdma_u_init(char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;data_addr1 = inp32(dma_base + DMA_DATA_ADDR1);</span>
<span class="p_add">+	s_dma-&gt;stride1 = inp32(dma_base + DMA_STRIDE1);</span>
<span class="p_add">+	s_dma-&gt;stretch_stride1 = inp32(dma_base + DMA_STRETCH_STRIDE1);</span>
<span class="p_add">+	s_dma-&gt;data_num1 = inp32(dma_base + DMA_DATA_NUM1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_rdma_v_init(char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dma-&gt;data_addr2 = inp32(dma_base + DMA_DATA_ADDR2);</span>
<span class="p_add">+	s_dma-&gt;stride2 = inp32(dma_base + DMA_STRIDE2);</span>
<span class="p_add">+	s_dma-&gt;stretch_stride2 = inp32(dma_base + DMA_STRETCH_STRIDE2);</span>
<span class="p_add">+	s_dma-&gt;data_num2 = inp32(dma_base + DMA_DATA_NUM2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_chn_set_reg_default_value(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					char __iomem *dma_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_REG_DEFAULT, 0x1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_REG_DEFAULT, 0x0, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_rdma_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				  char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_REG_DEFAULT, 0x1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_REG_DEFAULT, 0x0, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_OFT_X0, s_dma-&gt;oft_x0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_OFT_Y0, s_dma-&gt;oft_y0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_OFT_X1, s_dma-&gt;oft_x1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_OFT_Y1, s_dma-&gt;oft_y1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_MASK0, s_dma-&gt;mask0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_MASK1, s_dma-&gt;mask1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRETCH_SIZE_VRT,</span>
<span class="p_add">+			s_dma-&gt;stretch_size_vrt, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_CTRL, s_dma-&gt;ctrl, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_TILE_SCRAM, s_dma-&gt;tile_scram,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_DATA_ADDR0, s_dma-&gt;data_addr0,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRIDE0, s_dma-&gt;stride0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRETCH_STRIDE0,</span>
<span class="p_add">+			s_dma-&gt;stretch_stride0, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_RD_SHADOW, s_dma-&gt;ch_rd_shadow,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + CH_CTL, s_dma-&gt;ch_ctl, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_dma-&gt;vpp_used) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + VPP_CTRL, s_dma-&gt;vpp_ctrl,</span>
<span class="p_add">+				32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_BUF_CTRL, s_dma-&gt;dma_buf_ctrl,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_dma-&gt;afbc_used) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HREG_HDR_PTR_LO,</span>
<span class="p_add">+				s_dma-&gt;afbcd_hreg_hdr_ptr_lo, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HREG_PIC_WIDTH,</span>
<span class="p_add">+				s_dma-&gt;afbcd_hreg_pic_width, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HREG_PIC_HEIGHT,</span>
<span class="p_add">+				s_dma-&gt;afbcd_hreg_pic_height, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HREG_FORMAT,</span>
<span class="p_add">+				s_dma-&gt;afbcd_hreg_format, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_CTL, s_dma-&gt;afbcd_ctl,</span>
<span class="p_add">+				32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_STR, s_dma-&gt;afbcd_str,</span>
<span class="p_add">+				32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_LINE_CROP,</span>
<span class="p_add">+				s_dma-&gt;afbcd_line_crop, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_INPUT_HEADER_STRIDE,</span>
<span class="p_add">+				s_dma-&gt;afbcd_input_header_stride, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_PAYLOAD_STRIDE,</span>
<span class="p_add">+				s_dma-&gt;afbcd_payload_stride, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_MM_BASE_0,</span>
<span class="p_add">+				s_dma-&gt;afbcd_mm_base_0, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_AFBCD_PAYLOAD_POINTER,</span>
<span class="p_add">+				s_dma-&gt;afbcd_afbcd_payload_pointer, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HEIGHT_BF_STR,</span>
<span class="p_add">+				s_dma-&gt;afbcd_height_bf_str, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_OS_CFG,</span>
<span class="p_add">+				s_dma-&gt;afbcd_os_cfg, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_SCRAMBLE_MODE,</span>
<span class="p_add">+				s_dma-&gt;afbcd_scramble_mode, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, dma_base + AFBCD_HEADER_POINTER_OFFSET,</span>
<span class="p_add">+				s_dma-&gt;afbcd_header_pointer_offset, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_rdma_u_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				    char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_DATA_ADDR1, s_dma-&gt;data_addr1,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRIDE1, s_dma-&gt;stride1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRETCH_STRIDE1,</span>
<span class="p_add">+			s_dma-&gt;stretch_stride1, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_rdma_v_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				    char __iomem *dma_base, dss_rdma_t *s_dma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_DATA_ADDR2, s_dma-&gt;data_addr2,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRIDE2, s_dma-&gt;stride2, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dma_base + DMA_STRETCH_STRIDE2,</span>
<span class="p_add">+			s_dma-&gt;stretch_stride2, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_get_rdma_tile_interleave(uint32_t stride)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	uint32_t interleave[MAX_TILE_SURPORT_NUM] = {</span>
<span class="p_add">+		256, 512, 1024, 2048, 4096, 8192,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_TILE_SURPORT_NUM; i++) {</span>
<span class="p_add">+		if (interleave[i] == stride)</span>
<span class="p_add">+			return MIN_INTERLEAVE + i;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_rdma_config(struct hisi_fb_data_type *hisifd, int ovl_idx,</span>
<span class="p_add">+			 dss_layer_t *layer, dss_rect_ltrb_t *clip_rect,</span>
<span class="p_add">+			 dss_rect_t *out_aligned_rect,</span>
<span class="p_add">+			 bool *rdma_stretch_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_rdma_t *dma = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	bool mmu_enable = false;</span>
<span class="p_add">+	bool is_yuv_semi_planar = false;</span>
<span class="p_add">+	bool is_yuv_planar = false;</span>
<span class="p_add">+	bool src_rect_mask_enable = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint32_t rdma_addr = 0;</span>
<span class="p_add">+	uint32_t rdma_stride = 0;</span>
<span class="p_add">+	int rdma_format = 0;</span>
<span class="p_add">+	int rdma_transform = 0;</span>
<span class="p_add">+	int rdma_data_num = 0;</span>
<span class="p_add">+	uint32_t stretch_size_vrt = 0;</span>
<span class="p_add">+	uint32_t stretched_line_num = 0;</span>
<span class="p_add">+	uint32_t stretched_stride = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	int bpp = 0;</span>
<span class="p_add">+	int aligned_pixel = 0;</span>
<span class="p_add">+	int rdma_oft_x0 = 0;</span>
<span class="p_add">+	int rdma_oft_y0 = 0;</span>
<span class="p_add">+	int rdma_oft_x1 = 0;</span>
<span class="p_add">+	int rdma_oft_y1 = 0;</span>
<span class="p_add">+	int rdma_mask_x0 = 0;</span>
<span class="p_add">+	int rdma_mask_y0 = 0;</span>
<span class="p_add">+	int rdma_mask_x1 = 0;</span>
<span class="p_add">+	int rdma_mask_y1 = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	uint32_t l2t_interleave_n = 0;</span>
<span class="p_add">+	dss_rect_ltrb_t aligned_rect = { 0, 0, 0, 0 };</span>
<span class="p_add">+	dss_rect_ltrb_t aligned_mask_rect = { 0, 0, 0, 0 };</span>
<span class="p_add">+	dss_rect_t new_src_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint32_t afbcd_half_block_mode = 0;</span>
<span class="p_add">+	uint32_t afbcd_stretch_acc = 0;</span>
<span class="p_add">+	uint32_t afbcd_stretch_inc = 0;</span>
<span class="p_add">+	uint32_t afbcd_height_bf_str = 0;</span>
<span class="p_add">+	uint32_t afbcd_top_crop_num = 0;</span>
<span class="p_add">+	uint32_t afbcd_bottom_crop_num = 0;</span>
<span class="p_add">+	uint32_t afbc_header_addr = 0;</span>
<span class="p_add">+	uint32_t afbc_header_stride = 0;</span>
<span class="p_add">+	uint32_t afbc_payload_addr = 0;</span>
<span class="p_add">+	uint32_t afbc_payload_stride = 0;</span>
<span class="p_add">+	uint32_t afbc_header_start_pos = 0;</span>
<span class="p_add">+	uint32_t afbc_header_pointer_offset = 0;</span>
<span class="p_add">+	uint32_t stride_align = 0;</span>
<span class="p_add">+	uint32_t addr_align = 0;</span>
<span class="p_add">+	dss_rect_ltrb_t afbc_rect;</span>
<span class="p_add">+	uint32_t mm_base_0 = 0;</span>
<span class="p_add">+	uint32_t mm_base_1 = 0;</span>
<span class="p_add">+	bool mm_alloc_needed = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	new_src_rect = layer-&gt;src_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	stretched_line_num = isNeedRdmaStretchBlt(hisifd, layer);</span>
<span class="p_add">+	*rdma_stretch_enable = (stretched_line_num &gt; 0) ? true : false;</span>
<span class="p_add">+</span>
<span class="p_add">+	mmu_enable = (layer-&gt;img.mmu_enable == 1) ? true : false;</span>
<span class="p_add">+	is_yuv_semi_planar = isYUVSemiPlanar(layer-&gt;img.format);</span>
<span class="p_add">+	is_yuv_planar = isYUVPlanar(layer-&gt;img.format);</span>
<span class="p_add">+</span>
<span class="p_add">+	rdma_format = hisi_pixel_format_hal2dma(layer-&gt;img.format);</span>
<span class="p_add">+	if (rdma_format &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer format(%d) not support !\n&quot;,</span>
<span class="p_add">+			    layer-&gt;img.format);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rdma_transform = hisi_transform_hal2dma(layer-&gt;transform, chn_idx);</span>
<span class="p_add">+	if (rdma_transform &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer transform(%d) not support!\n&quot;,</span>
<span class="p_add">+			    layer-&gt;transform);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bpp = (is_yuv_semi_planar || is_yuv_planar) ? 1 : layer-&gt;img.bpp;</span>
<span class="p_add">+	aligned_pixel = DMA_ALIGN_BYTES / bpp;</span>
<span class="p_add">+</span>
<span class="p_add">+	src_rect_mask_enable = isSrcRectMasked(layer, aligned_pixel);</span>
<span class="p_add">+</span>
<span class="p_add">+	dma = &amp;(hisifd-&gt;dss_module.rdma[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.dma_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_YUV_DEINTERLACE) {</span>
<span class="p_add">+		dma-&gt;vpp_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+			dma-&gt;vpp_ctrl = set_bits32(dma-&gt;vpp_ctrl, 0x2, 2, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			dma-&gt;vpp_ctrl = set_bits32(dma-&gt;vpp_ctrl, 0x3, 2, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCD) {</span>
<span class="p_add">+		if ((layer-&gt;img.mmbuf_base &gt; 0) &amp;&amp; (layer-&gt;img.mmbuf_size &gt; 0)) {</span>
<span class="p_add">+			mm_base_0 = layer-&gt;img.mmbuf_base;</span>
<span class="p_add">+			mm_base_1 =</span>
<span class="p_add">+			    layer-&gt;img.mmbuf_base + layer-&gt;img.mmbuf_size / 2;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			BUG_ON(hisifd-&gt;mmbuf_info == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ovl_idx &lt;= DSS_OVL1) {</span>
<span class="p_add">+				mm_alloc_needed = true;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (hisifd-&gt;mmbuf_info-&gt;mm_used[chn_idx] == 1)</span>
<span class="p_add">+					mm_alloc_needed = false;</span>
<span class="p_add">+				else</span>
<span class="p_add">+					mm_alloc_needed = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (mm_alloc_needed) {</span>
<span class="p_add">+				afbc_rect.left =</span>
<span class="p_add">+				    ALIGN_DOWN(new_src_rect.x,</span>
<span class="p_add">+					       MMBUF_ADDR_ALIGN);</span>
<span class="p_add">+				afbc_rect.right =</span>
<span class="p_add">+				    ALIGN_UP(new_src_rect.x - afbc_rect.left +</span>
<span class="p_add">+					     new_src_rect.w, MMBUF_ADDR_ALIGN);</span>
<span class="p_add">+				hisifd-&gt;mmbuf_info-&gt;mm_size[chn_idx] =</span>
<span class="p_add">+				    afbc_rect.right * layer-&gt;img.bpp *</span>
<span class="p_add">+				    MMBUF_LINE_NUM;</span>
<span class="p_add">+				hisifd-&gt;mmbuf_info-&gt;mm_base[chn_idx] =</span>
<span class="p_add">+				    hisi_dss_mmbuf_alloc(g_mmbuf_gen_pool,</span>
<span class="p_add">+							 hisifd-&gt;mmbuf_info-&gt;mm_size[chn_idx]);</span>
<span class="p_add">+				if (hisifd-&gt;mmbuf_info-&gt;mm_base[chn_idx] &lt;</span>
<span class="p_add">+				    MMBUF_BASE) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, chn%d failed to alloc mmbuf, mm_base=0x%x.\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, chn_idx,</span>
<span class="p_add">+					     hisifd-&gt;mmbuf_info-&gt;mm_base[chn_idx]);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			mm_base_0 = hisifd-&gt;mmbuf_info-&gt;mm_base[chn_idx];</span>
<span class="p_add">+			mm_base_1 = hisifd-&gt;mmbuf_info-&gt;mm_base[chn_idx] +</span>
<span class="p_add">+			    hisifd-&gt;mmbuf_info-&gt;mm_size[chn_idx] / 2;</span>
<span class="p_add">+			hisifd-&gt;mmbuf_info-&gt;mm_used[chn_idx] = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mm_base_0 -= MMBUF_BASE;</span>
<span class="p_add">+		mm_base_1 -= MMBUF_BASE;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((layer-&gt;img.width &amp; (AFBC_HEADER_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (layer-&gt;img.height &amp; (AFBC_BLOCK_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d img width(%d) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;img heigh(%d) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, layer-&gt;img.width,</span>
<span class="p_add">+			     AFBC_HEADER_ADDR_ALIGN, layer-&gt;img.height,</span>
<span class="p_add">+			     AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((mm_base_0 &amp; (MMBUF_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (mm_base_1 &amp; (MMBUF_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (layer-&gt;img.mmbuf_size &amp; (MMBUF_ADDR_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d mm_base_0(0x%x) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;mm_base_1(0x%x) is not %d bytes aligned, or mmbuf_size(0x%x) is &quot;</span>
<span class="p_add">+			     &quot;not %d bytes aligned!\n&quot;, layer-&gt;layer_idx,</span>
<span class="p_add">+			     mm_base_0, MMBUF_ADDR_ALIGN, mm_base_1,</span>
<span class="p_add">+			     MMBUF_ADDR_ALIGN, layer-&gt;img.mmbuf_size,</span>
<span class="p_add">+			     MMBUF_ADDR_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dma-&gt;afbc_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		aligned_rect.left =</span>
<span class="p_add">+		    ALIGN_DOWN(new_src_rect.x, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+		aligned_rect.right =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.x + new_src_rect.w,</span>
<span class="p_add">+			     AFBC_BLOCK_ALIGN) - 1;</span>
<span class="p_add">+		aligned_rect.top = ALIGN_DOWN(new_src_rect.y, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+		aligned_rect.bottom =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.y + new_src_rect.h,</span>
<span class="p_add">+			     AFBC_BLOCK_ALIGN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		out_aligned_rect-&gt;x = 0;</span>
<span class="p_add">+		out_aligned_rect-&gt;y = 0;</span>
<span class="p_add">+		out_aligned_rect-&gt;w =</span>
<span class="p_add">+		    aligned_rect.right - aligned_rect.left + 1;</span>
<span class="p_add">+		out_aligned_rect-&gt;h =</span>
<span class="p_add">+		    aligned_rect.bottom - aligned_rect.top + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbcd_height_bf_str =</span>
<span class="p_add">+		    aligned_rect.bottom - aligned_rect.top + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (*rdma_stretch_enable) {</span>
<span class="p_add">+			afbcd_stretch_inc = 0;</span>
<span class="p_add">+			afbcd_stretch_acc = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			out_aligned_rect-&gt;h /= 2;</span>
<span class="p_add">+			if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_FLIP_V) {</span>
<span class="p_add">+				afbcd_half_block_mode =</span>
<span class="p_add">+				    AFBC_HALF_BLOCK_LOWER_ONLY;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				afbcd_half_block_mode =</span>
<span class="p_add">+				    AFBC_HALF_BLOCK_UPPER_ONLY;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_FLIP_V) {</span>
<span class="p_add">+				afbcd_half_block_mode =</span>
<span class="p_add">+				    AFBC_HALF_BLOCK_LOWER_UPPER_ALL;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				afbcd_half_block_mode =</span>
<span class="p_add">+				    AFBC_HALF_BLOCK_UPPER_LOWER_ALL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;img.</span>
<span class="p_add">+		    afbc_header_addr &amp; (AFBC_SUPER_GRAPH_HEADER_ADDR_ALIGN -</span>
<span class="p_add">+					1)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d super graph afbc_header_addr(0x%x) &quot;</span>
<span class="p_add">+			     &quot;is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, afbc_header_addr,</span>
<span class="p_add">+			     AFBC_SUPER_GRAPH_HEADER_ADDR_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		clip_rect-&gt;left = new_src_rect.x - aligned_rect.left;</span>
<span class="p_add">+		clip_rect-&gt;right =</span>
<span class="p_add">+		    aligned_rect.right - DSS_WIDTH(new_src_rect.x +</span>
<span class="p_add">+						   new_src_rect.w);</span>
<span class="p_add">+		clip_rect-&gt;top = new_src_rect.y - aligned_rect.top;</span>
<span class="p_add">+		clip_rect-&gt;bottom =</span>
<span class="p_add">+		    aligned_rect.bottom - DSS_HEIGHT(new_src_rect.y +</span>
<span class="p_add">+						     new_src_rect.h);</span>
<span class="p_add">+		if (hisi_adjust_clip_rect(layer, clip_rect) &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;clip rect invalid =&gt; layer_idx=%d, chn_idx=%d, &quot;</span>
<span class="p_add">+			     &quot;clip_rect(%d, %d, %d, %d).\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, chn_idx, clip_rect-&gt;left,</span>
<span class="p_add">+			     clip_rect-&gt;right, clip_rect-&gt;top,</span>
<span class="p_add">+			     clip_rect-&gt;bottom);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		afbcd_top_crop_num = (clip_rect-&gt;top &gt; AFBCD_TOP_CROP_MAX) ?</span>
<span class="p_add">+		    AFBCD_TOP_CROP_MAX : clip_rect-&gt;top;</span>
<span class="p_add">+		afbcd_bottom_crop_num =</span>
<span class="p_add">+		    (clip_rect-&gt;bottom &gt;</span>
<span class="p_add">+		     AFBCD_BOTTOM_CROP_MAX) ? AFBCD_BOTTOM_CROP_MAX :</span>
<span class="p_add">+		    clip_rect-&gt;bottom;</span>
<span class="p_add">+</span>
<span class="p_add">+		clip_rect-&gt;top -= afbcd_top_crop_num;</span>
<span class="p_add">+		BUG_ON(clip_rect-&gt;top &lt; 0);</span>
<span class="p_add">+		clip_rect-&gt;bottom -= afbcd_bottom_crop_num;</span>
<span class="p_add">+		BUG_ON(clip_rect-&gt;bottom &lt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		out_aligned_rect-&gt;h -=</span>
<span class="p_add">+		    (afbcd_top_crop_num + afbcd_bottom_crop_num);</span>
<span class="p_add">+</span>
<span class="p_add">+		rdma_oft_x0 = aligned_rect.left / aligned_pixel;</span>
<span class="p_add">+		rdma_oft_x1 = aligned_rect.right / aligned_pixel;</span>
<span class="p_add">+		stretch_size_vrt = DSS_HEIGHT(out_aligned_rect-&gt;h);</span>
<span class="p_add">+		stretched_line_num = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_rect = aligned_rect;</span>
<span class="p_add">+		afbc_rect.left =</span>
<span class="p_add">+		    ALIGN_DOWN(new_src_rect.x, AFBC_HEADER_ADDR_ALIGN);</span>
<span class="p_add">+		afbc_rect.right =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.x + new_src_rect.w,</span>
<span class="p_add">+			     AFBC_HEADER_ADDR_ALIGN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_header_stride =</span>
<span class="p_add">+		    (layer-&gt;img.width / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    AFBC_HEADER_STRIDE_BLOCK;</span>
<span class="p_add">+		afbc_header_pointer_offset =</span>
<span class="p_add">+		    (afbc_rect.top / AFBC_BLOCK_ALIGN) * afbc_header_stride +</span>
<span class="p_add">+		    (afbc_rect.left / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    AFBC_HEADER_STRIDE_BLOCK;</span>
<span class="p_add">+		afbc_header_addr =</span>
<span class="p_add">+		    layer-&gt;img.afbc_header_addr + afbc_header_pointer_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((afbc_header_addr &amp; (AFBC_HEADER_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (afbc_header_stride &amp; (AFBC_HEADER_STRIDE_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d afbc_header_addr(0x%x) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;afbc_header_stride(0x%x) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, afbc_header_addr,</span>
<span class="p_add">+			     AFBC_HEADER_ADDR_ALIGN, afbc_header_stride,</span>
<span class="p_add">+			     AFBC_HEADER_STRIDE_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON((aligned_rect.left - afbc_rect.left) &lt; 0);</span>
<span class="p_add">+		afbc_header_start_pos =</span>
<span class="p_add">+		    (aligned_rect.left - afbc_rect.left) / AFBC_BLOCK_ALIGN;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;img.bpp == 4) {</span>
<span class="p_add">+			stride_align = AFBC_PAYLOAD_STRIDE_ALIGN_32;</span>
<span class="p_add">+			addr_align = AFBC_PAYLOAD_ADDR_ALIGN_32;</span>
<span class="p_add">+		} else if (layer-&gt;img.bpp == 2) {</span>
<span class="p_add">+			stride_align = AFBC_PAYLOAD_STRIDE_ALIGN_16;</span>
<span class="p_add">+			addr_align = AFBC_PAYLOAD_ADDR_ALIGN_16;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;bpp(%d) not supported!\n&quot;, layer-&gt;img.bpp);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_payload_stride = layer-&gt;img.afbc_payload_stride;</span>
<span class="p_add">+		if (layer-&gt;img.afbc_scramble_mode != DSS_AFBC_SCRAMBLE_MODE2) {</span>
<span class="p_add">+			afbc_payload_stride =</span>
<span class="p_add">+			    (layer-&gt;img.width / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+			    stride_align;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		afbc_payload_addr = layer-&gt;img.afbc_payload_addr +</span>
<span class="p_add">+		    (aligned_rect.top / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    afbc_payload_stride +</span>
<span class="p_add">+		    (aligned_rect.left / AFBC_BLOCK_ALIGN) * stride_align;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((afbc_payload_addr &amp; (addr_align - 1)) ||</span>
<span class="p_add">+		    (afbc_payload_stride &amp; (stride_align - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d afbc_payload_addr(0x%x) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;afbc_payload_stride(0x%x) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, afbc_payload_addr, addr_align,</span>
<span class="p_add">+			     afbc_payload_stride, stride_align);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+			HISI_FB_INFO</span>
<span class="p_add">+			    (&quot;fb%d, mm_base_0=0x%x, mm_base_1=0x%x, mmbuf_size=%d, &quot;</span>
<span class="p_add">+			     &quot;aligned_rect(%d,%d,%d,%d), afbc_rect(%d,%d,%d,%d)!\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, mm_base_0, mm_base_1,</span>
<span class="p_add">+			     layer-&gt;img.mmbuf_size, aligned_rect.left,</span>
<span class="p_add">+			     aligned_rect.top, aligned_rect.right,</span>
<span class="p_add">+			     aligned_rect.bottom, afbc_rect.left, afbc_rect.top,</span>
<span class="p_add">+			     afbc_rect.right, afbc_rect.bottom);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dma-&gt;oft_x0 = set_bits32(dma-&gt;oft_x0, rdma_oft_x0, 16, 0);</span>
<span class="p_add">+		dma-&gt;oft_x1 = set_bits32(dma-&gt;oft_x1, rdma_oft_x1, 16, 0);</span>
<span class="p_add">+		dma-&gt;stretch_size_vrt = set_bits32(dma-&gt;stretch_size_vrt,</span>
<span class="p_add">+						   (stretch_size_vrt |</span>
<span class="p_add">+						    (stretched_line_num &lt;&lt; 13)),</span>
<span class="p_add">+						   19, 0);</span>
<span class="p_add">+		dma-&gt;ctrl = set_bits32(dma-&gt;ctrl, rdma_format, 5, 3);</span>
<span class="p_add">+		dma-&gt;ctrl =</span>
<span class="p_add">+		    set_bits32(dma-&gt;ctrl, (mmu_enable ? 0x1 : 0x0), 1, 8);</span>
<span class="p_add">+		dma-&gt;ctrl = set_bits32(dma-&gt;ctrl, rdma_transform, 3, 9);</span>
<span class="p_add">+		dma-&gt;ctrl =</span>
<span class="p_add">+		    set_bits32(dma-&gt;ctrl, (*rdma_stretch_enable ? 1 : 0), 1,</span>
<span class="p_add">+			       12);</span>
<span class="p_add">+		dma-&gt;ch_ctl = set_bits32(dma-&gt;ch_ctl, 0x1, 1, 0);</span>
<span class="p_add">+		dma-&gt;ch_ctl = set_bits32(dma-&gt;ch_ctl, 0x1, 1, 2);</span>
<span class="p_add">+</span>
<span class="p_add">+		dma-&gt;afbcd_hreg_pic_width =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_hreg_pic_width,</span>
<span class="p_add">+			       (aligned_rect.right - aligned_rect.left), 16, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_hreg_pic_height =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_hreg_pic_height,</span>
<span class="p_add">+			       (aligned_rect.bottom - aligned_rect.top), 16, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_hreg_format =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_hreg_format, 0x1, 1, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_hreg_format =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_hreg_format,</span>
<span class="p_add">+			       (isYUVPackage(layer-&gt;img.format) ? 0x0 : 0x1), 1,</span>
<span class="p_add">+			       21);</span>
<span class="p_add">+		dma-&gt;afbcd_ctl =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_ctl, afbcd_half_block_mode, 2, 6);</span>
<span class="p_add">+		dma-&gt;afbcd_str =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_str,</span>
<span class="p_add">+			       (afbcd_stretch_acc &lt;&lt; 8 | afbcd_stretch_inc), 12,</span>
<span class="p_add">+			       0);</span>
<span class="p_add">+		dma-&gt;afbcd_line_crop =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_line_crop,</span>
<span class="p_add">+			       (afbcd_top_crop_num &lt;&lt; 4 |</span>
<span class="p_add">+				afbcd_bottom_crop_num), 8, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_hreg_hdr_ptr_lo =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_hreg_hdr_ptr_lo, afbc_header_addr, 32,</span>
<span class="p_add">+			       0);</span>
<span class="p_add">+		dma-&gt;afbcd_input_header_stride =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_input_header_stride,</span>
<span class="p_add">+			       (afbc_header_start_pos &lt;&lt; 14) |</span>
<span class="p_add">+			       afbc_header_stride, 16, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_payload_stride =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_payload_stride, afbc_payload_stride,</span>
<span class="p_add">+			       20, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_mm_base_0 =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_mm_base_0, mm_base_0, 32, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_afbcd_payload_pointer =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_afbcd_payload_pointer,</span>
<span class="p_add">+			       afbc_payload_addr, 32, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_height_bf_str =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_height_bf_str,</span>
<span class="p_add">+			       DSS_HEIGHT(afbcd_height_bf_str), 16, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_header_pointer_offset =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_header_pointer_offset,</span>
<span class="p_add">+			       afbc_header_pointer_offset, 32, 0);</span>
<span class="p_add">+		dma-&gt;afbcd_scramble_mode =</span>
<span class="p_add">+		    set_bits32(dma-&gt;afbcd_scramble_mode,</span>
<span class="p_add">+			       layer-&gt;img.afbc_scramble_mode, 2, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rdma_addr = mmu_enable ? layer-&gt;img.vir_addr : layer-&gt;img.phy_addr;</span>
<span class="p_add">+	if (rdma_addr &amp; (DMA_ADDR_ALIGN - 1)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;layer%d rdma_addr(0x%x) is not %d bytes aligned.\n&quot;,</span>
<span class="p_add">+		     layer-&gt;layer_idx, rdma_addr, DMA_ADDR_ALIGN);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;img.stride &amp; (DMA_STRIDE_ALIGN - 1)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer%d stride(0x%x) is not %d bytes aligned.\n&quot;,</span>
<span class="p_add">+			    layer-&gt;layer_idx, layer-&gt;img.stride,</span>
<span class="p_add">+			    DMA_STRIDE_ALIGN);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_TILE) {</span>
<span class="p_add">+		l2t_interleave_n =</span>
<span class="p_add">+		    hisi_get_rdma_tile_interleave(layer-&gt;img.stride);</span>
<span class="p_add">+		if (l2t_interleave_n &lt; MIN_INTERLEAVE) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;tile stride should be 256*2^n, error stride:%d!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;img.stride);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (rdma_addr &amp; (TILE_DMA_ADDR_ALIGN - 1)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;layer%d tile rdma_addr(0x%x) is not %d bytes aligned.\n&quot;,</span>
<span class="p_add">+			     layer-&gt;layer_idx, rdma_addr, TILE_DMA_ADDR_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_YUV_P_420(layer-&gt;img.format) || is_YUV_P_422(layer-&gt;img.format)) {</span>
<span class="p_add">+		aligned_rect.left =</span>
<span class="p_add">+		    ALIGN_DOWN(new_src_rect.x, 2 * aligned_pixel);</span>
<span class="p_add">+		aligned_rect.right =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.x + new_src_rect.w,</span>
<span class="p_add">+			     2 * aligned_pixel) - 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		aligned_rect.left = ALIGN_DOWN(new_src_rect.x, aligned_pixel);</span>
<span class="p_add">+		aligned_rect.right =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.x + new_src_rect.w,</span>
<span class="p_add">+			     aligned_pixel) - 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_YUV_SP_420(layer-&gt;img.format) || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+		aligned_rect.top = ALIGN_DOWN(new_src_rect.y, 2);</span>
<span class="p_add">+		aligned_rect.bottom =</span>
<span class="p_add">+		    ALIGN_UP(new_src_rect.y + new_src_rect.h, 2) - 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		aligned_rect.top = new_src_rect.y;</span>
<span class="p_add">+		aligned_rect.bottom =</span>
<span class="p_add">+		    DSS_HEIGHT(new_src_rect.y + new_src_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (src_rect_mask_enable) {</span>
<span class="p_add">+		if (is_YUV_P_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_422(layer-&gt;img.format)) {</span>
<span class="p_add">+			aligned_mask_rect.left =</span>
<span class="p_add">+			    ALIGN_UP(layer-&gt;src_rect_mask.x, 2 * aligned_pixel);</span>
<span class="p_add">+			aligned_mask_rect.right =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;src_rect_mask.x +</span>
<span class="p_add">+				       layer-&gt;src_rect_mask.w,</span>
<span class="p_add">+				       2 * aligned_pixel) - 1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			aligned_mask_rect.left =</span>
<span class="p_add">+			    ALIGN_UP(layer-&gt;src_rect_mask.x, aligned_pixel);</span>
<span class="p_add">+			aligned_mask_rect.right =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;src_rect_mask.x +</span>
<span class="p_add">+				       layer-&gt;src_rect_mask.w,</span>
<span class="p_add">+				       aligned_pixel) - 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+			aligned_mask_rect.top =</span>
<span class="p_add">+			    ALIGN_UP(layer-&gt;src_rect_mask.y, 2);</span>
<span class="p_add">+			aligned_mask_rect.bottom =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;src_rect_mask.y +</span>
<span class="p_add">+				       layer-&gt;src_rect_mask.h, 2) - 1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			aligned_mask_rect.top = layer-&gt;src_rect_mask.y;</span>
<span class="p_add">+			aligned_mask_rect.bottom =</span>
<span class="p_add">+			    DSS_HEIGHT(layer-&gt;src_rect_mask.y +</span>
<span class="p_add">+				       layer-&gt;src_rect_mask.h);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	out_aligned_rect-&gt;x = 0;</span>
<span class="p_add">+	out_aligned_rect-&gt;y = 0;</span>
<span class="p_add">+	out_aligned_rect-&gt;w = aligned_rect.right - aligned_rect.left + 1;</span>
<span class="p_add">+	out_aligned_rect-&gt;h = aligned_rect.bottom - aligned_rect.top + 1;</span>
<span class="p_add">+	if (stretched_line_num &gt; 0) {</span>
<span class="p_add">+		stretch_size_vrt = (out_aligned_rect-&gt;h / stretched_line_num) +</span>
<span class="p_add">+		    ((out_aligned_rect-&gt;h % stretched_line_num) ? 1 : 0) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		out_aligned_rect-&gt;h = stretch_size_vrt + 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		stretch_size_vrt = 0x0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	clip_rect-&gt;left = new_src_rect.x - aligned_rect.left;</span>
<span class="p_add">+	clip_rect-&gt;right =</span>
<span class="p_add">+	    aligned_rect.right - DSS_WIDTH(new_src_rect.x + new_src_rect.w);</span>
<span class="p_add">+	clip_rect-&gt;top = new_src_rect.y - aligned_rect.top;</span>
<span class="p_add">+	clip_rect-&gt;bottom =</span>
<span class="p_add">+	    aligned_rect.bottom - DSS_HEIGHT(new_src_rect.y + new_src_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisi_adjust_clip_rect(layer, clip_rect) &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;clip rect invalid =&gt; layer_idx=%d, chn_idx=%d, &quot;</span>
<span class="p_add">+		     &quot;clip_rect(%d, %d, %d, %d).\n&quot;,</span>
<span class="p_add">+		     layer-&gt;layer_idx, chn_idx, clip_rect-&gt;left,</span>
<span class="p_add">+		     clip_rect-&gt;right, clip_rect-&gt;top, clip_rect-&gt;bottom);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rdma_oft_y0 = aligned_rect.top;</span>
<span class="p_add">+	rdma_oft_y1 = aligned_rect.bottom;</span>
<span class="p_add">+	rdma_oft_x0 = aligned_rect.left / aligned_pixel;</span>
<span class="p_add">+	rdma_oft_x1 = aligned_rect.right / aligned_pixel;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((rdma_oft_x1 - rdma_oft_x0) &lt; 0 ||</span>
<span class="p_add">+	    (rdma_oft_x1 - rdma_oft_x0 + 1) &gt; DMA_IN_WIDTH_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;out of range, rdma_oft_x0 = %d, rdma_oft_x1 = %d!\n&quot;,</span>
<span class="p_add">+		     rdma_oft_x0, rdma_oft_x1);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((rdma_oft_y1 - rdma_oft_y0) &lt; 0 ||</span>
<span class="p_add">+	    (rdma_oft_y1 - rdma_oft_y0 + 1) &gt; DMA_IN_HEIGHT_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;out of range, rdma_oft_y0 = %d, rdma_oft_y1 = %d\n&quot;,</span>
<span class="p_add">+		     rdma_oft_y0, rdma_oft_y1);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rdma_addr =</span>
<span class="p_add">+	    hisi_calculate_display_addr(mmu_enable, layer, &amp;aligned_rect,</span>
<span class="p_add">+					DSS_ADDR_PLANE0);</span>
<span class="p_add">+	rdma_stride = layer-&gt;img.stride;</span>
<span class="p_add">+	rdma_data_num =</span>
<span class="p_add">+	    (rdma_oft_x1 - rdma_oft_x0 + 1) * (rdma_oft_y1 - rdma_oft_y0 + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (src_rect_mask_enable) {</span>
<span class="p_add">+		rdma_mask_y0 = aligned_mask_rect.top;</span>
<span class="p_add">+		rdma_mask_y1 = aligned_mask_rect.bottom;</span>
<span class="p_add">+		rdma_mask_x0 = aligned_mask_rect.left / aligned_pixel;</span>
<span class="p_add">+		rdma_mask_x1 = aligned_mask_rect.right / aligned_pixel;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((rdma_mask_x1 - rdma_mask_x0) &gt; 2)</span>
<span class="p_add">+			rdma_mask_x0 += 2;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((rdma_mask_x0 &lt;= rdma_oft_x0)</span>
<span class="p_add">+		    || (rdma_mask_x1 &gt;= rdma_oft_x1)</span>
<span class="p_add">+		    || (rdma_mask_y0 &lt;= rdma_oft_y0)</span>
<span class="p_add">+		    || (rdma_mask_y1 &gt;= rdma_oft_y1)) {</span>
<span class="p_add">+			src_rect_mask_enable = false;</span>
<span class="p_add">+			rdma_mask_x0 = 0;</span>
<span class="p_add">+			rdma_mask_y0 = 0;</span>
<span class="p_add">+			rdma_mask_x1 = 0;</span>
<span class="p_add">+			rdma_mask_y1 = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (stretched_line_num &gt; 0) {</span>
<span class="p_add">+		stretched_stride =</span>
<span class="p_add">+		    stretched_line_num * rdma_stride / DMA_ALIGN_BYTES;</span>
<span class="p_add">+		rdma_data_num =</span>
<span class="p_add">+		    (stretch_size_vrt + 1) * (rdma_oft_x1 - rdma_oft_x0 + 1);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		stretch_size_vrt = rdma_oft_y1 - rdma_oft_y0;</span>
<span class="p_add">+		stretched_line_num = 0x0;</span>
<span class="p_add">+		stretched_stride = 0x0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dma-&gt;oft_x0 = set_bits32(dma-&gt;oft_x0, rdma_oft_x0, 16, 0);</span>
<span class="p_add">+	dma-&gt;oft_y0 = set_bits32(dma-&gt;oft_y0, rdma_oft_y0, 16, 0);</span>
<span class="p_add">+	dma-&gt;oft_x1 = set_bits32(dma-&gt;oft_x1, rdma_oft_x1, 16, 0);</span>
<span class="p_add">+	dma-&gt;oft_y1 = set_bits32(dma-&gt;oft_y1, rdma_oft_y1, 16, 0);</span>
<span class="p_add">+	dma-&gt;mask0 = set_bits32(dma-&gt;mask0,</span>
<span class="p_add">+				(rdma_mask_y0 | (rdma_mask_x0 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	dma-&gt;mask1 = set_bits32(dma-&gt;mask1,</span>
<span class="p_add">+				(rdma_mask_y1 | (rdma_mask_x1 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	dma-&gt;stretch_size_vrt = set_bits32(dma-&gt;stretch_size_vrt,</span>
<span class="p_add">+					   (stretch_size_vrt |</span>
<span class="p_add">+					    (stretched_line_num &lt;&lt; 13)), 19, 0);</span>
<span class="p_add">+	dma-&gt;ctrl =</span>
<span class="p_add">+	    set_bits32(dma-&gt;ctrl, ((layer-&gt;need_cap &amp; CAP_TILE) ? 0x1 : 0x0), 1,</span>
<span class="p_add">+		       1);</span>
<span class="p_add">+	dma-&gt;ctrl = set_bits32(dma-&gt;ctrl, rdma_format, 5, 3);</span>
<span class="p_add">+	dma-&gt;ctrl = set_bits32(dma-&gt;ctrl, (mmu_enable ? 0x1 : 0x0), 1, 8);</span>
<span class="p_add">+	dma-&gt;ctrl = set_bits32(dma-&gt;ctrl, rdma_transform, 3, 9);</span>
<span class="p_add">+	dma-&gt;ctrl =</span>
<span class="p_add">+	    set_bits32(dma-&gt;ctrl, ((stretched_line_num &gt; 0) ? 0x1 : 0x0), 1,</span>
<span class="p_add">+		       12);</span>
<span class="p_add">+	dma-&gt;ctrl =</span>
<span class="p_add">+	    set_bits32(dma-&gt;ctrl, (src_rect_mask_enable ? 0x1 : 0x0), 1, 17);</span>
<span class="p_add">+	dma-&gt;tile_scram =</span>
<span class="p_add">+	    set_bits32(dma-&gt;tile_scram,</span>
<span class="p_add">+		       ((layer-&gt;need_cap &amp; CAP_TILE) ? 0x1 : 0x0), 1, 0);</span>
<span class="p_add">+	dma-&gt;ch_ctl = set_bits32(dma-&gt;ch_ctl, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	dma-&gt;data_addr0 = set_bits32(dma-&gt;data_addr0, rdma_addr, 32, 0);</span>
<span class="p_add">+	dma-&gt;stride0 = set_bits32(dma-&gt;stride0,</span>
<span class="p_add">+				  ((rdma_stride /</span>
<span class="p_add">+				    DMA_ALIGN_BYTES) | (l2t_interleave_n &lt;&lt;</span>
<span class="p_add">+							16)), 20, 0);</span>
<span class="p_add">+	dma-&gt;stretch_stride0 =</span>
<span class="p_add">+	    set_bits32(dma-&gt;stretch_stride0, stretched_stride, 19, 0);</span>
<span class="p_add">+	dma-&gt;data_num0 = set_bits32(dma-&gt;data_num0, rdma_data_num, 30, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_yuv_semi_planar || is_yuv_planar) {</span>
<span class="p_add">+		if (is_YUV_P_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_422(layer-&gt;img.format)) {</span>
<span class="p_add">+			rdma_oft_x0 /= 2;</span>
<span class="p_add">+			rdma_oft_x1 = (rdma_oft_x1 + 1) / 2 - 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;img.format)</span>
<span class="p_add">+		    || is_YUV_P_420(layer-&gt;img.format)) {</span>
<span class="p_add">+			rdma_oft_y0 /= 2;</span>
<span class="p_add">+			rdma_oft_y1 = (rdma_oft_y1 + 1) / 2 - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			stretched_line_num /= 2;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		rdma_addr =</span>
<span class="p_add">+		    hisi_calculate_display_addr(mmu_enable, layer,</span>
<span class="p_add">+						&amp;aligned_rect, DSS_ADDR_PLANE1);</span>
<span class="p_add">+		rdma_stride = layer-&gt;img.stride_plane1;</span>
<span class="p_add">+		rdma_data_num =</span>
<span class="p_add">+		    (rdma_oft_x1 - rdma_oft_x0 + 1) * (rdma_oft_y1 -</span>
<span class="p_add">+						       rdma_oft_y0 + 1) * 2;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (*rdma_stretch_enable) {</span>
<span class="p_add">+			stretched_stride =</span>
<span class="p_add">+			    stretched_line_num * rdma_stride / DMA_ALIGN_BYTES;</span>
<span class="p_add">+			rdma_data_num =</span>
<span class="p_add">+			    (stretch_size_vrt + 1) * (rdma_oft_x1 -</span>
<span class="p_add">+						      rdma_oft_x0 + 1) * 2;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			stretch_size_vrt = 0;</span>
<span class="p_add">+			stretched_line_num = 0;</span>
<span class="p_add">+			stretched_stride = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dma-&gt;data_addr1 = set_bits32(dma-&gt;data_addr1, rdma_addr, 32, 0);</span>
<span class="p_add">+		dma-&gt;stride1 = set_bits32(dma-&gt;stride1,</span>
<span class="p_add">+					  ((rdma_stride /</span>
<span class="p_add">+					    DMA_ALIGN_BYTES) | (l2t_interleave_n &lt;&lt; 16)), 20, 0);</span>
<span class="p_add">+		dma-&gt;stretch_stride1 =</span>
<span class="p_add">+		    set_bits32(dma-&gt;stretch_stride1, stretched_stride, 19, 0);</span>
<span class="p_add">+		dma-&gt;data_num1 =</span>
<span class="p_add">+		    set_bits32(dma-&gt;data_num1, rdma_data_num, 30, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_yuv_planar) {</span>
<span class="p_add">+			rdma_addr =</span>
<span class="p_add">+			    hisi_calculate_display_addr(mmu_enable, layer,</span>
<span class="p_add">+							&amp;aligned_rect,</span>
<span class="p_add">+							DSS_ADDR_PLANE2);</span>
<span class="p_add">+			rdma_stride = layer-&gt;img.stride_plane2;</span>
<span class="p_add">+</span>
<span class="p_add">+			dma-&gt;data_addr2 =</span>
<span class="p_add">+			    set_bits32(dma-&gt;data_addr2, rdma_addr, 32, 0);</span>
<span class="p_add">+			dma-&gt;stride2 =</span>
<span class="p_add">+			    set_bits32(dma-&gt;stride2,</span>
<span class="p_add">+				       ((rdma_stride /</span>
<span class="p_add">+					     DMA_ALIGN_BYTES) | (l2t_interleave_n &lt;&lt; 16)), 20, 0);</span>
<span class="p_add">+			dma-&gt;stretch_stride2 =</span>
<span class="p_add">+			    set_bits32(dma-&gt;stretch_stride1, stretched_stride,</span>
<span class="p_add">+				       19, 0);</span>
<span class="p_add">+			dma-&gt;data_num2 =</span>
<span class="p_add">+			    set_bits32(dma-&gt;data_num1, rdma_data_num, 30, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS DFC</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_dfc_init(char __iomem *dfc_base, dss_dfc_t *s_dfc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(dfc_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dfc == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_dfc, 0, sizeof(dss_dfc_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_dfc-&gt;disp_size = inp32(dfc_base + DFC_DISP_SIZE);</span>
<span class="p_add">+	s_dfc-&gt;pix_in_num = inp32(dfc_base + DFC_PIX_IN_NUM);</span>
<span class="p_add">+	s_dfc-&gt;disp_fmt = inp32(dfc_base + DFC_DISP_FMT);</span>
<span class="p_add">+	s_dfc-&gt;clip_ctl_hrz = inp32(dfc_base + DFC_CLIP_CTL_HRZ);</span>
<span class="p_add">+	s_dfc-&gt;clip_ctl_vrz = inp32(dfc_base + DFC_CLIP_CTL_VRZ);</span>
<span class="p_add">+	s_dfc-&gt;ctl_clip_en = inp32(dfc_base + DFC_CTL_CLIP_EN);</span>
<span class="p_add">+	s_dfc-&gt;icg_module = inp32(dfc_base + DFC_ICG_MODULE);</span>
<span class="p_add">+	s_dfc-&gt;dither_enable = inp32(dfc_base + DFC_DITHER_ENABLE);</span>
<span class="p_add">+	s_dfc-&gt;padding_ctl = inp32(dfc_base + DFC_PADDING_CTL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_dfc_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				 char __iomem *dfc_base, dss_dfc_t *s_dfc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dfc_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dfc == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_DISP_SIZE, s_dfc-&gt;disp_size, 32,</span>
<span class="p_add">+			0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_PIX_IN_NUM, s_dfc-&gt;pix_in_num,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_DISP_FMT, s_dfc-&gt;disp_fmt, 32,</span>
<span class="p_add">+			0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_CLIP_CTL_HRZ,</span>
<span class="p_add">+			s_dfc-&gt;clip_ctl_hrz, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_CLIP_CTL_VRZ,</span>
<span class="p_add">+			s_dfc-&gt;clip_ctl_vrz, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_CTL_CLIP_EN, s_dfc-&gt;ctl_clip_en,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_ICG_MODULE, s_dfc-&gt;icg_module,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_DITHER_ENABLE,</span>
<span class="p_add">+			s_dfc-&gt;dither_enable, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dfc_base + DFC_PADDING_CTL, s_dfc-&gt;padding_ctl,</span>
<span class="p_add">+			32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_rdfc_config(struct hisi_fb_data_type *hisifd, dss_layer_t *layer,</span>
<span class="p_add">+			 dss_rect_t *aligned_rect, dss_rect_ltrb_t clip_rect)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_dfc_t *dfc = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	int dfc_fmt = 0;</span>
<span class="p_add">+	int dfc_bpp = 0;</span>
<span class="p_add">+	int dfc_pix_in_num = 0;</span>
<span class="p_add">+	int dfc_aligned = 0;</span>
<span class="p_add">+	int size_hrz = 0;</span>
<span class="p_add">+	int size_vrt = 0;</span>
<span class="p_add">+	int dfc_hrz_clip = 0;</span>
<span class="p_add">+	bool need_clip = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc = &amp;(hisifd-&gt;dss_module.dfc[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.dfc_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_fmt = hisi_pixel_format_hal2dfc(layer-&gt;img.format);</span>
<span class="p_add">+	if (dfc_fmt &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer format (%d) not support !\n&quot;,</span>
<span class="p_add">+			    layer-&gt;img.format);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_bpp = hisi_dfc_get_bpp(dfc_fmt);</span>
<span class="p_add">+	if (dfc_bpp &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;dfc_bpp(%d) not support !\n&quot;, dfc_bpp);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_pix_in_num = (dfc_bpp &lt;= 2) ? 0x1 : 0x0;</span>
<span class="p_add">+	dfc_aligned = (dfc_bpp &lt;= 2) ? 4 : 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	need_clip = isNeedRectClip(clip_rect);</span>
<span class="p_add">+</span>
<span class="p_add">+	size_hrz = DSS_WIDTH(aligned_rect-&gt;w);</span>
<span class="p_add">+	size_vrt = DSS_HEIGHT(aligned_rect-&gt;h);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((size_hrz + 1) % dfc_aligned) != 0) {</span>
<span class="p_add">+		size_hrz -= 1;</span>
<span class="p_add">+		HISI_FB_ERR(&quot;SIZE_HRT=%d mismatch!bpp=%d\n&quot;, size_hrz,</span>
<span class="p_add">+			    layer-&gt;img.bpp);</span>
<span class="p_add">+</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer_idx%d, format=%d, transform=%d, &quot;</span>
<span class="p_add">+			    &quot;original_src_rect(%d,%d,%d,%d), rdma_out_rect(%d,%d,%d,%d), &quot;</span>
<span class="p_add">+			    &quot;dst_rect(%d,%d,%d,%d)!\n&quot;,</span>
<span class="p_add">+			    layer-&gt;layer_idx, layer-&gt;img.format,</span>
<span class="p_add">+			    layer-&gt;transform, layer-&gt;src_rect.x,</span>
<span class="p_add">+			    layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+			    layer-&gt;src_rect.h, aligned_rect-&gt;x, aligned_rect-&gt;y,</span>
<span class="p_add">+			    aligned_rect-&gt;w, aligned_rect-&gt;h, layer-&gt;dst_rect.x,</span>
<span class="p_add">+			    layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+			    layer-&gt;dst_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_hrz_clip = (size_hrz + 1) % dfc_aligned;</span>
<span class="p_add">+	if (dfc_hrz_clip) {</span>
<span class="p_add">+		clip_rect.right += dfc_hrz_clip;</span>
<span class="p_add">+		size_hrz += dfc_hrz_clip;</span>
<span class="p_add">+		need_clip = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc-&gt;disp_size =</span>
<span class="p_add">+	    set_bits32(dfc-&gt;disp_size, (size_vrt | (size_hrz &lt;&lt; 16)), 29, 0);</span>
<span class="p_add">+	dfc-&gt;pix_in_num = set_bits32(dfc-&gt;pix_in_num, dfc_pix_in_num, 1, 0);</span>
<span class="p_add">+	dfc-&gt;disp_fmt = set_bits32(dfc-&gt;disp_fmt,</span>
<span class="p_add">+				   ((dfc_fmt &lt;&lt; 1) |</span>
<span class="p_add">+				    (hisi_uv_swap(layer-&gt;img.format) &lt;&lt; 6) |</span>
<span class="p_add">+				    (hisi_rb_swap(layer-&gt;img.format) &lt;&lt; 7)), 8, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (need_clip) {</span>
<span class="p_add">+		dfc-&gt;clip_ctl_hrz = set_bits32(dfc-&gt;clip_ctl_hrz,</span>
<span class="p_add">+					       (clip_rect.right | (clip_rect.left &lt;&lt; 16)),</span>
<span class="p_add">+					       32, 0);</span>
<span class="p_add">+		dfc-&gt;clip_ctl_vrz =</span>
<span class="p_add">+		    set_bits32(dfc-&gt;clip_ctl_vrz,</span>
<span class="p_add">+			       (clip_rect.bottom | (clip_rect.top &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+		dfc-&gt;ctl_clip_en = set_bits32(dfc-&gt;ctl_clip_en, 0x1, 1, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dfc-&gt;clip_ctl_hrz = set_bits32(dfc-&gt;clip_ctl_hrz, 0x0, 32, 0);</span>
<span class="p_add">+		dfc-&gt;clip_ctl_vrz = set_bits32(dfc-&gt;clip_ctl_vrz, 0x0, 32, 0);</span>
<span class="p_add">+		dfc-&gt;ctl_clip_en = set_bits32(dfc-&gt;ctl_clip_en, 0x1, 1, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dfc-&gt;icg_module = set_bits32(dfc-&gt;icg_module, 0x1, 1, 0);</span>
<span class="p_add">+	dfc-&gt;dither_enable = set_bits32(dfc-&gt;dither_enable, 0x0, 1, 0);</span>
<span class="p_add">+	dfc-&gt;padding_ctl = set_bits32(dfc-&gt;padding_ctl, 0x0, 17, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (need_clip) {</span>
<span class="p_add">+		aligned_rect-&gt;w -= (clip_rect.left + clip_rect.right);</span>
<span class="p_add">+		aligned_rect-&gt;h -= (clip_rect.top + clip_rect.bottom);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS SCF</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/* Filter coefficients for SCF */</span>
<span class="p_add">+#define PHASE_NUM	(66)</span>
<span class="p_add">+#define TAP4	(4)</span>
<span class="p_add">+#define TAP5	(5)</span>
<span class="p_add">+#define TAP6	(6)</span>
<span class="p_add">+#define COEF_LUT_NUM	(2)</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_LUT_TAP4[SCL_COEF_IDX_MAX][PHASE_NUM][TAP4] = {</span>
<span class="p_add">+	/* YUV_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {214, 599, 214, -3},</span>
<span class="p_add">+	 {207, 597, 223, -3},</span>
<span class="p_add">+	 {200, 596, 231, -3},</span>
<span class="p_add">+	 {193, 596, 238, -3},</span>
<span class="p_add">+	 {186, 595, 246, -3},</span>
<span class="p_add">+	 {178, 594, 255, -3},</span>
<span class="p_add">+	 {171, 593, 263, -3},</span>
<span class="p_add">+	 {165, 591, 271, -3},</span>
<span class="p_add">+	 {158, 589, 279, -2},</span>
<span class="p_add">+	 {151, 587, 288, -2},</span>
<span class="p_add">+	 {145, 584, 296, -1},</span>
<span class="p_add">+	 {139, 582, 304, -1},</span>
<span class="p_add">+	 {133, 578, 312, 1},</span>
<span class="p_add">+	 {127, 575, 321, 1},</span>
<span class="p_add">+	 {121, 572, 329, 2},</span>
<span class="p_add">+	 {115, 568, 337, 4},</span>
<span class="p_add">+	 {109, 564, 346, 5},</span>
<span class="p_add">+	 {104, 560, 354, 6},</span>
<span class="p_add">+	 {98, 555, 362, 9},</span>
<span class="p_add">+	 {94, 550, 370, 10},</span>
<span class="p_add">+	 {88, 546, 379, 11},</span>
<span class="p_add">+	 {84, 540, 387, 13},</span>
<span class="p_add">+	 {79, 535, 395, 15},</span>
<span class="p_add">+	 {74, 530, 403, 17},</span>
<span class="p_add">+	 {70, 524, 411, 19},</span>
<span class="p_add">+	 {66, 518, 419, 21},</span>
<span class="p_add">+	 {62, 512, 427, 23},</span>
<span class="p_add">+	 {57, 506, 435, 26},</span>
<span class="p_add">+	 {54, 499, 443, 28},</span>
<span class="p_add">+	 {50, 492, 451, 31},</span>
<span class="p_add">+	 {47, 486, 457, 34},</span>
<span class="p_add">+	 {43, 479, 465, 37},</span>
<span class="p_add">+	 {40, 472, 472, 40},</span>
<span class="p_add">+	 {214, 599, 214, -3},</span>
<span class="p_add">+	 {207, 597, 223, -3},</span>
<span class="p_add">+	 {200, 596, 231, -3},</span>
<span class="p_add">+	 {193, 596, 238, -3},</span>
<span class="p_add">+	 {186, 595, 246, -3},</span>
<span class="p_add">+	 {178, 594, 255, -3},</span>
<span class="p_add">+	 {171, 593, 263, -3},</span>
<span class="p_add">+	 {165, 591, 271, -3},</span>
<span class="p_add">+	 {158, 589, 279, -2},</span>
<span class="p_add">+	 {151, 587, 288, -2},</span>
<span class="p_add">+	 {145, 584, 296, -1},</span>
<span class="p_add">+	 {139, 582, 304, -1},</span>
<span class="p_add">+	 {133, 578, 312, 1},</span>
<span class="p_add">+	 {127, 575, 321, 1},</span>
<span class="p_add">+	 {121, 572, 329, 2},</span>
<span class="p_add">+	 {115, 568, 337, 4},</span>
<span class="p_add">+	 {109, 564, 346, 5},</span>
<span class="p_add">+	 {104, 560, 354, 6},</span>
<span class="p_add">+	 {98, 555, 362, 9},</span>
<span class="p_add">+	 {94, 550, 370, 10},</span>
<span class="p_add">+	 {88, 546, 379, 11},</span>
<span class="p_add">+	 {84, 540, 387, 13},</span>
<span class="p_add">+	 {79, 535, 395, 15},</span>
<span class="p_add">+	 {74, 530, 403, 17},</span>
<span class="p_add">+	 {70, 524, 411, 19},</span>
<span class="p_add">+	 {66, 518, 419, 21},</span>
<span class="p_add">+	 {62, 512, 427, 23},</span>
<span class="p_add">+	 {57, 506, 435, 26},</span>
<span class="p_add">+	 {54, 499, 443, 28},</span>
<span class="p_add">+	 {50, 492, 451, 31},</span>
<span class="p_add">+	 {47, 486, 457, 34},</span>
<span class="p_add">+	 {43, 479, 465, 37},</span>
<span class="p_add">+	 {40, 472, 472, 40}</span>
<span class="p_add">+	 },</span>
<span class="p_add">+</span>
<span class="p_add">+	/* RGB_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {0, 1024, 0, 0},</span>
<span class="p_add">+	 {0, 1008, 16, 0},</span>
<span class="p_add">+	 {0, 992, 32, 0},</span>
<span class="p_add">+	 {0, 976, 48, 0},</span>
<span class="p_add">+	 {0, 960, 64, 0},</span>
<span class="p_add">+	 {0, 944, 80, 0},</span>
<span class="p_add">+	 {0, 928, 96, 0},</span>
<span class="p_add">+	 {0, 912, 112, 0},</span>
<span class="p_add">+	 {0, 896, 128, 0},</span>
<span class="p_add">+	 {0, 880, 144, 0},</span>
<span class="p_add">+	 {0, 864, 160, 0},</span>
<span class="p_add">+	 {0, 848, 176, 0},</span>
<span class="p_add">+	 {0, 832, 192, 0},</span>
<span class="p_add">+	 {0, 816, 208, 0},</span>
<span class="p_add">+	 {0, 800, 224, 0},</span>
<span class="p_add">+	 {0, 784, 240, 0},</span>
<span class="p_add">+	 {0, 768, 256, 0},</span>
<span class="p_add">+	 {0, 752, 272, 0},</span>
<span class="p_add">+	 {0, 736, 288, 0},</span>
<span class="p_add">+	 {0, 720, 304, 0},</span>
<span class="p_add">+	 {0, 704, 320, 0},</span>
<span class="p_add">+	 {0, 688, 336, 0},</span>
<span class="p_add">+	 {0, 672, 352, 0},</span>
<span class="p_add">+	 {0, 656, 368, 0},</span>
<span class="p_add">+	 {0, 640, 384, 0},</span>
<span class="p_add">+	 {0, 624, 400, 0},</span>
<span class="p_add">+	 {0, 608, 416, 0},</span>
<span class="p_add">+	 {0, 592, 432, 0},</span>
<span class="p_add">+	 {0, 576, 448, 0},</span>
<span class="p_add">+	 {0, 560, 464, 0},</span>
<span class="p_add">+	 {0, 544, 480, 0},</span>
<span class="p_add">+	 {0, 528, 496, 0},</span>
<span class="p_add">+	 {0, 512, 512, 0},</span>
<span class="p_add">+	 {0, 1024, 0, 0},</span>
<span class="p_add">+	 {0, 1008, 16, 0},</span>
<span class="p_add">+	 {0, 992, 32, 0},</span>
<span class="p_add">+	 {0, 976, 48, 0},</span>
<span class="p_add">+	 {0, 960, 64, 0},</span>
<span class="p_add">+	 {0, 944, 80, 0},</span>
<span class="p_add">+	 {0, 928, 96, 0},</span>
<span class="p_add">+	 {0, 912, 112, 0},</span>
<span class="p_add">+	 {0, 896, 128, 0},</span>
<span class="p_add">+	 {0, 880, 144, 0},</span>
<span class="p_add">+	 {0, 864, 160, 0},</span>
<span class="p_add">+	 {0, 848, 176, 0},</span>
<span class="p_add">+	 {0, 832, 192, 0},</span>
<span class="p_add">+	 {0, 816, 208, 0},</span>
<span class="p_add">+	 {0, 800, 224, 0},</span>
<span class="p_add">+	 {0, 784, 240, 0},</span>
<span class="p_add">+	 {0, 768, 256, 0},</span>
<span class="p_add">+	 {0, 752, 272, 0},</span>
<span class="p_add">+	 {0, 736, 288, 0},</span>
<span class="p_add">+	 {0, 720, 304, 0},</span>
<span class="p_add">+	 {0, 704, 320, 0},</span>
<span class="p_add">+	 {0, 688, 336, 0},</span>
<span class="p_add">+	 {0, 672, 352, 0},</span>
<span class="p_add">+	 {0, 656, 368, 0},</span>
<span class="p_add">+	 {0, 640, 384, 0},</span>
<span class="p_add">+	 {0, 624, 400, 0},</span>
<span class="p_add">+	 {0, 608, 416, 0},</span>
<span class="p_add">+	 {0, 592, 432, 0},</span>
<span class="p_add">+	 {0, 576, 448, 0},</span>
<span class="p_add">+	 {0, 560, 464, 0},</span>
<span class="p_add">+	 {0, 544, 480, 0},</span>
<span class="p_add">+	 {0, 528, 496, 0},</span>
<span class="p_add">+	 {0, 512, 512, 0}</span>
<span class="p_add">+	 }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_LUT_TAP5[SCL_COEF_IDX_MAX][PHASE_NUM][TAP5] = {</span>
<span class="p_add">+	/* YUV_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {98, 415, 415, 98, -2},</span>
<span class="p_add">+	 {95, 412, 418, 103, -4},</span>
<span class="p_add">+	 {91, 408, 422, 107, -4},</span>
<span class="p_add">+	 {87, 404, 426, 111, -4},</span>
<span class="p_add">+	 {84, 399, 430, 115, -4},</span>
<span class="p_add">+	 {80, 395, 434, 119, -4},</span>
<span class="p_add">+	 {76, 390, 438, 124, -4},</span>
<span class="p_add">+	 {73, 386, 440, 128, -3},</span>
<span class="p_add">+	 {70, 381, 444, 132, -3},</span>
<span class="p_add">+	 {66, 376, 448, 137, -3},</span>
<span class="p_add">+	 {63, 371, 451, 142, -3},</span>
<span class="p_add">+	 {60, 366, 455, 146, -3},</span>
<span class="p_add">+	 {57, 361, 457, 151, -2},</span>
<span class="p_add">+	 {54, 356, 460, 156, -2},</span>
<span class="p_add">+	 {51, 351, 463, 161, -2},</span>
<span class="p_add">+	 {49, 346, 465, 165, -1},</span>
<span class="p_add">+	 {46, 341, 468, 170, -1},</span>
<span class="p_add">+	 {43, 336, 470, 175, 0},</span>
<span class="p_add">+	 {41, 331, 472, 180, 0},</span>
<span class="p_add">+	 {38, 325, 474, 186, 1},</span>
<span class="p_add">+	 {36, 320, 476, 191, 1},</span>
<span class="p_add">+	 {34, 315, 477, 196, 2},</span>
<span class="p_add">+	 {32, 309, 479, 201, 3},</span>
<span class="p_add">+	 {29, 304, 481, 206, 4},</span>
<span class="p_add">+	 {27, 299, 481, 212, 5},</span>
<span class="p_add">+	 {26, 293, 482, 217, 6},</span>
<span class="p_add">+	 {24, 288, 484, 222, 6},</span>
<span class="p_add">+	 {22, 282, 484, 228, 8},</span>
<span class="p_add">+	 {20, 277, 485, 233, 9},</span>
<span class="p_add">+	 {19, 271, 485, 238, 11},</span>
<span class="p_add">+	 {17, 266, 485, 244, 12},</span>
<span class="p_add">+	 {16, 260, 485, 250, 13},</span>
<span class="p_add">+	 {14, 255, 486, 255, 14},</span>
<span class="p_add">+	 {-94, 608, 608, -94, -4},</span>
<span class="p_add">+	 {-94, 594, 619, -91, -4},</span>
<span class="p_add">+	 {-96, 579, 635, -89, -5},</span>
<span class="p_add">+	 {-96, 563, 650, -87, -6},</span>
<span class="p_add">+	 {-97, 548, 665, -85, -7},</span>
<span class="p_add">+	 {-97, 532, 678, -82, -7},</span>
<span class="p_add">+	 {-98, 516, 693, -79, -8},</span>
<span class="p_add">+	 {-97, 500, 705, -75, -9},</span>
<span class="p_add">+	 {-97, 484, 720, -72, -11},</span>
<span class="p_add">+	 {-97, 468, 733, -68, -12},</span>
<span class="p_add">+	 {-96, 452, 744, -63, -13},</span>
<span class="p_add">+	 {-95, 436, 755, -58, -14},</span>
<span class="p_add">+	 {-94, 419, 768, -53, -16},</span>
<span class="p_add">+	 {-93, 403, 779, -48, -17},</span>
<span class="p_add">+	 {-92, 387, 789, -42, -18},</span>
<span class="p_add">+	 {-90, 371, 799, -36, -20},</span>
<span class="p_add">+	 {-89, 355, 809, -29, -22},</span>
<span class="p_add">+	 {-87, 339, 817, -22, -23},</span>
<span class="p_add">+	 {-86, 324, 826, -15, -25},</span>
<span class="p_add">+	 {-84, 308, 835, -8, -27},</span>
<span class="p_add">+	 {-82, 293, 842, 0, -29},</span>
<span class="p_add">+	 {-80, 277, 849, 9, -31},</span>
<span class="p_add">+	 {-78, 262, 855, 18, -33},</span>
<span class="p_add">+	 {-75, 247, 860, 27, -35},</span>
<span class="p_add">+	 {-73, 233, 865, 36, -37},</span>
<span class="p_add">+	 {-71, 218, 870, 46, -39},</span>
<span class="p_add">+	 {-69, 204, 874, 56, -41},</span>
<span class="p_add">+	 {-66, 190, 876, 67, -43},</span>
<span class="p_add">+	 {-64, 176, 879, 78, -45},</span>
<span class="p_add">+	 {-62, 163, 882, 89, -48},</span>
<span class="p_add">+	 {-59, 150, 883, 100, -50},</span>
<span class="p_add">+	 {-57, 137, 883, 112, -51},</span>
<span class="p_add">+	 {-55, 125, 884, 125, -55}</span>
<span class="p_add">+	 },</span>
<span class="p_add">+</span>
<span class="p_add">+	/* RGB_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {0, 512, 512, 0, 0},</span>
<span class="p_add">+	 {0, 496, 528, 0, 0},</span>
<span class="p_add">+	 {0, 480, 544, 0, 0},</span>
<span class="p_add">+	 {0, 464, 560, 0, 0},</span>
<span class="p_add">+	 {0, 448, 576, 0, 0},</span>
<span class="p_add">+	 {0, 432, 592, 0, 0},</span>
<span class="p_add">+	 {0, 416, 608, 0, 0},</span>
<span class="p_add">+	 {0, 400, 624, 0, 0},</span>
<span class="p_add">+	 {0, 384, 640, 0, 0},</span>
<span class="p_add">+	 {0, 368, 656, 0, 0},</span>
<span class="p_add">+	 {0, 352, 672, 0, 0},</span>
<span class="p_add">+	 {0, 336, 688, 0, 0},</span>
<span class="p_add">+	 {0, 320, 704, 0, 0},</span>
<span class="p_add">+	 {0, 304, 720, 0, 0},</span>
<span class="p_add">+	 {0, 288, 736, 0, 0},</span>
<span class="p_add">+	 {0, 272, 752, 0, 0},</span>
<span class="p_add">+	 {0, 256, 768, 0, 0},</span>
<span class="p_add">+	 {0, 240, 784, 0, 0},</span>
<span class="p_add">+	 {0, 224, 800, 0, 0},</span>
<span class="p_add">+	 {0, 208, 816, 0, 0},</span>
<span class="p_add">+	 {0, 192, 832, 0, 0},</span>
<span class="p_add">+	 {0, 176, 848, 0, 0},</span>
<span class="p_add">+	 {0, 160, 864, 0, 0},</span>
<span class="p_add">+	 {0, 144, 880, 0, 0},</span>
<span class="p_add">+	 {0, 128, 896, 0, 0},</span>
<span class="p_add">+	 {0, 112, 912, 0, 0},</span>
<span class="p_add">+	 {0, 96, 928, 0, 0},</span>
<span class="p_add">+	 {0, 80, 944, 0, 0},</span>
<span class="p_add">+	 {0, 64, 960, 0, 0},</span>
<span class="p_add">+	 {0, 48, 976, 0, 0},</span>
<span class="p_add">+	 {0, 32, 992, 0, 0},</span>
<span class="p_add">+	 {0, 16, 1008, 0, 0},</span>
<span class="p_add">+	 {0, 0, 1024, 0, 0},</span>
<span class="p_add">+	 {0, 512, 512, 0, 0},</span>
<span class="p_add">+	 {0, 496, 528, 0, 0},</span>
<span class="p_add">+	 {0, 480, 544, 0, 0},</span>
<span class="p_add">+	 {0, 464, 560, 0, 0},</span>
<span class="p_add">+	 {0, 448, 576, 0, 0},</span>
<span class="p_add">+	 {0, 432, 592, 0, 0},</span>
<span class="p_add">+	 {0, 416, 608, 0, 0},</span>
<span class="p_add">+	 {0, 400, 624, 0, 0},</span>
<span class="p_add">+	 {0, 384, 640, 0, 0},</span>
<span class="p_add">+	 {0, 368, 656, 0, 0},</span>
<span class="p_add">+	 {0, 352, 672, 0, 0},</span>
<span class="p_add">+	 {0, 336, 688, 0, 0},</span>
<span class="p_add">+	 {0, 320, 704, 0, 0},</span>
<span class="p_add">+	 {0, 304, 720, 0, 0},</span>
<span class="p_add">+	 {0, 288, 736, 0, 0},</span>
<span class="p_add">+	 {0, 272, 752, 0, 0},</span>
<span class="p_add">+	 {0, 256, 768, 0, 0},</span>
<span class="p_add">+	 {0, 240, 784, 0, 0},</span>
<span class="p_add">+	 {0, 224, 800, 0, 0},</span>
<span class="p_add">+	 {0, 208, 816, 0, 0},</span>
<span class="p_add">+	 {0, 192, 832, 0, 0},</span>
<span class="p_add">+	 {0, 176, 848, 0, 0},</span>
<span class="p_add">+	 {0, 160, 864, 0, 0},</span>
<span class="p_add">+	 {0, 144, 880, 0, 0},</span>
<span class="p_add">+	 {0, 128, 896, 0, 0},</span>
<span class="p_add">+	 {0, 112, 912, 0, 0},</span>
<span class="p_add">+	 {0, 96, 928, 0, 0},</span>
<span class="p_add">+	 {0, 80, 944, 0, 0},</span>
<span class="p_add">+	 {0, 64, 960, 0, 0},</span>
<span class="p_add">+	 {0, 48, 976, 0, 0},</span>
<span class="p_add">+	 {0, 32, 992, 0, 0},</span>
<span class="p_add">+	 {0, 16, 1008, 0, 0},</span>
<span class="p_add">+	 {0, 0, 1024, 0, 0}</span>
<span class="p_add">+	 }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_LUT_TAP6[SCL_COEF_IDX_MAX][PHASE_NUM][TAP6] = {</span>
<span class="p_add">+	/* YUV_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {2, 264, 500, 264, 2, -8},</span>
<span class="p_add">+	 {2, 257, 499, 268, 6, -8},</span>
<span class="p_add">+	 {1, 252, 498, 274, 8, -9},</span>
<span class="p_add">+	 {-1, 246, 498, 281, 9, -9},</span>
<span class="p_add">+	 {-2, 241, 497, 286, 12, -10},</span>
<span class="p_add">+	 {-3, 235, 497, 292, 13, -10},</span>
<span class="p_add">+	 {-5, 230, 496, 298, 15, -10},</span>
<span class="p_add">+	 {-6, 225, 495, 303, 18, -11},</span>
<span class="p_add">+	 {-7, 219, 494, 309, 20, -11},</span>
<span class="p_add">+	 {-7, 213, 493, 314, 23, -12},</span>
<span class="p_add">+	 {-9, 208, 491, 320, 26, -12},</span>
<span class="p_add">+	 {-10, 203, 490, 325, 28, -12},</span>
<span class="p_add">+	 {-10, 197, 488, 331, 31, -13},</span>
<span class="p_add">+	 {-10, 192, 486, 336, 33, -13},</span>
<span class="p_add">+	 {-12, 186, 485, 342, 36, -13},</span>
<span class="p_add">+	 {-12, 181, 482, 347, 39, -13},</span>
<span class="p_add">+	 {-13, 176, 480, 352, 42, -13},</span>
<span class="p_add">+	 {-14, 171, 478, 358, 45, -14},</span>
<span class="p_add">+	 {-14, 166, 476, 363, 48, -15},</span>
<span class="p_add">+	 {-14, 160, 473, 368, 52, -15},</span>
<span class="p_add">+	 {-14, 155, 470, 373, 55, -15},</span>
<span class="p_add">+	 {-15, 150, 467, 378, 59, -15},</span>
<span class="p_add">+	 {-15, 145, 464, 383, 62, -15},</span>
<span class="p_add">+	 {-16, 141, 461, 388, 65, -15},</span>
<span class="p_add">+	 {-16, 136, 458, 393, 68, -15},</span>
<span class="p_add">+	 {-16, 131, 455, 398, 72, -16},</span>
<span class="p_add">+	 {-16, 126, 451, 402, 77, -16},</span>
<span class="p_add">+	 {-16, 122, 448, 407, 79, -16},</span>
<span class="p_add">+	 {-16, 117, 444, 411, 84, -16},</span>
<span class="p_add">+	 {-17, 113, 441, 416, 87, -16},</span>
<span class="p_add">+	 {-17, 108, 437, 420, 92, -16},</span>
<span class="p_add">+	 {-17, 104, 433, 424, 96, -16},</span>
<span class="p_add">+	 {-17, 100, 429, 429, 100, -17},</span>
<span class="p_add">+	 {-187, 105, 1186, 105, -187, 2},</span>
<span class="p_add">+	 {-182, 86, 1186, 124, -192, 2},</span>
<span class="p_add">+	 {-176, 67, 1185, 143, -197, 2},</span>
<span class="p_add">+	 {-170, 49, 1182, 163, -202, 2},</span>
<span class="p_add">+	 {-166, 32, 1180, 184, -207, 1},</span>
<span class="p_add">+	 {-160, 15, 1176, 204, -212, 1},</span>
<span class="p_add">+	 {-155, -2, 1171, 225, -216, 1},</span>
<span class="p_add">+	 {-149, -18, 1166, 246, -221, 0},</span>
<span class="p_add">+	 {-145, -34, 1160, 268, -225, 0},</span>
<span class="p_add">+	 {-139, -49, 1153, 290, -230, -1},</span>
<span class="p_add">+	 {-134, -63, 1145, 312, -234, -2},</span>
<span class="p_add">+	 {-129, -78, 1137, 334, -238, -2},</span>
<span class="p_add">+	 {-124, -91, 1128, 357, -241, -5},</span>
<span class="p_add">+	 {-119, -104, 1118, 379, -245, -5},</span>
<span class="p_add">+	 {-114, -117, 1107, 402, -248, -6},</span>
<span class="p_add">+	 {-109, -129, 1096, 425, -251, -8},</span>
<span class="p_add">+	 {-104, -141, 1083, 448, -254, -8},</span>
<span class="p_add">+	 {-100, -152, 1071, 471, -257, -9},</span>
<span class="p_add">+	 {-95, -162, 1057, 494, -259, -11},</span>
<span class="p_add">+	 {-90, -172, 1043, 517, -261, -13},</span>
<span class="p_add">+	 {-86, -181, 1028, 540, -263, -14},</span>
<span class="p_add">+	 {-82, -190, 1013, 563, -264, -16},</span>
<span class="p_add">+	 {-77, -199, 997, 586, -265, -18},</span>
<span class="p_add">+	 {-73, -207, 980, 609, -266, -19},</span>
<span class="p_add">+	 {-69, -214, 963, 632, -266, -22},</span>
<span class="p_add">+	 {-65, -221, 945, 655, -266, -24},</span>
<span class="p_add">+	 {-62, -227, 927, 678, -266, -26},</span>
<span class="p_add">+	 {-58, -233, 908, 700, -265, -28},</span>
<span class="p_add">+	 {-54, -238, 889, 722, -264, -31},</span>
<span class="p_add">+	 {-51, -243, 870, 744, -262, -34},</span>
<span class="p_add">+	 {-48, -247, 850, 766, -260, -37},</span>
<span class="p_add">+	 {-45, -251, 829, 787, -257, -39},</span>
<span class="p_add">+	 {-42, -255, 809, 809, -255, -42}</span>
<span class="p_add">+	 },</span>
<span class="p_add">+</span>
<span class="p_add">+	/* RGB_COEF_IDX */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 {0, 0, 1024, 0, 0, 0},</span>
<span class="p_add">+	 {0, 0, 1008, 16, 0, 0},</span>
<span class="p_add">+	 {0, 0, 992, 32, 0, 0},</span>
<span class="p_add">+	 {0, 0, 976, 48, 0, 0},</span>
<span class="p_add">+	 {0, 0, 960, 64, 0, 0},</span>
<span class="p_add">+	 {0, 0, 944, 80, 0, 0},</span>
<span class="p_add">+	 {0, 0, 928, 96, 0, 0},</span>
<span class="p_add">+	 {0, 0, 912, 112, 0, 0},</span>
<span class="p_add">+	 {0, 0, 896, 128, 0, 0},</span>
<span class="p_add">+	 {0, 0, 880, 144, 0, 0},</span>
<span class="p_add">+	 {0, 0, 864, 160, 0, 0},</span>
<span class="p_add">+	 {0, 0, 848, 176, 0, 0},</span>
<span class="p_add">+	 {0, 0, 832, 192, 0, 0},</span>
<span class="p_add">+	 {0, 0, 816, 208, 0, 0},</span>
<span class="p_add">+	 {0, 0, 800, 224, 0, 0},</span>
<span class="p_add">+	 {0, 0, 784, 240, 0, 0},</span>
<span class="p_add">+	 {0, 0, 768, 256, 0, 0},</span>
<span class="p_add">+	 {0, 0, 752, 272, 0, 0},</span>
<span class="p_add">+	 {0, 0, 736, 288, 0, 0},</span>
<span class="p_add">+	 {0, 0, 720, 304, 0, 0},</span>
<span class="p_add">+	 {0, 0, 704, 320, 0, 0},</span>
<span class="p_add">+	 {0, 0, 688, 336, 0, 0},</span>
<span class="p_add">+	 {0, 0, 672, 352, 0, 0},</span>
<span class="p_add">+	 {0, 0, 656, 368, 0, 0},</span>
<span class="p_add">+	 {0, 0, 640, 384, 0, 0},</span>
<span class="p_add">+	 {0, 0, 624, 400, 0, 0},</span>
<span class="p_add">+	 {0, 0, 608, 416, 0, 0},</span>
<span class="p_add">+	 {0, 0, 592, 432, 0, 0},</span>
<span class="p_add">+	 {0, 0, 576, 448, 0, 0},</span>
<span class="p_add">+	 {0, 0, 560, 464, 0, 0},</span>
<span class="p_add">+	 {0, 0, 544, 480, 0, 0},</span>
<span class="p_add">+	 {0, 0, 528, 496, 0, 0},</span>
<span class="p_add">+	 {0, 0, 512, 512, 0, 0},</span>
<span class="p_add">+	 {0, 0, 1024, 0, 0, 0},</span>
<span class="p_add">+	 {0, 0, 1008, 16, 0, 0},</span>
<span class="p_add">+	 {0, 0, 992, 32, 0, 0},</span>
<span class="p_add">+	 {0, 0, 976, 48, 0, 0},</span>
<span class="p_add">+	 {0, 0, 960, 64, 0, 0},</span>
<span class="p_add">+	 {0, 0, 944, 80, 0, 0},</span>
<span class="p_add">+	 {0, 0, 928, 96, 0, 0},</span>
<span class="p_add">+	 {0, 0, 912, 112, 0, 0},</span>
<span class="p_add">+	 {0, 0, 896, 128, 0, 0},</span>
<span class="p_add">+	 {0, 0, 880, 144, 0, 0},</span>
<span class="p_add">+	 {0, 0, 864, 160, 0, 0},</span>
<span class="p_add">+	 {0, 0, 848, 176, 0, 0},</span>
<span class="p_add">+	 {0, 0, 832, 192, 0, 0},</span>
<span class="p_add">+	 {0, 0, 816, 208, 0, 0},</span>
<span class="p_add">+	 {0, 0, 800, 224, 0, 0},</span>
<span class="p_add">+	 {0, 0, 784, 240, 0, 0},</span>
<span class="p_add">+	 {0, 0, 768, 256, 0, 0},</span>
<span class="p_add">+	 {0, 0, 752, 272, 0, 0},</span>
<span class="p_add">+	 {0, 0, 736, 288, 0, 0},</span>
<span class="p_add">+	 {0, 0, 720, 304, 0, 0},</span>
<span class="p_add">+	 {0, 0, 704, 320, 0, 0},</span>
<span class="p_add">+	 {0, 0, 688, 336, 0, 0},</span>
<span class="p_add">+	 {0, 0, 672, 352, 0, 0},</span>
<span class="p_add">+	 {0, 0, 656, 368, 0, 0},</span>
<span class="p_add">+	 {0, 0, 640, 384, 0, 0},</span>
<span class="p_add">+	 {0, 0, 624, 400, 0, 0},</span>
<span class="p_add">+	 {0, 0, 608, 416, 0, 0},</span>
<span class="p_add">+	 {0, 0, 592, 432, 0, 0},</span>
<span class="p_add">+	 {0, 0, 576, 448, 0, 0},</span>
<span class="p_add">+	 {0, 0, 560, 464, 0, 0},</span>
<span class="p_add">+	 {0, 0, 544, 480, 0, 0},</span>
<span class="p_add">+	 {0, 0, 528, 496, 0, 0},</span>
<span class="p_add">+	 {0, 0, 512, 512, 0, 0}</span>
<span class="p_add">+	 }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_scl_init(char __iomem *scl_base, dss_scl_t *s_scl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(scl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_scl == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_scl, 0, sizeof(dss_scl_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_scl-&gt;en_hscl_str = inp32(scl_base + SCF_EN_HSCL_STR);</span>
<span class="p_add">+	s_scl-&gt;en_vscl_str = inp32(scl_base + SCF_EN_VSCL_STR);</span>
<span class="p_add">+	s_scl-&gt;h_v_order = inp32(scl_base + SCF_H_V_ORDER);</span>
<span class="p_add">+	s_scl-&gt;input_width_height = inp32(scl_base + SCF_INPUT_WIDTH_HEIGHT);</span>
<span class="p_add">+	s_scl-&gt;output_width_height = inp32(scl_base + SCF_OUTPUT_WIDTH_HEIGHT);</span>
<span class="p_add">+	s_scl-&gt;en_hscl = inp32(scl_base + SCF_EN_HSCL);</span>
<span class="p_add">+	s_scl-&gt;en_vscl = inp32(scl_base + SCF_EN_VSCL);</span>
<span class="p_add">+	s_scl-&gt;acc_hscl = inp32(scl_base + SCF_ACC_HSCL);</span>
<span class="p_add">+	s_scl-&gt;inc_hscl = inp32(scl_base + SCF_INC_HSCL);</span>
<span class="p_add">+	s_scl-&gt;inc_vscl = inp32(scl_base + SCF_INC_VSCL);</span>
<span class="p_add">+	s_scl-&gt;en_mmp = inp32(scl_base + SCF_EN_MMP);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_scl_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			  char __iomem *scl_base, dss_scl_t *s_scl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(scl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_scl == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_EN_HSCL_STR,</span>
<span class="p_add">+				s_scl-&gt;en_hscl_str, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_EN_VSCL_STR,</span>
<span class="p_add">+				s_scl-&gt;en_vscl_str, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_H_V_ORDER,</span>
<span class="p_add">+				s_scl-&gt;h_v_order, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_INPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+				s_scl-&gt;input_width_height, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_OUTPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+				s_scl-&gt;output_width_height, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_EN_HSCL,</span>
<span class="p_add">+				s_scl-&gt;en_hscl, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_EN_VSCL,</span>
<span class="p_add">+				s_scl-&gt;en_vscl, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_ACC_HSCL,</span>
<span class="p_add">+				s_scl-&gt;acc_hscl, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_INC_HSCL,</span>
<span class="p_add">+				s_scl-&gt;inc_hscl, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_INC_VSCL,</span>
<span class="p_add">+				s_scl-&gt;inc_vscl, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, scl_base + SCF_EN_MMP,</span>
<span class="p_add">+				s_scl-&gt;en_mmp, 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		set_reg(scl_base + SCF_EN_HSCL_STR, s_scl-&gt;en_hscl_str, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_EN_VSCL_STR, s_scl-&gt;en_vscl_str, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_H_V_ORDER, s_scl-&gt;h_v_order, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_INPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+			s_scl-&gt;input_width_height, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_OUTPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+			s_scl-&gt;output_width_height, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_EN_HSCL, s_scl-&gt;en_hscl, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_EN_VSCL, s_scl-&gt;en_vscl, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_ACC_HSCL, s_scl-&gt;acc_hscl, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_INC_HSCL, s_scl-&gt;inc_hscl, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_INC_VSCL, s_scl-&gt;inc_vscl, 32, 0);</span>
<span class="p_add">+		set_reg(scl_base + SCF_EN_MMP, s_scl-&gt;en_mmp, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_scl_write_coefs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     bool enable_cmdlist, char __iomem *addr,</span>
<span class="p_add">+			     const int **p, int row, int col)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int groups[3] = { 0 };</span>
<span class="p_add">+	int offset = 0;</span>
<span class="p_add">+	int valid_num = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int j = 0;</span>
<span class="p_add">+	int k = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(addr == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((row != PHASE_NUM) || (col &lt; TAP4 || col &gt; TAP6)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;SCF filter coefficients is err, phase_num = %d, tap_num = %d\n&quot;,</span>
<span class="p_add">+		     row, col);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*byte */</span>
<span class="p_add">+	offset = (col == TAP4) ? 8 : 16;</span>
<span class="p_add">+	valid_num = (offset == 16) ? 3 : 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; row; i++) {</span>
<span class="p_add">+		for (j = 0; j &lt; col; j += 2) {</span>
<span class="p_add">+			if ((col % 2) &amp;&amp; (j == col - 1)) {</span>
<span class="p_add">+				groups[j / 2] =</span>
<span class="p_add">+				    (*((int *)p + i * col + j) &amp; 0xFFF) | (0 &lt;&lt;</span>
<span class="p_add">+									   16);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				groups[j / 2] =</span>
<span class="p_add">+				    (*((int *)p + i * col + j) &amp; 0xFFF) |</span>
<span class="p_add">+				    (*((int *)p + i * col + j + 1) &lt;&lt; 16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (k = 0; k &lt; valid_num; k++) {</span>
<span class="p_add">+			if (enable_cmdlist) {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						addr + offset * i +</span>
<span class="p_add">+						k * sizeof(int), groups[k], 32,</span>
<span class="p_add">+						0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				set_reg(addr + offset * i + k * sizeof(int),</span>
<span class="p_add">+					groups[k], 32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			groups[k] = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_chn_scl_load_filter_coef_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					      bool enable_cmdlist, int chn_idx,</span>
<span class="p_add">+					      uint32_t format)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t module_base = 0;</span>
<span class="p_add">+	char __iomem *h0_y_addr = NULL;</span>
<span class="p_add">+	char __iomem *y_addr = NULL;</span>
<span class="p_add">+	char __iomem *uv_addr = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int chn_coef_idx = SCL_COEF_YUV_IDX;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	if ((chn_idx != DSS_RCHN_V0) &amp;&amp; (chn_idx != DSS_RCHN_V1)</span>
<span class="p_add">+	    &amp;&amp; (chn_idx != DSS_RCHN_V2))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (isYUV(format)) {</span>
<span class="p_add">+		chn_coef_idx = SCL_COEF_YUV_IDX;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chn_coef_idx = SCL_COEF_RGB_IDX;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_scf_lut_chn_coef_idx[chn_idx] == chn_coef_idx)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	g_scf_lut_chn_coef_idx[chn_idx] = chn_coef_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	module_base = g_dss_module_base[chn_idx][MODULE_SCL_LUT];</span>
<span class="p_add">+	BUG_ON(module_base == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	h0_y_addr = hisifd-&gt;dss_base + module_base + DSS_SCF_H0_Y_COEF_OFFSET;</span>
<span class="p_add">+	y_addr = hisifd-&gt;dss_base + module_base + DSS_SCF_Y_COEF_OFFSET;</span>
<span class="p_add">+	uv_addr = hisifd-&gt;dss_base + module_base + DSS_SCF_UV_COEF_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist, h0_y_addr,</span>
<span class="p_add">+				     (const int **)COEF_LUT_TAP6[chn_coef_idx],</span>
<span class="p_add">+				     PHASE_NUM, TAP6);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write H0_Y_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist, y_addr,</span>
<span class="p_add">+				     (const int **)COEF_LUT_TAP5[chn_coef_idx],</span>
<span class="p_add">+				     PHASE_NUM, TAP5);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write Y_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist, uv_addr,</span>
<span class="p_add">+				     (const int **)COEF_LUT_TAP4[chn_coef_idx],</span>
<span class="p_add">+				     PHASE_NUM, TAP4);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write UV_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_scl_coef_on(struct hisi_fb_data_type *hisifd, bool enable_cmdlist,</span>
<span class="p_add">+			 int coef_lut_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	uint32_t module_base = 0;</span>
<span class="p_add">+	char __iomem *h0_y_addr = NULL;</span>
<span class="p_add">+	char __iomem *y_addr = NULL;</span>
<span class="p_add">+	char __iomem *uv_addr = NULL;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_SCL_LUT];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			h0_y_addr =</span>
<span class="p_add">+			    hisifd-&gt;dss_base + module_base +</span>
<span class="p_add">+			    DSS_SCF_H0_Y_COEF_OFFSET;</span>
<span class="p_add">+			y_addr =</span>
<span class="p_add">+			    hisifd-&gt;dss_base + module_base +</span>
<span class="p_add">+			    DSS_SCF_Y_COEF_OFFSET;</span>
<span class="p_add">+			uv_addr =</span>
<span class="p_add">+			    hisifd-&gt;dss_base + module_base +</span>
<span class="p_add">+			    DSS_SCF_UV_COEF_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+			g_scf_lut_chn_coef_idx[i] = coef_lut_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+						     h0_y_addr,</span>
<span class="p_add">+						     (const int **)</span>
<span class="p_add">+						     COEF_LUT_TAP6</span>
<span class="p_add">+						     [coef_lut_idx], PHASE_NUM,</span>
<span class="p_add">+						     TAP6);</span>
<span class="p_add">+			if (ret &lt; 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;Error to write H0_Y_COEF coefficients.\n&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (i == DSS_RCHN_V0) {</span>
<span class="p_add">+				hisi_dss_arsr2p_coef_on(hisifd, enable_cmdlist);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist, y_addr,</span>
<span class="p_add">+						     (const int **)COEF_LUT_TAP5[coef_lut_idx],</span>
<span class="p_add">+						     PHASE_NUM, TAP5);</span>
<span class="p_add">+			if (ret &lt; 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;Error to write Y_COEF coefficients.\n&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_scl_write_coefs(hisifd, enable_cmdlist, uv_addr,</span>
<span class="p_add">+						     (const int **)COEF_LUT_TAP4[coef_lut_idx],</span>
<span class="p_add">+						     PHASE_NUM, TAP4);</span>
<span class="p_add">+			if (ret &lt; 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;Error to write UV_COEF coefficients.\n&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_scl_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_layer_t *layer, dss_rect_t *aligned_rect,</span>
<span class="p_add">+			bool rdma_stretch_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_scl_t *scl = NULL;</span>
<span class="p_add">+	dss_rect_t src_rect;</span>
<span class="p_add">+	dss_rect_t dst_rect;</span>
<span class="p_add">+	uint32_t need_cap = 0;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	uint32_t transform = 0;</span>
<span class="p_add">+	dss_block_info_t *pblock_info = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	bool has_pixel_alpha = false;</span>
<span class="p_add">+	bool en_hscl = false;</span>
<span class="p_add">+	bool en_vscl = false;</span>
<span class="p_add">+	bool en_mmp = false;</span>
<span class="p_add">+	uint32_t h_ratio = 0;</span>
<span class="p_add">+	uint32_t v_ratio = 0;</span>
<span class="p_add">+	uint32_t h_v_order = 0;</span>
<span class="p_add">+	uint32_t acc_hscl = 0;</span>
<span class="p_add">+	uint32_t acc_vscl = 0;</span>
<span class="p_add">+	uint32_t scf_en_vscl = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	need_cap = layer-&gt;need_cap;</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	transform = layer-&gt;transform;</span>
<span class="p_add">+	if (aligned_rect)</span>
<span class="p_add">+		src_rect = *aligned_rect;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		src_rect = layer-&gt;src_rect;</span>
<span class="p_add">+	dst_rect = layer-&gt;dst_rect;</span>
<span class="p_add">+	pblock_info = &amp;(layer-&gt;block_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pblock_info &amp;&amp; pblock_info-&gt;both_vscfh_arsr2p_used) {</span>
<span class="p_add">+		dst_rect = pblock_info-&gt;arsr2p_in_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (chn_idx == DSS_RCHN_V0) {</span>
<span class="p_add">+		dst_rect.h = src_rect.h;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (chn_idx == DSS_RCHN_V0 &amp;&amp; pblock_info-&gt;h_ratio_arsr2p</span>
<span class="p_add">+		    &amp;&amp; pblock_info-&gt;h_ratio) {</span>
<span class="p_add">+			h_ratio = pblock_info-&gt;h_ratio;</span>
<span class="p_add">+			en_hscl = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		} else if (chn_idx == DSS_RCHN_V0 &amp;&amp; !pblock_info-&gt;h_ratio</span>
<span class="p_add">+			   &amp;&amp; pblock_info-&gt;h_ratio_arsr2p) {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pblock_info &amp;&amp; (pblock_info-&gt;h_ratio != 0)</span>
<span class="p_add">+		    &amp;&amp; (pblock_info-&gt;h_ratio != SCF_INC_FACTOR)) {</span>
<span class="p_add">+			h_ratio = pblock_info-&gt;h_ratio;</span>
<span class="p_add">+			en_hscl = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (chn_idx == DSS_RCHN_V0) {</span>
<span class="p_add">+			dst_rect.w =</span>
<span class="p_add">+			    (src_rect.w &gt; dst_rect.w ? dst_rect.w : src_rect.w);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (src_rect.w == dst_rect.w)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		en_hscl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((src_rect.w &lt; SCF_MIN_INPUT)</span>
<span class="p_add">+		    || (dst_rect.w &lt; SCF_MIN_OUTPUT)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;src_rect.w(%d) small than 16, &quot;</span>
<span class="p_add">+			     &quot;or dst_rect.w(%d) small than 16\n&quot;,</span>
<span class="p_add">+			     src_rect.w, dst_rect.w);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		h_ratio =</span>
<span class="p_add">+		    (DSS_HEIGHT(src_rect.w) * SCF_INC_FACTOR +</span>
<span class="p_add">+		     SCF_INC_FACTOR / 2 - acc_hscl) / DSS_HEIGHT(dst_rect.w);</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((dst_rect.w &gt; (src_rect.w * SCF_UPSCALE_MAX))</span>
<span class="p_add">+		    || (src_rect.w &gt; (dst_rect.w * SCF_DOWNSCALE_MAX))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;width out of range, original_src_rec(%d, %d, %d, %d) &quot;</span>
<span class="p_add">+			     &quot;new_src_rect(%d, %d, %d, %d), &quot;</span>
<span class="p_add">+			     &quot;dst_rect(%d, %d, %d, %d), rdma_stretch_enable=%d\n&quot;,</span>
<span class="p_add">+			     layer-&gt;src_rect.x, layer-&gt;src_rect.y,</span>
<span class="p_add">+			     layer-&gt;src_rect.w, layer-&gt;src_rect.h, src_rect.x,</span>
<span class="p_add">+			     src_rect.y, src_rect.w, src_rect.h, dst_rect.x,</span>
<span class="p_add">+			     dst_rect.y, dst_rect.w, dst_rect.h,</span>
<span class="p_add">+			     rdma_stretch_enable);</span>
<span class="p_add">+</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (0);</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (src_rect.h == dst_rect.h)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		en_vscl = true;</span>
<span class="p_add">+		scf_en_vscl = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		v_ratio =</span>
<span class="p_add">+		    (DSS_HEIGHT(src_rect.h) * SCF_INC_FACTOR +</span>
<span class="p_add">+		     SCF_INC_FACTOR / 2 - acc_vscl) / DSS_HEIGHT(dst_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((dst_rect.h &gt; (src_rect.h * SCF_UPSCALE_MAX))</span>
<span class="p_add">+		    || (src_rect.h &gt; (dst_rect.h * SCF_DOWNSCALE_MAX))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;height out of range, original_src_rec(%d, %d, %d, %d) &quot;</span>
<span class="p_add">+			     &quot;new_src_rect(%d, %d, %d, %d), &quot;</span>
<span class="p_add">+			     &quot;dst_rect(%d, %d, %d, %d), rdma_stretch_enable=%d.\n&quot;,</span>
<span class="p_add">+			     layer-&gt;src_rect.x, layer-&gt;src_rect.y,</span>
<span class="p_add">+			     layer-&gt;src_rect.w, layer-&gt;src_rect.h, src_rect.x,</span>
<span class="p_add">+			     src_rect.y, src_rect.w, src_rect.h, dst_rect.x,</span>
<span class="p_add">+			     dst_rect.y, dst_rect.w, dst_rect.h,</span>
<span class="p_add">+			     rdma_stretch_enable);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!en_hscl &amp;&amp; !en_vscl) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* scale down, do hscl first; scale up, do vscl first */</span>
<span class="p_add">+	h_v_order = (src_rect.w &gt; dst_rect.w) ? 0 : 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pblock_info &amp;&amp; (pblock_info-&gt;acc_hscl != 0)) {</span>
<span class="p_add">+		acc_hscl = pblock_info-&gt;acc_hscl;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	scl = &amp;(hisifd-&gt;dss_module.scl[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.scl_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	has_pixel_alpha = hal_format_has_alpha(layer-&gt;img.format);</span>
<span class="p_add">+</span>
<span class="p_add">+	scl-&gt;en_hscl_str = set_bits32(scl-&gt;en_hscl_str, 0x0, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v_ratio &gt;= 2 * SCF_INC_FACTOR) {</span>
<span class="p_add">+		if (has_pixel_alpha)</span>
<span class="p_add">+			scl-&gt;en_vscl_str =</span>
<span class="p_add">+			    set_bits32(scl-&gt;en_vscl_str, 0x3, 2, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			scl-&gt;en_vscl_str =</span>
<span class="p_add">+			    set_bits32(scl-&gt;en_vscl_str, 0x1, 2, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		scl-&gt;en_vscl_str = set_bits32(scl-&gt;en_vscl_str, 0x0, 1, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (src_rect.h &gt; dst_rect.h) {</span>
<span class="p_add">+		scf_en_vscl = 0x3;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	en_mmp = 0x1;</span>
<span class="p_add">+</span>
<span class="p_add">+	scl-&gt;h_v_order = set_bits32(scl-&gt;h_v_order, h_v_order, 1, 0);</span>
<span class="p_add">+	scl-&gt;input_width_height = set_bits32(scl-&gt;input_width_height,</span>
<span class="p_add">+					     DSS_HEIGHT(src_rect.h), 13, 0);</span>
<span class="p_add">+	scl-&gt;input_width_height = set_bits32(scl-&gt;input_width_height,</span>
<span class="p_add">+					     DSS_WIDTH(src_rect.w), 13, 16);</span>
<span class="p_add">+	scl-&gt;output_width_height = set_bits32(scl-&gt;output_width_height,</span>
<span class="p_add">+					      DSS_HEIGHT(dst_rect.h), 13, 0);</span>
<span class="p_add">+	scl-&gt;output_width_height = set_bits32(scl-&gt;output_width_height,</span>
<span class="p_add">+					      DSS_WIDTH(dst_rect.w), 13, 16);</span>
<span class="p_add">+	scl-&gt;en_hscl = set_bits32(scl-&gt;en_hscl, (en_hscl ? 0x1 : 0x0), 1, 0);</span>
<span class="p_add">+	scl-&gt;en_vscl = set_bits32(scl-&gt;en_vscl, scf_en_vscl, 2, 0);</span>
<span class="p_add">+	scl-&gt;acc_hscl = set_bits32(scl-&gt;acc_hscl, acc_hscl, 31, 0);</span>
<span class="p_add">+	scl-&gt;inc_hscl = set_bits32(scl-&gt;inc_hscl, h_ratio, 24, 0);</span>
<span class="p_add">+	scl-&gt;inc_vscl = set_bits32(scl-&gt;inc_vscl, v_ratio, 24, 0);</span>
<span class="p_add">+	scl-&gt;en_mmp = set_bits32(scl-&gt;en_mmp, en_mmp, 1, 0);</span>
<span class="p_add">+	scl-&gt;fmt = layer-&gt;img.format;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_post_scf_init(char __iomem *post_scf_base,</span>
<span class="p_add">+				   dss_arsr1p_t *s_post_scf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(post_scf_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_post_scf == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_post_scf, 0, sizeof(dss_arsr1p_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_post_scf-&gt;ihleft = inp32(post_scf_base + ARSR1P_IHLEFT);</span>
<span class="p_add">+	s_post_scf-&gt;ihright = inp32(post_scf_base + ARSR1P_IHRIGHT);</span>
<span class="p_add">+	s_post_scf-&gt;ihleft1 = inp32(post_scf_base + ARSR1P_IHLEFT1);</span>
<span class="p_add">+	s_post_scf-&gt;ihright1 = inp32(post_scf_base + ARSR1P_IHRIGHT1);</span>
<span class="p_add">+	s_post_scf-&gt;ivtop = inp32(post_scf_base + ARSR1P_IVTOP);</span>
<span class="p_add">+	s_post_scf-&gt;ivbottom = inp32(post_scf_base + ARSR1P_IVBOTTOM);</span>
<span class="p_add">+	s_post_scf-&gt;uv_offset = inp32(post_scf_base + ARSR1P_UV_OFFSET);</span>
<span class="p_add">+	s_post_scf-&gt;ihinc = inp32(post_scf_base + ARSR1P_IHINC);</span>
<span class="p_add">+	s_post_scf-&gt;ivinc = inp32(post_scf_base + ARSR1P_IVINC);</span>
<span class="p_add">+	s_post_scf-&gt;mode = inp32(post_scf_base + ARSR1P_MODE);</span>
<span class="p_add">+	s_post_scf-&gt;format = inp32(post_scf_base + ARSR1P_FORMAT);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_post_scf-&gt;skin_thres_y = inp32(post_scf_base + ARSR1P_SKIN_THRES_Y);</span>
<span class="p_add">+	s_post_scf-&gt;skin_thres_u = inp32(post_scf_base + ARSR1P_SKIN_THRES_U);</span>
<span class="p_add">+	s_post_scf-&gt;skin_thres_v = inp32(post_scf_base + ARSR1P_SKIN_THRES_V);</span>
<span class="p_add">+	s_post_scf-&gt;skin_expected = inp32(post_scf_base + ARSR1P_SKIN_EXPECTED);</span>
<span class="p_add">+	s_post_scf-&gt;skin_cfg = inp32(post_scf_base + ARSR1P_SKIN_CFG);</span>
<span class="p_add">+	s_post_scf-&gt;shoot_cfg1 = inp32(post_scf_base + ARSR1P_SHOOT_CFG1);</span>
<span class="p_add">+	s_post_scf-&gt;shoot_cfg2 = inp32(post_scf_base + ARSR1P_SHOOT_CFG2);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg1 = inp32(post_scf_base + ARSR1P_SHARP_CFG1);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg2 = inp32(post_scf_base + ARSR1P_SHARP_CFG2);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg3 = inp32(post_scf_base + ARSR1P_SHARP_CFG3);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg4 = inp32(post_scf_base + ARSR1P_SHARP_CFG4);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg5 = inp32(post_scf_base + ARSR1P_SHARP_CFG5);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg6 = inp32(post_scf_base + ARSR1P_SHARP_CFG6);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg7 = inp32(post_scf_base + ARSR1P_SHARP_CFG7);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg8 = inp32(post_scf_base + ARSR1P_SHARP_CFG8);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg9 = inp32(post_scf_base + ARSR1P_SHARP_CFG9);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg10 = inp32(post_scf_base + ARSR1P_SHARP_CFG10);</span>
<span class="p_add">+	s_post_scf-&gt;sharp_cfg11 = inp32(post_scf_base + ARSR1P_SHARP_CFG11);</span>
<span class="p_add">+	s_post_scf-&gt;diff_ctrl = inp32(post_scf_base + ARSR1P_DIFF_CTRL);</span>
<span class="p_add">+	s_post_scf-&gt;lsc_cfg1 = inp32(post_scf_base + ARSR1P_LSC_CFG1);</span>
<span class="p_add">+	s_post_scf-&gt;lsc_cfg2 = inp32(post_scf_base + ARSR1P_LSC_CFG2);</span>
<span class="p_add">+	s_post_scf-&gt;lsc_cfg3 = inp32(post_scf_base + ARSR1P_LSC_CFG3);</span>
<span class="p_add">+	s_post_scf-&gt;force_clk_on_cfg =</span>
<span class="p_add">+	    inp32(post_scf_base + ARSR1P_FORCE_CLK_ON_CFG);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_post_scf_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      char __iomem *post_scf_base,</span>
<span class="p_add">+				      dss_arsr1p_t *s_post_scf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(post_scf_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_post_scf == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+			hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_IMG_SIZE_BEF_SR,</span>
<span class="p_add">+			((DSS_HEIGHT(s_post_scf-&gt;dpp_img_vrt_bef_sr) &lt;&lt; 16) |</span>
<span class="p_add">+			 (DSS_WIDTH(s_post_scf-&gt;dpp_img_hrz_bef_sr))), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+			hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_IMG_SIZE_AFT_SR,</span>
<span class="p_add">+			((DSS_HEIGHT(s_post_scf-&gt;dpp_img_vrt_aft_sr) &lt;&lt; 16) |</span>
<span class="p_add">+			 (DSS_WIDTH(s_post_scf-&gt;dpp_img_hrz_aft_sr))), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IHLEFT, s_post_scf-&gt;ihleft);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IHRIGHT, s_post_scf-&gt;ihright);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IHLEFT1, s_post_scf-&gt;ihleft1);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IHRIGHT1, s_post_scf-&gt;ihright1);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IVTOP, s_post_scf-&gt;ivtop);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IVBOTTOM, s_post_scf-&gt;ivbottom);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_UV_OFFSET, s_post_scf-&gt;uv_offset);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IHINC, s_post_scf-&gt;ihinc);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_IVINC, s_post_scf-&gt;ivinc);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_MODE, s_post_scf-&gt;mode);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_FORMAT, s_post_scf-&gt;format);</span>
<span class="p_add">+</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SKIN_THRES_Y, s_post_scf-&gt;skin_thres_y);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SKIN_THRES_U, s_post_scf-&gt;skin_thres_u);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SKIN_THRES_V, s_post_scf-&gt;skin_thres_v);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SKIN_EXPECTED, s_post_scf-&gt;skin_expected);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SKIN_CFG, s_post_scf-&gt;skin_cfg);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHOOT_CFG1, s_post_scf-&gt;shoot_cfg1);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHOOT_CFG2, s_post_scf-&gt;shoot_cfg2);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG1, s_post_scf-&gt;sharp_cfg1);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG2, s_post_scf-&gt;sharp_cfg2);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG3, s_post_scf-&gt;sharp_cfg3);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG4, s_post_scf-&gt;sharp_cfg4);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG5, s_post_scf-&gt;sharp_cfg5);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG6, s_post_scf-&gt;sharp_cfg6);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG7, s_post_scf-&gt;sharp_cfg7);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG8, s_post_scf-&gt;sharp_cfg8);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG9, s_post_scf-&gt;sharp_cfg9);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG10, s_post_scf-&gt;sharp_cfg10);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_SHARP_CFG11, s_post_scf-&gt;sharp_cfg11);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_DIFF_CTRL, s_post_scf-&gt;diff_ctrl);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_LSC_CFG1, s_post_scf-&gt;lsc_cfg1);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_LSC_CFG2, s_post_scf-&gt;lsc_cfg2);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_LSC_CFG3, s_post_scf-&gt;lsc_cfg3);</span>
<span class="p_add">+	outp32(post_scf_base + ARSR1P_FORCE_CLK_ON_CFG,</span>
<span class="p_add">+	       s_post_scf-&gt;force_clk_on_cfg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_post_scf_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	dss_rect_t src_rect = { 0 };</span>
<span class="p_add">+	dss_rect_t dst_rect = { 0 };</span>
<span class="p_add">+	dss_arsr1p_t *post_scf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	int32_t ihinc = 0;</span>
<span class="p_add">+	int32_t ivinc = 0;</span>
<span class="p_add">+	int32_t ihleft = 0;</span>
<span class="p_add">+	int32_t ihright = 0;</span>
<span class="p_add">+	int32_t ihleft1 = 0;</span>
<span class="p_add">+	int32_t ihright1 = 0;</span>
<span class="p_add">+	int32_t ivtop = 0;</span>
<span class="p_add">+	int32_t ivbottom = 0;</span>
<span class="p_add">+	int32_t extraw = 0;</span>
<span class="p_add">+	int32_t extraw_left = 0;</span>
<span class="p_add">+	int32_t extraw_right = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!HISI_DSS_SUPPORT_DPP_MODULE_BIT(DPP_MODULE_POST_SCF)) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;res_updt_rect.w == 0) &amp;&amp; (pov_req-&gt;res_updt_rect.h == 0)) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;res_updt_rect.w &lt; 0) || (pov_req-&gt;res_updt_rect.h &lt; 0)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, res_updt_rect[%d,%d, %d,%d] is invalid!\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, pov_req-&gt;res_updt_rect.x,</span>
<span class="p_add">+			    pov_req-&gt;res_updt_rect.y, pov_req-&gt;res_updt_rect.w,</span>
<span class="p_add">+			    pov_req-&gt;res_updt_rect.h);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;res_updt_rect.w == hisifd-&gt;res_updt_rect.w)</span>
<span class="p_add">+	    &amp;&amp; (pov_req-&gt;res_updt_rect.h == hisifd-&gt;res_updt_rect.h)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG</span>
<span class="p_add">+	    (&quot;fb%d, post scf res_updt_rect[%d, %d]-&gt;lcd_rect[%d, %d]\n&quot;,</span>
<span class="p_add">+	     hisifd-&gt;index, pov_req-&gt;res_updt_rect.w, pov_req-&gt;res_updt_rect.h,</span>
<span class="p_add">+	     pinfo-&gt;xres, pinfo-&gt;yres);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect = pov_req-&gt;res_updt_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	src_rect = pov_req-&gt;res_updt_rect;</span>
<span class="p_add">+	dst_rect.x = 0;</span>
<span class="p_add">+	dst_rect.y = 0;</span>
<span class="p_add">+	dst_rect.w = pinfo-&gt;xres;</span>
<span class="p_add">+	dst_rect.h = pinfo-&gt;yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf = &amp;(hisifd-&gt;dss_module.post_scf);</span>
<span class="p_add">+	hisifd-&gt;dss_module.post_scf_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((src_rect.w &lt; 16) || (src_rect.h &lt; 16)</span>
<span class="p_add">+	    || (src_rect.w &gt; 3840) || (src_rect.h &gt; 8192)</span>
<span class="p_add">+	    || (dst_rect.w &gt; 8192) || (dst_rect.h &gt; 8192)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;invalid input size: src_rect(%d,%d,%d,%d) &quot;</span>
<span class="p_add">+		     &quot;should be larger than 16*16, less than 3840*8192!\n&quot;</span>
<span class="p_add">+		     &quot;invalid output size: dst_rect(%d,%d,%d,%d) &quot;</span>
<span class="p_add">+		     &quot;should be less than 8192*8192!\n&quot;,</span>
<span class="p_add">+		     src_rect.x, src_rect.y, src_rect.w, src_rect.h, dst_rect.x,</span>
<span class="p_add">+		     dst_rect.y, dst_rect.w, dst_rect.h);</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ihinc = ARSR1P_INC_FACTOR * src_rect.w / dst_rect.w;</span>
<span class="p_add">+	ivinc = ARSR1P_INC_FACTOR * src_rect.h / dst_rect.h;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ihinc == ARSR1P_INC_FACTOR)</span>
<span class="p_add">+	    &amp;&amp; (ivinc == ARSR1P_INC_FACTOR)</span>
<span class="p_add">+	    &amp;&amp; (pinfo-&gt;arsr1p_sharpness_support != 1)) {</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 0x2000&lt;=ihinc&lt;=0x80000; 0x2000&lt;=ivinc&lt;=0x80000; */</span>
<span class="p_add">+	if ((ihinc &lt; 0x2000) || (ihinc &gt; ARSR1P_INC_FACTOR)</span>
<span class="p_add">+	    || (ivinc &lt; 0x2000) || (ivinc &gt; ARSR1P_INC_FACTOR)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;invalid ihinc(0x%x), ivinc(0x%x)!\n&quot;, ihinc,</span>
<span class="p_add">+			    ivinc);</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ihinc &gt; ARSR1P_INC_FACTOR) || (ivinc &gt; ARSR1P_INC_FACTOR)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;scaling down is not supported by ARSR1P, &quot;</span>
<span class="p_add">+		     &quot;ihinc = 0x%x, ivinc = 0x%x\n&quot;,</span>
<span class="p_add">+		     ihinc, ivinc);</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;mode = 0x0;</span>
<span class="p_add">+	if (pinfo-&gt;arsr1p_sharpness_support) {</span>
<span class="p_add">+		post_scf-&gt;mode |= 0xe;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;mode |= 0x20;</span>
<span class="p_add">+	if ((ihinc &lt; ARSR1P_INC_FACTOR) || (ivinc &lt; ARSR1P_INC_FACTOR)) {</span>
<span class="p_add">+		post_scf-&gt;mode |= 0x10;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		post_scf-&gt;mode |= 0x40;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;dpp_img_hrz_bef_sr = src_rect.w;</span>
<span class="p_add">+	post_scf-&gt;dpp_img_vrt_bef_sr = src_rect.h;</span>
<span class="p_add">+	post_scf-&gt;dpp_img_hrz_aft_sr = dst_rect.w;</span>
<span class="p_add">+	post_scf-&gt;dpp_img_vrt_aft_sr = dst_rect.h;</span>
<span class="p_add">+</span>
<span class="p_add">+	extraw = (8 * ARSR1P_INC_FACTOR) / ihinc;</span>
<span class="p_add">+	extraw_left = (extraw % 2) ? (extraw + 1) : (extraw);</span>
<span class="p_add">+	extraw = (2 * ARSR1P_INC_FACTOR) / ihinc;</span>
<span class="p_add">+	extraw_right = (extraw % 2) ? (extraw + 1) : (extraw);</span>
<span class="p_add">+</span>
<span class="p_add">+	ihleft1 = dst_rect.x * ihinc - src_rect.x * ARSR1P_INC_FACTOR;</span>
<span class="p_add">+	if (ihleft1 &lt; 0)</span>
<span class="p_add">+		ihleft1 = 0;</span>
<span class="p_add">+	ihleft = ihleft1 - extraw_left * ihinc;</span>
<span class="p_add">+	if (ihleft &lt; 0)</span>
<span class="p_add">+		ihleft = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ihright1 = ihleft1 + (dst_rect.w - 1) * ihinc;</span>
<span class="p_add">+	ihright = ihright1 + extraw_right * ihinc;</span>
<span class="p_add">+	if (ihright &gt;= src_rect.w * ARSR1P_INC_FACTOR)</span>
<span class="p_add">+		ihright = src_rect.w * ARSR1P_INC_FACTOR - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	ivtop = dst_rect.y * ivinc - src_rect.y * ARSR1P_INC_FACTOR;</span>
<span class="p_add">+	if (ivtop &lt; 0)</span>
<span class="p_add">+		ivtop = 0;</span>
<span class="p_add">+	ivbottom = ivtop + (dst_rect.h - 1) * ivinc;</span>
<span class="p_add">+	if (ivbottom &gt;= src_rect.h * ARSR1P_INC_FACTOR)</span>
<span class="p_add">+		ivbottom = src_rect.h * ARSR1P_INC_FACTOR - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ihleft1 - ihleft) % (ihinc)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;(ihleft1(%d)-ihleft(%d))  ihinc(%d) != 0, invalid!\n&quot;,</span>
<span class="p_add">+		     ihleft1, ihleft, ihinc);</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ihright1 - ihleft1) % ihinc) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;(ihright1(%d)-ihleft1(%d))  ihinc(%d) != 0, invalid!\n&quot;,</span>
<span class="p_add">+		     ihright1, ihleft1, ihinc);</span>
<span class="p_add">+		post_scf-&gt;mode = 0x1;</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;ihleft = set_bits32(post_scf-&gt;ihleft, ihleft, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ihright = set_bits32(post_scf-&gt;ihright, ihright, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ihleft1 = set_bits32(post_scf-&gt;ihleft1, ihleft1, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ihright1 = set_bits32(post_scf-&gt;ihright1, ihright1, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ivtop = set_bits32(post_scf-&gt;ivtop, ivtop, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ivbottom = set_bits32(post_scf-&gt;ivbottom, ivbottom, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ihinc = set_bits32(post_scf-&gt;ihinc, ihinc, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;ivinc = set_bits32(post_scf-&gt;ivinc, ivinc, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;skin_thres_y =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;skin_thres_y, 0x534b, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;skin_thres_u =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;skin_thres_u, 0x330a05, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;skin_thres_v =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;skin_thres_v, 0xaa0c06, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;skin_expected =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;skin_expected, 0x917198, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;skin_cfg = set_bits32(post_scf-&gt;skin_cfg, 0x30a06, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;shoot_cfg1 = set_bits32(post_scf-&gt;shoot_cfg1, 0x14, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;shoot_cfg2 = set_bits32(post_scf-&gt;shoot_cfg2, 0x1f0, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg1 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg1, 0x40300602, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg2 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg2, 0x40300602, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg3 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg3, 0x12c0000, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg4 = set_bits32(post_scf-&gt;sharp_cfg4, 0x0, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg5 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg5, 0x1900000, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg6 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg6, 0xffff641e, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg7 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg7, 0x1a00018, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg8 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg8, 0x200640, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg9 =</span>
<span class="p_add">+	    set_bits32(post_scf-&gt;sharp_cfg9, 0x2006400, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg10 = set_bits32(post_scf-&gt;sharp_cfg10, 0x0, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;sharp_cfg11 = set_bits32(post_scf-&gt;sharp_cfg11, 0x0, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	post_scf-&gt;diff_ctrl = set_bits32(post_scf-&gt;diff_ctrl, 0x1410, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;lsc_cfg1 = set_bits32(post_scf-&gt;lsc_cfg1, 0x3c618410, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;lsc_cfg2 = set_bits32(post_scf-&gt;lsc_cfg2, 0x0, 32, 0);</span>
<span class="p_add">+	post_scf-&gt;lsc_cfg3 = set_bits32(post_scf-&gt;lsc_cfg3, 0x800600, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS POST_CLIP</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_post_clip_init(char __iomem *post_clip_base,</span>
<span class="p_add">+				    dss_post_clip_t *s_post_clip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(post_clip_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_post_clip == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_post_clip, 0, sizeof(dss_post_clip_t));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_post_clip_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_post_clip_t *post_clip = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_rect_t post_clip_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	post_clip_rect = layer-&gt;dst_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((chn_idx &gt;= DSS_RCHN_V0) &amp;&amp; (chn_idx &lt;= DSS_RCHN_G1))</span>
<span class="p_add">+	    || (chn_idx == DSS_RCHN_V2)) {</span>
<span class="p_add">+		post_clip = &amp;(hisifd-&gt;dss_module.post_clip[chn_idx]);</span>
<span class="p_add">+		hisifd-&gt;dss_module.post_cilp_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		post_clip-&gt;disp_size =</span>
<span class="p_add">+		    set_bits32(post_clip-&gt;disp_size,</span>
<span class="p_add">+			       DSS_HEIGHT(post_clip_rect.h), 13, 0);</span>
<span class="p_add">+		post_clip-&gt;disp_size =</span>
<span class="p_add">+		    set_bits32(post_clip-&gt;disp_size,</span>
<span class="p_add">+			       DSS_WIDTH(post_clip_rect.w), 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((chn_idx == DSS_RCHN_V0)</span>
<span class="p_add">+		    &amp;&amp; layer-&gt;block_info.arsr2p_left_clip) {</span>
<span class="p_add">+			post_clip-&gt;clip_ctl_hrz =</span>
<span class="p_add">+			    set_bits32(post_clip-&gt;clip_ctl_hrz,</span>
<span class="p_add">+				       layer-&gt;block_info.arsr2p_left_clip, 6, 16);</span>
<span class="p_add">+			post_clip-&gt;clip_ctl_hrz =</span>
<span class="p_add">+			    set_bits32(post_clip-&gt;clip_ctl_hrz, 0x0, 6, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			post_clip-&gt;clip_ctl_hrz =</span>
<span class="p_add">+			    set_bits32(post_clip-&gt;clip_ctl_hrz, 0x0, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		post_clip-&gt;clip_ctl_vrz =</span>
<span class="p_add">+		    set_bits32(post_clip-&gt;clip_ctl_vrz, 0x0, 32, 0);</span>
<span class="p_add">+		post_clip-&gt;ctl_clip_en =</span>
<span class="p_add">+		    set_bits32(post_clip-&gt;ctl_clip_en, 0x1, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_post_clip_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				char __iomem *post_clip_base,</span>
<span class="p_add">+				dss_post_clip_t *s_post_clip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(post_clip_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_post_clip == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, post_clip_base + POST_CLIP_DISP_SIZE,</span>
<span class="p_add">+			s_post_clip-&gt;disp_size, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, post_clip_base + POST_CLIP_CTL_HRZ,</span>
<span class="p_add">+			s_post_clip-&gt;clip_ctl_hrz, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, post_clip_base + POST_CLIP_CTL_VRZ,</span>
<span class="p_add">+			s_post_clip-&gt;clip_ctl_vrz, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, post_clip_base + POST_CLIP_EN,</span>
<span class="p_add">+			s_post_clip-&gt;ctl_clip_en, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS MCTL</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_mctl_init(char __iomem *mctl_base, dss_mctl_t *s_mctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(mctl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_mctl, 0, sizeof(dss_mctl_t));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_ch_starty_init(char __iomem *mctl_ch_starty_base,</span>
<span class="p_add">+					 dss_mctl_ch_t *s_mctl_ch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(mctl_ch_starty_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_ch == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_mctl_ch, 0, sizeof(dss_mctl_ch_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_mctl_ch-&gt;chn_starty = inp32(mctl_ch_starty_base);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_ch_mod_dbg_init(char __iomem *mctl_ch_dbg_base,</span>
<span class="p_add">+					  dss_mctl_ch_t *s_mctl_ch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(mctl_ch_dbg_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_ch == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_mctl_ch-&gt;chn_mod_dbg = inp32(mctl_ch_dbg_base);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_sys_init(char __iomem *mctl_sys_base,</span>
<span class="p_add">+				   dss_mctl_sys_t *s_mctl_sys)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(mctl_sys_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_sys == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_mctl_sys, 0, sizeof(dss_mctl_sys_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_OVL_IDX_MAX; i++) {</span>
<span class="p_add">+		s_mctl_sys-&gt;chn_ov_sel[i] = 0xFFFFFFFF;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_WCH_MAX; i++) {</span>
<span class="p_add">+		s_mctl_sys-&gt;wchn_ov_sel[i] = 0x0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_sys_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      char __iomem *mctl_sys_base,</span>
<span class="p_add">+				      dss_mctl_sys_t *s_mctl_sys, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int k = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(mctl_sys_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_sys == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_mctl_sys-&gt;chn_ov_sel_used[ovl_idx]) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+				mctl_sys_base + MCTL_RCH_OV0_SEL + ovl_idx * 0x4,</span>
<span class="p_add">+				s_mctl_sys-&gt;chn_ov_sel[ovl_idx], 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (k = 0; k &lt; DSS_WCH_MAX; k++) {</span>
<span class="p_add">+		if (s_mctl_sys-&gt;wch_ov_sel_used[k]) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+					mctl_sys_base + MCTL_WCH_OV2_SEL + k * 0x4,</span>
<span class="p_add">+					s_mctl_sys-&gt;wchn_ov_sel[k], 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_mctl_sys-&gt;ov_flush_en_used[ovl_idx]) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+				mctl_sys_base + MCTL_OV0_FLUSH_EN + ovl_idx * 0x4,</span>
<span class="p_add">+				s_mctl_sys-&gt;ov_flush_en[ovl_idx], 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_ov_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				     char __iomem *mctl_base,</span>
<span class="p_add">+				     dss_mctl_t *s_mctl, int ovl_idx,</span>
<span class="p_add">+				     bool enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(mctl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL0) || (ovl_idx == DSS_OVL1)) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, mctl_base + MCTL_CTL_MUTEX_DBUF,</span>
<span class="p_add">+				s_mctl-&gt;ctl_mutex_dbuf, 32, 0);</span>
<span class="p_add">+		hisi_dss_mctl_ov_set_ctl_dbg_reg(hisifd, mctl_base,</span>
<span class="p_add">+						 enable_cmdlist);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mctl_base + MCTL_CTL_MUTEX_OV,</span>
<span class="p_add">+			s_mctl-&gt;ctl_mutex_ov, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				     dss_mctl_ch_base_t *mctl_ch_base,</span>
<span class="p_add">+				     dss_mctl_ch_t *s_mctl_ch,</span>
<span class="p_add">+				     int32_t mctl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *chn_mutex_base = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(mctl_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_ch == NULL);</span>
<span class="p_add">+	BUG_ON((mctl_idx &lt; DSS_MCTL0) || (mctl_idx &gt;= DSS_MCTL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_MCTL_IDX_MAX; i++) {</span>
<span class="p_add">+		if (g_dss_module_ovl_base[i][MODULE_MCTL_BASE] == 0)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		chn_mutex_base = mctl_ch_base-&gt;chn_mutex_base +</span>
<span class="p_add">+		    g_dss_module_ovl_base[i][MODULE_MCTL_BASE];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (i != mctl_idx) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd, chn_mutex_base, 0, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_mutex_base = mctl_ch_base-&gt;chn_mutex_base +</span>
<span class="p_add">+	    g_dss_module_ovl_base[mctl_idx][MODULE_MCTL_BASE];</span>
<span class="p_add">+	BUG_ON(chn_mutex_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, chn_mutex_base, s_mctl_ch-&gt;chn_mutex, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_mctl_sys_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					 dss_mctl_ch_base_t *mctl_ch_base,</span>
<span class="p_add">+					 dss_mctl_ch_t *s_mctl_ch, int chn_idx,</span>
<span class="p_add">+					 bool normal)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *mctl_sys_base = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(mctl_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_mctl_ch == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_sys_base = hisifd-&gt;dss_base + DSS_MCTRL_SYS_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (normal == true) {</span>
<span class="p_add">+		if (chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd, mctl_sys_base + MCTL_MOD19_DBG,</span>
<span class="p_add">+					0xA0000, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd, mctl_sys_base + MCTL_MOD20_DBG,</span>
<span class="p_add">+					0xA0000, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (normal == false) {</span>
<span class="p_add">+		if (chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd, mctl_sys_base + MCTL_MOD19_DBG,</span>
<span class="p_add">+					0xA0002, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+			hisifd-&gt;set_reg(hisifd, mctl_sys_base + MCTL_MOD20_DBG,</span>
<span class="p_add">+					0xA0002, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mctl_ch_base-&gt;chn_ov_en_base) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, mctl_ch_base-&gt;chn_ov_en_base,</span>
<span class="p_add">+				s_mctl_ch-&gt;chn_ov_oen, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mctl_ch_base-&gt;chn_flush_en_base,</span>
<span class="p_add">+			s_mctl_ch-&gt;chn_flush_en, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mctl_mutex_lock(struct hisi_fb_data_type *hisifd, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *mctl_base = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_base = hisifd-&gt;dss_module.mctl_base[ovl_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mctl_base + MCTL_CTL_MUTEX, 0x1, 1, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mctl_mutex_unlock(struct hisi_fb_data_type *hisifd, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *mctl_base = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_base = hisifd-&gt;dss_module.mctl_base[ovl_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, mctl_base + MCTL_CTL_MUTEX, 0x0, 1, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mctl_on(struct hisi_fb_data_type *hisifd, int mctl_idx,</span>
<span class="p_add">+		      bool enable_cmdlist, bool fastboot_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *mctl_base = NULL;</span>
<span class="p_add">+	char __iomem *mctl_sys_base = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((mctl_idx &lt; DSS_MCTL0) || (mctl_idx &gt;= DSS_MCTL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_base = hisifd-&gt;dss_base +</span>
<span class="p_add">+	    g_dss_module_ovl_base[mctl_idx][MODULE_MCTL_BASE];</span>
<span class="p_add">+	mctl_sys_base = hisifd-&gt;dss_base + DSS_MCTRL_SYS_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(mctl_base + MCTL_CTL_EN, 0x1, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((mctl_idx == DSS_MCTL0) || (mctl_idx == DSS_MCTL1)) {</span>
<span class="p_add">+		set_reg(mctl_base + MCTL_CTL_MUTEX_ITF, mctl_idx + 1, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		tmp = MCTL_MOD_DBG_CH_NUM + MCTL_MOD_DBG_OV_NUM +</span>
<span class="p_add">+		    MCTL_MOD_DBG_DBUF_NUM + MCTL_MOD_DBG_SCF_NUM;</span>
<span class="p_add">+		for (i = 0; i &lt; tmp; i++) {</span>
<span class="p_add">+			set_reg(mctl_sys_base + MCTL_MOD0_DBG + i * 0x4,</span>
<span class="p_add">+				0xA0000, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; MCTL_MOD_DBG_ITF_NUM; i++) {</span>
<span class="p_add">+			set_reg(mctl_sys_base + MCTL_MOD17_DBG + i * 0x4,</span>
<span class="p_add">+				0xA0F00, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!fastboot_enable) {</span>
<span class="p_add">+			set_reg(mctl_base + MCTL_CTL_TOP, 0x1, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		set_reg(mctl_base + MCTL_CTL_DBG, 0xB13A00, 32, 0);</span>
<span class="p_add">+		if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+			set_reg(mctl_base + MCTL_CTL_TOP, 0x1, 32, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (mctl_idx == DSS_MCTL0) {</span>
<span class="p_add">+				set_reg(mctl_base + MCTL_CTL_TOP, 0x2, 32, 0);</span>
<span class="p_add">+			} else if (mctl_idx == DSS_MCTL1) {</span>
<span class="p_add">+				set_reg(mctl_base + MCTL_CTL_TOP, 0x3, 32, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				set_reg(mctl_base + MCTL_CTL_TOP, 0x1, 32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_mctl_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			    dss_wb_layer_t *wb_layer, int ovl_idx,</span>
<span class="p_add">+			    dss_rect_t *wb_ov_block_rect, bool has_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	int layer_idx = 0;</span>
<span class="p_add">+	dss_mctl_ch_t *mctl_ch = NULL;</span>
<span class="p_add">+	dss_mctl_sys_t *mctl_sys = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON((layer == NULL) &amp;&amp; (wb_layer == NULL));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+		mctl_sys = &amp;(hisifd-&gt;dss_module.mctl_sys);</span>
<span class="p_add">+		hisifd-&gt;dss_module.mctl_sys_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		mctl_ch = &amp;(hisifd-&gt;dss_module.mctl_ch[chn_idx]);</span>
<span class="p_add">+		hisifd-&gt;dss_module.mctl_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (chn_idx != DSS_WCHN_W2) {</span>
<span class="p_add">+			mctl_ch-&gt;chn_ov_oen = set_bits32(mctl_ch-&gt;chn_ov_oen,</span>
<span class="p_add">+							 (ovl_idx - 1), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pov_req-&gt;wb_layer_nums == MAX_DSS_DST_NUM) {</span>
<span class="p_add">+				mctl_sys-&gt;wchn_ov_sel[0] =</span>
<span class="p_add">+				    set_bits32(mctl_sys-&gt;wchn_ov_sel[0], 3, 32, 0);</span>
<span class="p_add">+				mctl_sys-&gt;wch_ov_sel_used[0] = 1;</span>
<span class="p_add">+				mctl_sys-&gt;wchn_ov_sel[1] =</span>
<span class="p_add">+				    set_bits32(mctl_sys-&gt;wchn_ov_sel[1], 3, 32, 0);</span>
<span class="p_add">+				mctl_sys-&gt;wch_ov_sel_used[1] = 1;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				mctl_sys-&gt;wchn_ov_sel[ovl_idx - DSS_OVL2] =</span>
<span class="p_add">+				    set_bits32(mctl_sys-&gt;wchn_ov_sel[ovl_idx - DSS_OVL2],</span>
<span class="p_add">+					       (chn_idx - DSS_WCHN_W0 + 1), 32, 0);</span>
<span class="p_add">+				mctl_sys-&gt;wch_ov_sel_used[ovl_idx - DSS_OVL2] = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mctl_ch-&gt;chn_mutex = set_bits32(mctl_ch-&gt;chn_mutex, 0x1, 1, 0);</span>
<span class="p_add">+		mctl_ch-&gt;chn_flush_en =</span>
<span class="p_add">+		    set_bits32(mctl_ch-&gt;chn_flush_en, 0x1, 1, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+		layer_idx = layer-&gt;layer_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;need_cap &amp; CAP_BASE)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (has_base) {</span>
<span class="p_add">+			layer_idx -= 1;</span>
<span class="p_add">+			if (layer_idx &lt; 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, layer_idx(%d) is out of range!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, layer_idx);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mctl_sys = &amp;(hisifd-&gt;dss_module.mctl_sys);</span>
<span class="p_add">+		hisifd-&gt;dss_module.mctl_sys_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;need_cap &amp; (CAP_DIM | CAP_PURE_COLOR)) {</span>
<span class="p_add">+			mctl_sys-&gt;chn_ov_sel[ovl_idx] =</span>
<span class="p_add">+			    set_bits32(mctl_sys-&gt;chn_ov_sel[ovl_idx], 0x8, 4,</span>
<span class="p_add">+				       (layer_idx + 1) * 4);</span>
<span class="p_add">+			mctl_sys-&gt;chn_ov_sel_used[ovl_idx] = 1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			mctl_ch = &amp;(hisifd-&gt;dss_module.mctl_ch[chn_idx]);</span>
<span class="p_add">+			hisifd-&gt;dss_module.mctl_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			mctl_ch-&gt;chn_mutex =</span>
<span class="p_add">+			    set_bits32(mctl_ch-&gt;chn_mutex, 0x1, 1, 0);</span>
<span class="p_add">+			mctl_ch-&gt;chn_flush_en =</span>
<span class="p_add">+			    set_bits32(mctl_ch-&gt;chn_flush_en, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (chn_idx != DSS_RCHN_V2) {</span>
<span class="p_add">+				mctl_ch-&gt;chn_ov_oen =</span>
<span class="p_add">+				    set_bits32(mctl_ch-&gt;chn_ov_oen,</span>
<span class="p_add">+					       ((1 &lt;&lt; (layer_idx + 1)) |</span>
<span class="p_add">+						(0x100 &lt;&lt; ovl_idx)), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (wb_ov_block_rect) {</span>
<span class="p_add">+					mctl_ch-&gt;chn_starty =</span>
<span class="p_add">+					    set_bits32(mctl_ch-&gt;chn_starty,</span>
<span class="p_add">+						       ((layer-&gt;dst_rect.y -</span>
<span class="p_add">+							 wb_ov_block_rect-&gt;y) | (0x8 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					mctl_ch-&gt;chn_starty =</span>
<span class="p_add">+					    set_bits32(mctl_ch-&gt;chn_starty,</span>
<span class="p_add">+						       (layer-&gt;dst_rect.y | (0x8 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				mctl_sys-&gt;chn_ov_sel[ovl_idx] =</span>
<span class="p_add">+				    set_bits32(mctl_sys-&gt;chn_ov_sel[ovl_idx],</span>
<span class="p_add">+					       chn_idx, 4, (layer_idx + 1) * 4);</span>
<span class="p_add">+				mctl_sys-&gt;chn_ov_sel_used[ovl_idx] = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_mctl_ov_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req, int ovl_idx, bool has_base,</span>
<span class="p_add">+			    bool is_first_ov_block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_mctl_t *mctl = NULL;</span>
<span class="p_add">+	dss_mctl_sys_t *mctl_sys = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req &amp;&amp; pov_req-&gt;wb_layer_infos[0].chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl = &amp;(hisifd-&gt;dss_module.mctl[ovl_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.mctl_used[ovl_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ovl_idx == DSS_OVL0) {</span>
<span class="p_add">+		mctl-&gt;ctl_mutex_itf =</span>
<span class="p_add">+		    set_bits32(mctl-&gt;ctl_mutex_itf, 0x1, 2, 0);</span>
<span class="p_add">+		mctl-&gt;ctl_mutex_dbuf =</span>
<span class="p_add">+		    set_bits32(mctl-&gt;ctl_mutex_dbuf, 0x1, 2, 0);</span>
<span class="p_add">+	} else if (ovl_idx == DSS_OVL1) {</span>
<span class="p_add">+		mctl-&gt;ctl_mutex_itf =</span>
<span class="p_add">+		    set_bits32(mctl-&gt;ctl_mutex_itf, 0x2, 2, 0);</span>
<span class="p_add">+		mctl-&gt;ctl_mutex_dbuf =</span>
<span class="p_add">+		    set_bits32(mctl-&gt;ctl_mutex_dbuf, 0x2, 2, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl-&gt;ctl_mutex_ov = set_bits32(mctl-&gt;ctl_mutex_ov, 1 &lt;&lt; ovl_idx, 4, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_sys = &amp;(hisifd-&gt;dss_module.mctl_sys);</span>
<span class="p_add">+	hisifd-&gt;dss_module.mctl_sys_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	mctl_sys-&gt;chn_ov_sel[ovl_idx] =</span>
<span class="p_add">+	    set_bits32(mctl_sys-&gt;chn_ov_sel[ovl_idx], 0x8, 4, 0);</span>
<span class="p_add">+	mctl_sys-&gt;chn_ov_sel_used[ovl_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL0) || (ovl_idx == DSS_OVL1)) {</span>
<span class="p_add">+		if (is_first_ov_block) {</span>
<span class="p_add">+			mctl_sys-&gt;ov_flush_en[ovl_idx] =</span>
<span class="p_add">+			    set_bits32(mctl_sys-&gt;ov_flush_en[ovl_idx], 0xd, 4, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			mctl_sys-&gt;ov_flush_en[ovl_idx] =</span>
<span class="p_add">+			    set_bits32(mctl_sys-&gt;ov_flush_en[ovl_idx], 0x1, 1, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mctl_sys-&gt;ov_flush_en_used[ovl_idx] = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mctl_sys-&gt;ov_flush_en[ovl_idx] =</span>
<span class="p_add">+		    set_bits32(mctl_sys-&gt;ov_flush_en[ovl_idx], 0x1, 1, 0);</span>
<span class="p_add">+		mctl_sys-&gt;ov_flush_en_used[ovl_idx] = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS OVL</span>
<span class="p_add">+ */</span>
<span class="p_add">+static dss_ovl_alpha_t g_ovl_alpha[DSS_BLEND_MAX] = {</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	{1, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 3, 0, 0, 1, 0},</span>
<span class="p_add">+	{1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 3, 0, 0, 0, 1},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 0, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{3, 0, 0, 0, 1, 1, 3, 1, 0, 0, 1},</span>
<span class="p_add">+	{2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	{1, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0},</span>
<span class="p_add">+	{2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0},</span>
<span class="p_add">+	{2, 2, 0, 0, 0, 0, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{3, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0},</span>
<span class="p_add">+	{2, 2, 0, 0, 0, 0, 2, 2, 0, 0, 0},</span>
<span class="p_add">+	{3, 2, 0, 0, 0, 0, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{2, 1, 0, 0, 0, 0, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{2, 1, 0, 0, 0, 0, 3, 1, 0, 0, 1},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 1, 3, 0, 1, 0, 0},</span>
<span class="p_add">+</span>
<span class="p_add">+	{2, 1, 0, 0, 0, 1, 3, 2, 0, 0, 0},</span>
<span class="p_add">+	{2, 1, 0, 0, 0, 1, 3, 1, 0, 0, 1},</span>
<span class="p_add">+	{0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t get_ovl_blending_mode(dss_overlay_t *pov_req,</span>
<span class="p_add">+				      dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t blend_mode = 0;</span>
<span class="p_add">+	bool has_per_pixel_alpha = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	has_per_pixel_alpha = hal_format_has_alpha(layer-&gt;img.format);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* delete it for DTS2015061204735 and DTS2015060408590 */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	   if (layer-&gt;layer_idx == 0) {</span>
<span class="p_add">+	   if (has_per_pixel_alpha) {</span>
<span class="p_add">+	   blend_mode = DSS_BLEND_SRC;</span>
<span class="p_add">+	   } else {</span>
<span class="p_add">+	   blend_mode= DSS_BLEND_FIX_PER17;</span>
<span class="p_add">+	   }</span>
<span class="p_add">+	   } else</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		if (layer-&gt;blending == HISI_FB_BLENDING_PREMULT) {</span>
<span class="p_add">+			if (has_per_pixel_alpha) {</span>
<span class="p_add">+				blend_mode =</span>
<span class="p_add">+				    (layer-&gt;glb_alpha &lt;</span>
<span class="p_add">+				     0xFF) ? DSS_BLEND_FIX_PER12 :</span>
<span class="p_add">+				    DSS_BLEND_SRC_OVER_DST;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				blend_mode =</span>
<span class="p_add">+				    (layer-&gt;glb_alpha &lt;</span>
<span class="p_add">+				     0xFF) ? DSS_BLEND_FIX_PER8 : DSS_BLEND_SRC;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else if (layer-&gt;blending == HISI_FB_BLENDING_COVERAGE) {</span>
<span class="p_add">+			if (has_per_pixel_alpha) {</span>
<span class="p_add">+				blend_mode =</span>
<span class="p_add">+				    (layer-&gt;glb_alpha &lt;</span>
<span class="p_add">+				     0xFF) ? DSS_BLEND_FIX_PER13 :</span>
<span class="p_add">+				    DSS_BLEND_FIX_OVER;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				blend_mode =</span>
<span class="p_add">+				    (layer-&gt;glb_alpha &lt;</span>
<span class="p_add">+				     0xFF) ? DSS_BLEND_FIX_PER8 : DSS_BLEND_SRC;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (has_per_pixel_alpha) {</span>
<span class="p_add">+				blend_mode = DSS_BLEND_SRC;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				blend_mode = DSS_BLEND_FIX_PER17;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;layer_idx(%d), blending=%d, fomat=%d, &quot;</span>
<span class="p_add">+		     &quot;has_per_pixel_alpha=%d, blend_mode=%d.\n&quot;,</span>
<span class="p_add">+		     layer-&gt;layer_idx, layer-&gt;blending, layer-&gt;img.format,</span>
<span class="p_add">+		     has_per_pixel_alpha, blend_mode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return blend_mode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_ovl_init(char __iomem *ovl_base, dss_ovl_t *s_ovl,</span>
<span class="p_add">+			      int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(ovl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_ovl == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_ovl, 0, sizeof(dss_ovl_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_ovl-&gt;ovl_size = inp32(ovl_base + OVL_SIZE);</span>
<span class="p_add">+	s_ovl-&gt;ovl_bg_color = inp32(ovl_base + OVL_BG_COLOR);</span>
<span class="p_add">+	s_ovl-&gt;ovl_dst_startpos = inp32(ovl_base + OVL_DST_STARTPOS);</span>
<span class="p_add">+	s_ovl-&gt;ovl_dst_endpos = inp32(ovl_base + OVL_DST_ENDPOS);</span>
<span class="p_add">+	s_ovl-&gt;ovl_gcfg = inp32(ovl_base + OVL_GCFG);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL1) || (ovl_idx == DSS_OVL3)) {</span>
<span class="p_add">+		for (i = 0; i &lt; OVL_2LAYER_NUM; i++) {</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_pos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_POS + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_size =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_SIZE + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_pattern =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PATTERN + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_alpha =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_ALPHA + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_cfg =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_CFG + i * 0x3C);</span>
<span class="p_add">+</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer_pos[i].layer_pspos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PSPOS + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer_pos[i].layer_pepos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PEPOS + i * 0x3C);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		s_ovl-&gt;ovl_block_size = inp32(ovl_base + OVL2_BLOCK_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; OVL_6LAYER_NUM; i++) {</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_pos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_POS + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_size =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_SIZE + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_pattern =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PATTERN + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_alpha =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_ALPHA + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer[i].layer_cfg =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_CFG + i * 0x3C);</span>
<span class="p_add">+</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer_pos[i].layer_pspos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PSPOS + i * 0x3C);</span>
<span class="p_add">+			s_ovl-&gt;ovl_layer_pos[i].layer_pepos =</span>
<span class="p_add">+			    inp32(ovl_base + OVL_LAYER0_PEPOS + i * 0x3C);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		s_ovl-&gt;ovl_block_size = inp32(ovl_base + OVL6_BLOCK_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_ovl_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				 char __iomem *ovl_base, dss_ovl_t *s_ovl,</span>
<span class="p_add">+				 int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(ovl_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_ovl == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL1) || (ovl_idx == DSS_OVL3)) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL2_REG_DEFAULT, 0x1, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL2_REG_DEFAULT, 0x0, 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL6_REG_DEFAULT, 0x1, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL6_REG_DEFAULT, 0x0, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, ovl_base + OVL_SIZE, s_ovl-&gt;ovl_size, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, ovl_base + OVL_BG_COLOR,</span>
<span class="p_add">+			s_ovl-&gt;ovl_bg_color, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, ovl_base + OVL_DST_STARTPOS,</span>
<span class="p_add">+			s_ovl-&gt;ovl_dst_startpos, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, ovl_base + OVL_DST_ENDPOS,</span>
<span class="p_add">+			s_ovl-&gt;ovl_dst_endpos, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, ovl_base + OVL_GCFG, s_ovl-&gt;ovl_gcfg, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL1) || (ovl_idx == DSS_OVL3)) {</span>
<span class="p_add">+		for (i = 0; i &lt; OVL_2LAYER_NUM; i++) {</span>
<span class="p_add">+			if (s_ovl-&gt;ovl_layer_used[i] == 1) {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_POS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_SIZE + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_size, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PATTERN + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pattern, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_ALPHA + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_alpha, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_CFG + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_cfg, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PSPOS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer_pos[i].layer_pspos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PEPOS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer_pos[i].layer_pepos, 32, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_POS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_SIZE + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_size, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_CFG + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_cfg, 32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL2_BLOCK_SIZE,</span>
<span class="p_add">+				s_ovl-&gt;ovl_block_size, 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; OVL_6LAYER_NUM; i++) {</span>
<span class="p_add">+			if (s_ovl-&gt;ovl_layer_used[i] == 1) {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_POS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_SIZE + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_size, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PATTERN + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pattern, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_ALPHA + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_alpha, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_CFG + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_cfg, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PSPOS + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer_pos[i].layer_pspos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_PEPOS +i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer_pos[i].layer_pepos, 32, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_POS +i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_pos, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_SIZE + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_size, 32, 0);</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						ovl_base + OVL_LAYER0_CFG + i * 0x3C,</span>
<span class="p_add">+						s_ovl-&gt;ovl_layer[i].layer_cfg, 32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL6_BLOCK_SIZE,</span>
<span class="p_add">+				s_ovl-&gt;ovl_block_size, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_ov_set_reg_default_value(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				       char __iomem *ovl_base, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(ovl_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL1) || (ovl_idx == DSS_OVL3)) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL2_REG_DEFAULT, 0x1, 32,</span>
<span class="p_add">+				0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL2_REG_DEFAULT, 0x0, 32,</span>
<span class="p_add">+				0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL6_REG_DEFAULT, 0x1, 32,</span>
<span class="p_add">+				0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, ovl_base + OVL6_REG_DEFAULT, 0x0, 32,</span>
<span class="p_add">+				0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_ovl_base_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req,</span>
<span class="p_add">+			     dss_overlay_block_t *pov_h_block,</span>
<span class="p_add">+			     dss_rect_t *wb_ov_block_rect, int ovl_idx,</span>
<span class="p_add">+			     int ov_h_block_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_ovl_t *ovl = NULL;</span>
<span class="p_add">+	int img_width = 0;</span>
<span class="p_add">+	int img_height = 0;</span>
<span class="p_add">+	int block_size = 0x7FFF;</span>
<span class="p_add">+	int temp = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int m = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos_tmp = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_tmp = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	int pov_h_block_idx = 0;</span>
<span class="p_add">+	int layer_idx = 0;</span>
<span class="p_add">+	bool has_base = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req &amp;&amp; pov_req-&gt;wb_layer_infos[0].chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl = &amp;(hisifd-&gt;dss_module.ov[ovl_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.ov_used[ovl_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_ov_block_rect) {</span>
<span class="p_add">+		img_width = wb_ov_block_rect-&gt;w;</span>
<span class="p_add">+		img_height = wb_ov_block_rect-&gt;h;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if ((!pov_req)</span>
<span class="p_add">+		    || (pov_req-&gt;dirty_rect.x == 0 &amp;&amp; pov_req-&gt;dirty_rect.y == 0</span>
<span class="p_add">+			&amp;&amp; pov_req-&gt;dirty_rect.w == 0</span>
<span class="p_add">+			&amp;&amp; pov_req-&gt;dirty_rect.h == 0)) {</span>
<span class="p_add">+			img_width = get_panel_xres(hisifd);</span>
<span class="p_add">+			img_height = get_panel_yres(hisifd);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			img_width = pov_req-&gt;dirty_rect.w;</span>
<span class="p_add">+			img_height = pov_req-&gt;dirty_rect.h;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_h_block &amp;&amp; (pov_req-&gt;ov_block_nums != 0)) {</span>
<span class="p_add">+		if (pov_req-&gt;ov_block_nums &gt; 1) {</span>
<span class="p_add">+			pov_h_block_infos_tmp =</span>
<span class="p_add">+			    (dss_overlay_block_t *) (pov_req-&gt;ov_block_infos_ptr);</span>
<span class="p_add">+			for (m = ov_h_block_idx; m &lt; pov_req-&gt;ov_block_nums;</span>
<span class="p_add">+			     m++) {</span>
<span class="p_add">+				pov_h_block_tmp = &amp;(pov_h_block_infos_tmp[m]);</span>
<span class="p_add">+				has_base = false;</span>
<span class="p_add">+</span>
<span class="p_add">+				for (i = 0; i &lt; pov_h_block_tmp-&gt;layer_nums;</span>
<span class="p_add">+				     i++) {</span>
<span class="p_add">+					layer =</span>
<span class="p_add">+					    &amp;(pov_h_block_tmp-&gt;layer_infos[i]);</span>
<span class="p_add">+					if (layer-&gt;need_cap &amp; CAP_BASE) {</span>
<span class="p_add">+						HISI_FB_INFO</span>
<span class="p_add">+						    (&quot;layer%d is base, i=%d!\n&quot;,</span>
<span class="p_add">+						     layer-&gt;layer_idx, i);</span>
<span class="p_add">+						has_base = true;</span>
<span class="p_add">+						continue;</span>
<span class="p_add">+					}</span>
<span class="p_add">+</span>
<span class="p_add">+					layer_idx = i;</span>
<span class="p_add">+					if (has_base) {</span>
<span class="p_add">+						layer_idx = i - 1;</span>
<span class="p_add">+					}</span>
<span class="p_add">+</span>
<span class="p_add">+					if (layer_idx &gt;= pov_h_block_idx) {</span>
<span class="p_add">+						ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+						    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+							       [layer_idx].layer_pos, 0, 15, 0);</span>
<span class="p_add">+						ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+						    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+							       [layer_idx].layer_pos,</span>
<span class="p_add">+							       img_height, 15, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+						ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+						    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+							       [layer_idx].layer_size,</span>
<span class="p_add">+							       img_width, 15, 0);</span>
<span class="p_add">+						ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+						    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+							       [layer_idx].layer_size,</span>
<span class="p_add">+							       img_height + 1, 15, 16);</span>
<span class="p_add">+						ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+						    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+							       [layer_idx].layer_cfg,</span>
<span class="p_add">+							       0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+						if (layer-&gt;need_cap &amp; (CAP_DIM |</span>
<span class="p_add">+								CAP_PURE_COLOR)) {</span>
<span class="p_add">+</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_pattern =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_pattern,</span>
<span class="p_add">+								       layer-&gt;color, 32, 0);</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_cfg,</span>
<span class="p_add">+								       0x1, 1, 0);</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_cfg,</span>
<span class="p_add">+								       0x1, 1, 8);</span>
<span class="p_add">+						} else {</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_pattern =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_pattern,</span>
<span class="p_add">+								       0x0, 32, 0);</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_cfg,</span>
<span class="p_add">+								       0x1, 1, 0);</span>
<span class="p_add">+							ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+							    set_bits32(ovl-&gt;ovl_layer</span>
<span class="p_add">+								       [layer_idx].layer_cfg,</span>
<span class="p_add">+								       0x0, 1, 8);</span>
<span class="p_add">+						}</span>
<span class="p_add">+</span>
<span class="p_add">+						ovl-&gt;ovl_layer_used[layer_idx] = 1;</span>
<span class="p_add">+						pov_h_block_idx = layer_idx + 1;</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wb_ov_block_rect) {</span>
<span class="p_add">+			if ((pov_req-&gt;wb_layer_infos[0].transform &amp;</span>
<span class="p_add">+					HISI_FB_TRANSFORM_ROT_90)</span>
<span class="p_add">+			   || (pov_req-&gt;wb_layer_infos[1].transform &amp;</span>
<span class="p_add">+			   		HISI_FB_TRANSFORM_ROT_90)) {</span>
<span class="p_add">+				block_size = DSS_HEIGHT(wb_ov_block_rect-&gt;h);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				temp =</span>
<span class="p_add">+				    pov_h_block-&gt;ov_block_rect.y +</span>
<span class="p_add">+				    DSS_HEIGHT(pov_h_block-&gt;ov_block_rect.h) -</span>
<span class="p_add">+				    wb_ov_block_rect-&gt;y;</span>
<span class="p_add">+				if (temp &gt;= wb_ov_block_rect-&gt;h) {</span>
<span class="p_add">+					block_size =</span>
<span class="p_add">+					    DSS_HEIGHT(wb_ov_block_rect-&gt;h);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					block_size = temp;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			block_size =</span>
<span class="p_add">+			    pov_h_block-&gt;ov_block_rect.y +</span>
<span class="p_add">+			    DSS_HEIGHT(pov_h_block-&gt;ov_block_rect.h);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl-&gt;ovl_size = set_bits32(ovl-&gt;ovl_size, DSS_WIDTH(img_width), 15, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_size =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_size, DSS_HEIGHT(img_height), 15, 16);</span>
<span class="p_add">+#ifdef CONFIG_HISI_FB_OV_BASE_USED</span>
<span class="p_add">+	ovl-&gt;ovl_bg_color = set_bits32(ovl-&gt;ovl_bg_color, 0xFFFF0000, 32, 0);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ovl-&gt;ovl_bg_color = set_bits32(ovl-&gt;ovl_bg_color, 0xFF000000, 32, 0);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	ovl-&gt;ovl_dst_startpos = set_bits32(ovl-&gt;ovl_dst_startpos, 0x0, 32, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_dst_endpos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_dst_endpos, DSS_WIDTH(img_width), 15, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_dst_endpos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_dst_endpos, DSS_HEIGHT(img_height), 15, 16);</span>
<span class="p_add">+	ovl-&gt;ovl_gcfg = set_bits32(ovl-&gt;ovl_gcfg, 0x1, 1, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_gcfg = set_bits32(ovl-&gt;ovl_gcfg, 0x1, 1, 16);</span>
<span class="p_add">+	ovl-&gt;ovl_block_size =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_block_size, block_size, 15, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_ovl_layer_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			      dss_rect_t *wb_ov_block_rect, bool has_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_ovl_t *ovl = NULL;</span>
<span class="p_add">+	int ovl_idx = 0;</span>
<span class="p_add">+	int layer_idx = 0;</span>
<span class="p_add">+	int blend_mode = 0;</span>
<span class="p_add">+	dss_rect_t wb_ov_rect;</span>
<span class="p_add">+	dss_rect_t dst_rect;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl_idx = hisifd-&gt;ov_req.ovl_idx;</span>
<span class="p_add">+	layer_idx = layer-&gt;layer_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+	ovl = &amp;(hisifd-&gt;dss_module.ov[ovl_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.ov_used[ovl_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_BASE) {</span>
<span class="p_add">+		ovl-&gt;ovl_bg_color =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_bg_color, layer-&gt;color, 32, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_gcfg = set_bits32(ovl-&gt;ovl_gcfg, 0x1, 1, 16);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;glb_alpha &lt; 0) {</span>
<span class="p_add">+		layer-&gt;glb_alpha = 0;</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer&#39;s glb_alpha(0x%x) is out of range!&quot;,</span>
<span class="p_add">+			    layer-&gt;glb_alpha);</span>
<span class="p_add">+	} else if (layer-&gt;glb_alpha &gt; 0xFF) {</span>
<span class="p_add">+		layer-&gt;glb_alpha = 0xFF;</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer&#39;s glb_alpha(0x%x) is out of range!&quot;,</span>
<span class="p_add">+			    layer-&gt;glb_alpha);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	blend_mode = get_ovl_blending_mode(pov_req, layer);</span>
<span class="p_add">+	BUG_ON((blend_mode &lt; 0) || (blend_mode &gt;= DSS_BLEND_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (has_base) {</span>
<span class="p_add">+		layer_idx -= 1;</span>
<span class="p_add">+		if (layer_idx &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;layer_idx(%d) is out of range!\n&quot;,</span>
<span class="p_add">+				    layer_idx);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl-&gt;ovl_layer_used[layer_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((layer-&gt;chn_idx == DSS_RCHN_V0)</span>
<span class="p_add">+	    &amp;&amp; layer-&gt;block_info.arsr2p_left_clip) {</span>
<span class="p_add">+		dst_rect.x =</span>
<span class="p_add">+		    layer-&gt;dst_rect.x + layer-&gt;block_info.arsr2p_left_clip;</span>
<span class="p_add">+		dst_rect.y = layer-&gt;dst_rect.y;</span>
<span class="p_add">+		dst_rect.w =</span>
<span class="p_add">+		    layer-&gt;dst_rect.w - layer-&gt;block_info.arsr2p_left_clip;</span>
<span class="p_add">+		dst_rect.h = layer-&gt;dst_rect.h;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dst_rect = layer-&gt;dst_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_ov_block_rect) {</span>
<span class="p_add">+		wb_ov_rect.x = pov_req-&gt;wb_ov_rect.x + wb_ov_block_rect-&gt;x;</span>
<span class="p_add">+		wb_ov_rect.y = pov_req-&gt;wb_ov_rect.y;</span>
<span class="p_add">+</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pos,</span>
<span class="p_add">+			       (dst_rect.x - wb_ov_rect.x), 15, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pos,</span>
<span class="p_add">+			       (dst_rect.y - wb_ov_rect.y), 15, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_size,</span>
<span class="p_add">+			       (dst_rect.x - wb_ov_rect.x +</span>
<span class="p_add">+				DSS_WIDTH(dst_rect.w)), 15, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_size,</span>
<span class="p_add">+			       (dst_rect.y - wb_ov_rect.y +</span>
<span class="p_add">+				DSS_HEIGHT(dst_rect.h)), 15, 16);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pos, dst_rect.x,</span>
<span class="p_add">+			       15, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pos =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pos, dst_rect.y,</span>
<span class="p_add">+			       15, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_size,</span>
<span class="p_add">+			       DSS_WIDTH(dst_rect.x + dst_rect.w), 15, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_size =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_size,</span>
<span class="p_add">+			       DSS_HEIGHT(dst_rect.y + dst_rect.h), 15, 16);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl-&gt;ovl_layer[layer_idx].layer_alpha =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_alpha,</span>
<span class="p_add">+		       ((layer-&gt;glb_alpha &lt;&lt; 0) |</span>
<span class="p_add">+		        (g_ovl_alpha[blend_mode].fix_mode &lt;&lt; 8) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].dst_pmode &lt;&lt; 9) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].alpha_offdst &lt;&lt; 10) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].dst_gmode &lt;&lt; 12) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].dst_amode &lt;&lt; 14) |</span>
<span class="p_add">+				(layer-&gt;glb_alpha &lt;&lt;16) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].alpha_smode &lt;&lt; 24) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].src_pmode &lt;&lt; 25) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].src_lmode &lt;&lt; 26) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].alpha_offdst &lt;&lt; 27) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].src_gmode &lt;&lt; 28) |</span>
<span class="p_add">+				(g_ovl_alpha[blend_mode].src_amode &lt;&lt; 30)), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; (CAP_DIM | CAP_PURE_COLOR)) {</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pattern =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pattern,</span>
<span class="p_add">+			       layer-&gt;color, 32, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_cfg, 0x1, 1, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_cfg, 0x1, 1, 8);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_pattern =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_pattern, 0x0, 32,</span>
<span class="p_add">+			       0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_cfg, 0x1, 1, 0);</span>
<span class="p_add">+		ovl-&gt;ovl_layer[layer_idx].layer_cfg =</span>
<span class="p_add">+		    set_bits32(ovl-&gt;ovl_layer[layer_idx].layer_cfg, 0x0, 1, 8);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl-&gt;ovl_layer_pos[layer_idx].layer_pspos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_layer_pos[layer_idx].layer_pspos, dst_rect.x,</span>
<span class="p_add">+		       15, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_layer_pos[layer_idx].layer_pspos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_layer_pos[layer_idx].layer_pspos, dst_rect.y,</span>
<span class="p_add">+		       15, 16);</span>
<span class="p_add">+	ovl-&gt;ovl_layer_pos[layer_idx].layer_pepos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_layer_pos[layer_idx].layer_pepos,</span>
<span class="p_add">+		       DSS_WIDTH(dst_rect.x + dst_rect.w), 15, 0);</span>
<span class="p_add">+	ovl-&gt;ovl_layer_pos[layer_idx].layer_pepos =</span>
<span class="p_add">+	    set_bits32(ovl-&gt;ovl_layer_pos[layer_idx].layer_pepos,</span>
<span class="p_add">+		       DSS_HEIGHT(dst_rect.y + dst_rect.h), 15, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** dirty_region_updt</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void hisi_dss_dirty_region_dbuf_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					       char __iomem *dss_base,</span>
<span class="p_add">+					       dirty_region_updt_t *</span>
<span class="p_add">+					       s_dirty_region_updt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dss_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dirty_region_updt == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dss_base + DSS_DBUF0_OFFSET + DBUF_FRM_SIZE,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;dbuf_frm_size, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dss_base + DSS_DBUF0_OFFSET + DBUF_FRM_HSIZE,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;dbuf_frm_hsize, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dss_base + DSS_DPP_OFFSET + DPP_IMG_SIZE_BEF_SR,</span>
<span class="p_add">+			((s_dirty_region_updt-&gt;dpp_img_vrt_bef_sr &lt;&lt; 16) |</span>
<span class="p_add">+			  s_dirty_region_updt-&gt;dpp_img_hrz_bef_sr), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, dss_base + DSS_DPP_OFFSET + DPP_IMG_SIZE_AFT_SR,</span>
<span class="p_add">+			((s_dirty_region_updt-&gt;dpp_img_vrt_aft_sr &lt;&lt; 16) |</span>
<span class="p_add">+			  s_dirty_region_updt-&gt;dpp_img_hrz_aft_sr), 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_dirty_region_updt_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					       char __iomem *dss_base,</span>
<span class="p_add">+					       dirty_region_updt_t *</span>
<span class="p_add">+					       s_dirty_region_updt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(dss_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_dirty_region_updt == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(dss_base + DSS_MIPI_DSI0_OFFSET + MIPIDSI_EDPI_CMD_SIZE_OFFSET,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;edpi_cmd_size, 32, 0);</span>
<span class="p_add">+	if (is_dual_mipi_panel(hisifd)) {</span>
<span class="p_add">+		set_reg(dss_base + DSS_MIPI_DSI1_OFFSET +</span>
<span class="p_add">+			MIPIDSI_EDPI_CMD_SIZE_OFFSET,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;edpi_cmd_size, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI0_HRZ_CTRL0,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl0, 29, 0);</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI0_HRZ_CTRL1,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl1, 13, 0);</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI0_HRZ_CTRL2,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl2, 13, 0);</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_VRT_CTRL0,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_vrt_ctrl0, 29, 0);</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_VRT_CTRL1,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_vrt_ctrl1, 13, 0);</span>
<span class="p_add">+	set_reg(dss_base + DSS_LDI0_OFFSET + LDI_VRT_CTRL2,</span>
<span class="p_add">+		s_dirty_region_updt-&gt;ldi_vrt_ctrl2, 13, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_dual_mipi_panel(hisifd)) {</span>
<span class="p_add">+		set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI1_HRZ_CTRL0,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl0, 29, 0);</span>
<span class="p_add">+		set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI1_HRZ_CTRL1,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl1, 13, 0);</span>
<span class="p_add">+		set_reg(dss_base + DSS_LDI0_OFFSET + LDI_DPI1_HRZ_CTRL2,</span>
<span class="p_add">+			s_dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl2, 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.ifbc_type != IFBC_TYPE_NONE) {</span>
<span class="p_add">+		if (!is_ifbc_vesa_panel(hisifd)) {</span>
<span class="p_add">+			set_reg(dss_base + DSS_IFBC_OFFSET + IFBC_SIZE,</span>
<span class="p_add">+				s_dirty_region_updt-&gt;ifbc_size, 32, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			set_reg(dss_base + DSS_DSC_OFFSET + DSC_PIC_SIZE,</span>
<span class="p_add">+				s_dirty_region_updt-&gt;ifbc_size, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_dirty_region_dbuf_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	dirty_region_updt_t *dirty_region_updt = NULL;</span>
<span class="p_add">+	struct dss_rect dirty = { 0 };</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index != PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    !pinfo-&gt;dirty_region_updt_support)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!pov_req)</span>
<span class="p_add">+	    || (pov_req-&gt;dirty_rect.x == 0 &amp;&amp; pov_req-&gt;dirty_rect.y == 0</span>
<span class="p_add">+		&amp;&amp; pov_req-&gt;dirty_rect.w == 0 &amp;&amp; pov_req-&gt;dirty_rect.h == 0)) {</span>
<span class="p_add">+		dirty.x = 0;</span>
<span class="p_add">+		dirty.y = 0;</span>
<span class="p_add">+		dirty.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+		dirty.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dirty = pov_req-&gt;dirty_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((dirty.x == hisifd-&gt;dirty_region_updt.x)</span>
<span class="p_add">+	    &amp;&amp; (dirty.y == hisifd-&gt;dirty_region_updt.y)</span>
<span class="p_add">+	    &amp;&amp; (dirty.w == hisifd-&gt;dirty_region_updt.w)</span>
<span class="p_add">+	    &amp;&amp; (dirty.h == hisifd-&gt;dirty_region_updt.h)) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt = &amp;(hisifd-&gt;dss_module.dirty_region_updt);</span>
<span class="p_add">+	hisifd-&gt;dss_module.dirty_region_updt_used = 1;</span>
<span class="p_add">+	dirty_region_updt-&gt;dpp_img_hrz_bef_sr =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dpp_img_hrz_bef_sr,</span>
<span class="p_add">+		       DSS_WIDTH(dirty.w), 13, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;dpp_img_vrt_bef_sr =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dpp_img_vrt_bef_sr,</span>
<span class="p_add">+		       DSS_WIDTH(dirty.h), 13, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;dpp_img_hrz_aft_sr =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dpp_img_hrz_aft_sr,</span>
<span class="p_add">+		       DSS_WIDTH(dirty.w), 13, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;dpp_img_vrt_aft_sr =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dpp_img_vrt_aft_sr,</span>
<span class="p_add">+		       DSS_WIDTH(dirty.h), 13, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt-&gt;dbuf_frm_size =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dbuf_frm_size, dirty.w * dirty.h, 27,</span>
<span class="p_add">+		       0);</span>
<span class="p_add">+	dirty_region_updt-&gt;dbuf_frm_hsize =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;dbuf_frm_hsize, DSS_WIDTH(dirty.w),</span>
<span class="p_add">+		       13, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_dirty_region_updt_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				       dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_fb_panel_data *pdata = NULL;</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+	dirty_region_updt_t *dirty_region_updt = NULL;</span>
<span class="p_add">+	struct dss_rect dirty = { 0 };</span>
<span class="p_add">+	uint32_t h_porch_pading = 0;</span>
<span class="p_add">+	uint32_t v_porch_pading = 0;</span>
<span class="p_add">+	dss_rect_t rect = { 0 };</span>
<span class="p_add">+	uint32_t max_latency = 0;</span>
<span class="p_add">+	uint32_t bits_per_pixel = 0;</span>
<span class="p_add">+	uint32_t h_front_porch_max = 0;</span>
<span class="p_add">+	uint32_t h_front_porch = 0;</span>
<span class="p_add">+	uint32_t h_back_porch = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	pdata = dev_get_platdata(&amp;hisifd-&gt;pdev-&gt;dev);</span>
<span class="p_add">+	BUG_ON(pdata == NULL);</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index != PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    !pinfo-&gt;dirty_region_updt_support)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!pov_req) || (pov_req-&gt;dirty_rect.w == 0)</span>
<span class="p_add">+	    || (pov_req-&gt;dirty_rect.h == 0)) {</span>
<span class="p_add">+		dirty.x = 0;</span>
<span class="p_add">+		dirty.y = 0;</span>
<span class="p_add">+		dirty.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+		dirty.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dirty = pov_req-&gt;dirty_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.xres &gt;= dirty.w) {</span>
<span class="p_add">+		h_porch_pading = hisifd-&gt;panel_info.xres - dirty.w;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;panel_info.yres &gt;= dirty.h) {</span>
<span class="p_add">+		v_porch_pading = hisifd-&gt;panel_info.yres - dirty.h;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((dirty.x == hisifd-&gt;dirty_region_updt.x)</span>
<span class="p_add">+	    &amp;&amp; (dirty.y == hisifd-&gt;dirty_region_updt.y)</span>
<span class="p_add">+	    &amp;&amp; (dirty.w == hisifd-&gt;dirty_region_updt.w)</span>
<span class="p_add">+	    &amp;&amp; (dirty.h == hisifd-&gt;dirty_region_updt.h)) {</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rect.x = 0;</span>
<span class="p_add">+	rect.y = 0;</span>
<span class="p_add">+	rect.w = dirty.w;</span>
<span class="p_add">+	rect.h = dirty.h;</span>
<span class="p_add">+	mipi_ifbc_get_rect(hisifd, &amp;rect);</span>
<span class="p_add">+</span>
<span class="p_add">+	h_front_porch = pinfo-&gt;ldi.h_front_porch;</span>
<span class="p_add">+	h_back_porch = pinfo-&gt;ldi.h_back_porch;</span>
<span class="p_add">+</span>
<span class="p_add">+	h_porch_pading = h_porch_pading * rect.w / dirty.w;</span>
<span class="p_add">+	v_porch_pading = v_porch_pading * rect.h / dirty.h;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinfo-&gt;bpp == LCD_RGB888)</span>
<span class="p_add">+		bits_per_pixel = 24;</span>
<span class="p_add">+	else if (pinfo-&gt;bpp == LCD_RGB565)</span>
<span class="p_add">+		bits_per_pixel = 16;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		bits_per_pixel = 24;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinfo-&gt;pxl_clk_rate_div == 0)</span>
<span class="p_add">+		pinfo-&gt;pxl_clk_rate_div = 1;</span>
<span class="p_add">+	max_latency =</span>
<span class="p_add">+	    (rect.w * bits_per_pixel / 8 + 1 + 6) / (pinfo-&gt;mipi.lane_nums + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	h_front_porch_max =</span>
<span class="p_add">+	    max_latency * (pinfo-&gt;pxl_clk_rate / pinfo-&gt;pxl_clk_rate_div) /</span>
<span class="p_add">+	    pinfo-&gt;dsi_phy_ctrl.lane_byte_clk;</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;bits_per_pixel = %d\n&quot; &quot;data_lane_lp2hs_time = %d\n&quot;</span>
<span class="p_add">+		      &quot;max_latency = %d\n&quot; &quot;pxl_clk_rate = %lld\n&quot;</span>
<span class="p_add">+		      &quot;pxl_clk_rate_div = %d\n&quot;</span>
<span class="p_add">+		      &quot;dsi_phy_ctrl.lane_byte_clk = %lld\n&quot;</span>
<span class="p_add">+		      &quot;h_front_porch_max = %d\n&quot;, bits_per_pixel,</span>
<span class="p_add">+		      pinfo-&gt;dsi_phy_ctrl.data_lane_lp2hs_time, max_latency,</span>
<span class="p_add">+		      pinfo-&gt;pxl_clk_rate, pinfo-&gt;pxl_clk_rate_div,</span>
<span class="p_add">+		      pinfo-&gt;dsi_phy_ctrl.lane_byte_clk, h_front_porch_max);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (h_front_porch &gt; h_front_porch_max) {</span>
<span class="p_add">+		h_back_porch += (h_front_porch - h_front_porch_max);</span>
<span class="p_add">+		h_front_porch = h_front_porch_max;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt = &amp;(hisifd-&gt;dss_module.dirty_region_updt);</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl0 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl0,</span>
<span class="p_add">+		       (h_front_porch) | ((h_back_porch + h_porch_pading) &lt;&lt;</span>
<span class="p_add">+					  16), 29, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl1 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl1,</span>
<span class="p_add">+		       DSS_WIDTH(pinfo-&gt;ldi.h_pulse_width), 13, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl2 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_dpi0_hrz_ctrl2, DSS_WIDTH(rect.w),</span>
<span class="p_add">+		       13, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_dual_mipi_panel(hisifd)) {</span>
<span class="p_add">+		dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl0 =</span>
<span class="p_add">+		    set_bits32(dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl0,</span>
<span class="p_add">+			       (h_back_porch + h_porch_pading) &lt;&lt; 16, 29, 0);</span>
<span class="p_add">+		dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl1 =</span>
<span class="p_add">+		    set_bits32(dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl1,</span>
<span class="p_add">+			       DSS_WIDTH(pinfo-&gt;ldi.h_pulse_width), 13, 0);</span>
<span class="p_add">+		dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl2 =</span>
<span class="p_add">+		    set_bits32(dirty_region_updt-&gt;ldi_dpi1_hrz_ctrl2,</span>
<span class="p_add">+			       DSS_WIDTH(rect.w), 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_vrt_ctrl0 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_vrt_ctrl0,</span>
<span class="p_add">+		       (pinfo-&gt;ldi.v_front_porch +</span>
<span class="p_add">+			v_porch_pading) | ((pinfo-&gt;ldi.v_back_porch) &lt;&lt; 16), 29,</span>
<span class="p_add">+		       0);</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_vrt_ctrl1 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_vrt_ctrl1,</span>
<span class="p_add">+		       DSS_HEIGHT(pinfo-&gt;ldi.v_pulse_width), 13, 0);</span>
<span class="p_add">+	dirty_region_updt-&gt;ldi_vrt_ctrl2 =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;ldi_vrt_ctrl2, DSS_HEIGHT(rect.h), 13,</span>
<span class="p_add">+		       0);</span>
<span class="p_add">+</span>
<span class="p_add">+	dirty_region_updt-&gt;edpi_cmd_size =</span>
<span class="p_add">+	    set_bits32(dirty_region_updt-&gt;edpi_cmd_size, rect.w, 16, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinfo-&gt;ifbc_type != IFBC_TYPE_NONE) {</span>
<span class="p_add">+		if ((pinfo-&gt;ifbc_type == IFBC_TYPE_VESA2X_DUAL) ||</span>
<span class="p_add">+		    (pinfo-&gt;ifbc_type == IFBC_TYPE_VESA3X_DUAL)) {</span>
<span class="p_add">+			dirty_region_updt-&gt;ifbc_size =</span>
<span class="p_add">+			    set_bits32(dirty_region_updt-&gt;ifbc_size,</span>
<span class="p_add">+				       ((DSS_WIDTH(dirty.w / 2) &lt;&lt; 16) |</span>
<span class="p_add">+					DSS_HEIGHT(dirty.h)), 32, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			dirty_region_updt-&gt;ifbc_size =</span>
<span class="p_add">+			    set_bits32(dirty_region_updt-&gt;ifbc_size,</span>
<span class="p_add">+				       ((DSS_WIDTH(dirty.w) &lt;&lt; 16) |</span>
<span class="p_add">+					DSS_HEIGHT(dirty.h)), 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*if (pdata &amp;&amp; pdata-&gt;set_display_region) {</span>
<span class="p_add">+	   pdata-&gt;set_display_region(hisifd-&gt;pdev, &amp;dirty);</span>
<span class="p_add">+	   } */</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt = dirty;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_dirty_region_updt_set_reg(hisifd, hisifd-&gt;dss_base,</span>
<span class="p_add">+					   &amp;(hisifd-&gt;dss_module.</span>
<span class="p_add">+					     dirty_region_updt));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_dirty_region_updt) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;dirty_region(%d,%d, %d,%d), h_porch_pading=%d, v_porch_pading=%d.\n&quot;,</span>
<span class="p_add">+		     dirty.x, dirty.y, dirty.w, dirty.h, h_porch_pading,</span>
<span class="p_add">+		     v_porch_pading);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** WCHN</span>
<span class="p_add">+ */</span>
<span class="p_add">+static uint32_t hisi_calculate_display_addr_wb(bool mmu_enable,</span>
<span class="p_add">+					       dss_wb_layer_t *wb_layer,</span>
<span class="p_add">+					       dss_rect_t aligned_rect,</span>
<span class="p_add">+					       dss_rect_t *ov_block_rect,</span>
<span class="p_add">+					       int add_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t addr = 0;</span>
<span class="p_add">+	uint32_t dst_addr = 0;</span>
<span class="p_add">+	uint32_t stride = 0;</span>
<span class="p_add">+	uint32_t offset = 0;</span>
<span class="p_add">+	int left = 0, top = 0;</span>
<span class="p_add">+	int bpp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+		left = wb_layer-&gt;dst_rect.x;</span>
<span class="p_add">+		top =</span>
<span class="p_add">+		    ov_block_rect-&gt;x - wb_layer-&gt;dst_rect.x +</span>
<span class="p_add">+		    wb_layer-&gt;dst_rect.y;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		left = aligned_rect.x;</span>
<span class="p_add">+		top = aligned_rect.y;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (add_type == DSS_ADDR_PLANE0) {</span>
<span class="p_add">+		stride = wb_layer-&gt;dst.stride;</span>
<span class="p_add">+		dst_addr =</span>
<span class="p_add">+		    mmu_enable ? wb_layer-&gt;dst.vir_addr : wb_layer-&gt;dst.</span>
<span class="p_add">+		    phy_addr;</span>
<span class="p_add">+	} else if (add_type == DSS_ADDR_PLANE1) {</span>
<span class="p_add">+		stride = wb_layer-&gt;dst.stride_plane1;</span>
<span class="p_add">+		offset = wb_layer-&gt;dst.offset_plane1;</span>
<span class="p_add">+		dst_addr =</span>
<span class="p_add">+		    mmu_enable ? (wb_layer-&gt;dst.vir_addr +</span>
<span class="p_add">+				  offset) : (wb_layer-&gt;dst.phy_addr + offset);</span>
<span class="p_add">+		top /= 2;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;NOT SUPPORT this add_type(%d).\n&quot;, add_type);</span>
<span class="p_add">+		BUG_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bpp = wb_layer-&gt;dst.bpp;</span>
<span class="p_add">+	addr = dst_addr + left * bpp + top * stride;</span>
<span class="p_add">+</span>
<span class="p_add">+	return addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_wdfc_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 dss_wb_layer_t *layer, dss_rect_t *aligned_rect,</span>
<span class="p_add">+			 dss_rect_t *ov_block_rect)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_dfc_t *dfc = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_rect_t in_rect;</span>
<span class="p_add">+	bool need_dither = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	int size_hrz = 0;</span>
<span class="p_add">+	int size_vrt = 0;</span>
<span class="p_add">+	int dfc_fmt = 0;</span>
<span class="p_add">+	int dfc_pix_in_num = 0;</span>
<span class="p_add">+	int aligned_line = 0;</span>
<span class="p_add">+	uint32_t dfc_w = 0;</span>
<span class="p_add">+	int aligned_pixel = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint32_t left_pad = 0;</span>
<span class="p_add">+	uint32_t right_pad = 0;</span>
<span class="p_add">+	uint32_t top_pad = 0;</span>
<span class="p_add">+	uint32_t bottom_pad = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint32_t addr = 0;</span>
<span class="p_add">+	uint32_t dst_addr = 0;</span>
<span class="p_add">+	uint32_t bpp = 0;</span>
<span class="p_add">+	bool mmu_enable = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+	BUG_ON(aligned_rect == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc = &amp;(hisifd-&gt;dss_module.dfc[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.dfc_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_fmt = hisi_pixel_format_hal2dfc(layer-&gt;dst.format);</span>
<span class="p_add">+	if (dfc_fmt &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer format (%d) not support !\n&quot;,</span>
<span class="p_add">+			    layer-&gt;dst.format);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCE) {</span>
<span class="p_add">+		aligned_pixel = AFBC_BLOCK_ALIGN;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		aligned_pixel = DMA_ALIGN_BYTES / layer-&gt;dst.bpp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	need_dither = isNeedDither(dfc_fmt);</span>
<span class="p_add">+	if (ov_block_rect) {</span>
<span class="p_add">+		memcpy(&amp;in_rect, ov_block_rect, sizeof(dss_rect_t));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		in_rect = layer-&gt;src_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size_hrz = DSS_WIDTH(in_rect.w);</span>
<span class="p_add">+	size_vrt = DSS_HEIGHT(in_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((size_hrz + 1) % 2 == 1) {</span>
<span class="p_add">+		size_hrz += 1;</span>
<span class="p_add">+		dfc_w = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc_pix_in_num = (layer-&gt;dst.bpp &lt;= 2) ? 0x1 : 0x0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCE) {</span>
<span class="p_add">+		aligned_rect-&gt;x = ALIGN_DOWN(in_rect.x, aligned_pixel);</span>
<span class="p_add">+		aligned_rect-&gt;w =</span>
<span class="p_add">+		    ALIGN_UP(in_rect.x - aligned_rect-&gt;x + in_rect.w + dfc_w,</span>
<span class="p_add">+			     aligned_pixel);</span>
<span class="p_add">+		aligned_rect-&gt;y = ALIGN_DOWN(in_rect.y, aligned_pixel);</span>
<span class="p_add">+		aligned_rect-&gt;h =</span>
<span class="p_add">+		    ALIGN_UP(in_rect.y - aligned_rect-&gt;y + in_rect.h,</span>
<span class="p_add">+			     aligned_pixel);</span>
<span class="p_add">+</span>
<span class="p_add">+		left_pad = in_rect.x - aligned_rect-&gt;x;</span>
<span class="p_add">+		right_pad =</span>
<span class="p_add">+		    aligned_rect-&gt;w - (in_rect.x - aligned_rect-&gt;x + in_rect.w +</span>
<span class="p_add">+				       dfc_w);</span>
<span class="p_add">+		top_pad = in_rect.y - aligned_rect-&gt;y;</span>
<span class="p_add">+		bottom_pad =</span>
<span class="p_add">+		    aligned_rect-&gt;h - (in_rect.y - aligned_rect-&gt;y + in_rect.h);</span>
<span class="p_add">+	} else if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+		aligned_line = (layer-&gt;dst.bpp &lt;= 2) ? 32 : 16;</span>
<span class="p_add">+		mmu_enable = (layer-&gt;dst.mmu_enable == 1) ? true : false;</span>
<span class="p_add">+		dst_addr =</span>
<span class="p_add">+		    mmu_enable ? layer-&gt;dst.vir_addr : layer-&gt;dst.phy_addr;</span>
<span class="p_add">+		bpp = layer-&gt;dst.bpp;</span>
<span class="p_add">+		addr =</span>
<span class="p_add">+		    dst_addr + layer-&gt;dst_rect.x * bpp +</span>
<span class="p_add">+		    (in_rect.x - layer-&gt;dst_rect.x + layer-&gt;dst_rect.y) *</span>
<span class="p_add">+		    	layer-&gt;dst.stride;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;dst.format)) {</span>
<span class="p_add">+			top_pad = (addr &amp; 0x1F) / bpp;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			top_pad = (addr &amp; 0x3F) / bpp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		aligned_rect-&gt;x = in_rect.x;</span>
<span class="p_add">+		aligned_rect-&gt;y = in_rect.y;</span>
<span class="p_add">+		aligned_rect-&gt;w = size_hrz + 1;</span>
<span class="p_add">+		aligned_rect-&gt;h = ALIGN_UP(in_rect.h + top_pad, aligned_line);</span>
<span class="p_add">+</span>
<span class="p_add">+		left_pad = 0;</span>
<span class="p_add">+		right_pad = 0;</span>
<span class="p_add">+		bottom_pad = aligned_rect-&gt;h - in_rect.h - top_pad;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		aligned_rect-&gt;x = ALIGN_DOWN(in_rect.x, aligned_pixel);</span>
<span class="p_add">+		aligned_rect-&gt;w =</span>
<span class="p_add">+		    ALIGN_UP(in_rect.x - aligned_rect-&gt;x + in_rect.w + dfc_w,</span>
<span class="p_add">+			     aligned_pixel);</span>
<span class="p_add">+		aligned_rect-&gt;y = in_rect.y;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_YUV_SP_420(layer-&gt;dst.format)) {</span>
<span class="p_add">+			aligned_rect-&gt;h = ALIGN_UP(in_rect.h, 2);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			aligned_rect-&gt;h = in_rect.h;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		left_pad = in_rect.x - aligned_rect-&gt;x;</span>
<span class="p_add">+		right_pad = aligned_rect-&gt;w - (left_pad + in_rect.w + dfc_w);</span>
<span class="p_add">+		top_pad = 0;</span>
<span class="p_add">+		bottom_pad = aligned_rect-&gt;h - in_rect.h;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dfc-&gt;disp_size =</span>
<span class="p_add">+	    set_bits32(dfc-&gt;disp_size, (size_vrt | (size_hrz &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	dfc-&gt;pix_in_num = set_bits32(dfc-&gt;pix_in_num, dfc_pix_in_num, 1, 0);</span>
<span class="p_add">+	dfc-&gt;disp_fmt = set_bits32(dfc-&gt;disp_fmt, dfc_fmt, 5, 1);</span>
<span class="p_add">+	dfc-&gt;clip_ctl_hrz = set_bits32(dfc-&gt;clip_ctl_hrz, 0x0, 12, 0);</span>
<span class="p_add">+	dfc-&gt;clip_ctl_vrz = set_bits32(dfc-&gt;clip_ctl_vrz, 0x0, 12, 0);</span>
<span class="p_add">+	dfc-&gt;ctl_clip_en = set_bits32(dfc-&gt;ctl_clip_en, 0x0, 1, 0);</span>
<span class="p_add">+	dfc-&gt;icg_module = set_bits32(dfc-&gt;icg_module, 0x1, 1, 0);</span>
<span class="p_add">+	if (need_dither) {</span>
<span class="p_add">+		dfc-&gt;dither_enable = set_bits32(dfc-&gt;dither_enable, 0x1, 1, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dfc-&gt;dither_enable = set_bits32(dfc-&gt;dither_enable, 0x0, 1, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (left_pad || right_pad || top_pad || bottom_pad) {</span>
<span class="p_add">+		dfc-&gt;padding_ctl = set_bits32(dfc-&gt;padding_ctl, (left_pad |</span>
<span class="p_add">+								 (right_pad &lt;&lt; 8) | (top_pad &lt;&lt; 16) |</span>
<span class="p_add">+								 (bottom_pad &lt;&lt; 24) | (0x1 &lt;&lt; 31)), 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dfc-&gt;padding_ctl = set_bits32(dfc-&gt;padding_ctl, 0x0, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_wdma_init(char __iomem *wdma_base, dss_wdma_t *s_wdma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(wdma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_wdma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_wdma, 0, sizeof(dss_wdma_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_wdma-&gt;oft_x0 = inp32(wdma_base + DMA_OFT_X0);</span>
<span class="p_add">+	s_wdma-&gt;oft_y0 = inp32(wdma_base + DMA_OFT_Y0);</span>
<span class="p_add">+	s_wdma-&gt;oft_x1 = inp32(wdma_base + DMA_OFT_X1);</span>
<span class="p_add">+	s_wdma-&gt;oft_y1 = inp32(wdma_base + DMA_OFT_Y1);</span>
<span class="p_add">+	s_wdma-&gt;mask0 = inp32(wdma_base + DMA_MASK0);</span>
<span class="p_add">+	s_wdma-&gt;mask1 = inp32(wdma_base + DMA_MASK1);</span>
<span class="p_add">+	s_wdma-&gt;stretch_size_vrt = inp32(wdma_base + DMA_STRETCH_SIZE_VRT);</span>
<span class="p_add">+	s_wdma-&gt;ctrl = inp32(wdma_base + DMA_CTRL);</span>
<span class="p_add">+	s_wdma-&gt;tile_scram = inp32(wdma_base + DMA_TILE_SCRAM);</span>
<span class="p_add">+	s_wdma-&gt;sw_mask_en = inp32(wdma_base + WDMA_DMA_SW_MASK_EN);</span>
<span class="p_add">+	s_wdma-&gt;start_mask0 = inp32(wdma_base + WDMA_DMA_START_MASK0);</span>
<span class="p_add">+	s_wdma-&gt;end_mask0 = inp32(wdma_base + WDMA_DMA_END_MASK1);</span>
<span class="p_add">+	s_wdma-&gt;start_mask1 = inp32(wdma_base + WDMA_DMA_START_MASK1);</span>
<span class="p_add">+	s_wdma-&gt;end_mask1 = inp32(wdma_base + WDMA_DMA_END_MASK1);</span>
<span class="p_add">+	s_wdma-&gt;data_addr = inp32(wdma_base + DMA_DATA_ADDR0);</span>
<span class="p_add">+	s_wdma-&gt;stride0 = inp32(wdma_base + DMA_STRIDE0);</span>
<span class="p_add">+	s_wdma-&gt;data1_addr = inp32(wdma_base + DMA_DATA_ADDR1);</span>
<span class="p_add">+	s_wdma-&gt;stride1 = inp32(wdma_base + DMA_STRIDE1);</span>
<span class="p_add">+	s_wdma-&gt;stretch_stride = inp32(wdma_base + DMA_STRETCH_STRIDE0);</span>
<span class="p_add">+	s_wdma-&gt;data_num = inp32(wdma_base + DMA_DATA_NUM0);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_wdma-&gt;ch_rd_shadow = inp32(wdma_base + CH_RD_SHADOW);</span>
<span class="p_add">+	s_wdma-&gt;ch_ctl = inp32(wdma_base + CH_CTL);</span>
<span class="p_add">+	s_wdma-&gt;ch_secu_en = inp32(wdma_base + CH_SECU_EN);</span>
<span class="p_add">+	s_wdma-&gt;ch_sw_end_req = inp32(wdma_base + CH_SW_END_REQ);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_wdma-&gt;afbce_hreg_pic_blks = inp32(wdma_base + AFBCE_HREG_PIC_BLKS);</span>
<span class="p_add">+	s_wdma-&gt;afbce_hreg_format = inp32(wdma_base + AFBCE_HREG_FORMAT);</span>
<span class="p_add">+	s_wdma-&gt;afbce_hreg_hdr_ptr_lo =</span>
<span class="p_add">+	    inp32(wdma_base + AFBCE_HREG_HDR_PTR_LO);</span>
<span class="p_add">+	s_wdma-&gt;afbce_hreg_pld_ptr_lo =</span>
<span class="p_add">+	    inp32(wdma_base + AFBCE_HREG_PLD_PTR_LO);</span>
<span class="p_add">+	s_wdma-&gt;afbce_picture_size = inp32(wdma_base + AFBCE_PICTURE_SIZE);</span>
<span class="p_add">+	s_wdma-&gt;afbce_ctl = inp32(wdma_base + AFBCE_CTL);</span>
<span class="p_add">+	s_wdma-&gt;afbce_header_srtide = inp32(wdma_base + AFBCE_HEADER_SRTIDE);</span>
<span class="p_add">+	s_wdma-&gt;afbce_payload_stride = inp32(wdma_base + AFBCE_PAYLOAD_STRIDE);</span>
<span class="p_add">+	s_wdma-&gt;afbce_enc_os_cfg = inp32(wdma_base + AFBCE_ENC_OS_CFG);</span>
<span class="p_add">+	s_wdma-&gt;afbce_mem_ctrl = inp32(wdma_base + AFBCE_MEM_CTRL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisi_dss_wdma_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				  char __iomem *wdma_base, dss_wdma_t *s_wdma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(wdma_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_wdma == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + CH_REG_DEFAULT, 0x1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + CH_REG_DEFAULT, 0x0, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_OFT_X0, s_wdma-&gt;oft_x0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_OFT_Y0, s_wdma-&gt;oft_y0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_OFT_X1, s_wdma-&gt;oft_x1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_OFT_Y1, s_wdma-&gt;oft_y1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_CTRL, s_wdma-&gt;ctrl, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_TILE_SCRAM,</span>
<span class="p_add">+			s_wdma-&gt;tile_scram, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + WDMA_DMA_SW_MASK_EN,</span>
<span class="p_add">+			s_wdma-&gt;sw_mask_en, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + WDMA_DMA_START_MASK0,</span>
<span class="p_add">+			s_wdma-&gt;start_mask0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + WDMA_DMA_END_MASK0,</span>
<span class="p_add">+			s_wdma-&gt;end_mask0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_DATA_ADDR0,</span>
<span class="p_add">+			s_wdma-&gt;data_addr, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_STRIDE0,</span>
<span class="p_add">+			s_wdma-&gt;stride0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_DATA_ADDR1,</span>
<span class="p_add">+			s_wdma-&gt;data1_addr, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_STRIDE1,</span>
<span class="p_add">+			s_wdma-&gt;stride1, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + CH_CTL, s_wdma-&gt;ch_ctl, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + ROT_SIZE, s_wdma-&gt;rot_size, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, wdma_base + DMA_BUF_SIZE,</span>
<span class="p_add">+			s_wdma-&gt;dma_buf_size, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_wdma-&gt;afbc_used == 1) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HREG_PIC_BLKS,</span>
<span class="p_add">+				s_wdma-&gt;afbce_hreg_pic_blks, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HREG_FORMAT,</span>
<span class="p_add">+				s_wdma-&gt;afbce_hreg_format, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HREG_HDR_PTR_LO,</span>
<span class="p_add">+				s_wdma-&gt;afbce_hreg_hdr_ptr_lo, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HREG_PLD_PTR_LO,</span>
<span class="p_add">+				s_wdma-&gt;afbce_hreg_pld_ptr_lo, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_PICTURE_SIZE,</span>
<span class="p_add">+				s_wdma-&gt;afbce_picture_size, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HEADER_SRTIDE,</span>
<span class="p_add">+				s_wdma-&gt;afbce_header_srtide, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_PAYLOAD_STRIDE,</span>
<span class="p_add">+				s_wdma-&gt;afbce_payload_stride, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_ENC_OS_CFG,</span>
<span class="p_add">+				s_wdma-&gt;afbce_enc_os_cfg, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_THRESHOLD,</span>
<span class="p_add">+				s_wdma-&gt;afbce_threshold, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_SCRAMBLE_MODE,</span>
<span class="p_add">+				s_wdma-&gt;afbce_scramble_mode, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, wdma_base + AFBCE_HEADER_POINTER_OFFSET,</span>
<span class="p_add">+				s_wdma-&gt;afbce_header_pointer_offset, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_wdma_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 dss_overlay_t *pov_req, dss_wb_layer_t *layer,</span>
<span class="p_add">+			 dss_rect_t aligned_rect, dss_rect_t *ov_block_rect,</span>
<span class="p_add">+			 bool last_block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_wdma_t *wdma = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	int wdma_format = 0;</span>
<span class="p_add">+	int wdma_transform = 0;</span>
<span class="p_add">+	uint32_t oft_x0 = 0;</span>
<span class="p_add">+	uint32_t oft_x1 = 0;</span>
<span class="p_add">+	uint32_t oft_y0 = 0;</span>
<span class="p_add">+	uint32_t oft_y1 = 0;</span>
<span class="p_add">+	uint32_t data_num = 0;</span>
<span class="p_add">+	uint32_t wdma_addr = 0;</span>
<span class="p_add">+	uint32_t wdma_stride = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint32_t wdma_buf_width = 0;</span>
<span class="p_add">+	uint32_t wdma_buf_height = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_rect_t in_rect;</span>
<span class="p_add">+	int temp = 0;</span>
<span class="p_add">+	int aligned_pixel = 0;</span>
<span class="p_add">+	int l2t_interleave_n = 0;</span>
<span class="p_add">+	bool mmu_enable = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_rect_ltrb_t afbc_header_rect = { 0 };</span>
<span class="p_add">+	dss_rect_ltrb_t afbc_payload_rect = { 0 };</span>
<span class="p_add">+	uint32_t afbce_hreg_pic_blks;</span>
<span class="p_add">+	uint32_t afbc_header_addr = 0;</span>
<span class="p_add">+	uint32_t afbc_header_stride = 0;</span>
<span class="p_add">+	uint32_t afbc_payload_addr = 0;</span>
<span class="p_add">+	uint32_t afbc_payload_stride = 0;</span>
<span class="p_add">+	int32_t afbc_header_start_pos = 0;</span>
<span class="p_add">+	uint32_t afbc_header_pointer_offset = 0;</span>
<span class="p_add">+	uint32_t stride_align = 0;</span>
<span class="p_add">+	uint32_t addr_align = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma = &amp;(hisifd-&gt;dss_module.wdma[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.dma_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma_format = hisi_pixel_format_hal2dma(layer-&gt;dst.format);</span>
<span class="p_add">+	if (wdma_format &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_pixel_format_hal2dma failed!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	in_rect = aligned_rect;</span>
<span class="p_add">+	aligned_pixel = DMA_ALIGN_BYTES / layer-&gt;dst.bpp;</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma_transform = hisi_transform_hal2dma(layer-&gt;transform, chn_idx);</span>
<span class="p_add">+	if (wdma_transform &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_transform_hal2dma failed!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mmu_enable = (layer-&gt;dst.mmu_enable == 1) ? true : false;</span>
<span class="p_add">+	wdma_addr = mmu_enable ? layer-&gt;dst.vir_addr : layer-&gt;dst.phy_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCE) {</span>
<span class="p_add">+		wdma-&gt;afbc_used = 1;</span>
<span class="p_add">+		if ((layer-&gt;dst.width &amp; (AFBC_HEADER_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (layer-&gt;dst.height &amp; (AFBC_BLOCK_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;wb_layer img width(%d) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;img heigh(%d) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;dst.width, AFBC_HEADER_ADDR_ALIGN,</span>
<span class="p_add">+			     layer-&gt;dst.height, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((in_rect.w &lt; AFBC_PIC_WIDTH_MIN)</span>
<span class="p_add">+		    || (in_rect.w &gt; AFBCE_IN_WIDTH_MAX)</span>
<span class="p_add">+		    || (in_rect.h &lt; AFBC_PIC_HEIGHT_MIN)</span>
<span class="p_add">+		    || (in_rect.h &gt; AFBC_PIC_HEIGHT_MAX)</span>
<span class="p_add">+		    || (in_rect.w &amp; (AFBC_BLOCK_ALIGN - 1))</span>
<span class="p_add">+		    || (in_rect.h &amp; (AFBC_BLOCK_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;afbce in_rect(%d,%d, %d,%d) is out of range!&quot;,</span>
<span class="p_add">+			     in_rect.x, in_rect.y, in_rect.w, in_rect.h);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_header_rect.right =</span>
<span class="p_add">+		    ALIGN_UP(in_rect.x + in_rect.w, AFBC_HEADER_ADDR_ALIGN) - 1;</span>
<span class="p_add">+		afbc_header_rect.bottom =</span>
<span class="p_add">+		    ALIGN_UP(in_rect.y + in_rect.h, AFBC_BLOCK_ALIGN) - 1;</span>
<span class="p_add">+		if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+			afbc_header_rect.left =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;dst_rect.x,</span>
<span class="p_add">+				       AFBC_HEADER_ADDR_ALIGN);</span>
<span class="p_add">+			afbc_header_rect.top =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;dst_rect.y +</span>
<span class="p_add">+				       (ov_block_rect-&gt;x - layer-&gt;dst_rect.x),</span>
<span class="p_add">+				       AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+			afbc_payload_rect.left =</span>
<span class="p_add">+			    ALIGN_DOWN(layer-&gt;dst_rect.x, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+			afbc_payload_rect.top = afbc_header_rect.top;</span>
<span class="p_add">+</span>
<span class="p_add">+			afbc_header_start_pos =</span>
<span class="p_add">+			    (layer-&gt;dst_rect.x -</span>
<span class="p_add">+			     afbc_header_rect.left) / AFBC_BLOCK_ALIGN;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			afbc_header_rect.left =</span>
<span class="p_add">+			    ALIGN_DOWN(in_rect.x, AFBC_HEADER_ADDR_ALIGN);</span>
<span class="p_add">+			afbc_header_rect.top =</span>
<span class="p_add">+			    ALIGN_DOWN(in_rect.y, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+			afbc_payload_rect.left =</span>
<span class="p_add">+			    ALIGN_DOWN(in_rect.x, AFBC_BLOCK_ALIGN);</span>
<span class="p_add">+			afbc_payload_rect.top = afbc_header_rect.top;</span>
<span class="p_add">+</span>
<span class="p_add">+			afbc_header_start_pos =</span>
<span class="p_add">+			    (in_rect.x -</span>
<span class="p_add">+			     afbc_header_rect.left) / AFBC_BLOCK_ALIGN;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (afbc_header_start_pos &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;afbc_header_start_pos(%d) is invalid!\n&quot;,</span>
<span class="p_add">+				    afbc_header_start_pos);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		afbce_hreg_pic_blks =</span>
<span class="p_add">+		    (in_rect.w / AFBC_BLOCK_ALIGN) * (in_rect.h /</span>
<span class="p_add">+						      AFBC_BLOCK_ALIGN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_header_stride =</span>
<span class="p_add">+		    (layer-&gt;dst.width / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    AFBC_HEADER_STRIDE_BLOCK;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_header_pointer_offset =</span>
<span class="p_add">+		    (afbc_header_rect.top / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    afbc_header_stride +</span>
<span class="p_add">+		    (afbc_header_rect.left / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    AFBC_HEADER_STRIDE_BLOCK;</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_header_addr =</span>
<span class="p_add">+		    layer-&gt;dst.afbc_header_addr + afbc_header_pointer_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((afbc_header_addr &amp; (AFBC_HEADER_ADDR_ALIGN - 1)) ||</span>
<span class="p_add">+		    (afbc_header_stride &amp; (AFBC_HEADER_STRIDE_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;wb_layer afbc_header_addr(0x%x) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;afbc_header_stride(0x%x) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     afbc_header_addr, AFBC_HEADER_ADDR_ALIGN,</span>
<span class="p_add">+			     afbc_header_stride, AFBC_HEADER_STRIDE_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;dst.bpp == 4) {</span>
<span class="p_add">+			stride_align = AFBC_PAYLOAD_STRIDE_ALIGN_32;</span>
<span class="p_add">+			addr_align = AFBC_PAYLOAD_ADDR_ALIGN_32;</span>
<span class="p_add">+		} else if (layer-&gt;dst.bpp == 2) {</span>
<span class="p_add">+			stride_align = AFBC_PAYLOAD_STRIDE_ALIGN_16;</span>
<span class="p_add">+			addr_align = AFBC_PAYLOAD_ADDR_ALIGN_16;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;bpp(%d) not supported!\n&quot;, layer-&gt;dst.bpp);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		afbc_payload_stride = layer-&gt;dst.afbc_payload_stride;</span>
<span class="p_add">+		if (layer-&gt;dst.afbc_scramble_mode != DSS_AFBC_SCRAMBLE_MODE2) {</span>
<span class="p_add">+			afbc_payload_stride =</span>
<span class="p_add">+			    (layer-&gt;dst.width / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+			    stride_align;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		afbc_payload_addr = layer-&gt;dst.afbc_payload_addr +</span>
<span class="p_add">+		    (afbc_payload_rect.top / AFBC_BLOCK_ALIGN) *</span>
<span class="p_add">+		    afbc_payload_stride +</span>
<span class="p_add">+		    (afbc_payload_rect.left / AFBC_BLOCK_ALIGN) * stride_align;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((afbc_payload_addr &amp; (addr_align - 1)) ||</span>
<span class="p_add">+		    (afbc_payload_stride &amp; (stride_align - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;afbc_payload_addr(0x%x) is not %d bytes aligned, or &quot;</span>
<span class="p_add">+			     &quot;afbc_payload_stride(0x%x) is not %d bytes aligned!\n&quot;,</span>
<span class="p_add">+			     afbc_payload_addr, addr_align, afbc_payload_stride,</span>
<span class="p_add">+			     stride_align);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+			HISI_FB_INFO</span>
<span class="p_add">+			    (&quot;aligned_rect(%d,%d,%d,%d), afbc_rect(%d,%d,%d,%d)!\n&quot;,</span>
<span class="p_add">+			     in_rect.x, in_rect.y,</span>
<span class="p_add">+			     DSS_WIDTH(in_rect.x + in_rect.w),</span>
<span class="p_add">+			     DSS_WIDTH(in_rect.y + in_rect.h),</span>
<span class="p_add">+			     afbc_payload_rect.left, afbc_payload_rect.top,</span>
<span class="p_add">+			     afbc_payload_rect.right, afbc_payload_rect.bottom);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;ctrl = set_bits32(wdma-&gt;ctrl, wdma_format, 5, 3);</span>
<span class="p_add">+		wdma-&gt;ctrl =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;ctrl, (mmu_enable ? 0x1 : 0x0), 1, 8);</span>
<span class="p_add">+		wdma-&gt;ctrl = set_bits32(wdma-&gt;ctrl, wdma_transform, 3, 9);</span>
<span class="p_add">+		if (last_block) {</span>
<span class="p_add">+			wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 0x1d, 5, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 0xd, 5, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;rot_size = set_bits32(wdma-&gt;rot_size,</span>
<span class="p_add">+					    (DSS_WIDTH(in_rect.w) |</span>
<span class="p_add">+					     (DSS_HEIGHT(in_rect.h) &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_hreg_pic_blks =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_hreg_pic_blks,</span>
<span class="p_add">+		    		afbce_hreg_pic_blks, 24, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_hreg_format =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_hreg_format,</span>
<span class="p_add">+			       (isYUVPackage(layer-&gt;dst.format) ? 0x0 : 0x1), 1, 21);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_hreg_hdr_ptr_lo =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_hreg_hdr_ptr_lo,</span>
<span class="p_add">+		    		afbc_header_addr, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_hreg_pld_ptr_lo =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_hreg_pld_ptr_lo,</span>
<span class="p_add">+		    		afbc_payload_addr, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_picture_size =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_picture_size,</span>
<span class="p_add">+			       ((DSS_WIDTH(in_rect.w) &lt;&lt; 16) |</span>
<span class="p_add">+			          DSS_HEIGHT(in_rect.h)), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_header_srtide =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_header_srtide,</span>
<span class="p_add">+			       ((afbc_header_start_pos &lt;&lt; 14) |</span>
<span class="p_add">+				afbc_header_stride), 16, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_payload_stride =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_payload_stride, afbc_payload_stride, 20, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_enc_os_cfg =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_enc_os_cfg,</span>
<span class="p_add">+			       DSS_AFBCE_ENC_OS_CFG_DEFAULT_VAL, 3, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma-&gt;afbce_mem_ctrl =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_mem_ctrl, 0x0, 12, 0);</span>
<span class="p_add">+		wdma-&gt;afbce_threshold =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_threshold, 0x2, 32, 0);</span>
<span class="p_add">+		wdma-&gt;afbce_header_pointer_offset =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_header_pointer_offset,</span>
<span class="p_add">+			       afbc_header_pointer_offset, 32, 0);</span>
<span class="p_add">+		wdma-&gt;afbce_scramble_mode =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;afbce_scramble_mode,</span>
<span class="p_add">+			       layer-&gt;dst.afbc_scramble_mode, 2, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_TILE) {</span>
<span class="p_add">+		l2t_interleave_n =</span>
<span class="p_add">+		    hisi_get_rdma_tile_interleave(layer-&gt;dst.stride);</span>
<span class="p_add">+		if (l2t_interleave_n &lt; MIN_INTERLEAVE) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;tile stride should be 256*2^n, error stride:%d!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;dst.stride);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wdma_addr &amp; (TILE_DMA_ADDR_ALIGN - 1)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;tile wdma_addr(0x%x) is not %d bytes aligned.\n&quot;,</span>
<span class="p_add">+			     wdma_addr, TILE_DMA_ADDR_ALIGN);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+		temp = in_rect.w;</span>
<span class="p_add">+		in_rect.w = in_rect.h;</span>
<span class="p_add">+		in_rect.h = temp;</span>
<span class="p_add">+</span>
<span class="p_add">+		oft_x0 = 0;</span>
<span class="p_add">+		oft_x1 = DSS_WIDTH(in_rect.w) / aligned_pixel;</span>
<span class="p_add">+		oft_y0 = 0;</span>
<span class="p_add">+		oft_y1 = DSS_HEIGHT(ov_block_rect-&gt;w);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		oft_x0 = in_rect.x / aligned_pixel;</span>
<span class="p_add">+		oft_x1 = DSS_WIDTH(in_rect.x + in_rect.w) / aligned_pixel;</span>
<span class="p_add">+		oft_y0 = in_rect.y;</span>
<span class="p_add">+		oft_y1 = DSS_HEIGHT(in_rect.y + in_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma_addr =</span>
<span class="p_add">+	    hisi_calculate_display_addr_wb(mmu_enable, layer, in_rect,</span>
<span class="p_add">+					   ov_block_rect, DSS_ADDR_PLANE0);</span>
<span class="p_add">+	wdma_stride = layer-&gt;dst.stride / DMA_ALIGN_BYTES;</span>
<span class="p_add">+</span>
<span class="p_add">+	data_num = (oft_x1 - oft_x0 + 1) * (oft_y1 - oft_y0 + 1);</span>
<span class="p_add">+	if (layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90) {</span>
<span class="p_add">+		wdma-&gt;rot_size = set_bits32(wdma-&gt;rot_size,</span>
<span class="p_add">+					    (DSS_WIDTH(ov_block_rect-&gt;w) |</span>
<span class="p_add">+					     (DSS_HEIGHT(aligned_rect.h) &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ov_block_rect) {</span>
<span class="p_add">+			wdma_buf_width = DSS_HEIGHT(ov_block_rect-&gt;h);</span>
<span class="p_add">+			wdma_buf_height = DSS_WIDTH(ov_block_rect-&gt;w);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			wdma_buf_width = DSS_HEIGHT(layer-&gt;src_rect.h);</span>
<span class="p_add">+			wdma_buf_height = DSS_WIDTH(layer-&gt;src_rect.w);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (ov_block_rect) {</span>
<span class="p_add">+			wdma_buf_width = DSS_WIDTH(ov_block_rect-&gt;w);</span>
<span class="p_add">+			wdma_buf_height = DSS_HEIGHT(ov_block_rect-&gt;h);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			wdma_buf_width = DSS_WIDTH(layer-&gt;src_rect.w);</span>
<span class="p_add">+			wdma_buf_height = DSS_HEIGHT(layer-&gt;src_rect.h);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma-&gt;oft_x0 = set_bits32(wdma-&gt;oft_x0, oft_x0, 12, 0);</span>
<span class="p_add">+	wdma-&gt;oft_y0 = set_bits32(wdma-&gt;oft_y0, oft_y0, 16, 0);</span>
<span class="p_add">+	wdma-&gt;oft_x1 = set_bits32(wdma-&gt;oft_x1, oft_x1, 12, 0);</span>
<span class="p_add">+	wdma-&gt;oft_y1 = set_bits32(wdma-&gt;oft_y1, oft_y1, 16, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma-&gt;ctrl = set_bits32(wdma-&gt;ctrl, wdma_format, 5, 3);</span>
<span class="p_add">+	wdma-&gt;ctrl = set_bits32(wdma-&gt;ctrl, wdma_transform, 3, 9);</span>
<span class="p_add">+	wdma-&gt;ctrl = set_bits32(wdma-&gt;ctrl, (mmu_enable ? 0x1 : 0x0), 1, 8);</span>
<span class="p_add">+	wdma-&gt;data_num = set_bits32(wdma-&gt;data_num, data_num, 30, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma-&gt;ctrl =</span>
<span class="p_add">+	    set_bits32(wdma-&gt;ctrl, ((layer-&gt;need_cap &amp; CAP_TILE) ? 0x1 : 0x0),</span>
<span class="p_add">+		       1, 1);</span>
<span class="p_add">+	wdma-&gt;tile_scram =</span>
<span class="p_add">+	    set_bits32(wdma-&gt;tile_scram,</span>
<span class="p_add">+		       ((layer-&gt;need_cap &amp; CAP_TILE) ? 0x1 : 0x0), 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma-&gt;data_addr = set_bits32(wdma-&gt;data_addr, wdma_addr, 32, 0);</span>
<span class="p_add">+	wdma-&gt;stride0 =</span>
<span class="p_add">+	    set_bits32(wdma-&gt;stride0, wdma_stride | (l2t_interleave_n &lt;&lt; 16),</span>
<span class="p_add">+		       20, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_YUV_SP_420(layer-&gt;dst.format)) {</span>
<span class="p_add">+		wdma_addr =</span>
<span class="p_add">+		    hisi_calculate_display_addr_wb(mmu_enable, layer, in_rect,</span>
<span class="p_add">+						   ov_block_rect, DSS_ADDR_PLANE1);</span>
<span class="p_add">+</span>
<span class="p_add">+		wdma_stride = layer-&gt;dst.stride_plane1 / DMA_ALIGN_BYTES;</span>
<span class="p_add">+		wdma-&gt;data1_addr =</span>
<span class="p_add">+		    set_bits32(wdma-&gt;data1_addr, wdma_addr, 32, 0);</span>
<span class="p_add">+		wdma-&gt;stride1 = set_bits32(wdma-&gt;stride1, wdma_stride, 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last_block) {</span>
<span class="p_add">+		wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 1, 1, 4);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 0, 1, 4);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 1, 1, 3);</span>
<span class="p_add">+	wdma-&gt;ch_ctl = set_bits32(wdma-&gt;ch_ctl, 1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	wdma-&gt;dma_buf_size = set_bits32(wdma-&gt;dma_buf_size,</span>
<span class="p_add">+					wdma_buf_width | (wdma_buf_height &lt;&lt; 16), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS GLOBAL</span>
<span class="p_add">+ */</span>
<span class="p_add">+int hisi_dss_module_init(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;(hisifd-&gt;dss_module), &amp;(hisifd-&gt;dss_module_default),</span>
<span class="p_add">+	       sizeof(dss_module_reg_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_module_default(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_module_reg_t *dss_module = NULL;</span>
<span class="p_add">+	uint32_t module_base = 0;</span>
<span class="p_add">+	char __iomem *dss_base = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	dss_base = hisifd-&gt;dss_base;</span>
<span class="p_add">+	BUG_ON(dss_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_module = &amp;(hisifd-&gt;dss_module_default);</span>
<span class="p_add">+	memset(dss_module, 0, sizeof(dss_module_reg_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_MCTL_IDX_MAX; i++) {</span>
<span class="p_add">+		module_base = g_dss_module_ovl_base[i][MODULE_MCTL_BASE];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_mctl_init(dss_module-&gt;mctl_base[i],</span>
<span class="p_add">+					   &amp;(dss_module-&gt;mctl[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_OVL_IDX_MAX; i++) {</span>
<span class="p_add">+		module_base = g_dss_module_ovl_base[i][MODULE_OVL_BASE];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;ov_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_ovl_init(dss_module-&gt;ov_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;ov[i]), i);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_AIF0_CHN];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;aif_ch_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_aif_init(dss_module-&gt;aif_ch_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;aif[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_AIF1_CHN];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;aif1_ch_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_aif_init(dss_module-&gt;aif1_ch_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;aif1[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MIF_CHN];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mif_ch_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_mif_init(dss_module-&gt;mif_ch_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;mif[i]), i);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MCTL_CHN_MUTEX];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_base[i].chn_mutex_base =</span>
<span class="p_add">+			    dss_base + module_base;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MCTL_CHN_FLUSH_EN];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_base[i].chn_flush_en_base =</span>
<span class="p_add">+			    dss_base + module_base;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MCTL_CHN_OV_OEN];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_base[i].chn_ov_en_base =</span>
<span class="p_add">+			    dss_base + module_base;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MCTL_CHN_STARTY];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_base[i].chn_starty_base =</span>
<span class="p_add">+			    dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_mctl_ch_starty_init(</span>
<span class="p_add">+				dss_module-&gt;mctl_ch_base[i].chn_starty_base,</span>
<span class="p_add">+				&amp;(dss_module-&gt;mctl_ch[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_MCTL_CHN_MOD_DBG];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_base[i].chn_mod_dbg_base =</span>
<span class="p_add">+			    dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_mctl_ch_mod_dbg_init(</span>
<span class="p_add">+				dss_module-&gt;mctl_ch_base[i].chn_mod_dbg_base,</span>
<span class="p_add">+				&amp;(dss_module-&gt;mctl_ch[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_DMA];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;dma_base[i] = dss_base + module_base;</span>
<span class="p_add">+			if (i &lt; DSS_WCHN_W0 || i == DSS_RCHN_V2) {</span>
<span class="p_add">+				hisi_dss_rdma_init(dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						   &amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisi_dss_wdma_init(dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						   &amp;(dss_module-&gt;wdma[i]));</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((i == DSS_RCHN_V0) || (i == DSS_RCHN_V1)</span>
<span class="p_add">+			    || (i == DSS_RCHN_V2)) {</span>
<span class="p_add">+				hisi_dss_rdma_u_init(dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						     &amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+				hisi_dss_rdma_v_init(dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						     &amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_DFC];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;dfc_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_dfc_init(dss_module-&gt;dfc_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;dfc[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_SCL];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;scl_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_scl_init(dss_module-&gt;scl_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;scl[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = DSS_POST_SCF_OFFSET;</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;post_scf_base = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_post_scf_init(dss_module-&gt;post_scf_base,</span>
<span class="p_add">+					       &amp;(dss_module-&gt;post_scf));</span>
<span class="p_add">+		}</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_PCSC];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;pcsc_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_csc_init(dss_module-&gt;pcsc_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;pcsc[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_ARSR2P];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;arsr2p_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_arsr2p_init(dss_module-&gt;arsr2p_base[i],</span>
<span class="p_add">+					     &amp;(dss_module-&gt;arsr2p[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_POST_CLIP];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;post_clip_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_post_clip_init(dss_module-&gt;post_clip_base[i],</span>
<span class="p_add">+						&amp;(dss_module-&gt;post_clip[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		module_base = g_dss_module_base[i][MODULE_CSC];</span>
<span class="p_add">+		if (module_base != 0) {</span>
<span class="p_add">+			dss_module-&gt;csc_base[i] = dss_base + module_base;</span>
<span class="p_add">+			hisi_dss_csc_init(dss_module-&gt;csc_base[i],</span>
<span class="p_add">+					  &amp;(dss_module-&gt;csc[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	module_base = DSS_MCTRL_SYS_OFFSET;</span>
<span class="p_add">+	if (module_base != 0) {</span>
<span class="p_add">+		dss_module-&gt;mctl_sys_base = dss_base + module_base;</span>
<span class="p_add">+		hisi_dss_mctl_sys_init(dss_module-&gt;mctl_sys_base,</span>
<span class="p_add">+				       &amp;(dss_module-&gt;mctl_sys));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	module_base = DSS_SMMU_OFFSET;</span>
<span class="p_add">+	if (module_base != 0) {</span>
<span class="p_add">+		dss_module-&gt;smmu_base = dss_base + module_base;</span>
<span class="p_add">+		hisi_dss_smmu_init(dss_module-&gt;smmu_base, &amp;(dss_module-&gt;smmu));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_ch_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				int32_t mctl_idx, int chn_idx, uint32_t wb_type,</span>
<span class="p_add">+				bool enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_module_reg_t *dss_module = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((chn_idx &lt; 0) || (chn_idx &gt;= DSS_CHN_MAX_DEFINE));</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_module = &amp;(hisifd-&gt;dss_module);</span>
<span class="p_add">+	i = chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		if (chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+			tmp = (0x1 &lt;&lt; DSS_CMDLIST_V2);</span>
<span class="p_add">+			hisifd-&gt;cmdlist_idx = DSS_CMDLIST_V2;</span>
<span class="p_add">+		} else if (chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+			tmp = (0x1 &lt;&lt; DSS_CMDLIST_W2);</span>
<span class="p_add">+			hisifd-&gt;cmdlist_idx = DSS_CMDLIST_W2;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			tmp = (0x1 &lt;&lt; chn_idx);</span>
<span class="p_add">+			hisifd-&gt;cmdlist_idx = chn_idx;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_add_new_node(hisifd, tmp, 0, 0, 0, 0, wb_type);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, hisi_cmdlist_add_new_node err:%d \n&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;mctl_ch_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_mctl_ch_set_reg(hisifd,</span>
<span class="p_add">+					 &amp;(dss_module-&gt;mctl_ch_base[i]),</span>
<span class="p_add">+					 &amp;(dss_module-&gt;mctl_ch[i]), mctl_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;smmu_used == 1) {</span>
<span class="p_add">+		hisi_dss_smmu_ch_set_reg(hisifd, dss_module-&gt;smmu_base,</span>
<span class="p_add">+					 &amp;(dss_module-&gt;smmu), i);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;dma_used[i] == 1) {</span>
<span class="p_add">+		if (i &lt; DSS_WCHN_W0 || i == DSS_RCHN_V2) {</span>
<span class="p_add">+			hisi_dss_rdma_set_reg(hisifd, dss_module-&gt;dma_base[i],</span>
<span class="p_add">+					      &amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			hisi_dss_wdma_set_reg(hisifd, dss_module-&gt;dma_base[i],</span>
<span class="p_add">+					      &amp;(dss_module-&gt;wdma[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((i == DSS_RCHN_V0) || (i == DSS_RCHN_V1)</span>
<span class="p_add">+		    || (i == DSS_RCHN_V2)) {</span>
<span class="p_add">+			hisi_dss_rdma_u_set_reg(hisifd, dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						&amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+			hisi_dss_rdma_v_set_reg(hisifd, dss_module-&gt;dma_base[i],</span>
<span class="p_add">+						&amp;(dss_module-&gt;rdma[i]));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;aif_ch_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_aif_ch_set_reg(hisifd, dss_module-&gt;aif_ch_base[i],</span>
<span class="p_add">+					&amp;(dss_module-&gt;aif[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;aif1_ch_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_aif_ch_set_reg(hisifd, dss_module-&gt;aif1_ch_base[i],</span>
<span class="p_add">+					&amp;(dss_module-&gt;aif1[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;mif_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_mif_set_reg(hisifd, dss_module-&gt;mif_ch_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;mif[i]), i);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;dfc_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_dfc_set_reg(hisifd, dss_module-&gt;dfc_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;dfc[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;scl_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_chn_scl_load_filter_coef_set_reg(hisifd, false,</span>
<span class="p_add">+							  chn_idx,</span>
<span class="p_add">+							  dss_module-&gt;scl[i].fmt);</span>
<span class="p_add">+		hisi_dss_scl_set_reg(hisifd, dss_module-&gt;scl_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;scl[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (hisifd-&gt;dss_module.post_cilp_used[i]) {</span>
<span class="p_add">+		hisi_dss_post_clip_set_reg(hisifd,</span>
<span class="p_add">+					   dss_module-&gt;post_clip_base[i],</span>
<span class="p_add">+					   &amp;(dss_module-&gt;post_clip[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (dss_module-&gt;pcsc_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_csc_set_reg(hisifd, dss_module-&gt;pcsc_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;pcsc[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;arsr2p_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_arsr2p_set_reg(hisifd, dss_module-&gt;arsr2p_base[i],</span>
<span class="p_add">+					&amp;(dss_module-&gt;arsr2p[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;csc_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_csc_set_reg(hisifd, dss_module-&gt;csc_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;csc[i]));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;mctl_ch_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_mctl_sys_ch_set_reg(hisifd,</span>
<span class="p_add">+					     &amp;(dss_module-&gt;mctl_ch_base[i]),</span>
<span class="p_add">+					     &amp;(dss_module-&gt;mctl_ch[i]), i, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_ov_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				dss_overlay_t *pov_req, int ovl_idx,</span>
<span class="p_add">+				bool enable_cmdlist, int task_end, int last,</span>
<span class="p_add">+				bool is_first_ov_block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_module_reg_t *dss_module = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req &amp;&amp; pov_req-&gt;wb_layer_infos[0].chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_module = &amp;(hisifd-&gt;dss_module);</span>
<span class="p_add">+	i = ovl_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		tmp = (0x1 &lt;&lt; (DSS_CMDLIST_OV0 + ovl_idx));</span>
<span class="p_add">+		hisifd-&gt;cmdlist_idx = DSS_CMDLIST_OV0 + ovl_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_cmdlist_add_new_node(hisifd, tmp, 0, task_end, 0, last,</span>
<span class="p_add">+					      0);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, hisi_cmdlist_add_new_node err:%d \n&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;mctl_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_mctl_ov_set_reg(hisifd, dss_module-&gt;mctl_base[i],</span>
<span class="p_add">+					 &amp;(dss_module-&gt;mctl[i]), ovl_idx,</span>
<span class="p_add">+					 enable_cmdlist);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_first_ov_block) {</span>
<span class="p_add">+		if (dss_module-&gt;dirty_region_updt_used == 1)</span>
<span class="p_add">+			hisi_dss_dirty_region_dbuf_set_reg(hisifd,</span>
<span class="p_add">+							   hisifd-&gt;dss_base,</span>
<span class="p_add">+							   &amp;(dss_module-&gt;</span>
<span class="p_add">+							     dirty_region_updt));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;ov_used[i] == 1) {</span>
<span class="p_add">+		hisi_dss_ovl_set_reg(hisifd, dss_module-&gt;ov_base[i],</span>
<span class="p_add">+				     &amp;(dss_module-&gt;ov[i]), ovl_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;dss_module.post_scf_used == 1) {</span>
<span class="p_add">+		hisi_dss_post_scf_set_reg(hisifd,</span>
<span class="p_add">+					  hisifd-&gt;dss_module.post_scf_base,</span>
<span class="p_add">+					  &amp;(hisifd-&gt;dss_module.post_scf));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dss_module-&gt;mctl_sys_used == 1) {</span>
<span class="p_add">+		hisi_dss_mctl_sys_set_reg(hisifd, dss_module-&gt;mctl_sys_base,</span>
<span class="p_add">+					  &amp;(dss_module-&gt;mctl_sys), ovl_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_prev_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				  dss_overlay_t *pov_req,</span>
<span class="p_add">+				  uint32_t cmdlist_pre_idxs,</span>
<span class="p_add">+				  bool enable_cmdlist, bool *use_comm_mmbuf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_module_reg_t *dss_module = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	dss_wb_layer_t *wb_layer = NULL;</span>
<span class="p_add">+	int32_t ovl_idx = 0;</span>
<span class="p_add">+	int32_t layer_idx = 0;</span>
<span class="p_add">+	int32_t mctl_idx = 0;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int j = 0;</span>
<span class="p_add">+	int k = 0;</span>
<span class="p_add">+	int m = 0;</span>
<span class="p_add">+	bool has_base = false;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_temp = 0;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block = NULL;</span>
<span class="p_add">+	dss_mmbuf_t offline_mmbuf[DSS_CHN_MAX_DEFINE];</span>
<span class="p_add">+	bool has_rot = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	ovl_idx = pov_req-&gt;ovl_idx;</span>
<span class="p_add">+	dss_module = &amp;(hisifd-&gt;dss_module);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		if (pov_req-&gt;wb_enable) {</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_cmdlist_add_new_node(hisifd, cmdlist_pre_idxs,</span>
<span class="p_add">+						      0, 1, 1, 1, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_cmdlist_add_new_node(hisifd, cmdlist_pre_idxs,</span>
<span class="p_add">+						      0, 0, 0, 0, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, hisi_cmdlist_add_new_node err:%d \n&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(offline_mmbuf, 0x0, sizeof(offline_mmbuf));</span>
<span class="p_add">+	cmdlist_idxs_temp = cmdlist_pre_idxs;</span>
<span class="p_add">+	pov_h_block_infos = (dss_overlay_block_t *) pov_req-&gt;ov_block_infos_ptr;</span>
<span class="p_add">+	for (m = 0; m &lt; pov_req-&gt;ov_block_nums; m++) {</span>
<span class="p_add">+		pov_h_block = &amp;(pov_h_block_infos[m]);</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; pov_h_block-&gt;layer_nums; i++) {</span>
<span class="p_add">+			layer = &amp;(pov_h_block-&gt;layer_infos[i]);</span>
<span class="p_add">+			chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+			layer_idx = layer-&gt;layer_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+				mctl_idx = DSS_MCTL5;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				mctl_idx = ovl_idx;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (layer-&gt;need_cap &amp; (CAP_BASE | CAP_DIM | CAP_PURE_COLOR)) {</span>
<span class="p_add">+				if (layer-&gt;need_cap &amp; CAP_BASE)</span>
<span class="p_add">+					has_base = true;</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ovl_idx == DSS_OVL0) {</span>
<span class="p_add">+				if ((layer-&gt;need_cap &amp; CAP_AFBCD)</span>
<span class="p_add">+				    &amp;&amp; (layer-&gt;dst_rect.y &gt;=</span>
<span class="p_add">+					pov_h_block-&gt;ov_block_rect.y)) {</span>
<span class="p_add">+					if (j &lt; DSS_CHN_MAX_DEFINE) {</span>
<span class="p_add">+						g_pre_online_mmbuf[j].addr =</span>
<span class="p_add">+						    layer-&gt;img.mmbuf_base;</span>
<span class="p_add">+						g_pre_online_mmbuf[j].size =</span>
<span class="p_add">+						    layer-&gt;img.mmbuf_size;</span>
<span class="p_add">+						j++;</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ovl_idx == DSS_OVL2) {</span>
<span class="p_add">+				if (layer-&gt;need_cap &amp; CAP_AFBCD) {</span>
<span class="p_add">+					if (j &lt; DSS_CHN_MAX_DEFINE) {</span>
<span class="p_add">+						offline_mmbuf[j].addr =</span>
<span class="p_add">+						    layer-&gt;img.mmbuf_base;</span>
<span class="p_add">+						offline_mmbuf[j].size =</span>
<span class="p_add">+						    layer-&gt;img.mmbuf_size;</span>
<span class="p_add">+						j++;</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+				tmp = (0x1 &lt;&lt; DSS_CMDLIST_V2);</span>
<span class="p_add">+				hisifd-&gt;cmdlist_idx = DSS_CMDLIST_V2;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				tmp = (0x1 &lt;&lt; chn_idx);</span>
<span class="p_add">+				hisifd-&gt;cmdlist_idx = chn_idx;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((cmdlist_idxs_temp &amp; tmp) != tmp) {</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				cmdlist_idxs_temp &amp;= (~tmp);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_chn_set_reg_default_value(hisifd,</span>
<span class="p_add">+							   dss_module-&gt;dma_base[chn_idx]);</span>
<span class="p_add">+			hisi_dss_smmu_ch_set_reg(hisifd, dss_module-&gt;smmu_base,</span>
<span class="p_add">+						 &amp;(dss_module-&gt;smmu), chn_idx);</span>
<span class="p_add">+			hisi_dss_mif_set_reg(hisifd,</span>
<span class="p_add">+					     dss_module-&gt;mif_ch_base[chn_idx],</span>
<span class="p_add">+					     &amp;(dss_module-&gt;mif[chn_idx]), chn_idx);</span>
<span class="p_add">+			hisi_dss_aif_ch_set_reg(hisifd,</span>
<span class="p_add">+						dss_module-&gt;aif_ch_base[chn_idx],</span>
<span class="p_add">+						&amp;(dss_module-&gt;aif[chn_idx]));</span>
<span class="p_add">+</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_mutex =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_mutex,</span>
<span class="p_add">+				       0x1, 1, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_flush_en =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_flush_en,</span>
<span class="p_add">+			    	   0x1, 1, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_ov_oen =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_ov_oen,</span>
<span class="p_add">+				       0x0, 32, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_mctl_sys_ch_set_reg(hisifd,</span>
<span class="p_add">+						     &amp;(dss_module-&gt;mctl_ch_base[chn_idx]),</span>
<span class="p_add">+						     &amp;(dss_module-&gt;mctl_ch[chn_idx]),</span>
<span class="p_add">+						     chn_idx, false);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_dump_mmbuf) {</span>
<span class="p_add">+		if (ovl_idx == DSS_OVL0) {</span>
<span class="p_add">+			for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;g_pre_online_mmbuf[%d].addr=%d, size=%d, j=%d\n&quot;,</span>
<span class="p_add">+				     i, g_pre_online_mmbuf[i].addr,</span>
<span class="p_add">+				     g_pre_online_mmbuf[i].size, j);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req-&gt;wb_enable</span>
<span class="p_add">+	    &amp;&amp; ((ovl_idx &gt; DSS_OVL1) || (mctl_idx == DSS_MCTL5))) {</span>
<span class="p_add">+		if (mctl_idx != DSS_MCTL5) {</span>
<span class="p_add">+			hisifd-&gt;cmdlist_idx = DSS_CMDLIST_OV0 + ovl_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_ov_set_reg_default_value(hisifd,</span>
<span class="p_add">+							  dss_module-&gt;ov_base[ovl_idx],</span>
<span class="p_add">+							  ovl_idx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (k = 0; k &lt; pov_req-&gt;wb_layer_nums; k++) {</span>
<span class="p_add">+			wb_layer = &amp;(pov_req-&gt;wb_layer_infos[k]);</span>
<span class="p_add">+			chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+			if (wb_layer-&gt;transform &amp; HISI_FB_TRANSFORM_ROT_90)</span>
<span class="p_add">+				has_rot = true;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (chn_idx == DSS_WCHN_W2) {</span>
<span class="p_add">+				hisifd-&gt;cmdlist_idx = DSS_CMDLIST_W2;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisifd-&gt;cmdlist_idx = chn_idx;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_chn_set_reg_default_value(hisifd,</span>
<span class="p_add">+							   dss_module-&gt;dma_base[chn_idx]);</span>
<span class="p_add">+			hisi_dss_mif_set_reg(hisifd,</span>
<span class="p_add">+					     dss_module-&gt;mif_ch_base[chn_idx],</span>
<span class="p_add">+					     &amp;(dss_module-&gt;mif[chn_idx]), chn_idx);</span>
<span class="p_add">+			hisi_dss_aif_ch_set_reg(hisifd,</span>
<span class="p_add">+						dss_module-&gt;aif_ch_base[chn_idx],</span>
<span class="p_add">+						&amp;(dss_module-&gt;aif[chn_idx]));</span>
<span class="p_add">+</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_mutex =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_mutex,</span>
<span class="p_add">+				       0x1, 1, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_flush_en =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_flush_en,</span>
<span class="p_add">+			    	   0x1, 1, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch[chn_idx].chn_ov_oen =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_ch[chn_idx].chn_ov_oen,</span>
<span class="p_add">+				       0x0, 32, 0);</span>
<span class="p_add">+			dss_module-&gt;mctl_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_mctl_sys_ch_set_reg(hisifd,</span>
<span class="p_add">+						     &amp;(dss_module-&gt;mctl_ch_base[chn_idx]),</span>
<span class="p_add">+						     &amp;(dss_module-&gt;mctl_ch[chn_idx]),</span>
<span class="p_add">+						     chn_idx, false);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mctl_idx != DSS_MCTL5) {</span>
<span class="p_add">+			hisifd-&gt;cmdlist_idx = DSS_CMDLIST_OV0 + ovl_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+			dss_module-&gt;mctl_sys.chn_ov_sel_used[ovl_idx] = 1;</span>
<span class="p_add">+			dss_module-&gt;mctl_sys.wch_ov_sel_used[ovl_idx -</span>
<span class="p_add">+							     DSS_OVL2] = 1;</span>
<span class="p_add">+			dss_module-&gt;mctl_sys.ov_flush_en_used[ovl_idx] = 1;</span>
<span class="p_add">+			dss_module-&gt;mctl_sys.ov_flush_en[ovl_idx] =</span>
<span class="p_add">+			    set_bits32(dss_module-&gt;mctl_sys.ov_flush_en[ovl_idx],</span>
<span class="p_add">+			    	   0x1, 1, 0);</span>
<span class="p_add">+			hisi_dss_mctl_sys_set_reg(hisifd,</span>
<span class="p_add">+						  dss_module-&gt;mctl_sys_base,</span>
<span class="p_add">+						  &amp;(dss_module-&gt;mctl_sys), ovl_idx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+			for (k = 0; k &lt; DSS_CHN_MAX_DEFINE; k++) {</span>
<span class="p_add">+				if ((((offline_mmbuf[i].addr &lt;</span>
<span class="p_add">+					   g_pre_online_mmbuf[k].addr + g_pre_online_mmbuf[k].size)</span>
<span class="p_add">+				      &amp;&amp; (offline_mmbuf[i].addr &gt;=</span>
<span class="p_add">+				       g_pre_online_mmbuf[k].addr))</span>
<span class="p_add">+				     ||</span>
<span class="p_add">+				      ((g_pre_online_mmbuf[k].addr &lt;</span>
<span class="p_add">+				       offline_mmbuf[i].addr + offline_mmbuf[i].size)</span>
<span class="p_add">+				      &amp;&amp; (g_pre_online_mmbuf[k].addr &gt;=</span>
<span class="p_add">+					   offline_mmbuf[i].addr)))</span>
<span class="p_add">+				    &amp;&amp; offline_mmbuf[i].size) {</span>
<span class="p_add">+					if (use_comm_mmbuf) {</span>
<span class="p_add">+						*use_comm_mmbuf = true;</span>
<span class="p_add">+						break;</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_debug_dump_mmbuf) {</span>
<span class="p_add">+			for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;offline_mmbuf[%d].addr=%d, size=%d, use_comm_mmbuf=%d, j=%d\n&quot;,</span>
<span class="p_add">+				     i, offline_mmbuf[i].addr,</span>
<span class="p_add">+				     offline_mmbuf[i].size, *use_comm_mmbuf, j);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!has_rot) {</span>
<span class="p_add">+			memset(g_pre_online_mmbuf, 0x0,</span>
<span class="p_add">+			       sizeof(g_pre_online_mmbuf));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_unflow_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req, bool unmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	if (pov_req-&gt;ovl_idx == DSS_OVL0) {</span>
<span class="p_add">+		tmp =</span>
<span class="p_add">+		    inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET +</span>
<span class="p_add">+			  LDI_CPU_ITF_INT_MSK);</span>
<span class="p_add">+		if (unmask) {</span>
<span class="p_add">+			tmp &amp;= ~BIT_LDI_UNFLOW;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			tmp |= BIT_LDI_UNFLOW;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK,</span>
<span class="p_add">+		       tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (pov_req-&gt;ovl_idx == DSS_OVL1) {</span>
<span class="p_add">+		tmp =</span>
<span class="p_add">+		    inp32(hisifd-&gt;dss_base + DSS_LDI1_OFFSET +</span>
<span class="p_add">+			  LDI_CPU_ITF_INT_MSK);</span>
<span class="p_add">+		if (unmask) {</span>
<span class="p_add">+			tmp &amp;= ~BIT_LDI_UNFLOW;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			tmp |= BIT_LDI_UNFLOW;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_LDI1_OFFSET + LDI_CPU_ITF_INT_MSK,</span>
<span class="p_add">+		       tmp);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** compose handler</span>
<span class="p_add">+ */</span>
<span class="p_add">+int hisi_ov_compose_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req,</span>
<span class="p_add">+			    dss_overlay_block_t *pov_h_block,</span>
<span class="p_add">+			    dss_layer_t *layer,</span>
<span class="p_add">+			    dss_rect_t *wb_dst_rect,</span>
<span class="p_add">+			    dss_rect_t *wb_ov_block_rect,</span>
<span class="p_add">+			    dss_rect_ltrb_t *clip_rect,</span>
<span class="p_add">+			    dss_rect_t *aligned_rect,</span>
<span class="p_add">+			    bool *rdma_stretch_enable,</span>
<span class="p_add">+			    bool *has_base,</span>
<span class="p_add">+			    bool csc_needed, bool enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int32_t mctl_idx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_h_block == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+	BUG_ON(clip_rect == NULL);</span>
<span class="p_add">+	BUG_ON(aligned_rect == NULL);</span>
<span class="p_add">+	BUG_ON(rdma_stretch_enable == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_check_layer_par(hisifd, layer);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_check_layer_par failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; (CAP_BASE | CAP_DIM | CAP_PURE_COLOR)) {</span>
<span class="p_add">+		if (layer-&gt;need_cap &amp; CAP_BASE)</span>
<span class="p_add">+			*has_base = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ovl_layer_config(hisifd, pov_req, layer,</span>
<span class="p_add">+					      wb_ov_block_rect, *has_base);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;hisi_dss_ovl_config failed! need_cap=0x%x, ret=%d\n&quot;,</span>
<span class="p_add">+			     layer-&gt;need_cap, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_mctl_ch_config(hisifd, pov_req, layer, NULL,</span>
<span class="p_add">+					    pov_req-&gt;ovl_idx, wb_ov_block_rect,</span>
<span class="p_add">+					    *has_base);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;hisi_dss_mctl_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_block_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;layer-&gt;dst_rect.y=%d, pov_h_block-&gt;ov_block_rect.y=%d,&quot;</span>
<span class="p_add">+		     &quot;layer-&gt;chn_idx=%d, layer-&gt;layer_idx=%d\n&quot;,</span>
<span class="p_add">+		     layer-&gt;dst_rect.y, pov_h_block-&gt;ov_block_rect.y,</span>
<span class="p_add">+		     layer-&gt;chn_idx, layer-&gt;layer_idx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;dst_rect.y &lt; pov_h_block-&gt;ov_block_rect.y) {</span>
<span class="p_add">+		if (g_debug_ovl_block_composer) {</span>
<span class="p_add">+			HISI_FB_INFO</span>
<span class="p_add">+			    (&quot;layer-&gt;dst_rect.y=%d, pov_h_block-&gt;ov_block_rect.y=%d,&quot;</span>
<span class="p_add">+			     &quot;layer-&gt;chn_idx=%d, layer-&gt;layer_idx=%d!!!!\n&quot;,</span>
<span class="p_add">+			     layer-&gt;dst_rect.y, pov_h_block-&gt;ov_block_rect.y,</span>
<span class="p_add">+			     layer-&gt;chn_idx, layer-&gt;layer_idx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ovl_layer_config(hisifd, pov_req, layer,</span>
<span class="p_add">+					      wb_ov_block_rect, *has_base);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;hisi_dss_ovl_config failed, ret = %d\n&quot;,</span>
<span class="p_add">+				    ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_mctl_ch_config(hisifd, pov_req, layer, NULL,</span>
<span class="p_add">+					    pov_req-&gt;ovl_idx, wb_ov_block_rect,</span>
<span class="p_add">+					    *has_base);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;hisi_dss_mctl_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_smmu_ch_config(hisifd, layer, NULL);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_smmu_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;fb%d, rdma input, src_rect(%d,%d,%d,%d), &quot;</span>
<span class="p_add">+		     &quot;src_rect_mask(%d,%d,%d,%d), dst_rect(%d,%d,%d,%d).\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, layer-&gt;src_rect.x, layer-&gt;src_rect.y,</span>
<span class="p_add">+		     layer-&gt;src_rect.w, layer-&gt;src_rect.h,</span>
<span class="p_add">+		     layer-&gt;src_rect_mask.x, layer-&gt;src_rect_mask.y,</span>
<span class="p_add">+		     layer-&gt;src_rect_mask.w, layer-&gt;src_rect_mask.h,</span>
<span class="p_add">+		     layer-&gt;dst_rect.x, layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+		     layer-&gt;dst_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_rdma_config(hisifd, pov_req-&gt;ovl_idx, layer,</span>
<span class="p_add">+				   clip_rect, aligned_rect,</span>
<span class="p_add">+				   rdma_stretch_enable);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_rdma_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;fb%d, rdma output, clip_rect(%d,%d,%d,%d), &quot;</span>
<span class="p_add">+		     &quot;aligned_rect(%d,%d,%d,%d), dst_rect(%d,%d,%d,%d).\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, clip_rect-&gt;left, clip_rect-&gt;right,</span>
<span class="p_add">+		     clip_rect-&gt;top, clip_rect-&gt;bottom, aligned_rect-&gt;x,</span>
<span class="p_add">+		     aligned_rect-&gt;y, aligned_rect-&gt;w, aligned_rect-&gt;h,</span>
<span class="p_add">+		     layer-&gt;dst_rect.x, layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+		     layer-&gt;dst_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_aif_ch_config(hisifd, pov_req, layer, wb_dst_rect, NULL,</span>
<span class="p_add">+				   pov_req-&gt;ovl_idx);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_aif_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_aif1_ch_config(hisifd, pov_req, layer, NULL,</span>
<span class="p_add">+				    pov_req-&gt;ovl_idx);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_aif1_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_mif_config(hisifd, layer, NULL, *rdma_stretch_enable);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_mif_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_rdfc_config(hisifd, layer, aligned_rect, *clip_rect);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_rdfc_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;fb%d, rdfc output, clip_rect(%d,%d,%d,%d), &quot;</span>
<span class="p_add">+		     &quot;aligned_rect(%d,%d,%d,%d), dst_rect(%d,%d,%d,%d).\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, clip_rect-&gt;left, clip_rect-&gt;right,</span>
<span class="p_add">+		     clip_rect-&gt;top, clip_rect-&gt;bottom, aligned_rect-&gt;x,</span>
<span class="p_add">+		     aligned_rect-&gt;y, aligned_rect-&gt;w, aligned_rect-&gt;h,</span>
<span class="p_add">+		     layer-&gt;dst_rect.x, layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+		     layer-&gt;dst_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_scl_config(hisifd, layer, aligned_rect,</span>
<span class="p_add">+				*rdma_stretch_enable);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_scl_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr2p_config(hisifd, layer, aligned_rect,</span>
<span class="p_add">+				   *rdma_stretch_enable);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_arsr2p_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hisi_dss_post_clip_config(hisifd, layer);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_post_clip_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			    ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+		HISI_FB_INFO</span>
<span class="p_add">+		    (&quot;fb%d, scf output, clip_rect(%d,%d,%d,%d), &quot;</span>
<span class="p_add">+		     &quot;aligned_rect(%d,%d,%d,%d), dst_rect(%d,%d,%d,%d).\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, clip_rect-&gt;left, clip_rect-&gt;right,</span>
<span class="p_add">+		     clip_rect-&gt;top, clip_rect-&gt;bottom, aligned_rect-&gt;x,</span>
<span class="p_add">+		     aligned_rect-&gt;y, aligned_rect-&gt;w, aligned_rect-&gt;h,</span>
<span class="p_add">+		     layer-&gt;dst_rect.x, layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+		     layer-&gt;dst_rect.h);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (csc_needed) {</span>
<span class="p_add">+		ret = hisi_dss_csc_config(hisifd, layer, NULL);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;hisi_dss_csc_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+				    ret);</span>
<span class="p_add">+			goto err_return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_ovl_layer_config(hisifd, pov_req, layer, wb_ov_block_rect,</span>
<span class="p_add">+				      *has_base);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_ovl_config failed, ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_mctl_ch_config(hisifd, pov_req, layer, NULL,</span>
<span class="p_add">+				    pov_req-&gt;ovl_idx, wb_ov_block_rect,</span>
<span class="p_add">+				    *has_base);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisi_dss_mctl_ch_config failed! ret = %d\n&quot;, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;chn_idx == DSS_RCHN_V2) {</span>
<span class="p_add">+		mctl_idx = DSS_MCTL5;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mctl_idx = pov_req-&gt;ovl_idx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_ch_module_set_regs(hisifd, mctl_idx, layer-&gt;chn_idx, 0,</span>
<span class="p_add">+					enable_cmdlist);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, hisi_dss_ch_module_set_regs failed! ret = %d\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, ret);</span>
<span class="p_add">+		goto err_return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_return:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+DEFINE_SEMAPHORE(hisi_dss_mmbuf_sem);</span>
<span class="p_add">+static int mmbuf_refcount = 0;</span>
<span class="p_add">+static int dss_sr_refcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+struct hisifb_mmbuf {</span>
<span class="p_add">+	struct list_head list_node;</span>
<span class="p_add">+	uint32_t addr;</span>
<span class="p_add">+	uint32_t size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct list_head *g_mmbuf_list = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisifb_dss_on(struct hisi_fb_data_type *hisifd, int enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int prev_refcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +.\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	prev_refcount = dss_sr_refcount++;</span>
<span class="p_add">+	if (!prev_refcount) {</span>
<span class="p_add">+		hisi_dss_qos_on(hisifd);</span>
<span class="p_add">+		hisi_dss_mmbuf_on(hisifd);</span>
<span class="p_add">+		hisi_dss_mif_on(hisifd);</span>
<span class="p_add">+		hisi_dss_smmu_on(hisifd);</span>
<span class="p_add">+		hisi_dss_scl_coef_on(hisifd, false, SCL_COEF_YUV_IDX);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable_cmdlist) {</span>
<span class="p_add">+			hisi_dss_cmdlist_qos_on(hisifd);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -, dss_sr_refcount=%d.\n&quot;, hisifd-&gt;index,</span>
<span class="p_add">+		      dss_sr_refcount);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void hisifb_dss_off(struct hisi_fb_data_type *hisifd, bool is_lp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisifb_mmbuf *node, *_node_;</span>
<span class="p_add">+	int new_refcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +.\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+	new_refcount = --dss_sr_refcount;</span>
<span class="p_add">+	WARN_ON(new_refcount &lt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_lp) {</span>
<span class="p_add">+		if (!new_refcount) {</span>
<span class="p_add">+			hisifd-&gt;ldi_data_gate_en = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			memset(&amp;(hisifd-&gt;ov_block_infos_prev_prev), 0,</span>
<span class="p_add">+			       HISI_DSS_OV_BLOCK_NUMS *</span>
<span class="p_add">+			       sizeof(dss_overlay_block_t));</span>
<span class="p_add">+			memset(&amp;hisifd-&gt;ov_req_prev_prev, 0,</span>
<span class="p_add">+			       sizeof(dss_overlay_t));</span>
<span class="p_add">+			memset(&amp;(hisifd-&gt;ov_block_infos_prev), 0,</span>
<span class="p_add">+			       HISI_DSS_OV_BLOCK_NUMS *</span>
<span class="p_add">+			       sizeof(dss_overlay_block_t));</span>
<span class="p_add">+			memset(&amp;hisifd-&gt;ov_req_prev, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+			memset(&amp;(hisifd-&gt;ov_block_infos), 0,</span>
<span class="p_add">+			       HISI_DSS_OV_BLOCK_NUMS *</span>
<span class="p_add">+			       sizeof(dss_overlay_block_t));</span>
<span class="p_add">+			memset(&amp;hisifd-&gt;ov_req, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!g_mmbuf_list || is_lp) {</span>
<span class="p_add">+		up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_refcount) {</span>
<span class="p_add">+		list_for_each_entry_safe(node, _node_, g_mmbuf_list, list_node) {</span>
<span class="p_add">+			if ((node-&gt;addr &gt; 0) &amp;&amp; (node-&gt;size &gt; 0)) {</span>
<span class="p_add">+				gen_pool_free(hisifd-&gt;mmbuf_gen_pool,</span>
<span class="p_add">+					      node-&gt;addr, node-&gt;size);</span>
<span class="p_add">+				HISI_FB_DEBUG</span>
<span class="p_add">+				    (&quot;hisi_dss_mmbuf_free, addr=0x%x, size=%d.\n&quot;,</span>
<span class="p_add">+				     node-&gt;addr, node-&gt;size);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			list_del(&amp;node-&gt;list_node);</span>
<span class="p_add">+			kfree(node);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -, dss_sr_refcount=%d.\n&quot;, hisifd-&gt;index,</span>
<span class="p_add">+		      dss_sr_refcount);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void *hisi_dss_mmbuf_init(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gen_pool *pool = NULL;</span>
<span class="p_add">+	int order = 3;</span>
<span class="p_add">+	size_t size = MMBUF_SIZE_MAX;</span>
<span class="p_add">+	uint32_t addr = MMBUF_BASE;</span>
<span class="p_add">+	int prev_refcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +.\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	prev_refcount = mmbuf_refcount++;</span>
<span class="p_add">+	if (!prev_refcount) {</span>
<span class="p_add">+		pool = gen_pool_create(order, 0);</span>
<span class="p_add">+		if (pool == NULL) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, gen_pool_create failed!&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (gen_pool_add(pool, addr, size, 0) != 0) {</span>
<span class="p_add">+			gen_pool_destroy(pool);</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, gen_pool_add failed!&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		g_mmbuf_gen_pool = pool;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!g_mmbuf_list) {</span>
<span class="p_add">+			g_mmbuf_list =</span>
<span class="p_add">+			    kzalloc(sizeof(struct list_head), GFP_KERNEL);</span>
<span class="p_add">+			BUG_ON(g_mmbuf_list == NULL);</span>
<span class="p_add">+			INIT_LIST_HEAD(g_mmbuf_list);</span>
<span class="p_add">+		}</span>
<span class="p_add">+#ifdef CONFIG_SMMU_RWERRADDR_USED</span>
<span class="p_add">+		if (!g_smmu_rwerraddr_virt) {</span>
<span class="p_add">+			g_smmu_rwerraddr_virt =</span>
<span class="p_add">+			    kmalloc(SMMU_RW_ERR_ADDR_SIZE,</span>
<span class="p_add">+				    GFP_KERNEL | __GFP_DMA);</span>
<span class="p_add">+			if (g_smmu_rwerraddr_virt) {</span>
<span class="p_add">+				memset(g_smmu_rwerraddr_virt, 0,</span>
<span class="p_add">+				       SMMU_RW_ERR_ADDR_SIZE);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;kmalloc g_smmu_rwerraddr_virt fail.\n&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;mmbuf_gen_pool = g_mmbuf_gen_pool;</span>
<span class="p_add">+	hisifd-&gt;mmbuf_list = g_mmbuf_list;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_out:</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -, mmbuf_refcount=%d.\n&quot;, hisifd-&gt;index,</span>
<span class="p_add">+		      mmbuf_refcount);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pool;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mmbuf_deinit(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int new_refcount = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +.\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_dss_off(hisifd, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+	new_refcount = --mmbuf_refcount;</span>
<span class="p_add">+	WARN_ON(new_refcount &lt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_refcount) {</span>
<span class="p_add">+		if (g_mmbuf_gen_pool) {</span>
<span class="p_add">+			gen_pool_destroy(g_mmbuf_gen_pool);</span>
<span class="p_add">+			g_mmbuf_gen_pool = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_mmbuf_list) {</span>
<span class="p_add">+			kfree(g_mmbuf_list);</span>
<span class="p_add">+			g_mmbuf_list = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+#ifdef CONFIG_SMMU_RWERRADDR_USED</span>
<span class="p_add">+		if (g_smmu_rwerraddr_virt) {</span>
<span class="p_add">+			kfree(g_smmu_rwerraddr_virt);</span>
<span class="p_add">+			g_smmu_rwerraddr_virt = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;mmbuf_gen_pool = NULL;</span>
<span class="p_add">+	hisifd-&gt;mmbuf_list = NULL;</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -, mmbuf_refcount=%d.\n&quot;, hisifd-&gt;index,</span>
<span class="p_add">+		      mmbuf_refcount);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+uint32_t hisi_dss_mmbuf_alloc(void *handle, uint32_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t addr = 0;</span>
<span class="p_add">+	struct hisifb_mmbuf *node = NULL;</span>
<span class="p_add">+	struct hisifb_mmbuf *mmbuf_node, *_node_;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == handle) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;handle is NULL!\n&quot;);</span>
<span class="p_add">+		return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == g_mmbuf_list) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;g_mmbuf_list is NULL!\n&quot;);</span>
<span class="p_add">+		return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= 0 || size &gt; MMBUF_SIZE_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;mmbuf size is invalid, size=%d!\n&quot;, size);</span>
<span class="p_add">+		return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = gen_pool_alloc(handle, size);</span>
<span class="p_add">+	if (addr &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_INFO(&quot;note: mmbuf not enough,addr=0x%x\n&quot;, addr);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		node = kzalloc(sizeof(struct hisifb_mmbuf), GFP_KERNEL);</span>
<span class="p_add">+		if (node) {</span>
<span class="p_add">+			node-&gt;addr = addr;</span>
<span class="p_add">+			node-&gt;size = size;</span>
<span class="p_add">+			list_add_tail(&amp;node-&gt;list_node, g_mmbuf_list);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;kzalloc struct hisifb_mmbuf fail!\n&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((addr &amp; (MMBUF_ADDR_ALIGN - 1))</span>
<span class="p_add">+		    || (size &amp; (MMBUF_ADDR_ALIGN - 1))) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;addr(0x%x) is not %d bytes aligned, &quot;</span>
<span class="p_add">+			     &quot;or size(0x%x) is not %d bytes&quot;</span>
<span class="p_add">+			     &quot;aligned!\n&quot;, addr, MMBUF_ADDR_ALIGN, size,</span>
<span class="p_add">+			     MMBUF_ADDR_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+			list_for_each_entry_safe(mmbuf_node, _node_,</span>
<span class="p_add">+						 g_mmbuf_list, list_node) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;mmbuf_node_addr(0x%x), mmbuf_node_size(0x%x)!\n&quot;,</span>
<span class="p_add">+				     mmbuf_node-&gt;addr, mmbuf_node-&gt;size);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;addr=0x%x, size=%d.\n&quot;, addr, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mmbuf_free(void *handle, uint32_t addr, uint32_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisifb_mmbuf *node, *_node_;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == handle) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;handle is NULL!\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == g_mmbuf_list) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;g_mmbuf_list is NULL!\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(node, _node_, g_mmbuf_list, list_node) {</span>
<span class="p_add">+		if ((node-&gt;addr == addr) &amp;&amp; (node-&gt;size == size)) {</span>
<span class="p_add">+			gen_pool_free(handle, addr, size);</span>
<span class="p_add">+			list_del(&amp;node-&gt;list_node);</span>
<span class="p_add">+			kfree(node);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	up(&amp;hisi_dss_mmbuf_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;addr=0x%x, size=%d.\n&quot;, addr, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mmbuf_info_clear(struct hisi_fb_data_type *hisifd, int idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	dss_mmbuf_info_t *mmbuf_info = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((idx &lt; 0) || (idx &gt;= HISI_DSS_CMDLIST_DATA_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	mmbuf_info = &amp;(hisifd-&gt;mmbuf_infos[idx]);</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+		if (mmbuf_info-&gt;mm_used[i] == 1) {</span>
<span class="p_add">+			hisi_dss_mmbuf_free(g_mmbuf_gen_pool,</span>
<span class="p_add">+					    mmbuf_info-&gt;mm_base[i],</span>
<span class="p_add">+					    mmbuf_info-&gt;mm_size[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+				HISI_FB_INFO(&quot;fb%d, mm_base(0x%x, %d).\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index,</span>
<span class="p_add">+					     mmbuf_info-&gt;mm_base[i],</span>
<span class="p_add">+					     mmbuf_info-&gt;mm_size[i]);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			mmbuf_info-&gt;mm_base[i] = 0;</span>
<span class="p_add">+			mmbuf_info-&gt;mm_size[i] = 0;</span>
<span class="p_add">+			mmbuf_info-&gt;mm_used[i] = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_mmbuf_info_get_online(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = (hisifd-&gt;frame_count + 1) % HISI_DSS_CMDLIST_DATA_MAX;</span>
<span class="p_add">+	hisi_dss_mmbuf_info_clear(hisifd, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = hisifd-&gt;frame_count % HISI_DSS_CMDLIST_DATA_MAX;</span>
<span class="p_add">+	hisifd-&gt;mmbuf_info = &amp;(hisifd-&gt;mmbuf_infos[tmp]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+void hisi_dss_mmbuf_on(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+	outp32(hisifd-&gt;mmbuf_crg_base + SMC_LOCK, 0x5A5A5A5A);</span>
<span class="p_add">+	outp32(hisifd-&gt;mmbuf_crg_base + SMC_MEM_LP, 0x00000712);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_overlay_fastboot(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block_infos = NULL;</span>
<span class="p_add">+	dss_overlay_block_t *pov_h_block = NULL;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+		memset(pov_req_prev, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+		pov_req_prev-&gt;ov_block_infos_ptr =</span>
<span class="p_add">+		    (uint64_t) (&amp;(hisifd-&gt;ov_block_infos_prev));</span>
<span class="p_add">+		pov_req_prev-&gt;ov_block_nums = 1;</span>
<span class="p_add">+		pov_req_prev-&gt;ovl_idx = DSS_OVL0;</span>
<span class="p_add">+</span>
<span class="p_add">+		pov_h_block_infos =</span>
<span class="p_add">+		    (dss_overlay_block_t *) pov_req_prev-&gt;ov_block_infos_ptr;</span>
<span class="p_add">+		pov_h_block = &amp;(pov_h_block_infos[0]);</span>
<span class="p_add">+		pov_h_block-&gt;layer_nums = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		layer = &amp;(pov_h_block-&gt;layer_infos[0]);</span>
<span class="p_add">+		layer-&gt;img.mmu_enable = 0;</span>
<span class="p_add">+		layer-&gt;layer_idx = 0x0;</span>
<span class="p_add">+		layer-&gt;chn_idx = DSS_RCHN_D0;</span>
<span class="p_add">+		layer-&gt;need_cap = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(&amp;(hisifd-&gt;dss_module_default.rdma[DSS_RCHN_D0]),</span>
<span class="p_add">+		       &amp;(hisifd-&gt;dss_module_default.rdma[DSS_RCHN_D3]),</span>
<span class="p_add">+		       sizeof(dss_rdma_t));</span>
<span class="p_add">+		memcpy(&amp;(hisifd-&gt;dss_module_default.dfc[DSS_RCHN_D0]),</span>
<span class="p_add">+		       &amp;(hisifd-&gt;dss_module_default.dfc[DSS_RCHN_D3]),</span>
<span class="p_add">+		       sizeof(dss_dfc_t));</span>
<span class="p_add">+		memcpy(&amp;(hisifd-&gt;dss_module_default.ov[DSS_OVL0].ovl_layer[0]),</span>
<span class="p_add">+		       &amp;(hisifd-&gt;dss_module_default.ov[DSS_OVL0].ovl_layer[1]),</span>
<span class="p_add">+		       sizeof(dss_ovl_layer_t));</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(&amp;(hisifd-&gt;dss_module_default.mctl_ch[DSS_RCHN_D0]), 0,</span>
<span class="p_add">+		       sizeof(dss_mctl_ch_t));</span>
<span class="p_add">+		memset(&amp;(hisifd-&gt;dss_module_default.mctl[DSS_OVL0]), 0,</span>
<span class="p_add">+		       sizeof(dss_mctl_t));</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;dss_module_default.mctl_sys.chn_ov_sel[DSS_OVL0] =</span>
<span class="p_add">+		    0xFFFFFFFF;</span>
<span class="p_add">+		hisifd-&gt;dss_module_default.mctl_sys.ov_flush_en[DSS_OVL0] = 0x0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+			if (hisifd-&gt;vactive0_start_flag == 0) {</span>
<span class="p_add">+				hisifd-&gt;vactive0_start_flag = 1;</span>
<span class="p_add">+				hisifd-&gt;vactive0_end_flag = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_on(struct hisi_fb_data_type *hisifd, bool fastboot_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int ovl_idx = 0;</span>
<span class="p_add">+	int mctl_idx = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs = 0;</span>
<span class="p_add">+	int enable_cmdlist = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;(hisifd-&gt;sbl), 0, sizeof(dss_sbl_t));</span>
<span class="p_add">+	hisifd-&gt;sbl_enable = 0;</span>
<span class="p_add">+	hisifd-&gt;sbl_lsensor_value = 0;</span>
<span class="p_add">+	hisifd-&gt;sbl_level = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;vactive0_start_flag = 0;</span>
<span class="p_add">+	hisifd-&gt;vactive0_end_flag = 0;</span>
<span class="p_add">+	hisifd-&gt;crc_flag = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.x = 0;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.y = 0;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.x = 0;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.y = 0;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.x = 0;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.y = 0;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;ov_req, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+	hisifd-&gt;ov_req.frame_no = 0xFFFFFFFF;</span>
<span class="p_add">+</span>
<span class="p_add">+	g_offline_cmdlist_idxs = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+	if (g_dss_module_resource_initialized == 0) {</span>
<span class="p_add">+		hisi_dss_module_default(hisifd);</span>
<span class="p_add">+		g_dss_module_resource_initialized = 1;</span>
<span class="p_add">+		hisifd-&gt;dss_module_resource_initialized = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hisifd-&gt;dss_module_resource_initialized) {</span>
<span class="p_add">+		if (hisifd-&gt;index != PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+			memcpy(&amp;(hisifd-&gt;dss_module_default),</span>
<span class="p_add">+			       &amp;(hisifd_list[PRIMARY_PANEL_IDX]-&gt;</span>
<span class="p_add">+				 dss_module_default), sizeof(dss_module_reg_t));</span>
<span class="p_add">+		}</span>
<span class="p_add">+		hisifd-&gt;dss_module_resource_initialized = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#else</span>
<span class="p_add">+	if ((hisifd-&gt;index == PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    (hisifd-&gt;index == EXTERNAL_PANEL_IDX)) {</span>
<span class="p_add">+		hisifb_activate_vsync(hisifd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_dss_module_resource_initialized == 0) {</span>
<span class="p_add">+		hisi_dss_module_default(hisifd);</span>
<span class="p_add">+		g_dss_module_resource_initialized = 1;</span>
<span class="p_add">+		hisifd-&gt;dss_module_resource_initialized = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!hisifd-&gt;dss_module_resource_initialized) {</span>
<span class="p_add">+			if (hisifd-&gt;index != PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+				if (hisifd_list[PRIMARY_PANEL_IDX]) {</span>
<span class="p_add">+					memcpy(&amp;(hisifd-&gt;dss_module_default),</span>
<span class="p_add">+					       &amp;(hisifd_list</span>
<span class="p_add">+						 [PRIMARY_PANEL_IDX]-&gt;</span>
<span class="p_add">+						 dss_module_default),</span>
<span class="p_add">+					       sizeof(dss_module_reg_t));</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+			hisifd-&gt;dss_module_resource_initialized = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_cmdlist = g_enable_ovl_cmdlist_online;</span>
<span class="p_add">+	hisifb_dss_on(hisifd, enable_cmdlist);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index == PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    (hisifd-&gt;index == EXTERNAL_PANEL_IDX)) {</span>
<span class="p_add">+		if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+			ovl_idx = DSS_OVL0;</span>
<span class="p_add">+			mctl_idx = DSS_MCTL0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ovl_idx = DSS_OVL1;</span>
<span class="p_add">+			mctl_idx = DSS_MCTL1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((hisifd-&gt;index == EXTERNAL_PANEL_IDX)</span>
<span class="p_add">+		    &amp;&amp; hisifd-&gt;panel_info.fake_hdmi)</span>
<span class="p_add">+			enable_cmdlist = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		ldi_data_gate(hisifd, true);</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_dss_mctl_on(hisifd, mctl_idx, enable_cmdlist,</span>
<span class="p_add">+				 fastboot_enable);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (fastboot_enable) {</span>
<span class="p_add">+			hisi_overlay_fastboot(hisifd);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = hisi_dss_module_init(hisifd);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, failed to hisi_dss_module_init! ret = %d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (enable_cmdlist) {</span>
<span class="p_add">+				hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+				hisi_cmdlist_data_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+				cmdlist_idxs =</span>
<span class="p_add">+				    (0x1 &lt;&lt; (ovl_idx + DSS_CMDLIST_OV0));</span>
<span class="p_add">+				hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs,</span>
<span class="p_add">+							  0, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+				hisi_dss_mctl_mutex_lock(hisifd, ovl_idx);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			hisifd-&gt;ov_req_prev.ovl_idx = ovl_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_ovl_base_config(hisifd, NULL, NULL, NULL,</span>
<span class="p_add">+						     ovl_idx, 0);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, faile to hisi_dss_ovl_base_config! ret=%d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_mctl_ov_config(hisifd, NULL, ovl_idx,</span>
<span class="p_add">+						    false, true);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, faile to hisi_dss_mctl_config! ret=%d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_dss_ov_module_set_regs(hisifd, NULL, ovl_idx,</span>
<span class="p_add">+							enable_cmdlist, 1, 0,</span>
<span class="p_add">+							true);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, failed to hisi_dss_module_config! ret = %d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (enable_cmdlist) {</span>
<span class="p_add">+				hisi_cmdlist_flush_cache(hisifd,</span>
<span class="p_add">+							 hisifd-&gt;ion_client,</span>
<span class="p_add">+							 cmdlist_idxs);</span>
<span class="p_add">+				hisi_cmdlist_config_start(hisifd, mctl_idx,</span>
<span class="p_add">+							  cmdlist_idxs, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hisi_dss_mctl_mutex_unlock(hisifd, ovl_idx);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			single_frame_update(hisifd);</span>
<span class="p_add">+			enable_ldi(hisifd);</span>
<span class="p_add">+			hisifb_frame_updated(hisifd);</span>
<span class="p_add">+			hisifd-&gt;frame_count++;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_cmdlist) {</span>
<span class="p_add">+				hisi_cmdlist_dump_all_node(hisifd, NULL,</span>
<span class="p_add">+							   cmdlist_idxs);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+ err_out:</span>
<span class="p_add">+		hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+	} else if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		enable_cmdlist = g_enable_ovl_cmdlist_offline;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_dss_mctl_on(hisifd, DSS_MCTL2, enable_cmdlist, 0);</span>
<span class="p_add">+		hisi_dss_mctl_on(hisifd, DSS_MCTL3, enable_cmdlist, 0);</span>
<span class="p_add">+		hisi_dss_mctl_on(hisifd, DSS_MCTL5, enable_cmdlist, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not supported!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_off(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int ovl_idx = 0;</span>
<span class="p_add">+	uint32_t cmdlist_pre_idxs = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs = 0;</span>
<span class="p_add">+	int enable_cmdlist = 0;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, +\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index == PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    (hisifd-&gt;index == EXTERNAL_PANEL_IDX)) {</span>
<span class="p_add">+		hisifb_activate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = hisi_vactive0_start_config(hisifd, pov_req_prev);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_vactive0_start_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hisifd-&gt;aod_function == 1) {</span>
<span class="p_add">+			HISI_FB_INFO(&quot;fb%d, aod mode\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+			ovl_idx = DSS_OVL0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ovl_idx = DSS_OVL1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		enable_cmdlist = g_enable_ovl_cmdlist_online;</span>
<span class="p_add">+		if ((hisifd-&gt;index == EXTERNAL_PANEL_IDX)</span>
<span class="p_add">+		    &amp;&amp; hisifd-&gt;panel_info.fake_hdmi)</span>
<span class="p_add">+			enable_cmdlist = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = hisi_dss_module_init(hisifd);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, failed to hisi_dss_module_init! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable_cmdlist) {</span>
<span class="p_add">+			hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_cmdlist_data_get_online(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev,</span>
<span class="p_add">+							  &amp;cmdlist_pre_idxs,</span>
<span class="p_add">+							  NULL);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+				     &quot;pov_req_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+				goto err_out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			cmdlist_idxs = (1 &lt;&lt; (DSS_CMDLIST_OV0 + ovl_idx));</span>
<span class="p_add">+			cmdlist_pre_idxs &amp;= (~(cmdlist_idxs));</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_cmdlist_add_nop_node(hisifd, cmdlist_pre_idxs, 0,</span>
<span class="p_add">+						  0);</span>
<span class="p_add">+			hisi_cmdlist_add_nop_node(hisifd, cmdlist_idxs, 0, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_dss_mctl_mutex_lock(hisifd, ovl_idx);</span>
<span class="p_add">+			cmdlist_pre_idxs = ~0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_dss_prev_module_set_regs(hisifd, pov_req_prev,</span>
<span class="p_add">+					      cmdlist_pre_idxs, enable_cmdlist,</span>
<span class="p_add">+					      NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ovl_base_config(hisifd, NULL, NULL, NULL, ovl_idx,</span>
<span class="p_add">+					     0);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, faile to hisi_dss_ovl_base_config! ret=%d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_mctl_ov_config(hisifd, NULL, ovl_idx, false, true);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, faile to hisi_dss_mctl_config! ret=%d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = hisi_dss_dirty_region_dbuf_config(hisifd, NULL);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, hisi_dss_dirty_region_dbuf_config failed! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    hisi_dss_ov_module_set_regs(hisifd, NULL, ovl_idx,</span>
<span class="p_add">+						enable_cmdlist, 1, 0, true);</span>
<span class="p_add">+		if (ret != 0) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, failed to hisi_dss_module_config! ret = %d\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable_cmdlist) {</span>
<span class="p_add">+			hisi_cmdlist_config_stop(hisifd, cmdlist_pre_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+			cmdlist_idxs |= cmdlist_pre_idxs;</span>
<span class="p_add">+			hisi_cmdlist_flush_cache(hisifd, hisifd-&gt;ion_client,</span>
<span class="p_add">+						 cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_cmdlist) {</span>
<span class="p_add">+				hisi_cmdlist_dump_all_node(hisifd, NULL,</span>
<span class="p_add">+							   cmdlist_idxs);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			hisi_cmdlist_config_start(hisifd, ovl_idx, cmdlist_idxs, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			hisi_dss_mctl_mutex_unlock(hisifd, ovl_idx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+			hisi_dss_dirty_region_updt_config(hisifd, NULL);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ldi_data_gate(hisifd, true);</span>
<span class="p_add">+</span>
<span class="p_add">+		single_frame_update(hisifd);</span>
<span class="p_add">+		hisifb_frame_updated(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!hisi_dss_check_reg_reload_status(hisifd)) {</span>
<span class="p_add">+			mdelay(20);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ldi_data_gate(hisifd, false);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_mipi_cmd_panel(hisifd)) {</span>
<span class="p_add">+			hisifd-&gt;ldi_data_gate_en = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;frame_count++;</span>
<span class="p_add">+ err_out:</span>
<span class="p_add">+		hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+	} else if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not support !\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		BUG_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		hisifb_dss_off(hisifd, true);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifb_dss_off(hisifd, false);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;ldi_data_gate_en = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;(hisifd-&gt;ov_block_infos_prev_prev), 0,</span>
<span class="p_add">+	       HISI_DSS_OV_BLOCK_NUMS * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;ov_req_prev_prev, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+	memset(&amp;(hisifd-&gt;ov_block_infos_prev), 0,</span>
<span class="p_add">+	       HISI_DSS_OV_BLOCK_NUMS * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;ov_req_prev, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+	memset(&amp;(hisifd-&gt;ov_block_infos), 0,</span>
<span class="p_add">+	       HISI_DSS_OV_BLOCK_NUMS * sizeof(dss_overlay_block_t));</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;ov_req, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_DEBUG(&quot;fb%d, -\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool hisi_dss_check_reg_reload_status(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mdelay(50);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool hisi_dss_check_crg_sctrl_status(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t crg_state_check = 0;</span>
<span class="p_add">+	uint32_t sctrl_mmbuf_dss_check = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	crg_state_check = inp32(hisifd-&gt;peri_crg_base + PERCLKEN3);</span>
<span class="p_add">+	if ((crg_state_check &amp; 0x23000) != 0x23000) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;dss crg_clk_enable failed, crg_state_check = 0x%x\n&quot;,</span>
<span class="p_add">+		     crg_state_check);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	crg_state_check = inp32(hisifd-&gt;peri_crg_base + PERRSTSTAT3);</span>
<span class="p_add">+	if ((crg_state_check | 0xfffff3ff) != 0xfffff3ff) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;dss crg_reset failed, crg_state_check = 0x%x\n&quot;,</span>
<span class="p_add">+			    crg_state_check);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	crg_state_check = inp32(hisifd-&gt;peri_crg_base + ISOSTAT);</span>
<span class="p_add">+	if ((crg_state_check | 0xffffffbf) != 0xffffffbf) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;dss iso_disable failed, crg_state_check = 0x%x\n&quot;,</span>
<span class="p_add">+			    crg_state_check);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	crg_state_check = inp32(hisifd-&gt;peri_crg_base + PERPWRSTAT);</span>
<span class="p_add">+	if ((crg_state_check &amp; 0x20) != 0x20) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;dss subsys regulator_enabel failed, crg_state_check = 0x%x\n&quot;,</span>
<span class="p_add">+		     crg_state_check);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	sctrl_mmbuf_dss_check = inp32(hisifd-&gt;sctrl_base + SCPERCLKEN1);</span>
<span class="p_add">+	if ((sctrl_mmbuf_dss_check &amp; 0x1000000) != 0x1000000) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;dss subsys mmbuf_dss_clk_enable failed, sctrl_mmbuf_dss_check = 0x%x\n&quot;,</span>
<span class="p_add">+		     sctrl_mmbuf_dss_check);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_ioctl_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			       uint32_t cmd, void __user *argp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t timediff = 0;</span>
<span class="p_add">+	struct timeval tv0;</span>
<span class="p_add">+	struct timeval tv1;</span>
<span class="p_add">+	struct hisi_panel_info *pinfo = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (NULL == hisifd) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;NULL Pointer\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pinfo = &amp;(hisifd-&gt;panel_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case HISIFB_OV_ONLINE_PLAY:</span>
<span class="p_add">+		if (hisifd-&gt;ov_online_play) {</span>
<span class="p_add">+			if (g_debug_ovl_online_composer_timediff &amp; 0x1)</span>
<span class="p_add">+				hisifb_get_timestamp(&amp;tv0);</span>
<span class="p_add">+</span>
<span class="p_add">+			down(&amp;hisifd-&gt;blank_sem);</span>
<span class="p_add">+			ret = hisifd-&gt;ov_online_play(hisifd, argp);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_ERR(&quot;fb%d ov_online_play failed!\n&quot;,</span>
<span class="p_add">+					    hisifd-&gt;index);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			up(&amp;hisifd-&gt;blank_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer_timediff &amp; 0x1) {</span>
<span class="p_add">+				hisifb_get_timestamp(&amp;tv1);</span>
<span class="p_add">+				timediff = hisifb_timestamp_diff(&amp;tv0, &amp;tv1);</span>
<span class="p_add">+				if (timediff &gt;=</span>
<span class="p_add">+				    g_debug_ovl_online_composer_time_threshold)</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;ONLING_IOCTL_TIMEDIFF is %u us!\n&quot;,</span>
<span class="p_add">+					     timediff);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret == 0) {</span>
<span class="p_add">+				if (hisifd-&gt;bl_update) {</span>
<span class="p_add">+					hisifd-&gt;bl_update(hisifd);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_init(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char wq_name[128] = { 0 };</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(hisifd-&gt;dss_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;dss_module_resource_initialized = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;vactive0_start_flag = 0;</span>
<span class="p_add">+	hisifd-&gt;vactive0_end_flag = 0;</span>
<span class="p_add">+	init_waitqueue_head(&amp;hisifd-&gt;vactive0_start_wq);</span>
<span class="p_add">+	hisifd-&gt;ldi_data_gate_en = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;crc_flag = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;frame_update_flag = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;ov_req, 0, sizeof(dss_overlay_t));</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;dss_module, 0, sizeof(dss_module_reg_t));</span>
<span class="p_add">+	memset(&amp;hisifd-&gt;dss_module_default, 0, sizeof(dss_module_reg_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.x = 0;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.y = 0;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;dirty_region_updt.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.x = 0;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.y = 0;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;resolution_rect.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.x = 0;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.y = 0;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.w = hisifd-&gt;panel_info.xres;</span>
<span class="p_add">+	hisifd-&gt;res_updt_rect.h = hisifd-&gt;panel_info.yres;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;pan_display_fnc = hisi_overlay_pan_display;</span>
<span class="p_add">+	hisifd-&gt;ov_ioctl_handler = hisi_overlay_ioctl_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;dss_debug_wq = NULL;</span>
<span class="p_add">+	hisifd-&gt;ldi_underflow_wq = NULL;</span>
<span class="p_add">+	hisifd-&gt;rch2_ce_end_wq = NULL;</span>
<span class="p_add">+	hisifd-&gt;rch4_ce_end_wq = NULL;</span>
<span class="p_add">+	hisifd-&gt;dpp_ce_end_wq = NULL;</span>
<span class="p_add">+	hisifd-&gt;hiace_end_wq = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hisifd-&gt;index == PRIMARY_PANEL_IDX) ||</span>
<span class="p_add">+	    (hisifd-&gt;index == EXTERNAL_PANEL_IDX</span>
<span class="p_add">+	     &amp;&amp; !hisifd-&gt;panel_info.fake_hdmi)) {</span>
<span class="p_add">+		snprintf(wq_name, 128, &quot;fb%d_dss_debug&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		hisifd-&gt;dss_debug_wq = create_singlethread_workqueue(wq_name);</span>
<span class="p_add">+		if (!hisifd-&gt;dss_debug_wq) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, create dss debug workqueue failed!\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		INIT_WORK(&amp;hisifd-&gt;dss_debug_work, hisi_dss_debug_func);</span>
<span class="p_add">+</span>
<span class="p_add">+		snprintf(wq_name, 128, &quot;fb%d_ldi_underflow&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		hisifd-&gt;ldi_underflow_wq =</span>
<span class="p_add">+		    create_singlethread_workqueue(wq_name);</span>
<span class="p_add">+		if (!hisifd-&gt;ldi_underflow_wq) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, create ldi underflow workqueue failed!\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		INIT_WORK(&amp;hisifd-&gt;ldi_underflow_work,</span>
<span class="p_add">+			  hisi_ldi_underflow_handle_func);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+		hisifd-&gt;ov_online_play = hisi_ov_online_play;</span>
<span class="p_add">+		hisifd-&gt;ov_wb_isr_handler = NULL;</span>
<span class="p_add">+		hisifd-&gt;ov_vactive0_start_isr_handler =</span>
<span class="p_add">+		    hisi_vactive0_start_isr_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;crc_isr_handler = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (hisifd-&gt;index == EXTERNAL_PANEL_IDX) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+		hisifd-&gt;ov_online_play = hisi_ov_online_play;</span>
<span class="p_add">+		hisifd-&gt;ov_wb_isr_handler = NULL;</span>
<span class="p_add">+		hisifd-&gt;ov_vactive0_start_isr_handler =</span>
<span class="p_add">+		    hisi_vactive0_start_isr_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;crc_isr_handler = NULL;</span>
<span class="p_add">+	} else if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+		hisifd-&gt;ov_online_play = NULL;</span>
<span class="p_add">+		hisifd-&gt;ov_wb_isr_handler = NULL;</span>
<span class="p_add">+		hisifd-&gt;ov_vactive0_start_isr_handler = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;crc_isr_handler = NULL;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d not support this device!\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_cmdlist_init(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_mmbuf_init(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_deinit(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;rch4_ce_end_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;rch4_ce_end_wq);</span>
<span class="p_add">+		hisifd-&gt;rch4_ce_end_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;rch2_ce_end_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;rch2_ce_end_wq);</span>
<span class="p_add">+		hisifd-&gt;rch2_ce_end_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;dpp_ce_end_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;dpp_ce_end_wq);</span>
<span class="p_add">+		hisifd-&gt;dpp_ce_end_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;hiace_end_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;hiace_end_wq);</span>
<span class="p_add">+		hisifd-&gt;hiace_end_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;dss_debug_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;dss_debug_wq);</span>
<span class="p_add">+		hisifd-&gt;dss_debug_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;ldi_underflow_wq) {</span>
<span class="p_add">+		destroy_workqueue(hisifd-&gt;ldi_underflow_wq);</span>
<span class="p_add">+		hisifd-&gt;ldi_underflow_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_cmdlist_deinit(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_dss_mmbuf_deinit(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_vactive0_start_isr_handler(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_mipi_cmd_panel(hisifd) &amp;&amp; (hisifd-&gt;frame_update_flag == 0)) {</span>
<span class="p_add">+		hisifd-&gt;vactive0_start_flag = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;vactive0_start_flag++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	wake_up_interruptible_all(&amp;hisifd-&gt;vactive0_start_wq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_vactive0_start_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			       dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int ret1 = 0;</span>
<span class="p_add">+	int times = 0;</span>
<span class="p_add">+	uint32_t prev_vactive0_start = 0;</span>
<span class="p_add">+	uint32_t isr_s1 = 0;</span>
<span class="p_add">+	uint32_t isr_s2 = 0;</span>
<span class="p_add">+	uint32_t isr_s2_mask = 0;</span>
<span class="p_add">+	char __iomem *ldi_base = NULL;</span>
<span class="p_add">+	struct timeval tv0;</span>
<span class="p_add">+	struct timeval tv1;</span>
<span class="p_add">+	dss_overlay_t *pov_req_dump = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev_prev = NULL;</span>
<span class="p_add">+	uint32_t cmdlist_idxs = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_prev = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_prev_prev = 0;</span>
<span class="p_add">+	uint32_t read_value[4] = { 0 };</span>
<span class="p_add">+	uint32_t ldi_vstate = 0;</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+	pov_req_prev_prev = &amp;(hisifd-&gt;ov_req_prev_prev);</span>
<span class="p_add">+	if (is_mipi_cmd_panel(hisifd) &amp;&amp; (hisifd-&gt;frame_update_flag == 0)) {</span>
<span class="p_add">+		pov_req_dump = &amp;(hisifd-&gt;ov_req_prev_prev);</span>
<span class="p_add">+		if (hisifd-&gt;vactive0_start_flag == 1) {</span>
<span class="p_add">+			hisifd-&gt;vactive0_start_flag = 0;</span>
<span class="p_add">+			single_frame_update(hisifd);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hisifd-&gt;vactive0_start_flag == 0) {</span>
<span class="p_add">+			hisifb_get_timestamp(&amp;tv0);</span>
<span class="p_add">+</span>
<span class="p_add">+ REDO_0:</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    wait_event_interruptible_timeout(hisifd-&gt;vactive0_start_wq,</span>
<span class="p_add">+							     hisifd-&gt;vactive0_start_flag,</span>
<span class="p_add">+							     msecs_to_jiffies</span>
<span class="p_add">+							     (DSS_COMPOSER_TIMEOUT_THRESHOLD_ASIC));</span>
<span class="p_add">+			if (ret == -ERESTARTSYS) {</span>
<span class="p_add">+				if (times &lt; 50) {</span>
<span class="p_add">+					times++;</span>
<span class="p_add">+					mdelay(10);</span>
<span class="p_add">+					goto REDO_0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+			times = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret &lt;= 0) {</span>
<span class="p_add">+				hisifb_get_timestamp(&amp;tv1);</span>
<span class="p_add">+</span>
<span class="p_add">+				ret1 =</span>
<span class="p_add">+				    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev,</span>
<span class="p_add">+								  &amp;cmdlist_idxs_prev,</span>
<span class="p_add">+								  NULL);</span>
<span class="p_add">+				if (ret1 != 0) {</span>
<span class="p_add">+					HISI_FB_INFO</span>
<span class="p_add">+					    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+					     &quot;pov_req_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, ret1);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				ret1 =</span>
<span class="p_add">+				    hisi_cmdlist_get_cmdlist_idxs</span>
<span class="p_add">+				    (pov_req_prev_prev, &amp;cmdlist_idxs_prev_prev,</span>
<span class="p_add">+				     NULL);</span>
<span class="p_add">+				if (ret1 != 0) {</span>
<span class="p_add">+					HISI_FB_INFO</span>
<span class="p_add">+					    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+					     &quot;pov_req_prev_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, ret1);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				cmdlist_idxs =</span>
<span class="p_add">+				    cmdlist_idxs_prev | cmdlist_idxs_prev_prev;</span>
<span class="p_add">+</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, 1wait_for vactive0_start_flag timeout!ret=%d, &quot;</span>
<span class="p_add">+				     &quot;vactive0_start_flag=%d, pre_pre_frame_no=%u, &quot;</span>
<span class="p_add">+				     &quot;frame_no=%u, TIMESTAMP_DIFF is %u us, &quot;</span>
<span class="p_add">+				     &quot;cmdlist_idxs_prev=0x%x, cmdlist_idxs_prev_prev=0x%x, &quot;</span>
<span class="p_add">+				     &quot;cmdlist_idxs=0x%x, itf0_ints=0x%x\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret,</span>
<span class="p_add">+				     hisifd-&gt;vactive0_start_flag,</span>
<span class="p_add">+				     pov_req_dump-&gt;frame_no, pov_req-&gt;frame_no,</span>
<span class="p_add">+				     hisifb_timestamp_diff(&amp;tv0, &amp;tv1),</span>
<span class="p_add">+				     cmdlist_idxs_prev, cmdlist_idxs_prev_prev,</span>
<span class="p_add">+				     cmdlist_idxs,</span>
<span class="p_add">+				     inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET +</span>
<span class="p_add">+					   LDI_CPU_ITF_INTS)</span>
<span class="p_add">+				    );</span>
<span class="p_add">+</span>
<span class="p_add">+				if (g_debug_ovl_online_composer_hold) {</span>
<span class="p_add">+					dumpDssOverlay(hisifd, pov_req_dump,</span>
<span class="p_add">+						       (g_debug_need_save_file</span>
<span class="p_add">+							== 1));</span>
<span class="p_add">+					hisi_cmdlist_dump_all_node(hisifd, NULL,</span>
<span class="p_add">+								   cmdlist_idxs);</span>
<span class="p_add">+					mdelay(HISI_DSS_COMPOSER_HOLD_TIME);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				if (g_debug_ldi_underflow_clear</span>
<span class="p_add">+				    &amp;&amp; g_ldi_data_gate_en) {</span>
<span class="p_add">+#if 1</span>
<span class="p_add">+					hisi_cmdlist_config_reset(hisifd,</span>
<span class="p_add">+								  pov_req_dump,</span>
<span class="p_add">+								  cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+					ldi_data_gate(hisifd, false);</span>
<span class="p_add">+					mdelay(10);</span>
<span class="p_add">+#else</span>
<span class="p_add">+					if (hisifd-&gt;ldi_underflow_wq) {</span>
<span class="p_add">+						queue_work(hisifd-&gt;</span>
<span class="p_add">+							   ldi_underflow_wq,</span>
<span class="p_add">+							   &amp;hisifd-&gt;</span>
<span class="p_add">+							   ldi_underflow_work);</span>
<span class="p_add">+					}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+					mipi_panel_check_reg(hisifd,</span>
<span class="p_add">+							     read_value);</span>
<span class="p_add">+					ldi_vstate =</span>
<span class="p_add">+					    inp32(hisifd-&gt;dss_base +</span>
<span class="p_add">+						  DSS_LDI0_OFFSET + LDI_VSTATE);</span>
<span class="p_add">+					HISI_FB_ERR(&quot;fb%d, &quot;</span>
<span class="p_add">+						    &quot;Number of the Errors on DSI : 0x05 = 0x%x\n&quot;</span>
<span class="p_add">+						    &quot;Display Power Mode : 0x0A = 0x%x\n&quot;</span>
<span class="p_add">+						    &quot;Display Signal Mode : 0x0E = 0x%x\n&quot;</span>
<span class="p_add">+						    &quot;Display Self-Diagnostic Result : 0x0F = 0x%x\n&quot;</span>
<span class="p_add">+						    &quot;LDI vstate : 0x%x, LDI dpi0_hstate : 0x%x\n&quot;,</span>
<span class="p_add">+						    hisifd-&gt;index,</span>
<span class="p_add">+						    read_value[0],</span>
<span class="p_add">+						    read_value[1],</span>
<span class="p_add">+						    read_value[2],</span>
<span class="p_add">+						    read_value[3], ldi_vstate,</span>
<span class="p_add">+						    inp32(hisifd-&gt;dss_base +</span>
<span class="p_add">+							  DSS_LDI0_OFFSET +</span>
<span class="p_add">+							  LDI_DPI0_HSTATE));</span>
<span class="p_add">+</span>
<span class="p_add">+					memset(&amp;(hisifd-&gt;ov_block_infos_prev), 0,</span>
<span class="p_add">+					       HISI_DSS_OV_BLOCK_NUMS *</span>
<span class="p_add">+					       sizeof(dss_overlay_block_t));</span>
<span class="p_add">+</span>
<span class="p_add">+					memset(&amp;(hisifd-&gt;ov_req_prev), 0,</span>
<span class="p_add">+					       sizeof(dss_overlay_t));</span>
<span class="p_add">+</span>
<span class="p_add">+					if (LDI_VSTATE_V_WAIT_TE0 == ldi_vstate) {</span>
<span class="p_add">+						vactive_timeout_count++;</span>
<span class="p_add">+						if ((vactive_timeout_count &gt;= 3)</span>
<span class="p_add">+						    &amp;&amp; hisifd-&gt;panel_info.esd_enable) {</span>
<span class="p_add">+							hisifd-&gt;esd_recover_state =</span>
<span class="p_add">+								ESD_RECOVER_STATE_START;</span>
<span class="p_add">+							if (hisifd-&gt;esd_ctrl.esd_check_wq) {</span>
<span class="p_add">+								queue_work(hisifd-&gt;esd_ctrl.esd_check_wq,</span>
<span class="p_add">+								     &amp;(hisifd-&gt;esd_ctrl.esd_check_work));</span>
<span class="p_add">+							}</span>
<span class="p_add">+						}</span>
<span class="p_add">+					}</span>
<span class="p_add">+					return 0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				ldi_data_gate(hisifd, false);</span>
<span class="p_add">+				mipi_panel_check_reg(hisifd, read_value);</span>
<span class="p_add">+				ldi_vstate =</span>
<span class="p_add">+				    inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_VSTATE);</span>
<span class="p_add">+				HISI_FB_ERR(&quot;fb%d, &quot;</span>
<span class="p_add">+					    &quot;Number of the Errors on DSI : 0x05 = 0x%x\n&quot;</span>
<span class="p_add">+					    &quot;Display Power Mode : 0x0A = 0x%x\n&quot;</span>
<span class="p_add">+					    &quot;Display Signal Mode : 0x0E = 0x%x\n&quot;</span>
<span class="p_add">+					    &quot;Display Self-Diagnostic Result : 0x0F = 0x%x\n&quot;</span>
<span class="p_add">+					    &quot;LDI vstate : 0x%x, LDI dpi0_hstate : 0x%x \n&quot;,</span>
<span class="p_add">+					    hisifd-&gt;index, read_value[0],</span>
<span class="p_add">+					    read_value[1], read_value[2],</span>
<span class="p_add">+					    read_value[3], ldi_vstate,</span>
<span class="p_add">+					    inp32(hisifd-&gt;dss_base +</span>
<span class="p_add">+						  DSS_LDI0_OFFSET +</span>
<span class="p_add">+						  LDI_DPI0_HSTATE));</span>
<span class="p_add">+</span>
<span class="p_add">+ REDO_1:</span>
<span class="p_add">+				ret =</span>
<span class="p_add">+				    wait_event_interruptible_timeout(hisifd-&gt;vactive0_start_wq,</span>
<span class="p_add">+								     hisifd-&gt;vactive0_start_flag,</span>
<span class="p_add">+								     msecs_to_jiffies</span>
<span class="p_add">+								     (DSS_COMPOSER_TIMEOUT_THRESHOLD_ASIC));</span>
<span class="p_add">+				if (ret == -ERESTARTSYS) {</span>
<span class="p_add">+					if (times &lt; 50) {</span>
<span class="p_add">+						times++;</span>
<span class="p_add">+						mdelay(10);</span>
<span class="p_add">+						goto REDO_1;</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+				times = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (ret &lt;= 0) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, 2wait_for vactive0_start_flag timeout!ret=%d, &quot;</span>
<span class="p_add">+					     &quot;vactive0_start_flag=%d, frame_no=%u.\n&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, ret,</span>
<span class="p_add">+					     hisifd-&gt;vactive0_start_flag,</span>
<span class="p_add">+					     pov_req_dump-&gt;frame_no);</span>
<span class="p_add">+</span>
<span class="p_add">+					ldi_data_gate(hisifd, false);</span>
<span class="p_add">+					ret = -ETIMEDOUT;</span>
<span class="p_add">+					if (LDI_VSTATE_V_WAIT_TE0 == ldi_vstate) {</span>
<span class="p_add">+						vactive_timeout_count++;</span>
<span class="p_add">+						if ((vactive_timeout_count &gt;= 1)</span>
<span class="p_add">+						    &amp;&amp; hisifd-&gt;panel_info.esd_enable) {</span>
<span class="p_add">+							hisifd-&gt;esd_recover_state =</span>
<span class="p_add">+							    ESD_RECOVER_STATE_START;</span>
<span class="p_add">+							if (hisifd-&gt;esd_ctrl.esd_check_wq) {</span>
<span class="p_add">+								queue_work(hisifd-&gt;esd_ctrl.esd_check_wq,</span>
<span class="p_add">+								     &amp;(hisifd-&gt;esd_ctrl.esd_check_work));</span>
<span class="p_add">+							}</span>
<span class="p_add">+							ret = 0;</span>
<span class="p_add">+						}</span>
<span class="p_add">+					}</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					ldi_data_gate(hisifd, true);</span>
<span class="p_add">+					ret = 0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ldi_data_gate(hisifd, true);</span>
<span class="p_add">+				ret = 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ldi_data_gate(hisifd, true);</span>
<span class="p_add">+		hisifd-&gt;vactive0_start_flag = 0;</span>
<span class="p_add">+		hisifd-&gt;vactive0_end_flag = 0;</span>
<span class="p_add">+		if (ret &gt;= 0) {</span>
<span class="p_add">+			vactive_timeout_count = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pov_req_dump = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifb_get_timestamp(&amp;tv0);</span>
<span class="p_add">+		ldi_data_gate(hisifd, false);</span>
<span class="p_add">+		prev_vactive0_start = hisifd-&gt;vactive0_start_flag;</span>
<span class="p_add">+</span>
<span class="p_add">+ REDO_2:</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    wait_event_interruptible_timeout(hisifd-&gt;vactive0_start_wq,</span>
<span class="p_add">+						     (prev_vactive0_start !=</span>
<span class="p_add">+						      hisifd-&gt;vactive0_start_flag),</span>
<span class="p_add">+						     msecs_to_jiffies</span>
<span class="p_add">+						     (DSS_COMPOSER_TIMEOUT_THRESHOLD_ASIC));</span>
<span class="p_add">+		if (ret == -ERESTARTSYS) {</span>
<span class="p_add">+			if (times &lt; 50) {</span>
<span class="p_add">+				times++;</span>
<span class="p_add">+				mdelay(10);</span>
<span class="p_add">+				goto REDO_2;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret &lt;= 0) {</span>
<span class="p_add">+			hisifb_get_timestamp(&amp;tv1);</span>
<span class="p_add">+			ret =</span>
<span class="p_add">+			    hisi_cmdlist_get_cmdlist_idxs(pov_req_dump,</span>
<span class="p_add">+							  &amp;cmdlist_idxs, NULL);</span>
<span class="p_add">+			if (ret != 0) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+				     &quot;pov_req_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, ret);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, 1wait_for vactive0_start_flag timeout!ret=%d, &quot;</span>
<span class="p_add">+			     &quot;vactive0_start_flag=%d, frame_no=%u, &quot;</span>
<span class="p_add">+			     &quot;TIMESTAMP_DIFF is %u us, cmdlist_idxs=0x%x!\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, ret,</span>
<span class="p_add">+			     hisifd-&gt;vactive0_start_flag,</span>
<span class="p_add">+			     pov_req_dump-&gt;frame_no,</span>
<span class="p_add">+			     hisifb_timestamp_diff(&amp;tv0, &amp;tv1),</span>
<span class="p_add">+			     cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer_hold) {</span>
<span class="p_add">+				dumpDssOverlay(hisifd, pov_req_dump,</span>
<span class="p_add">+					       (g_debug_need_save_file == 1));</span>
<span class="p_add">+				hisi_cmdlist_dump_all_node(hisifd, NULL,</span>
<span class="p_add">+							   cmdlist_idxs);</span>
<span class="p_add">+				mdelay(HISI_DSS_COMPOSER_HOLD_TIME);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			mipi_dsi_reset(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+			ret = -ETIMEDOUT;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret == -ETIMEDOUT) {</span>
<span class="p_add">+		if (pov_req_dump &amp;&amp; pov_req_dump-&gt;ovl_idx == DSS_OVL0) {</span>
<span class="p_add">+			isr_s1 = inp32(hisifd-&gt;dss_base + GLB_CPU_PDP_INTS);</span>
<span class="p_add">+			isr_s2_mask =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET +</span>
<span class="p_add">+				  LDI_CPU_ITF_INT_MSK);</span>
<span class="p_add">+			isr_s2 =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET +</span>
<span class="p_add">+				  LDI_CPU_ITF_INTS);</span>
<span class="p_add">+			ldi_base = hisifd-&gt;dss_base + DSS_LDI0_OFFSET;</span>
<span class="p_add">+		} else if (pov_req_dump &amp;&amp; pov_req_dump-&gt;ovl_idx == DSS_OVL1) {</span>
<span class="p_add">+			isr_s1 = inp32(hisifd-&gt;dss_base + GLB_CPU_SDP_INTS);</span>
<span class="p_add">+			isr_s2_mask =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_LDI1_OFFSET +</span>
<span class="p_add">+				  LDI_CPU_ITF_INT_MSK);</span>
<span class="p_add">+			isr_s2 =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_LDI1_OFFSET +</span>
<span class="p_add">+				  LDI_CPU_ITF_INTS);</span>
<span class="p_add">+			ldi_base = hisifd-&gt;dss_base + DSS_LDI1_OFFSET;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, isr_s1=0x%x, isr_s2_mask=0x%x, isr_s2=0x%x, &quot;</span>
<span class="p_add">+			    &quot;LDI_CTRL(0x%x), LDI_FRM_MSK(0x%x).\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, isr_s1, isr_s2_mask, isr_s2,</span>
<span class="p_add">+			    inp32(ldi_base + LDI_CTRL),</span>
<span class="p_add">+			    inp32(ldi_base + LDI_FRM_MSK));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_crc_enable(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_enable_crc_debug == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req-&gt;crc_enable_status &lt;= 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		tmp = inp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;crc_enable_status == DSS_CRC_OV_EN) {</span>
<span class="p_add">+			outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+			       DBG_CRC_OV0_EN, 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_OV0_INT;</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_LDI_EN) {</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_ITF0_INT;</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_SUM_EN) {</span>
<span class="p_add">+			outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+			       DBG_CRC_SUM_EN, 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_SUM_INT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK, tmp);</span>
<span class="p_add">+	} else if (hisifd-&gt;index == EXTERNAL_PANEL_IDX) {</span>
<span class="p_add">+		tmp = inp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;crc_enable_status == DSS_CRC_OV_EN) {</span>
<span class="p_add">+			outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+			       DBG_CRC_OV1_EN, 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_OV1_INT;</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_LDI_EN) {</span>
<span class="p_add">+			outp32(hisifd-&gt;dss_base + GLB_CRC_LDI1_EN, 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_ITF1_INT;</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_SUM_EN) {</span>
<span class="p_add">+			outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+			       DBG_CRC_SUM_EN, 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp &amp;= ~BIT_CRC_SUM_INT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK, tmp);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not support!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_crc_disable(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET + DBG_CRC_OV0_EN, 0x0);</span>
<span class="p_add">+</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET + DBG_CRC_SUM_EN, 0x0);</span>
<span class="p_add">+		tmp = inp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK);</span>
<span class="p_add">+		tmp |= (BIT_CRC_OV0_INT | BIT_CRC_ITF0_INT | BIT_CRC_SUM_INT);</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK, tmp);</span>
<span class="p_add">+	} else if (hisifd-&gt;index == EXTERNAL_PANEL_IDX) {</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET + DBG_CRC_OV1_EN, 0x0);</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + GLB_CRC_LDI1_EN, 0x0);</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET + DBG_CRC_SUM_EN, 0x0);</span>
<span class="p_add">+		tmp = inp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK);</span>
<span class="p_add">+		tmp |= (BIT_CRC_OV1_INT | BIT_CRC_ITF1_INT | BIT_CRC_SUM_INT);</span>
<span class="p_add">+		outp32(hisifd-&gt;dss_base + DSS_DPP_OFFSET + DPP_INT_MSK, tmp);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not support!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hisi_crc_get_result(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			       dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		if (pov_req-&gt;crc_enable_status == DSS_CRC_OV_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ov_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_DBG_OV0);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ov_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_OV0_FRM);</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_LDI_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + GLB_CRC_DBG_LDI0);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + GLB_CRC_LDI0_FRM);</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_SUM_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_DBG_SUM);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_SUM_FRM);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (hisifd-&gt;index == EXTERNAL_PANEL_IDX) {</span>
<span class="p_add">+		if (pov_req-&gt;crc_enable_status == DSS_CRC_OV_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ov_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_DBG_OV1);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ov_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_OV1_FRM);</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_LDI_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + GLB_CRC_DBG_LDI1);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + GLB_CRC_LDI1_FRM);</span>
<span class="p_add">+		} else if (pov_req-&gt;crc_enable_status == DSS_CRC_SUM_EN) {</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_result =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_DBG_SUM);</span>
<span class="p_add">+			pov_req-&gt;crc_info.crc_ldi_frm =</span>
<span class="p_add">+			    inp32(hisifd-&gt;dss_base + DSS_DBG_OFFSET +</span>
<span class="p_add">+				  DBG_CRC_SUM_FRM);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, not support!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_crc_isr_handler(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_crc_disable(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;crc_flag++;</span>
<span class="p_add">+	wake_up_interruptible_all(&amp;hisifd-&gt;crc_wq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_crc_config(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_enable_crc_debug == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req-&gt;crc_enable_status &lt;= 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+#if 1</span>
<span class="p_add">+	mdelay(100);</span>
<span class="p_add">+	hisi_crc_get_result(hisifd, pov_req);</span>
<span class="p_add">+	hisi_crc_disable(hisifd);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	prev_crc_flag = hisifd-&gt;crc_flag;</span>
<span class="p_add">+	ret = wait_event_interruptible_timeout(hisifd-&gt;crc_wq,</span>
<span class="p_add">+					       (prev_crc_flag !=</span>
<span class="p_add">+						hisifd-&gt;crc_flag), 1 * HZ);</span>
<span class="p_add">+	if (ret == -ERESTARTSYS) {</span>
<span class="p_add">+		HISI_FB_DEBUG</span>
<span class="p_add">+		    (&quot;fb%d, wait_for crc_flag, &quot;</span>
<span class="p_add">+		     &quot;Returns -ERESTARTSYS if interrupted by a signal!\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index);</span>
<span class="p_add">+		ret =</span>
<span class="p_add">+		    wait_event_interruptible_timeout(hisifd-&gt;crc_wq,</span>
<span class="p_add">+						     (prev_crc_flag !=</span>
<span class="p_add">+						      hisifd-&gt;crc_flag), 1 * HZ);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, wait_for crc_flag timeout!ret=%d, &quot;</span>
<span class="p_add">+			    &quot;prev_crc_flag=%d, crc_flag=%d\n&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, ret, prev_crc_flag,</span>
<span class="p_add">+			    hisifd-&gt;crc_flag);</span>
<span class="p_add">+		ret = -ETIMEDOUT;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisi_crc_get_result(hisifd, pov_req);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_debug_func(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_fb_data_type *hisifd = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd = container_of(work, struct hisi_fb_data_type, dss_debug_work);</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	dumpDssOverlay(hisifd, &amp;hisifd-&gt;ov_req, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_ldi_underflow_handle_func(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hisi_fb_data_type *hisifd = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev = NULL;</span>
<span class="p_add">+	dss_overlay_t *pov_req_prev_prev = NULL;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_prev = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_prev_prev = 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+	uint32_t isr_s1 = 0;</span>
<span class="p_add">+	uint32_t isr_s2 = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd =</span>
<span class="p_add">+	    container_of(work, struct hisi_fb_data_type, ldi_underflow_work);</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_INFO(&quot;fb%d, +.\n&quot;, hisifd-&gt;index);</span>
<span class="p_add">+</span>
<span class="p_add">+	down(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+	if (!hisifd-&gt;panel_power_on) {</span>
<span class="p_add">+		HISI_FB_INFO(&quot;fb%d, panel is power off!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		up(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisifb_activate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	pov_req_prev = &amp;(hisifd-&gt;ov_req_prev);</span>
<span class="p_add">+	pov_req_prev_prev = &amp;(hisifd-&gt;ov_req_prev_prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev, &amp;cmdlist_idxs_prev, NULL);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+		     &quot;pov_req_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_cmdlist_get_cmdlist_idxs(pov_req_prev_prev,</span>
<span class="p_add">+					  &amp;cmdlist_idxs_prev_prev, NULL);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, hisi_cmdlist_get_cmdlist_idxs &quot;</span>
<span class="p_add">+		     &quot;pov_req_prev_prev failed! ret = %d\n&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisi_cmdlist_config_reset(hisifd, pov_req_prev,</span>
<span class="p_add">+				  cmdlist_idxs_prev | cmdlist_idxs_prev_prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_ldi(hisifd);</span>
<span class="p_add">+	isr_s1 = inp32(hisifd-&gt;dss_base + GLB_CPU_PDP_INTS);</span>
<span class="p_add">+	isr_s2 = inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_CPU_ITF_INTS);</span>
<span class="p_add">+	outp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_CPU_ITF_INTS, isr_s2);</span>
<span class="p_add">+	outp32(hisifd-&gt;dss_base + GLB_CPU_PDP_INTS, isr_s1);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = inp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK);</span>
<span class="p_add">+	tmp &amp;= ~BIT_LDI_UNFLOW;</span>
<span class="p_add">+	outp32(hisifd-&gt;dss_base + DSS_LDI0_OFFSET + LDI_CPU_ITF_INT_MSK, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifb_deactivate_vsync(hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+	up(&amp;hisifd-&gt;blank_sem0);</span>
<span class="p_add">+</span>
<span class="p_add">+	HISI_FB_INFO</span>
<span class="p_add">+	    (&quot;fb%d, -. cmdlist_idxs_prev = 0x%x, cmdlist_idxs_prev_prev = 0x%x\n&quot;,</span>
<span class="p_add">+	     hisifd-&gt;index, cmdlist_idxs_prev, cmdlist_idxs_prev_prev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*lint +e778 +e732*/</span>
<span class="p_header">diff --git a/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.h b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.h</span>
new file mode 100755
<span class="p_header">index 000000000000..31088fbe2c73</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils.h</span>
<span class="p_chunk">@@ -0,0 +1,269 @@</span> <span class="p_context"></span>
<span class="p_add">+/* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 and</span>
<span class="p_add">+ * only version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef HISI_OVERLAY_UTILS_H</span>
<span class="p_add">+#define HISI_OVERLAY_UTILS_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;hisi_fb.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern uint32_t g_dss_module_base[DSS_CHN_MAX_DEFINE][MODULE_CHN_MAX];</span>
<span class="p_add">+extern uint32_t g_dss_module_ovl_base[DSS_MCTL_IDX_MAX][MODULE_OVL_MAX];</span>
<span class="p_add">+extern uint32_t g_dss_module_cap[DSS_CHN_MAX_DEFINE][MODULE_CAP_MAX];</span>
<span class="p_add">+extern uint32_t g_dss_mif_sid_map[DSS_CHN_MAX_DEFINE];</span>
<span class="p_add">+extern uint32_t g_dss_smmu_smrx_idx[DSS_CHN_MAX_DEFINE];</span>
<span class="p_add">+extern int g_scf_lut_chn_coef_idx[DSS_CHN_MAX_DEFINE];</span>
<span class="p_add">+extern unsigned int g_dss_smmu_outstanding;</span>
<span class="p_add">+extern void *g_smmu_rwerraddr_virt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DSS_COMPOSER_TIMEOUT_THRESHOLD_FPGA	(10000)</span>
<span class="p_add">+#define DSS_COMPOSER_TIMEOUT_THRESHOLD_ASIC	(300)</span>
<span class="p_add">+</span>
<span class="p_add">+enum ENUM_LDI_VSTATE {</span>
<span class="p_add">+	LDI_VSTATE_IDLE = 0x1,</span>
<span class="p_add">+	LDI_VSTATE_VSW = 0x2,</span>
<span class="p_add">+	LDI_VSTATE_VBP = 0x4,</span>
<span class="p_add">+	LDI_VSTATE_VACTIVE0 = 0x8,</span>
<span class="p_add">+	LDI_VSTATE_VACTIVE_SPACE = 0x10,</span>
<span class="p_add">+	LDI_VSTATE_VACTIVE1 = 0x20,</span>
<span class="p_add">+	LDI_VSTATE_VFP = 0x40,</span>
<span class="p_add">+	LDI_VSTATE_V_WAIT_TE0 = 0x80,</span>
<span class="p_add">+	LDI_VSTATE_V_WAIT_TE1 = 0x100,</span>
<span class="p_add">+	LDI_VSTATE_V_WAIT_TE_EN = 0x200,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void dumpDssOverlay(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req,</span>
<span class="p_add">+		    bool isNeedSaveFile);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_get_hal_format(struct fb_info *info);</span>
<span class="p_add">+int hisi_overlay_init(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_overlay_deinit(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_overlay_on(struct hisi_fb_data_type *hisifd, bool fastboot_enable);</span>
<span class="p_add">+int hisi_overlay_off(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+bool hisi_dss_check_reg_reload_status(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+bool hisi_dss_check_crg_sctrl_status(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisifb_adjust_block_rect(int block_num, dss_rect_t *ov_block_rects[],</span>
<span class="p_add">+			      dss_wb_layer_t *wb_layer);</span>
<span class="p_add">+void hisifb_disreset_dss(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_vactive0_start_isr_handler(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_vactive0_start_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			       dss_overlay_t *pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_dirty_region_dbuf_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      dss_overlay_t *pov_req);</span>
<span class="p_add">+void hisi_dss_dirty_region_updt_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				       dss_overlay_t *pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_handle_cur_ovl_req(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				dss_overlay_t *pov_req);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_ov_compose_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req,</span>
<span class="p_add">+			    dss_overlay_block_t *pov_h_block,</span>
<span class="p_add">+			    dss_layer_t *layer,</span>
<span class="p_add">+			    dss_rect_t *wb_dst_rect,</span>
<span class="p_add">+			    dss_rect_t *wb_ov_block_rect,</span>
<span class="p_add">+			    dss_rect_ltrb_t *clip_rect,</span>
<span class="p_add">+			    dss_rect_t *aligned_rect,</span>
<span class="p_add">+			    bool *rdma_stretch_enable,</span>
<span class="p_add">+			    bool *has_base,</span>
<span class="p_add">+			    bool csc_needed, bool enable_cmdlist);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_qos_on(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_mmbuf_on(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_mif_on(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_smmu_on(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_smmu_init(char __iomem *smmu_base, dss_smmu_t *s_smmu);</span>
<span class="p_add">+void hisi_dss_smmu_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      char __iomem *smmu_base, dss_smmu_t *s_smmu,</span>
<span class="p_add">+			      int chn_idx);</span>
<span class="p_add">+void hisi_dss_smmu_ov_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      char __iomem *smmu_base, dss_smmu_t *s_smmu);</span>
<span class="p_add">+int hisi_dss_scl_coef_on(struct hisi_fb_data_type *hisifd, bool enable_cmdlist,</span>
<span class="p_add">+			 int coef_lut_idx);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_overlay_pan_display(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_ov_online_play(struct hisi_fb_data_type *hisifd, void __user *argp);</span>
<span class="p_add">+int hisi_overlay_ioctl_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			       uint32_t cmd, void __user *argp);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_unflow_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req, bool unmask);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_chn_set_reg_default_value(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					char __iomem *dma_base);</span>
<span class="p_add">+void hisi_dss_ov_set_reg_default_value(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				       char __iomem *ovl_base, int ovl_idx);</span>
<span class="p_add">+int hisi_dss_prev_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				  dss_overlay_t *pov_req,</span>
<span class="p_add">+				  uint32_t cmdlist_pre_idxs,</span>
<span class="p_add">+				  bool enable_cmdlist, bool *use_comm_mmbuf);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_check_pure_layer(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_overlay_block_t *pov_h_block,</span>
<span class="p_add">+			      void __user *argp);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_check_userdata(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req,</span>
<span class="p_add">+			    dss_overlay_block_t *pov_h_block_infos);</span>
<span class="p_add">+int hisi_dss_check_layer_par(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_layer_t *layer);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_aif_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 dss_overlay_t *pov_req,</span>
<span class="p_add">+			 dss_overlay_block_t *pov_h_block);</span>
<span class="p_add">+void hisi_dss_aif_init(char __iomem *aif_ch_base, dss_aif_t *s_aif);</span>
<span class="p_add">+void hisi_dss_aif_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     char __iomem *aif_ch_base, dss_aif_t *s_aif);</span>
<span class="p_add">+int hisi_dss_aif_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			   dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			   dss_rect_t *wb_dst_rect, dss_wb_layer_t *wb_layer,</span>
<span class="p_add">+			   int ovl_idx);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_aif1_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			    dss_wb_layer_t *wb_layer, int ovl_idx);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_mif_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_layer_t *layer, dss_wb_layer_t *wb_layer,</span>
<span class="p_add">+			bool rdma_stretch_enable);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_smmu_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_layer_t *layer, dss_wb_layer_t *wb_layer);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_rdma_config(struct hisi_fb_data_type *hisifd, int ovl_idx,</span>
<span class="p_add">+			 dss_layer_t *layer, dss_rect_ltrb_t *clip_rect,</span>
<span class="p_add">+			 dss_rect_t *aligned_rect, bool *rdma_stretch_enable);</span>
<span class="p_add">+int hisi_dss_wdma_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 dss_overlay_t *pov_req, dss_wb_layer_t *layer,</span>
<span class="p_add">+			 dss_rect_t aligned_rect, dss_rect_t *ov_block_rect,</span>
<span class="p_add">+			 bool last_block);</span>
<span class="p_add">+int hisi_dss_rdfc_config(struct hisi_fb_data_type *hisifd, dss_layer_t *layer,</span>
<span class="p_add">+			 dss_rect_t *aligned_rect, dss_rect_ltrb_t clip_rect);</span>
<span class="p_add">+int hisi_dss_wdfc_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 dss_wb_layer_t *layer, dss_rect_t *aligned_rect,</span>
<span class="p_add">+			 dss_rect_t *ov_block_rect);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_scl_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			  char __iomem *scl_base, dss_scl_t *s_scl);</span>
<span class="p_add">+int hisi_dss_chn_scl_load_filter_coef_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					      bool enable_cmdlist, int chn_idx,</span>
<span class="p_add">+					      uint32_t format);</span>
<span class="p_add">+int hisi_dss_post_scl_load_filter_coef(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				       bool enable_cmdlist,</span>
<span class="p_add">+				       char __iomem *scl_lut_base,</span>
<span class="p_add">+				       int coef_lut_idx);</span>
<span class="p_add">+int hisi_dss_scl_config(struct hisi_fb_data_type *hisifd, dss_layer_t *layer,</span>
<span class="p_add">+			dss_rect_t *aligned_rect, bool rdma_stretch_enable);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_post_scf_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req);</span>
<span class="p_add">+void hisi_dss_csc_init(char __iomem *csc_base, dss_csc_t *s_csc);</span>
<span class="p_add">+void hisi_dss_csc_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			  char __iomem *csc_base, dss_csc_t *s_csc);</span>
<span class="p_add">+int hisi_dss_csc_config(struct hisi_fb_data_type *hisifd, dss_layer_t *layer,</span>
<span class="p_add">+			dss_wb_layer_t *wb_layer);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_ovl_base_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     dss_overlay_t *pov_req,</span>
<span class="p_add">+			     dss_overlay_block_t *pov_h_block,</span>
<span class="p_add">+			     dss_rect_t *wb_ov_block_rect, int ovl_idx,</span>
<span class="p_add">+			     int ov_h_block_idx);</span>
<span class="p_add">+int hisi_dss_ovl_layer_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			      dss_rect_t *wb_ov_block_rect, bool has_base);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_mctl_mutex_lock(struct hisi_fb_data_type *hisifd, int ovl_idx);</span>
<span class="p_add">+void hisi_dss_mctl_mutex_unlock(struct hisi_fb_data_type *hisifd, int ovl_idx);</span>
<span class="p_add">+void hisi_dss_mctl_on(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		      int mctl_idx, bool enable_cmdlist, bool fastboot_enable);</span>
<span class="p_add">+int hisi_dss_mctl_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			    dss_wb_layer_t *wb_layer, int ovl_idx,</span>
<span class="p_add">+			    dss_rect_t *wb_ov_block_rect, bool has_base);</span>
<span class="p_add">+int hisi_dss_mctl_ov_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    dss_overlay_t *pov_req, int ovl_idx, bool has_base,</span>
<span class="p_add">+			    bool is_first_ov_block);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_sharpness_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_layer_t *layer);</span>
<span class="p_add">+int hisi_dss_post_clip_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			      dss_layer_t *layer);</span>
<span class="p_add">+int hisi_dss_ce_config(struct hisi_fb_data_type *hisifd, dss_layer_t *layer);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_module_default(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_dss_module_init(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_dss_ch_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				int32_t mctl_idx, int chn_idx, uint32_t wb_type,</span>
<span class="p_add">+				bool enable_cmdlist);</span>
<span class="p_add">+int hisi_dss_ov_module_set_regs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				dss_overlay_t *pov_req, int ovl_idx,</span>
<span class="p_add">+				bool enable_cmdlist, int task_end, int last,</span>
<span class="p_add">+				bool is_first_ov_block);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_secure_layer_check_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+					dss_overlay_t *pov_req);</span>
<span class="p_add">+void hisi_rch2_ce_end_handle_func(struct work_struct *work);</span>
<span class="p_add">+void hisi_rch4_ce_end_handle_func(struct work_struct *work);</span>
<span class="p_add">+void hisi_dss_dpp_acm_ce_end_handle_func(struct work_struct *work);</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_crc_isr_handler(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+int hisi_crc_enable(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req);</span>
<span class="p_add">+int hisi_crc_config(struct hisi_fb_data_type *hisifd, dss_overlay_t *pov_req);</span>
<span class="p_add">+void hisi_dss_debug_func(struct work_struct *work);</span>
<span class="p_add">+void hisi_ldi_underflow_handle_func(struct work_struct *work);</span>
<span class="p_add">+</span>
<span class="p_add">+void *hisi_dss_mmbuf_init(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_mmbuf_deinit(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+uint32_t hisi_dss_mmbuf_alloc(void *handle, uint32_t size);</span>
<span class="p_add">+void hisi_dss_mmbuf_free(void *handle, uint32_t addr, uint32_t size);</span>
<span class="p_add">+void hisi_dss_mmbuf_info_clear(struct hisi_fb_data_type *hisifd, int idx);</span>
<span class="p_add">+void hisi_mmbuf_info_get_online(struct hisi_fb_data_type *hisifd);</span>
<span class="p_add">+void hisi_dss_mctl_ov_set_ctl_dbg_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				      char __iomem *mctl_base,</span>
<span class="p_add">+				      bool enable_cmdlist);</span>
<span class="p_add">+uint32_t hisi_dss_mif_get_invalid_sel(dss_img_t *img, uint32_t transform,</span>
<span class="p_add">+				      int v_scaling_factor, uint8_t is_tile,</span>
<span class="p_add">+				      bool rdma_stretch_enable);</span>
<span class="p_add">+</span>
<span class="p_add">+bool isYUVPackage(uint32_t format);</span>
<span class="p_add">+bool isYUVSemiPlanar(uint32_t format);</span>
<span class="p_add">+bool isYUVPlanar(uint32_t format);</span>
<span class="p_add">+bool isYUV(uint32_t format);</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_YUV_SP_420(uint32_t format);</span>
<span class="p_add">+bool is_YUV_SP_422(uint32_t format);</span>
<span class="p_add">+bool is_YUV_P_420(uint32_t format);</span>
<span class="p_add">+bool is_YUV_P_422(uint32_t format);</span>
<span class="p_add">+bool is_RGBX(uint32_t format);</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_arsr1p_write_coefs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				bool enable_cmdlist, char __iomem *addr,</span>
<span class="p_add">+				const int **p, int row, int col);</span>
<span class="p_add">+</span>
<span class="p_add">+/*arsr2p interface*/</span>
<span class="p_add">+void hisi_dss_arsr2p_init(char __iomem *arsr2p_base, dss_arsr2p_t *s_arsr2p);</span>
<span class="p_add">+void hisi_dss_arsr2p_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     char __iomem *arsr2p_base,</span>
<span class="p_add">+			     dss_arsr2p_t *s_arsr2p);</span>
<span class="p_add">+void hisi_dss_arsr2p_coef_on(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			     bool enable_cmdlist);</span>
<span class="p_add">+int hisi_dss_arsr2p_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				dss_layer_t *layer, dss_rect_t *aligned_rect, bool rdma_stretch_enable);</span>
<span class="p_add">+void hisi_remove_mctl_mutex(struct hisi_fb_data_type *hisifd, int mctl_idx,</span>
<span class="p_add">+			    uint32_t cmdlist_idxs);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* HISI_OVERLAY_UTILS_H */</span>
<span class="p_header">diff --git a/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.c b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.c</span>
new file mode 100755
<span class="p_header">index 000000000000..fb7628e0aa3e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.c</span>
<span class="p_chunk">@@ -0,0 +1,2741 @@</span> <span class="p_context"></span>
<span class="p_add">+/* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 and</span>
<span class="p_add">+ * only version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;hisi_overlay_utils.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+uint32_t g_dss_module_base[DSS_CHN_MAX_DEFINE][MODULE_CHN_MAX] = {</span>
<span class="p_add">+	/* D0 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH0_OFFSET,</span>
<span class="p_add">+	 AIF0_CH0_OFFSET,</span>
<span class="p_add">+	 AIF1_CH0_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH0,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH0_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH0_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH0_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD0_DBG,</span>
<span class="p_add">+	 DSS_RCH_D0_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_D0_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_D0_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* D1 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH1_OFFSET,</span>
<span class="p_add">+	 AIF0_CH1_OFFSET,</span>
<span class="p_add">+	 AIF1_CH1_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH1,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH1_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH1_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH1_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD1_DBG,</span>
<span class="p_add">+	 DSS_RCH_D1_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_D1_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_D1_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* V0 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH2_OFFSET,</span>
<span class="p_add">+	 AIF0_CH2_OFFSET,</span>
<span class="p_add">+	 AIF1_CH2_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH2,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH2_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH2_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH2_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD2_DBG,</span>
<span class="p_add">+	 DSS_RCH_VG0_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_DFC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_SCL_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_SCL_LUT_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_ARSR_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_ARSR_LUT_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_POST_CLIP_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_PCSC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG0_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* G0 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH3_OFFSET,</span>
<span class="p_add">+	 AIF0_CH3_OFFSET,</span>
<span class="p_add">+	 AIF1_CH3_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH3,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH3_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH3_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH3_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD3_DBG,</span>
<span class="p_add">+	 DSS_RCH_G0_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_G0_DFC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_G0_SCL_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_G0_POST_CLIP_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_G0_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* V1 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH4_OFFSET,</span>
<span class="p_add">+	 AIF0_CH4_OFFSET,</span>
<span class="p_add">+	 AIF1_CH4_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH4,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH4_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH4_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH4_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD4_DBG,</span>
<span class="p_add">+	 DSS_RCH_VG1_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG1_DFC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG1_SCL_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG1_SCL_LUT_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_VG1_POST_CLIP_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_VG1_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* G1 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH5_OFFSET,</span>
<span class="p_add">+	 AIF0_CH5_OFFSET,</span>
<span class="p_add">+	 AIF1_CH5_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH5,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH5_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH5_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH5_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD5_DBG,</span>
<span class="p_add">+	 DSS_RCH_G1_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_G1_DFC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_G1_SCL_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_G1_POST_CLIP_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_G1_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* D2 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH6_OFFSET,</span>
<span class="p_add">+	 AIF0_CH6_OFFSET,</span>
<span class="p_add">+	 AIF1_CH6_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH6,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH6_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH6_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH6_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD6_DBG,</span>
<span class="p_add">+	 DSS_RCH_D2_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_D2_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_D2_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* D3 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH7_OFFSET,</span>
<span class="p_add">+	 AIF0_CH7_OFFSET,</span>
<span class="p_add">+	 AIF1_CH7_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH7,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH7_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH7_OV_OEN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH7_STARTY,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD7_DBG,</span>
<span class="p_add">+	 DSS_RCH_D3_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_D3_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_D3_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* W0 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH8_OFFSET,</span>
<span class="p_add">+	 AIF0_CH8_OFFSET,</span>
<span class="p_add">+	 AIF1_CH8_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_WCH0,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_WCH0_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_WCH0_OV_IEN,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH0_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_WCH0_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH0_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* W1 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH9_OFFSET,</span>
<span class="p_add">+	 AIF0_CH9_OFFSET,</span>
<span class="p_add">+	 AIF1_CH9_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_WCH1,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_WCH1_FLUSH_EN,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_WCH1_OV_IEN,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH1_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_WCH1_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH1_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	/* V2 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH10_OFFSET,</span>
<span class="p_add">+	 AIF0_CH11_OFFSET,</span>
<span class="p_add">+	 AIF1_CH11_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_RCH8,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_RCH8_FLUSH_EN,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_MOD8_DBG,</span>
<span class="p_add">+	 DSS_RCH_VG2_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG2_DFC_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG2_SCL_OFFSET,</span>
<span class="p_add">+	 DSS_RCH_VG2_SCL_LUT_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_VG2_POST_CLIP_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_RCH_VG2_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+	/* W2 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 MIF_CH11_OFFSET,</span>
<span class="p_add">+	 AIF0_CH12_OFFSET,</span>
<span class="p_add">+	 AIF1_CH12_OFFSET,</span>
<span class="p_add">+	 MCTL_CTL_MUTEX_WCH2,</span>
<span class="p_add">+	 DSS_MCTRL_SYS_OFFSET + MCTL_WCH2_FLUSH_EN,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH2_DMA_OFFSET,</span>
<span class="p_add">+	 DSS_WCH2_DFC_OFFSET,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 0,</span>
<span class="p_add">+	 DSS_WCH2_CSC_OFFSET,</span>
<span class="p_add">+	 }</span>
<span class="p_add">+	,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+uint32_t g_dss_module_ovl_base[DSS_MCTL_IDX_MAX][MODULE_OVL_MAX] = {</span>
<span class="p_add">+	{DSS_OVL0_OFFSET,</span>
<span class="p_add">+	 DSS_MCTRL_CTL0_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	{DSS_OVL1_OFFSET,</span>
<span class="p_add">+	 DSS_MCTRL_CTL1_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	{DSS_OVL2_OFFSET,</span>
<span class="p_add">+	 DSS_MCTRL_CTL2_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	{DSS_OVL3_OFFSET,</span>
<span class="p_add">+	 DSS_MCTRL_CTL3_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	{0,</span>
<span class="p_add">+	 DSS_MCTRL_CTL4_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+</span>
<span class="p_add">+	{0,</span>
<span class="p_add">+	 DSS_MCTRL_CTL5_OFFSET}</span>
<span class="p_add">+	,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int g_scf_lut_chn_coef_idx[DSS_CHN_MAX_DEFINE] = {</span>
<span class="p_add">+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+uint32_t g_dss_module_cap[DSS_CHN_MAX_DEFINE][MODULE_CAP_MAX] = {</span>
<span class="p_add">+	/* D2 */</span>
<span class="p_add">+	{0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1},</span>
<span class="p_add">+	/* D3 */</span>
<span class="p_add">+	{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},</span>
<span class="p_add">+	/* V0 */</span>
<span class="p_add">+	{0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1},</span>
<span class="p_add">+	/* G0 */</span>
<span class="p_add">+	{0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	/* V1 */</span>
<span class="p_add">+	{0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1},</span>
<span class="p_add">+	/* G1 */</span>
<span class="p_add">+	{0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0},</span>
<span class="p_add">+	/* D0 */</span>
<span class="p_add">+	{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},</span>
<span class="p_add">+	/* D1 */</span>
<span class="p_add">+	{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1},</span>
<span class="p_add">+</span>
<span class="p_add">+	/* W0 */</span>
<span class="p_add">+	{1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1},</span>
<span class="p_add">+	/* W1 */</span>
<span class="p_add">+	{1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1},</span>
<span class="p_add">+</span>
<span class="p_add">+	/* V2 */</span>
<span class="p_add">+	{0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1},</span>
<span class="p_add">+	/* W2 */</span>
<span class="p_add">+	{1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* number of smrx idx for each channel */</span>
<span class="p_add">+uint32_t g_dss_chn_sid_num[DSS_CHN_MAX_DEFINE] = {</span>
<span class="p_add">+	4, 1, 4, 4, 4, 4, 1, 1, 3, 3, 3, 2</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* start idx of each channel */</span>
<span class="p_add">+/* smrx_idx = g_dss_smmu_smrx_idx[chn_idx] + (0 ~ g_dss_chn_sid_num[chn_idx]) */</span>
<span class="p_add">+uint32_t g_dss_smmu_smrx_idx[DSS_CHN_MAX_DEFINE] = {</span>
<span class="p_add">+	0, 4, 5, 9, 13, 17, 21, 22, 26, 29, 23, 32</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void *g_smmu_rwerraddr_virt = NULL;</span>
<span class="p_add">+static void aif_bw_sort(dss_aif_bw_t a[], int n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int j = 0;</span>
<span class="p_add">+	dss_aif_bw_t tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (; i &lt; n; ++i) {</span>
<span class="p_add">+		for (j = i; j &lt; n - 1; ++j) {</span>
<span class="p_add">+			if (a[j].bw &gt; a[j + 1].bw) {</span>
<span class="p_add">+				tmp = a[j];</span>
<span class="p_add">+				a[j] = a[j + 1];</span>
<span class="p_add">+				a[j + 1] = tmp;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_aif_handler(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		     dss_overlay_t *pov_req, dss_overlay_block_t *pov_h_block)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int k = 0;</span>
<span class="p_add">+	dss_layer_t *layer = NULL;</span>
<span class="p_add">+	dss_wb_layer_t *wb_layer = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_aif_bw_t *aif_bw = NULL;</span>
<span class="p_add">+	uint32_t tmp = 0;</span>
<span class="p_add">+	uint32_t bw_sum = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	int rch_cnt = 0;</span>
<span class="p_add">+	int axi0_cnt = 0;</span>
<span class="p_add">+	int axi1_cnt = 0;</span>
<span class="p_add">+	dss_aif_bw_t aif_bw_tmp[DSS_CHN_MAX_DEFINE];</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_aif_bw_t *aif1_bw = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON(pov_h_block == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(aif_bw_tmp, 0, sizeof(aif_bw_tmp));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req-&gt;wb_enable) {</span>
<span class="p_add">+		for (k = 0; k &lt; pov_req-&gt;wb_layer_nums; k++) {</span>
<span class="p_add">+			wb_layer = &amp;(pov_req-&gt;wb_layer_infos[k]);</span>
<span class="p_add">+			chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+			aif_bw = &amp;(hisifd-&gt;dss_module.aif_bw[chn_idx]);</span>
<span class="p_add">+			aif_bw-&gt;bw = (uint64_t) wb_layer-&gt;dst.buf_size *</span>
<span class="p_add">+			    (wb_layer-&gt;src_rect.w * wb_layer-&gt;src_rect.h) /</span>
<span class="p_add">+			    (wb_layer-&gt;dst.width * wb_layer-&gt;dst.height);</span>
<span class="p_add">+			aif_bw-&gt;chn_idx = chn_idx;</span>
<span class="p_add">+			aif_bw-&gt;axi_sel = AXI_CHN1;</span>
<span class="p_add">+			aif_bw-&gt;is_used = 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;wb_compose_type == DSS_WB_COMPOSE_COPYBIT) {</span>
<span class="p_add">+			for (i = 0; i &lt; pov_h_block-&gt;layer_nums; i++) {</span>
<span class="p_add">+				layer = &amp;pov_h_block-&gt;layer_infos[i];</span>
<span class="p_add">+				chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+				aif_bw_tmp[i].chn_idx = chn_idx;</span>
<span class="p_add">+				aif_bw_tmp[i].axi_sel = AXI_CHN0;</span>
<span class="p_add">+				aif_bw_tmp[i].is_used = 1;</span>
<span class="p_add">+				hisifd-&gt;dss_module.aif_bw[chn_idx] =</span>
<span class="p_add">+				    aif_bw_tmp[i];</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rch_cnt = 0;</span>
<span class="p_add">+	for (i = 0; i &lt; pov_h_block-&gt;layer_nums; i++) {</span>
<span class="p_add">+		layer = &amp;pov_h_block-&gt;layer_infos[i];</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;need_cap &amp; (CAP_BASE | CAP_DIM | CAP_PURE_COLOR))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;need_cap &amp; CAP_AFBCD) {</span>
<span class="p_add">+			aif1_bw = &amp;(hisifd-&gt;dss_module.aif1_bw[chn_idx]);</span>
<span class="p_add">+			aif1_bw-&gt;is_used = 1;</span>
<span class="p_add">+			aif1_bw-&gt;chn_idx = chn_idx;</span>
<span class="p_add">+			if ((pov_req-&gt;ovl_idx == DSS_OVL0) ||</span>
<span class="p_add">+			    (pov_req-&gt;ovl_idx == DSS_OVL1)) {</span>
<span class="p_add">+				if ((i % 2) == 0) {</span>
<span class="p_add">+					aif1_bw-&gt;axi_sel = AXI_CHN0;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					aif1_bw-&gt;axi_sel = AXI_CHN1;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if ((i % 2) == 0) {</span>
<span class="p_add">+					aif1_bw-&gt;axi_sel = AXI_CHN1;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					aif1_bw-&gt;axi_sel = AXI_CHN0;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;fb%d, aif1, chn_idx=%d, axi_sel=%d.\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, chn_idx, aif1_bw-&gt;axi_sel);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		aif_bw_tmp[i].bw = (uint64_t) layer-&gt;img.buf_size *</span>
<span class="p_add">+		    (layer-&gt;src_rect.w * layer-&gt;src_rect.h) /</span>
<span class="p_add">+		    (layer-&gt;img.width * layer-&gt;img.height);</span>
<span class="p_add">+		aif_bw_tmp[i].chn_idx = chn_idx;</span>
<span class="p_add">+		aif_bw_tmp[i].axi_sel = AXI_CHN0;</span>
<span class="p_add">+		aif_bw_tmp[i].is_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		bw_sum += aif_bw_tmp[i].bw;</span>
<span class="p_add">+		rch_cnt++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	aif_bw_sort(aif_bw_tmp, rch_cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+		if (aif_bw_tmp[i].is_used != 1)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp += aif_bw_tmp[i].bw;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((pov_req-&gt;ovl_idx == DSS_OVL0)</span>
<span class="p_add">+		    || (pov_req-&gt;ovl_idx == DSS_OVL1)) {</span>
<span class="p_add">+			if (tmp &lt;= (bw_sum / 2)) {</span>
<span class="p_add">+				aif_bw_tmp[i].axi_sel = AXI_CHN0;</span>
<span class="p_add">+				if (axi0_cnt &gt;= AXI0_MAX_DSS_CHN_THRESHOLD) {</span>
<span class="p_add">+					aif_bw_tmp[i -</span>
<span class="p_add">+						   AXI0_MAX_DSS_CHN_THRESHOLD].axi_sel</span>
<span class="p_add">+					    = AXI_CHN1;</span>
<span class="p_add">+					axi1_cnt++;</span>
<span class="p_add">+					axi0_cnt--;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				axi0_cnt++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif_bw_tmp[i].axi_sel = AXI_CHN1;</span>
<span class="p_add">+				axi1_cnt++;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (tmp &lt;= (bw_sum / 2)) {</span>
<span class="p_add">+				aif_bw_tmp[i].axi_sel = AXI_CHN1;</span>
<span class="p_add">+				if (axi1_cnt &gt;= AXI1_MAX_DSS_CHN_THRESHOLD) {</span>
<span class="p_add">+					aif_bw_tmp[i -</span>
<span class="p_add">+						   AXI1_MAX_DSS_CHN_THRESHOLD].axi_sel</span>
<span class="p_add">+					    = AXI_CHN0;</span>
<span class="p_add">+					axi0_cnt++;</span>
<span class="p_add">+					axi1_cnt--;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				axi1_cnt++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif_bw_tmp[i].axi_sel = AXI_CHN0;</span>
<span class="p_add">+				axi0_cnt++;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		chn_idx = aif_bw_tmp[i].chn_idx;</span>
<span class="p_add">+		hisifd-&gt;dss_module.aif_bw[chn_idx] = aif_bw_tmp[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (g_debug_ovl_online_composer) {</span>
<span class="p_add">+			HISI_FB_INFO</span>
<span class="p_add">+			    (&quot;fb%d, aif0, chn_idx=%d, axi_sel=%d, bw=%llu.\n&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, chn_idx, aif_bw_tmp[i].axi_sel,</span>
<span class="p_add">+			     aif_bw_tmp[i].bw);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_qos_on(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	outp32(hisifd-&gt;noc_dss_base + 0xc, 0x2);</span>
<span class="p_add">+	outp32(hisifd-&gt;noc_dss_base + 0x8c, 0x2);</span>
<span class="p_add">+	outp32(hisifd-&gt;noc_dss_base + 0x10c, 0x2);</span>
<span class="p_add">+	outp32(hisifd-&gt;noc_dss_base + 0x18c, 0x2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS AIF</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int mid_array[DSS_CHN_MAX_DEFINE] = {</span>
<span class="p_add">+	0xb, 0xa, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x2, 0x1, 0x3, 0x0</span>
<span class="p_add">+};</span>
<span class="p_add">+#define CREDIT_STEP_LOWER_ENABLE</span>
<span class="p_add">+void hisi_dss_aif_init(char __iomem *aif_ch_base, dss_aif_t *s_aif)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(aif_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_aif == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_aif, 0, sizeof(dss_aif_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_aif-&gt;aif_ch_ctl = inp32(aif_ch_base + AIF_CH_CTL);</span>
<span class="p_add">+	s_aif-&gt;aif_ch_ctl_add = inp32(aif_ch_base + AIF_CH_CTL_ADD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_aif_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			char __iomem *aif_ch_base, dss_aif_t *s_aif)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(aif_ch_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_aif == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, aif_ch_base + AIF_CH_CTL, s_aif-&gt;aif_ch_ctl, 32,</span>
<span class="p_add">+			0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, aif_ch_base + AIF_CH_CTL_ADD,</span>
<span class="p_add">+			s_aif-&gt;aif_ch_ctl_add, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_aif_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		       dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+		       dss_rect_t *wb_dst_rect,</span>
<span class="p_add">+		       dss_wb_layer_t *wb_layer, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_aif_t *aif = NULL;</span>
<span class="p_add">+	dss_aif_bw_t *aif_bw = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	int mid = 0;</span>
<span class="p_add">+	uint32_t credit_step = 0;</span>
<span class="p_add">+	uint32_t credit_step_lower = 0;</span>
<span class="p_add">+	uint64_t dss_core_rate = 0;</span>
<span class="p_add">+	uint32_t scfd_h = 0;</span>
<span class="p_add">+	uint32_t scfd_v = 0;</span>
<span class="p_add">+	uint32_t online_offline_rate = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON((layer == NULL) &amp;&amp; (wb_layer == NULL));</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	aif = &amp;(hisifd-&gt;dss_module.aif[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.aif_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	aif_bw = &amp;(hisifd-&gt;dss_module.aif_bw[chn_idx]);</span>
<span class="p_add">+	BUG_ON(aif_bw-&gt;is_used != 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	mid = mid_array[chn_idx];</span>
<span class="p_add">+	BUG_ON(mid &lt; 0 || mid &gt; 0xb);</span>
<span class="p_add">+</span>
<span class="p_add">+	aif-&gt;aif_ch_ctl = set_bits32(aif-&gt;aif_ch_ctl, aif_bw-&gt;axi_sel, 1, 0);</span>
<span class="p_add">+	aif-&gt;aif_ch_ctl = set_bits32(aif-&gt;aif_ch_ctl, mid, 4, 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL2) || (ovl_idx == DSS_OVL3)</span>
<span class="p_add">+	    || (layer-&gt;chn_idx == DSS_RCHN_V2)) {</span>
<span class="p_add">+		if (layer &amp;&amp; ((layer-&gt;need_cap &amp; CAP_AFBCD) != CAP_AFBCD)) {</span>
<span class="p_add">+			dss_core_rate = hisifd-&gt;dss_clk_rate.dss_pri_clk_rate;</span>
<span class="p_add">+			if (dss_core_rate == 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, dss_core_rate(%llu) is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, dss_core_rate);</span>
<span class="p_add">+				dss_core_rate = DEFAULT_DSS_CORE_CLK_07V_RATE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step_lower =</span>
<span class="p_add">+			    g_dss_min_bandwidth_inbusbusy * 1000000UL * 8 /</span>
<span class="p_add">+			    dss_core_rate;</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((layer-&gt;src_rect.w &gt; layer-&gt;dst_rect.w) &amp;&amp;</span>
<span class="p_add">+			    (layer-&gt;src_rect.w &gt; get_panel_xres(hisifd))) {</span>
<span class="p_add">+				scfd_h =</span>
<span class="p_add">+				    layer-&gt;src_rect.w * 100 /</span>
<span class="p_add">+				    get_panel_xres(hisifd);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_h = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (layer-&gt;src_rect.h &gt; layer-&gt;dst_rect.h) {</span>
<span class="p_add">+				scfd_v =</span>
<span class="p_add">+				    layer-&gt;src_rect.h * 100 / layer-&gt;dst_rect.h;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_v = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pov_req-&gt;wb_compose_type == DSS_WB_COMPOSE_COPYBIT) {</span>
<span class="p_add">+				if (wb_dst_rect) {</span>
<span class="p_add">+					online_offline_rate =</span>
<span class="p_add">+					    wb_dst_rect-&gt;w * wb_dst_rect-&gt;h /</span>
<span class="p_add">+					    (hisifd-&gt;panel_info.xres *</span>
<span class="p_add">+					     hisifd-&gt;panel_info.yres);</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
<span class="p_add">+				if (online_offline_rate == 0)</span>
<span class="p_add">+					online_offline_rate = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step =</span>
<span class="p_add">+			    hisifd-&gt;panel_info.pxl_clk_rate *</span>
<span class="p_add">+			    online_offline_rate * 32 * scfd_h * scfd_v /</span>
<span class="p_add">+			    dss_core_rate / (100 * 100);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer</span>
<span class="p_add">+			    || g_debug_ovl_credit_step) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;fb%d, layer_idx(%d), chn_idx(%d), src_rect(%d,%d,%d,%d),&quot;</span>
<span class="p_add">+				     &quot;dst_rect(%d,%d,%d,%d), scfd_h=%d, &quot;</span>
<span class="p_add">+				     &quot;scfd_v=%d, credit_step=%d.\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, layer-&gt;layer_idx,</span>
<span class="p_add">+				     layer-&gt;chn_idx, layer-&gt;src_rect.x,</span>
<span class="p_add">+				     layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+				     layer-&gt;src_rect.h, layer-&gt;dst_rect.x,</span>
<span class="p_add">+				     layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+				     layer-&gt;dst_rect.h, scfd_h, scfd_v,</span>
<span class="p_add">+				     credit_step);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (credit_step &lt; 32) {</span>
<span class="p_add">+				credit_step = 32;</span>
<span class="p_add">+			}</span>
<span class="p_add">+#ifndef CREDIT_STEP_LOWER_ENABLE</span>
<span class="p_add">+			if (credit_step &gt; 64) {</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, 0x1, 1, 11);</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, credit_step, 7,</span>
<span class="p_add">+					       16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+#else</span>
<span class="p_add">+			/* credit en lower */</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, 1, 1, 11);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, 2, 4, 12);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, credit_step_lower,</span>
<span class="p_add">+				       7, 16);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl, 0x2, 2, 8);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (wb_layer) {</span>
<span class="p_add">+			dss_core_rate = hisifd-&gt;dss_clk_rate.dss_pri_clk_rate;</span>
<span class="p_add">+			if (dss_core_rate == 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, dss_core_rate(%llu) is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, dss_core_rate);</span>
<span class="p_add">+				dss_core_rate = DEFAULT_DSS_CORE_CLK_07V_RATE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step_lower =</span>
<span class="p_add">+			    g_dss_min_bandwidth_inbusbusy * 1000000UL * 8 /</span>
<span class="p_add">+			    dss_core_rate;</span>
<span class="p_add">+</span>
<span class="p_add">+			scfd_h = 100;</span>
<span class="p_add">+			scfd_v = 100;</span>
<span class="p_add">+			online_offline_rate = 1;</span>
<span class="p_add">+			credit_step =</span>
<span class="p_add">+			    hisifd-&gt;panel_info.pxl_clk_rate *</span>
<span class="p_add">+			    online_offline_rate * 32 * scfd_h * scfd_v /</span>
<span class="p_add">+			    dss_core_rate / (100 * 100);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (credit_step &lt; 32) {</span>
<span class="p_add">+				credit_step = 32;</span>
<span class="p_add">+			}</span>
<span class="p_add">+#ifndef CREDIT_STEP_LOWER_ENABLE</span>
<span class="p_add">+			if (credit_step &gt; 64) {</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, 0x1, 1, 11);</span>
<span class="p_add">+				aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif-&gt;aif_ch_ctl, credit_step, 7,</span>
<span class="p_add">+					       16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+#else</span>
<span class="p_add">+			/* credit en lower */</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, 1, 1, 11);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, 2, 4, 12);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl_add, credit_step_lower,</span>
<span class="p_add">+				       7, 16);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl, 0x2, 2, 8);</span>
<span class="p_add">+			aif-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int hisi_dss_aif1_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_overlay_t *pov_req, dss_layer_t *layer,</span>
<span class="p_add">+			dss_wb_layer_t *wb_layer, int ovl_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_aif_t *aif1 = NULL;</span>
<span class="p_add">+	dss_aif_bw_t *aif1_bw = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	uint32_t need_cap = 0;</span>
<span class="p_add">+	int mid = 0;</span>
<span class="p_add">+	uint32_t credit_step = 0;</span>
<span class="p_add">+	uint32_t credit_step_lower = 0;</span>
<span class="p_add">+	uint64_t dss_core_rate = 0;</span>
<span class="p_add">+	uint32_t scfd_h = 0;</span>
<span class="p_add">+	uint32_t scfd_v = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(pov_req == NULL);</span>
<span class="p_add">+	BUG_ON((layer == NULL) &amp;&amp; (wb_layer == NULL));</span>
<span class="p_add">+	BUG_ON((ovl_idx &lt; DSS_OVL0) || (ovl_idx &gt;= DSS_OVL_IDX_MAX));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+		need_cap = wb_layer-&gt;need_cap;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+		need_cap = layer-&gt;need_cap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(need_cap &amp; CAP_AFBCD))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	aif1 = &amp;(hisifd-&gt;dss_module.aif1[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.aif1_ch_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	aif1_bw = &amp;(hisifd-&gt;dss_module.aif1_bw[chn_idx]);</span>
<span class="p_add">+	BUG_ON(aif1_bw-&gt;is_used != 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	mid = mid_array[chn_idx];</span>
<span class="p_add">+	BUG_ON(mid &lt; 0 || mid &gt; 0xb);</span>
<span class="p_add">+</span>
<span class="p_add">+	aif1-&gt;aif_ch_ctl = set_bits32(aif1-&gt;aif_ch_ctl, aif1_bw-&gt;axi_sel, 1, 0);</span>
<span class="p_add">+	aif1-&gt;aif_ch_ctl = set_bits32(aif1-&gt;aif_ch_ctl, mid, 4, 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ovl_idx == DSS_OVL0) || (ovl_idx == DSS_OVL1)) {</span>
<span class="p_add">+		if (layer &amp;&amp; (layer-&gt;need_cap &amp; CAP_AFBCD)) {</span>
<span class="p_add">+			dss_core_rate = hisifd-&gt;dss_clk_rate.dss_pri_clk_rate;</span>
<span class="p_add">+			if (dss_core_rate == 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, dss_core_rate(%llu) is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, dss_core_rate);</span>
<span class="p_add">+				dss_core_rate = DEFAULT_DSS_CORE_CLK_07V_RATE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((layer-&gt;src_rect.w &gt; layer-&gt;dst_rect.w) &amp;&amp;</span>
<span class="p_add">+			    (layer-&gt;src_rect.w &gt; get_panel_xres(hisifd))) {</span>
<span class="p_add">+				scfd_h =</span>
<span class="p_add">+				    layer-&gt;src_rect.w * 100 /</span>
<span class="p_add">+				    get_panel_xres(hisifd);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_h = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (layer-&gt;src_rect.h &gt; layer-&gt;dst_rect.h) {</span>
<span class="p_add">+				scfd_v =</span>
<span class="p_add">+				    layer-&gt;src_rect.h * 100 / layer-&gt;dst_rect.h;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_v = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step =</span>
<span class="p_add">+			    hisifd-&gt;panel_info.pxl_clk_rate * 32 * 150 *</span>
<span class="p_add">+			    scfd_h * scfd_v / dss_core_rate / (100 * 100 * 100);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer</span>
<span class="p_add">+			    || g_debug_ovl_credit_step) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;fb%d, layer_idx(%d), chn_idx(%d), src_rect(%d,%d,%d,%d),&quot;</span>
<span class="p_add">+				     &quot;dst_rect(%d,%d,%d,%d), scfd_h=%d, &quot;</span>
<span class="p_add">+				     &quot;scfd_v=%d, credit_step=%d.\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, layer-&gt;layer_idx,</span>
<span class="p_add">+				     layer-&gt;chn_idx, layer-&gt;src_rect.x,</span>
<span class="p_add">+				     layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+				     layer-&gt;src_rect.h, layer-&gt;dst_rect.x,</span>
<span class="p_add">+				     layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+				     layer-&gt;dst_rect.h, scfd_h, scfd_v,</span>
<span class="p_add">+				     credit_step);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (credit_step &lt; 32) {</span>
<span class="p_add">+				credit_step = 32;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (credit_step &gt; 64) {</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, 0x1, 1, 11);</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, credit_step, 7,</span>
<span class="p_add">+					       16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (layer &amp;&amp; (layer-&gt;need_cap &amp; CAP_AFBCD)) {</span>
<span class="p_add">+			dss_core_rate = hisifd-&gt;dss_clk_rate.dss_pri_clk_rate;</span>
<span class="p_add">+			if (dss_core_rate == 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, dss_core_rate(%llu is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, dss_core_rate);</span>
<span class="p_add">+				dss_core_rate = DEFAULT_DSS_CORE_CLK_07V_RATE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step_lower =</span>
<span class="p_add">+			    g_dss_min_bandwidth_inbusbusy * 1000000UL * 8 /</span>
<span class="p_add">+			    dss_core_rate;</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((layer-&gt;src_rect.w &gt; layer-&gt;dst_rect.w) &amp;&amp;</span>
<span class="p_add">+			    (layer-&gt;src_rect.w &gt; get_panel_xres(hisifd))) {</span>
<span class="p_add">+				scfd_h =</span>
<span class="p_add">+				    layer-&gt;src_rect.w * 100 /</span>
<span class="p_add">+				    get_panel_xres(hisifd);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_h = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (layer-&gt;src_rect.h &gt; layer-&gt;dst_rect.h) {</span>
<span class="p_add">+				scfd_v =</span>
<span class="p_add">+				    layer-&gt;src_rect.h * 100 / layer-&gt;dst_rect.h;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				scfd_v = 100;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			credit_step =</span>
<span class="p_add">+			    hisifd-&gt;panel_info.pxl_clk_rate * 32 * scfd_h *</span>
<span class="p_add">+			    scfd_v / dss_core_rate / (100 * 100);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (g_debug_ovl_online_composer</span>
<span class="p_add">+			    || g_debug_ovl_credit_step) {</span>
<span class="p_add">+				HISI_FB_INFO</span>
<span class="p_add">+				    (&quot;fb%d, layer_idx(%d), chn_idx(%d), src_rect(%d,%d,%d,%d),&quot;</span>
<span class="p_add">+				     &quot;dst_rect(%d,%d,%d,%d), scfd_h=%d, &quot;</span>
<span class="p_add">+				     &quot;scfd_v=%d, credit_step=%d.\n&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, layer-&gt;layer_idx,</span>
<span class="p_add">+				     layer-&gt;chn_idx, layer-&gt;src_rect.x,</span>
<span class="p_add">+				     layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+				     layer-&gt;src_rect.h, layer-&gt;dst_rect.x,</span>
<span class="p_add">+				     layer-&gt;dst_rect.y, layer-&gt;dst_rect.w,</span>
<span class="p_add">+				     layer-&gt;dst_rect.h, scfd_h, scfd_v,</span>
<span class="p_add">+				     credit_step);</span>
<span class="p_add">+			}</span>
<span class="p_add">+#ifndef CREDIT_STEP_LOWER_ENABLE</span>
<span class="p_add">+			if (credit_step &gt; 64) {</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, 0x1, 1, 11);</span>
<span class="p_add">+				aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+				    set_bits32(aif1-&gt;aif_ch_ctl, credit_step, 7,</span>
<span class="p_add">+					       16);</span>
<span class="p_add">+			}</span>
<span class="p_add">+#else</span>
<span class="p_add">+			/* credit en lower */</span>
<span class="p_add">+			aif1-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif1-&gt;aif_ch_ctl_add, 1, 1, 11);</span>
<span class="p_add">+			aif1-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif1-&gt;aif_ch_ctl_add, 2, 4, 12);</span>
<span class="p_add">+			aif1-&gt;aif_ch_ctl_add =</span>
<span class="p_add">+			    set_bits32(aif1-&gt;aif_ch_ctl_add, credit_step_lower,</span>
<span class="p_add">+				       7, 16);</span>
<span class="p_add">+			aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif1-&gt;aif_ch_ctl, 0x2, 2, 8);</span>
<span class="p_add">+			aif1-&gt;aif_ch_ctl =</span>
<span class="p_add">+			    set_bits32(aif1-&gt;aif_ch_ctl, 0x0, 1, 11);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS SMMU</span>
<span class="p_add">+ */</span>
<span class="p_add">+void hisi_dss_smmu_on(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char __iomem *smmu_base = NULL;</span>
<span class="p_add">+	int idx0 = 0;</span>
<span class="p_add">+	int idx1 = 0;</span>
<span class="p_add">+	int idx2 = 0;</span>
<span class="p_add">+	uint32_t phy_pgd_base = 0;</span>
<span class="p_add">+	struct iommu_domain_data *domain_data = NULL;</span>
<span class="p_add">+	uint64_t smmu_rwerraddr_phys = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	smmu_base = hisifd-&gt;dss_base + DSS_SMMU_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SCR, 0x0, 1, 0);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SCR, 0x1, 8, 20);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SCR, g_dss_smmu_outstanding - 1, 4, 16);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SCR, 0x7, 3, 3);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_LP_CTRL, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_CB_TTBCR, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (g_smmu_rwerraddr_virt) {</span>
<span class="p_add">+		smmu_rwerraddr_phys = virt_to_phys(g_smmu_rwerraddr_virt);</span>
<span class="p_add">+		set_reg(smmu_base + SMMU_ERR_RDADDR,</span>
<span class="p_add">+			(uint32_t) (smmu_rwerraddr_phys &amp; 0xFFFFFFFF), 32, 0);</span>
<span class="p_add">+		set_reg(smmu_base + SMMU_ERR_WRADDR,</span>
<span class="p_add">+			(uint32_t) (smmu_rwerraddr_phys &amp; 0xFFFFFFFF), 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		set_reg(smmu_base + SMMU_ERR_RDADDR, 0x7FF00000, 32, 0);</span>
<span class="p_add">+		set_reg(smmu_base + SMMU_ERR_WRADDR, 0x7FFF0000, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_RLD_EN0_NS, DSS_SMMU_RLD_EN0_DEFAULT_VAL, 32,</span>
<span class="p_add">+		0);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_RLD_EN1_NS, DSS_SMMU_RLD_EN1_DEFAULT_VAL, 32,</span>
<span class="p_add">+		0);</span>
<span class="p_add">+</span>
<span class="p_add">+	idx0 = 36;</span>
<span class="p_add">+	idx1 = 37;</span>
<span class="p_add">+	idx2 = 38;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SMRx_NS + idx0 * 0x4, 0x1, 32, 0);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SMRx_NS + idx1 * 0x4, 0x1, 32, 0);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_SMRx_NS + idx2 * 0x4, 0x1, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	domain_data = (struct iommu_domain_data *)(hisifd-&gt;hisi_domain-&gt;priv);</span>
<span class="p_add">+	phy_pgd_base = (uint32_t) (domain_data-&gt;phy_pgd_base);</span>
<span class="p_add">+	set_reg(smmu_base + SMMU_CB_TTBR0, phy_pgd_base, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_smmu_init(char __iomem *smmu_base, dss_smmu_t *s_smmu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(smmu_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_smmu == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_smmu, 0, sizeof(dss_smmu_t));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_smmu_ch_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			 char __iomem *smmu_base, dss_smmu_t *s_smmu,</span>
<span class="p_add">+			 int chn_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t idx = 0;</span>
<span class="p_add">+	uint32_t i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(smmu_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_smmu == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (s_smmu-&gt;smmu_smrx_ns_used[chn_idx] == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; g_dss_chn_sid_num[chn_idx]; i++) {</span>
<span class="p_add">+		idx = g_dss_smmu_smrx_idx[chn_idx] + i;</span>
<span class="p_add">+		BUG_ON((idx &lt; 0) || (idx &gt;= SMMU_SID_NUM));</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, smmu_base + SMMU_SMRx_NS + idx * 0x4,</span>
<span class="p_add">+				s_smmu-&gt;smmu_smrx_ns[idx], 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_smmu_ch_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_layer_t *layer, dss_wb_layer_t *wb_layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_smmu_t *smmu = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_img_t *img = NULL;</span>
<span class="p_add">+	uint32_t idx = 0;</span>
<span class="p_add">+	uint32_t i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON((layer == NULL) &amp;&amp; (wb_layer == NULL));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		img = &amp;(wb_layer-&gt;dst);</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		img = &amp;(layer-&gt;img);</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	smmu = &amp;(hisifd-&gt;dss_module.smmu);</span>
<span class="p_add">+	hisifd-&gt;dss_module.smmu_used = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	smmu-&gt;smmu_smrx_ns_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; g_dss_chn_sid_num[chn_idx]; i++) {</span>
<span class="p_add">+		idx = g_dss_smmu_smrx_idx[chn_idx] + i;</span>
<span class="p_add">+		BUG_ON((idx &lt; 0) || (idx &gt;= SMMU_SID_NUM));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (img-&gt;mmu_enable == 0) {</span>
<span class="p_add">+			smmu-&gt;smmu_smrx_ns[idx] =</span>
<span class="p_add">+			    set_bits32(smmu-&gt;smmu_smrx_ns[idx], 0x1, 1, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* stream config */</span>
<span class="p_add">+			smmu-&gt;smmu_smrx_ns[idx] =</span>
<span class="p_add">+			    set_bits32(smmu-&gt;smmu_smrx_ns[idx], 0x0, 1, 0);</span>
<span class="p_add">+			smmu-&gt;smmu_smrx_ns[idx] =</span>
<span class="p_add">+			    set_bits32(smmu-&gt;smmu_smrx_ns[idx], 0x1, 1, 4);</span>
<span class="p_add">+			smmu-&gt;smmu_smrx_ns[idx] =</span>
<span class="p_add">+			    set_bits32(smmu-&gt;smmu_smrx_ns[idx], 0x3, 7, 5);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisifb_adjust_block_rect(int block_num, dss_rect_t *ov_block_rects[],</span>
<span class="p_add">+			 dss_wb_layer_t *wb_layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS CSC</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CSC_ROW	(3)</span>
<span class="p_add">+#define CSC_COL	(5)</span>
<span class="p_add">+</span>
<span class="p_add">+/* application: mode 2 is used in rgb2yuv, mode 0 is used in yuv2rgb */</span>
<span class="p_add">+#define CSC_MPREC_MODE_0 (0)</span>
<span class="p_add">+#define CSC_MPREC_MODE_1 (1)</span>
<span class="p_add">+#define CSC_MPREC_MODE_2 (2)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CSC_MPREC_MODE_RGB2YUV (CSC_MPREC_MODE_2)</span>
<span class="p_add">+#define CSC_MPREC_MODE_YUV2RGB (CSC_MPREC_MODE_0)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ ** Rec.601 for Computer</span>
<span class="p_add">+ ** [ p00 p01 p02 cscidc2 cscodc2 ]</span>
<span class="p_add">+ ** [ p10 p11 p12 cscidc1 cscodc1 ]</span>
<span class="p_add">+ ** [ p20 p21 p22 cscidc0 cscodc0 ]</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int CSC_COE_YUV2RGB601_NARROW_MPREC0[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x4a8, 0x000, 0x662, 0x7f0, 0x000},</span>
<span class="p_add">+	{0x4a8, 0x1e6f, 0x1cc0, 0x77f, 0x000},</span>
<span class="p_add">+	{0x4a8, 0x812, 0x000, 0x77f, 0x000}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_RGB2YUV601_NARROW_MPREC2[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x41C, 0x811, 0x191, 0x000, 0x010},</span>
<span class="p_add">+	{0x1DA1, 0x1B58, 0x707, 0x000, 0x081},</span>
<span class="p_add">+	{0x707, 0x1A1E, 0x1EDB, 0x000, 0x081}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_YUV2RGB709_NARROW_MPREC0[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x4a8, 0x000, 0x72c, 0x7f0, 0x000},</span>
<span class="p_add">+	{0x4a8, 0x1f26, 0x1dde, 0x77f, 0x000},</span>
<span class="p_add">+	{0x4a8, 0x873, 0x000, 0x77f, 0x000}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_RGB2YUV709_NARROW_MPREC2[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x2EC, 0x9D4, 0x0FE, 0x000, 0x010},</span>
<span class="p_add">+	{0x1E64, 0x1A95, 0x707, 0x000, 0x081},</span>
<span class="p_add">+	{0x707, 0x199E, 0x1F5B, 0x000, 0x081}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_YUV2RGB601_WIDE_MPREC0[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x400, 0x000, 0x59c, 0x000, 0x000},</span>
<span class="p_add">+	{0x400, 0x1ea0, 0x1d25, 0x77f, 0x000},</span>
<span class="p_add">+	{0x400, 0x717, 0x000, 0x77f, 0x000}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_RGB2YUV601_WIDE_MPREC2[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x4C9, 0x964, 0x1d3, 0x000, 0x000},</span>
<span class="p_add">+	{0x1D4D, 0x1AB3, 0x800, 0x000, 0x081},</span>
<span class="p_add">+	{0x800, 0x194D, 0x1EB3, 0x000, 0x081},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_YUV2RGB709_WIDE_MPREC0[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x400, 0x000, 0x64d, 0x000, 0x000},</span>
<span class="p_add">+	{0x400, 0x1f40, 0x1e21, 0x77f, 0x000},</span>
<span class="p_add">+	{0x400, 0x76c, 0x000, 0x77f, 0x000}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int CSC_COE_RGB2YUV709_WIDE_MPREC2[CSC_ROW][CSC_COL] = {</span>
<span class="p_add">+	{0x367, 0xB71, 0x128, 0x000, 0x000},</span>
<span class="p_add">+	{0x1E2B, 0x19D5, 0x800, 0x000, 0x081},</span>
<span class="p_add">+	{0x800, 0x18BC, 0x1F44, 0x000, 0x081},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_csc_init(char __iomem *csc_base, dss_csc_t *s_csc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(csc_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_csc == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_csc, 0, sizeof(dss_csc_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_csc-&gt;idc0 = inp32(csc_base + CSC_IDC0);</span>
<span class="p_add">+	s_csc-&gt;idc2 = inp32(csc_base + CSC_IDC2);</span>
<span class="p_add">+	s_csc-&gt;odc0 = inp32(csc_base + CSC_ODC0);</span>
<span class="p_add">+	s_csc-&gt;odc2 = inp32(csc_base + CSC_ODC2);</span>
<span class="p_add">+	s_csc-&gt;p0 = inp32(csc_base + CSC_P0);</span>
<span class="p_add">+	s_csc-&gt;p1 = inp32(csc_base + CSC_P1);</span>
<span class="p_add">+	s_csc-&gt;p2 = inp32(csc_base + CSC_P2);</span>
<span class="p_add">+	s_csc-&gt;p3 = inp32(csc_base + CSC_P3);</span>
<span class="p_add">+	s_csc-&gt;p4 = inp32(csc_base + CSC_P4);</span>
<span class="p_add">+	s_csc-&gt;icg_module = inp32(csc_base + CSC_ICG_MODULE);</span>
<span class="p_add">+	s_csc-&gt;mprec = inp32(csc_base + CSC_MPREC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_csc_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		     char __iomem *csc_base, dss_csc_t *s_csc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(csc_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_csc == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_IDC0, s_csc-&gt;idc0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_IDC2, s_csc-&gt;idc2, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_ODC0, s_csc-&gt;odc0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_ODC2, s_csc-&gt;odc2, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_P0, s_csc-&gt;p0, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_P1, s_csc-&gt;p1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_P2, s_csc-&gt;p2, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_P3, s_csc-&gt;p3, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_P4, s_csc-&gt;p4, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_ICG_MODULE,</span>
<span class="p_add">+			s_csc-&gt;icg_module, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, csc_base + CSC_MPREC, s_csc-&gt;mprec, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_pcsc_needed(dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (layer-&gt;chn_idx != DSS_RCHN_V0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_2D_SHARPNESS)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* horizental shrink is not supported by arsr2p */</span>
<span class="p_add">+	if ((layer-&gt;dst_rect.h != layer-&gt;src_rect.h)</span>
<span class="p_add">+	    || (layer-&gt;dst_rect.w &gt; layer-&gt;src_rect.w))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_csc_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		    dss_layer_t *layer, dss_wb_layer_t *wb_layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_csc_t *csc = NULL;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	uint32_t format = 0;</span>
<span class="p_add">+	uint32_t csc_mode = 0;</span>
<span class="p_add">+	int (*csc_coe_yuv2rgb)[CSC_COL];</span>
<span class="p_add">+	int (*csc_coe_rgb2yuv)[CSC_COL];</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		chn_idx = wb_layer-&gt;chn_idx;</span>
<span class="p_add">+		format = wb_layer-&gt;dst.format;</span>
<span class="p_add">+		csc_mode = wb_layer-&gt;dst.csc_mode;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+		format = layer-&gt;img.format;</span>
<span class="p_add">+		csc_mode = layer-&gt;img.csc_mode;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (chn_idx != DSS_RCHN_V0) {</span>
<span class="p_add">+		if (!isYUV(format))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		hisifd-&gt;dss_module.csc_used[chn_idx] = 1;</span>
<span class="p_add">+	} else if ((chn_idx == DSS_RCHN_V0) &amp;&amp; (!isYUV(format))) {</span>
<span class="p_add">+		if (!is_pcsc_needed(layer))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		hisifd-&gt;dss_module.csc_used[DSS_RCHN_V0] = 1;</span>
<span class="p_add">+		hisifd-&gt;dss_module.pcsc_used[DSS_RCHN_V0] = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;dss_module.csc_used[chn_idx] = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (csc_mode == DSS_CSC_601_WIDE) {</span>
<span class="p_add">+		csc_coe_yuv2rgb = CSC_COE_YUV2RGB601_WIDE_MPREC0;</span>
<span class="p_add">+		csc_coe_rgb2yuv = CSC_COE_RGB2YUV601_WIDE_MPREC2;</span>
<span class="p_add">+	} else if (csc_mode == DSS_CSC_601_NARROW) {</span>
<span class="p_add">+		csc_coe_yuv2rgb = CSC_COE_YUV2RGB601_NARROW_MPREC0;</span>
<span class="p_add">+		csc_coe_rgb2yuv = CSC_COE_RGB2YUV601_NARROW_MPREC2;</span>
<span class="p_add">+	} else if (csc_mode == DSS_CSC_709_WIDE) {</span>
<span class="p_add">+		csc_coe_yuv2rgb = CSC_COE_YUV2RGB709_WIDE_MPREC0;</span>
<span class="p_add">+		csc_coe_rgb2yuv = CSC_COE_RGB2YUV709_WIDE_MPREC2;</span>
<span class="p_add">+	} else if (csc_mode == DSS_CSC_709_NARROW) {</span>
<span class="p_add">+		csc_coe_yuv2rgb = CSC_COE_YUV2RGB709_NARROW_MPREC0;</span>
<span class="p_add">+		csc_coe_rgb2yuv = CSC_COE_RGB2YUV709_NARROW_MPREC2;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* TBD  add csc mprec mode 1 and mode 2 */</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support this csc_mode(%d)!\n&quot;, csc_mode);</span>
<span class="p_add">+		csc_coe_yuv2rgb = CSC_COE_YUV2RGB601_WIDE_MPREC0;</span>
<span class="p_add">+		csc_coe_rgb2yuv = CSC_COE_RGB2YUV601_WIDE_MPREC2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* config rch csc */</span>
<span class="p_add">+	if (layer &amp;&amp; hisifd-&gt;dss_module.csc_used[chn_idx]) {</span>
<span class="p_add">+		csc = &amp;(hisifd-&gt;dss_module.csc[chn_idx]);</span>
<span class="p_add">+		csc-&gt;mprec = CSC_MPREC_MODE_YUV2RGB;</span>
<span class="p_add">+		csc-&gt;icg_module = set_bits32(csc-&gt;icg_module, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;idc0 = set_bits32(csc-&gt;idc0,</span>
<span class="p_add">+				       (csc_coe_yuv2rgb[2][3]) |</span>
<span class="p_add">+				       (csc_coe_yuv2rgb[1][3] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;idc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;idc2, (csc_coe_yuv2rgb[0][3]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;odc0 = set_bits32(csc-&gt;odc0,</span>
<span class="p_add">+				       (csc_coe_yuv2rgb[2][4]) |</span>
<span class="p_add">+				       (csc_coe_yuv2rgb[1][4] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;odc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;odc2, (csc_coe_yuv2rgb[0][4]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_yuv2rgb[0][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_yuv2rgb[0][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_yuv2rgb[0][2], 13, 0);</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_yuv2rgb[1][0], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_yuv2rgb[1][1], 13, 0);</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_yuv2rgb[1][2], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_yuv2rgb[2][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_yuv2rgb[2][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p4 = set_bits32(csc-&gt;p4, csc_coe_yuv2rgb[2][2], 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* config rch pcsc */</span>
<span class="p_add">+	if (layer &amp;&amp; hisifd-&gt;dss_module.pcsc_used[chn_idx]) {</span>
<span class="p_add">+		csc = &amp;(hisifd-&gt;dss_module.pcsc[chn_idx]);</span>
<span class="p_add">+		csc-&gt;mprec = CSC_MPREC_MODE_RGB2YUV;</span>
<span class="p_add">+		csc-&gt;icg_module = set_bits32(csc-&gt;icg_module, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;idc0 = set_bits32(csc-&gt;idc0,</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[2][3]) |</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[1][3] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;idc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;idc2, (csc_coe_rgb2yuv[0][3]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;odc0 = set_bits32(csc-&gt;odc0,</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[2][4]) |</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[1][4] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;odc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;odc2, (csc_coe_rgb2yuv[0][4]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_rgb2yuv[0][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_rgb2yuv[0][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_rgb2yuv[0][2], 13, 0);</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_rgb2yuv[1][0], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_rgb2yuv[1][1], 13, 0);</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_rgb2yuv[1][2], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_rgb2yuv[2][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_rgb2yuv[2][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p4 = set_bits32(csc-&gt;p4, csc_coe_rgb2yuv[2][2], 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* config wch csc */</span>
<span class="p_add">+	if (wb_layer) {</span>
<span class="p_add">+		csc = &amp;(hisifd-&gt;dss_module.csc[chn_idx]);</span>
<span class="p_add">+		csc-&gt;mprec = CSC_MPREC_MODE_RGB2YUV;</span>
<span class="p_add">+		csc-&gt;icg_module = set_bits32(csc-&gt;icg_module, 0x1, 1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;idc0 = set_bits32(csc-&gt;idc0,</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[2][3]) |</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[1][3] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;idc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;idc2, (csc_coe_rgb2yuv[0][3]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;odc0 = set_bits32(csc-&gt;odc0,</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[2][4]) |</span>
<span class="p_add">+				       (csc_coe_rgb2yuv[1][4] &lt;&lt; 16), 27, 0);</span>
<span class="p_add">+		csc-&gt;odc2 =</span>
<span class="p_add">+		    set_bits32(csc-&gt;odc2, (csc_coe_rgb2yuv[0][4]), 11, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_rgb2yuv[0][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p0 = set_bits32(csc-&gt;p0, csc_coe_rgb2yuv[0][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_rgb2yuv[0][2], 13, 0);</span>
<span class="p_add">+		csc-&gt;p1 = set_bits32(csc-&gt;p1, csc_coe_rgb2yuv[1][0], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_rgb2yuv[1][1], 13, 0);</span>
<span class="p_add">+		csc-&gt;p2 = set_bits32(csc-&gt;p2, csc_coe_rgb2yuv[1][2], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_rgb2yuv[2][0], 13, 0);</span>
<span class="p_add">+		csc-&gt;p3 = set_bits32(csc-&gt;p3, csc_coe_rgb2yuv[2][1], 13, 16);</span>
<span class="p_add">+</span>
<span class="p_add">+		csc-&gt;p4 = set_bits32(csc-&gt;p4, csc_coe_rgb2yuv[2][2], 13, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+uint32_t hisi_dss_mif_get_invalid_sel(dss_img_t *img, uint32_t transform,</span>
<span class="p_add">+			     int v_scaling_factor, uint8_t is_tile,</span>
<span class="p_add">+			     bool rdma_stretch_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t invalid_sel_val = 0;</span>
<span class="p_add">+	uint32_t tlb_tag_org = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (img == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;img is null&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((transform == (HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_H))</span>
<span class="p_add">+	    || (transform ==</span>
<span class="p_add">+		(HISI_FB_TRANSFORM_ROT_90 | HISI_FB_TRANSFORM_FLIP_V))) {</span>
<span class="p_add">+		transform = HISI_FB_TRANSFORM_ROT_90;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tlb_tag_org = (transform &amp; 0x7) |</span>
<span class="p_add">+	    ((is_tile ? 1 : 0) &lt;&lt; 3) | ((rdma_stretch_enable ? 1 : 0) &lt;&lt; 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (tlb_tag_org) {</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x0:</span>
<span class="p_add">+		invalid_sel_val = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x1:</span>
<span class="p_add">+		invalid_sel_val = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x2:</span>
<span class="p_add">+		invalid_sel_val = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x3:</span>
<span class="p_add">+		invalid_sel_val = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x4:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x7:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x8:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x9:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0xA:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0xB:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0xC:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0xF:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x10:</span>
<span class="p_add">+		invalid_sel_val = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x11:</span>
<span class="p_add">+		invalid_sel_val = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x12:</span>
<span class="p_add">+		invalid_sel_val = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x13:</span>
<span class="p_add">+		invalid_sel_val = 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x14:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x17:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x18:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x19:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x1A:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x1B:</span>
<span class="p_add">+		invalid_sel_val = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x1C:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case MMU_TLB_TAG_ORG_0x1F:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		invalid_sel_val = 0;</span>
<span class="p_add">+		HISI_FB_ERR(&quot;not support this tlb_tag_org(0x%x)!\n&quot;,</span>
<span class="p_add">+			    tlb_tag_org);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return invalid_sel_val;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS ARSR2P</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ARSR2P_PHASE_NUM	(9)</span>
<span class="p_add">+#define ARSR2P_TAP4	(4)</span>
<span class="p_add">+#define ARSR2P_TAP6	(6)</span>
<span class="p_add">+#define ARSR2P_MIN_INPUT (16)</span>
<span class="p_add">+#define ARSR2P_MAX_WIDTH (2560)</span>
<span class="p_add">+#define ARSR2P_MAX_HEIGHT (8192)</span>
<span class="p_add">+#define ARSR2P_SCALE_MAX (60)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARSR2P_SCL_UP_OFFSET (0x48)</span>
<span class="p_add">+#define ARSR2P_COEF_H0_OFFSET (0x100)</span>
<span class="p_add">+#define ARSR2P_COEF_H1_OFFSET (0x200)</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_AUV_SCL_UP_TAP4[ARSR2P_PHASE_NUM][ARSR2P_TAP4] = {</span>
<span class="p_add">+	{-3, 254, 6, -1},</span>
<span class="p_add">+	{-9, 255, 13, -3},</span>
<span class="p_add">+	{-18, 254, 27, -7},</span>
<span class="p_add">+	{-23, 245, 44, -10},</span>
<span class="p_add">+	{-27, 233, 64, -14},</span>
<span class="p_add">+	{-29, 218, 85, -18},</span>
<span class="p_add">+	{-29, 198, 108, -21},</span>
<span class="p_add">+	{-29, 177, 132, -24},</span>
<span class="p_add">+	{-27, 155, 155, -27}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_AUV_SCL_DOWN_TAP4[ARSR2P_PHASE_NUM][ARSR2P_TAP4] = {</span>
<span class="p_add">+	{31, 194, 31, 0},</span>
<span class="p_add">+	{23, 206, 44, -17},</span>
<span class="p_add">+	{14, 203, 57, -18},</span>
<span class="p_add">+	{6, 198, 70, -18},</span>
<span class="p_add">+	{0, 190, 85, -19},</span>
<span class="p_add">+	{-5, 180, 99, -18},</span>
<span class="p_add">+	{-10, 170, 114, -18},</span>
<span class="p_add">+	{-13, 157, 129, -17},</span>
<span class="p_add">+	{-15, 143, 143, -15}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_Y_SCL_UP_TAP6[ARSR2P_PHASE_NUM][ARSR2P_TAP6] = {</span>
<span class="p_add">+	{0, -3, 254, 6, -1, 0},</span>
<span class="p_add">+	{4, -12, 252, 15, -5, 2},</span>
<span class="p_add">+	{7, -22, 245, 31, -9, 4},</span>
<span class="p_add">+	{10, -29, 234, 49, -14, 6},</span>
<span class="p_add">+	{12, -34, 221, 68, -19, 8},</span>
<span class="p_add">+	{13, -37, 206, 88, -24, 10},</span>
<span class="p_add">+	{14, -38, 189, 108, -29, 12},</span>
<span class="p_add">+	{14, -38, 170, 130, -33, 13},</span>
<span class="p_add">+	{14, -36, 150, 150, -36, 14}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const int COEF_Y_SCL_DOWN_TAP6[ARSR2P_PHASE_NUM][ARSR2P_TAP6] = {</span>
<span class="p_add">+	{-22, 43, 214, 43, -22, 0},</span>
<span class="p_add">+	{-18, 29, 205, 53, -23, 10},</span>
<span class="p_add">+	{-16, 18, 203, 67, -25, 9},</span>
<span class="p_add">+	{-13, 9, 198, 80, -26, 8},</span>
<span class="p_add">+	{-10, 0, 191, 95, -27, 7},</span>
<span class="p_add">+	{-7, -7, 182, 109, -27, 6},</span>
<span class="p_add">+	{-5, -14, 174, 124, -27, 4},</span>
<span class="p_add">+	{-2, -18, 162, 137, -25, 2},</span>
<span class="p_add">+	{0, -22, 150, 150, -22, 0}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS ARSR2P</span>
<span class="p_add">+ */</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_arsr1p_write_coefs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    bool enable_cmdlist, char __iomem *addr,</span>
<span class="p_add">+			    const int **p, int row, int col)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int coef_value = 0;</span>
<span class="p_add">+	int coef_num = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int j = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(addr == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((row != ARSR2P_PHASE_NUM)</span>
<span class="p_add">+	    || ((col != ARSR2P_TAP4) &amp;&amp; (col != ARSR2P_TAP6))) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;arsr1p filter coefficients is err, arsr1p_phase_num = %d, arsr1p_tap_num = %d\n&quot;,</span>
<span class="p_add">+		     row, col);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	coef_num = (col == ARSR2P_TAP4 ? 2 : 3);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (j = 0; j &lt; 2; j++) {</span>
<span class="p_add">+		for (i = 0; i &lt; row; i++) {</span>
<span class="p_add">+			if (coef_num == 2) {</span>
<span class="p_add">+				coef_value =</span>
<span class="p_add">+				    (*((int *)p + i * col + j * coef_num) &amp;</span>
<span class="p_add">+				     0x1FF) |</span>
<span class="p_add">+				    ((*((int *)p + i * col + j * coef_num + 1) &amp;</span>
<span class="p_add">+				      0x1FF) &lt;&lt; 9);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				coef_value =</span>
<span class="p_add">+				    (*((int *)p + i * col + j * coef_num) &amp;</span>
<span class="p_add">+				     0x1FF) |</span>
<span class="p_add">+				    ((*((int *)p + i * col + j * coef_num + 1) &amp;</span>
<span class="p_add">+				      0x1FF) &lt;&lt; 9) | ((*((int *)p + i * col +</span>
<span class="p_add">+							 j * coef_num +</span>
<span class="p_add">+							 2) &amp; 0x1FF) &lt;&lt; 18);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (enable_cmdlist) {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						addr + 0x8 * i + j * 0x4,</span>
<span class="p_add">+						coef_value, 32, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				set_reg(addr + 0x8 * i + j * 0x4, coef_value,</span>
<span class="p_add">+					32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_post_scl_load_filter_coef(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				   bool enable_cmdlist,</span>
<span class="p_add">+				   char __iomem *scl_lut_base,</span>
<span class="p_add">+				   int coef_lut_idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr1p_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					scl_lut_base + ARSR1P_COEFF_H_Y0,</span>
<span class="p_add">+					(const int **)COEF_Y_SCL_UP_TAP6,</span>
<span class="p_add">+					ARSR2P_PHASE_NUM, ARSR2P_TAP6);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write H_Y0_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr1p_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					scl_lut_base + ARSR1P_COEFF_V_Y0,</span>
<span class="p_add">+					(const int **)COEF_Y_SCL_UP_TAP6,</span>
<span class="p_add">+					ARSR2P_PHASE_NUM, ARSR2P_TAP6);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write V_Y0_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr1p_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					scl_lut_base + ARSR1P_COEFF_H_UV0,</span>
<span class="p_add">+					(const int **)COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write H_UV0_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr1p_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					scl_lut_base + ARSR1P_COEFF_V_UV0,</span>
<span class="p_add">+					(const int **)COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write V_UV0_COEF coefficients.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_arsr2p_write_coefs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			    bool enable_cmdlist, char __iomem *addr,</span>
<span class="p_add">+			    const int **p, int row, int col)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int coef_value = 0;</span>
<span class="p_add">+	int coef_num = 0;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	int j = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(addr == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((row != ARSR2P_PHASE_NUM)</span>
<span class="p_add">+	    || ((col != ARSR2P_TAP4) &amp;&amp; (col != ARSR2P_TAP6))) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;arsr2p filter coefficients is err, arsr2p_phase_num = %d, arsr2p_tap_num = %d\n&quot;,</span>
<span class="p_add">+		     row, col);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	coef_num = (col == ARSR2P_TAP4 ? 2 : 3);</span>
<span class="p_add">+	for (i = 0; i &lt; row; i++) {</span>
<span class="p_add">+		for (j = 0; j &lt; 2; j++) {</span>
<span class="p_add">+			if (coef_num == 2) {</span>
<span class="p_add">+				coef_value =</span>
<span class="p_add">+				    (*((int *)p + i * col + j * coef_num) &amp;</span>
<span class="p_add">+				     0x1FF) |</span>
<span class="p_add">+				    ((*((int *)p + i * col + j * coef_num + 1) &amp;</span>
<span class="p_add">+				      0x1FF) &lt;&lt; 9);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				coef_value =</span>
<span class="p_add">+				    (*((int *)p + i * col + j * coef_num) &amp;</span>
<span class="p_add">+				     0x1FF) |</span>
<span class="p_add">+				    ((*((int *)p + i * col + j * coef_num + 1) &amp;</span>
<span class="p_add">+				      0x1FF) &lt;&lt; 9) | ((*((int *)p + i * col +</span>
<span class="p_add">+							 j * coef_num +</span>
<span class="p_add">+							 2) &amp; 0x1FF) &lt;&lt; 18);</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (enable_cmdlist) {</span>
<span class="p_add">+				hisifd-&gt;set_reg(hisifd,</span>
<span class="p_add">+						addr + 0x8 * i + j * 0x4,</span>
<span class="p_add">+						coef_value, 32, 0);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				set_reg(addr + 0x8 * i + j * 0x4, coef_value,</span>
<span class="p_add">+					32, 0);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_arsr2p_write_config_coefs(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				   bool enable_cmdlist,</span>
<span class="p_add">+				   char __iomem *addr,</span>
<span class="p_add">+				   const int **scl_down,</span>
<span class="p_add">+				   const int **scl_up, int row, int col)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr2p_write_coefs(hisifd, enable_cmdlist, addr,</span>
<span class="p_add">+					scl_down, row, col);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write COEF_SCL_DOWN coefficients.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =</span>
<span class="p_add">+	    hisi_dss_arsr2p_write_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					addr + ARSR2P_SCL_UP_OFFSET, scl_up,</span>
<span class="p_add">+					row, col);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;Error to write COEF_SCL_UP coefficients.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_arsr2p_init(char __iomem *arsr2p_base, dss_arsr2p_t *s_arsr2p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(arsr2p_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_arsr2p == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(s_arsr2p, 0, sizeof(dss_arsr2p_t));</span>
<span class="p_add">+</span>
<span class="p_add">+	s_arsr2p-&gt;arsr_input_width_height =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_INPUT_WIDTH_HEIGHT);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr_output_width_height =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_OUTPUT_WIDTH_HEIGHT);</span>
<span class="p_add">+	s_arsr2p-&gt;ihleft = inp32(arsr2p_base + ARSR2P_IHLEFT);</span>
<span class="p_add">+	s_arsr2p-&gt;ihright = inp32(arsr2p_base + ARSR2P_IHRIGHT);</span>
<span class="p_add">+	s_arsr2p-&gt;ivtop = inp32(arsr2p_base + ARSR2P_IVTOP);</span>
<span class="p_add">+	s_arsr2p-&gt;ivbottom = inp32(arsr2p_base + ARSR2P_IVBOTTOM);</span>
<span class="p_add">+	s_arsr2p-&gt;ihinc = inp32(arsr2p_base + ARSR2P_IHINC);</span>
<span class="p_add">+	s_arsr2p-&gt;ivinc = inp32(arsr2p_base + ARSR2P_IVINC);</span>
<span class="p_add">+	s_arsr2p-&gt;offset = inp32(arsr2p_base + ARSR2P_UV_OFFSET);</span>
<span class="p_add">+	s_arsr2p-&gt;mode = inp32(arsr2p_base + ARSR2P_MODE);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_thres_y =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_THRES_Y);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_thres_u =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_THRES_U);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_thres_v =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_THRES_V);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_cfg0 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_CFG0);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_cfg1 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_CFG1);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.skin_cfg2 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SKIN_CFG2);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.shoot_cfg1 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHOOT_CFG1);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.shoot_cfg2 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHOOT_CFG2);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg1 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG1);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg2 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG2);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg3 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG3);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg4 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG4);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg5 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG5);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg6 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG6);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg7 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG7);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg8 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG8);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.sharp_cfg9 =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_SHARP_CFG9);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.texturw_analysts =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_TEXTURW_ANALYSTS);</span>
<span class="p_add">+	s_arsr2p-&gt;arsr2p_effect.intplshootctrl =</span>
<span class="p_add">+	    inp32(arsr2p_base + ARSR2P_INTPLSHOOTCTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	s_arsr2p-&gt;ihleft1 = inp32(arsr2p_base + ARSR2P_IHLEFT1);</span>
<span class="p_add">+	s_arsr2p-&gt;ihright1 = inp32(arsr2p_base + ARSR2P_IHRIGHT1);</span>
<span class="p_add">+	s_arsr2p-&gt;ivbottom1 = inp32(arsr2p_base + ARSR2P_IVBOTTOM1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_arsr2p_set_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			char __iomem *arsr2p_base, dss_arsr2p_t *s_arsr2p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(arsr2p_base == NULL);</span>
<span class="p_add">+	BUG_ON(s_arsr2p == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_INPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+			s_arsr2p-&gt;arsr_input_width_height, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_OUTPUT_WIDTH_HEIGHT,</span>
<span class="p_add">+			s_arsr2p-&gt;arsr_output_width_height, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IHLEFT,</span>
<span class="p_add">+			s_arsr2p-&gt;ihleft, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IHRIGHT,</span>
<span class="p_add">+			s_arsr2p-&gt;ihright, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IVTOP,</span>
<span class="p_add">+			s_arsr2p-&gt;ivtop, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IVBOTTOM,</span>
<span class="p_add">+			s_arsr2p-&gt;ivbottom, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IHINC,</span>
<span class="p_add">+			s_arsr2p-&gt;ihinc, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IVINC,</span>
<span class="p_add">+			s_arsr2p-&gt;ivinc, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_UV_OFFSET,</span>
<span class="p_add">+			s_arsr2p-&gt;offset, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_MODE,</span>
<span class="p_add">+			s_arsr2p-&gt;mode, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;dss_module.arsr2p_effect_used[DSS_RCHN_V0]) {</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_Y,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_thres_y, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_U,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_thres_u, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_V,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_thres_v, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG0,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_cfg0, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG1,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_cfg1, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG2,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.skin_cfg2, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHOOT_CFG1,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.shoot_cfg1, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHOOT_CFG2,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.shoot_cfg2, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG1,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg1, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG2,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg2, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG3,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg3, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG4,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg4, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG5,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg5, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG6,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg6, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG7,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg7, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG8,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg8, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG9,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.sharp_cfg9, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_TEXTURW_ANALYSTS,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.texturw_analysts, 32, 0);</span>
<span class="p_add">+		hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_INTPLSHOOTCTRL,</span>
<span class="p_add">+				s_arsr2p-&gt;arsr2p_effect.intplshootctrl, 32, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IHLEFT1,</span>
<span class="p_add">+			s_arsr2p-&gt;ihleft1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IHRIGHT1,</span>
<span class="p_add">+			s_arsr2p-&gt;ihright1, 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_IVBOTTOM1,</span>
<span class="p_add">+			s_arsr2p-&gt;ivbottom1, 32, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_arsr2p_coef_on(struct hisi_fb_data_type *hisifd, bool enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t module_base = 0;</span>
<span class="p_add">+	char __iomem *arsr2p_base = 0;</span>
<span class="p_add">+	char __iomem *coefy_v = NULL;</span>
<span class="p_add">+	char __iomem *coefa_v = NULL;</span>
<span class="p_add">+	char __iomem *coefuv_v = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	module_base = g_dss_module_base[DSS_RCHN_V0][MODULE_ARSR2P_LUT];</span>
<span class="p_add">+	coefy_v = hisifd-&gt;dss_base + module_base + ARSR2P_LUT_COEFY_V_OFFSET;</span>
<span class="p_add">+	coefa_v = hisifd-&gt;dss_base + module_base + ARSR2P_LUT_COEFA_V_OFFSET;</span>
<span class="p_add">+	coefuv_v = hisifd-&gt;dss_base + module_base + ARSR2P_LUT_COEFUV_V_OFFSET;</span>
<span class="p_add">+	arsr2p_base =</span>
<span class="p_add">+	    hisifd-&gt;dss_base + g_dss_module_base[DSS_RCHN_V0][MODULE_ARSR2P];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* COEFY_V COEFY_H */</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist, coefy_v,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_Y_SCL_DOWN_TAP6,</span>
<span class="p_add">+					   (const int **)COEF_Y_SCL_UP_TAP6,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP6);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefy_v + ARSR2P_COEF_H0_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_Y_SCL_DOWN_TAP6,</span>
<span class="p_add">+					   (const int **)COEF_Y_SCL_UP_TAP6,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP6);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefy_v + ARSR2P_COEF_H1_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_Y_SCL_DOWN_TAP6,</span>
<span class="p_add">+					   (const int **)COEF_Y_SCL_UP_TAP6,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP6);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* COEFA_V COEFA_H */</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist, coefa_v,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefa_v + ARSR2P_COEF_H0_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefa_v + ARSR2P_COEF_H1_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* COEFUV_V COEFUV_H */</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist, coefuv_v,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefuv_v + ARSR2P_COEF_H0_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+	hisi_dss_arsr2p_write_config_coefs(hisifd, enable_cmdlist,</span>
<span class="p_add">+					   coefuv_v + ARSR2P_COEF_H1_OFFSET,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_DOWN_TAP4,</span>
<span class="p_add">+					   (const int **)</span>
<span class="p_add">+					   COEF_AUV_SCL_UP_TAP4,</span>
<span class="p_add">+					   ARSR2P_PHASE_NUM, ARSR2P_TAP4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisi_cmdlist_set_reg;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hisifd-&gt;set_reg = hisifb_set_reg;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_Y,</span>
<span class="p_add">+			(75 | (83 &lt;&lt; 8) | (145 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_U,</span>
<span class="p_add">+			(5 | (10 &lt;&lt; 8) | (113 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_THRES_V,</span>
<span class="p_add">+			(6 | (12 &lt;&lt; 8) | (152 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG0,</span>
<span class="p_add">+			(512 | (3 &lt;&lt; 12)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG1, (819), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SKIN_CFG2, (682), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHOOT_CFG1,</span>
<span class="p_add">+			(512 | (20 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHOOT_CFG2,</span>
<span class="p_add">+			(-16 | (0 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG1,</span>
<span class="p_add">+			(2 | (6 &lt;&lt; 8) | (48 &lt;&lt; 16) | (64 &lt;&lt; 24)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG2,</span>
<span class="p_add">+			(8 | (24 &lt;&lt; 8) | (24 &lt;&lt; 16) | (40 &lt;&lt; 24)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG3,</span>
<span class="p_add">+			(1 | (1 &lt;&lt; 8) | (2500 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG4,</span>
<span class="p_add">+			(10 | (6 &lt;&lt; 8) | (9 &lt;&lt; 16) | (12 &lt;&lt; 24)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG5,</span>
<span class="p_add">+			(2 | (12 &lt;&lt; 8)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG6,</span>
<span class="p_add">+			(448 | (64 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG7,</span>
<span class="p_add">+			(1 | (250 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG8,</span>
<span class="p_add">+			(-48000), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_SHARP_CFG9,</span>
<span class="p_add">+			(-32000), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_TEXTURW_ANALYSTS,</span>
<span class="p_add">+			(15 | (20 &lt;&lt; 16)), 32, 0);</span>
<span class="p_add">+	hisifd-&gt;set_reg(hisifd, arsr2p_base + ARSR2P_INTPLSHOOTCTRL,</span>
<span class="p_add">+			(4), 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisi_dss_arsr2p_effect_config(dss_arsr2p_effect_t *arsr2p_effect)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_thres_y = 75 | (83 &lt;&lt; 8) | (145 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_thres_u = 5 | (10 &lt;&lt; 8) | (113 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_thres_v = 6 | (12 &lt;&lt; 8) | (152 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_cfg0 = 512 | (3 &lt;&lt; 12);</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_cfg1 = 819;</span>
<span class="p_add">+	arsr2p_effect-&gt;skin_cfg2 = 682;</span>
<span class="p_add">+	arsr2p_effect-&gt;shoot_cfg1 = 512 | (20 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;shoot_cfg2 = -16 | (0 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg1 = 2 | (6 &lt;&lt; 8) | (48 &lt;&lt; 16) | (64 &lt;&lt; 24);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg2 = 8 | (24 &lt;&lt; 8) | (24 &lt;&lt; 16) | (40 &lt;&lt; 24);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg3 = 1 | (1 &lt;&lt; 8) | (2500 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg4 = 10 | (6 &lt;&lt; 8) | (9 &lt;&lt; 16) | (12 &lt;&lt; 24);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg5 = 2 | (12 &lt;&lt; 8);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg6 = 448 | (64 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg7 = 1 | (250 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg8 = -48000;</span>
<span class="p_add">+	arsr2p_effect-&gt;sharp_cfg9 = -32000;</span>
<span class="p_add">+	arsr2p_effect-&gt;texturw_analysts = 15 | (20 &lt;&lt; 16);</span>
<span class="p_add">+	arsr2p_effect-&gt;intplshootctrl = 4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_arsr2p_config(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+		       dss_layer_t *layer, dss_rect_t *aligned_rect,</span>
<span class="p_add">+		       bool rdma_stretch_enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_arsr2p_t *arsr2p = NULL;</span>
<span class="p_add">+	dss_rect_t src_rect;</span>
<span class="p_add">+	dss_rect_t dst_rect;</span>
<span class="p_add">+	uint32_t need_cap = 0;</span>
<span class="p_add">+	int chn_idx = 0;</span>
<span class="p_add">+	dss_block_info_t *pblock_info = NULL;</span>
<span class="p_add">+	int extraw = 0, extraw_left = 0, extraw_right = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	bool en_hscl = false;</span>
<span class="p_add">+	bool en_vscl = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* arsr mode */</span>
<span class="p_add">+	bool imageintpl_dis = false;</span>
<span class="p_add">+	bool hscldown_enabled = false;</span>
<span class="p_add">+	bool nearest_en = false;</span>
<span class="p_add">+	bool diintpl_en = false;</span>
<span class="p_add">+	bool textureanalyhsisen_en = false;</span>
<span class="p_add">+	bool skinctrl_en = false;</span>
<span class="p_add">+	bool shootdetect_en = false;</span>
<span class="p_add">+	bool sharpen_en = false;</span>
<span class="p_add">+	bool arsr2p_bypass = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	bool hscldown_flag = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	int ih_inc = 0;</span>
<span class="p_add">+	int iv_inc = 0;</span>
<span class="p_add">+	int ih_left = 0;</span>
<span class="p_add">+	int ih_right = 0;</span>
<span class="p_add">+	int iv_top = 0;</span>
<span class="p_add">+	int iv_bottom = 0;</span>
<span class="p_add">+	int uv_offset = 0;</span>
<span class="p_add">+	int src_width = 0;</span>
<span class="p_add">+	int dst_whole_width = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	int outph_left = 0;</span>
<span class="p_add">+	int outph_right = 0;</span>
<span class="p_add">+	int outpv_bottom = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+	BUG_ON(layer == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	chn_idx = layer-&gt;chn_idx;</span>
<span class="p_add">+	if (chn_idx != DSS_RCHN_V0) {</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	need_cap = layer-&gt;need_cap;</span>
<span class="p_add">+</span>
<span class="p_add">+	src_rect = layer-&gt;src_rect;</span>
<span class="p_add">+	dst_rect = layer-&gt;dst_rect;</span>
<span class="p_add">+	pblock_info = &amp;(layer-&gt;block_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pblock_info &amp;&amp; pblock_info-&gt;h_ratio_arsr2p) {</span>
<span class="p_add">+		src_rect = pblock_info-&gt;arsr2p_in_rect;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	src_rect.h = aligned_rect-&gt;h;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* horizental scaler compute */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (pblock_info &amp;&amp; pblock_info-&gt;h_ratio_arsr2p) {</span>
<span class="p_add">+			ih_inc = pblock_info-&gt;h_ratio_arsr2p;</span>
<span class="p_add">+			src_width = src_rect.w;</span>
<span class="p_add">+			dst_whole_width = pblock_info-&gt;arsr2p_dst_w;</span>
<span class="p_add">+			src_rect.x = src_rect.x - pblock_info-&gt;arsr2p_src_x;</span>
<span class="p_add">+			src_rect.y = src_rect.y - pblock_info-&gt;arsr2p_src_y;</span>
<span class="p_add">+			dst_rect.x = dst_rect.x - pblock_info-&gt;arsr2p_dst_x;</span>
<span class="p_add">+			dst_rect.y = dst_rect.y - pblock_info-&gt;arsr2p_dst_y;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pblock_info-&gt;both_vscfh_arsr2p_used) {</span>
<span class="p_add">+				hscldown_flag = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (rdma_stretch_enable) {</span>
<span class="p_add">+				en_hscl = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ih_inc &amp;&amp; ih_inc != ARSR2P_INC_FACTOR) {</span>
<span class="p_add">+				en_hscl = true;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* horizental scaling down is not supported by arsr2p, set src_rect.w = dst_rect.w */</span>
<span class="p_add">+			if (src_rect.w &gt; dst_rect.w) {</span>
<span class="p_add">+				src_width = dst_rect.w;</span>
<span class="p_add">+				hscldown_flag = true;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				src_width = src_rect.w;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			dst_whole_width = dst_rect.w;</span>
<span class="p_add">+</span>
<span class="p_add">+			src_rect.x = 0;</span>
<span class="p_add">+			src_rect.y = 0;</span>
<span class="p_add">+			dst_rect.x = 0;</span>
<span class="p_add">+			dst_rect.y = 0;</span>
<span class="p_add">+			if (src_width != dst_rect.w)</span>
<span class="p_add">+				en_hscl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+			ih_inc =</span>
<span class="p_add">+			    (DSS_WIDTH(src_width) * ARSR2P_INC_FACTOR +</span>
<span class="p_add">+			     ARSR2P_INC_FACTOR - ih_left) / dst_rect.w;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		outph_left =</span>
<span class="p_add">+		    dst_rect.x * ih_inc - (src_rect.x * ARSR2P_INC_FACTOR);</span>
<span class="p_add">+		if (outph_left &lt; 0)</span>
<span class="p_add">+			outph_left = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		extraw = (8 * ARSR2P_INC_FACTOR) / ih_inc;</span>
<span class="p_add">+		extraw_left = (extraw % 2) ? (extraw + 1) : (extraw);</span>
<span class="p_add">+		ih_left = outph_left - extraw_left * ih_inc;</span>
<span class="p_add">+		if (ih_left &lt; 0)</span>
<span class="p_add">+			ih_left = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		outph_right =</span>
<span class="p_add">+		    (dst_rect.x + dst_rect.w - 1) * ih_inc -</span>
<span class="p_add">+		    (src_rect.x * ARSR2P_INC_FACTOR);</span>
<span class="p_add">+		if (dst_whole_width == dst_rect.w) {</span>
<span class="p_add">+			extraw = (2 * ARSR2P_INC_FACTOR) / ih_inc;</span>
<span class="p_add">+			extraw_right = (extraw % 2) ? (extraw + 1) : (extraw);</span>
<span class="p_add">+			ih_right = outph_right + extraw_right * ih_inc;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*if(ihright+(starti &lt;&lt; 16)) &gt;(width - 1)* ihinc);</span>
<span class="p_add">+			   ihright = endo*ihinc-(starti&lt;&lt;16); */</span>
<span class="p_add">+			extraw =</span>
<span class="p_add">+			    (dst_whole_width - 1) * ih_inc -</span>
<span class="p_add">+			    (src_rect.x * ARSR2P_INC_FACTOR);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ih_right &gt; extraw) {</span>
<span class="p_add">+				ih_right = extraw;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ih_right = src_width * ARSR2P_INC_FACTOR - 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* vertical scaler compute */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (src_rect.h != dst_rect.h)</span>
<span class="p_add">+			en_vscl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (src_rect.h &gt; dst_rect.h) {</span>
<span class="p_add">+			iv_inc =</span>
<span class="p_add">+			    (DSS_HEIGHT(src_rect.h) * ARSR2P_INC_FACTOR +</span>
<span class="p_add">+			     ARSR2P_INC_FACTOR / 2 -</span>
<span class="p_add">+			     iv_top) / DSS_HEIGHT(dst_rect.h);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			iv_inc =</span>
<span class="p_add">+			    (DSS_HEIGHT(src_rect.h) * ARSR2P_INC_FACTOR +</span>
<span class="p_add">+			     ARSR2P_INC_FACTOR - iv_top) / dst_rect.h;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		iv_bottom = DSS_HEIGHT(dst_rect.h) * iv_inc + iv_top;</span>
<span class="p_add">+		outpv_bottom = iv_bottom;</span>
<span class="p_add">+	} while(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (need_cap &amp; CAP_2D_SHARPNESS) {</span>
<span class="p_add">+		sharpen_en = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!en_hscl) &amp;&amp; (!en_vscl)) {</span>
<span class="p_add">+		if (!sharpen_en) {</span>
<span class="p_add">+			/*if both scaler up and sharpness are not needed, just return */</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		} else if (!hscldown_flag) {</span>
<span class="p_add">+			/*if only sharpness is needed, disable image interplo, enable textureanalyhsis */</span>
<span class="p_add">+			imageintpl_dis = true;</span>
<span class="p_add">+			textureanalyhsisen_en = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	arsr2p = &amp;(hisifd-&gt;dss_module.arsr2p[chn_idx]);</span>
<span class="p_add">+	hisifd-&gt;dss_module.arsr2p_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*check arsr2p input and output width */</span>
<span class="p_add">+	if ((src_width &lt; ARSR2P_MIN_INPUT) || (dst_rect.w &lt; ARSR2P_MIN_INPUT)</span>
<span class="p_add">+	    || (src_width &gt; ARSR2P_MAX_WIDTH)</span>
<span class="p_add">+	    || (dst_rect.w &gt; ARSR2P_MAX_WIDTH)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;src_rect.w(%d) or dst_rect.w(%d) is smaller than 16 &quot;</span>
<span class="p_add">+		     &quot;or larger than 2560!\n&quot;,</span>
<span class="p_add">+		     src_width, dst_rect.w);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((dst_rect.w &gt; (src_width * ARSR2P_SCALE_MAX))</span>
<span class="p_add">+	    || (src_width &gt; (dst_rect.w * ARSR2P_SCALE_MAX))) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;width out of range, original_src_rec(%d, %d, %d, %d) &quot;</span>
<span class="p_add">+		     &quot;new_src_rect(%d, %d, %d, %d), dst_rect(%d, %d, %d, %d)\n&quot;,</span>
<span class="p_add">+		     layer-&gt;src_rect.x, layer-&gt;src_rect.y, src_width,</span>
<span class="p_add">+		     layer-&gt;src_rect.h, src_rect.x, src_rect.y, src_width,</span>
<span class="p_add">+		     src_rect.h, dst_rect.x, dst_rect.y, dst_rect.w,</span>
<span class="p_add">+		     dst_rect.h);</span>
<span class="p_add">+</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*check arsr2p input and output height */</span>
<span class="p_add">+	if ((src_rect.h &gt; ARSR2P_MAX_HEIGHT)</span>
<span class="p_add">+	    || (dst_rect.h &gt; ARSR2P_MAX_HEIGHT)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;src_rect.h(%d) or dst_rect.h(%d) is smaller than 16 &quot;</span>
<span class="p_add">+		     &quot;or larger than 8192!\n&quot;,</span>
<span class="p_add">+		     src_rect.h, dst_rect.h);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((dst_rect.h &gt; (src_rect.h * ARSR2P_SCALE_MAX))</span>
<span class="p_add">+	    || (src_rect.h &gt; (dst_rect.h * ARSR2P_SCALE_MAX))) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;height out of range, original_src_rec(%d, %d, %d, %d) &quot;</span>
<span class="p_add">+		     &quot;new_src_rect(%d, %d, %d, %d), dst_rect(%d, %d, %d, %d).\n&quot;,</span>
<span class="p_add">+		     layer-&gt;src_rect.x, layer-&gt;src_rect.y, layer-&gt;src_rect.w,</span>
<span class="p_add">+		     layer-&gt;src_rect.h, src_rect.x, src_rect.y, src_rect.w,</span>
<span class="p_add">+		     src_rect.h, dst_rect.x, dst_rect.y, dst_rect.w,</span>
<span class="p_add">+		     dst_rect.h);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*if arsr2p is enabled, hbp+hfp+hsw &gt; 20 */</span>
<span class="p_add">+	/*if (hisifd_primary &amp;&amp; (hisifd_primary-&gt;panel_info.ldi.h_back_porch + hisifd_primary-&gt;panel_info.ldi.h_front_porch</span>
<span class="p_add">+	   + hisifd_primary-&gt;panel_info.ldi.h_pulse_width) &lt;= 20) {</span>
<span class="p_add">+	   HISI_FB_ERR(&quot;ldi hbp+hfp+hsw is not larger than 20, return!\n&quot;);</span>
<span class="p_add">+	   return -EINVAL;</span>
<span class="p_add">+	   } */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*config arsr2p mode , start */</span>
<span class="p_add">+	arsr2p_bypass = false;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (hscldown_flag) {</span>
<span class="p_add">+			hscldown_enabled = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!en_hscl &amp;&amp; (iv_inc &gt;= 2 * ARSR2P_INC_FACTOR)</span>
<span class="p_add">+		    &amp;&amp; !pblock_info-&gt;h_ratio_arsr2p) {</span>
<span class="p_add">+			nearest_en = true;</span>
<span class="p_add">+			sharpen_en = false;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((!en_hscl) &amp;&amp; (!en_vscl)) {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		diintpl_en = true;</span>
<span class="p_add">+		textureanalyhsisen_en = true;</span>
<span class="p_add">+	} while(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sharpen_en) {</span>
<span class="p_add">+		skinctrl_en = true;</span>
<span class="p_add">+		shootdetect_en = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*config arsr2p mode , end */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*if sharpness 2d is needed, config the arsr2p effect */</span>
<span class="p_add">+	hisi_dss_arsr2p_effect_config(&amp;(arsr2p-&gt;arsr2p_effect));</span>
<span class="p_add">+	hisifd-&gt;dss_module.arsr2p_effect_used[chn_idx] = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	arsr2p-&gt;arsr_input_width_height =</span>
<span class="p_add">+	    set_bits32(arsr2p-&gt;arsr_input_width_height,</span>
<span class="p_add">+		       DSS_HEIGHT(src_rect.h), 13, 0);</span>
<span class="p_add">+	arsr2p-&gt;arsr_input_width_height =</span>
<span class="p_add">+	    set_bits32(arsr2p-&gt;arsr_input_width_height, DSS_WIDTH(src_width),</span>
<span class="p_add">+		       13, 16);</span>
<span class="p_add">+	arsr2p-&gt;arsr_output_width_height =</span>
<span class="p_add">+	    set_bits32(arsr2p-&gt;arsr_output_width_height,</span>
<span class="p_add">+		       DSS_HEIGHT(dst_rect.h), 13, 0);</span>
<span class="p_add">+	arsr2p-&gt;arsr_output_width_height =</span>
<span class="p_add">+	    set_bits32(arsr2p-&gt;arsr_output_width_height,</span>
<span class="p_add">+		       DSS_WIDTH(dst_rect.w), 13, 16);</span>
<span class="p_add">+	arsr2p-&gt;ihleft = set_bits32(arsr2p-&gt;ihleft, ih_left, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ihright = set_bits32(arsr2p-&gt;ihright, ih_right, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ivtop = set_bits32(arsr2p-&gt;ivtop, iv_top, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ivbottom = set_bits32(arsr2p-&gt;ivbottom, iv_bottom, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ihinc = set_bits32(arsr2p-&gt;ihinc, ih_inc, 22, 0);</span>
<span class="p_add">+	arsr2p-&gt;ivinc = set_bits32(arsr2p-&gt;ivinc, iv_inc, 22, 0);</span>
<span class="p_add">+	arsr2p-&gt;offset = set_bits32(arsr2p-&gt;offset, uv_offset, 22, 0);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, arsr2p_bypass, 1, 0);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, sharpen_en, 1, 1);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, shootdetect_en, 1, 2);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, skinctrl_en, 1, 3);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, textureanalyhsisen_en, 1, 4);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, diintpl_en, 1, 5);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, nearest_en, 1, 6);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, hscldown_enabled, 1, 7);</span>
<span class="p_add">+	arsr2p-&gt;mode = set_bits32(arsr2p-&gt;mode, imageintpl_dis, 1, 8);</span>
<span class="p_add">+</span>
<span class="p_add">+	arsr2p-&gt;ihleft1 = set_bits32(arsr2p-&gt;ihleft1, outph_left, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ihright1 = set_bits32(arsr2p-&gt;ihright1, outph_right, 29, 0);</span>
<span class="p_add">+	arsr2p-&gt;ivbottom1 = set_bits32(arsr2p-&gt;ivbottom1, outpv_bottom, 29, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ ** DSS remove mctl ch&amp;ov mutex for offline</span>
<span class="p_add">+ */</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_remove_mctl_mutex(struct hisi_fb_data_type *hisifd, int mctl_idx,</span>
<span class="p_add">+		       uint32_t cmdlist_idxs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dss_module_reg_t *dss_module = NULL;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	char __iomem *chn_mutex_base = NULL;</span>
<span class="p_add">+	char __iomem *cmdlist_base = NULL;</span>
<span class="p_add">+	uint32_t offset = 0;</span>
<span class="p_add">+	uint32_t cmdlist_idxs_temp = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(hisifd == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	dss_module = &amp;(hisifd-&gt;dss_module);</span>
<span class="p_add">+	cmdlist_base = hisifd-&gt;dss_base + DSS_CMDLIST_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; DSS_CHN_MAX_DEFINE; i++) {</span>
<span class="p_add">+		if (dss_module-&gt;mctl_ch_used[i] == 1) {</span>
<span class="p_add">+			chn_mutex_base =</span>
<span class="p_add">+			    dss_module-&gt;mctl_ch_base[i].chn_mutex_base +</span>
<span class="p_add">+			    g_dss_module_ovl_base[mctl_idx][MODULE_MCTL_BASE];</span>
<span class="p_add">+			BUG_ON(chn_mutex_base == NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+			set_reg(chn_mutex_base, 0, 32, 0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	set_reg(dss_module-&gt;mctl_base[mctl_idx] + MCTL_CTL_MUTEX_OV, 0, 32, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	offset = 0x40;</span>
<span class="p_add">+	cmdlist_idxs_temp = cmdlist_idxs;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; HISI_DSS_CMDLIST_MAX; i++) {</span>
<span class="p_add">+		if ((cmdlist_idxs_temp &amp; 0x1) == 0x1) {</span>
<span class="p_add">+			set_reg(cmdlist_base + CMDLIST_CH0_CTRL + i * offset,</span>
<span class="p_add">+				0x6, 3, 2);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		cmdlist_idxs_temp = cmdlist_idxs_temp &gt;&gt; 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void</span>
<span class="p_add">+hisi_dss_mctl_ov_set_ctl_dbg_reg(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+				 char __iomem *mctl_base, bool enable_cmdlist)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (hisifd == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisifd is null&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (enable_cmdlist) {</span>
<span class="p_add">+		set_reg(mctl_base + MCTL_CTL_DBG, 0xB03A20, 32, 0);</span>
<span class="p_add">+		set_reg(mctl_base + MCTL_CTL_TOP, 0x1, 32, 0);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		set_reg(mctl_base + MCTL_CTL_DBG, 0xB13A00, 32, 0);</span>
<span class="p_add">+		if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+			set_reg(mctl_base + MCTL_CTL_TOP, 0x2, 32, 0);</span>
<span class="p_add">+		} else if (hisifd-&gt;index == EXTERNAL_PANEL_IDX) {</span>
<span class="p_add">+			set_reg(mctl_base + MCTL_CTL_TOP, 0x3, 32, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_check_userdata(struct hisi_fb_data_type *hisifd,</span>
<span class="p_add">+			dss_overlay_t *pov_req,</span>
<span class="p_add">+			dss_overlay_block_t *pov_h_block_infos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+	dss_wb_layer_t *wb_layer = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;invalid hisifd!&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_req == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, invalid pov_req!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pov_h_block_infos == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, invalid pov_h_block_infos!&quot;, hisifd-&gt;index);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;ov_block_nums &lt;= 0) ||</span>
<span class="p_add">+	    (pov_req-&gt;ov_block_nums &gt; HISI_DSS_OV_BLOCK_NUMS)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, invalid ov_block_nums=%d!&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, pov_req-&gt;ov_block_nums);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_h_block_infos-&gt;layer_nums &lt;= 0)</span>
<span class="p_add">+	    || (pov_h_block_infos-&gt;layer_nums &gt; MAX_DSS_SRC_NUM)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, invalid layer_nums=%d!&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, pov_h_block_infos-&gt;layer_nums);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((pov_req-&gt;ovl_idx &lt; 0) || pov_req-&gt;ovl_idx &gt;= DSS_OVL_IDX_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, invalid ovl_idx=%d!&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, pov_req-&gt;ovl_idx);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == PRIMARY_PANEL_IDX) {</span>
<span class="p_add">+		if (hisifd-&gt;panel_info.dirty_region_updt_support) {</span>
<span class="p_add">+			if (pov_req-&gt;dirty_rect.x &lt; 0</span>
<span class="p_add">+			    || pov_req-&gt;dirty_rect.y &lt; 0</span>
<span class="p_add">+			    || pov_req-&gt;dirty_rect.w &lt; 0</span>
<span class="p_add">+			    || pov_req-&gt;dirty_rect.h &lt; 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;dirty_rect(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+				     pov_req-&gt;dirty_rect.x,</span>
<span class="p_add">+				     pov_req-&gt;dirty_rect.y,</span>
<span class="p_add">+				     pov_req-&gt;dirty_rect.w,</span>
<span class="p_add">+				     pov_req-&gt;dirty_rect.h);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		if (pov_req-&gt;wb_enable != 1) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;pov_req-&gt;wb_enable=%u is invalid!\n&quot;,</span>
<span class="p_add">+				    pov_req-&gt;wb_enable);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((pov_req-&gt;wb_layer_nums &lt;= 0) ||</span>
<span class="p_add">+		    (pov_req-&gt;wb_layer_nums &gt; MAX_DSS_DST_NUM)) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, invalid wb_layer_nums=%d!&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, pov_req-&gt;wb_layer_nums);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;wb_ov_rect.x &lt; 0 || pov_req-&gt;wb_ov_rect.y &lt; 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;wb_ov_rect(%d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+				    pov_req-&gt;wb_ov_rect.x,</span>
<span class="p_add">+				    pov_req-&gt;wb_ov_rect.y);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pov_req-&gt;wb_compose_type &gt;= DSS_WB_COMPOSE_TYPE_MAX) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;wb_compose_type=%u is invalid!\n&quot;,</span>
<span class="p_add">+				    pov_req-&gt;wb_compose_type);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; pov_req-&gt;wb_layer_nums; i++) {</span>
<span class="p_add">+			wb_layer = &amp;(pov_req-&gt;wb_layer_infos[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;chn_idx != DSS_WCHN_W2) {</span>
<span class="p_add">+				if (wb_layer-&gt;chn_idx &lt; DSS_WCHN_W0</span>
<span class="p_add">+				    || wb_layer-&gt;chn_idx &gt; DSS_WCHN_W1) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, wchn_idx=%d is invalid!&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index, wb_layer-&gt;chn_idx);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;dst.format &gt;= HISI_FB_PIXEL_FORMAT_MAX) {</span>
<span class="p_add">+				HISI_FB_ERR(&quot;fb%d, format=%d is invalid!&quot;,</span>
<span class="p_add">+					    hisifd-&gt;index,</span>
<span class="p_add">+					    wb_layer-&gt;dst.format);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((wb_layer-&gt;dst.bpp == 0)</span>
<span class="p_add">+			    || (wb_layer-&gt;dst.width == 0)</span>
<span class="p_add">+			    || (wb_layer-&gt;dst.height == 0)</span>
<span class="p_add">+			    || (wb_layer-&gt;dst.stride == 0)) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, bpp=%d, width=%d, height=%d, stride=%d is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index, wb_layer-&gt;dst.bpp,</span>
<span class="p_add">+				     wb_layer-&gt;dst.width, wb_layer-&gt;dst.height,</span>
<span class="p_add">+				     wb_layer-&gt;dst.stride);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+			if (wb_layer-&gt;dst.mmu_enable) {</span>
<span class="p_add">+				if (wb_layer-&gt;dst.buf_size == 0) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, buf_size=%d is invalid!&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index,</span>
<span class="p_add">+					     wb_layer-&gt;dst.buf_size);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (isYUVSemiPlanar(wb_layer-&gt;dst.format)</span>
<span class="p_add">+			    || isYUVPlanar(wb_layer-&gt;dst.format)) {</span>
<span class="p_add">+				if ((wb_layer-&gt;dst.stride_plane1 == 0)</span>
<span class="p_add">+				    || (wb_layer-&gt;dst.offset_plane1 == 0)) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, stride_plane1=%d, offset_plane1=%d is invalid!&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index,</span>
<span class="p_add">+					     wb_layer-&gt;dst.stride_plane1,</span>
<span class="p_add">+					     wb_layer-&gt;dst.offset_plane1);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (isYUVPlanar(wb_layer-&gt;dst.format)) {</span>
<span class="p_add">+				if ((wb_layer-&gt;dst.stride_plane2 == 0)</span>
<span class="p_add">+				    || (wb_layer-&gt;dst.offset_plane2 == 0)) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, stride_plane2=%d, offset_plane2=%d is invalid!&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index,</span>
<span class="p_add">+					     wb_layer-&gt;dst.stride_plane2,</span>
<span class="p_add">+					     wb_layer-&gt;dst.offset_plane2);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;need_cap &amp; CAP_AFBCE) {</span>
<span class="p_add">+				if ((wb_layer-&gt;dst.afbc_header_stride == 0)</span>
<span class="p_add">+				    || (wb_layer-&gt;dst.afbc_payload_stride == 0)) {</span>
<span class="p_add">+					HISI_FB_ERR</span>
<span class="p_add">+					    (&quot;fb%d, afbc_header_stride=%d, afbc_payload_stride=%d is invalid!&quot;,</span>
<span class="p_add">+					     hisifd-&gt;index,</span>
<span class="p_add">+					     wb_layer-&gt;dst.afbc_header_stride,</span>
<span class="p_add">+					     wb_layer-&gt;dst.afbc_payload_stride);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;dst.csc_mode &gt;= DSS_CSC_MOD_MAX) {</span>
<span class="p_add">+				HISI_FB_ERR(&quot;fb%d, csc_mode=%d is invalid!&quot;,</span>
<span class="p_add">+					    hisifd-&gt;index,</span>
<span class="p_add">+					    wb_layer-&gt;dst.csc_mode);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;dst.afbc_scramble_mode &gt;=</span>
<span class="p_add">+			    DSS_AFBC_SCRAMBLE_MODE_MAX) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;fb%d, afbc_scramble_mode=%d is invalid!&quot;,</span>
<span class="p_add">+				     hisifd-&gt;index,</span>
<span class="p_add">+				     wb_layer-&gt;dst.afbc_scramble_mode);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;src_rect.x &lt; 0 || wb_layer-&gt;src_rect.y &lt; 0</span>
<span class="p_add">+			    || wb_layer-&gt;src_rect.w &lt;= 0</span>
<span class="p_add">+			    || wb_layer-&gt;src_rect.h &lt;= 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;src_rect(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+				     wb_layer-&gt;src_rect.x, wb_layer-&gt;src_rect.y,</span>
<span class="p_add">+				     wb_layer-&gt;src_rect.w,</span>
<span class="p_add">+				     wb_layer-&gt;src_rect.h);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (wb_layer-&gt;dst_rect.x &lt; 0 || wb_layer-&gt;dst_rect.y &lt; 0</span>
<span class="p_add">+			    || wb_layer-&gt;dst_rect.w &lt;= 0</span>
<span class="p_add">+			    || wb_layer-&gt;dst_rect.h &lt;= 0) {</span>
<span class="p_add">+				HISI_FB_ERR</span>
<span class="p_add">+				    (&quot;dst_rect(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+				     wb_layer-&gt;dst_rect.x, wb_layer-&gt;dst_rect.y,</span>
<span class="p_add">+				     wb_layer-&gt;dst_rect.w,</span>
<span class="p_add">+				     wb_layer-&gt;dst_rect.h);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
<span class="p_add">+hisi_dss_check_layer_par(struct hisi_fb_data_type *hisifd, dss_layer_t *layer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (hisifd == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;hisifd is NULL, return!&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer == NULL) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;layer is NULL, return!&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;layer_idx &lt; 0 || layer-&gt;layer_idx &gt;= MAX_DSS_SRC_NUM) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, layer_idx=%d is invalid!&quot;, hisifd-&gt;index,</span>
<span class="p_add">+			    layer-&gt;layer_idx);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; (CAP_BASE | CAP_DIM | CAP_PURE_COLOR))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hisifd-&gt;index == AUXILIARY_PANEL_IDX) {</span>
<span class="p_add">+		if (layer-&gt;chn_idx != DSS_RCHN_V2) {</span>
<span class="p_add">+			if (layer-&gt;chn_idx &lt; 0 || layer-&gt;chn_idx &gt;= DSS_WCHN_W0) {</span>
<span class="p_add">+				HISI_FB_ERR(&quot;fb%d, rchn_idx=%d is invalid!&quot;,</span>
<span class="p_add">+					    hisifd-&gt;index, layer-&gt;chn_idx);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (layer-&gt;chn_idx == DSS_RCHN_D2) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, chn_idx[%d] does not used by offline play!&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, layer-&gt;chn_idx);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (layer-&gt;chn_idx &lt; 0 || layer-&gt;chn_idx &gt;= DSS_WCHN_W0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, rchn_idx=%d is invalid!&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, layer-&gt;chn_idx);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;blending &lt; 0 || layer-&gt;blending &gt;= HISI_FB_BLENDING_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, blending=%d is invalid!&quot;, hisifd-&gt;index,</span>
<span class="p_add">+			    layer-&gt;blending);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;img.format &gt;= HISI_FB_PIXEL_FORMAT_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, format=%d is invalid!&quot;, hisifd-&gt;index,</span>
<span class="p_add">+			    layer-&gt;img.format);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((layer-&gt;img.bpp == 0) || (layer-&gt;img.width == 0)</span>
<span class="p_add">+	    || (layer-&gt;img.height == 0) || (layer-&gt;img.stride == 0)) {</span>
<span class="p_add">+		HISI_FB_ERR</span>
<span class="p_add">+		    (&quot;fb%d, bpp=%d, width=%d, height=%d, stride=%d is invalid!&quot;,</span>
<span class="p_add">+		     hisifd-&gt;index, layer-&gt;img.bpp, layer-&gt;img.width,</span>
<span class="p_add">+		     layer-&gt;img.height, layer-&gt;img.stride);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+	if (layer-&gt;img.mmu_enable) {</span>
<span class="p_add">+		if (layer-&gt;img.buf_size == 0) {</span>
<span class="p_add">+			HISI_FB_ERR(&quot;fb%d, buf_size=%d is invalid!&quot;,</span>
<span class="p_add">+				    hisifd-&gt;index, layer-&gt;img.buf_size);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (isYUVSemiPlanar(layer-&gt;img.format)</span>
<span class="p_add">+	    || isYUVPlanar(layer-&gt;img.format)) {</span>
<span class="p_add">+		if ((layer-&gt;img.stride_plane1 == 0)</span>
<span class="p_add">+		    || (layer-&gt;img.offset_plane1 == 0)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, stride_plane1=%d, offset_plane1=%d is invalid!&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, layer-&gt;img.stride_plane1,</span>
<span class="p_add">+			     layer-&gt;img.offset_plane1);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (isYUVPlanar(layer-&gt;img.format)) {</span>
<span class="p_add">+		if ((layer-&gt;img.stride_plane2 == 0)</span>
<span class="p_add">+		    || (layer-&gt;img.offset_plane2 == 0)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, stride_plane2=%d, offset_plane2=%d is invalid!&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, layer-&gt;img.stride_plane2,</span>
<span class="p_add">+			     layer-&gt;img.offset_plane2);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;need_cap &amp; CAP_AFBCD) {</span>
<span class="p_add">+		if ((layer-&gt;img.afbc_header_stride == 0)</span>
<span class="p_add">+		    || (layer-&gt;img.afbc_payload_stride == 0)</span>
<span class="p_add">+		    || (layer-&gt;img.mmbuf_size == 0)) {</span>
<span class="p_add">+			HISI_FB_ERR</span>
<span class="p_add">+			    (&quot;fb%d, afbc_header_stride=%d, afbc_payload_stride=%d, &quot;</span>
<span class="p_add">+			     &quot;mmbuf_size=%d is invalid!&quot;,</span>
<span class="p_add">+			     hisifd-&gt;index, layer-&gt;img.afbc_header_stride,</span>
<span class="p_add">+			     layer-&gt;img.afbc_payload_stride,</span>
<span class="p_add">+			     layer-&gt;img.mmbuf_size);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;img.csc_mode &gt;= DSS_CSC_MOD_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, csc_mode=%d is invalid!&quot;, hisifd-&gt;index,</span>
<span class="p_add">+			    layer-&gt;img.csc_mode);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;img.afbc_scramble_mode &gt;= DSS_AFBC_SCRAMBLE_MODE_MAX) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, afbc_scramble_mode=%d is invalid!&quot;,</span>
<span class="p_add">+			    hisifd-&gt;index, layer-&gt;img.afbc_scramble_mode);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((layer-&gt;layer_idx != 0) &amp;&amp; (layer-&gt;need_cap &amp; CAP_BASE)) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;fb%d, layer%d is not base!&quot;, hisifd-&gt;index,</span>
<span class="p_add">+			    layer-&gt;layer_idx);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;src_rect.x &lt; 0 || layer-&gt;src_rect.y &lt; 0 ||</span>
<span class="p_add">+	    layer-&gt;src_rect.w &lt;= 0 || layer-&gt;src_rect.h &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;src_rect(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+			    layer-&gt;src_rect.x, layer-&gt;src_rect.y,</span>
<span class="p_add">+			    layer-&gt;src_rect.w, layer-&gt;src_rect.h);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;src_rect_mask.x &lt; 0 || layer-&gt;src_rect_mask.y &lt; 0 ||</span>
<span class="p_add">+	    layer-&gt;src_rect_mask.w &lt; 0 || layer-&gt;src_rect_mask.h &lt; 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;src_rect_mask(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+			    layer-&gt;src_rect_mask.x, layer-&gt;src_rect_mask.y,</span>
<span class="p_add">+			    layer-&gt;src_rect_mask.w, layer-&gt;src_rect_mask.h);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (layer-&gt;dst_rect.x &lt; 0 || layer-&gt;dst_rect.y &lt; 0 ||</span>
<span class="p_add">+	    layer-&gt;dst_rect.w &lt;= 0 || layer-&gt;dst_rect.h &lt;= 0) {</span>
<span class="p_add">+		HISI_FB_ERR(&quot;dst_rect(%d, %d, %d, %d) is out of range!\n&quot;,</span>
<span class="p_add">+			    layer-&gt;dst_rect.x, layer-&gt;dst_rect.y,</span>
<span class="p_add">+			    layer-&gt;dst_rect.w, layer-&gt;dst_rect.h);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void hisifb_disreset_dss(struct hisi_fb_data_type *hisifd)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.h b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.h</span>
new file mode 100755
<span class="p_header">index 000000000000..1d5b1fc0cc92</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/video/fbdev/hisi/dss/hisi_overlay_utils_hi3660.h</span>
<span class="p_chunk">@@ -0,0 +1,73 @@</span> <span class="p_context"></span>
<span class="p_add">+/* Copyright (c) 2013-2014, Hisilicon Tech. Co., Ltd. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 and</span>
<span class="p_add">+ * only version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef _HISI_OVERLAY_UTILS_PLATFORM_H_</span>
<span class="p_add">+#define _HISI_OVERLAY_UTILS_PLATFORM_H_</span>
<span class="p_add">+</span>
<span class="p_add">+#define HISI_DSS_VERSION_V400</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPIO_LCD_POWER_1V2  (54)</span>
<span class="p_add">+#define GPIO_LCD_STANDBY    (67)</span>
<span class="p_add">+#define GPIO_LCD_RESETN     (65)</span>
<span class="p_add">+#define GPIO_LCD_GATING     (60)</span>
<span class="p_add">+#define GPIO_LCD_PCLK_GATING (58)</span>
<span class="p_add">+#define GPIO_LCD_REFCLK_GATING (59)</span>
<span class="p_add">+#define GPIO_LCD_SPICS         (168)</span>
<span class="p_add">+#define GPIO_LCD_DRV_EN        (73)</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPIO_PG_SEL_A (72)</span>
<span class="p_add">+#define GPIO_TX_RX_A (74)</span>
<span class="p_add">+#define GPIO_PG_SEL_B (76)</span>
<span class="p_add">+#define GPIO_TX_RX_B (78)</span>
<span class="p_add">+</span>
<span class="p_add">+/*******************************************************************************</span>
<span class="p_add">+ **</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CRGPERI_PLL0_CLK_RATE	(1600000000UL)</span>
<span class="p_add">+#define CRGPERI_PLL2_CLK_RATE	(960000000UL)</span>
<span class="p_add">+#define CRGPERI_PLL3_CLK_RATE	(1600000000UL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DEFAULT_DSS_CORE_CLK_08V_RATE	(535000000UL)</span>
<span class="p_add">+#define DEFAULT_DSS_CORE_CLK_07V_RATE	(400000000UL)</span>
<span class="p_add">+#define DEFAULT_PCLK_DSS_RATE	(114000000UL)</span>
<span class="p_add">+#define DEFAULT_PCLK_PCTRL_RATE	(80000000UL)</span>
<span class="p_add">+#define DSS_MAX_PXL0_CLK_288M (288000000UL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MMBUF_SIZE_MAX	(288 * 1024)</span>
<span class="p_add">+#define HISI_DSS_CMDLIST_MAX	(16)</span>
<span class="p_add">+#define HISI_DSS_CMDLIST_IDXS_MAX (0xFFFF)</span>
<span class="p_add">+#define HISI_DSS_COPYBIT_CMDLIST_IDXS	 (0xC000)</span>
<span class="p_add">+#define HISI_DSS_DPP_MAX_SUPPORT_BIT (0x7ff)</span>
<span class="p_add">+#define HISIFB_DSS_PLATFORM_TYPE  (FB_ACCEL_HI366x | FB_ACCEL_PLATFORM_TYPE_ASIC)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DSS_MIF_SMMU_SMRX_IDX_STEP (16)</span>
<span class="p_add">+#define CRG_PERI_DIS3_DEFAULT_VAL     (0x0002F000)</span>
<span class="p_add">+#define SCF_LINE_BUF	(2560)</span>
<span class="p_add">+#define DSS_GLB_MODULE_CLK_SEL_DEFAULT_VAL  (0xF0000008)</span>
<span class="p_add">+#define DSS_LDI_CLK_SEL_DEFAULT_VAL    (0x00000004)</span>
<span class="p_add">+#define DSS_DBUF_MEM_CTRL_DEFAULT_VAL  (0x00000008)</span>
<span class="p_add">+#define DSS_SMMU_RLD_EN0_DEFAULT_VAL    (0xffffffff)</span>
<span class="p_add">+#define DSS_SMMU_RLD_EN1_DEFAULT_VAL    (0xffffff8f)</span>
<span class="p_add">+#define DSS_SMMU_OUTSTANDING_VAL		(0xf)</span>
<span class="p_add">+#define DSS_MIF_CTRL2_INVAL_SEL3_STRIDE_MASK		(0xc)</span>
<span class="p_add">+#define DSS_AFBCE_ENC_OS_CFG_DEFAULT_VAL			(0x7)</span>
<span class="p_add">+#define TUI_SEC_RCH			(DSS_RCHN_V0)</span>
<span class="p_add">+#define DSS_CHN_MAX_DEFINE (DSS_COPYBIT_MAX)</span>
<span class="p_add">+</span>
<span class="p_add">+/* perf stat */</span>
<span class="p_add">+#define DSS_DEVMEM_PERF_BASE						(0xFDF10000)</span>
<span class="p_add">+#define CRG_PERIPH_APB_PERRSTSTAT0_REG 				(0x68)</span>
<span class="p_add">+#define CRG_PERIPH_APB_IP_RST_PERF_STAT_BIT 		(18)</span>
<span class="p_add">+#define PERF_SAMPSTOP_REG 							(0x10)</span>
<span class="p_add">+#define DEVMEM_PERF_SIZE							(0x100)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



