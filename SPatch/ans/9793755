
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[5/5] soc bcm: brcmstb: Add support for S2/S3/S5 suspend states (MIPS) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [5/5] soc bcm: brcmstb: Add support for S2/S3/S5 suspend states (MIPS)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=4640">Florian Fainelli</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 16, 2017, 9:37 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170616213703.21487-6-f.fainelli@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9793755/mbox/"
   >mbox</a>
|
   <a href="/patch/9793755/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9793755/">/patch/9793755/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4B67960231 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 21:38:09 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3B10628683
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 21:38:09 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2FCD0286A8; Fri, 16 Jun 2017 21:38:09 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DB2CB286A1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 16 Jun 2017 21:38:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752566AbdFPVh5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 16 Jun 2017 17:37:57 -0400
Received: from mail-wr0-f193.google.com ([209.85.128.193]:32976 &quot;EHLO
	mail-wr0-f193.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752452AbdFPVhy (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 16 Jun 2017 17:37:54 -0400
Received: by mail-wr0-f193.google.com with SMTP id x23so7704706wrb.0;
	Fri, 16 Jun 2017 14:37:48 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=OEe49S3mB0SjDTi4o2cvsaml3dUmI2dn+leCXcD8XsE=;
	b=MZolEphhZw+gV2KsIzg6umrSN9QlN72dj9RQ1+vNZPLglD/2YKoqkF/9Tcm5wNbBSR
	tO3i/UuKvBCmlSPEFdsVg2keyshn13EWbvQ6DlN1Y2/2E+LhTGYQ7ltny1u2REKL+D/y
	TwyWgIzm9rmYeoUE0q3l/A1BjWE8ZCu6/Dj+7THCEL33b6I+Qfty5jmk1jOo8PZZWe/K
	Dd3xC6hYdJHFzji4K1xOTOkfLMmouYL12H751w6seSyMvSyJQBaQzjDBwfRt5BTbBA7K
	OI17d+3nxkJSvcPVqMnPp2X3FsyOmBQ03wyy70hNt4APT6cfGa/afxB6mQLfrbOc1Kd3
	DRWQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=OEe49S3mB0SjDTi4o2cvsaml3dUmI2dn+leCXcD8XsE=;
	b=iwORVUePGd/1I8Uz/X4dR2HVRhYEsrBKg2UyPsd5X7IPpFyMskYASapf3jj3kruN1D
	qmOZg+PZENwDXM9D6QSJFNx2Z8xGXo3JA3fNClsolZOX6hwqFMoY0YzvVoos7hgYgpe+
	PvgU9ryL4ovng3gchaz3QU69WwhgkNN6Ln7q9G+jRG/bMzTZyQK8DgT5Ohm9CadZ93sJ
	eiEfL0iBoiG5BoHzq/46e6u0cFXnbZk0r0yILqn34aM8iLQ/Su98P13CQ9zLiJ3sxpAR
	U+8paQhgFJcfhYJKxs3YQMunjO6rRqlwsgnFhYmVXkp4grRP3Vw/tcSesVoVoy9YMeqU
	IJkg==
X-Gm-Message-State: AKS2vOw8nMvuJWjqCSXpvIxlz0XbzWir4kM4jyyYN8YrNjkmhDarRzlW
	7X4nw1w5daSOpIk3tgk=
X-Received: by 10.223.143.77 with SMTP id p71mr7482946wrb.3.1497649061801;
	Fri, 16 Jun 2017 14:37:41 -0700 (PDT)
Received: from fainelli-desktop.broadcom.com ([192.19.255.250])
	by smtp.gmail.com with ESMTPSA id
	w17sm2576546wra.34.2017.06.16.14.37.37
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Fri, 16 Jun 2017 14:37:41 -0700 (PDT)
From: Florian Fainelli &lt;f.fainelli@gmail.com&gt;
To: linux-arm-kernel@vger.kernel.org
Cc: Justin Chen &lt;justinpopo6@gmail.com&gt;,
	Florian Fainelli &lt;f.fainelli@gmail.com&gt;,
	Rob Herring &lt;robh+dt@kernel.org&gt;, Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Brian Norris &lt;computersforpeace@gmail.com&gt;,
	Gregory Fong &lt;gregory.0xf0@gmail.com&gt;,
	bcm-kernel-feedback-list@broadcom.com (maintainer:BROADCOM BCM7XXX ARM
	ARCHITECTURE), Hauke Mehrtens &lt;hauke@hauke-m.de&gt;,
	=?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= &lt;zajec5@gmail.com&gt;,
	Ralf Baechle &lt;ralf@linux-mips.org&gt;, Markus Mayer &lt;mmayer@broadcom.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;, Eric Anholt &lt;eric@anholt.net&gt;,
	Doug Berger &lt;opendmb@gmail.com&gt;,
	devicetree@vger.kernel.org (open list:OPEN FIRMWARE AND FLATTENED
	DEVICE TREE BINDINGS),
	linux-arm-kernel@lists.infradead.org (moderated list:BROADCOM BCM7XXX
	ARM ARCHITECTURE), linux-kernel@vger.kernel.org (open list),
	linux-mips@linux-mips.org (open list:BROADCOM BCM47XX MIPS
	ARCHITECTURE), 
	linux-pm@vger.kernerl.org, &quot;Rafael J. Wysocki&quot; &lt;rjw@rjwysocki.net&gt;
Subject: [PATCH 5/5] soc bcm: brcmstb: Add support for S2/S3/S5 suspend
	states (MIPS)
Date: Fri, 16 Jun 2017 14:37:03 -0700
Message-Id: &lt;20170616213703.21487-6-f.fainelli@gmail.com&gt;
X-Mailer: git-send-email 2.9.3
In-Reply-To: &lt;20170616213703.21487-1-f.fainelli@gmail.com&gt;
References: &lt;20170616213703.21487-1-f.fainelli@gmail.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=4640">Florian Fainelli</a> - June 16, 2017, 9:37 p.m.</div>
<pre class="content">
<span class="from">From: Justin Chen &lt;justinpopo6@gmail.com&gt;</span>

This commit adds support for the Broadcom STB S2/S3/S5 suspend
states on MIPS based SoCs.

This requires quite a lot of code in order to deal with the
different HW blocks that need to be quiesced during suspend:

- DDR PHY
- DDR memory controller and arbiter
- control processor

The final steps of the suspend execute in cache and there is is a little
bit of assembly code in order to shut down the DDR PHY PLL and then go
into a wait loop until a wake-up even occurs. Conversely the resume part
involves waiting for the DDR PHY PLL to come back up and resume
executions where we left.
<span class="signed-off-by">
Signed-off-by: Justin Chen &lt;justinpopo6@gmail.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Florian Fainelli &lt;f.fainelli@gmail.com&gt;</span>
---
 drivers/soc/bcm/brcmstb/Kconfig      |   2 +-
 drivers/soc/bcm/brcmstb/pm/Makefile  |   1 +
 drivers/soc/bcm/brcmstb/pm/pm-mips.c | 461 +++++++++++++++++++++++++++++++++++
 drivers/soc/bcm/brcmstb/pm/pm.h      |  13 +-
 drivers/soc/bcm/brcmstb/pm/s2-mips.S | 200 +++++++++++++++
 drivers/soc/bcm/brcmstb/pm/s3-mips.S | 146 +++++++++++
 6 files changed, 821 insertions(+), 2 deletions(-)
 create mode 100644 drivers/soc/bcm/brcmstb/pm/pm-mips.c
 create mode 100644 drivers/soc/bcm/brcmstb/pm/s2-mips.S
 create mode 100644 drivers/soc/bcm/brcmstb/pm/s3-mips.S
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/Kconfig b/drivers/soc/bcm/brcmstb/Kconfig</span>
<span class="p_header">index 246fc0f30515..7ab04f10dbe7 100644</span>
<span class="p_header">--- a/drivers/soc/bcm/brcmstb/Kconfig</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/Kconfig</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"> if SOC_BRCMSTB</span>
 config BRCMSTB_PM
         bool &quot;Support suspend/resume for STB platforms&quot;
         default y
<span class="p_del">-	depends on ARM</span>
<span class="p_add">+	depends on ARM || BMIPS_GENERIC</span>
         depends on PM
 
 endif # SOC_BRCMSTB
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/pm/Makefile b/drivers/soc/bcm/brcmstb/pm/Makefile</span>
<span class="p_header">index 66a4f7e43ad5..d524ce9644ba 100644</span>
<span class="p_header">--- a/drivers/soc/bcm/brcmstb/pm/Makefile</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/pm/Makefile</span>
<span class="p_chunk">@@ -1 +1,2 @@</span> <span class="p_context"></span>
 obj-$(CONFIG_ARM)		+= s2-arm.o pm-arm.o
<span class="p_add">+obj-$(CONFIG_BMIPS_GENERIC)	+= s2-mips.o s3-mips.o pm-mips.o</span>
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/pm/pm-mips.c b/drivers/soc/bcm/brcmstb/pm/pm-mips.c</span>
new file mode 100644
<span class="p_header">index 000000000000..5037b2dc6be9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/pm/pm-mips.c</span>
<span class="p_chunk">@@ -0,0 +1,461 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MIPS-specific support for Broadcom STB S2/S3/S5 power management</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016-2017 Broadcom</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/printk.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/bmips.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;pm.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define S2_NUM_PARAMS		6</span>
<span class="p_add">+#define MAX_NUM_MEMC		3</span>
<span class="p_add">+</span>
<span class="p_add">+/* S3 constants */</span>
<span class="p_add">+#define MAX_GP_REGS		16</span>
<span class="p_add">+#define MAX_CP0_REGS		32</span>
<span class="p_add">+#define NUM_MEMC_CLIENTS	128</span>
<span class="p_add">+#define AON_CTRL_RAM_SIZE	128</span>
<span class="p_add">+#define BRCMSTB_S3_MAGIC	0x5AFEB007</span>
<span class="p_add">+</span>
<span class="p_add">+#define CLEAR_RESET_MASK	0x01</span>
<span class="p_add">+</span>
<span class="p_add">+/* Index each CP0 register that needs to be saved */</span>
<span class="p_add">+#define CONTEXT		0</span>
<span class="p_add">+#define USER_LOCAL	1</span>
<span class="p_add">+#define PGMK		2</span>
<span class="p_add">+#define HWRENA		3</span>
<span class="p_add">+#define COMPARE		4</span>
<span class="p_add">+#define STATUS		5</span>
<span class="p_add">+#define CONFIG		6</span>
<span class="p_add">+#define MODE		7</span>
<span class="p_add">+#define EDSP		8</span>
<span class="p_add">+#define BOOT_VEC	9</span>
<span class="p_add">+#define EBASE		10</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcmstb_memc {</span>
<span class="p_add">+	void __iomem *ddr_phy_base;</span>
<span class="p_add">+	void __iomem *arb_base;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcmstb_pm_control {</span>
<span class="p_add">+	void __iomem *aon_ctrl_base;</span>
<span class="p_add">+	void __iomem *aon_sram_base;</span>
<span class="p_add">+	void __iomem *timers_base;</span>
<span class="p_add">+	struct brcmstb_memc memcs[MAX_NUM_MEMC];</span>
<span class="p_add">+	int num_memc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcm_pm_s3_context {</span>
<span class="p_add">+	u32			cp0_regs[MAX_CP0_REGS];</span>
<span class="p_add">+	u32			memc0_rts[NUM_MEMC_CLIENTS];</span>
<span class="p_add">+	u32			sc_boot_vec;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcmstb_mem_transfer;</span>
<span class="p_add">+</span>
<span class="p_add">+struct brcmstb_mem_transfer {</span>
<span class="p_add">+	struct brcmstb_mem_transfer	*next;</span>
<span class="p_add">+	void				*src;</span>
<span class="p_add">+	void				*dst;</span>
<span class="p_add">+	dma_addr_t			pa_src;</span>
<span class="p_add">+	dma_addr_t			pa_dst;</span>
<span class="p_add">+	u32				len;</span>
<span class="p_add">+	u8				key;</span>
<span class="p_add">+	u8				mode;</span>
<span class="p_add">+	u8				src_remapped;</span>
<span class="p_add">+	u8				dst_remapped;</span>
<span class="p_add">+	u8				src_dst_remapped;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define AON_SAVE_SRAM(base, idx, val) \</span>
<span class="p_add">+	__raw_writel(val, base + (idx &lt;&lt; 2))</span>
<span class="p_add">+</span>
<span class="p_add">+/* Used for saving registers in asm */</span>
<span class="p_add">+u32 gp_regs[MAX_GP_REGS];</span>
<span class="p_add">+</span>
<span class="p_add">+#define	BSP_CLOCK_STOP		0x00</span>
<span class="p_add">+#define PM_INITIATE		0x01</span>
<span class="p_add">+</span>
<span class="p_add">+static struct brcmstb_pm_control ctrl;</span>
<span class="p_add">+</span>
<span class="p_add">+static void brcm_pm_save_cp0_context(struct brcm_pm_s3_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Generic MIPS */</span>
<span class="p_add">+	ctx-&gt;cp0_regs[CONTEXT] = read_c0_context();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[USER_LOCAL] = read_c0_userlocal();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[PGMK] = read_c0_pagemask();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[HWRENA] = read_c0_cache();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[COMPARE] = read_c0_compare();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[STATUS] = read_c0_status();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Broadcom specific */</span>
<span class="p_add">+	ctx-&gt;cp0_regs[CONFIG] = read_c0_brcm_config();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[MODE] = read_c0_brcm_mode();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[EDSP] = read_c0_brcm_edsp();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[BOOT_VEC] = read_c0_brcm_bootvec();</span>
<span class="p_add">+	ctx-&gt;cp0_regs[EBASE] = read_c0_ebase();</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx-&gt;sc_boot_vec = bmips_read_zscm_reg(0xa0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void brcm_pm_restore_cp0_context(struct brcm_pm_s3_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Restore cp0 state */</span>
<span class="p_add">+	bmips_write_zscm_reg(0xa0, ctx-&gt;sc_boot_vec);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Generic MIPS */</span>
<span class="p_add">+	write_c0_context(ctx-&gt;cp0_regs[CONTEXT]);</span>
<span class="p_add">+	write_c0_userlocal(ctx-&gt;cp0_regs[USER_LOCAL]);</span>
<span class="p_add">+	write_c0_pagemask(ctx-&gt;cp0_regs[PGMK]);</span>
<span class="p_add">+	write_c0_cache(ctx-&gt;cp0_regs[HWRENA]);</span>
<span class="p_add">+	write_c0_compare(ctx-&gt;cp0_regs[COMPARE]);</span>
<span class="p_add">+	write_c0_status(ctx-&gt;cp0_regs[STATUS]);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Broadcom specific */</span>
<span class="p_add">+	write_c0_brcm_config(ctx-&gt;cp0_regs[CONFIG]);</span>
<span class="p_add">+	write_c0_brcm_mode(ctx-&gt;cp0_regs[MODE]);</span>
<span class="p_add">+	write_c0_brcm_edsp(ctx-&gt;cp0_regs[EDSP]);</span>
<span class="p_add">+	write_c0_brcm_bootvec(ctx-&gt;cp0_regs[BOOT_VEC]);</span>
<span class="p_add">+	write_c0_ebase(ctx-&gt;cp0_regs[EBASE]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void  brcmstb_pm_handshake(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *base = ctrl.aon_ctrl_base;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* BSP power handshake, v1 */</span>
<span class="p_add">+	tmp = __raw_readl(base + AON_CTRL_HOST_MISC_CMDS);</span>
<span class="p_add">+	tmp &amp;= ~1UL;</span>
<span class="p_add">+	__raw_writel(tmp, base + AON_CTRL_HOST_MISC_CMDS);</span>
<span class="p_add">+	(void)__raw_readl(base + AON_CTRL_HOST_MISC_CMDS);</span>
<span class="p_add">+</span>
<span class="p_add">+	__raw_writel(0, base + AON_CTRL_PM_INITIATE);</span>
<span class="p_add">+	(void)__raw_readl(base + AON_CTRL_PM_INITIATE);</span>
<span class="p_add">+	__raw_writel(BSP_CLOCK_STOP | PM_INITIATE,</span>
<span class="p_add">+		     base + AON_CTRL_PM_INITIATE);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * HACK: BSP may have internal race on the CLOCK_STOP command.</span>
<span class="p_add">+	 * Avoid touching the BSP for a few milliseconds.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mdelay(3);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void brcmstb_pm_s5(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *base = ctrl.aon_ctrl_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	brcmstb_pm_handshake();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear magic s3 warm-boot value */</span>
<span class="p_add">+	AON_SAVE_SRAM(ctrl.aon_sram_base, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the countdown */</span>
<span class="p_add">+	__raw_writel(0x10, base + AON_CTRL_PM_CPU_WAIT_COUNT);</span>
<span class="p_add">+	(void)__raw_readl(base + AON_CTRL_PM_CPU_WAIT_COUNT);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prepare to S5 cold boot */</span>
<span class="p_add">+	__raw_writel(PM_COLD_CONFIG, base + AON_CTRL_PM_CTRL);</span>
<span class="p_add">+	(void)__raw_readl(base + AON_CTRL_PM_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	__raw_writel((PM_COLD_CONFIG | PM_PWR_DOWN), base +</span>
<span class="p_add">+		      AON_CTRL_PM_CTRL);</span>
<span class="p_add">+	(void)__raw_readl(base + AON_CTRL_PM_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ __volatile__(</span>
<span class="p_add">+	&quot;	wait\n&quot;</span>
<span class="p_add">+	: : : &quot;memory&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_s3(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct brcm_pm_s3_context s3_context;</span>
<span class="p_add">+	void __iomem *memc_arb_base;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prepare for s3 */</span>
<span class="p_add">+	AON_SAVE_SRAM(ctrl.aon_sram_base, 0, BRCMSTB_S3_MAGIC);</span>
<span class="p_add">+	AON_SAVE_SRAM(ctrl.aon_sram_base, 1, (u32)&amp;s3_reentry);</span>
<span class="p_add">+	AON_SAVE_SRAM(ctrl.aon_sram_base, 2, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear RESET_HISTORY */</span>
<span class="p_add">+	tmp = __raw_readl(ctrl.aon_ctrl_base + AON_CTRL_RESET_CTRL);</span>
<span class="p_add">+	tmp &amp;= ~CLEAR_RESET_MASK;</span>
<span class="p_add">+	__raw_writel(tmp, ctrl.aon_ctrl_base + AON_CTRL_RESET_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Inhibit DDR_RSTb pulse for both MMCs*/</span>
<span class="p_add">+	for (i = 0; i &lt; ctrl.num_memc; i++) {</span>
<span class="p_add">+		tmp = __raw_readl(ctrl.memcs[i].ddr_phy_base +</span>
<span class="p_add">+			DDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp &amp;= ~0x0f;</span>
<span class="p_add">+		__raw_writel(tmp, ctrl.memcs[i].ddr_phy_base +</span>
<span class="p_add">+			DDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);</span>
<span class="p_add">+		tmp |= (0x05 | BIT(5));</span>
<span class="p_add">+		__raw_writel(tmp, ctrl.memcs[i].ddr_phy_base +</span>
<span class="p_add">+			DDR40_PHY_CONTROL_REGS_0_STANDBY_CTRL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save CP0 context */</span>
<span class="p_add">+	brcm_pm_save_cp0_context(&amp;s3_context);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save RTS(skip debug register) */</span>
<span class="p_add">+	memc_arb_base = ctrl.memcs[0].arb_base + 4;</span>
<span class="p_add">+	for (i = 0; i &lt; NUM_MEMC_CLIENTS; i++) {</span>
<span class="p_add">+		s3_context.memc0_rts[i] = __raw_readl(memc_arb_base);</span>
<span class="p_add">+		memc_arb_base += 4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save I/O context */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	_dma_cache_wback_inv(0, ~0);</span>
<span class="p_add">+</span>
<span class="p_add">+	brcm_pm_do_s3(ctrl.aon_ctrl_base, current_cpu_data.dcache.linesz);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* CPU reconfiguration */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	bmips_cpu_setup();</span>
<span class="p_add">+	cpumask_clear(&amp;bmips_booted_mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore RTS (skip debug register) */</span>
<span class="p_add">+	memc_arb_base = ctrl.memcs[0].arb_base + 4;</span>
<span class="p_add">+	for (i = 0; i &lt; NUM_MEMC_CLIENTS; i++) {</span>
<span class="p_add">+		__raw_writel(s3_context.memc0_rts[i], memc_arb_base);</span>
<span class="p_add">+		memc_arb_base += 4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* restore CP0 context */</span>
<span class="p_add">+	brcm_pm_restore_cp0_context(&amp;s3_context);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_s2(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to pass 6 arguments to an assembly function. Lets avoid</span>
<span class="p_add">+	 * the stack and pass arguments in a explicit 4 byte array. The</span>
<span class="p_add">+	 * assembly code assumes all arguements are 4 bytes and arguments</span>
<span class="p_add">+	 * are ordered like so:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 0: AON_CTRl base register</span>
<span class="p_add">+	 * 1: DDR_PHY base register</span>
<span class="p_add">+	 * 2: TIMERS base resgister</span>
<span class="p_add">+	 * 3: I-Cache line size</span>
<span class="p_add">+	 * 4: Restart vector address</span>
<span class="p_add">+	 * 5: Restart vector size</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	u32 s2_params[6];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prepare s2 parameters */</span>
<span class="p_add">+	s2_params[0] = (u32)ctrl.aon_ctrl_base;</span>
<span class="p_add">+	s2_params[1] = (u32)ctrl.memcs[0].ddr_phy_base;</span>
<span class="p_add">+	s2_params[2] = (u32)ctrl.timers_base;</span>
<span class="p_add">+	s2_params[3] = (u32)current_cpu_data.icache.linesz;</span>
<span class="p_add">+	s2_params[4] = (u32)BMIPS_WARM_RESTART_VEC;</span>
<span class="p_add">+	s2_params[5] = (u32)(bmips_smp_int_vec_end -</span>
<span class="p_add">+		bmips_smp_int_vec);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Drop to standby */</span>
<span class="p_add">+	brcm_pm_do_s2(s2_params);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_standby(bool deep_standby)</span>
<span class="p_add">+{</span>
<span class="p_add">+	brcmstb_pm_handshake();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send IRQs to BMIPS_WARM_RESTART_VEC */</span>
<span class="p_add">+	clear_c0_cause(CAUSEF_IV);</span>
<span class="p_add">+	irq_disable_hazard();</span>
<span class="p_add">+	set_c0_status(ST0_BEV);</span>
<span class="p_add">+	irq_disable_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (deep_standby)</span>
<span class="p_add">+		brcmstb_pm_s3();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		brcmstb_pm_s2();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Send IRQs to normal runtime vectors */</span>
<span class="p_add">+	clear_c0_status(ST0_BEV);</span>
<span class="p_add">+	irq_disable_hazard();</span>
<span class="p_add">+	set_c0_cause(CAUSEF_IV);</span>
<span class="p_add">+	irq_disable_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		ret = brcmstb_pm_standby(false);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		ret = brcmstb_pm_standby(true);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops brcmstb_pm_ops = {</span>
<span class="p_add">+	.enter		= brcmstb_pm_enter,</span>
<span class="p_add">+	.valid		= brcmstb_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id aon_ctrl_dt_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;brcm,brcmstb-aon-ctrl&quot; },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id ddr_phy_dt_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;brcm,brcmstb-ddr-phy&quot; },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id arb_dt_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;brcm,brcmstb-memc-arb&quot; },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id timers_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;brcm,brcmstb-timers&quot; },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __iomem *brcmstb_ioremap_node(struct device_node *dn,</span>
<span class="p_add">+						 int index)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return of_io_request_and_map(dn, index, dn-&gt;full_name);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __iomem *brcmstb_ioremap_match(const struct of_device_id *matches,</span>
<span class="p_add">+					   int index, const void **ofdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn;</span>
<span class="p_add">+	const struct of_device_id *match;</span>
<span class="p_add">+</span>
<span class="p_add">+	dn = of_find_matching_node_and_match(NULL, matches, &amp;match);</span>
<span class="p_add">+	if (!dn)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ofdata)</span>
<span class="p_add">+		*ofdata = match-&gt;data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return brcmstb_ioremap_node(dn, index);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brcmstb_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* AON ctrl registers */</span>
<span class="p_add">+	base = brcmstb_ioremap_match(aon_ctrl_dt_ids, 0, NULL);</span>
<span class="p_add">+	if (IS_ERR(base)) {</span>
<span class="p_add">+		pr_err(&quot;error mapping AON_CTRL\n&quot;);</span>
<span class="p_add">+		goto aon_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ctrl.aon_ctrl_base = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* AON SRAM registers */</span>
<span class="p_add">+	base = brcmstb_ioremap_match(aon_ctrl_dt_ids, 1, NULL);</span>
<span class="p_add">+	if (IS_ERR(base)) {</span>
<span class="p_add">+		pr_err(&quot;error mapping AON_SRAM\n&quot;);</span>
<span class="p_add">+		goto sram_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ctrl.aon_sram_base = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctrl.num_memc = 0;</span>
<span class="p_add">+	/* Map MEMC DDR PHY registers */</span>
<span class="p_add">+	for_each_matching_node(dn, ddr_phy_dt_ids) {</span>
<span class="p_add">+		i = ctrl.num_memc;</span>
<span class="p_add">+		if (i &gt;= MAX_NUM_MEMC) {</span>
<span class="p_add">+			pr_warn(&quot;Too many MEMCs (max %d)\n&quot;, MAX_NUM_MEMC);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		base = brcmstb_ioremap_node(dn, 0);</span>
<span class="p_add">+		if (IS_ERR(base))</span>
<span class="p_add">+			goto ddr_err;</span>
<span class="p_add">+</span>
<span class="p_add">+		ctrl.memcs[i].ddr_phy_base = base;</span>
<span class="p_add">+		ctrl.num_memc++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* MEMC ARB registers */</span>
<span class="p_add">+	base = brcmstb_ioremap_match(arb_dt_ids, 0, NULL);</span>
<span class="p_add">+	if (IS_ERR(base)) {</span>
<span class="p_add">+		pr_err(&quot;error mapping MEMC ARB\n&quot;);</span>
<span class="p_add">+		goto ddr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ctrl.memcs[0].arb_base = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Timer registers */</span>
<span class="p_add">+	base = brcmstb_ioremap_match(timers_ids, 0, NULL);</span>
<span class="p_add">+	if (IS_ERR(base)) {</span>
<span class="p_add">+		pr_err(&quot;error mapping timers\n&quot;);</span>
<span class="p_add">+		goto tmr_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ctrl.timers_base = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* s3 cold boot aka s5 */</span>
<span class="p_add">+	pm_power_off = brcmstb_pm_s5;</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;brcmstb_pm_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+tmr_err:</span>
<span class="p_add">+	iounmap(ctrl.memcs[0].arb_base);</span>
<span class="p_add">+ddr_err:</span>
<span class="p_add">+	for (i = 0; i &lt; ctrl.num_memc; i++)</span>
<span class="p_add">+		iounmap(ctrl.memcs[i].ddr_phy_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	iounmap(ctrl.aon_sram_base);</span>
<span class="p_add">+sram_err:</span>
<span class="p_add">+	iounmap(ctrl.aon_ctrl_base);</span>
<span class="p_add">+aon_err:</span>
<span class="p_add">+	return PTR_ERR(base);</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(brcmstb_pm_init);</span>
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/pm/pm.h b/drivers/soc/bcm/brcmstb/pm/pm.h</span>
<span class="p_header">index 142519fdb8f8..b7d35ac70e60 100644</span>
<span class="p_header">--- a/drivers/soc/bcm/brcmstb/pm/pm.h</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/pm/pm.h</span>
<span class="p_chunk">@@ -70,9 +70,20 @@</span> <span class="p_context"></span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_add">+#ifndef CONFIG_MIPS</span>
 extern const unsigned long brcmstb_pm_do_s2_sz;
 extern asmlinkage int brcmstb_pm_do_s2(void __iomem *aon_ctrl_base,
 		void __iomem *ddr_phy_pll_status);
<span class="p_del">-#endif</span>
<span class="p_add">+#else</span>
<span class="p_add">+/* s2 asm */</span>
<span class="p_add">+extern asmlinkage int brcm_pm_do_s2(u32 *s2_params);</span>
<span class="p_add">+</span>
<span class="p_add">+/* s3 asm */</span>
<span class="p_add">+extern asmlinkage int brcm_pm_do_s3(void __iomem *aon_ctrl_base,</span>
<span class="p_add">+		int dcache_linesz);</span>
<span class="p_add">+extern int s3_reentry;</span>
<span class="p_add">+#endif /* CONFIG_MIPS */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif </span>
 
 #endif /* __BRCMSTB_PM_H__ */
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/pm/s2-mips.S b/drivers/soc/bcm/brcmstb/pm/s2-mips.S</span>
new file mode 100644
<span class="p_header">index 000000000000..27a14bc46043</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/pm/s2-mips.S</span>
<span class="p_chunk">@@ -0,0 +1,200 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2016 Broadcom Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/regdef.h&gt;</span>
<span class="p_add">+#include &lt;asm/mipsregs.h&gt;</span>
<span class="p_add">+#include &lt;asm/stackframe.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;pm.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.set	noreorder</span>
<span class="p_add">+	.align	5</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * a0: u32 params array</span>
<span class="p_add">+ */</span>
<span class="p_add">+LEAF(brcm_pm_do_s2)</span>
<span class="p_add">+</span>
<span class="p_add">+	subu	sp, 64</span>
<span class="p_add">+	sw	ra, 0(sp)</span>
<span class="p_add">+	sw	s0, 4(sp)</span>
<span class="p_add">+	sw	s1, 8(sp)</span>
<span class="p_add">+	sw	s2, 12(sp)</span>
<span class="p_add">+	sw	s3, 16(sp)</span>
<span class="p_add">+	sw	s4, 20(sp)</span>
<span class="p_add">+	sw	s5, 24(sp)</span>
<span class="p_add">+	sw	s6, 28(sp)</span>
<span class="p_add">+	sw	s7, 32(sp)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Dereference the params array</span>
<span class="p_add">+	 * s0: AON_CTRL base register</span>
<span class="p_add">+	 * s1: DDR_PHY base register</span>
<span class="p_add">+	 * s2: TIMERS base register</span>
<span class="p_add">+	 * s3: I-Cache line size</span>
<span class="p_add">+	 * s4: Restart vector address</span>
<span class="p_add">+	 * s5: Restart vector size</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	move	t0, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	lw	s0, 0(t0)</span>
<span class="p_add">+	lw	s1, 4(t0)</span>
<span class="p_add">+	lw	s2, 8(t0)</span>
<span class="p_add">+	lw	s3, 12(t0)</span>
<span class="p_add">+	lw	s4, 16(t0)</span>
<span class="p_add">+	lw	s5, 20(t0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Lock this asm section into the I-cache */</span>
<span class="p_add">+	addiu	t1, s3, -1</span>
<span class="p_add">+	not	t1</span>
<span class="p_add">+</span>
<span class="p_add">+	la	t0, brcm_pm_do_s2</span>
<span class="p_add">+	and	t0, t1</span>
<span class="p_add">+</span>
<span class="p_add">+	la	t2, asm_end</span>
<span class="p_add">+	and	t2, t1</span>
<span class="p_add">+</span>
<span class="p_add">+1:	cache	0x1c, 0(t0)</span>
<span class="p_add">+	bne	t0, t2, 1b</span>
<span class="p_add">+	addu	t0, s3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Lock the interrupt vector into the I-cache */</span>
<span class="p_add">+	move	t0, zero</span>
<span class="p_add">+</span>
<span class="p_add">+2:	move	t1, s4</span>
<span class="p_add">+	cache 	0x1c, 0(t1)</span>
<span class="p_add">+	addu	t1, s3</span>
<span class="p_add">+	addu	t0, s3</span>
<span class="p_add">+	ble	t0, s5, 2b</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	sync</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Power down request */</span>
<span class="p_add">+	li	t0, PM_S2_COMMAND</span>
<span class="p_add">+	sw	zero, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+	lw	zero, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+	sw	t0, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+	lw	t0, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable CP0 interrupt 2 and wait for interrupt */</span>
<span class="p_add">+	mfc0	t0, CP0_STATUS</span>
<span class="p_add">+	/* Save cp0 sr for restoring later */</span>
<span class="p_add">+	move	s6, t0</span>
<span class="p_add">+</span>
<span class="p_add">+	li	t1, ~(ST0_IM | ST0_IE)</span>
<span class="p_add">+	and	t0, t1</span>
<span class="p_add">+	ori	t0, STATUSF_IP2</span>
<span class="p_add">+	mtc0	t0, CP0_STATUS</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	ori	t0, ST0_IE</span>
<span class="p_add">+	mtc0	t0, CP0_STATUS</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for interrupt */</span>
<span class="p_add">+	wait</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for memc0 */</span>
<span class="p_add">+1:	lw	t0, DDR40_PHY_CONTROL_REGS_0_PLL_STATUS(s1)</span>
<span class="p_add">+	andi	t0, 1</span>
<span class="p_add">+	beqz	t0, 1b</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 1ms delay needed for stable recovery */</span>
<span class="p_add">+	/* Use TIMER1 to count 1 ms */</span>
<span class="p_add">+	li	t0, RESET_TIMER</span>
<span class="p_add">+	sw	t0, TIMER_TIMER1_CTRL(s2)</span>
<span class="p_add">+	lw	t0, TIMER_TIMER1_CTRL(s2)</span>
<span class="p_add">+</span>
<span class="p_add">+	li	t0, START_TIMER</span>
<span class="p_add">+	sw	t0, TIMER_TIMER1_CTRL(s2)</span>
<span class="p_add">+	lw	t0, TIMER_TIMER1_CTRL(s2)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prepare delay */</span>
<span class="p_add">+	li	t0, TIMER_MASK</span>
<span class="p_add">+	lw	t1, TIMER_TIMER1_STAT(s2)</span>
<span class="p_add">+	and	t1, t0</span>
<span class="p_add">+	/* 1ms delay */</span>
<span class="p_add">+	addi	t1, 27000</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the timer value to exceed t1 */</span>
<span class="p_add">+1:	lw	t0, TIMER_TIMER1_STAT(s2)</span>
<span class="p_add">+	sgtu	t2, t1, t0</span>
<span class="p_add">+	bnez	t2, 1b</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Power back up */</span>
<span class="p_add">+	li	t1, 1</span>
<span class="p_add">+	sw	t1, AON_CTRL_HOST_MISC_CMDS(s0)</span>
<span class="p_add">+	lw	t1, AON_CTRL_HOST_MISC_CMDS(s0)</span>
<span class="p_add">+</span>
<span class="p_add">+	sw	zero, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+	lw	zero, AON_CTRL_PM_CTRL(s0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unlock I-cache */</span>
<span class="p_add">+	addiu	t1, s3, -1</span>
<span class="p_add">+	not	t1</span>
<span class="p_add">+</span>
<span class="p_add">+	la	t0, brcm_pm_do_s2</span>
<span class="p_add">+	and 	t0, t1</span>
<span class="p_add">+</span>
<span class="p_add">+	la	t2, asm_end</span>
<span class="p_add">+	and	t2, t1</span>
<span class="p_add">+</span>
<span class="p_add">+1:	cache	0x00, 0(t0)</span>
<span class="p_add">+	bne	t0, t2, 1b</span>
<span class="p_add">+	addu	t0, s3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unlock interrupt vector */</span>
<span class="p_add">+	move	t0, zero</span>
<span class="p_add">+</span>
<span class="p_add">+2:	move	t1, s4</span>
<span class="p_add">+	cache 	0x00, 0(t1)</span>
<span class="p_add">+	addu	t1, s3</span>
<span class="p_add">+	addu	t0, s3</span>
<span class="p_add">+	ble	t0, s5, 2b</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore cp0 sr */</span>
<span class="p_add">+	sync</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	mtc0	s6, CP0_STATUS</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set return value to success */</span>
<span class="p_add">+	li	v0, 0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Return to caller */</span>
<span class="p_add">+	lw	s7, 32(sp)</span>
<span class="p_add">+	lw	s6, 28(sp)</span>
<span class="p_add">+	lw	s5, 24(sp)</span>
<span class="p_add">+	lw	s4, 20(sp)</span>
<span class="p_add">+	lw	s3, 16(sp)</span>
<span class="p_add">+	lw	s2, 12(sp)</span>
<span class="p_add">+	lw	s1, 8(sp)</span>
<span class="p_add">+	lw	s0, 4(sp)</span>
<span class="p_add">+	lw	ra, 0(sp)</span>
<span class="p_add">+	addiu	sp, 64</span>
<span class="p_add">+</span>
<span class="p_add">+	jr ra</span>
<span class="p_add">+	nop</span>
<span class="p_add">+END(brcm_pm_do_s2)</span>
<span class="p_add">+</span>
<span class="p_add">+	.globl asm_end</span>
<span class="p_add">+asm_end:</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/drivers/soc/bcm/brcmstb/pm/s3-mips.S b/drivers/soc/bcm/brcmstb/pm/s3-mips.S</span>
new file mode 100644
<span class="p_header">index 000000000000..1242308a8868</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/soc/bcm/brcmstb/pm/s3-mips.S</span>
<span class="p_chunk">@@ -0,0 +1,146 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2016 Broadcom Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/regdef.h&gt;</span>
<span class="p_add">+#include &lt;asm/mipsregs.h&gt;</span>
<span class="p_add">+#include &lt;asm/bmips.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;pm.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.set		noreorder</span>
<span class="p_add">+	.align		5</span>
<span class="p_add">+	.global		s3_reentry</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * a0: AON_CTRL base register</span>
<span class="p_add">+ * a1: D-Cache line size</span>
<span class="p_add">+ */</span>
<span class="p_add">+LEAF(brcm_pm_do_s3)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the address of s3_context */</span>
<span class="p_add">+	la	t0, gp_regs</span>
<span class="p_add">+	sw	ra, 0(t0)</span>
<span class="p_add">+	sw	s0, 4(t0)</span>
<span class="p_add">+	sw	s1, 8(t0)</span>
<span class="p_add">+	sw	s2, 12(t0)</span>
<span class="p_add">+	sw	s3, 16(t0)</span>
<span class="p_add">+	sw	s4, 20(t0)</span>
<span class="p_add">+	sw	s5, 24(t0)</span>
<span class="p_add">+	sw	s6, 28(t0)</span>
<span class="p_add">+	sw	s7, 32(t0)</span>
<span class="p_add">+	sw	gp, 36(t0)</span>
<span class="p_add">+	sw	sp, 40(t0)</span>
<span class="p_add">+	sw	fp, 44(t0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save CP0 Status */</span>
<span class="p_add">+	mfc0	t1, CP0_STATUS</span>
<span class="p_add">+	sw	t1, 48(t0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Write-back gp registers - cache will be gone */</span>
<span class="p_add">+	addiu	t1, a1, -1</span>
<span class="p_add">+	not	t1</span>
<span class="p_add">+	and	t0, t1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush at least 64 bytes */</span>
<span class="p_add">+	addiu	t2, t0, 64</span>
<span class="p_add">+	and	t2, t1</span>
<span class="p_add">+</span>
<span class="p_add">+1:	cache	0x17, 0(t0)</span>
<span class="p_add">+	bne	t0, t2, 1b</span>
<span class="p_add">+	addu	t0, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Drop to deep standby */</span>
<span class="p_add">+	li	t1, PM_WARM_CONFIG</span>
<span class="p_add">+	sw	zero, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+	lw	zero, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+	sw	t1, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+	lw	t1, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+</span>
<span class="p_add">+	li	t1, (PM_WARM_CONFIG | PM_PWR_DOWN)</span>
<span class="p_add">+	sw	t1, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+	lw	t1, AON_CTRL_PM_CTRL(a0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable CP0 interrupt 2 and wait for interrupt */</span>
<span class="p_add">+	mfc0	t0, CP0_STATUS</span>
<span class="p_add">+</span>
<span class="p_add">+	li	t1, ~(ST0_IM | ST0_IE)</span>
<span class="p_add">+	and	t0, t1</span>
<span class="p_add">+	ori	t0, STATUSF_IP2</span>
<span class="p_add">+	mtc0	t0, CP0_STATUS</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	ori	t0, ST0_IE</span>
<span class="p_add">+	mtc0	t0, CP0_STATUS</span>
<span class="p_add">+</span>
<span class="p_add">+        /* Wait for interrupt */</span>
<span class="p_add">+        wait</span>
<span class="p_add">+        nop</span>
<span class="p_add">+</span>
<span class="p_add">+s3_reentry:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear call/return stack */</span>
<span class="p_add">+	li	t0, (0x06 &lt;&lt; 16)</span>
<span class="p_add">+	mtc0	t0, $22, 2</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear jump target buffer */</span>
<span class="p_add">+	li	t0, (0x04 &lt;&lt; 16)</span>
<span class="p_add">+	mtc0	t0, $22, 2</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+	ssnop</span>
<span class="p_add">+</span>
<span class="p_add">+	sync</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Setup mmu defaults */</span>
<span class="p_add">+	mtc0	zero, CP0_WIRED</span>
<span class="p_add">+	mtc0	zero, CP0_ENTRYHI</span>
<span class="p_add">+	li	k0, PM_DEFAULT_MASK</span>
<span class="p_add">+	mtc0	k0, CP0_PAGEMASK</span>
<span class="p_add">+</span>
<span class="p_add">+	li	sp, BMIPS_WARM_RESTART_VEC</span>
<span class="p_add">+	la	k0, plat_wired_tlb_setup</span>
<span class="p_add">+	jalr	k0</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore general purpose registers */</span>
<span class="p_add">+	la	t0, gp_regs</span>
<span class="p_add">+	lw	fp, 44(t0)</span>
<span class="p_add">+	lw	sp, 40(t0)</span>
<span class="p_add">+	lw	gp, 36(t0)</span>
<span class="p_add">+	lw	s7, 32(t0)</span>
<span class="p_add">+	lw	s6, 28(t0)</span>
<span class="p_add">+	lw	s5, 24(t0)</span>
<span class="p_add">+	lw	s4, 20(t0)</span>
<span class="p_add">+	lw	s3, 16(t0)</span>
<span class="p_add">+	lw	s2, 12(t0)</span>
<span class="p_add">+	lw	s1, 8(t0)</span>
<span class="p_add">+	lw	s0, 4(t0)</span>
<span class="p_add">+	lw	ra, 0(t0)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore CP0 status */</span>
<span class="p_add">+	lw	t1, 48(t0)</span>
<span class="p_add">+	mtc0	t1, CP0_STATUS</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Return to caller */</span>
<span class="p_add">+	li	v0, 0</span>
<span class="p_add">+	jr      ra</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+END(brcm_pm_do_s3)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



